<!DOCTYPE html>
<html lang="zh-CN">
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>Chapter 16 string 类和标准模板库 - Uniqueland</title>
  
    <meta name="keywords" content="Program,C++">
  

  
    <meta name="description" content="C++ tutorial">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://www.helloimg.com/images/2022/03/27/ReozOM.png">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

</head>

<body>
  

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div id="l_body">
    <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Uniqueland</p>
    
    
      <p class="subtitle">--XR's personal Blog</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/categories/"
              
              
              id="categories">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>分类</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

    <div id='safearea'>
      <div class='body-wrapper' id="pjax-container">
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
    <div class='headimg-div'>
      <a class='headimg-a'>
        <img class='headimg' src='https://s2.loli.net/2025/04/26/9F74KMasiN1YwQW.png'/>
      </a>
    </div>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Chapter 16 string 类和标准模板库
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="https://raw.githubusercontent.com/srcx404/pic/refs/heads/main/xr.jpg">
    <p>XR</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2025年4月30日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Chapter 16 string 类和标准模板库" data-path="/2025/04/30/Cpp_tutorial_Chapter_16/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <h2 id="16-1-string-类"><a href="#16-1-string-类" class="headerlink" title="16.1 string 类"></a>16.1 string 类</h2><p>我们在第 4 章已经初步接触了 C++ 标准库中的 <code>string</code> 类。与 C 语言风格的、以空字符结尾的字符数组（C-风格字符串）相比，<code>string</code> 类提供了更强大、更安全、更方便的字符串处理方式。</p>
<p><strong>优点:</strong></p>
<ul>
<li>  <strong>自动内存管理:</strong> <code>string</code> 对象会自动管理存储字符串所需的内存，无需手动分配和释放，避免了许多 C 风格字符串常见的内存错误（如缓冲区溢出）。</li>
<li>  <strong>丰富的操作:</strong> 提供了大量的成员函数用于字符串的查找、拼接、比较、修改、插入、删除等操作。</li>
<li>  <strong>安全性:</strong> 成员函数通常会进行边界检查（如 <code>at()</code> 方法），或者提供明确定义的操作行为。</li>
<li>  <strong>与 STL 兼容:</strong> 可以方便地与标准模板库 (STL) 中的算法和容器一起使用。</li>
</ul>
<p><code>string</code> 类实际上是模板类 <code>basic_string&lt;char&gt;</code> 的一个 <code>typedef</code>（类型别名）。它定义在 <code>&lt;string&gt;</code> 头文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 必须包含此头文件</span></span></span><br></pre></td></tr></table></figure>

<h3 id="16-1-1-构造字符串"><a href="#16-1-1-构造字符串" class="headerlink" title="16.1.1 构造字符串"></a>16.1.1 构造字符串</h3><p>创建 <code>string</code> 对象有多种方式（构造函数）：</p>
<ol>
<li><strong>默认构造函数:</strong> 创建一个空字符串。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s1; <span class="comment">// s1 是一个空字符串 &quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>*<em>从 C 风格字符串 (const char</em>)**: 用一个 C 风格字符串来初始化 <code>string</code> 对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 从字符串字面值初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_str = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span><span class="params">(c_str)</span></span>; <span class="comment">// 从 const char* 变量初始化</span></span><br></pre></td></tr></table></figure></li>
<li><strong>复制构造函数:</strong> 用另一个 <code>string</code> 对象来初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s4 = s2; <span class="comment">// s4 的内容是 &quot;Hello&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s5</span><span class="params">(s4)</span></span>;  <span class="comment">// s5 的内容也是 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>从 C 风格字符串的部分内容:</strong> 用 C 风格字符串的前 <code>n</code> 个字符初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* long_cstr = <span class="string">&quot;Programming&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s6</span><span class="params">(long_cstr, <span class="number">7</span>)</span></span>; <span class="comment">// 用 &quot;Programming&quot; 的前 7 个字符初始化 s6，内容是 &quot;Program&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>从 <code>string</code> 对象的部分内容 (子字符串):</strong> 用另一个 <code>string</code> 对象的子字符串初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s7 = <span class="string">&quot;Example String&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s8</span><span class="params">(s7, <span class="number">8</span>, <span class="number">6</span>)</span></span>; <span class="comment">// 从 s7 的索引 8 开始，取 6 个字符初始化 s8，内容是 &quot;String&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>填充构造函数:</strong> 用 <code>n</code> 个重复的字符 <code>c</code> 初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s9</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">// s9 的内容是 &quot;----------&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>从迭代器范围:</strong> 用一对指向字符序列的迭代器（例如来自另一个容器或 C 风格数组）来初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char_array[] = &#123;<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s10</span><span class="params">(char_array, char_array + <span class="keyword">sizeof</span>(char_array))</span></span>; <span class="comment">// s10 内容是 &quot;Test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; char_vec = &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s11</span><span class="params">(char_vec.begin(), char_vec.end())</span></span>; <span class="comment">// s11 内容是 &quot;Data&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>使用初始化列表 (C++11):</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s12 = &#123;<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;; <span class="comment">// s12 内容是 &quot;Init&quot;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s13 &#123;<span class="string">&quot;List&quot;</span>&#125;; <span class="comment">// s13 内容是 &quot;List&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* phrase = <span class="string">&quot;World Wide Web&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s5</span><span class="params">(phrase, <span class="number">5</span>)</span></span>; <span class="comment">// &quot;World&quot;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s6</span><span class="params">(phrase + <span class="number">6</span>, <span class="number">4</span>)</span></span>; <span class="comment">// &quot;Wide&quot; (从索引6开始取4个)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s7</span><span class="params">(s2, <span class="number">1</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 从 s2[1] 开始取 3 个: &quot;ell&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s5: &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s6: &quot;</span> &lt;&lt; s6 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s7: &quot;</span> &lt;&lt; s7 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-1-2-string-类输入"><a href="#16-1-2-string-类输入" class="headerlink" title="16.1.2 string 类输入"></a>16.1.2 string 类输入</h3><p>从输入流（如 <code>cin</code>）读取数据到 <code>string</code> 对象主要有两种方式：</p>
<ol>
<li><p><strong>使用 <code>operator&gt;&gt;</code>:</strong></p>
<ul>
<li><p>  行为类似于读取 C 风格字符串或基本数据类型。</p>
</li>
<li><p>  它会<strong>跳过开头</strong>的所有空白字符（空格、制表符、换行符）。</p>
</li>
<li><p>  然后读取非空白字符，直到遇到下一个空白字符为止。</p>
</li>
<li><p>读取的内容（不包括结尾的空白字符）存储在 <code>string</code> 对象中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt; // 用于字符串流示例</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word1, word2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter two words separated by space: &quot;</span>; <span class="comment">// 例如输入 &quot;Hello World&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word1 &gt;&gt; word2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 1: &quot;</span> &lt;&lt; word1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 2: &quot;</span> &lt;&lt; word2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;World&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示跳过空白</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="string">&quot;   LeadingSpaces Word&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> temp;</span><br><span class="line">    ss &gt;&gt; temp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After skipping spaces: &quot;</span> &lt;&lt; temp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;LeadingSpaces&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>使用 <code>getline()</code> 函数:</strong></p>
<ul>
<li><p>  用于读取<strong>一整行</strong>输入，直到遇到指定的分隔符（默认为换行符 <code>\n</code>）。</p>
</li>
<li><p>  <strong>不会</strong>跳过开头的空白字符。</p>
</li>
<li><p>  读取的内容（<strong>不包括</strong>分隔符本身）存储在 <code>string</code> 对象中。</p>
</li>
<li><p>  分隔符会从输入流中被读取并丢弃。</p>
</li>
<li><p>*函数原型:**</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt; // getline 定义在这里</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">getline</span><span class="params">(<span class="built_in">std</span>::istream&amp; is, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim = <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line1, line2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a line of text: &quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：如果之前有 &gt;&gt; 操作，可能需要清除缓冲区中的换行符</span></span><br><span class="line">    <span class="comment">// std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\n&#x27;);</span></span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line1); <span class="comment">// 读取整行，直到按 Enter</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter another line: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 1: &quot;</span> &lt;&lt; line1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 2: &quot;</span> &lt;&lt; line2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><strong>混合使用 <code>&gt;&gt;</code> 和 <code>getline()</code> 的问题:</strong><br>当 <code>&gt;&gt;</code> 读取输入后，它会将导致读取结束的空白字符（通常是换行符）留在输入缓冲区中。如果紧接着调用 <code>getline()</code>，它会立即读到这个换行符，认为读取到空行，然后结束。</p>
<p><strong>解决方法:</strong> 在 <code>&gt;&gt;</code> 之后、<code>getline()</code> 之前，清除缓冲区中残留的换行符。常用的方法是使用 <code>cin.ignore()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // for numeric_limits</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除 cin &gt;&gt; age 后留下的换行符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-1-3-使用字符串"><a href="#16-1-3-使用字符串" class="headerlink" title="16.1.3 使用字符串"></a>16.1.3 使用字符串</h3><p><code>string</code> 类提供了丰富的成员函数来操作字符串：</p>
<ul>
<li><p><strong>赋值:</strong> 使用 <code>operator=</code>。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Initial&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s2;</span><br><span class="line">s2 = s1; <span class="comment">// s2 内容变为 &quot;Initial&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;New Value&quot;</span>; <span class="comment">// s2 内容变为 &quot;New Value&quot;</span></span><br><span class="line">s2 = <span class="string">&#x27;C&#x27;</span>; <span class="comment">// s2 内容变为 &quot;C&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>拼接/连接:</strong> 使用 <code>operator+</code> 或 <code>operator+=</code>。可以与 <code>string</code> 对象、C 风格字符串或单个字符拼接。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> first = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> last = <span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> full = first + <span class="string">&quot; &quot;</span> + last; <span class="comment">// full 是 &quot;John Doe&quot;</span></span><br><span class="line">first += <span class="string">&quot;athan&quot;</span>; <span class="comment">// first 变为 &quot;Johnathan&quot;</span></span><br><span class="line">full += <span class="string">&#x27;!&#x27;</span>; <span class="comment">// full 变为 &quot;John Doe!&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>比较:</strong> 使用关系运算符 (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)。比较是按字典顺序进行的。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str1 &lt; str2) &#123; <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; comes before &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str1 == <span class="string">&quot;Apple&quot;</span>) &#123; <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 is Apple&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取长度/大小:</strong> 使用 <code>length()</code> 或 <code>size()</code> 方法（两者等价）。返回字符串中的字符数。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; msg.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; msg.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>访问字符:</strong></p>
<ul>
<li><p>  <code>operator[]</code>: 提供快速访问，但<strong>不进行边界检查</strong>。访问越界是未定义行为。</p>
</li>
<li><p><code>at()</code>: 提供边界检查的访问。如果索引越界，会抛出 <code>std::out_of_range</code> 异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> word = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> first_char = word[<span class="number">0</span>]; <span class="comment">// &#x27;W&#x27;</span></span><br><span class="line"><span class="keyword">char</span> last_char = word[word.length() - <span class="number">1</span>]; <span class="comment">// &#x27;d&#x27;</span></span><br><span class="line"><span class="comment">// word[5] = &#x27;!&#x27;; // 危险！越界访问，未定义行为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.at(<span class="number">1</span>); <span class="comment">// &#x27;o&#x27;</span></span><br><span class="line">    word.at(<span class="number">0</span>) = <span class="string">&#x27;J&#x27;</span>; <span class="comment">// word 变为 &quot;Jorld&quot;</span></span><br><span class="line">    c = word.at(<span class="number">10</span>); <span class="comment">// 越界，将抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::out_of_range&amp; oor) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Out of Range error: &quot;</span> &lt;&lt; oor.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>查找:</strong> <code>string</code> 提供了多种查找方法：</p>
<ul>
<li><p>  <code>find(substr, pos=0)</code>: 从索引 <code>pos</code> 开始查找子串 <code>substr</code> 第一次出现的位置。</p>
</li>
<li><p>  <code>rfind(substr, pos=npos)</code>: 从索引 <code>pos</code> 向前查找子串 <code>substr</code> 最后一次出现的位置。</p>
</li>
<li><p>  <code>find_first_of(chars, pos=0)</code>: 从 <code>pos</code> 开始查找 <code>chars</code> 中<strong>任何一个</strong>字符第一次出现的位置。</p>
</li>
<li><p>  <code>find_last_of(chars, pos=npos)</code>: 从 <code>pos</code> 向前查找 <code>chars</code> 中<strong>任何一个</strong>字符最后一次出现的位置。</p>
</li>
<li><p>  <code>find_first_not_of(chars, pos=0)</code>: 从 <code>pos</code> 开始查找<strong>第一个不</strong>在 <code>chars</code> 中的字符的位置。</p>
</li>
<li><p>  <code>find_last_not_of(chars, pos=npos)</code>: 从 <code>pos</code> 向前查找<strong>最后一个不</strong>在 <code>chars</code> 中的字符的位置。</p>
</li>
<li><p>所有查找方法如果找到，返回匹配的起始索引；如果找不到，返回 <code>std::string::npos</code> (一个静态成员常量，通常是 <code>-1</code> 或最大无符号整数值)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> search_str = <span class="string">&quot;the&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> vowels = <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos = text.find(search_str); <span class="comment">// 查找 &quot;the&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; search_str &lt;&lt; <span class="string">&quot;&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 35</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; search_str &lt;&lt; <span class="string">&quot;&#x27; not found.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = text.find(<span class="string">&quot;The&quot;</span>); <span class="comment">// 查找 &quot;The&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;The&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = text.find_first_of(vowels); <span class="comment">// 查找第一个元音</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First vowel &#x27;&quot;</span> &lt;&lt; text[pos] &lt;&lt; <span class="string">&quot;&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;e&#x27; at 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = text.find_first_not_of(<span class="string">&quot; &quot;</span>); <span class="comment">// 查找第一个非空格</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First non-space &#x27;&quot;</span> &lt;&lt; text[pos] &lt;&lt; <span class="string">&quot;&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;T&#x27; at 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>修改:</strong></p>
<ul>
<li><p>  <code>insert(pos, str)</code>: 在索引 <code>pos</code> 处插入字符串 <code>str</code>。</p>
</li>
<li><p>  <code>erase(pos, count)</code>: 从索引 <code>pos</code> 开始删除 <code>count</code> 个字符。</p>
</li>
<li><p>  <code>replace(pos, count, str)</code>: 将从 <code>pos</code> 开始的 <code>count</code> 个字符替换为 <code>str</code>。</p>
</li>
<li><p>  <code>append(str)</code>: 在末尾追加 <code>str</code> (等价于 <code>+=</code>)。</p>
</li>
<li><p><code>assign(str)</code>: 替换整个字符串内容为 <code>str</code> (等价于 <code>=</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> phrase = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">phrase.insert(<span class="number">6</span>, <span class="string">&quot;beautiful &quot;</span>); <span class="comment">// &quot;Hello beautiful world&quot;</span></span><br><span class="line">phrase.erase(<span class="number">0</span>, <span class="number">6</span>); <span class="comment">// &quot;beautiful world&quot;</span></span><br><span class="line">phrase.replace(<span class="number">0</span>, <span class="number">9</span>, <span class="string">&quot;Wonderful&quot;</span>); <span class="comment">// &quot;Wonderful world&quot;</span></span><br><span class="line">phrase.append(<span class="string">&quot;!&quot;</span>); <span class="comment">// &quot;Wonderful world!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>获取 C 风格字符串:</strong></p>
<ul>
<li><p>  <code>c_str()</code>: 返回一个指向以空字符结尾的 <code>const char*</code> 数组的指针，内容与 <code>string</code> 对象相同。返回的指针指向的内存在 <code>string</code> 对象被修改或销毁后可能失效。</p>
</li>
<li><p><code>data()</code>: 类似 <code>c_str()</code>，但在 C++11 之前不保证以空字符结尾（C++11 起保证结尾有 <code>\0</code>）。</p>
<p>当你需要将 <code>string</code> 对象传递给需要 <code>const char*</code> 的 C 风格函数时，这两个方法非常有用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // for printf</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cpp_str = <span class="string">&quot;C++ String&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using c_str(): %s\n&quot;</span>, cpp_str.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="16-1-4-string-还提供了哪些功能"><a href="#16-1-4-string-还提供了哪些功能" class="headerlink" title="16.1.4 string 还提供了哪些功能"></a>16.1.4 string 还提供了哪些功能</h3><p><code>std::string</code> 类还有许多其他功能，包括：</p>
<ul>
<li><strong>容量管理:</strong><ul>
<li>  <code>capacity()</code>: 返回当前分配的内存容量（可能大于 <code>size()</code>）。</li>
<li>  <code>reserve(n)</code>: 请求至少为 <code>n</code> 的容量。如果 <code>n</code> 大于当前容量，可能重新分配内存。</li>
<li>  <code>shrink_to_fit()</code> (C++11): 请求减少容量以匹配当前大小。</li>
<li>  <code>clear()</code>: 清空字符串内容（<code>size()</code> 变为 0）。</li>
<li>  <code>empty()</code>: 检查字符串是否为空（<code>size() == 0</code>）。</li>
</ul>
</li>
<li>  <strong>迭代器:</strong> 提供 <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code> 等迭代器，允许像遍历容器一样遍历字符串中的字符，可以配合 STL 算法使用。</li>
<li>  <strong>子字符串:</strong> <code>substr(pos, count)</code>: 返回一个新的 <code>string</code> 对象，包含从 <code>pos</code> 开始的 <code>count</code> 个字符的子串。</li>
<li>  <strong>比较:</strong> <code>compare()</code> 方法提供比关系运算符更详细的比较选项。</li>
<li>  <strong>数值转换 (C++11):</strong> <code>&lt;string&gt;</code> 头文件还包含 <code>stoi</code>, <code>stol</code>, <code>stod</code>, <code>to_string</code> 等函数，用于字符串和数值类型之间的转换。</li>
</ul>
<p>要了解 <code>string</code> 类的所有功能，建议查阅 C++ 参考文档（如 cppreference.com）。</p>
<h3 id="16-1-5-字符串种类"><a href="#16-1-5-字符串种类" class="headerlink" title="16.1.5 字符串种类"></a>16.1.5 字符串种类</h3><p><code>std::string</code> 是 <code>std::basic_string&lt;char&gt;</code> 的别名，用于处理基于 <code>char</code> 的窄字符字符串（通常是 ASCII 或 UTF-8 编码）。</p>
<p>C++ 标准库还提供了处理其他字符类型的 <code>basic_string</code> 特化版本：</p>
<ul>
<li>  <strong><code>std::wstring</code>:</strong> <code>basic_string&lt;wchar_t&gt;</code> 的别名，用于处理宽字符 (<code>wchar_t</code>) 字符串，常用于 Windows API 中的 Unicode。</li>
<li>  <strong><code>std::u16string</code> (C++11):</strong> <code>basic_string&lt;char16_t&gt;</code> 的别名，用于处理 UTF-16 编码的字符串。</li>
<li>  <strong><code>std::u32string</code> (C++11):</strong> <code>basic_string&lt;char32_t&gt;</code> 的别名，用于处理 UTF-32 编码的字符串。</li>
</ul>
<p>这些宽字符串类具有与 <code>std::string</code> 类似的操作接口，但处理的字符类型不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> wide_str = <span class="string">L&quot;Wide String Example&quot;</span>; <span class="comment">// L 前缀表示宽字符字面量</span></span><br><span class="line">    <span class="built_in">std</span>::u16string utf16_str = <span class="string">u&quot;UTF-16 String&quot;</span>; <span class="comment">// u 前缀</span></span><br><span class="line">    <span class="built_in">std</span>::u32string utf32_str = <span class="string">U&quot;UTF-32 String&quot;</span>; <span class="comment">// U 前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::wcout 用于输出宽字符串</span></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;Wide: &quot;</span> &lt;&lt; wide_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 UTF-16/32 字符串通常需要特定的库或转换</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; utf16_str &lt;&lt; std::endl; // 可能无法正确显示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择哪种字符串类型取决于你的应用场景和需要处理的字符集。在现代 C++ 中，如果需要处理 Unicode，通常推荐使用 UTF-8 编码的 <code>std::string</code>，并配合相应的 Unicode 处理库。</p>
<h2 id="16-2-智能指针模板类"><a href="#16-2-智能指针模板类" class="headerlink" title="16.2 智能指针模板类"></a>16.2 智能指针模板类</h2><p>在 C++ 中，使用 <code>new</code> 分配动态内存后，必须使用 <code>delete</code> 来释放它，否则会导致**内存泄漏 (Memory Leak)**。手动管理内存容易出错，尤其是在复杂的代码路径、异常处理或资源共享的情况下。忘记 <code>delete</code>、重复 <code>delete</code> 或使用悬挂指针（指向已释放内存的指针）都是常见的错误来源。</p>
<p>为了解决这个问题，C++ 标准库（在 <code>&lt;memory&gt;</code> 头文件中）提供了一系列<strong>智能指针 (Smart Pointers)</strong> 模板类。智能指针是行为类似于指针的类对象，但它们能<strong>自动管理</strong>所指向的动态分配的内存。当智能指针本身离开作用域（例如函数结束、对象销毁）或被重新赋值时，它会自动调用 <code>delete</code>（或自定义的删除器）来释放其管理的内存。这极大地简化了动态内存管理，提高了程序的健壮性，并有助于实现 RAII（资源获取即初始化）。</p>
<p>C++11 引入了三种主要的智能指针类型：</p>
<ol>
<li> <strong><code>std::unique_ptr&lt;T&gt;</code>:</strong> 实现<strong>独占所有权 (Exclusive Ownership)</strong> 或严格所有权模型。在任何时候，只有一个 <code>unique_ptr</code> 可以指向给定的资源。当 <code>unique_ptr</code> 被销毁或重置时，资源被释放。它<strong>不能被复制</strong>，但可以被**移动 (Moved)**。</li>
<li> <strong><code>std::shared_ptr&lt;T&gt;</code>:</strong> 实现<strong>共享所有权 (Shared Ownership)</strong> 模型。允许多个 <code>shared_ptr</code> 指向同一个资源。内部维护一个**引用计数 (Reference Count)**，记录有多少个 <code>shared_ptr</code> 指向该资源。只有当最后一个指向资源的 <code>shared_ptr</code> 被销毁或重置时，资源才会被释放。</li>
<li> <strong><code>std::weak_ptr&lt;T&gt;</code>:</strong> 是一种<strong>非拥有 (Non-owning)</strong> 的智能指针，它指向由 <code>shared_ptr</code> 管理的资源，但<strong>不增加</strong>引用计数。它主要用于解决 <code>shared_ptr</code> 可能遇到的<strong>循环引用 (Cyclic Reference)</strong> 问题，并用于观察资源是否存在。</li>
</ol>
<h3 id="16-2-1-使用智能指针"><a href="#16-2-1-使用智能指针" class="headerlink" title="16.2.1 使用智能指针"></a>16.2.1 使用智能指针</h3><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a><code>std::unique_ptr</code></h4><p><code>unique_ptr</code> 是轻量级的智能指针，开销几乎与原始指针相同。它是管理动态分配资源的<strong>首选</strong>方式，除非你需要共享所有权。</p>
<p><strong>创建:</strong></p>
<ul>
<li><strong>推荐方式 (C++14 及以后):</strong> 使用 <code>std::make_unique&lt;T&gt;(args...)</code>。它更安全（避免了某些异常安全问题）且可能更高效。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指向 int 的 unique_ptr</span></span><br><span class="line"><span class="keyword">auto</span> uptr_int = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 指向值为 10 的 int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指向 string 的 unique_ptr</span></span><br><span class="line"><span class="keyword">auto</span> uptr_str = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 指向 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>C++11 方式:</strong> 直接使用 <code>new</code>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uptr_int_cpp11</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uptr_str_cpp11</span><span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;World&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>所有权转移 (移动):</strong> <code>unique_ptr</code> 不能复制，但可以通过 <code>std::move()</code> 转移所有权。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr1 = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 错误！不能复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr3 = <span class="built_in">std</span>::move(ptr1); <span class="comment">// OK！所有权从 ptr1 转移到 ptr3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 ptr1 变为 nullptr</span></span><br><span class="line"><span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptr1 is now null.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ptr3) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptr3 holds the value: &quot;</span> &lt;&lt; *ptr3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数可以返回 <code>unique_ptr</code>，这会自动触发移动语义，将所有权转移给调用者。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">create_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Created String&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; owned_ptr = create_string(); <span class="comment">// 所有权转移给 owned_ptr</span></span><br></pre></td></tr></table></figure>

<p><strong>使用:</strong> 像普通指针一样使用 <code>*</code> 和 <code>-&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uptr = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *uptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; uptr-&gt;length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><strong>其他操作:</strong></p>
<ul>
<li>  <code>get()</code>: 返回指向被管理对象的原始指针（但不转移所有权）。小心使用，避免手动 <code>delete</code> 这个指针。</li>
<li>  <code>reset(p)</code>: 销毁当前管理的对象（如果有），并接管指针 <code>p</code> 指向的新对象。</li>
<li>  <code>reset()</code>: 销毁当前管理的对象，并将 <code>unique_ptr</code> 置为空。</li>
<li>  <code>release()</code>: 放弃对指针的所有权，返回原始指针，并将 <code>unique_ptr</code> 置为空。调用者<strong>负责</strong>手动 <code>delete</code> 返回的指针。</li>
</ul>
<p><strong>用于数组:</strong> <code>unique_ptr</code> 可以管理动态分配的数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指向包含 5 个 int 的数组的 unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; uptr_arr = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>[]&gt;(<span class="number">5</span>); <span class="comment">// C++14</span></span><br><span class="line"><span class="comment">// 或者 std::unique_ptr&lt;int[]&gt; uptr_arr_cpp11(new int[5]); // C++11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 operator[] 访问元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    uptr_arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; uptr_arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 离开作用域时，会自动调用 delete[]</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义删除器:</strong> 可以为 <code>unique_ptr</code> 指定自定义的删除器，用于执行非标准的资源释放操作（如关闭文件句柄）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // for FILE, fopen, fclose</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileCloser</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE* fp)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">            <span class="built_in">std</span>::fclose(fp);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File closed.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用自定义删除器 FileCloser</span></span><br><span class="line">    std::unique_ptr&lt;FILE, FileCloser&gt; file_ptr(std::fopen(&quot;test.txt&quot;, &quot;w&quot;));</span><br><span class="line">    <span class="keyword">if</span> (file_ptr) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">fprintf</span>(file_ptr.get(), <span class="string">&quot;Hello from unique_ptr with custom deleter.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 file_ptr 离开作用域时，FileCloser::operator() 会被调用以关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a><code>std::shared_ptr</code></h4><p><code>shared_ptr</code> 用于资源可能被多个指针共享所有权的场景。</p>
<p><strong>创建:</strong></p>
<ul>
<li><strong>推荐方式:</strong> 使用 <code>std::make_shared&lt;T&gt;(args...)</code>。它通常更高效，因为它可以在一次内存分配中同时为对象和引用计数控制块分配内存。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sptr_int = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr_str = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Shared&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 <code>new</code>:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sptr_int_new</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">60</span>))</span></span>;</span><br><span class="line"><span class="comment">// 注意：不要将同一个原始指针用于初始化多个 shared_ptr，应通过复制已有的 shared_ptr 来共享</span></span><br><span class="line"><span class="comment">// int* raw_ptr = new int(70);</span></span><br><span class="line"><span class="comment">// std::shared_ptr&lt;int&gt; sp1(raw_ptr);</span></span><br><span class="line"><span class="comment">// std::shared_ptr&lt;int&gt; sp2(raw_ptr); // 错误！会导致重复 delete</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>共享所有权和引用计数:</strong> 复制 <code>shared_ptr</code> 会增加引用计数，销毁或重置 <code>shared_ptr</code> 会减少引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1; <span class="comment">// 复制，引用计数增加</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// sp1 不再指向对象，引用计数减少</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp1 reset. sp2 use_count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 sp2 离开作用域时，引用计数变为 0，对象被删除</span></span><br></pre></td></tr></table></figure>

<p><strong>使用:</strong> 与 <code>unique_ptr</code> 类似，使用 <code>*</code> 和 <code>-&gt;</code>。</p>
<p><strong>其他操作:</strong></p>
<ul>
<li>  <code>get()</code>: 返回原始指针。</li>
<li>  <code>reset()</code> / <code>reset(p)</code>: 减少当前对象的引用计数（如果为 0 则删除），并可选地接管新指针 <code>p</code>。</li>
<li>  <code>use_count()</code>: 返回当前的引用计数值（主要用于调试）。</li>
</ul>
<p><strong>循环引用问题:</strong> 如果两个对象通过 <code>shared_ptr</code> 相互引用，它们的引用计数永远不会变为 0，即使没有外部指针指向它们，也会导致内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeA</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB&gt; ptrB;</span><br><span class="line">    ~NodeA() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeA destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeA&gt; ptrA;</span><br><span class="line">    ~NodeB() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeB destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeA&gt; pa = <span class="built_in">std</span>::make_shared&lt;NodeA&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB&gt; pb = <span class="built_in">std</span>::make_shared&lt;NodeB&gt;();</span><br><span class="line"></span><br><span class="line">    pa-&gt;ptrB = pb; <span class="comment">// pa 指向 pb</span></span><br><span class="line">    pb-&gt;ptrA = pa; <span class="comment">// pb 指向 pa (形成循环引用)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pa use_count: &quot;</span> &lt;&lt; pa.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2 (pa 和 pb-&gt;ptrA)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pb use_count: &quot;</span> &lt;&lt; pb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2 (pb 和 pa-&gt;ptrB)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 pa 和 pb 离开作用域时，引用计数都只减到 1，析构函数不会被调用，内存泄漏！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决方案:</strong> 使用 <code>std::weak_ptr</code> 打破循环。</p>
<h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a><code>std::weak_ptr</code></h4><p><code>weak_ptr</code> 用于“观察”由 <code>shared_ptr</code> 管理的对象，但它本身不拥有对象，也不影响对象的生命周期（不改变引用计数）。</p>
<p><strong>创建:</strong> 只能从 <code>shared_ptr</code> 或另一个 <code>weak_ptr</code> 创建。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp; <span class="comment">// wp 观察 sp 管理的对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp use_count: &quot;</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;wp use_count: &quot;</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1 (weak_ptr::use_count 返回的是 shared_ptr 的计数)</span></span><br></pre></td></tr></table></figure>

<p><strong>使用:</strong></p>
<ul>
<li>  <code>expired()</code>: 检查所观察的对象是否已被销毁（对应的 <code>shared_ptr</code> 引用计数是否为 0）。</li>
<li><code>lock()</code>: <strong>关键方法</strong>。尝试获取一个指向所观察对象的 <code>shared_ptr</code>。<ul>
<li>  如果对象仍然存在，返回一个有效的 <code>shared_ptr</code>（并增加引用计数）。</li>
<li>如果对象已被销毁，返回一个空的 <code>shared_ptr</code>。<br>这是访问 <code>weak_ptr</code> 指向对象的<strong>安全</strong>方式。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.expired()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object observed by wp is expired.\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; locked_sp = wp.lock(); <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">    <span class="keyword">if</span> (locked_sp) &#123; <span class="comment">// 检查是否成功获取</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object still alive. Value: &quot;</span> &lt;&lt; *locked_sp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;use_count after lock: &quot;</span> &lt;&lt; locked_sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 引用计数增加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object expired between check and lock.\n&quot;</span>; <span class="comment">// 可能发生 (多线程)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// locked_sp 离开作用域，引用计数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp.reset(); <span class="comment">// 原始 shared_ptr 释放对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original shared_ptr reset.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; locked_sp_after_reset = wp.lock();</span><br><span class="line"><span class="keyword">if</span> (!locked_sp_after_reset) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;weak_ptr lock() failed after object destruction.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决循环引用:</strong> 在循环引用的场景中，让其中一个指针（或两个）成为 <code>weak_ptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB_weak</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeA_weak</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB_weak&gt; ptrB; <span class="comment">// NodeA 强引用 NodeB</span></span><br><span class="line">    ~NodeA_weak() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeA_weak destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB_weak</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;NodeA_weak&gt; ptrA; <span class="comment">// NodeB 弱引用 NodeA (打破循环)</span></span><br><span class="line">    ~NodeB_weak() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeB_weak destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeA_weak&gt; pa = <span class="built_in">std</span>::make_shared&lt;NodeA_weak&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB_weak&gt; pb = <span class="built_in">std</span>::make_shared&lt;NodeB_weak&gt;();</span><br><span class="line"></span><br><span class="line">    pa-&gt;ptrB = pb;</span><br><span class="line">    pb-&gt;ptrA = pa; <span class="comment">// pa 赋值给 weak_ptr，不增加 pa 的引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pa use_count: &quot;</span> &lt;&lt; pa.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pb use_count: &quot;</span> &lt;&lt; pb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 pa 和 pb 离开作用域时，引用计数都能降为 0，对象被正确销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 输出 NodeA_weak destroyed 和 NodeB_weak destroyed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-2-2-有关智能指针的注意事项"><a href="#16-2-2-有关智能指针的注意事项" class="headerlink" title="16.2.2 有关智能指针的注意事项"></a>16.2.2 有关智能指针的注意事项</h3><ul>
<li>  <strong>不要混用智能指针和原始指针:</strong> 避免将 <code>get()</code> 返回的原始指针传递给另一个智能指针或手动 <code>delete</code>。</li>
<li>  <strong>优先使用 <code>make_unique</code> 和 <code>make_shared</code>:</strong> 更安全、可能更高效。</li>
<li>  <strong><code>shared_ptr</code> 的性能开销:</strong> 引用计数是原子操作，在多线程环境下有一定开销。<code>shared_ptr</code> 对象本身也比 <code>unique_ptr</code> 或原始指针大（需要存储指向控制块的指针）。</li>
<li>  <strong><code>this</code> 指针问题:</strong> 不要在类的构造函数中将 <code>this</code> 指针直接传递给 <code>shared_ptr</code> 的构造函数。如果需要让类自身能够创建指向自己的 <code>shared_ptr</code>，应继承自 <code>std::enable_shared_from_this&lt;YourClass&gt;</code> 并使用 <code>shared_from_this()</code> 方法。</li>
</ul>
<h3 id="16-2-3-unique-ptr-为何优于-auto-ptr"><a href="#16-2-3-unique-ptr-为何优于-auto-ptr" class="headerlink" title="16.2.3 unique_ptr 为何优于 auto_ptr"></a>16.2.3 <code>unique_ptr</code> 为何优于 <code>auto_ptr</code></h3><p>C++98 引入了 <code>std::auto_ptr</code>，它是 <code>unique_ptr</code> 的前身，也试图实现独占所有权。但 <code>auto_ptr</code> 有一个严重的设计缺陷：它的<strong>复制构造函数</strong>和<strong>赋值运算符</strong>会<strong>转移所有权</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ap1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2 = ap1; <span class="comment">// ！！所有权从 ap1 转移到 ap2，ap1 变为无效！！</span></span><br></pre></td></tr></table></figure>
<p>这种隐式的、破坏性的复制行为非常危险，尤其是在将 <code>auto_ptr</code> 放入容器或作为函数参数按值传递时，会导致意外的所有权丢失。</p>
<p>C++11 引入了移动语义，使得 <code>unique_ptr</code> 可以通过显式的 <code>std::move</code> 来安全地转移所有权，同时<strong>禁止</strong>了复制操作，从而避免了 <code>auto_ptr</code> 的问题。</p>
<p><strong><code>auto_ptr</code> 已在 C++11 中被废弃，并在 C++17 中被移除。应始终使用 <code>unique_ptr</code> 替代它。</strong></p>
<h3 id="16-2-4-选择智能指针"><a href="#16-2-4-选择智能指针" class="headerlink" title="16.2.4 选择智能指针"></a>16.2.4 选择智能指针</h3><ul>
<li>  <strong>默认选择 <code>std::unique_ptr</code>:</strong> 当你需要管理一个动态分配的资源，并且不需要共享其所有权时，<code>unique_ptr</code> 是最简单、最高效的选择。</li>
<li>  <strong>使用 <code>std::shared_ptr</code>:</strong> 当资源需要被多个所有者共享生命周期时（例如，在数据结构中多个部分可能引用同一个节点，或者回调函数需要确保某个对象在其执行期间存活）。</li>
<li>  <strong>使用 <code>std::weak_ptr</code>:</strong> 当你需要观察一个由 <code>shared_ptr</code> 管理的对象，但不想影响其生命周期时，特别是为了打破 <code>shared_ptr</code> 之间的循环引用。</li>
</ul>
<p>智能指针是现代 C++ 中管理动态资源的核心工具，极大地提高了代码的安全性和简洁性。</p>
<h2 id="16-3-标准模板库（STL）"><a href="#16-3-标准模板库（STL）" class="headerlink" title="16.3 标准模板库（STL）"></a>16.3 标准模板库（STL）</h2><p><strong>标准模板库 (Standard Template Library, STL)</strong> 是 C++ 标准库的一个重要组成部分，它提供了一套通用的模板类和函数，用于实现常用的数据结构和算法。STL 的核心思想是**泛型编程 (Generic Programming)**，即代码独立于特定的数据类型，可以应用于多种类型。</p>
<p>STL 主要由三个核心组件构成：</p>
<ol>
<li> <strong>容器 (Containers):</strong> 用于存储数据的模板类。例如 <code>vector</code>, <code>list</code>, <code>deque</code>, <code>set</code>, <code>map</code> 等。它们封装了数据结构，并提供了管理元素的方法。</li>
<li> <strong>算法 (Algorithms):</strong> 用于处理容器中数据的模板函数。例如 <code>sort</code>, <code>find</code>, <code>copy</code>, <code>for_each</code> 等。这些算法通常通过迭代器作用于容器中的元素范围。</li>
<li> <strong>迭代器 (Iterators):</strong> 行为类似于指针的对象，用于遍历容器中的元素，并作为连接容器和算法的桥梁。</li>
</ol>
<p>本节将重点介绍 STL 中最常用的容器之一：<code>vector</code>，以及适用于多种容器的通用操作。</p>
<h3 id="16-3-1-模板类-vector"><a href="#16-3-1-模板类-vector" class="headerlink" title="16.3.1 模板类 vector"></a>16.3.1 模板类 vector</h3><p><code>std::vector</code> 是一个模板类，定义在 <code>&lt;vector&gt;</code> 头文件中。它实现了一个**动态数组 (Dynamic Array)**，可以根据需要自动增长或收缩大小。</p>
<p><strong>特点:</strong></p>
<ul>
<li>  <strong>动态大小:</strong> 可以在运行时添加或删除元素，<code>vector</code> 会自动管理内存。</li>
<li>  <strong>随机访问:</strong> 支持通过索引 (<code>[]</code> 或 <code>at()</code>) 快速访问任何位置的元素，时间复杂度为 O(1)。</li>
<li>  <strong>连续存储:</strong> 元素在内存中是连续存储的，这使得通过指针或迭代器进行遍历非常高效，并能与需要连续内存的 C 风格 API 兼容。</li>
<li>  <strong>尾部插入/删除高效:</strong> 在末尾添加 (<code>push_back</code>) 或删除 (<code>pop_back</code>) 元素通常很高效（摊销时间复杂度为 O(1)）。</li>
<li>  <strong>中间插入/删除低效:</strong> 在中间或开头插入或删除元素可能需要移动后续所有元素，时间复杂度为 O(N)。</li>
</ul>
<p><strong>基本用法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 包含 vector 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 vector 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores; <span class="comment">// 创建一个空的 int 向量</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">lengths</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建包含 10 个 double 元素的向量，默认初始化为 0.0</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">names</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;Unknown&quot;</span>)</span></span>; <span class="comment">// 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用初始化列表 (C++11)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到末尾</span></span><br><span class="line">    scores.push_back(<span class="number">95</span>);</span><br><span class="line">    scores.push_back(<span class="number">88</span>);</span><br><span class="line">    scores.push_back(<span class="number">76</span>); <span class="comment">// scores 现在是 &#123;95, 88, 76&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First score: &quot;</span> &lt;&lt; scores[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 []</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second score: &quot;</span> &lt;&lt; scores.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 at() (带边界检查)</span></span><br><span class="line">    scores[<span class="number">0</span>] = <span class="number">98</span>; <span class="comment">// 修改元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of scores: &quot;</span> &lt;&lt; scores.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of names: &quot;</span> &lt;&lt; names.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-3-2-可对容器执行的操作"><a href="#16-3-2-可对容器执行的操作" class="headerlink" title="16.3.2 可对容器执行的操作"></a>16.3.2 可对容器执行的操作</h3><p>许多 STL 容器（包括 <code>vector</code>）都支持一组常见的操作：</p>
<ul>
<li>  <strong><code>size()</code>:</strong> 返回容器中元素的数量。类型通常是 <code>size_type</code> (一种无符号整型)。</li>
<li>  <strong><code>empty()</code>:</strong> 检查容器是否为空。如果 <code>size() == 0</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>  <strong><code>operator[]</code>:</strong> 通过索引访问元素（仅适用于 <code>vector</code>, <code>deque</code>, <code>string</code>, <code>array</code>）。<strong>不进行边界检查</strong>。</li>
<li>  <strong><code>at()</code>:</strong> 通过索引访问元素（仅适用于 <code>vector</code>, <code>deque</code>, <code>string</code>, <code>array</code>）。<strong>进行边界检查</strong>，越界时抛出 <code>std::out_of_range</code> 异常。</li>
<li>  <strong><code>front()</code>:</strong> 返回对第一个元素的引用。容器不能为空。</li>
<li>  <strong><code>back()</code>:</strong> 返回对最后一个元素的引用。容器不能为空。</li>
<li>  <strong><code>push_back(value)</code>:</strong> (仅适用于 <code>vector</code>, <code>deque</code>, <code>list</code>, <code>string</code>) 在容器末尾添加一个值为 <code>value</code> 的元素。</li>
<li>  <strong><code>pop_back()</code>:</strong> (仅适用于 <code>vector</code>, <code>deque</code>, <code>list</code>, <code>string</code>) 删除容器末尾的元素。容器不能为空。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // for out_of_range</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Front: &quot;</span> &lt;&lt; data.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back: &quot;</span> &lt;&lt; data.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 3</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element at index 1: &quot;</span> &lt;&lt; data[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data.push_back(<span class="number">4</span>); <span class="comment">// data: &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After push_back(4), back is: &quot;</span> &lt;&lt; data.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    data.pop_back(); <span class="comment">// data: &#123;1, 2, 3&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After pop_back(), back is: &quot;</span> &lt;&lt; data.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        data.at(<span class="number">1</span>) = <span class="number">20</span>; <span class="comment">// 修改第二个元素</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element at index 1 (using at): &quot;</span> &lt;&lt; data.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line">        <span class="keyword">int</span> val = data.at(<span class="number">5</span>); <span class="comment">// 访问越界，将抛出异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::out_of_range&amp; oor) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; oor.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-3-3-对容器可执行的其他操作"><a href="#16-3-3-对容器可执行的其他操作" class="headerlink" title="16.3.3 对容器可执行的其他操作"></a>16.3.3 对容器可执行的其他操作</h3><p>除了基本操作，STL 容器还提供了其他一些有用的方法，其中许多涉及到**迭代器 (Iterators)**。迭代器是泛化的指针，用于指定容器中的位置或范围。</p>
<ul>
<li><p><strong>迭代器获取:</strong></p>
<ul>
<li>  <code>begin()</code>: 返回指向容器第一个元素的迭代器。</li>
<li>  <code>end()</code>: 返回指向容器<strong>末尾之后 (past-the-end)</strong> 位置的迭代器。它不指向任何有效元素，常用于标记范围的结束。</li>
<li>  <code>rbegin()</code>, <code>rend()</code>: 返回反向迭代器，用于从后向前遍历。</li>
<li>  <code>cbegin()</code>, <code>cend()</code>, <code>crbegin()</code>, <code>crend()</code> (C++11): 返回 <code>const</code> 迭代器，用于只读访问。</li>
</ul>
</li>
<li><p><strong>插入 (<code>insert()</code>):</strong> 在指定位置插入元素。需要一个指向插入位置的迭代器。</p>
<ul>
<li>  <code>insert(iterator pos, const value_type&amp; val)</code>: 在 <code>pos</code> 之前插入 <code>val</code>。返回指向新插入元素的迭代器。</li>
<li>  <code>insert(iterator pos, size_type n, const value_type&amp; val)</code>: 在 <code>pos</code> 之前插入 <code>n</code> 个 <code>val</code>。</li>
<li>  <code>insert(iterator pos, InputIt first, InputIt last)</code>: 在 <code>pos</code> 之前插入来自迭代器范围 <code>[first, last)</code> 的元素。</li>
</ul>
</li>
<li><p><strong>删除 (<code>erase()</code>):</strong> 删除指定位置或范围的元素。需要迭代器。</p>
<ul>
<li>  <code>erase(iterator pos)</code>: 删除 <code>pos</code> 指向的元素。返回指向被删除元素之后元素的迭代器。</li>
<li>  <code>erase(iterator first, iterator last)</code>: 删除范围 <code>[first, last)</code> 内的元素。返回指向最后一个被删除元素之后元素的迭代器。</li>
</ul>
</li>
<li><p>  <strong>清空 (<code>clear()</code>):</strong> 删除容器中的所有元素。<code>size()</code> 变为 0。</p>
</li>
<li><p>  <strong>交换 (<code>swap()</code>):</strong> <code>c1.swap(c2)</code> 或 <code>std::swap(c1, c2)</code>。高效地交换两个容器的内容。对于 <code>vector</code> 等容器，通常只交换内部指针和大小信息，速度很快。</p>
</li>
<li><p><strong>赋值 (<code>assign()</code>):</strong> 替换容器的全部内容。</p>
<ul>
<li>  <code>assign(size_type n, const value_type&amp; val)</code>: 赋值为 <code>n</code> 个 <code>val</code>。</li>
<li>  <code>assign(InputIt first, InputIt last)</code>: 赋值为来自迭代器范围 <code>[first, last)</code> 的元素。</li>
<li>  <code>assign(initializer_list&lt;value_type&gt; il)</code> (C++11): 从初始化列表赋值。</li>
</ul>
</li>
<li><p><strong>容量管理 (主要用于 <code>vector</code>, <code>string</code>, <code>deque</code>):</strong></p>
<ul>
<li>  <code>capacity()</code>: 返回当前已分配内存能够容纳的元素数量。</li>
<li>  <code>reserve(n)</code>: 请求将容量增加到至少 <code>n</code>。如果 <code>n</code> 大于当前容量，可能发生内存重新分配（这会导致所有迭代器、指针和引用失效）。</li>
<li>  <code>shrink_to_fit()</code> (C++11): 请求减少容量以匹配 <code>size()</code>。不保证一定减少。</li>
</ul>
</li>
</ul>
<p><strong>示例 (使用迭代器):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); <span class="comment">// 指向 10</span></span><br><span class="line">    it += <span class="number">2</span>; <span class="comment">// 移动迭代器，指向 30 (vector 支持随机访问迭代器)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    v.insert(it, <span class="number">25</span>); <span class="comment">// 在 30 之前插入 25。v: &#123;10, 20, 25, 30, 40, 50&#125;</span></span><br><span class="line">                      <span class="comment">// 注意：vector 插入可能导致迭代器失效，最好重新获取或使用返回的迭代器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insert: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    it = v.begin() + <span class="number">1</span>; <span class="comment">// 指向 20</span></span><br><span class="line">    v.erase(it); <span class="comment">// 删除 20。v: &#123;10, 25, 30, 40, 50&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After erase(it): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    it = v.begin() + <span class="number">1</span>; <span class="comment">// 指向 25</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it_end = v.begin() + <span class="number">3</span>; <span class="comment">// 指向 40 (范围是 [it, it_end) )</span></span><br><span class="line">    v.erase(it, it_end); <span class="comment">// 删除 25, 30。v: &#123;10, 40, 50&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After erase(range): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 assign</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;;</span><br><span class="line">    v.assign(l.begin(), l.end()); <span class="comment">// 用 list 的内容替换 vector 内容。v: &#123;100, 200, 300&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After assign: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.clear(); <span class="comment">// 清空 vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After clear, size is: &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-3-4-基于范围的-for-循环（C-11）"><a href="#16-3-4-基于范围的-for-循环（C-11）" class="headerlink" title="16.3.4 基于范围的 for 循环（C++11）"></a>16.3.4 基于范围的 for 循环（C++11）</h3><p>C++11 引入了一种更简洁、更不易出错的遍历容器（以及其他支持 <code>begin()</code> 和 <code>end()</code> 的序列）的方式：**基于范围的 for 循环 (Range-based for loop)**。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( declaration : range_expression ) &#123;</span><br><span class="line">    <span class="comment">// loop_statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>range_expression</code>: 一个可以提供 <code>begin()</code> 和 <code>end()</code> 迭代器的对象（如 STL 容器、数组、初始化列表，或定义了相应成员/非成员函数的自定义类型）。</li>
<li>  <code>declaration</code>: 声明一个变量，其类型应与 <code>range_expression</code> 中的元素类型兼容。每次循环迭代，<code>range_expression</code> 中的下一个元素会被<strong>复制</strong>或<strong>引用</strong>到这个变量中。</li>
</ul>
<p><strong>常用形式:</strong></p>
<ul>
<li><strong>只读访问 (推荐):</strong> 使用 <code>const auto&amp;</code> 避免不必要的复制，并确保不会意外修改元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; name : names) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Alice Bob Charlie</span></span><br></pre></td></tr></table></figure></li>
<li><strong>修改元素:</strong> 使用 <code>auto&amp;</code> 获取元素的引用，允许在循环中修改容器内容。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num *= <span class="number">2</span>; <span class="comment">// 将每个元素乘以 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nums 现在是 &#123;2, 4, 6, 8&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 2 4 6 8</span></span><br></pre></td></tr></table></figure></li>
<li><strong>复制元素:</strong> 使用 <code>auto</code> (或具体类型) 会将每个元素<strong>复制</strong>到循环变量中。对循环变量的修改<strong>不会</strong>影响容器中的原始元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> val : data) &#123;</span><br><span class="line">    val += <span class="number">1</span>; <span class="comment">// 只修改了副本 val，data 不变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出 6 11 16</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; d : data) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出 5 10 15 (原始数据未变)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>基于范围的 for 循环极大地简化了遍历容器的代码，使其更易读、更安全（避免了迭代器失效或索引越界等常见错误）。</p>
<h2 id="16-4-泛型编程"><a href="#16-4-泛型编程" class="headerlink" title="16.4 泛型编程"></a>16.4 泛型编程</h2><p><strong>泛型编程 (Generic Programming)</strong> 是一种编程范式，旨在编写独立于特定数据类型的代码。其目标是创建可重用的组件（如函数或类），这些组件可以处理多种不同的数据类型，而无需为每种类型重写代码。C++ 中的<strong>模板 (Templates)</strong> 是实现泛型编程的主要机制。</p>
<p>标准模板库 (STL) 就是泛型编程思想的集中体现。它通过模板定义了通用的容器、算法和迭代器，使得我们可以用同样的方式操作 <code>vector&lt;int&gt;</code>, <code>list&lt;string&gt;</code> 或其他自定义类型的数据。</p>
<h3 id="16-4-1-为何使用迭代器"><a href="#16-4-1-为何使用迭代器" class="headerlink" title="16.4.1 为何使用迭代器"></a>16.4.1 为何使用迭代器</h3><p>STL 的设计核心是将<strong>数据存储（容器）</strong>和<strong>数据操作（算法）</strong>分离开来。但是，算法如何才能访问不同容器（如 <code>vector</code>, <code>list</code>, <code>deque</code>）中的数据呢？不同的容器内部结构可能完全不同。</p>
<p><strong>迭代器 (Iterators)</strong> 就是解决这个问题的关键。迭代器是一种<strong>泛化的指针</strong>，它提供了一种统一的方式来<strong>遍历</strong>容器中的元素，并访问元素的值，而<strong>无需暴露容器的内部实现细节</strong>。</p>
<ul>
<li>  <strong>抽象访问:</strong> 算法不直接操作容器，而是通过迭代器来访问容器中的元素范围。</li>
<li>  <strong>统一接口:</strong> 所有容器都提供符合特定标准的迭代器接口（如 <code>begin()</code>, <code>end()</code>, <code>++</code> 前进, <code>*</code> 解引用）。</li>
<li>  <strong>灵活性:</strong> 算法只需要知道如何使用迭代器，就可以应用于任何提供兼容迭代器的容器。例如，<code>std::sort</code> 算法可以对 <code>vector</code>, <code>deque</code> 甚至普通数组（通过指针，指针也是一种迭代器）进行排序，只要它们提供所需的迭代器类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::find</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value_to_find = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> value_to_find_list = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> value_to_find_arr = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::find 算法，通过迭代器操作不同容器</span></span><br><span class="line">    <span class="keyword">auto</span> it_vec = <span class="built_in">std</span>::find(vec.begin(), vec.end(), value_to_find);</span><br><span class="line">    <span class="keyword">if</span> (it_vec != vec.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value_to_find &lt;&lt; <span class="string">&quot; in vector.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it_lst = <span class="built_in">std</span>::find(lst.begin(), lst.end(), value_to_find_list);</span><br><span class="line">    <span class="keyword">if</span> (it_lst != lst.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value_to_find_list &lt;&lt; <span class="string">&quot; in list.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通指针也可以作为迭代器使用</span></span><br><span class="line">    <span class="keyword">int</span>* it_arr = <span class="built_in">std</span>::find(arr, arr + <span class="number">5</span>, value_to_find_arr);</span><br><span class="line">    <span class="keyword">if</span> (it_arr != arr + <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value_to_find_arr &lt;&lt; <span class="string">&quot; in array.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，同一个 <code>std::find</code> 算法可以作用于 <code>vector</code>, <code>list</code> 和 C 风格数组，因为它操作的是迭代器（或指针）定义的范围，而不是容器本身。</p>
<h3 id="16-4-2-迭代器类型"><a href="#16-4-2-迭代器类型" class="headerlink" title="16.4.2 迭代器类型"></a>16.4.2 迭代器类型</h3><p>STL 定义了五种主要的迭代器类别，它们根据提供的操作能力进行区分：</p>
<ol>
<li><p><strong>输入迭代器 (Input Iterator):</strong></p>
<ul>
<li>  最基本的迭代器，只能<strong>向前</strong>移动 (<code>++</code>)。</li>
<li>  只能<strong>读取</strong> (<code>*</code>) 所指向的元素<strong>一次</strong>（读取后再次读取同一位置的结果未定义）。</li>
<li>  支持比较相等 (<code>==</code>, <code>!=</code>)。</li>
<li>  用于单遍扫描算法，例如 <code>std::find</code>, <code>std::accumulate</code>。<code>istream_iterator</code> 是一个例子。</li>
</ul>
</li>
<li><p><strong>输出迭代器 (Output Iterator):</strong></p>
<ul>
<li>  只能<strong>向前</strong>移动 (<code>++</code>)。</li>
<li>  只能<strong>写入</strong> (<code>*it = value</code>) 所指向的位置<strong>一次</strong>。</li>
<li>  不支持比较。</li>
<li>  用于将结果写入目标，例如 <code>std::copy</code> 的第三个参数。<code>ostream_iterator</code> 是一个例子。</li>
</ul>
</li>
<li><p><strong>前向迭代器 (Forward Iterator):</strong></p>
<ul>
<li>  结合了输入和输出迭代器的部分能力（但更强）。</li>
<li>  可以<strong>向前</strong>移动 (<code>++</code>)。</li>
<li>  可以<strong>多次读取</strong> (<code>*</code>) 同一个元素。</li>
<li>  可以<strong>多次写入</strong> (<code>*it = value</code>) 同一个元素（如果指向的是非 <code>const</code> 元素）。</li>
<li>  支持比较相等 (<code>==</code>, <code>!=</code>)。</li>
<li>  用于需要多次遍历同一范围的算法。<code>std::forward_list</code> 提供前向迭代器。<code>unordered</code> 容器也提供至少前向迭代器。</li>
</ul>
</li>
<li><p><strong>双向迭代器 (Bidirectional Iterator):</strong></p>
<ul>
<li>  继承了前向迭代器的所有能力。</li>
<li>  增加了<strong>向后</strong>移动 (<code>--</code>) 的能力。</li>
<li>  <code>std::list</code>, <code>std::set</code>, <code>std::map</code> 提供双向迭代器。</li>
</ul>
</li>
<li><p><strong>随机访问迭代器 (Random Access Iterator):</strong></p>
<ul>
<li>  最强大的迭代器，继承了双向迭代器的所有能力。</li>
<li>  支持<strong>算术运算</strong>：<code>it + n</code>, <code>it - n</code>, <code>it += n</code>, <code>it -= n</code> (快速移动到任意位置)。</li>
<li>  支持<strong>下标运算</strong>：<code>it[n]</code> (等价于 <code>*(it + n)</code>)。</li>
<li>  支持比较大小 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)。</li>
<li>  支持计算两个迭代器之间的距离 (<code>it2 - it1</code>)。</li>
<li>  <code>std::vector</code>, <code>std::deque</code>, <code>std::array</code>, <code>std::string</code> 提供随机访问迭代器。普通指针也是随机访问迭代器。</li>
</ul>
</li>
</ol>
<p>算法会根据其需要指定它所要求的最低迭代器类别。例如，<code>std::reverse</code> 需要双向迭代器，而 <code>std::sort</code> 需要随机访问迭代器（因为它需要高效地交换任意位置的元素）。</p>
<h3 id="16-4-3-迭代器层次结构"><a href="#16-4-3-迭代器层次结构" class="headerlink" title="16.4.3 迭代器层次结构"></a>16.4.3 迭代器层次结构</h3><p>这五种迭代器类型形成了一个层次结构，后面的类别拥有前面类别所有（或等价）的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input Iterator   Output Iterator</span><br><span class="line">      \             &#x2F;</span><br><span class="line">       Forward Iterator</span><br><span class="line">            |</span><br><span class="line">     Bidirectional Iterator</span><br><span class="line">            |</span><br><span class="line">     Random Access Iterator</span><br></pre></td></tr></table></figure>

<p>这意味着，如果一个算法需要前向迭代器，你可以传递给它前向、双向或随机访问迭代器。但如果算法需要随机访问迭代器，你就不能传递给它双向或前向迭代器。</p>
<h3 id="16-4-4-概念、改进和模型-Concepts-Refinements-and-Models"><a href="#16-4-4-概念、改进和模型-Concepts-Refinements-and-Models" class="headerlink" title="16.4.4 概念、改进和模型 (Concepts, Refinements, and Models)"></a>16.4.4 概念、改进和模型 (Concepts, Refinements, and Models)</h3><p>STL 的设计基于<strong>概念 (Concepts)</strong> 的思想。一个概念是一组对类型的要求（包括类型必须提供的操作、类型别名、语义保证等）。</p>
<ul>
<li>  <strong>概念 (Concept):</strong> 例如，“迭代器”是一个概念，“可排序 (Sortable)”是一个概念，“容器”是一个概念。</li>
<li>  <strong>改进 (Refinement):</strong> 一个概念可以是另一个概念的改进。例如，“前向迭代器”是“输入迭代器”的改进，因为它增加了可以多次读取的要求。“双向迭代器”是“前向迭代器”的改进，增加了向后移动的要求。</li>
<li>  <strong>模型 (Model):</strong> 一个具体的类型如果满足了某个概念的所有要求，就称为该概念的一个**模型 (Model)**。例如，<code>std::vector&lt;int&gt;::iterator</code> 是“随机访问迭代器”概念的一个模型。<code>int</code> 类型是“可相加 (Additive)”概念的一个模型。</li>
</ul>
<p>虽然 C++ 标准本身直到 C++20 才正式引入语言级别的 Concepts 支持，但 STL 从一开始就是基于这种思想设计的。算法的文档通常会说明它对模板参数（特别是迭代器类型）的概念要求。例如，<code>std::sort</code> 要求其迭代器参数是“随机访问迭代器 (RandomAccessIterator)”的模型，并且元素类型是“可小于比较 (LessThanComparable)”和“可移动构造/赋值 (MoveConstructible/MoveAssignable)”的模型。</p>
<p>理解概念有助于我们知道哪些算法可以用于哪些容器或数据类型。</p>
<h3 id="16-4-5-容器种类"><a href="#16-4-5-容器种类" class="headerlink" title="16.4.5 容器种类"></a>16.4.5 容器种类</h3><p>STL 提供了多种容器类型，可以大致分为几类：</p>
<ol>
<li><p><strong>顺序容器 (Sequence Containers):</strong> 元素按照线性顺序排列。</p>
<ul>
<li>  <code>std::vector</code>: 动态数组，连续内存，随机访问快，尾部插入/删除快，中间插入/删除慢。</li>
<li>  <code>std::deque</code> (Double-Ended Queue): 双端队列，非连续内存（分块），支持随机访问，<strong>头部和尾部</strong>插入/删除都快，中间插入/删除慢。</li>
<li>  <code>std::list</code>: 双向链表，非连续内存，不支持随机访问（访问元素需遍历），<strong>任何位置</strong>插入/删除都快 (O(1))。</li>
<li>  <code>std::forward_list</code> (C++11): 单向链表，比 <code>list</code> 开销更小，只支持向前遍历，任何位置插入/删除快。</li>
<li>  <code>std::array</code> (C++11): <strong>固定大小</strong>数组，是对 C 风格数组的封装，连续内存，支持随机访问，大小在编译时确定，不能动态改变。</li>
</ul>
</li>
<li><p><strong>关联容器 (Associative Containers):</strong> 元素根据<strong>键 (Key)</strong> 进行排序和存储，查找速度通常较快 (对数时间复杂度 O(log N))。</p>
<ul>
<li>  <code>std::set</code>: 存储<strong>唯一</strong>元素的集合，自动排序。</li>
<li>  <code>std::map</code>: 存储**键-值对 (Key-Value Pair)**，键是唯一的，根据键自动排序。</li>
<li>  <code>std::multiset</code>: 类似于 <code>set</code>，但允许存储<strong>重复</strong>元素。</li>
<li>  <code>std::multimap</code>: 类似于 <code>map</code>，但允许存储具有<strong>相同键</strong>的多个键-值对。</li>
</ul>
</li>
<li><p><strong>无序关联容器 (Unordered Associative Containers) (C++11):</strong> 元素根据键的<strong>哈希值 (Hash Value)</strong> 存储在桶 (Bucket) 中，不保证元素顺序。插入、删除和查找的平均时间复杂度通常为常数时间 O(1)，但最坏情况下可能退化为线性时间 O(N)。</p>
<ul>
<li>  <code>std::unordered_set</code>: 存储唯一元素的哈希集合。</li>
<li>  <code>std::unordered_map</code>: 存储键-值对的哈希映射，键唯一。</li>
<li>  <code>std::unordered_multiset</code>: 允许重复元素的哈希集合。</li>
<li>  <code>std::unordered_multimap</code>: 允许重复键的哈希映射。</li>
</ul>
</li>
<li><p><strong>容器适配器 (Container Adapters):</strong> 基于其他容器类型实现特定接口（通常限制了底层容器的功能）。</p>
<ul>
<li>  <code>std::stack</code>: 后进先出 (LIFO) 栈，默认基于 <code>deque</code> 实现。</li>
<li>  <code>std::queue</code>: 先进先出 (FIFO) 队列，默认基于 <code>deque</code> 实现。</li>
<li>  <code>std::priority_queue</code>: 优先级队列，最大（或最小）元素总是在顶部，默认基于 <code>vector</code> 实现。</li>
</ul>
</li>
</ol>
<p>选择哪种容器取决于具体需求，如是否需要排序、是否需要快速随机访问、插入/删除的频率和位置、是否允许重复元素等。</p>
<h3 id="16-4-6-关联容器"><a href="#16-4-6-关联容器" class="headerlink" title="16.4.6 关联容器"></a>16.4.6 关联容器</h3><p>关联容器的核心特点是元素根据<strong>键</strong>自动排序。它们通常使用某种形式的平衡二叉搜索树（如红黑树）来实现，保证了插入、删除和查找操作的时间复杂度为 O(log N)。</p>
<ul>
<li><p><strong><code>std::set&lt;Key&gt;</code>:</strong></p>
<ul>
<li><p>  存储类型为 <code>Key</code> 的<strong>唯一</strong>元素。</p>
</li>
<li><p>  元素自动按升序排序（默认使用 <code>operator&lt;</code>）。</p>
</li>
<li><p>主要用于快速检查元素是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; unique_words;</span><br><span class="line">    unique_words.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    unique_words.insert(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    unique_words.insert(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 重复插入会被忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Set contains: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word : unique_words) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: apple banana (已排序)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unique_words.count(<span class="string">&quot;banana&quot;</span>)) &#123; <span class="comment">// count() 返回 0 或 1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;banana is in the set.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = unique_words.find(<span class="string">&quot;cherry&quot;</span>); <span class="comment">// find() 返回迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (it == unique_words.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cherry is not in the set.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong><code>std::map&lt;Key, Value&gt;</code>:</strong></p>
<ul>
<li><p>  存储 <code>std::pair&lt;const Key, Value&gt;</code> 类型的键-值对。</p>
</li>
<li><p>  键 <code>Key</code> 必须是<strong>唯一</strong>的。</p>
</li>
<li><p>  元素根据键自动排序。</p>
</li>
<li><p>可以通过键快速查找对应的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_counts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入方式</span></span><br><span class="line">    word_counts.insert(&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    word_counts.insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>));</span><br><span class="line">    word_counts[<span class="string">&quot;cherry&quot;</span>] = <span class="number">2</span>; <span class="comment">// 使用 operator[] 插入或更新</span></span><br><span class="line"></span><br><span class="line">    word_counts[<span class="string">&quot;apple&quot;</span>] = <span class="number">4</span>; <span class="comment">// 更新 apple 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Map contains:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="built_in">pair</span> : word_counts) &#123;</span><br><span class="line">        <span class="comment">// pair.first 是 const Key, pair.second 是 Value</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">pair</span>.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">pair</span>.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 输出按键排序: apple: 4, banana: 5, cherry: 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count for banana: &quot;</span> &lt;&lt; word_counts[<span class="string">&quot;banana&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 [] 访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = word_counts.find(<span class="string">&quot;grape&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == word_counts.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;grape not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：如果使用 operator[] 访问不存在的键，会自动插入一个具有默认值的元素！</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count for grape (after []): &quot;</span> &lt;&lt; word_counts[<span class="string">&quot;grape&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0，并插入了 &#123;&quot;grape&quot;, 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>  <strong><code>std::multiset&lt;Key&gt;</code>:</strong> 允许存储重复的键，元素自动排序。</p>
</li>
<li><p>  <strong><code>std::multimap&lt;Key, Value&gt;</code>:</strong> 允许存储重复的键，键值对根据键自动排序。查找会返回一个范围（所有具有该键的元素）。</p>
</li>
</ul>
<h3 id="16-4-7-无序关联容器（C-11）"><a href="#16-4-7-无序关联容器（C-11）" class="headerlink" title="16.4.7 无序关联容器（C++11）"></a>16.4.7 无序关联容器（C++11）</h3><p>无序关联容器使用<strong>哈希表 (Hash Table)</strong> 实现，元素不保证任何特定顺序。它们通过计算键的<strong>哈希值</strong>来确定元素存储的位置（桶）。</p>
<ul>
<li><p>  <strong>优点:</strong> 插入、删除和查找的<strong>平均</strong>时间复杂度为 O(1)，通常比关联容器更快。</p>
</li>
<li><p><strong>缺点:</strong></p>
<ul>
<li>  <strong>最坏</strong>情况下的时间复杂度为 O(N)（当发生大量哈希冲突时）。</li>
<li>  元素是无序的。</li>
<li>  需要为键类型提供<strong>哈希函数</strong>和<strong>相等比较</strong>操作（标准库为基本类型和 <code>string</code> 等提供了默认实现）。</li>
<li>  哈希表操作可能会导致迭代器失效。</li>
</ul>
</li>
<li><p>  <strong><code>std::unordered_set&lt;Key&gt;</code>:</strong> 存储唯一键的哈希集合。</p>
</li>
<li><p>  <strong><code>std::unordered_map&lt;Key, Value&gt;</code>:</strong> 存储唯一键值对的哈希映射。</p>
</li>
<li><p>  <strong><code>std::unordered_multiset&lt;Key&gt;</code>:</strong> 允许重复键的哈希集合。</p>
</li>
<li><p>  <strong><code>std::unordered_multimap&lt;Key, Value&gt;</code>:</strong> 允许重复键的哈希映射。</p>
</li>
</ul>
<p><strong>示例 (<code>unordered_map</code>):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; phonebook;</span><br><span class="line"></span><br><span class="line">    phonebook[<span class="string">&quot;Alice&quot;</span>] = <span class="number">12345</span>;</span><br><span class="line">    phonebook[<span class="string">&quot;Bob&quot;</span>] = <span class="number">67890</span>;</span><br><span class="line">    phonebook.insert(&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">54321</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Phonebook (order not guaranteed):\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; entry : phonebook) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; entry.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; entry.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bob&#x27;s number: &quot;</span> &lt;&lt; phonebook[<span class="string">&quot;Bob&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phonebook.count(<span class="string">&quot;David&quot;</span>)) &#123; <span class="comment">// count() 返回 0 或 1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;David found.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;David not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无序容器在不需要元素排序且注重平均查找性能的场景下非常有用，例如实现缓存、快速查找表等。</p>
<h2 id="16-5-函数对象"><a href="#16-5-函数对象" class="headerlink" title="16.5 函数对象"></a>16.5 函数对象</h2><p>在 STL 中，许多算法（如 <code>sort</code>, <code>find_if</code>, <code>for_each</code>）不仅可以通过迭代器指定操作的范围，还可以接受一个额外的参数来<strong>定制其行为</strong>。这个参数通常是一个<strong>可调用 (Callable)</strong> 的实体，用于指定比较规则、判断条件或要执行的操作。</p>
<p>除了普通的函数指针，C++ 还提供了一种强大的可调用实体：**函数对象 (Function Object)**，也称为 **函数符 (Functor)**。</p>
<h3 id="16-5-1-函数符概念"><a href="#16-5-1-函数符概念" class="headerlink" title="16.5.1 函数符概念"></a>16.5.1 函数符概念</h3><p>函数对象（或函数符）是一个<strong>重载了函数调用运算符 <code>operator()</code></strong> 的类的对象。这意味着你可以像调用函数一样使用这个对象。</p>
<p><strong>基本结构:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunctor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载 operator()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 可以是 const 成员函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Functor called with value: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyFunctor f; <span class="comment">// 创建函数对象</span></span><br><span class="line">    f(<span class="number">10</span>);       <span class="comment">// 调用对象，就像调用函数一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以临时创建并调用</span></span><br><span class="line">    MyFunctor()(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么使用函数对象？</strong></p>
<ol>
<li><p><strong>携带状态:</strong> 与普通函数不同，函数对象是<strong>对象</strong>，它可以拥有自己的<strong>成员变量（状态）</strong>。这些状态可以在多次调用之间保持，或者在创建时进行配置。这对于需要累加、计数或根据特定上下文操作的算法非常有用。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for for_each</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象，用于计算总和并记录调用次数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumAndCount</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SumAndCount() : sum(<span class="number">0</span>), count(<span class="number">0</span>) &#123;&#125; <span class="comment">// 初始化状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sum; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    SumAndCount sac; <span class="comment">// 创建带有状态的函数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数对象传递给 for_each 算法</span></span><br><span class="line">    <span class="comment">// for_each 会对 nums 中的每个元素调用 sac.operator()</span></span><br><span class="line">    <span class="comment">// 注意：for_each 返回其函数对象参数的副本。</span></span><br><span class="line">    <span class="comment">// 如果需要获取最终状态，需要接收返回值（或使用引用包装器）</span></span><br><span class="line">    sac = <span class="built_in">std</span>::for_each(nums.begin(), nums.end(), sac);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sac.getSum() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; sac.getCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p> <strong>内联可能性:</strong> 编译器通常更容易对函数对象的 <code>operator()</code> 进行<strong>内联 (inline)</strong> 优化，因为它在编译时是已知的。相比之下，通过函数指针调用函数通常会阻止内联，可能带来轻微的性能开销。</p>
</li>
<li><p> <strong>类型多样性:</strong> 每个函数对象类都是一个独立的类型。这允许我们通过模板特化或重载来为不同的函数对象提供不同的行为。</p>
</li>
</ol>
<h3 id="16-5-2-预定义的函数符"><a href="#16-5-2-预定义的函数符" class="headerlink" title="16.5.2 预定义的函数符"></a>16.5.2 预定义的函数符</h3><p>标准库在 <code>&lt;functional&gt;</code> 头文件中提供了一系列常用的<strong>预定义函数符</strong>，可以直接使用，省去了自己编写简单操作类的麻烦。</p>
<p>常见的预定义函数符包括：</p>
<ul>
<li><strong>算术类:</strong><ul>
<li>  <code>plus&lt;T&gt;</code>: 执行 <code>arg1 + arg2</code>。</li>
<li>  <code>minus&lt;T&gt;</code>: 执行 <code>arg1 - arg2</code>。</li>
<li>  <code>multiplies&lt;T&gt;</code>: 执行 <code>arg1 * arg2</code>。</li>
<li>  <code>divides&lt;T&gt;</code>: 执行 <code>arg1 / arg2</code>。</li>
<li>  <code>modulus&lt;T&gt;</code>: 执行 <code>arg1 % arg2</code>。</li>
<li>  <code>negate&lt;T&gt;</code>: 执行 <code>-arg</code>。</li>
</ul>
</li>
<li><strong>比较类:</strong><ul>
<li>  <code>equal_to&lt;T&gt;</code>: 执行 <code>arg1 == arg2</code>。</li>
<li>  <code>not_equal_to&lt;T&gt;</code>: 执行 <code>arg1 != arg2</code>。</li>
<li>  <code>less&lt;T&gt;</code>: 执行 <code>arg1 &lt; arg2</code> (默认排序规则)。</li>
<li>  <code>greater&lt;T&gt;</code>: 执行 <code>arg1 &gt; arg2</code>。</li>
<li>  <code>less_equal&lt;T&gt;</code>: 执行 <code>arg1 &lt;= arg2</code>。</li>
<li>  <code>greater_equal&lt;T&gt;</code>: 执行 <code>arg1 &gt;= arg2</code>。</li>
</ul>
</li>
<li><strong>逻辑类:</strong><ul>
<li>  <code>logical_and&lt;T&gt;</code>: 执行 <code>arg1 &amp;&amp; arg2</code>。</li>
<li>  <code>logical_or&lt;T&gt;</code>: 执行 <code>arg1 || arg2</code>。</li>
<li>  <code>logical_not&lt;T&gt;</code>: 执行 <code>!arg</code>。</li>
</ul>
</li>
</ul>
<p><strong>使用示例:</strong></p>
<p>这些预定义函数符常用于需要自定义比较或操作的 STL 算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for sort, count_if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // 包含预定义函数符</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 greater&lt;int&gt; 进行降序排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(nums.begin(), nums.end(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="comment">// 等价于 std::sort(nums.begin(), nums.end(), [](int a, int b)&#123; return a &gt; b; &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted descending: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 9 8 5 4 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 less&lt;int&gt; 和 bind (或 lambda) 来查找小于 5 的元素数量</span></span><br><span class="line">    <span class="comment">// C++11 之前的做法可能使用 bind1st/bind2nd (已废弃) 或 boost::bind</span></span><br><span class="line">    <span class="comment">// C++11 及以后，lambda 更常用：</span></span><br><span class="line">    <span class="keyword">int</span> count_less_than_5 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(),</span><br><span class="line">                                          [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x &lt; <span class="number">5</span>; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count less than 5: &quot;</span> &lt;&lt; count_less_than_5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3 (4, 2, 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用预定义函数符和 lambda 结合 (虽然有点绕)</span></span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    count_less_than_5 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(),</span><br><span class="line">                                     [threshold](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;()(x, threshold); &#125;);</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count less than 5 (lambda+functor): &quot;</span> &lt;&lt; count_less_than_5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-5-3-自适应函数符和函数适配器-旧概念"><a href="#16-5-3-自适应函数符和函数适配器-旧概念" class="headerlink" title="16.5.3 自适应函数符和函数适配器 (旧概念)"></a>16.5.3 自适应函数符和函数适配器 (旧概念)</h3><p>在 C++11 引入 lambda 表达式之前，为了更灵活地组合和使用函数符，STL 提供了一些更复杂的机制，如<strong>自适应函数符 (Adaptable Functors)</strong> 和**函数适配器 (Function Adapters)**。</p>
<ul>
<li>  <strong>自适应函数符:</strong> 除了 <code>operator()</code>，还提供了一些嵌套的 <code>typedef</code>（如 <code>result_type</code>, <code>first_argument_type</code>, <code>second_argument_type</code>），使得适配器能够了解函数符的参数和返回类型。预定义的函数符大多是自适应的。</li>
<li><strong>函数适配器:</strong> 用于修改或绑定函数符的参数。<ul>
<li>  <strong>绑定器 (Binders):</strong> 如 <code>bind1st</code> 和 <code>bind2nd</code> (在 C++11 中<strong>废弃</strong>，C++17 中<strong>移除</strong>)，用于将二元函数符的一个参数绑定到特定值，生成一个一元函数符。例如，<code>bind1st(less&lt;int&gt;(), 5)</code> 会创建一个判断参数是否小于 5 的一元函数符。</li>
<li>  <strong>求反器 (Negators):</strong> 如 <code>not1</code> 和 <code>not2</code> (在 C++17 中<strong>废弃</strong>)，用于对一元或二元谓词函数符的结果取反。例如，<code>not1(is_even)</code> 会创建一个判断是否为奇数的一元函数符。</li>
<li>  <strong>成员函数适配器:</strong> 如 <code>mem_fun</code> 和 <code>mem_fun_ref</code> (在 C++11 中<strong>废弃</strong>，C++17 中<strong>移除</strong>)，用于将成员函数包装成可以被 STL 算法使用的函数对象。</li>
</ul>
</li>
</ul>
<p><strong>现代 C++ 的替代方案:</strong></p>
<p>这些旧的适配器机制比较复杂且用法受限。在现代 C++ (C++11 及以后) 中，它们的功能很大程度上被以下特性取代：</p>
<ul>
<li>  <strong><code>std::bind</code> (来自 <code>&lt;functional&gt;</code>):</strong> 一个更通用、更强大的绑定器，可以绑定普通函数、成员函数、函数对象，并灵活地指定参数占位符 (<code>std::placeholders::_1</code>, <code>_2</code> 等)。</li>
<li>  <strong>Lambda 表达式:</strong> 提供了非常简洁和灵活的方式来就地定义匿名函数对象，可以捕获上下文变量，极大地简化了需要传递自定义逻辑给算法的场景。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // for std::bind, std::less, std::placeholders</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind (替代 bind1st/bind2nd)</span></span><br><span class="line">    <span class="comment">// 创建一个一元谓词，判断 x &lt; threshold</span></span><br><span class="line">    <span class="keyword">auto</span> less_than_threshold = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, threshold);</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(), less_than_threshold);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count (bind): &quot;</span> &lt;&lt; count1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式 (更简洁)</span></span><br><span class="line">    <span class="keyword">int</span> count2 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(),</span><br><span class="line">                              [threshold](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x &lt; threshold; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count (lambda): &quot;</span> &lt;&lt; count2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然旧的适配器已被废弃，但理解函数对象的基本概念仍然很重要，因为它们是 STL 设计的基础，并且 lambda 表达式本质上就是编译器为我们自动生成的匿名函数对象。</p>
<h2 id="16-6-算法"><a href="#16-6-算法" class="headerlink" title="16.6 算法"></a>16.6 算法</h2><p>STL 的第三个主要组件是**算法 (Algorithms)**。STL 提供了大量用于处理容器（或其他序列）中数据的模板函数，这些函数统称为算法。它们定义在 <code>&lt;algorithm&gt;</code> 头文件中（还有一些数值算法在 <code>&lt;numeric&gt;</code> 中）。</p>
<p>STL 算法是<strong>泛型</strong>的，它们通过<strong>迭代器</strong>作用于元素范围，而不依赖于特定容器的实现。这使得同一个算法可以应用于 <code>vector</code>, <code>list</code>, <code>deque</code>, C 风格数组等多种数据结构。</p>
<h3 id="16-6-1-算法组"><a href="#16-6-1-算法组" class="headerlink" title="16.6.1 算法组"></a>16.6.1 算法组</h3><p>STL 算法可以根据其功能大致分为几类：</p>
<ol>
<li><strong>非修改序列操作 (Non-modifying sequence operations):</strong> 这些算法检查序列中的元素，但<strong>不修改</strong>元素的值。它们通常返回一个迭代器、一个布尔值或一个计数值。<ul>
<li>  例如: <code>find</code>, <code>find_if</code>, <code>count</code>, <code>count_if</code>, <code>equal</code>, <code>search</code>, <code>for_each</code>。</li>
</ul>
</li>
<li><strong>修改序列操作 (Modifying sequence operations):</strong> 这些算法会<strong>修改</strong>序列中的元素值或元素顺序。<ul>
<li>  例如: <code>copy</code>, <code>copy_if</code>, <code>move</code>, <code>transform</code>, <code>replace</code>, <code>replace_if</code>, <code>fill</code>, <code>generate</code>, <code>remove</code>, <code>remove_if</code>, <code>unique</code>, <code>reverse</code>, <code>rotate</code>, <code>random_shuffle</code> (C++17 废弃), <code>shuffle</code> (C++11)。</li>
</ul>
</li>
<li><strong>排序和相关操作 (Sorting and related operations):</strong> 用于对序列进行排序或执行基于排序的操作。<ul>
<li>  例如: <code>sort</code>, <code>stable_sort</code>, <code>partial_sort</code>, <code>nth_element</code>, <code>binary_search</code>, <code>lower_bound</code>, <code>upper_bound</code>, <code>equal_range</code>, <code>merge</code>, <code>inplace_merge</code>。</li>
</ul>
</li>
<li><strong>数值操作 (Numeric operations):</strong> 定义在 <code>&lt;numeric&gt;</code> 头文件中，用于执行数值计算。<ul>
<li>  例如: <code>accumulate</code>, <code>inner_product</code>, <code>partial_sum</code>, <code>adjacent_difference</code>, <code>iota</code> (C++11)。</li>
</ul>
</li>
<li><strong>堆操作 (Heap operations):</strong> 用于将范围维护成堆结构。<ul>
<li>  例如: <code>make_heap</code>, <code>push_heap</code>, <code>pop_heap</code>, <code>sort_heap</code>。</li>
</ul>
</li>
<li><strong>最小/最大操作 (Min/max operations):</strong><ul>
<li>  例如: <code>min</code>, <code>max</code>, <code>minmax</code> (C++11), <code>min_element</code>, <code>max_element</code>, <code>minmax_element</code> (C++11)。</li>
</ul>
</li>
<li><strong>排列操作 (Permutation operations):</strong><ul>
<li>  例如: <code>next_permutation</code>, <code>prev_permutation</code>。</li>
</ul>
</li>
</ol>
<h3 id="16-6-2-算法的通用特征"><a href="#16-6-2-算法的通用特征" class="headerlink" title="16.6.2 算法的通用特征"></a>16.6.2 算法的通用特征</h3><ul>
<li>  <strong>基于迭代器:</strong> 算法通常接受一对迭代器 <code>first</code> 和 <code>last</code> 作为参数，指定要操作的<strong>左闭右开区间 <code>[first, last)</code>**。<code>last</code> 指向的是要处理的最后一个元素的</strong>下一个**位置。</li>
<li>  <strong>不检查边界:</strong> 大多数算法假定传入的迭代器范围是有效的。传递无效范围（如 <code>end()</code> 在 <code>begin()</code> 之前，或迭代器指向不同容器）会导致未定义行为。</li>
<li><strong>不改变容器大小 (通常):</strong> 修改序列的算法（如 <code>replace</code>, <code>remove</code>）通常只<strong>覆盖</strong>或<strong>移动</strong>元素，而<strong>不改变容器的大小</strong>。例如，<code>remove</code> 只是将不被移除的元素移动到序列的前部，并返回一个指向新的逻辑末尾的迭代器，它<strong>不会</strong>真正删除容器中的元素。通常需要配合容器的 <code>erase</code> 方法来实际删除元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> val_to_remove = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 remove 将所有不等于 2 的元素移到前面</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = <span class="built_in">std</span>::remove(v.begin(), v.end(), val_to_remove);</span><br><span class="line">    <span class="comment">// v 现在可能是 &#123;1, 3, 4, 5, ?, ?, ?&#125; (问号代表未定义的值)</span></span><br><span class="line">    <span class="comment">// new_end 指向第一个问号的位置 (逻辑上的新末尾)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after remove (before erase): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出可能包含未定义值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSize before erase: &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// size 仍然是 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 erase 删除从 new_end 到原始末尾的元素</span></span><br><span class="line">    v.erase(new_end, v.end());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after erase: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 3 4 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSize after erase: &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// size 变为 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>  <strong>接受函数对象/Lambda:</strong> 许多算法接受一个额外的参数（通常是最后一个参数），用于指定自定义的比较逻辑（如 <code>sort</code> 的比较函数）、判断条件（如 <code>find_if</code>, <code>count_if</code> 的谓词）或要执行的操作（如 <code>for_each</code>, <code>transform</code> 的函数）。这可以是函数指针、函数对象或 lambda 表达式。</li>
<li><strong>谓词 (Predicate):</strong> 接受一个或两个参数并返回 <code>bool</code> 值的可调用实体。<ul>
<li>  <strong>一元谓词:</strong> <code>bool pred(const Type&amp; a)</code>，用于 <code>find_if</code>, <code>count_if</code>, <code>remove_if</code> 等。</li>
<li>  <strong>二元谓词:</strong> <code>bool pred(const Type&amp; a, const Type&amp; b)</code>，用于 <code>sort</code>, <code>unique</code> 等，通常表示某种顺序关系（如“小于”）。</li>
</ul>
</li>
</ul>
<p><strong>示例 (使用算法和 Lambda):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // for accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. find_if: 查找第一个偶数</span></span><br><span class="line">    <span class="keyword">auto</span> it_even = <span class="built_in">std</span>::find_if(nums.begin(), nums.end(),</span><br><span class="line">                                [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (it_even != nums.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First even number: &quot;</span> &lt;&lt; *it_even &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. sort: 按绝对值大小排序 (自定义比较)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mixed = &#123;<span class="number">3</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-9</span>, <span class="number">2</span>, <span class="number">-6</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(mixed.begin(), mixed.end(),</span><br><span class="line">              [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b); &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted by absolute value: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : mixed) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: -1 -1 2 3 4 5 -6 -9 (或类似，取决于稳定排序)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. transform: 将所有元素平方</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">squares</span><span class="params">(nums.size())</span></span>; <span class="comment">// 目标容器需要足够大</span></span><br><span class="line">    <span class="built_in">std</span>::transform(nums.begin(), nums.end(), squares.begin(),</span><br><span class="line">                   [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x * x; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Squares: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : squares) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 9 1 16 1 25 81 4 36</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accumulate: 计算所有元素的和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(nums.begin(), nums.end(), <span class="number">0</span>); <span class="comment">// 0 是初始值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 31</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. for_each: 对每个元素执行操作</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Person&gt; people = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;People: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(people.begin(), people.end(),</span><br><span class="line">                  [](<span class="keyword">const</span> Person&amp; p)&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;) &quot;</span>; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Alice(30) Bob(25) Charlie(35)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-6-3-STL-和-string-类"><a href="#16-6-3-STL-和-string-类" class="headerlink" title="16.6.3 STL 和 string 类"></a>16.6.3 STL 和 string 类</h3><p><code>std::string</code> 类虽然不是 STL 容器（它没有 <code>value_type</code> 等嵌套类型定义），但它提供了与 STL 兼容的接口，特别是<strong>迭代器</strong> (<code>begin()</code>, <code>end()</code> 等）。因此，许多 STL 算法可以直接应用于 <code>std::string</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt; // for ::tolower</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 find 查找字符</span></span><br><span class="line">    <span class="keyword">auto</span> it_l = <span class="built_in">std</span>::find(str.begin(), str.end(), <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it_l != str.end()) &#123;</span><br><span class="line">        <span class="comment">// 计算索引</span></span><br><span class="line">        <span class="keyword">size_t</span> index = <span class="built_in">std</span>::distance(str.begin(), it_l);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;l&#x27; first found at index: &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 count_if 统计小写字母数量</span></span><br><span class="line">    <span class="keyword">int</span> lower_count = <span class="built_in">std</span>::count_if(str.begin(), str.end(),</span><br><span class="line">                                   [](<span class="keyword">char</span> c)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">islower</span>(c); &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lowercase count: &quot;</span> &lt;&lt; lower_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 transform 将字符串转为小写</span></span><br><span class="line">    <span class="built_in">std</span>::transform(str.begin(), str.end(), str.begin(), <span class="comment">// 可以原地修改</span></span><br><span class="line">                   [](<span class="keyword">unsigned</span> <span class="keyword">char</span> c)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">tolower</span>(c); &#125;); <span class="comment">// 使用 unsigned char 避免负值问题</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lowercase string: &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reverse 反转字符串</span></span><br><span class="line">    <span class="built_in">std</span>::reverse(str.begin(), str.end());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reversed string: &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: dlrow olleh</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>string</code> 类本身也提供了许多成员函数（如 <code>find</code>, <code>replace</code>），但使用 STL 算法有时可以提供更通用或更强大的功能（例如配合 lambda 使用复杂条件）。</p>
<h3 id="16-6-4-函数和容器方法"><a href="#16-6-4-函数和容器方法" class="headerlink" title="16.6.4 函数和容器方法"></a>16.6.4 函数和容器方法</h3><p>有时，容器本身提供了与某个 STL 算法功能相似的<strong>成员函数</strong>。例如：</p>
<ul>
<li>  <code>list</code> 有自己的 <code>sort()</code> 成员函数。</li>
<li>  <code>list</code> 有自己的 <code>remove()</code> 和 <code>remove_if()</code> 成员函数。</li>
<li>  <code>list</code> 有自己的 <code>unique()</code> 成员函数。</li>
<li>  <code>set</code>, <code>map</code> 等关联容器有 <code>find()</code> 成员函数。</li>
</ul>
<p><strong>何时使用成员函数 vs. STL 算法？</strong></p>
<ul>
<li><strong>优先使用成员函数 (如果可用且满足需求):</strong> 容器的成员函数通常能更好地利用容器的内部结构进行优化。<ul>
<li>  例如，<code>list::sort()</code> 比 <code>std::sort(list.begin(), list.end())</code> (如果 <code>list</code> 迭代器支持的话，但它不支持随机访问，所以不能用 <code>std::sort</code>) 更高效，因为它只需要重新链接节点，而不需要移动元素。</li>
<li>  <code>list::remove()</code> 可以真正地从链表中删除节点并调整大小，而 <code>std::remove</code> 不能。</li>
<li>  关联容器的 <code>find()</code> 成员函数利用其内部树或哈希结构，复杂度为 O(log N) 或 O(1)，而 <code>std::find</code> 是线性扫描 O(N)。</li>
</ul>
</li>
<li><strong>使用 STL 算法:</strong><ul>
<li>  当容器没有提供相应的成员函数时。</li>
<li>  当需要跨不同容器类型使用统一的算法时。</li>
<li>  当需要更复杂的、成员函数不支持的操作逻辑时（例如，使用 <code>std::remove_copy_if</code> 将不满足条件的元素复制到另一个容器）。</li>
</ul>
</li>
</ul>
<h3 id="16-6-5-使用-STL"><a href="#16-6-5-使用-STL" class="headerlink" title="16.6.5 使用 STL"></a>16.6.5 使用 STL</h3><p>掌握 STL 的关键在于理解其三个核心组件如何协同工作：</p>
<ol>
<li> <strong>选择合适的容器:</strong> 根据数据存储和访问的需求选择 <code>vector</code>, <code>list</code>, <code>map</code>, <code>set</code> 等。</li>
<li> <strong>使用迭代器指定范围:</strong> 通过 <code>begin()</code>, <code>end()</code> 或其他方式获取迭代器来定义算法操作的元素区间 <code>[first, last)</code>。</li>
<li> <strong>选择合适的算法:</strong> 从 <code>&lt;algorithm&gt;</code> 或 <code>&lt;numeric&gt;</code> 中选择能完成所需任务的算法。</li>
<li> <strong>提供自定义逻辑 (如果需要):</strong> 通过函数对象、lambda 表达式或函数指针向算法传递自定义的比较、判断或操作规则。</li>
</ol>
<p>STL 是一个强大而灵活的库，熟练使用它可以大大提高 C++ 编程的效率和代码质量。建议多查阅文档（如 cppreference.com）了解各种容器、算法和迭代器的详细用法和要求。</p>
<h2 id="16-7-其他库"><a href="#16-7-其他库" class="headerlink" title="16.7 其他库"></a>16.7 其他库</h2><p>除了 <code>string</code> 类、智能指针和 STL 的核心组件（容器、算法、迭代器）之外，C++ 标准库还提供了许多其他有用的工具和类。本节将简要介绍 <code>valarray</code> 类和 C++11 引入的 <code>initializer_list</code>。</p>
<h3 id="16-7-1-vector、valarray-和-array"><a href="#16-7-1-vector、valarray-和-array" class="headerlink" title="16.7.1 vector、valarray 和 array"></a>16.7.1 vector、valarray 和 array</h3><p>我们在前面章节已经接触过 <code>vector</code> 和 <code>array</code>，它们都提供了类似数组的功能，但各有特点。标准库还在 <code>&lt;valarray&gt;</code> 头文件中提供了另一个模板类 <code>std::valarray</code>，它主要设计用于<strong>数值计算</strong>，特别是对整个数组进行高效的元素级算术运算。</p>
<ul>
<li><p><strong><code>std::vector&lt;T&gt;</code>:</strong></p>
<ul>
<li>  <strong>头文件:</strong> <code>&lt;vector&gt;</code></li>
<li>  <strong>大小:</strong> 动态大小，可运行时增长和收缩。</li>
<li>  <strong>内存:</strong> 保证元素连续存储。</li>
<li>  <strong>主要特点:</strong> 通用的动态数组，支持丰富的 STL 算法，尾部插入/删除高效。</li>
<li>  <strong>数值运算:</strong> 不直接支持元素级的算术运算符（例如，两个 <code>vector</code> 不能直接相加）。需要手动循环或使用 <code>std::transform</code> 等算法。</li>
</ul>
</li>
<li><p><strong><code>std::array&lt;T, N&gt;</code> (C++11):</strong></p>
<ul>
<li>  <strong>头文件:</strong> <code>&lt;array&gt;</code></li>
<li>  <strong>大小:</strong> <strong>固定大小</strong> <code>N</code>，在编译时确定。</li>
<li>  <strong>内存:</strong> 保证元素连续存储，通常在栈上分配（如果是局部变量且大小适中）。</li>
<li>  <strong>主要特点:</strong> 对 C 风格数组的类型安全封装，支持 STL 算法，性能与 C 风格数组相当。</li>
<li>  <strong>数值运算:</strong> 与 <code>vector</code> 类似，不直接支持元素级运算。</li>
</ul>
</li>
<li><p><strong><code>std::valarray&lt;T&gt;</code>:</strong></p>
<ul>
<li>  <strong>头文件:</strong> <code>&lt;valarray&gt;</code></li>
<li>  <strong>大小:</strong> 动态大小（但通常在创建后大小变化不频繁）。</li>
<li>  <strong>内存:</strong> 不保证连续存储（实现可能进行优化，如分块）。</li>
<li>  <strong>主要特点:</strong> <strong>专为数值计算设计</strong>。重载了算术运算符 (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 等）以支持<strong>元素级 (element-wise)</strong> 操作。还提供了许多数学函数（如 <code>abs</code>, <code>sqrt</code>, <code>sin</code>, <code>cos</code> 等）的应用版本。</li>
<li>  <strong>STL 兼容性:</strong> 与标准 STL 算法的兼容性不如 <code>vector</code> 和 <code>array</code> 好（例如，其迭代器可能不是标准类别）。</li>
</ul>
</li>
</ul>
<p><strong>比较总结:</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>std::vector&lt;T&gt;</code></th>
<th align="left"><code>std::array&lt;T, N&gt;</code> (C++11)</th>
<th align="left"><code>std::valarray&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>头文件</strong></td>
<td align="left"><code>&lt;vector&gt;</code></td>
<td align="left"><code>&lt;array&gt;</code></td>
<td align="left"><code>&lt;valarray&gt;</code></td>
</tr>
<tr>
<td align="left"><strong>大小</strong></td>
<td align="left">动态</td>
<td align="left">固定 (编译时)</td>
<td align="left">动态</td>
</tr>
<tr>
<td align="left"><strong>内存</strong></td>
<td align="left">连续</td>
<td align="left">连续</td>
<td align="left">不保证连续</td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left">通用动态数组</td>
<td align="left">C 数组的安全替代品</td>
<td align="left">数值计算</td>
</tr>
<tr>
<td align="left"><strong>元素级运算</strong></td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>STL 算法</strong></td>
<td align="left">完全兼容</td>
<td align="left">完全兼容</td>
<td align="left">有限兼容</td>
</tr>
</tbody></table>
<p><strong><code>valarray</code> 示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // for iota</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 valarray 进行元素级运算</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v1 = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v2 = &#123;<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v_sum, v_prod;</span><br><span class="line"></span><br><span class="line">    v_sum = v1 + v2;   <span class="comment">// 元素级相加: &#123;1.5, 2.5, 3.5, 4.5&#125;</span></span><br><span class="line">    v_prod = v1 * <span class="number">2.0</span>; <span class="comment">// 每个元素乘以 2.0: &#123;2.0, 4.0, 6.0, 8.0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1 + v2 = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : v_sum) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// C++11 range-based for 可能不直接支持 valarray</span></span><br><span class="line">    <span class="comment">// 使用传统循环或下标访问</span></span><br><span class="line">    <span class="comment">// for (size_t i = 0; i &lt; v_sum.size(); ++i) std::cout &lt;&lt; v_sum[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1 * 2.0 = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v_prod.size(); ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v_prod[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用数学函数</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v_sqrt = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(v_prod); <span class="comment">// 对每个元素求平方根</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sqrt(v_prod) = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v_sqrt.size(); ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v_sqrt[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比 vector (需要算法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec1 = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vec_prod</span><span class="params">(vec1.size())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::transform(vec1.begin(), vec1.end(), vec_prod.begin(),</span><br><span class="line">                   [](<span class="keyword">double</span> x)&#123; <span class="keyword">return</span> x * <span class="number">2.0</span>; &#125;);</span><br><span class="line">    <span class="comment">// vec_prod 现在是 &#123;2.0, 4.0, 6.0, 8.0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的主要任务是进行向量化或矩阵式的数值计算，<code>valarray</code> 可能是一个值得考虑的选择，尽管在现代 C++ 中，也有许多第三方库（如 Eigen, Blaze）提供了更强大和灵活的线性代数功能。对于通用的动态序列存储，<code>vector</code> 仍然是首选。</p>
<h3 id="16-7-2-模板-initializer-list（C-11）"><a href="#16-7-2-模板-initializer-list（C-11）" class="headerlink" title="16.7.2 模板 initializer_list（C++11）"></a>16.7.2 模板 initializer_list（C++11）</h3><p>C++11 引入了一个新的模板类 <code>std::initializer_list&lt;T&gt;</code>，定义在 <code>&lt;initializer_list&gt;</code> 头文件中。它是一个轻量级的代理对象，代表了一个用<strong>花括号 <code>&#123;&#125;</code></strong> 初始化的值列表，其中所有值的类型都是 <code>T</code> 或可以隐式转换为 <code>T</code>。</p>
<p><strong>主要目的:</strong> 使得函数（尤其是构造函数）能够接受<strong>任意数量</strong>的、类型相同的初始化值，就像内置数组或聚合类型那样使用花括号初始化一样。</p>
<p><strong>特点:</strong></p>
<ul>
<li>  <strong>轻量级:</strong> <code>initializer_list</code> 对象本身通常只包含指向底层（临时）数组的指针和数组的大小。复制 <code>initializer_list</code> 对象是浅拷贝，开销很小。</li>
<li>  <strong>只读访问:</strong> 通过 <code>initializer_list</code> 访问其元素通常是只读的 (<code>const T&amp;</code>)。你不能通过 <code>initializer_list</code> 修改列表中的元素。</li>
<li>  <strong>生命周期:</strong> <code>initializer_list</code> 引用的底层数组的生命周期与 <code>initializer_list</code> 对象本身相关联，通常是临时的。不要存储 <code>initializer_list</code> 对象并在其原始上下文之外使用。</li>
<li>  <strong>迭代器:</strong> 提供了 <code>begin()</code> 和 <code>end()</code> 成员函数，返回指向底层数组的 <code>const T*</code> 指针，可以方便地遍历列表中的元素。</li>
<li>  <strong><code>size()</code>:</strong> 返回列表中的元素数量。</li>
</ul>
<p><strong>如何工作:</strong> 当编译器遇到一个需要 <code>std::initializer_list&lt;T&gt;</code> 参数的地方，并且你提供了一个 <code>&#123;value1, value2, ...&#125;</code> 形式的初始化列表时，编译器会自动：</p>
<ol>
<li> 创建一个临时的、类型为 <code>const T</code> 的数组，并将列表中的值存储进去。</li>
<li> 创建一个 <code>std::initializer_list&lt;T&gt;</code> 对象，使其内部指针指向这个临时数组的开头，并记录数组的大小。</li>
<li> 将这个 <code>initializer_list&lt;T&gt;</code> 对象传递给函数或构造函数。</li>
</ol>
<h3 id="16-7-3-使用-initializer-list"><a href="#16-7-3-使用-initializer-list" class="headerlink" title="16.7.3 使用 initializer_list"></a>16.7.3 使用 initializer_list</h3><p><code>initializer_list</code> 最常见的用途是作为函数或构造函数的参数类型。</p>
<p><strong>1. 作为函数参数:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受一个 initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ints</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; il)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing &quot;</span> &lt;&lt; il.size() &lt;&lt; <span class="string">&quot; integers: &quot;</span>;</span><br><span class="line">    <span class="comment">// 可以使用范围 for 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; val : il) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用 begin()/end()</span></span><br><span class="line">    <span class="comment">// for (auto it = il.begin(); it != il.end(); ++it) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数接受任意类型的 initializer_list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum_list</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il)</span> </span>&#123;</span><br><span class="line">    T total&#123;&#125;; <span class="comment">// 值初始化 (对于数值类型为 0)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> T&amp; val : il) &#123;</span><br><span class="line">        total += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_ints(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 直接传递花括号列表</span></span><br><span class="line">    print_ints(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line">    print_ints(&#123;&#125;); <span class="comment">// 传递空列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_int = sum_list(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of ints: &quot;</span> &lt;&lt; total_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> total_double = sum_list(&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of doubles: &quot;</span> &lt;&lt; total_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6.6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::string total_string = sum_list&lt;std::string&gt;(&#123;&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;&#125;); // 也可以用于支持 += 的类型</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Sum of strings: &quot; &lt;&lt; total_string &lt;&lt; std::endl; // 输出 &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 作为构造函数参数:</strong></p>
<p>这是 <code>initializer_list</code> 最重要的用途之一，它使得 STL 容器（如 <code>vector</code>, <code>list</code>, <code>map</code>, <code>set</code> 等）以及用户自定义的类能够支持简洁的花括号列表初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：一个简单的自定义类，支持 initializer_list 构造</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数接受 initializer_list</span></span><br><span class="line">    MyData(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; il) : data_(il) &#123; <span class="comment">// 可以直接用来初始化 vector 成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyData constructed with &quot;</span> &lt;&lt; il.size() &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : data_) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 initializer_list 构造 STL 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 调用 vector(initializer_list&lt;int&gt;) 构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>, <span class="number">3</span>&#125;&#125;; <span class="comment">// 调用 map(initializer_list&lt;pair&lt;const string, int&gt;&gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 initializer_list 构造自定义类</span></span><br><span class="line">    MyData md1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    MyData md2 &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">// 也可以用花括号直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;md1 data: &quot;</span>;</span><br><span class="line">    md1.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;md2 data: &quot;</span>;</span><br><span class="line">    md2.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initializer_list</code> 极大地增强了 C++11 及以后版本的初始化语法，使其更加统一和方便，特别是对于容器和需要接受可变数量同类型参数的场景。</p>
<h2 id="16-8-总结"><a href="#16-8-总结" class="headerlink" title="16.8 总结"></a>16.8 总结</h2><p>本章深入探讨了 C++ 标准库提供的几个强大的工具，它们极大地增强了 C++ 的功能和易用性，特别是 <code>string</code> 类、智能指针和标准模板库 (STL)。</p>
<p>主要内容回顾：</p>
<ol>
<li><p><strong><code>string</code> 类:</strong></p>
<ul>
<li>  提供了比 C 风格字符数组更安全、更方便的字符串处理方式，具有自动内存管理和丰富的成员函数（构造、输入、拼接、查找、修改、比较等）。</li>
<li>  支持通过 <code>c_str()</code> 获取与 C 风格函数兼容的 <code>const char*</code>。</li>
<li>  标准库还提供了宽字符版本如 <code>wstring</code>。</li>
</ul>
</li>
<li><p><strong>智能指针 (<code>&lt;memory&gt;</code>):</strong></p>
<ul>
<li>  用于自动管理动态分配的内存，防止内存泄漏和悬挂指针。</li>
<li>  <strong><code>unique_ptr</code>:</strong> 实现独占所有权，轻量级，不可复制，可移动。管理动态数组时使用 <code>unique_ptr&lt;T[]&gt;</code>。是管理动态资源的首选。</li>
<li>  <strong><code>shared_ptr</code>:</strong> 实现共享所有权，通过引用计数管理资源生命周期。当最后一个 <code>shared_ptr</code> 销毁时释放资源。需要注意循环引用问题。</li>
<li>  <strong><code>weak_ptr</code>:</strong> 非拥有型指针，用于观察 <code>shared_ptr</code> 管理的对象，不增加引用计数，可用于打破循环引用。通过 <code>lock()</code> 安全地获取 <code>shared_ptr</code>。</li>
<li>  应优先使用 <code>make_unique</code> 和 <code>make_shared</code> 创建智能指针。</li>
<li>  <code>auto_ptr</code> 已被废弃，应使用 <code>unique_ptr</code>。</li>
</ul>
</li>
<li><p><strong>标准模板库 (STL):</strong></p>
<ul>
<li>  基于泛型编程思想，提供通用的容器、算法和迭代器。</li>
<li><strong>容器:</strong> 存储数据的模板类。<ul>
<li>  <strong>顺序容器:</strong> <code>vector</code> (动态数组), <code>deque</code> (双端队列), <code>list</code> (双向链表), <code>forward_list</code> (单向链表), <code>array</code> (固定大小数组)。</li>
<li>  <strong>关联容器:</strong> <code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code> (基于键排序，对数时间复杂度)。</li>
<li>  <strong>无序关联容器:</strong> <code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, <code>unordered_multimap</code> (基于哈希，平均常数时间复杂度)。</li>
<li>  <strong>容器适配器:</strong> <code>stack</code>, <code>queue</code>, <code>priority_queue</code> (提供特定接口)。</li>
</ul>
</li>
<li>  <strong><code>vector</code>:</strong> 最常用的动态数组，支持随机访问，尾部操作高效。</li>
<li>  <strong>迭代器:</strong> 泛化的指针，连接容器和算法，提供统一的遍历接口。分为输入、输出、前向、双向、随机访问五种类别。</li>
<li>  <strong>算法 (<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>):</strong> 对迭代器指定的范围进行操作的函数模板（如 <code>sort</code>, <code>find</code>, <code>copy</code>, <code>transform</code>, <code>accumulate</code>）。算法通常不改变容器大小，需要配合容器方法（如 <code>erase</code>）来实际增删元素。</li>
<li>  <strong>基于范围的 for 循环 (C++11):</strong> 提供了简洁、安全的遍历容器（或序列）的方式。</li>
</ul>
</li>
<li><p><strong>函数对象 (Functors):</strong></p>
<ul>
<li>  重载了 <code>operator()</code> 的类的对象，可以像函数一样调用。</li>
<li>  可以携带状态，常作为参数传递给 STL 算法以定制行为。</li>
<li>  标准库在 <code>&lt;functional&gt;</code> 中提供了预定义的函数符（如 <code>plus</code>, <code>less</code>）。</li>
<li>  现代 C++ 中，Lambda 表达式和 <code>std::bind</code> 提供了比旧式函数适配器更灵活的方式。</li>
</ul>
</li>
<li><p><strong>其他库特性:</strong></p>
<ul>
<li>  <strong><code>valarray</code> (<code>&lt;valarray&gt;</code>):</strong> 专为数值计算设计的动态数组，支持元素级算术运算。</li>
<li>  <strong><code>initializer_list</code> (<code>&lt;initializer_list&gt;</code>, C++11):</strong> 使得函数和构造函数能接受花括号初始化列表 <code>&#123;...&#125;</code>，简化了容器和自定义类的初始化。</li>
</ul>
</li>
</ol>
<p>本章介绍的库特性是现代 C++ 编程的基础。熟练运用 <code>string</code>、智能指针和 STL 的容器、迭代器、算法，可以编写出更安全、更简洁、更高效、更易于维护的代码。</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_16/>http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_16/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-30T23:40:40+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年4月30日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Program/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Program</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/C/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>C++</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_16/&title=Chapter 16 string 类和标准模板库 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_16/&title=Chapter 16 string 类和标准模板库 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_16/&title=Chapter 16 string 类和标准模板库 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2025/04/30/Cpp_tutorial_Chapter_17/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Chapter 17 输入、输出和文件</p>
          <p class='content'>17.1 C++输入和输出概述C++ 程序经常需要与外部世界进行交互：从键盘读取用户输入，将结果显示到屏幕，或者读写文件。C++ 使用流 (Stream) 的概念来处理输入和输出 (I/O) 操...</p>
        </a>
      
      
        <a class='next' href='/2025/04/30/Cpp_tutorial_Chapter_15/'>
          <p class='title'>Chapter 15 友元、异常和其他<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>15.1 友元通常，类的 private 和 protected 成员只能被该类的成员函数访问。这是 C++ 封装性的体现，有助于保护数据和隐藏实现细节。然而，在某些特殊情况下，允许特定的外部函...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-string-%E7%B1%BB"><span class="toc-text">16.1 string 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-%E6%9E%84%E9%80%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">16.1.1 构造字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-string-%E7%B1%BB%E8%BE%93%E5%85%A5"><span class="toc-text">16.1.2 string 类输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-3-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">16.1.3 使用字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-4-string-%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="toc-text">16.1.4 string 还提供了哪些功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB"><span class="toc-text">16.1.5 字符串种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">16.2 智能指针模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-1-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">16.2.1 使用智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-unique-ptr"><span class="toc-text">std::unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-shared-ptr"><span class="toc-text">std::shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-weak-ptr"><span class="toc-text">std::weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-2-%E6%9C%89%E5%85%B3%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">16.2.2 有关智能指针的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-3-unique-ptr-%E4%B8%BA%E4%BD%95%E4%BC%98%E4%BA%8E-auto-ptr"><span class="toc-text">16.2.3 unique_ptr 为何优于 auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-4-%E9%80%89%E6%8B%A9%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">16.2.4 选择智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89"><span class="toc-text">16.3 标准模板库（STL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-1-%E6%A8%A1%E6%9D%BF%E7%B1%BB-vector"><span class="toc-text">16.3.1 模板类 vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-2-%E5%8F%AF%E5%AF%B9%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">16.3.2 可对容器执行的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-3-%E5%AF%B9%E5%AE%B9%E5%99%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-text">16.3.3 对容器可执行的其他操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-4-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84-for-%E5%BE%AA%E7%8E%AF%EF%BC%88C-11%EF%BC%89"><span class="toc-text">16.3.4 基于范围的 for 循环（C++11）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-4-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">16.4 泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-1-%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">16.4.1 为何使用迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">16.4.2 迭代器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">16.4.3 迭代器层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-4-%E6%A6%82%E5%BF%B5%E3%80%81%E6%94%B9%E8%BF%9B%E5%92%8C%E6%A8%A1%E5%9E%8B-Concepts-Refinements-and-Models"><span class="toc-text">16.4.4 概念、改进和模型 (Concepts, Refinements, and Models)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-5-%E5%AE%B9%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-text">16.4.5 容器种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-6-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">16.4.6 关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-7-%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%EF%BC%88C-11%EF%BC%89"><span class="toc-text">16.4.7 无序关联容器（C++11）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-5-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">16.5 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-1-%E5%87%BD%E6%95%B0%E7%AC%A6%E6%A6%82%E5%BF%B5"><span class="toc-text">16.5.1 函数符概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-2-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E7%AC%A6"><span class="toc-text">16.5.2 预定义的函数符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-3-%E8%87%AA%E9%80%82%E5%BA%94%E5%87%BD%E6%95%B0%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8-%E6%97%A7%E6%A6%82%E5%BF%B5"><span class="toc-text">16.5.3 自适应函数符和函数适配器 (旧概念)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-6-%E7%AE%97%E6%B3%95"><span class="toc-text">16.6 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-1-%E7%AE%97%E6%B3%95%E7%BB%84"><span class="toc-text">16.6.1 算法组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-2-%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E5%BE%81"><span class="toc-text">16.6.2 算法的通用特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-3-STL-%E5%92%8C-string-%E7%B1%BB"><span class="toc-text">16.6.3 STL 和 string 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-4-%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%B9%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-text">16.6.4 函数和容器方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-5-%E4%BD%BF%E7%94%A8-STL"><span class="toc-text">16.6.5 使用 STL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-7-%E5%85%B6%E4%BB%96%E5%BA%93"><span class="toc-text">16.7 其他库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-1-vector%E3%80%81valarray-%E5%92%8C-array"><span class="toc-text">16.7.1 vector、valarray 和 array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-2-%E6%A8%A1%E6%9D%BF-initializer-list%EF%BC%88C-11%EF%BC%89"><span class="toc-text">16.7.2 模板 initializer_list（C++11）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-3-%E4%BD%BF%E7%94%A8-initializer-list"><span class="toc-text">16.7.3 使用 initializer_list</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-8-%E6%80%BB%E7%BB%93"><span class="toc-text">16.8 总结</span></a></li></ol>
    </div>
  </section>


  


</aside>



        
        
          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="Chapter 16 string 类和标准模板库";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        
      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5043500508'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a id="s-top" class="fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <script>
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/********************脚本懒加载函数********************************/
function loadScript(src, cb) {
var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
var script = document.createElement('script');
script.setAttribute('type','text/javascript');
if (cb) script.onload = cb;
script.setAttribute('src', src);
HEAD.appendChild(script);
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  








  <script>
  let APlayerController = new Object();
  APlayerController.id = '5043500508';  // 设定全局音乐播放ID
  APlayerController.volume = '0.7';
  loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css", window.volantis.loadcss);

  loadScript("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js")

  loadScript("https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js")


</script>




  
  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/valine.min.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";

    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      recordIP: 'false',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>





  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/app.min.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/search/hexo.min.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://uniqueland.top' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
       

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      
	 

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
      } catch (e) {
        console.log(e);
      }
	  
    });

    document.addEventListener('pjax:error', function (e) {
	  
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
