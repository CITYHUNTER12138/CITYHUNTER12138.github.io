<!DOCTYPE html>
<html lang="zh-CN">
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6'>
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>Chapter 18 探讨C++新标准 - Uniqueland</title>
  
    <meta name="keywords" content="Program,C++">
  

  
    <meta name="description" content="C++ tutorial">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://www.helloimg.com/images/2022/03/27/ReozOM.png">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

</head>

<body>
  

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div id="l_body">
    <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Uniqueland</p>
    
    
      <p class="subtitle">--XR's personal Blog</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/categories/"
              
              
              id="categories">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>分类</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

    <div id='safearea'>
      <div class='body-wrapper' id="pjax-container">
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
    <div class='headimg-div'>
      <a class='headimg-a'>
        <img class='headimg' src='https://s2.loli.net/2025/04/26/9F74KMasiN1YwQW.png'/>
      </a>
    </div>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Chapter 18 探讨C++新标准
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="https://raw.githubusercontent.com/srcx404/pic/refs/heads/main/xr.jpg">
    <p>XR</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2025年4月30日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Chapter 18 探讨C++新标准" data-path="/2025/04/30/Cpp_tutorial_Chapter_18/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <h2 id="18-1-复习前面介绍过的C-11功能"><a href="#18-1-复习前面介绍过的C-11功能" class="headerlink" title="18.1 复习前面介绍过的C++11功能"></a>18.1 复习前面介绍过的C++11功能</h2><p>C++11 标准为 C++ 语言带来了许多重要的改进和新特性，旨在提高语言的效率、安全性和易用性。在前面的章节中，我们已经接触并使用了其中的一些功能。本节将对这些已介绍的 C++11 特性进行一个简要的回顾。</p>
<h3 id="18-1-1-新类型"><a href="#18-1-1-新类型" class="headerlink" title="18.1.1 新类型"></a>18.1.1 新类型</h3><p>C++11 引入了几种新的基本类型：</p>
<ul>
<li><strong><code>long long</code> 和 <code>unsigned long long</code>:</strong> （第 3 章）提供了至少 64 位的整数类型，用于表示比 <code>long</code> 更大范围的整数。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> large_num = <span class="number">9876543210123L</span>L;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> very_large_positive = <span class="number">18446744073709551615U</span>LL;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>char16_t</code> 和 <code>char32_t</code>:</strong> （第 3 章, 第 16 章）用于显式支持 UTF-16 和 UTF-32 编码的字符。分别使用 <code>u</code> 和 <code>U</code> 前缀表示对应的字符和字符串字面量。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char16_t</span> utf16_char = <span class="string">u&#x27;Ω&#x27;</span>;</span><br><span class="line">char32_t utf32_char = U&#x27;🌍&#x27;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char16_t</span>* utf16_str = <span class="string">u&quot;你好&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char32_t</span>* utf32_str = <span class="string">U&quot;世界&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>nullptr</code>:</strong> （第 4 章）引入了新的空指针常量 <code>nullptr</code>，用于替代之前使用的 <code>0</code> 或 <code>NULL</code>。<code>nullptr</code> 具有明确的指针类型 (<code>std::nullptr_t</code>)，可以避免一些与 <code>0</code> (整数) 相关的歧义。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">void</span> (*func_ptr)(<span class="keyword">int</span>) = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// if (ptr1 == 0) &#123; /* ... */ &#125; // 旧式比较</span></span><br><span class="line"><span class="keyword">if</span> (ptr1 == <span class="literal">nullptr</span>) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// C++11 推荐</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="18-1-2-统一的初始化"><a href="#18-1-2-统一的初始化" class="headerlink" title="18.1.2 统一的初始化"></a>18.1.2 统一的初始化</h3><p>C++11 推广了使用<strong>花括号 <code>&#123;&#125;</code></strong> 进行初始化的方式，称为<strong>统一初始化 (Uniform Initialization)</strong> 或列表初始化 (List Initialization)。这种方式可以用于多种初始化场景，并有助于防止窄化转换 (Narrowing Conversion)。</p>
<ul>
<li><strong>基本类型:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> pi&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="comment">// int narrow_error&#123;3.14&#125;; // 编译错误！防止 double 到 int 的窄化</span></span><br></pre></td></tr></table></figure></li>
<li><strong>数组:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 大小自动推断</span></span><br></pre></td></tr></table></figure></li>
<li><strong>结构和类:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>STL 容器 (通过 <code>initializer_list</code>):</strong> （第 16 章）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m &#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="18-1-3-声明"><a href="#18-1-3-声明" class="headerlink" title="18.1.3 声明"></a>18.1.3 声明</h3><p>C++11 引入了新的声明方式来简化类型书写和推断：</p>
<ul>
<li><strong><code>auto</code>:</strong> （第 3 章）让编译器根据变量的<strong>初始化表达式</strong>自动推断其类型。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;        <span class="comment">// i 推断为 int</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="number">3.14</span>;      <span class="comment">// d 推断为 double</span></span><br><span class="line"><span class="keyword">auto</span> s = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;text&quot;</span>); <span class="comment">// s 推断为 std::string</span></span><br><span class="line"><span class="keyword">auto</span> it = v.begin(); <span class="comment">// it 推断为 std::vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>decltype</code>:</strong> 根据<strong>表达式</strong>推断类型，但不计算该表达式。常用于泛型编程或需要根据已有变量或函数返回值确定类型的场景。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>; <span class="comment">// y 的类型与 x 相同，为 int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(func()) z; <span class="comment">// z 的类型是 func 的返回类型 double (不实际调用 func)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="18-1-4-智能指针"><a href="#18-1-4-智能指针" class="headerlink" title="18.1.4 智能指针"></a>18.1.4 智能指针</h3><p>（第 16 章）C++11 在 <code>&lt;memory&gt;</code> 头文件中引入了现代智能指针，用于自动管理动态分配的内存，取代了容易出错的 <code>auto_ptr</code>。</p>
<ul>
<li>  <strong><code>std::unique_ptr&lt;T&gt;</code>:</strong> 独占所有权的智能指针，轻量级，不可复制，可移动。</li>
<li>  <strong><code>std::shared_ptr&lt;T&gt;</code>:</strong> 共享所有权的智能指针，通过引用计数管理对象生命周期。</li>
<li>  <strong><code>std::weak_ptr&lt;T&gt;</code>:</strong> 非拥有型指针，用于观察 <code>shared_ptr</code> 管理的对象，解决循环引用问题。</li>
</ul>
<h3 id="18-1-5-异常规范方面的修改"><a href="#18-1-5-异常规范方面的修改" class="headerlink" title="18.1.5 异常规范方面的修改"></a>18.1.5 异常规范方面的修改</h3><p>（第 15 章）C++11 引入了 <code>noexcept</code> 说明符和运算符，用于指示函数是否可能抛出异常。</p>
<ul>
<li><strong><code>noexcept</code> 说明符:</strong> 放在函数声明或定义后，表示该函数保证不抛出任何异常。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 声明保证不抛异常</span></span><br></pre></td></tr></table></figure>
  这有助于编译器进行优化，并用于异常安全保证。析构函数默认是 <code>noexcept</code> 的。</li>
<li>  <strong><code>noexcept</code> 运算符:</strong> <code>noexcept(expression)</code>，在编译时判断表达式 <code>expression</code> 是否可能抛出异常，返回一个 <code>bool</code> 常量。</li>
</ul>
<p>旧的 <code>throw()</code> 异常规范在 C++11 中被废弃。</p>
<h3 id="18-1-6-作用域内枚举"><a href="#18-1-6-作用域内枚举" class="headerlink" title="18.1.6 作用域内枚举"></a>18.1.6 作用域内枚举</h3><p>（第 10 章）C++11 引入了<strong>强类型枚举 (Strongly-typed enums)</strong> 或**作用域内枚举 (Scoped enums)**，使用 <code>enum class</code> (或 <code>enum struct</code>) 关键字定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span> &#123;</span> OK, ERROR &#125;;</span><br><span class="line"></span><br><span class="line">Color c = Color::RED;</span><br><span class="line">Status s = Status::OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if (c == s) &#123;&#125; // 编译错误！不同类型的枚举不能直接比较</span></span><br><span class="line"><span class="comment">// int x = c;     // 编译错误！不能隐式转换为整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == Color::GREEN) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点:</strong></p>
<ul>
<li>  <strong>强类型:</strong> 不同枚举类型的值不能隐式转换或直接比较。</li>
<li>  <strong>作用域:</strong> 枚举成员的作用域限定在枚举类型内部，必须通过 <code>EnumType::Member</code> 访问，避免了命名冲突。</li>
<li>  <strong>可指定底层类型:</strong> <code>enum class Color : char &#123; RED, GREEN, BLUE &#125;;</code></li>
</ul>
<h3 id="18-1-7-对类的修改"><a href="#18-1-7-对类的修改" class="headerlink" title="18.1.7 对类的修改"></a>18.1.7 对类的修改</h3><p>(本节主要回顾，但部分内容如委托/继承构造函数、override/final 在 18.3 详细介绍，这里仅提及概念)<br>C++11 对类定义和使用也进行了一些改进，部分已在前面章节涉及或将在后续章节详细介绍，例如：</p>
<ul>
<li>  <strong>默认构造函数和成员初始化:</strong> 允许在类定义中直接初始化非静态成员变量。</li>
<li>  <strong><code>= default</code> 和 <code>= delete</code>:</strong> 显式要求编译器生成默认的特殊成员函数（构造、析构、拷贝、移动）或禁用它们。</li>
<li>  <strong>委托构造函数:</strong> 一个构造函数可以调用同一类的另一个构造函数。</li>
<li>  <strong>继承构造函数:</strong> 派生类可以继承基类的构造函数。</li>
<li>  <strong><code>override</code> 和 <code>final</code>:</strong> 用于管理虚函数，<code>override</code> 确保派生类方法确实覆盖了基类虚函数，<code>final</code> 阻止派生类进一步覆盖虚函数或阻止类被继承。</li>
</ul>
<h3 id="18-1-8-模板和-STL-方面的修改"><a href="#18-1-8-模板和-STL-方面的修改" class="headerlink" title="18.1.8 模板和 STL 方面的修改"></a>18.1.8 模板和 STL 方面的修改</h3><p>C++11 对模板和标准库进行了大量增强：</p>
<ul>
<li><strong>基于范围的 <code>for</code> 循环:</strong> （第 5 章, 第 16 章）提供了简洁的遍历容器或序列的方式。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : v) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>  <strong><code>std::array</code>:</strong> （第 4 章, 第 16 章）提供了固定大小数组的模板类封装。</li>
<li>  <strong>无序关联容器:</strong> （第 16 章）引入了基于哈希表的 <code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, <code>unordered_multimap</code>。</li>
<li>  <strong><code>std::initializer_list</code>:</strong> （第 16 章）使得容器和其他类能够支持使用 <code>&#123;&#125;</code> 进行列表初始化。</li>
<li>  <strong>新的 STL 算法:</strong> 增加了一些新的算法（如 <code>copy_if</code>, <code>move</code>, <code>shuffle</code> 等）。</li>
<li>  <strong>Lambda 表达式:</strong> （第 16 章简单使用，第 18.4 节详细介绍）允许就地定义匿名函数对象。</li>
<li><strong>模板别名 (<code>using</code>):</strong> （第 14 章）提供了比 <code>typedef</code> 更清晰、更强大的为模板定义别名的方式。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;; <span class="comment">// Vec&lt;int&gt; 等价于 std::vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="18-1-9-右值引用"><a href="#18-1-9-右值引用" class="headerlink" title="18.1.9 右值引用"></a>18.1.9 右值引用</h3><p>(本节主要回顾，但右值引用和移动语义在 18.2 详细介绍，这里仅提及概念)<br>C++11 引入了一个重要的底层概念——<strong>右值引用 (Rvalue Reference)**，使用 <code>&amp;&amp;</code> 表示。右值引用主要用于实现</strong>移动语义 (Move Semantics)** 和**完美转发 (Perfect Forwarding)**。移动语义允许资源（如动态分配的内存）从一个对象“移动”到另一个对象，而不是进行昂贵的复制，这对于优化涉及临时对象或资源转移的操作至关重要（例如 <code>unique_ptr</code> 的所有权转移，<code>vector</code> 增长时的元素移动）。移动语义将在 18.2 节详细探讨。</p>
<p>这些 C++11 特性共同使得 C++ 代码可以写得更现代、更安全、更高效。</p>
<h2 id="18-2-移动语义和右值引用"><a href="#18-2-移动语义和右值引用" class="headerlink" title="18.2 移动语义和右值引用"></a>18.2 移动语义和右值引用</h2><p>C++11 引入了<strong>右值引用 (Rvalue Reference)</strong> 和**移动语义 (Move Semantics)**，这是 C++11 最重要的特性之一，旨在提高性能，特别是对于管理资源的类（如动态分配内存、文件句柄、网络连接等）。</p>
<h3 id="18-2-1-为何需要移动语义"><a href="#18-2-1-为何需要移动语义" class="headerlink" title="18.2.1 为何需要移动语义"></a>18.2.1 为何需要移动语义</h3><p>考虑一个管理动态内存的类，例如一个简单的字符串类或一个持有大缓冲区的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // for strlen, strcpy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LegacyBuffer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* buffer;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    LegacyBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;&quot;</span>) : size(<span class="built_in">std</span>::<span class="built_in">strlen</span>(s)), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor called for &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~LegacyBuffer() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor called for buffer at &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Constructor (Deep Copy)</span></span><br><span class="line">    LegacyBuffer(<span class="keyword">const</span> LegacyBuffer&amp; other) : size(other.size), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Constructor called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, other.buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Assignment Operator (Deep Copy)</span></span><br><span class="line">    LegacyBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> LegacyBuffer&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Assignment called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123; <span class="comment">// Self-assignment check</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer; <span class="comment">// Release old resource</span></span><br><span class="line">        size = other.size;</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]; <span class="comment">// Allocate new resource</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, other.buffer); <span class="comment">// Copy data</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer content: &quot;</span> &lt;&lt; (buffer ? buffer : <span class="string">&quot;null&quot;</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(LegacyBuffer&amp; first, LegacyBuffer&amp; second)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">         <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">         swap(first.size, second.size);</span><br><span class="line">         swap(first.buffer, second.buffer);</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer swapped via friend swap\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LegacyBuffer <span class="title">createBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LegacyBuffer(s); <span class="comment">// 返回一个临时对象 (rvalue)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++11 之前，当处理<strong>临时对象 (Temporary Objects)</strong> 或即将销毁的对象时，复制构造函数和复制赋值运算符会导致不必要的**深拷贝 (Deep Copy)**：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">LegacyBuffer <span class="title">b1</span><span class="params">(<span class="string">&quot;Original&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    LegacyBuffer b2 = b1; <span class="comment">// 调用复制构造函数 (深拷贝) - 合理，需要独立副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LegacyBuffer <span class="title">b3</span><span class="params">(<span class="string">&quot;Temporary Source&quot;</span>)</span></span>;</span><br><span class="line">    b1 = b3; <span class="comment">// 调用复制赋值运算符 (深拷贝) - 合理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题所在：处理临时对象</span></span><br><span class="line">    LegacyBuffer b4 = createBuffer(<span class="string">&quot;Temporary&quot;</span>); <span class="comment">// 1. createBuffer 返回临时对象</span></span><br><span class="line">                                                 <span class="comment">// 2. 临时对象被 *复制* 到 b4 (调用复制构造函数)</span></span><br><span class="line">                                                 <span class="comment">// 3. 临时对象被销毁</span></span><br><span class="line">                                                 <span class="comment">// (编译器优化 RVO/NRVO 可能消除这次复制，但概念上存在)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    b1 = createBuffer(<span class="string">&quot;Another Temp&quot;</span>); <span class="comment">// 1. createBuffer 返回临时对象</span></span><br><span class="line">                                       <span class="comment">// 2. 临时对象被 *复制* 赋值给 b1 (调用复制赋值)</span></span><br><span class="line">                                       <span class="comment">// 3. 临时对象被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在处理 <code>createBuffer</code> 返回的临时对象时，我们实际上只是想把临时对象内部管理的资源（<code>buffer</code> 指针和 <code>size</code>）<strong>转移</strong>给新的对象 (<code>b4</code> 或 <code>b1</code>)，因为临时对象马上就要被销毁了，它的资源没用了。进行深拷贝（重新分配内存并复制内容）是一种浪费。</p>
<p>移动语义就是为了解决这个问题：允许我们<strong>“窃取”</strong>或<strong>“移动”</strong>来自临时对象或明确标记为可移动对象的资源，而不是复制它们。</p>
<h3 id="右值引用-amp-amp"><a href="#右值引用-amp-amp" class="headerlink" title="右值引用 (&amp;&amp;)"></a>右值引用 (<code>&amp;&amp;</code>)</h3><p>为了区分可以安全“窃取”资源的临时对象和不能窃取的持久对象（左值），C++11 引入了**右值引用 (Rvalue Reference)**，用 <code>&amp;&amp;</code> 表示。</p>
<ul>
<li>  <strong>左值 (Lvalue):</strong> 通常指那些有名字、可以取地址、在表达式结束后仍然存在的对象。例如，变量名 <code>b1</code>, <code>b2</code>。</li>
<li>  <strong>右值 (Rvalue):</strong> 通常指那些临时的、没有名字、在表达式结束后即将销毁的值。例如，函数返回值 <code>createBuffer(&quot;Temporary&quot;)</code>，字面常量 <code>10</code>, <code>&quot;Hello&quot;</code>，算术表达式的结果 <code>x + y</code>。</li>
<li>  <strong>左值引用 (<code>&amp;</code>):</strong> 只能绑定到左值。<code>LegacyBuffer&amp; ref = b1;</code> (OK), <code>LegacyBuffer&amp; ref = createBuffer(&quot;Temp&quot;);</code> (错误!)。 (const 左值引用 <code>const LegacyBuffer&amp;</code> 是个例外，它可以绑定到右值)。</li>
<li>  <strong>右值引用 (<code>&amp;&amp;</code>):</strong> 只能绑定到右值。<code>LegacyBuffer&amp;&amp; rref = createBuffer(&quot;Temp&quot;);</code> (OK), <code>LegacyBuffer&amp;&amp; rref = b1;</code> (错误!)。</li>
</ul>
<p>右值引用 <code>&amp;&amp;</code> 的引入使得我们可以重载函数（特别是构造函数和赋值运算符），让它们能够区分接收的是左值还是右值，从而对右值（临时对象）采取不同的、更高效的操作（移动）。</p>
<h3 id="18-2-2-一个移动示例"><a href="#18-2-2-一个移动示例" class="headerlink" title="18.2.2 一个移动示例"></a>18.2.2 一个移动示例</h3><p>现在我们为 <code>LegacyBuffer</code> 类添加移动构造函数和移动赋值运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::move and std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModernBuffer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* buffer;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    ModernBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;&quot;</span>) : size(<span class="built_in">std</span>::<span class="built_in">strlen</span>(s)), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor called for &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~ModernBuffer() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor called for buffer at &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Constructor (Deep Copy)</span></span><br><span class="line">    ModernBuffer(<span class="keyword">const</span> ModernBuffer&amp; other) : size(other.size), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Constructor called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, other.buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Assignment Operator (Deep Copy)</span></span><br><span class="line">    ModernBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ModernBuffer&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Assignment called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 copy-and-swap idiom 更安全</span></span><br><span class="line">        <span class="function">ModernBuffer <span class="title">temp</span><span class="params">(other)</span></span>; <span class="comment">// 调用复制构造</span></span><br><span class="line">        swap(*<span class="keyword">this</span>, temp);        <span class="comment">// 交换资源</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 旧方式：</span></span><br><span class="line">        <span class="comment">// delete[] buffer;</span></span><br><span class="line">        <span class="comment">// size = other.size;</span></span><br><span class="line">        <span class="comment">// buffer = new char[size + 1];</span></span><br><span class="line">        <span class="comment">// std::strcpy(buffer, other.buffer);</span></span><br><span class="line">        <span class="comment">// return *this;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Move Constructor (C++11) ***</span></span><br><span class="line">    ModernBuffer(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span> <span class="comment">// 接收右值引用，标记为 noexcept</span></span><br><span class="line">        : size(other.size), buffer(other.buffer) <span class="comment">// 1. 窃取资源 (浅拷贝指针和大小)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Constructor called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 将源对象置于有效但可析构的状态 (通常是置空)</span></span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">        other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Move Assignment Operator (C++11) ***</span></span><br><span class="line">    ModernBuffer&amp; <span class="keyword">operator</span>=(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span> <span class="comment">// 接收右值引用，标记为 noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Assignment called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123; <span class="comment">// 自赋值检查 (虽然对右值不太可能，但保持良好习惯)</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 释放当前对象的资源</span></span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 窃取源对象的资源</span></span><br><span class="line">        size = other.size;</span><br><span class="line">        buffer = other.buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将源对象置于有效但可析构的状态</span></span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">        other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 或者使用 swap:</span></span><br><span class="line">        <span class="comment">// swap(*this, other);</span></span><br><span class="line">        <span class="comment">// return *this;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer content: &quot;</span> &lt;&lt; (buffer ? buffer : <span class="string">&quot;null&quot;</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ModernBuffer&amp; first, ModernBuffer&amp; second)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">         <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">         swap(first.size, second.size);</span><br><span class="line">         swap(first.buffer, second.buffer);</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer swapped via friend swap\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ModernBuffer <span class="title">createModernBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ModernBuffer(s); <span class="comment">// 返回临时对象 (rvalue)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ModernBuffer <span class="title">mb1</span><span class="params">(<span class="string">&quot;Original&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用移动构造函数 (因为 createModernBuffer 返回右值)</span></span><br><span class="line">    ModernBuffer mb2 = createModernBuffer(<span class="string">&quot;Temporary&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line">    mb2.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用移动赋值运算符 (因为 createModernBuffer 返回右值)</span></span><br><span class="line">    mb1 = createModernBuffer(<span class="string">&quot;Another Temp&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line">    mb1.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当用 <code>createModernBuffer</code> 返回的临时对象来初始化 <code>mb2</code> 或赋值给 <code>mb1</code> 时，会调用<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>。这些操作不再进行深拷贝，而是直接“窃取”临时对象的 <code>buffer</code> 指针，并将临时对象的指针置为 <code>nullptr</code>，避免了内存分配和数据复制，效率大大提高。</p>
<h3 id="18-2-3-移动构造函数解析"><a href="#18-2-3-移动构造函数解析" class="headerlink" title="18.2.3 移动构造函数解析"></a>18.2.3 移动构造函数解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ModernBuffer(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : size(other.size), buffer(other.buffer) <span class="comment">// 1. 窃取资源</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 将源对象置空</span></span><br><span class="line">    other.size = <span class="number">0</span>;</span><br><span class="line">    other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li> <strong>参数类型 <code>ModernBuffer&amp;&amp; other</code>:</strong> 接收一个右值引用，表示它只能绑定到右值（如临时对象）。</li>
<li> <strong>资源窃取:</strong> 构造函数通过初始化列表直接复制源对象 <code>other</code> 的指针 <code>buffer</code> 和大小 <code>size</code>。这是一个浅拷贝，非常快速。</li>
<li> <strong>置空源对象:</strong> <strong>关键步骤！</strong> 必须将源对象 <code>other</code> 的指针成员（<code>buffer</code>）设置为 <code>nullptr</code>（或其他有效但表示“空”状态的值）。这确保了当 <code>other</code>（临时对象）随后被析构时，它的析构函数 <code>delete[] buffer;</code> 不会释放已经被新对象“窃取”走的内存，从而避免了<strong>重复释放 (double free)</strong> 的错误。源对象必须被置于一个<strong>有效的、可析构的状态</strong>。</li>
<li> <strong><code>noexcept</code>:</strong> 移动操作通常<strong>不应该</strong>抛出异常（因为它们主要涉及指针和基本类型的赋值）。将移动构造函数和移动赋值运算符标记为 <code>noexcept</code> 非常重要。这允许 STL 容器等在需要重新分配内存时（如 <code>vector</code> 增长）安全地<strong>移动</strong>元素而不是复制它们，从而获得显著的性能提升。如果移动操作可能抛异常，STL 通常会回退到使用（保证异常安全的）复制操作。</li>
</ol>
<h3 id="18-2-4-赋值"><a href="#18-2-4-赋值" class="headerlink" title="18.2.4 赋值"></a>18.2.4 赋值</h3><p>移动赋值运算符的逻辑与移动构造函数类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ModernBuffer&amp; <span class="keyword">operator</span>=(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// ... 自赋值检查 ...</span></span><br><span class="line">    <span class="comment">// 1. 释放当前资源</span></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="comment">// 2. 窃取源资源</span></span><br><span class="line">    size = other.size;</span><br><span class="line">    buffer = other.buffer;</span><br><span class="line">    <span class="comment">// 3. 置空源对象</span></span><br><span class="line">    other.size = <span class="number">0</span>;</span><br><span class="line">    other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它首先释放自己当前持有的资源，然后窃取源对象的资源，最后将源对象置空。使用 <code>swap</code> 实现通常更简洁且能自动处理自赋值和异常安全（如果 <code>swap</code> 是 <code>noexcept</code> 的话）。</p>
<h3 id="18-2-5-强制移动-std-move"><a href="#18-2-5-强制移动-std-move" class="headerlink" title="18.2.5 强制移动 (std::move)"></a>18.2.5 强制移动 (<code>std::move</code>)</h3><p>移动构造函数和移动赋值运算符通常只对<strong>右值</strong>（如临时对象）起作用。但有时我们想从一个<strong>左值</strong>（有名字的对象）那里“窃取”资源，即使这个左值在之后还会存在（但我们明确知道不再需要它的资源了）。</p>
<p>例如，将一个大的 <code>vector</code> 的内容转移给另一个 <code>vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destination = source; // 这会调用复制赋值，复制所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们想移动 source 的内容到 destination，即使 source 是左值</span></span><br><span class="line"><span class="comment">// 使用 std::move() 将 source 强制转换为右值引用类型</span></span><br><span class="line">destination = <span class="built_in">std</span>::move(source);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，destination 拥有了原来的元素 &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// source 的状态是有效的，但内容未指定 (通常为空)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Source size after move: &quot;</span> &lt;&lt; source.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通常输出 0</span></span><br></pre></td></tr></table></figure>

<p><code>std::move</code> (定义在 <code>&lt;utility&gt;</code>) 本身<strong>并不执行任何移动操作</strong>。它只是一个<strong>类型转换</strong>，它无条件地将其实参（无论是左值还是右值）转换为<strong>右值引用类型</strong> (<code>T&amp;&amp;</code>)。</p>
<p>这个转换使得被转换的对象可以被绑定到接受右值引用的函数（如移动构造函数或移动赋值运算符），从而<strong>触发</strong>移动语义。</p>
<p><strong>使用 <code>std::move</code> 的注意事项:</strong></p>
<ul>
<li>  调用 <code>std::move(x)</code> 后，你不应该再对 <code>x</code> 的值做任何假设（除了它可以被安全地销毁或重新赋值）。它的资源可能已经被“偷走”了。</li>
<li>  只在你确定不再需要源对象（左值）的资源，或者源对象本身就是临时的（虽然对临时对象用 <code>std::move</code> 通常是多余的）时，才使用 <code>std::move</code>。</li>
</ul>
<p>移动语义和右值引用是 C++11 中实现资源高效转移的关键机制，对于编写高性能的 C++ 代码至关重要，尤其是在处理大型数据结构或管理系统资源时。</p>
<h2 id="18-3-新的类功能"><a href="#18-3-新的类功能" class="headerlink" title="18.3 新的类功能"></a>18.3 新的类功能</h2><p>C++11 不仅引入了移动语义，还对类的定义和使用方式进行了一些重要的增强，使得类的设计更加灵活和可控。</p>
<h3 id="18-3-1-特殊的成员函数"><a href="#18-3-1-特殊的成员函数" class="headerlink" title="18.3.1 特殊的成员函数"></a>18.3.1 特殊的成员函数</h3><p>对于一个类，编译器在特定条件下可以自动生成一些特殊的成员函数：</p>
<ol>
<li> <strong>默认构造函数 (Default Constructor):</strong> 如果你没有提供任何构造函数，编译器会生成一个。</li>
<li> <strong>析构函数 (Destructor):</strong> 如果你没有提供析构函数，编译器会生成一个。</li>
<li> <strong>复制构造函数 (Copy Constructor):</strong> 如果你没有提供复制构造函数，编译器会生成一个，执行逐成员复制。</li>
<li> <strong>复制赋值运算符 (Copy Assignment Operator):</strong> 如果你没有提供复制赋值运算符，编译器会生成一个，执行逐成员赋值。</li>
<li> <strong>移动构造函数 (Move Constructor) (C++11):</strong> 仅当<strong>没有</strong>显式声明任何复制操作（复制构造、复制赋值）<strong>且没有</strong>显式声明移动操作（移动构造、移动赋值）<strong>且没有</strong>显式声明析构函数时，编译器才会生成。它执行逐成员移动。</li>
<li> <strong>移动赋值运算符 (Move Assignment Operator) (C++11):</strong> 生成条件与移动构造函数类似。它执行逐成员移动。</li>
</ol>
<p><strong>规则总结 (Rule of Three/Five/Zero):</strong></p>
<ul>
<li>  <strong>Rule of Three (C++98):</strong> 如果你需要显式定义析构函数、复制构造函数或复制赋值运算符中的<strong>任何一个</strong>（通常是因为类管理了需要深拷贝或特殊清理的资源），那么你<strong>几乎肯定</strong>需要同时定义这三个。</li>
<li>  <strong>Rule of Five (C++11):</strong> 如果你需要显式定义上述三个中的任何一个，或者显式定义了移动构造函数或移动赋值运算符，那么你应该考虑定义或删除 (delete) <strong>所有五个</strong>（析构、复制构造、复制赋值、移动构造、移动赋值），以确保类的行为符合预期。因为显式定义任何一个复制/移动/析构函数都会阻止编译器自动生成移动操作。</li>
<li>  <strong>Rule of Zero (现代 C++ 推荐):</strong> 尽量设计你的类，使其<strong>不需要</strong>自定义析构函数、复制/移动构造函数或复制/移动赋值运算符。这通常通过使用 RAII（资源获取即初始化）原则和依赖标准库组件（如智能指针 <code>unique_ptr</code>, <code>shared_ptr</code> 和容器 <code>vector</code>, <code>string</code>）来实现，这些组件已经正确地处理了资源的复制、移动和释放。如果遵循 Rule of Zero，编译器生成的默认版本通常就能正常工作。</li>
</ul>
<h3 id="18-3-2-默认的方法和禁用的方法-default-delete"><a href="#18-3-2-默认的方法和禁用的方法-default-delete" class="headerlink" title="18.3.2 默认的方法和禁用的方法 (= default, = delete)"></a>18.3.2 默认的方法和禁用的方法 (<code>= default</code>, <code>= delete</code>)</h3><p>C++11 允许你更明确地控制特殊成员函数的生成：</p>
<ul>
<li><p><strong><code>= default</code>:</strong> 显式地告诉编译器生成该特殊成员函数的<strong>默认实现</strong>。即使因为你定义了其他构造函数或移动操作而导致编译器原本不会生成它，<code>= default</code> 也可以强制生成默认版本（如果可能的话）。这对于希望拥有默认行为但又需要自定义其他构造函数的情况很有用。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassDefault</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClassDefault(<span class="keyword">int</span> val) : data(val) &#123;&#125; <span class="comment">// 自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使定义了其他构造函数，仍显式要求编译器生成默认构造函数</span></span><br><span class="line">    MyClassDefault() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式要求编译器生成默认的复制构造函数</span></span><br><span class="line">    MyClassDefault(<span class="keyword">const</span> MyClassDefault&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// ... 其他特殊成员函数也可以 = default</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>= delete</code>:</strong> 显式地<strong>禁用</strong>某个成员函数（可以是特殊成员函数，也可以是普通成员函数）。如果代码尝试调用被 <code>= delete</code> 的函数，编译器会报错。这常用于阻止对象的复制或防止不期望的类型转换。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonCopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NonCopyable() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制构造函数</span></span><br><span class="line">    NonCopyable(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 禁用复制赋值运算符</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动操作通常仍可默认生成或显式 default</span></span><br><span class="line">    NonCopyable(NonCopyable&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(NonCopyable&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceManager</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr; <span class="comment">// unique_ptr 本身是不可复制的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ResourceManager(<span class="keyword">int</span> val) : ptr(<span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(val)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 由于 unique_ptr 不可复制，编译器不会生成默认的复制操作</span></span><br><span class="line">    <span class="comment">// 我们可以显式禁用它们，使意图更明确</span></span><br><span class="line">    ResourceManager(<span class="keyword">const</span> ResourceManager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ResourceManager&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResourceManager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动操作是允许的 (unique_ptr 可移动)</span></span><br><span class="line">    ResourceManager(ResourceManager&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ResourceManager&amp; <span class="keyword">operator</span>=(ResourceManager&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止通过整数进行隐式转换构造</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ResourceManager</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 禁止 long long 构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable nc1;</span><br><span class="line">    <span class="comment">// NonCopyable nc2 = nc1; // 编译错误！复制构造函数被删除</span></span><br><span class="line">    <span class="comment">// NonCopyable nc3;</span></span><br><span class="line">    <span class="comment">// nc3 = nc1;          // 编译错误！复制赋值运算符被删除</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ResourceManager <span class="title">rm1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ResourceManager rm2 = rm1; // 编译错误！</span></span><br><span class="line">    ResourceManager rm3 = <span class="built_in">std</span>::move(rm1); <span class="comment">// OK，移动构造函数是默认的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ResourceManager rm4(100LL); // 编译错误！long long 构造函数被删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>= default</code> 和 <code>= delete</code> 提高了代码的清晰度和对类行为的控制力。</p>
</li>
</ul>
<h3 id="18-3-3-委托构造函数"><a href="#18-3-3-委托构造函数" class="headerlink" title="18.3.3 委托构造函数"></a>18.3.3 委托构造函数</h3><p>C++11 允许一个构造函数调用<strong>同一个类</strong>的另一个构造函数，这称为**委托构造函数 (Delegating Constructor)**。这有助于减少构造函数之间的代码重复。</p>
<ul>
<li>  被委托的构造函数（目标构造函数）会先执行。</li>
<li>  目标构造函数执行完毕后，委托构造函数函数体内的代码（如果有的话）才会执行。</li>
<li>  委托调用必须出现在构造函数的<strong>初始化列表</strong>位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> content;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数 (执行实际初始化)</span></span><br><span class="line">    Report(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; t, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; c)</span><br><span class="line">        : id(i), title(t), content(c) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Target constructor called (id=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">        <span class="comment">// ... 可能还有其他初始化逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数 1: 提供默认 content</span></span><br><span class="line">    Report(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; t)</span><br><span class="line">        : Report(i, t, <span class="string">&quot;Default Content&quot;</span>) &#123; <span class="comment">// 委托给三个参数的构造函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delegating constructor 1 called.\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里可以添加此构造函数特有的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数 2: 提供默认 title 和 content</span></span><br><span class="line">    Report(<span class="keyword">int</span> i)</span><br><span class="line">        : Report(i, <span class="string">&quot;Default Title&quot;</span>) &#123; <span class="comment">// 委托给两个参数的构造函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delegating constructor 2 called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数 3: 提供所有默认值</span></span><br><span class="line">    Report()</span><br><span class="line">        : Report(<span class="number">0</span>) &#123; <span class="comment">// 委托给一个参数的构造函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delegating constructor 3 (default) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Title: &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot;, Content: &quot;</span> &lt;&lt; content &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r1:\n&quot;</span>;</span><br><span class="line">    <span class="function">Report <span class="title">r1</span><span class="params">(<span class="number">101</span>, <span class="string">&quot;Monthly Report&quot;</span>, <span class="string">&quot;Details...&quot;</span>)</span></span>; <span class="comment">// 调用目标构造</span></span><br><span class="line">    r1.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r2:\n&quot;</span>;</span><br><span class="line">    <span class="function">Report <span class="title">r2</span><span class="params">(<span class="number">102</span>, <span class="string">&quot;Weekly Update&quot;</span>)</span></span>; <span class="comment">// 调用委托构造 1 -&gt; 目标构造</span></span><br><span class="line">    r2.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r3:\n&quot;</span>;</span><br><span class="line">    <span class="function">Report <span class="title">r3</span><span class="params">(<span class="number">103</span>)</span></span>; <span class="comment">// 调用委托构造 2 -&gt; 委托构造 1 -&gt; 目标构造</span></span><br><span class="line">    r3.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r4:\n&quot;</span>;</span><br><span class="line">    Report r4; <span class="comment">// 调用委托构造 3 -&gt; 委托构造 2 -&gt; 委托构造 1 -&gt; 目标构造</span></span><br><span class="line">    r4.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>委托构造函数使得初始化逻辑可以集中在一个或少数几个构造函数中，其他构造函数只需提供默认值并委托即可。</p>
<h3 id="18-3-4-继承构造函数"><a href="#18-3-4-继承构造函数" class="headerlink" title="18.3.4 继承构造函数"></a>18.3.4 继承构造函数</h3><p>在 C++11 之前，如果派生类想使用基类的构造函数，它必须在自己的构造函数初始化列表中显式调用基类构造函数，并且为每个需要的基类构造函数签名提供一个对应的派生类构造函数。</p>
<p>C++11 允许派生类使用 <code>using</code> 声明来<strong>继承</strong>基类的构造函数（但有一些例外，如涉及虚基类的构造函数通常不被继承）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> v, <span class="built_in">std</span>::<span class="built_in">string</span> n) : value(v), name(n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base(int, string) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> v) : Base(v, <span class="string">&quot;DefaultName&quot;</span>) &#123; <span class="comment">// 使用委托构造</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base(int) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base() : Base(<span class="number">0</span>) &#123; <span class="comment">// 使用委托构造</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base() called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> extra_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 继承 Base 的所有构造函数</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 编译器会生成对应的 Derived 构造函数，它们调用匹配的 Base 构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以添加新的构造函数，或者覆盖继承来的构造函数 (如果签名相同)</span></span><br><span class="line">    Derived(<span class="keyword">double</span> d) : Base(<span class="number">999</span>, <span class="string">&quot;Special&quot;</span>), extra_data(d) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived(double) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要对继承来的构造函数添加额外初始化，需要显式定义</span></span><br><span class="line">    <span class="comment">// 例如，如果想让 Derived(int) 初始化 extra_data</span></span><br><span class="line">    Derived(<span class="keyword">int</span> v) : Base(v), extra_data(<span class="number">0.0</span>) &#123; <span class="comment">// 显式调用基类构造并初始化成员</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived(int) explicitly defined.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display_derived</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        display(); <span class="comment">// 调用基类的 display</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived - Extra Data: &quot;</span> &lt;&lt; extra_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d1:\n&quot;</span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;Object1&quot;</span>)</span></span>; <span class="comment">// 调用继承来的 Base(int, string) 对应的构造函数</span></span><br><span class="line">    d1.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d2:\n&quot;</span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 调用 Derived 自己定义的 Derived(int) 构造函数</span></span><br><span class="line">    d2.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d3:\n&quot;</span>;</span><br><span class="line">    Derived d3; <span class="comment">// 调用继承来的 Base() 对应的构造函数</span></span><br><span class="line">    d3.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d4:\n&quot;</span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d4</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// 调用 Derived 自己定义的 Derived(double) 构造函数</span></span><br><span class="line">    d4.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承构造函数简化了派生类的编写，特别是当基类有多个构造函数时，避免了编写大量仅仅是转发参数的派生类构造函数。</p>
<h3 id="18-3-5-管理虚方法：override-和-final"><a href="#18-3-5-管理虚方法：override-和-final" class="headerlink" title="18.3.5 管理虚方法：override 和 final"></a>18.3.5 管理虚方法：<code>override</code> 和 <code>final</code></h3><p>C++11 提供了两个新的**上下文关键字 (Contextual Keywords)**（只在特定位置有特殊含义，其他地方可用作标识符）来帮助管理类继承体系中的虚函数：<code>override</code> 和 <code>final</code>。</p>
<ul>
<li><p><strong><code>override</code>:</strong></p>
<ul>
<li>  显式地放在派生类中<strong>重写 (override)</strong> 的虚函数声明或定义之后。</li>
<li>  作用：让编译器检查该函数是否<strong>确实</strong>覆盖了基类中的某个虚函数（函数签名、<code>const</code> 限定符、引用限定符必须完全匹配）。</li>
<li>  如果派生类函数标记为 <code>override</code> 但并未覆盖任何基类虚函数（例如因为拼写错误、参数类型不匹配、<code>const</code> 不匹配），编译器会报错。</li>
<li>  这有助于防止因意外签名不匹配而导致的覆盖失败（变成隐藏或定义新函数）。</li>
</ul>
</li>
<li><p><strong><code>final</code> (用于虚函数):</strong></p>
<ul>
<li>  显式地放在派生类中<strong>重写</strong>的虚函数声明或定义之后。</li>
<li>  作用：阻止<strong>任何后续</strong>的派生类进一步覆盖这个虚函数。</li>
</ul>
</li>
<li><p><strong><code>final</code> (用于类):</strong></p>
<ul>
<li>  放在类定义的 <code>class</code> 关键字之后，类名之前或之后。</li>
<li>  作用：阻止该类被<strong>任何其他类继承</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing a generic document.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Saving generic document to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Document() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数很重要</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Report 继承自 Document</span></span><br><span class="line"><span class="comment">// Report 本身也禁止被进一步继承 (final class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 override 确保正确覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// OK，覆盖了基类的 print</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing a specific report.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void save(char* filename) override; // 编译错误！参数类型 const char* vs char* 不匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 final 阻止后续派生类覆盖 save</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Saving report securely to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void nonVirtualMethod() override; // 编译错误！基类没有这个虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 编译错误！Report 被标记为 final，不能被继承</span></span><br><span class="line"><span class="comment">class SpecialReport : public Report &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    // 编译错误！save 在 Report 中被标记为 final</span></span><br><span class="line"><span class="comment">    // void save(const char* filename) override &#123;</span></span><br><span class="line"><span class="comment">    //     std::cout &lt;&lt; &quot;Trying to save special report...\n&quot;;</span></span><br><span class="line"><span class="comment">    // &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Document* doc1 = <span class="keyword">new</span> Document();</span><br><span class="line">    Document* doc2 = <span class="keyword">new</span> Report();</span><br><span class="line"></span><br><span class="line">    doc1-&gt;print(); <span class="comment">// Output: Printing a generic document.</span></span><br><span class="line">    doc2-&gt;print(); <span class="comment">// Output: Printing a specific report. (多态)</span></span><br><span class="line"></span><br><span class="line">    doc1-&gt;save(<span class="string">&quot;doc.txt&quot;</span>);</span><br><span class="line">    doc2-&gt;save(<span class="string">&quot;report.txt&quot;</span>); <span class="comment">// 调用 Report::save</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> doc1;</span><br><span class="line">    <span class="keyword">delete</span> doc2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>override</code> 和 <code>final</code> 提高了代码的健壮性和可维护性，使得在复杂的继承体系中更容易正确地管理虚函数，并明确设计意图。</p>
<h2 id="18-4-Lambda-函数"><a href="#18-4-Lambda-函数" class="headerlink" title="18.4 Lambda 函数"></a>18.4 Lambda 函数</h2><p>C++11 引入了一个非常强大的特性：<strong>Lambda 表达式 (Lambda Expression)**，通常简称为 **Lambda 函数</strong> 或 <strong>Lambda</strong>。Lambda 表达式允许我们在需要可调用对象（如函数指针、函数对象）的地方<strong>就地定义一个匿名的函数对象</strong>。</p>
<p>Lambda 的主要目的是提供一种简洁的方式来定义简短的、通常只在局部范围内使用的函数或操作，特别是在将它们作为参数传递给 STL 算法时。</p>
<h3 id="Lambda-表达式语法"><a href="#Lambda-表达式语法" class="headerlink" title="Lambda 表达式语法"></a>Lambda 表达式语法</h3><p>Lambda 表达式的基本语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture_clause](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>[capture_clause]</code> (捕获子句):</strong> 这是 Lambda 表达式的开始。方括号 <code>[]</code> 用于指定如何从<strong>定义 Lambda 的外部作用域</strong>捕获变量（即让 Lambda 内部可以访问外部变量）。<ul>
<li>  <code>[]</code>: 不捕获任何外部变量。</li>
<li>  <code>[=]</code>: 以<strong>值拷贝</strong>方式捕获所有外部作用域中的<strong>自动变量</strong>（局部变量和参数）。</li>
<li>  <code>[&amp;]</code>: 以<strong>引用</strong>方式捕获所有外部作用域中的<strong>自动变量</strong>。</li>
<li>  <code>[var]</code>: 以<strong>值拷贝</strong>方式捕获指定的变量 <code>var</code>。</li>
<li>  <code>[&amp;var]</code>: 以<strong>引用</strong>方式捕获指定的变量 <code>var</code>。</li>
<li>  <code>[this]</code>: 捕获当前对象的 <code>this</code> 指针（仅在类的非静态成员函数内部有效）。</li>
<li>  可以混合使用，例如 <code>[=, &amp;var1, &amp;var2]</code> (默认值捕获，但 <code>var1</code> 和 <code>var2</code> 引用捕获)，<code>[&amp;, var1, var2]</code> (默认引用捕获，但 <code>var1</code> 和 <code>var2</code> 值捕获)。</li>
</ul>
</li>
<li>  <strong><code>(parameters)</code> (参数列表):</strong> 可选。与普通函数的参数列表类似，定义 Lambda 接受的参数。如果 Lambda 不需要参数，可以省略 <code>()</code>。</li>
<li>  <strong><code>-&gt; return_type</code> (返回类型):</strong> 可选。用于显式指定 Lambda 的返回类型。如果省略，编译器会尝试根据函数体中的 <code>return</code> 语句自动推断返回类型（如果函数体只有一个 <code>return</code> 语句，或者所有 <code>return</code> 语句返回相同类型，或者没有 <code>return</code> 语句则推断为 <code>void</code>）。如果无法推断或需要特定类型，则必须显式指定。</li>
<li>  <strong><code>&#123; function body &#125;</code> (函数体):</strong> 包含 Lambda 执行的代码，与普通函数的函数体类似。</li>
</ul>
<p><strong>最简单的 Lambda:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello Lambda!\n&quot;</span>; &#125; <span class="comment">// 一个不捕获、不接受参数、无返回值的 Lambda</span></span><br></pre></td></tr></table></figure>

<p><strong>Lambda 的类型:</strong> 每个 Lambda 表达式都会生成一个<strong>唯一的、未命名的函数对象类型</strong>。这意味着即使两个 Lambda 表达式的文本完全相同，它们的类型也是不同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = []()&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> lambda2 = []()&#123;&#125;;</span><br><span class="line"><span class="comment">// decltype(lambda1) != decltype(lambda2)</span></span><br></pre></td></tr></table></figure>
<p>我们可以将 Lambda 赋值给 <code>auto</code> 变量，或者存储在 <code>std::function</code> 包装器中。</p>
<h3 id="18-4-1-比较函数指针、函数符和-Lambda-函数"><a href="#18-4-1-比较函数指针、函数符和-Lambda-函数" class="headerlink" title="18.4.1 比较函数指针、函数符和 Lambda 函数"></a>18.4.1 比较函数指针、函数符和 Lambda 函数</h3><p>在需要传递可调用实体的场景（如 STL 算法）中，我们可以使用函数指针、函数对象（函数符）或 Lambda 函数。</p>
<ul>
<li><strong>函数指针:</strong><ul>
<li>  优点：语法简单，对于已存在的普通函数很方便。</li>
<li>  缺点：不能携带状态，通常无法内联，灵活性差。</li>
</ul>
</li>
<li><strong>函数对象 (Functor):</strong><ul>
<li>  优点：可以携带状态（通过成员变量），可以内联，类型安全。</li>
<li>  缺点：需要单独定义一个类，代码相对冗长，特别是对于简单的操作。</li>
</ul>
</li>
<li><strong>Lambda 函数:</strong><ul>
<li>  优点：语法简洁，可以直接在调用点定义，易于阅读；可以通过捕获子句方便地访问（携带）外部状态；通常可以内联；功能强大灵活。</li>
<li>  缺点：对于复杂或需要在多处重用的逻辑，单独定义函数或函数对象可能更清晰。</li>
</ul>
</li>
</ul>
<p><strong>示例对比 (用于 <code>std::sort</code> 的自定义比较):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareDescendingPtr</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompareDescendingFunctor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_copy1 = v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_copy2 = v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_copy3 = v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v_copy1.begin(), v_copy1.end(), compareDescendingPtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v_copy2.begin(), v_copy2.end(), CompareDescendingFunctor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 函数排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v_copy3.begin(), v_copy3.end(),</span><br><span class="line">              [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &gt; b; &#125; <span class="comment">// -&gt; bool 可省略</span></span><br><span class="line">             );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted (ptr): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v_copy1) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted (functor): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v_copy2) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted (lambda): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v_copy3) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Lambda 表达式提供了最简洁的语法，将比较逻辑直接写在了 <code>sort</code> 调用处。</p>
<h3 id="18-4-2-为何使用-lambda"><a href="#18-4-2-为何使用-lambda" class="headerlink" title="18.4.2 为何使用 lambda"></a>18.4.2 为何使用 lambda</h3><p>Lambda 表达式的主要优势在于其<strong>简洁性</strong>和<strong>局部性</strong>。</p>
<ol>
<li><p> <strong>简洁性:</strong> 对于只需要一两行代码的简单操作或谓词，定义一个完整的函数或函数对象类显得过于繁琐。Lambda 允许用非常紧凑的语法直接表达这些逻辑。</p>
</li>
<li><p> <strong>局部性:</strong> Lambda 可以直接定义在使用它的地方（例如，作为算法的参数）。这使得代码更易于阅读和理解，因为操作逻辑和调用它的代码紧密地放在一起，不需要跳转到其他地方去查找函数或类的定义。</p>
</li>
<li><p> <strong>状态捕获:</strong> Lambda 的捕获机制提供了一种非常方便的方式来访问定义 Lambda 时所处作用域的局部变量，而无需手动将这些变量包装到函数对象中。</p>
</li>
</ol>
<p><strong>示例 (使用捕获):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 lambda 查找所有大于 threshold 的数，并复制到 results</span></span><br><span class="line">    <span class="comment">// 捕获 threshold (值拷贝) 和 results (引用)</span></span><br><span class="line">    <span class="built_in">std</span>::for_each(nums.begin(), nums.end(),</span><br><span class="line">                  [threshold, &amp;results](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (x &gt; threshold) &#123;</span><br><span class="line">                          results.push_back(x); <span class="comment">// 可以修改引用捕获的 results</span></span><br><span class="line">                          <span class="comment">// threshold = 10; // 编译错误！值捕获的变量默认是 const 的</span></span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers greater than &quot;</span> &lt;&lt; threshold &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r : results) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 6 7 8 9 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 mutable lambda (允许修改值捕获的变量的副本)</span></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> mutable_lambda = [counter]() <span class="keyword">mutable</span> &#123; <span class="comment">// 使用 mutable</span></span><br><span class="line">        counter++; <span class="comment">// 现在可以修改 counter 的副本了</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda counter (copy): &quot;</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mutable_lambda(); <span class="comment">// 输出 1</span></span><br><span class="line">    mutable_lambda(); <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original counter: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 (原始 counter 未变)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示引用捕获修改外部变量</span></span><br><span class="line">    <span class="keyword">int</span> external_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(nums.begin(), nums.end(),</span><br><span class="line">                  [&amp;external_sum](<span class="keyword">int</span> x)&#123; <span class="comment">// 引用捕获</span></span><br><span class="line">                      external_sum += x;</span><br><span class="line">                  &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum calculated via lambda: &quot;</span> &lt;&lt; external_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 55</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>mutable</code> 关键字:</strong> 默认情况下，通过<strong>值捕获</strong>的变量在 Lambda 函数体内部是 <code>const</code> 的，不能被修改。如果你需要在 Lambda 内部修改值捕获变量的<strong>副本</strong>（这种修改不会影响外部原始变量），可以在参数列表 <code>()</code> 之后（或捕获列表 <code>[]</code> 之后，如果没有参数）加上 <code>mutable</code> 关键字。</p>
<p>Lambda 表达式是现代 C++ 中编写简洁、高效且易读代码的重要工具，尤其是在与 STL 算法结合使用时。</p>
<h2 id="18-5-包装器"><a href="#18-5-包装器" class="headerlink" title="18.5 包装器"></a>18.5 包装器</h2><p>在 C++ 中，有多种“可调用 (Callable)”的实体：普通函数、函数指针、函数对象（Functors）、Lambda 表达式、类的成员函数指针等。虽然它们都可以被调用，但它们的<strong>类型</strong>各不相同。这在需要存储或传递未知类型的可调用实体时会带来不便。</p>
<p>例如，你可能想创建一个回调函数列表，列表中的函数可以来自不同的源（有些是普通函数，有些是 Lambda，有些是对象的成员函数），但它们都接受相同的参数并返回相同的类型。如何用一个统一的类型来存储它们呢？</p>
<p>C++11 在 <code>&lt;functional&gt;</code> 头文件中提供了 <code>std::function</code> 模板类，它是一个通用的、多态的<strong>函数包装器 (Function Wrapper)**。<code>std::function</code> 的对象可以</strong>存储、复制和调用**任何符合其指定函数签名的可调用实体。</p>
<h3 id="18-5-1-包装器-function"><a href="#18-5-1-包装器-function" class="headerlink" title="18.5.1 包装器 function"></a>18.5.1 包装器 <code>function</code></h3><p><code>std::function</code> 的模板参数是它所要包装的函数的**签名 (Signature)**。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;ReturnType(ArgType1, ArgType2, ...)&gt; func_wrapper;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>ReturnType</code>: 被包装函数的返回类型。</li>
<li>  <code>ArgType1, ArgType2, ...</code>: 被包装函数接受的参数类型列表。</li>
</ul>
<p><strong>基本用法:</strong></p>
<p>你可以将任何具有兼容签名的可调用实体赋值给 <code>std::function</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function Pointer: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数对象 (Functor)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> prefix;</span><br><span class="line">    Printer(<span class="built_in">std</span>::<span class="built_in">string</span> p) : prefix(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Functor (&quot;</span> &lt;&lt; prefix &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 类的成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Greeter</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member Function: Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个可以包装 void(const std::string&amp;) 类型函数的 std::function</span></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)&gt; callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a) 包装普通函数指针</span></span><br><span class="line">    callback = print_message;</span><br><span class="line">    callback(<span class="string">&quot;Hello from function pointer!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b) 包装 Lambda 表达式</span></span><br><span class="line">    callback = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    callback(<span class="string">&quot;Hello from lambda!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c) 包装函数对象</span></span><br><span class="line">    <span class="function">Printer <span class="title">my_printer</span><span class="params">(<span class="string">&quot;LOG&quot;</span>)</span></span>;</span><br><span class="line">    callback = my_printer; <span class="comment">// Functor 对象可以直接赋值</span></span><br><span class="line">    callback(<span class="string">&quot;Hello from functor!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d) 包装类的成员函数 (需要绑定对象)</span></span><br><span class="line">    Greeter greeter_obj;</span><br><span class="line">    <span class="comment">// 使用 std::bind (或者 Lambda) 来绑定 this 指针</span></span><br><span class="line">    callback = <span class="built_in">std</span>::bind(&amp;Greeter::greet, &amp;greeter_obj, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">    <span class="comment">// 或者使用 Lambda 捕获对象</span></span><br><span class="line">    <span class="comment">// callback = [&amp;greeter_obj](const std::string&amp; name)&#123; greeter_obj.greet(name); &#125;;</span></span><br><span class="line">    callback(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 调用 greeter_obj.greet(&quot;Alice&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 std::function 是否为空 (是否持有可调用对象)</span></span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Callback is holding a callable entity.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 std::function</span></span><br><span class="line">    callback = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!callback) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Callback is now empty.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储不同类型的回调函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)&gt;&gt; callbacks;</span><br><span class="line">    callbacks.push_back(print_message);</span><br><span class="line">    callbacks.push_back([](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Another Lambda: &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;);</span><br><span class="line">    callbacks.push_back(my_printer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Calling stored callbacks ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cb : callbacks) &#123;</span><br><span class="line">        cb(<span class="string">&quot;Test message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::function</code> 通过<strong>类型擦除 (Type Erasure)</strong> 技术实现了这种通用性。它内部可以存储不同类型的可调用对象，并在调用时通过某种机制（通常涉及堆分配和虚函数调用，特别是对于捕获了数据的 Lambda 或大型函数对象）来执行实际的调用。</p>
<h3 id="18-5-1-续-function-及模板的低效性-潜在开销"><a href="#18-5-1-续-function-及模板的低效性-潜在开销" class="headerlink" title="18.5.1 (续) function 及模板的低效性 (潜在开销)"></a>18.5.1 (续) <code>function</code> 及模板的低效性 (潜在开销)</h3><p>虽然 <code>std::function</code> 非常灵活，但这种灵活性是有代价的：</p>
<ol>
<li><p><strong>类型擦除开销:</strong> 为了能够存储任意类型的可调用对象，<code>std::function</code> 通常需要在内部处理类型信息。这可能涉及到：</p>
<ul>
<li>  <strong>堆分配:</strong> 如果被包装的可调用对象（特别是带捕获的 Lambda 或函数对象）比较大，或者不能通过“小对象优化 (Small Object Optimization, SOO)”直接存储在 <code>std::function</code> 对象内部，就可能需要在堆上分配内存来存储它。堆分配和释放是有开销的。</li>
<li>  <strong>间接调用:</strong> 调用存储在 <code>std::function</code> 中的函数通常需要通过指针或虚函数进行间接调用，这比直接函数调用或模板实例化产生的内联调用要慢。</li>
</ul>
</li>
<li><p><strong>相比模板的低效性:</strong> 如果在编译时就知道具体的可调用类型，使用<strong>模板</strong>通常会更高效。模板允许编译器为每种具体的类型生成专门的代码，并且更容易进行内联优化，避免了 <code>std::function</code> 的类型擦除和间接调用开销。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用模板，更高效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_with_template</span><span class="params">(Callable func, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    func(data); <span class="comment">// 直接调用，可能内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::function，更灵活，但可能有开销</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_with_function</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)&gt; func, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    func(data); <span class="comment">// 间接调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> my_lambda = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)&#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">    process_with_template(my_lambda, <span class="string">&quot;data&quot;</span>); <span class="comment">// 高效</span></span><br><span class="line">    process_with_function(my_lambda, <span class="string">&quot;data&quot;</span>); <span class="comment">// 灵活，但可能稍慢</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>何时使用 <code>std::function</code>？</strong></p>
<ul>
<li>  当你需要在<strong>运行时</strong>确定要调用哪个函数，或者需要存储<strong>不同类型</strong>的可调用对象在同一个容器中时（如回调系统、事件处理）。</li>
<li>  当你需要定义一个接受<strong>任何</strong>符合特定签名的可调用对象的接口时。</li>
</ul>
<p><strong>何时避免使用 <code>std::function</code> (如果性能是关键)？</strong></p>
<ul>
<li>  当你在编译时就知道具体的可调用类型时，优先使用模板或直接调用。</li>
<li>  在性能极其敏感的代码路径中（如紧密循环内部），需要仔细评估 <code>std::function</code> 带来的开销。</li>
</ul>
<h3 id="18-5-2-修复问题-18-5-3-其他方式"><a href="#18-5-2-修复问题-18-5-3-其他方式" class="headerlink" title="18.5.2 修复问题 / 18.5.3 其他方式"></a>18.5.2 修复问题 / 18.5.3 其他方式</h3><p>这里的“修复问题”主要是指理解 <code>std::function</code> 的开销并根据场景选择合适的技术。“其他方式”则包括：</p>
<ol>
<li><p> <strong>使用模板:</strong> 如上所述，当类型在编译时已知时，模板是最高效的选择。</p>
</li>
<li><p> <strong>使用函数指针:</strong> 对于简单的、无状态的函数，直接使用函数指针类型 <code>ReturnType(*)(ArgTypes...)</code> 仍然是有效的，并且开销很小。</p>
</li>
<li><p> <strong>使用 Lambda:</strong> Lambda 本身是高效的（它们是匿名的函数对象）。只有当它们被存储在 <code>std::function</code> 中时，才可能引入 <code>std::function</code> 的开销。如果可以将 Lambda 直接传递给模板化的函数（如 STL 算法），通常不会有额外开销。</p>
</li>
<li><p><strong><code>std::bind</code>:</strong> (在 <code>&lt;functional&gt;</code> 中) <code>std::bind</code> 可以用来绑定函数的参数（包括成员函数的 <code>this</code> 指针）或重新排列参数顺序，生成一个新的可调用对象 (函数对象)。虽然 <code>std::bind</code> 也能被 <code>std::function</code> 存储，但现代 C++ 中，Lambda 通常提供了更简洁、更易读的方式来完成类似的任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为 100，第二个参数由调用者提供 (_1)，第三个参数为 300</span></span><br><span class="line">    <span class="keyword">auto</span> bound_func = <span class="built_in">std</span>::bind(func, <span class="number">100</span>, <span class="built_in">std</span>::placeholders::_1, <span class="number">300</span>);</span><br><span class="line">    bound_func(<span class="number">200</span>); <span class="comment">// 调用 func(100, 200, 300)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 实现相同效果</span></span><br><span class="line">    <span class="keyword">auto</span> lambda_func = [](<span class="keyword">int</span> b)&#123; func(<span class="number">100</span>, b, <span class="number">300</span>); &#125;;</span><br><span class="line">    lambda_func(<span class="number">200</span>); <span class="comment">// 调用 func(100, 200, 300)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>std::ref</code> 和 <code>std::cref</code>:</strong> (在 <code>&lt;functional&gt;</code> 中) 当你想通过值传递的包装器（如 <code>std::bind</code>, <code>std::thread</code> 构造函数, 甚至某些情况下的 <code>std::function</code>）传递参数的<strong>引用</strong>时，需要使用 <code>std::ref</code> (用于非 const 引用) 或 <code>std::cref</code> (用于 const 引用) 来包装参数。它们创建了一个轻量级的引用包装器对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_vector</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123; <span class="comment">// 接受引用</span></span><br><span class="line">    <span class="keyword">if</span> (!vec.empty()) &#123;</span><br><span class="line">        vec[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; my_vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::bind 默认按值复制参数</span></span><br><span class="line">    <span class="comment">// auto bound_copy = std::bind(modify_vector, my_vec); // 错误或无效，bind 复制了 vector</span></span><br><span class="line">    <span class="comment">// bound_copy(); // 修改的是副本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::ref 传递引用</span></span><br><span class="line">    <span class="keyword">auto</span> bound_ref = <span class="built_in">std</span>::bind(modify_vector, <span class="built_in">std</span>::ref(my_vec));</span><br><span class="line">    bound_ref(); <span class="comment">// 正确调用 modify_vector(my_vec)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after bind+ref: &quot;</span> &lt;&lt; my_vec[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::thread 构造函数也复制参数，需要 std::ref 传递引用</span></span><br><span class="line">    my_vec[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// Reset</span></span><br><span class="line">    <span class="comment">// std::thread t1(modify_vector, my_vec); // 线程操作的是 my_vec 的副本</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(modify_vector, <span class="built_in">std</span>::ref(my_vec))</span></span>; <span class="comment">// 线程操作的是 my_vec 的引用</span></span><br><span class="line">    <span class="comment">// t1.join();</span></span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after thread+ref: &quot;</span> &lt;&lt; my_vec[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>总之，<code>std::function</code> 是一个强大的通用函数包装器，提供了极大的灵活性，但在性能敏感的场景下需要注意其潜在开销，并考虑使用模板、函数指针或直接传递 Lambda 等替代方案。</p>
<h2 id="18-6-可变参数模板"><a href="#18-6-可变参数模板" class="headerlink" title="18.6 可变参数模板"></a>18.6 可变参数模板</h2><p>在 C++11 之前，模板（函数模板和类模板）通常只能接受固定数量的模板参数。如果你想编写一个可以接受任意数量参数的函数（类似于 C 语言中的 <code>printf</code>），通常需要依赖 C 风格的可变参数机制 (<code>&lt;cstdarg&gt;</code>)，这种机制不是类型安全的。</p>
<p>C++11 引入了<strong>可变参数模板 (Variadic Templates)**，允许模板（包括函数模板和类模板）接受</strong>任意数量、任意类型**的模板参数，并在编译时进行类型安全的处理。</p>
<h3 id="18-6-1-模板和函数参数包"><a href="#18-6-1-模板和函数参数包" class="headerlink" title="18.6.1 模板和函数参数包"></a>18.6.1 模板和函数参数包</h3><p>可变参数模板的核心是**参数包 (Parameter Pack)**。参数包有两种：</p>
<ol>
<li><p><strong>模板参数包 (Template Parameter Pack):</strong> 代表零个或多个模板参数（类型参数、非类型参数或模板参数）。</p>
<ul>
<li>  语法：<code>typename... Args</code> 或 <code>class... Args</code> (对于类型参数包)，<code>Type... args</code> (对于非类型参数包)。</li>
<li>  <code>...</code> (省略号) 是关键部分，表示这是一个参数包。</li>
</ul>
</li>
<li><p><strong>函数参数包 (Function Parameter Pack):</strong> 代表零个或多个函数参数。</p>
<ul>
<li>  语法：<code>Args... args</code>，其中 <code>Args</code> 是一个模板参数包。</li>
</ul>
</li>
</ol>
<p><strong>示例：定义一个接受任意数量参数的函数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义可变参数函数模板 show_list</span></span><br><span class="line"><span class="comment">// Args 是一个模板参数包 (代表零个或多个类型)</span></span><br><span class="line"><span class="comment">// args 是一个函数参数包 (代表零个或多个对应类型的参数)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如何处理 args？见下文</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of arguments: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 或者 sizeof...(args) 也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    show_list();                 <span class="comment">// Args 为空, args 为空. 输出: Number of arguments: 0</span></span><br><span class="line">    show_list(<span class="number">1</span>);                <span class="comment">// Args = &#123;int&#125;, args = &#123;1&#125;. 输出: Number of arguments: 1</span></span><br><span class="line">    show_list(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);       <span class="comment">// Args = &#123;int, const char*&#125;, args = &#123;1, &quot;hello&quot;&#125;. 输出: Number of arguments: 2</span></span><br><span class="line">    show_list(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&#x27;c&#x27;</span>);     <span class="comment">// Args = &#123;int, double, char&#125;, args = &#123;1, 3.14, &#x27;c&#x27;&#125;. 输出: Number of arguments: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sizeof...(Args)</code> 或 <code>sizeof...(args)</code> 运算符可以在编译时获取参数包中的参数数量。</p>
<h3 id="18-6-2-展开参数包"><a href="#18-6-2-展开参数包" class="headerlink" title="18.6.2 展开参数包"></a>18.6.2 展开参数包</h3><p>仅仅能接受任意数量的参数还不够，我们还需要一种方法来<strong>处理 (展开, Unpack)</strong> 参数包中的每一个参数。在 C++11 中，展开参数包通常需要使用<strong>递归 (Recursion)</strong> 或其他一些模板技巧。C++17 引入了更简洁的**折叠表达式 (Fold Expressions)**，但这里我们主要关注 C++11 的方法。</p>
<p>展开参数包的关键在于<strong>模式匹配</strong>和<strong>递归调用</strong>：设计一个函数模板，它处理参数包中的第一个参数，然后用剩余的参数递归调用自身。还需要一个处理参数包为空（递归终止）的基本情况。</p>
<h3 id="18-6-3-在可变参数模板函数中使用递归"><a href="#18-6-3-在可变参数模板函数中使用递归" class="headerlink" title="18.6.3 在可变参数模板函数中使用递归"></a>18.6.3 在可变参数模板函数中使用递归</h3><p>最常见的展开方式是定义两个函数模板：</p>
<ol>
<li> 一个<strong>递归</strong>版本，接受至少一个参数，处理第一个参数，然后用剩余参数调用自身。</li>
<li> 一个<strong>基本情况</strong>版本，接受零个参数，作为递归的终止条件。</li>
</ol>
<p><strong>示例：递归打印所有参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当参数包为空时调用此版本，终止递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 递归结束时打印换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本：处理第一个参数，然后用剩余参数递归调用</span></span><br><span class="line"><span class="comment">// Args 是模板参数包 (代表剩余参数的类型)</span></span><br><span class="line"><span class="comment">// args 是函数参数包 (代表剩余参数的值)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_values</span><span class="params">(<span class="keyword">const</span> T&amp; first_arg, <span class="keyword">const</span> Args&amp;... rest_args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 处理第一个参数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果还有剩余参数，打印分隔符并递归调用</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(Args) &gt; <span class="number">0</span>)</span> </span>&#123; <span class="comment">// C++17 if constexpr, 简化条件编译</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        print_values(rest_args...); <span class="comment">// 将剩余参数包展开并传递给下一次调用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print_values(); <span class="comment">// 调用基本情况版本，打印换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 写法 (没有 if constexpr):</span></span><br><span class="line">    <span class="comment">// if (sizeof...(Args) &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// print_values(rest_args...); // 递归调用，最终会调用到 print_values() 版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing values:\n&quot;</span>;</span><br><span class="line">    print_values(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 输出: 1, hello, 3.14, a</span></span><br><span class="line">    print_values(<span class="string">&quot;Single argument&quot;</span>);      <span class="comment">// 输出: Single argument</span></span><br><span class="line">    print_values();                       <span class="comment">// 输出: (空行)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用过程分析 <code>print_values(1, &quot;hello&quot;, 3.14, &#39;a&#39;)</code>:</strong></p>
<ol>
<li>调用 <code>print_values&lt;int, const char*, double, char&gt;(1, &quot;hello&quot;, 3.14, &#39;a&#39;)</code><ul>
<li>  <code>first_arg</code> = 1, <code>rest_args...</code> = {“hello”, 3.14, ‘a’}</li>
<li>  输出 “1, “</li>
<li>  递归调用 <code>print_values(&quot;hello&quot;, 3.14, &#39;a&#39;)</code></li>
</ul>
</li>
<li>调用 <code>print_values&lt;const char*, double, char&gt;(&quot;hello&quot;, 3.14, &#39;a&#39;)</code><ul>
<li>  <code>first_arg</code> = “hello”, <code>rest_args...</code> = {3.14, ‘a’}</li>
<li>  输出 “hello, “</li>
<li>  递归调用 <code>print_values(3.14, &#39;a&#39;)</code></li>
</ul>
</li>
<li>调用 <code>print_values&lt;double, char&gt;(3.14, &#39;a&#39;)</code><ul>
<li>  <code>first_arg</code> = 3.14, <code>rest_args...</code> = {‘a’}</li>
<li>  输出 “3.14, “</li>
<li>  递归调用 <code>print_values(&#39;a&#39;)</code></li>
</ul>
</li>
<li>调用 <code>print_values&lt;char&gt;(&#39;a&#39;)</code><ul>
<li>  <code>first_arg</code> = ‘a’, <code>rest_args...</code> = {} (空包)</li>
<li>  输出 “a”</li>
<li>  递归调用 <code>print_values()</code></li>
</ul>
</li>
<li>调用 <code>print_values()</code> (基本情况)<ul>
<li>  输出 <code>std::endl</code></li>
<li>  递归结束</li>
</ul>
</li>
</ol>
<p><strong>展开语法 <code>rest_args...</code>:</strong> 当在函数调用中对函数参数包使用 <code>...</code> 时，它会将包中的每个元素展开，作为独立的参数传递给函数。</p>
<p><strong>其他展开技巧 (C++11):</strong></p>
<p>虽然递归是最常见的方式，但也可以使用其他技巧，例如利用初始化列表或数组的逗号运算符特性来展开，但这些技巧通常更复杂且可读性较差。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始化列表展开 (技巧性较强)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_values_trick</span><span class="params">(<span class="keyword">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个临时 int 数组，利用初始化列表和逗号运算符</span></span><br><span class="line">    <span class="comment">// 对包中的每个参数执行 (std::cout &lt;&lt; arg &lt;&lt; &quot; &quot;, 0)</span></span><br><span class="line">    <span class="comment">// 结果是 &#123;0, 0, 0, ...&#125;，但副作用是打印了参数</span></span><br><span class="line">    <span class="keyword">int</span> dummy[] = &#123;<span class="number">0</span>, ( (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), <span class="number">0</span> )... &#125;;</span><br><span class="line">    <span class="comment">// (void)dummy; // 避免未使用变量警告 (可选)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     print_values_trick(<span class="number">10</span>, <span class="string">&quot;world&quot;</span>, <span class="number">0.5</span>); <span class="comment">// 输出: 10 world 0.5</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种技巧利用了 C++11 中 <code>...</code> 可以在表达式中展开参数包的特性 <code>(pattern)...</code>，其中 <code>pattern</code> 会对包中的每个元素应用一次。</p>
<p>可变参数模板是 C++ 元编程和泛型编程的强大工具，使得编写能够处理任意数量参数的类型安全函数（如自定义的 <code>printf</code>、<code>make_tuple</code>、<code>emplace_back</code> 等）成为可能。</p>
<h2 id="18-7-C-11新增的其他功能"><a href="#18-7-C-11新增的其他功能" class="headerlink" title="18.7 C++11新增的其他功能"></a>18.7 C++11新增的其他功能</h2><p>除了前面章节已经详细讨论或回顾的主要特性（如 <code>auto</code>, <code>nullptr</code>, 统一初始化, 移动语义, Lambda, 智能指针, 范围 <code>for</code>, 新类功能, 可变参数模板等）之外，C++11 标准还引入了许多其他重要的功能和库，进一步增强了语言的能力。本节将简要介绍其中的一些。</p>
<h3 id="18-7-1-并行编程"><a href="#18-7-1-并行编程" class="headerlink" title="18.7.1 并行编程"></a>18.7.1 并行编程</h3><p>C++11 首次在标准库层面提供了对<strong>多线程并发编程</strong>的支持，主要定义在 <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;condition_variable&gt;</code>, <code>&lt;future&gt;</code>, <code>&lt;atomic&gt;</code> 等头文件中。</p>
<ul>
<li><strong><code>std::thread</code>:</strong> 用于创建和管理线程。允许函数或可调用对象在独立的线程中执行。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Worker thread running.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(worker_thread)</span></span>; <span class="comment">// 创建新线程并执行 worker_thread</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Main thread running.\n&quot;</span>;</span><br><span class="line">    t.join(); <span class="comment">// 等待 worker_thread 执行完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>互斥量 (<code>std::mutex</code>, <code>std::lock_guard</code>, <code>std::unique_lock</code>):</strong> 用于保护共享数据，防止多个线程同时访问导致的数据竞争。<code>lock_guard</code> 和 <code>unique_lock</code> 提供了 RAII 风格的锁管理，确保互斥量能被正确释放。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex data_mutex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shared_data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_data</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(data_mutex)</span></span>; <span class="comment">// 自动加锁，离开作用域时自动解锁</span></span><br><span class="line">    shared_data.push_back(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>  <strong>条件变量 (<code>std::condition_variable</code>):</strong> 用于线程间的同步，允许一个线程等待某个条件变为真（由另一个线程通知）。通常与 <code>std::mutex</code> 和 <code>std::unique_lock</code> 配合使用。</li>
<li><strong>原子操作 (<code>std::atomic&lt;T&gt;</code>):</strong> 提供对基本类型的原子操作（如读取、写入、增减、比较交换），保证这些操作在多线程环境下不会被打断，避免了数据竞争，通常比使用互斥量更高效。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// counter++; // 原子地自增</span></span><br></pre></td></tr></table></figure></li>
<li>  <strong>异步操作 (<code>std::async</code>, <code>std::future</code>, <code>std::promise</code>):</strong> 提供了一种更高级的并发模型，允许异步地执行任务并获取其结果。<code>std::async</code> 可以启动一个异步任务，返回一个 <code>std::future</code> 对象，通过 <code>future</code> 可以在稍后获取任务的返回值或等待任务完成。<code>promise</code> 则用于在一个线程中设置值或异常，供另一个线程通过关联的 <code>future</code> 获取。</li>
</ul>
<p>C++11 的并发支持使得编写可移植的多线程程序成为可能。</p>
<h3 id="18-7-2-新增的库"><a href="#18-7-2-新增的库" class="headerlink" title="18.7.2 新增的库"></a>18.7.2 新增的库</h3><p>C++11 标准库增加了几个实用的新组件：</p>
<ul>
<li><strong><code>&lt;chrono&gt;</code>:</strong> 提供了处理<strong>时间</strong>和<strong>时间段</strong>的类型安全、精确的库。包括时钟 (<code>system_clock</code>, <code>steady_clock</code>, <code>high_resolution_clock</code>)、时间点 (<code>time_point</code>) 和时间段 (<code>duration</code>)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; // for sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">50</span>)); <span class="comment">// 休眠 50 毫秒</span></span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt; elapsed = end - start; <span class="comment">// 计算毫秒差</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Elapsed time: &quot;</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>&lt;random&gt;</code>:</strong> 提供了比 C 风格 <code>rand()</code> 更强大、更灵活的<strong>随机数生成</strong>工具。包括多种随机数引擎（如 <code>mt19937</code>）和分布（如 <code>uniform_int_distribution</code>, <code>normal_distribution</code>）。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd; <span class="comment">// 用于生成种子 (可能基于硬件)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// Mersenne Twister 引擎</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">distrib</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>; <span class="comment">// 均匀分布 [1, 6]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rolling a die: &quot;</span> &lt;&lt; distrib(gen) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>&lt;regex&gt;</code>:</strong> 提供了对<strong>正则表达式 (Regular Expressions)</strong> 的支持，用于强大的文本模式匹配和搜索/替换。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;Email: example@test.com&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::regex <span class="title">email_regex</span><span class="params">(<span class="string">R&quot;(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,&#125;\b)&quot;</span>)</span></span>; <span class="comment">// 原始字符串字面量</span></span><br><span class="line">    <span class="built_in">std</span>::smatch match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::regex_search(text, match, email_regex)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found email: &quot;</span> &lt;&lt; match.str(<span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>&lt;tuple&gt;</code>:</strong> 提供了<strong>元组 (Tuple)</strong> 类型 <code>std::tuple</code>，可以看作是匿名的、固定大小的异构值集合，类似于 <code>std::pair</code> 的泛化。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;int, std::string, double&gt; t1(10, &quot;hello&quot;, 3.14);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuple element 0: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 std::get&lt;i&gt; 访问</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuple element 1: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// C++17 结构化绑定更方便: auto [id, name, value] = t1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="18-7-3-低级编程"><a href="#18-7-3-低级编程" class="headerlink" title="18.7.3 低级编程"></a>18.7.3 低级编程</h3><p>C++11 也增强了对底层内存布局和编译时计算的支持：</p>
<ul>
<li><strong>对齐控制 (<code>alignas</code>, <code>alignof</code>):</strong><ul>
<li>  <code>alignas</code>: 用于指定变量或类型的<strong>内存对齐要求</strong>。</li>
<li><code>alignof</code>: 用于查询类型或对象的对齐要求（返回一个 <code>size_t</code>）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">16</span>)</span> AlignedStruct </span>&#123; <span class="comment">// 要求按 16 字节对齐</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Alignment of int: &quot;</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Alignment of AlignedStruct: &quot;</span> &lt;&lt; <span class="keyword">alignof</span>(AlignedStruct) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong><code>constexpr</code>:</strong> 用于声明函数或变量可以在<strong>编译时</strong>求值。<code>constexpr</code> 函数可以在编译时用于常量表达式，也可以在运行时像普通函数一样使用。<code>constexpr</code> 变量必须用常量表达式初始化。这使得更多的计算可以在编译阶段完成，提高了运行时性能并增强了元编程能力。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constexpr 函数，可在编译时计算</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : (n * factorial(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> five_factorial = factorial(<span class="number">5</span>); <span class="comment">// 编译时计算结果为 120</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, factorial(4)&gt; arr; <span class="comment">// 数组大小在编译时确定为 24</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> runtime_val = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> six_factorial = factorial(runtime_val); <span class="comment">// 运行时计算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="18-7-4-杂项"><a href="#18-7-4-杂项" class="headerlink" title="18.7.4 杂项"></a>18.7.4 杂项</h3><ul>
<li><strong>用户定义字面量 (User-defined Literals):</strong> 允许程序员为字面量（如 <code>&quot;hello&quot;</code>, <code>123</code>, <code>3.14</code>）定义后缀，从而创建具有特定类型或意义的对象。后缀通常以下划线 <code>_</code> 开头。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个将秒转换为毫秒的用户定义字面量后缀 _ms</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::chrono::milliseconds <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _ms(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ms) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::chrono::milliseconds(ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="number">150</span>_ms; <span class="comment">// duration 的类型是 std::chrono::milliseconds，值为 150ms</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Duration: &quot;</span> &lt;&lt; duration.count() &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>原始字符串字面量 (Raw String Literals):</strong> 用于简化包含大量特殊字符（如反斜杠 <code>\</code>、引号 <code>&quot;</code>）的字符串的定义，避免了繁琐的转义。<ul>
<li>  语法：<code>R&quot;delimiter(raw_characters)delimiter&quot;</code></li>
<li><code>delimiter</code> 是可选的分隔符序列（不能包含括号、反斜杠或空格），用于区分字符串内容和结束标记。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无需转义反斜杠和引号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path = <span class="string">R&quot;(C:\Program Files\My App\data.txt)&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> html = <span class="string">R&quot;delimiter(</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;&lt;title&gt;&quot;Example&quot;&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;Hello, world!&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">)delimiter&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; path &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; html &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>这些只是 C++11 新增功能的一部分，它们共同构成了现代 C++ 的基础，使得 C++ 成为一门功能更强大、表达力更强、更易于使用的编程语言。</p>
<h2 id="18-8-语言变化"><a href="#18-8-语言变化" class="headerlink" title="18.8 语言变化"></a>18.8 语言变化</h2><p>C++ 是一门不断发展的语言。从 C++98/03 到 C++11，再到后续的 C++14, C++17, C++20 等标准，语言本身和标准库都在持续演进，以满足现代软件开发的需求。C++11 是一个里程碑式的版本，引入了大量重要特性，其中许多特性并非凭空出现，而是在标准化之前经过了社区的广泛讨论和实践检验。Boost 库和 TR1 在这一过程中扮演了重要角色。</p>
<h3 id="18-8-1-Boost-项目"><a href="#18-8-1-Boost-项目" class="headerlink" title="18.8.1 Boost 项目"></a>18.8.1 Boost 项目</h3><p><strong>Boost C++ 库 (Boost C++ Libraries)</strong> 是一个广受推崇的、高质量的、经过同行评审的 C++ 库集合。它由 C++ 社区的众多开发者共同维护和贡献。</p>
<ul>
<li>  <strong>目的:</strong> Boost 旨在提供各种通用和特定领域的库，扩展 C++ 标准库的功能。它既包含可以直接使用的工具（如日期时间处理、文件系统操作、正则表达式、测试框架等），也包含一些实验性的、可能在未来被纳入 C++ 标准的库。</li>
<li>  <strong>影响力:</strong> Boost 对 C++ 标准的发展产生了深远影响。许多 C++11 及后续标准中的新特性（如智能指针 <code>shared_ptr</code>、函数包装器 <code>function</code>、线程库、正则表达式库、元组 <code>tuple</code>、<code>array</code> 等）都起源于 Boost 库中的对应组件，并在 Boost 中得到了广泛的应用和验证。</li>
<li>  <strong>“试炼场”:</strong> Boost 常常被视为 C++ 新特性的“试炼场”。一个库如果在 Boost 中被证明是稳定、有用且设计良好的，那么它被 C++ 标准委员会考虑并最终纳入官方标准的可能性就会大大增加。</li>
<li>  <strong>许可证:</strong> Boost 库通常采用非常宽松的 Boost Software License，允许在商业和非商业项目中自由使用。</li>
</ul>
<p>即使某些功能已被纳入 C++ 标准库，Boost 仍然提供了标准库中尚未包含的许多有用工具，并且有时会提供比标准库版本更早或功能更丰富的实现。</p>
<h3 id="18-8-2-TR1-Technical-Report-1"><a href="#18-8-2-TR1-Technical-Report-1" class="headerlink" title="18.8.2 TR1 (Technical Report 1)"></a>18.8.2 TR1 (Technical Report 1)</h3><p>**TR1 (Technical Report 1)**，正式名称是 ISO/IEC TR 19768:2007，是 C++ 标准委员会发布的一份技术报告，旨在扩展 C++03 标准库。它并不是 C++ 标准本身的一部分，但它定义了一系列推荐添加的库组件。</p>
<ul>
<li><strong>内容:</strong> TR1 包含了许多后来被正式纳入 C++11 标准库的特性，其中大部分源自 Boost 库。主要内容包括：<ul>
<li>  引用包装器 (<code>ref</code>, <code>cref</code>)</li>
<li>  智能指针 (<code>shared_ptr</code>, <code>weak_ptr</code> - <code>unique_ptr</code> 是 C++11 新设计的)</li>
<li>  函数对象包装器 (<code>function</code>)</li>
<li>  函数对象绑定器 (<code>bind</code>)</li>
<li>  类型萃取 (<code>&lt;type_traits&gt;</code>)</li>
<li>  随机数生成 (<code>&lt;random&gt;</code>)</li>
<li>  元组 (<code>&lt;tuple&gt;</code>)</li>
<li>  固定大小数组 (<code>&lt;array&gt;</code>)</li>
<li>  哈希表容器 (<code>&lt;unordered_set&gt;</code>, <code>&lt;unordered_map&gt;</code>)</li>
<li>  正则表达式 (<code>&lt;regex&gt;</code>)</li>
</ul>
</li>
<li>  <strong>命名空间:</strong> TR1 中的组件通常被放置在 <code>std::tr1</code> 命名空间下。例如，TR1 的智能指针是 <code>std::tr1::shared_ptr</code>。</li>
<li>  <strong>过渡角色:</strong> TR1 起到了一个重要的过渡作用。它允许编译器厂商和库开发者在 C++11 标准正式发布之前，就开始实现和提供这些即将标准化的重要库功能，让用户可以提前体验和使用。当 C++11 标准发布后，这些组件被正式移入了 <code>std</code> 命名空间，<code>std::tr1</code> 命名空间则逐渐被废弃。</li>
</ul>
<p>了解 Boost 和 TR1 有助于理解 C++11 中许多库特性的来源和演变过程。它们展示了 C++ 社区驱动语言发展的模式：通过第三方库（如 Boost）进行探索和实践，通过技术报告（如 TR1）进行预标准化，最终将成熟的特性纳入官方标准。</p>
<h3 id="18-8-3-使用-Boost"><a href="#18-8-3-使用-Boost" class="headerlink" title="18.8.3 使用 Boost"></a>18.8.3 使用 Boost</h3><p>虽然许多 Boost 库的功能已被 C++11 及后续标准吸收，但 Boost 仍然是一个非常有价值的资源库。</p>
<p><strong>如何使用 Boost (概念性步骤):</strong></p>
<ol>
<li> <strong>下载:</strong> 从 Boost 官方网站 (<a target="_blank" rel="noopener" href="https://www.boost.org/">boost.org</a>) 下载最新的 Boost 发行版。</li>
<li> <strong>解压:</strong> 将下载的压缩包解压到你选择的目录。</li>
<li><strong>编译 (部分库需要):</strong> Boost 中的许多库是<strong>仅头文件 (Header-only)</strong> 的，这意味着你只需要在你的代码中 <code>#include</code> 相应的头文件，并将 Boost 的根目录添加到编译器的包含路径 (Include Path) 中即可使用。然而，也有一些库（如 Boost.Thread, Boost.Filesystem, Boost.Regex, Boost.Program_options 等）需要<strong>编译</strong>成静态库或动态库文件。<ul>
<li>  编译通常需要运行 Boost 提供的 <code>bootstrap</code> 脚本（根据你的操作系统选择 <code>.bat</code> 或 <code>.sh</code>），然后运行生成的 <code>b2</code> (或 <code>bjam</code>) 构建工具。你需要指定你的编译器、构建类型（debug/release）、链接方式（static/shared）等。具体步骤请参考 Boost 官方文档。</li>
</ul>
</li>
<li><strong>配置项目:</strong><ul>
<li>  <strong>包含路径:</strong> 在你的项目设置中，将 Boost 库的根目录添加到编译器的头文件搜索路径。</li>
<li>  <strong>库路径 (如果编译了库):</strong> 将生成的库文件所在的目录添加到链接器的库文件搜索路径。</li>
<li>  <strong>链接库 (如果编译了库):</strong> 将你需要使用的 Boost 库文件（如 <code>libboost_thread-vc142-mt-gd-x64-1_79.lib</code> 等，文件名会根据版本、编译器、配置等变化）添加到链接器的输入中。</li>
</ul>
</li>
<li> <strong>包含头文件:</strong> 在你的 C++ 代码中使用 <code>#include &lt;boost/xxx.hpp&gt;</code> 来包含所需的 Boost 头文件。</li>
</ol>
<p><strong>示例 (使用 Boost.Lexical_Cast):</strong><br>Boost.Lexical_Cast 是一个仅头文件的库，用于字符串和数值之间的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Boost 根目录已添加到包含路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/lexical_cast.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = boost::lexical_cast&lt;<span class="keyword">int</span>&gt;(s);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;String &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27; cast to int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sd = boost::lexical_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(d);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Double &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; cast to string: &#x27;&quot;</span> &lt;&lt; sd &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> bad_s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> bad_i = boost::lexical_cast&lt;<span class="keyword">int</span>&gt;(bad_s); <span class="comment">// 会抛出 boost::bad_lexical_cast 异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> boost::bad_lexical_cast&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Lexical cast error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Boost 库可以极大地扩展 C++ 的能力，但需要注意正确配置编译和链接环境。建议详细阅读你所使用的具体 Boost 库的文档。</p>
<h2 id="18-9-总结"><a href="#18-9-总结" class="headerlink" title="18.9 总结"></a>18.9 总结</h2><p>本章深入探讨了 C++11 标准引入的一系列重要特性，这些特性极大地改变了 C++ 的编程方式，使其更高效、更安全、更易用。</p>
<p>主要内容回顾：</p>
<ol>
<li><p> <strong>C++11 特性回顾:</strong> 复习了之前章节已介绍的 C++11 功能，包括新类型 (<code>long long</code>, <code>char16_t</code>, <code>char32_t</code>, <code>nullptr</code>)、统一初始化 (<code>&#123;&#125;</code>), 声明 (<code>auto</code>, <code>decltype</code>)、智能指针 (<code>unique_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code>)、异常规范 (<code>noexcept</code>)、作用域内枚举 (<code>enum class</code>) 以及对类、模板和 STL 的改进（如范围 <code>for</code>、<code>array</code>、无序容器、<code>initializer_list</code>、模板别名 <code>using</code>）。</p>
</li>
<li><p><strong>移动语义和右值引用:</strong></p>
<ul>
<li>  <strong>右值引用 (<code>&amp;&amp;</code>):</strong> 引入用于区分即将销毁的临时对象（右值）和持久对象（左值）。</li>
<li>  <strong>移动语义:</strong> 允许从右值或标记为可移动的对象那里“窃取”资源（如动态内存指针），而不是进行昂贵的复制。</li>
<li>  <strong>移动构造函数和移动赋值运算符:</strong> 特殊成员函数，接收右值引用参数，实现资源转移并将源对象置于有效的空状态。应标记为 <code>noexcept</code>。</li>
<li>  <strong><code>std::move</code>:</strong> 将一个左值强制转换为右值引用类型，以触发移动语义（但本身不执行移动）。使用后不应对源对象的值做假设。</li>
</ul>
</li>
<li><p><strong>新的类功能:</strong></p>
<ul>
<li>  <strong>特殊成员函数控制 (<code>= default</code>, <code>= delete</code>):</strong> 显式要求编译器生成默认实现或禁用特定成员函数（特别是复制/移动操作）。</li>
<li>  <strong>委托构造函数:</strong> 允许一个构造函数调用同一类的另一个构造函数，减少代码重复。</li>
<li>  <strong>继承构造函数 (<code>using Base::Base;</code>):</strong> 允许派生类继承基类的构造函数，简化派生类编写。</li>
<li>  <strong>虚函数管理 (<code>override</code>, <code>final</code>):</strong> <code>override</code> 确保派生类方法正确覆盖基类虚函数；<code>final</code> 阻止虚函数被进一步覆盖或类被继承。</li>
</ul>
</li>
<li><p><strong>Lambda 函数:</strong></p>
<ul>
<li>  提供简洁的语法，用于在需要可调用对象的地方<strong>就地定义匿名函数对象</strong>。</li>
<li>  <strong><code>[capture](params) -&gt; ret &#123;body&#125;</code>:</strong> 包含捕获子句、参数列表（可选）、返回类型（可选）和函数体。</li>
<li>  <strong>捕获:</strong> 可以通过值 (<code>=</code>, <code>var</code>) 或引用 (<code>&amp;</code>, <code>&amp;var</code>) 捕获外部作用域的变量。<code>mutable</code> 关键字允许修改值捕获变量的副本。</li>
<li>  常用于 STL 算法，提高代码的局部性和可读性。</li>
</ul>
</li>
<li><p><strong>包装器 (<code>std::function</code>):</strong></p>
<ul>
<li>  定义在 <code>&lt;functional&gt;</code> 中的通用函数包装器。</li>
<li>  可以存储、复制和调用任何具有兼容签名的可调用实体（函数指针、Lambda、函数对象、成员函数等）。</li>
<li>  通过类型擦除实现，提供了灵活性，但在性能敏感场景下可能有开销（堆分配、间接调用）。</li>
<li>  替代方案包括模板（编译时已知类型时更高效）、函数指针、直接传递 Lambda。</li>
</ul>
</li>
<li><p><strong>可变参数模板:</strong></p>
<ul>
<li>  允许函数模板和类模板接受<strong>任意数量、任意类型</strong>的模板参数（模板参数包 <code>typename... Args</code>）和函数参数（函数参数包 <code>Args... args</code>）。</li>
<li>  使用 <code>sizeof...(Args)</code> 获取参数数量。</li>
<li>  通常需要通过<strong>递归</strong>或 C++17 的折叠表达式来<strong>展开</strong>参数包，以处理每个参数。</li>
</ul>
</li>
<li><p><strong>C++11 新增的其他功能:</strong></p>
<ul>
<li>  <strong>并发编程:</strong> 标准库支持 (<code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;atomic&gt;</code>, <code>&lt;future&gt;</code> 等）。</li>
<li>  <strong>新库:</strong> <code>&lt;chrono&gt;</code> (时间), <code>&lt;random&gt;</code> (随机数), <code>&lt;regex&gt;</code> (正则表达式), <code>&lt;tuple&gt;</code> (元组)。</li>
<li>  <strong>低级编程:</strong> 对齐控制 (<code>alignas</code>, <code>alignof</code>), 编译时计算 (<code>constexpr</code>)。</li>
<li>  <strong>杂项:</strong> 用户定义字面量, 原始字符串字面量 (<code>R&quot;(...)&quot;</code>)。</li>
</ul>
</li>
<li><p><strong>语言变化:</strong></p>
<ul>
<li>  强调了 C++ 语言的持续演进。</li>
<li>  介绍了 <strong>Boost 库</strong>作为 C++ 新特性的试验场和重要补充。</li>
<li>  介绍了 <strong>TR1</strong> 作为 C++11 库特性的前身和过渡。</li>
</ul>
</li>
</ol>
<p>C++11 是 C++ 发展的一个重要分水岭，它引入的这些特性深刻地影响了现代 C++ 的编程风格和实践。</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_18/>http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_18/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-30T23:41:03+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年4月30日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Program/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Program</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/C/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>C++</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_18/&title=Chapter 18 探讨C++新标准 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_18/&title=Chapter 18 探讨C++新标准 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_18/&title=Chapter 18 探讨C++新标准 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2025/04/30/Cpp_tutorial_Chapter_1/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Chapter 1 C++ Tutorial 简介</p>
          <p class='content'>本系列是参考《C++ Primer Plus》目录进行编写的精简版教程。
由于是精简版，因此可能不能完全覆盖原版《C++ Primer Plus》的所有内容，但是在篇幅上大大减少，只能说有利有弊...</p>
        </a>
      
      
        <a class='next' href='/2025/04/30/Cpp_tutorial_Chapter_17/'>
          <p class='title'>Chapter 17 输入、输出和文件<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>17.1 C++输入和输出概述C++ 程序经常需要与外部世界进行交互：从键盘读取用户输入，将结果显示到屏幕，或者读写文件。C++ 使用流 (Stream) 的概念来处理输入和输出 (I/O) 操...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-%E5%A4%8D%E4%B9%A0%E5%89%8D%E9%9D%A2%E4%BB%8B%E7%BB%8D%E8%BF%87%E7%9A%84C-11%E5%8A%9F%E8%83%BD"><span class="toc-text">18.1 复习前面介绍过的C++11功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-1-%E6%96%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">18.1.1 新类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-2-%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">18.1.2 统一的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-3-%E5%A3%B0%E6%98%8E"><span class="toc-text">18.1.3 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">18.1.4 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-5-%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-text">18.1.5 异常规范方面的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E6%9E%9A%E4%B8%BE"><span class="toc-text">18.1.6 作用域内枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-7-%E5%AF%B9%E7%B1%BB%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-text">18.1.7 对类的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-8-%E6%A8%A1%E6%9D%BF%E5%92%8C-STL-%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-text">18.1.8 模板和 STL 方面的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-9-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">18.1.9 右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">18.2 移动语义和右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-1-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-text">18.2.1 为何需要移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-amp-amp"><span class="toc-text">右值引用 (&amp;&amp;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-2-%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">18.2.2 一个移动示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-3-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">18.2.3 移动构造函数解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-4-%E8%B5%8B%E5%80%BC"><span class="toc-text">18.2.4 赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-5-%E5%BC%BA%E5%88%B6%E7%A7%BB%E5%8A%A8-std-move"><span class="toc-text">18.2.5 强制移动 (std::move)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-%E6%96%B0%E7%9A%84%E7%B1%BB%E5%8A%9F%E8%83%BD"><span class="toc-text">18.3 新的类功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-1-%E7%89%B9%E6%AE%8A%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">18.3.1 特殊的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-2-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%A6%81%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95-default-delete"><span class="toc-text">18.3.2 默认的方法和禁用的方法 (&#x3D; default, &#x3D; delete)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-3-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">18.3.3 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-4-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">18.3.4 继承构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-5-%E7%AE%A1%E7%90%86%E8%99%9A%E6%96%B9%E6%B3%95%EF%BC%9Aoverride-%E5%92%8C-final"><span class="toc-text">18.3.5 管理虚方法：override 和 final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-Lambda-%E5%87%BD%E6%95%B0"><span class="toc-text">18.4 Lambda 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-text">Lambda 表达式语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-1-%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E5%87%BD%E6%95%B0%E7%AC%A6%E5%92%8C-Lambda-%E5%87%BD%E6%95%B0"><span class="toc-text">18.4.1 比较函数指针、函数符和 Lambda 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-2-%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8-lambda"><span class="toc-text">18.4.2 为何使用 lambda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5-%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-text">18.5 包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-1-%E5%8C%85%E8%A3%85%E5%99%A8-function"><span class="toc-text">18.5.1 包装器 function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-1-%E7%BB%AD-function-%E5%8F%8A%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%8E%E6%95%88%E6%80%A7-%E6%BD%9C%E5%9C%A8%E5%BC%80%E9%94%80"><span class="toc-text">18.5.1 (续) function 及模板的低效性 (潜在开销)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-2-%E4%BF%AE%E5%A4%8D%E9%97%AE%E9%A2%98-18-5-3-%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F"><span class="toc-text">18.5.2 修复问题 &#x2F; 18.5.3 其他方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-6-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">18.6 可变参数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-1-%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-text">18.6.1 模板和函数参数包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-2-%E5%B1%95%E5%BC%80%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-text">18.6.2 展开参数包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-3-%E5%9C%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92"><span class="toc-text">18.6.3 在可变参数模板函数中使用递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-7-C-11%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="toc-text">18.7 C++11新增的其他功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-7-1-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B"><span class="toc-text">18.7.1 并行编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-7-2-%E6%96%B0%E5%A2%9E%E7%9A%84%E5%BA%93"><span class="toc-text">18.7.2 新增的库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-7-3-%E4%BD%8E%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="toc-text">18.7.3 低级编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-7-4-%E6%9D%82%E9%A1%B9"><span class="toc-text">18.7.4 杂项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-8-%E8%AF%AD%E8%A8%80%E5%8F%98%E5%8C%96"><span class="toc-text">18.8 语言变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-8-1-Boost-%E9%A1%B9%E7%9B%AE"><span class="toc-text">18.8.1 Boost 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-8-2-TR1-Technical-Report-1"><span class="toc-text">18.8.2 TR1 (Technical Report 1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-8-3-%E4%BD%BF%E7%94%A8-Boost"><span class="toc-text">18.8.3 使用 Boost</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-9-%E6%80%BB%E7%BB%93"><span class="toc-text">18.9 总结</span></a></li></ol>
    </div>
  </section>


  


</aside>



        
        
          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="Chapter 18 探讨C++新标准";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        
      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5043500508'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a id="s-top" class="fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <script>
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/********************脚本懒加载函数********************************/
function loadScript(src, cb) {
var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
var script = document.createElement('script');
script.setAttribute('type','text/javascript');
if (cb) script.onload = cb;
script.setAttribute('src', src);
HEAD.appendChild(script);
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  








  <script>
  let APlayerController = new Object();
  APlayerController.id = '5043500508';  // 设定全局音乐播放ID
  APlayerController.volume = '0.7';
  loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css", window.volantis.loadcss);

  loadScript("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js")

  loadScript("https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js")


</script>




  
  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/valine.min.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";

    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      recordIP: 'false',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>





  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/app.min.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/search/hexo.min.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://uniqueland.top' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
       

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      
	 

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
      } catch (e) {
        console.log(e);
      }
	  
    });

    document.addEventListener('pjax:error', function (e) {
	  
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
