<!DOCTYPE html>
<html lang="zh-CN">
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>Chapter 13 类继承 - Uniqueland</title>
  
    <meta name="keywords" content="Program,C++">
  

  
    <meta name="description" content="C++ tutorial">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://www.helloimg.com/images/2022/03/27/ReozOM.png">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

</head>

<body>
  

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div id="l_body">
    <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Uniqueland</p>
    
    
      <p class="subtitle">--XR's personal Blog</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/categories/"
              
              
              id="categories">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>分类</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

    <div id='safearea'>
      <div class='body-wrapper' id="pjax-container">
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
    <div class='headimg-div'>
      <a class='headimg-a'>
        <img class='headimg' src='https://s2.loli.net/2025/04/26/9F74KMasiN1YwQW.png'/>
      </a>
    </div>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Chapter 13 类继承
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="https://raw.githubusercontent.com/srcx404/pic/refs/heads/main/xr.jpg">
    <p>XR</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2025年4月30日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Chapter 13 类继承" data-path="/2025/04/30/Cpp_tutorial_Chapter_13/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <h2 id="13-1-一个简单的基类"><a href="#13-1-一个简单的基类" class="headerlink" title="13.1 一个简单的基类"></a>13.1 一个简单的基类</h2><p>面向对象编程 (OOP) 的一个核心优势是<strong>代码重用</strong>。除了通过包含对象成员（组合）之外，C++ 还提供了另一种强大的代码重用机制：**继承 (Inheritance)**。</p>
<p>继承允许我们基于一个已有的类（称为<strong>基类 (Base Class)</strong> 或<strong>父类 (Parent Class)**）来创建一个新的类（称为</strong>派生类 (Derived Class)** 或**子类 (Child Class)**）。派生类会自动获得基类的所有成员（数据和函数），并且可以添加自己的新成员或修改继承来的成员的行为。</p>
<p>这种机制非常适合用来表示现实世界中的“is-a”（是一种）关系。例如，一个“经理”<strong>是</strong>一个“员工”，一个“圆”<strong>是</strong>一个“形状”。</p>
<p>本节我们将从定义一个简单的基类开始，然后演示如何从中派生出新的类。</p>
<p><strong>场景:</strong> 假设我们要为一个乒乓球俱乐部编写程序，需要表示球员信息。</p>
<p><strong>基类 <code>TableTennisPlayer</code>:</strong></p>
<p>我们首先创建一个基础的 <code>TableTennisPlayer</code> 类，包含球员的姓名和是否有球桌。</p>
<p><strong>tabtenn0.h (基类定义)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname;</span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 显示姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;; <span class="comment">// 是否有球桌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;; <span class="comment">// 重置球桌状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TABTENN0_H_</span></span></span><br></pre></td></tr></table></figure>

<p><strong>tabtenn0.cpp (基类实现)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">TableTennisPlayer::TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                      : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125; <span class="comment">// 使用成员初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个基类很简单，包含了球员的基本信息和操作。</p>
<h3 id="13-1-1-派生一个类"><a href="#13-1-1-派生一个类" class="headerlink" title="13.1.1 派生一个类"></a>13.1.1 派生一个类</h3><p>现在，假设我们想为一部分球员添加“积分”信息。我们可以从 <code>TableTennisPlayer</code> 派生出一个新的类 <code>RatedPlayer</code>，它将继承 <code>TableTennisPlayer</code> 的所有成员，并添加自己的积分成员和相关方法。</p>
<p><strong>继承语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> accessSpecifier BaseClassName &#123;</span><br><span class="line">    <span class="comment">// ... 派生类新增的成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>DerivedClassName</code>: 派生类的名称。</li>
<li>  <code>:</code>: 表示继承关系。</li>
<li>  <code>accessSpecifier</code>: 访问说明符（通常是 <code>public</code>），指定继承类型。</li>
<li>  <code>BaseClassName</code>: 基类的名称。</li>
</ul>
<p><strong><code>RatedPlayer</code> 类的定义 (添加到 tabtenn0.h 或新的头文件)</strong></p>
<p>我们将 <code>RatedPlayer</code> 的定义也放在 <code>tabtenn0.h</code> 中（虽然分成不同文件更好）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... (TableTennisPlayer 定义之后) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer &#123; <span class="comment">// 使用 public 继承</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating; <span class="comment">// 新增成员：积分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类构造函数</span></span><br><span class="line">    RatedPlayer (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 使用基类对象进行构造</span></span><br><span class="line">    RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增方法</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125; <span class="comment">// 获取积分</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123; rating = r; &#125; <span class="comment">// 重置积分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (endif) ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>class RatedPlayer : public TableTennisPlayer</code>: 这声明了 <code>RatedPlayer</code> 是一个从 <code>TableTennisPlayer</code> <strong>公有继承 (publicly derived)</strong> 而来的类。</li>
<li>  <strong>公有继承 (<code>public</code>)</strong>: 这是最常用的继承方式。它建立了一种 “is-a” 关系。基类的公有成员在派生类中仍然是公有的，基类的保护成员在派生类中仍然是保护的。基类的私有成员虽然被继承下来了，但在派生类中是<strong>不可直接访问</strong>的。</li>
<li>  <code>RatedPlayer</code> 自动拥有了 <code>firstname</code>, <code>lastname</code>, <code>hasTable</code> 数据成员以及 <code>Name()</code>, <code>HasTable()</code>, <code>ResetTable()</code> 方法（尽管私有成员不能直接访问）。</li>
<li>  <code>RatedPlayer</code> 添加了自己的私有成员 <code>rating</code> 和公有方法 <code>Rating()</code>, <code>ResetRating()</code>。</li>
</ul>
<h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><p>派生类<strong>不能</strong>直接访问基类的<strong>私有成员</strong>。那么，派生类的构造函数如何初始化继承来的基类私有成员（如 <code>firstname</code>, <code>lastname</code>）呢？</p>
<p>答案是：派生类构造函数必须调用<strong>基类的构造函数</strong>来完成基类部分的初始化。这是通过<strong>成员初始化列表 (Member Initializer List)</strong> 实现的。</p>
<p><strong>派生类构造函数的实现 (添加到 tabtenn0.cpp)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... (TableTennisPlayer 实现之后) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayer 构造函数实现</span></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                         : TableTennisPlayer(fn, ln, ht), rating(r) &#123; <span class="comment">// 调用基类构造函数</span></span><br><span class="line">    <span class="comment">// rating(r) 初始化派生类自己的成员</span></span><br><span class="line">    <span class="comment">// 基类部分的初始化委托给 TableTennisPlayer 的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp)</span><br><span class="line">                         : TableTennisPlayer(tp), rating(r) &#123; <span class="comment">// 调用基类的复制构造函数 (这里是隐式生成的)</span></span><br><span class="line">    <span class="comment">// rating(r) 初始化派生类自己的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>: TableTennisPlayer(fn, ln, ht)</code>: 这部分是成员初始化列表的关键。它显式地调用了基类 <code>TableTennisPlayer</code> 的构造函数，并将必要的参数 (<code>fn</code>, <code>ln</code>, <code>ht</code>) 传递给它。基类构造函数负责初始化 <code>firstname</code>, <code>lastname</code>, <code>hasTable</code>。</li>
<li>  <code>, rating(r)</code>: 初始化列表也用于初始化派生类自己的成员 <code>rating</code>。</li>
<li>  <strong>规则:</strong> 在创建派生类对象时，程序会<strong>首先</strong>调用基类的构造函数来创建和初始化对象的基类部分，<strong>然后</strong>再执行派生类构造函数体（并初始化派生类成员）。如果你不在成员初始化列表中显式调用基类构造函数，编译器会尝试调用基类的<strong>默认构造函数</strong>。如果基类没有默认构造函数，或者你需要调用带参数的基类构造函数，就必须在初始化列表中显式调用。</li>
</ul>
<h3 id="13-1-3-使用派生类"><a href="#13-1-3-使用派生类" class="headerlink" title="13.1.3 使用派生类"></a>13.1.3 使用派生类</h3><p>派生类的对象拥有基类和派生类的所有公有成员。</p>
<p><strong>usett0.cpp (使用示例)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\usett0.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn0.h&quot;</span> <span class="comment">// 包含基类和派生类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="string">&quot;Chuck&quot;</span>, <span class="string">&quot;Blizzard&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// 使用派生类构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类对象可以使用基类的方法</span></span><br><span class="line">    rplayer1.Name(); <span class="comment">// 调用继承来的 TableTennisPlayer::Name()</span></span><br><span class="line">    <span class="keyword">if</span> (rplayer1.HasTable()) <span class="comment">// 调用继承来的 TableTennisPlayer::HasTable()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;: has a table.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类对象可以使用自己的方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    rplayer1.Name();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer1.Rating() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 RatedPlayer::Rating()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用基类对象初始化派生类对象 (通过特定构造函数)</span></span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer2</span><span class="params">(<span class="number">1212</span>, player1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    rplayer2.Name();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer2.Rating() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和运行:</strong></p>
<p>你需要将 <code>tabtenn0.cpp</code> 和 <code>usett0.cpp</code> 一起编译链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ usett0.cpp tabtenn0.cpp -o usett0</span><br><span class="line">./usett0</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Duck, Mallory: has a table.</span><br><span class="line">Name: Duck, Mallory; Rating: 1140</span><br><span class="line">Name: Blizzard, Chuck; Rating: 1212</span><br></pre></td></tr></table></figure>

<h3 id="13-1-4-派生类和基类之间的特殊关系"><a href="#13-1-4-派生类和基类之间的特殊关系" class="headerlink" title="13.1.4 派生类和基类之间的特殊关系"></a>13.1.4 派生类和基类之间的特殊关系</h3><p>公有继承建立了一种非常重要的关系：</p>
<ol>
<li><p> <strong>派生类对象也是一个基类对象:</strong> 一个 <code>RatedPlayer</code> 对象<strong>是</strong>一个 <code>TableTennisPlayer</code> 对象。这意味着需要 <code>TableTennisPlayer</code> 对象的地方，通常可以使用 <code>RatedPlayer</code> 对象来替代。</p>
</li>
<li><p><strong>基类指针/引用可以指向/引用派生类对象:</strong></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer * pt = &amp;rplayer1; <span class="comment">// 基类指针指向派生类对象 (OK)</span></span><br><span class="line">TableTennisPlayer &amp; rt = rplayer1; <span class="comment">// 基类引用引用派生类对象 (OK)</span></span><br><span class="line"></span><br><span class="line">pt-&gt;Name(); <span class="comment">// 通过基类指针调用基类方法 (OK)</span></span><br><span class="line">rt.Name(); <span class="comment">// 通过基类引用调用基类方法 (OK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，通过基类指针/引用不能直接调用派生类特有的方法</span></span><br><span class="line"><span class="comment">// pt-&gt;Rating(); // 错误！TableTennisPlayer 没有 Rating() 方法</span></span><br><span class="line"><span class="comment">// rt.Rating(); // 错误！</span></span><br></pre></td></tr></table></figure>
<p> 这种指针/引用的兼容性是实现<strong>多态 (Polymorphism)</strong> 的基础，我们将在后续章节详细讨论。</p>
</li>
</ol>
<p><strong>总结:</strong></p>
<ul>
<li>  继承允许基于现有类（基类）创建新类（派生类）。</li>
<li>  派生类继承基类的成员（数据和方法）。</li>
<li>  <strong>公有继承 (<code>public</code>)</strong> 建立 “is-a” 关系，基类的公有成员在派生类中仍是公有。</li>
<li>  派生类构造函数必须通过<strong>成员初始化列表</strong>调用适当的基类构造函数来初始化继承的基类成员。</li>
<li>  派生类对象可以使用基类的公有方法。</li>
<li>  基类指针或引用可以指向或引用派生类对象，但只能通过它们调用基类中定义的方法（除非使用虚函数和动态联编）。</li>
</ul>
<h2 id="13-2-继承：is-a-关系"><a href="#13-2-继承：is-a-关系" class="headerlink" title="13.2 继承：is-a 关系"></a>13.2 继承：is-a 关系</h2><p>我们在上一节看到了如何从一个基类派生出新类。其中，<strong>公有继承 (<code>public</code>)</strong> 是最常用的一种继承方式，它建立了一种被称为 <strong>“is-a”</strong> （或 “is-a-kind-of”）的关系模型。</p>
<p><strong>什么是 “is-a” 关系？</strong></p>
<p>“is-a” 关系意味着派生类的对象本质上也是基类的一种。换句话说，派生类是基类的一个<strong>特殊化</strong>版本。</p>
<ul>
<li>  在我们的例子中，<code>RatedPlayer</code> <strong>是</strong>一个 <code>TableTennisPlayer</code>。一个有积分的球员首先是一个乒乓球球员，只是他还额外具有积分属性。</li>
<li>  类似地，如果有一个 <code>Employee</code> 类和一个 <code>Manager</code> 类，并且 <code>Manager</code> 公有继承自 <code>Employee</code>，那么一个 <code>Manager</code> <strong>是</strong>一个 <code>Employee</code>。经理是员工的一种特殊类型，具有额外的职责或属性。</li>
<li>  一个 <code>Circle</code> <strong>是</strong>一个 <code>Shape</code>。</li>
<li>  一个 <code>Dog</code> <strong>是</strong>一个 <code>Animal</code>。</li>
</ul>
<p><strong>公有继承如何体现 “is-a”？</strong></p>
<p>公有继承之所以能模拟 “is-a” 关系，关键在于它保证了派生类对象拥有基类的<strong>所有公有接口</strong>。</p>
<ul>
<li>  当 <code>RatedPlayer</code> 公有继承 <code>TableTennisPlayer</code> 时，<code>TableTennisPlayer</code> 的所有 <code>public</code> 成员（如 <code>Name()</code>, <code>HasTable()</code>, <code>ResetTable()</code>）在 <code>RatedPlayer</code> 中也保持 <code>public</code>。</li>
<li>  这意味着任何可以对 <code>TableTennisPlayer</code> 对象执行的操作（通过其公有接口），同样也可以对 <code>RatedPlayer</code> 对象执行。一个 <code>RatedPlayer</code> 对象可以像 <code>TableTennisPlayer</code> 对象一样被使用，因为它具备了 <code>TableTennisPlayer</code> 的所有基本功能。</li>
</ul>
<p><strong>代码体现:</strong></p>
<p>这种关系最直接的体现就是基类指针或引用可以指向或引用派生类对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rp</span><span class="params">(<span class="string">&quot;May&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="literal">true</span>, <span class="number">1500</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">ttp</span><span class="params">(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;is-a&quot; 关系允许这种赋值/初始化</span></span><br><span class="line">TableTennisPlayer &amp; rt = rp; <span class="comment">// 基类引用可以引用派生类对象</span></span><br><span class="line">TableTennisPlayer * pt = &amp;rp; <span class="comment">// 基类指针可以指向派生类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过基类引用/指针调用基类的方法</span></span><br><span class="line">rt.Name(); <span class="comment">// 输出 Lee, May</span></span><br><span class="line">pt-&gt;Name(); <span class="comment">// 输出 Lee, May</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但不能直接通过基类引用/指针调用派生类特有的方法</span></span><br><span class="line"><span class="comment">// rt.Rating(); // 错误! TableTennisPlayer 没有 Rating() 方法</span></span><br><span class="line"><span class="comment">// pt-&gt;Rating(); // 错误!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以将派生类对象传递给需要基类对象的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPlayerName</span><span class="params">(<span class="keyword">const</span> TableTennisPlayer &amp; player)</span> </span>&#123;</span><br><span class="line">    player.Name();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showPlayerName(ttp); <span class="comment">// 传递基类对象 (OK)</span></span><br><span class="line">showPlayerName(rp);  <span class="comment">// 传递派生类对象 (OK, 因为 RatedPlayer is-a TableTennisPlayer)</span></span><br></pre></td></tr></table></figure>

<p><strong>与其他关系的对比:</strong></p>
<p>继承（特别是公有继承）与其他类之间的关系不同：</p>
<ul>
<li><p><strong>“has-a” 关系 (包含/组合 - Composition):</strong> 一个类包含另一个类的对象作为其成员。例如，一个 <code>Car</code> <strong>有一个</strong> <code>Engine</code>。这通常通过将 <code>Engine</code> 对象作为 <code>Car</code> 类的数据成员来实现。<code>Car</code> 不是 <code>Engine</code>，<code>Engine</code> 也不是 <code>Car</code>。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Engine engine_member; <span class="comment">// Car has-a Engine</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>“uses-a” 关系 (使用 - Association/Dependency):</strong> 一个类在它的方法中使用了另一个类的对象（例如，作为参数、返回值或局部变量），但并不拥有它。例如，一个 <code>Programmer</code> <strong>使用一个</strong> <code>Computer</code>。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeCode</span><span class="params">(Computer&amp; pc)</span> </span>&#123; <span class="comment">// Programmer uses-a Computer</span></span><br><span class="line">        <span class="comment">// ... 使用 pc 对象 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>为什么区分很重要？</strong></p>
<p>正确地识别类之间的关系并选择合适的实现方式（公有继承、私有继承、保护继承、组合、关联）对于设计良好、可维护的面向对象系统至关重要。</p>
<ul>
<li>  <strong>公有继承 (<code>public</code>)</strong> 应该只用于模拟<strong>真正</strong>的 “is-a” 关系。如果派生类不能完全替代基类（即不符合 Liskov 替换原则 - Liskov Substitution Principle），那么使用公有继承可能是不恰当的。</li>
<li>  如果关系是 “has-a”，应该使用<strong>组合</strong>（成员对象）。</li>
<li>  如果只是临时使用，则是 “uses-a” 关系。</li>
</ul>
<p><strong>不恰当的 “is-a” 示例:</strong></p>
<p>假设你想创建一个 <code>Square</code> 类和一个 <code>Rectangle</code> 类。你可能会想让 <code>Square</code> 继承自 <code>Rectangle</code>，因为正方形“是”矩形。但这里存在问题：如果 <code>Rectangle</code> 有 <code>setWidth()</code> 和 <code>setHeight()</code> 方法，并且它们可以独立设置宽高，那么当你在一个被视为 <code>Rectangle</code> 的 <code>Square</code> 对象上调用 <code>setWidth()</code> 时，为了保持正方形的性质，你可能需要同时修改高度，这违反了 <code>Rectangle</code> 的行为预期（宽度和高度可以独立设置）。在这种情况下，公有继承可能不是最佳选择，可能需要重新考虑设计或使用其他继承方式。</p>
<p><strong>总结:</strong></p>
<ul>
<li>  公有继承 (<code>public</code>) 建立了一种 <strong>“is-a”</strong> 关系，表示派生类是基类的一种特殊类型。</li>
<li>  “is-a” 关系的核心是派生类继承了基类的公有接口，因此可以像基类对象一样被使用。</li>
<li>  这体现在基类指针或引用可以指向或引用派生类对象。</li>
<li>  应将公有继承与 “has-a”（组合）和 “uses-a”（关联）关系区分开。</li>
<li>  只有在派生类确实符合基类的行为契约时，才应使用公有继承。</li>
</ul>
<h2 id="13-3-多态公有继承"><a href="#13-3-多态公有继承" class="headerlink" title="13.3 多态公有继承"></a>13.3 多态公有继承</h2><p>我们已经知道，公有继承建立了 “is-a” 关系，允许我们使用基类指针或引用来指向或引用派生类对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rp</span><span class="params">(<span class="string">&quot;May&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="literal">true</span>, <span class="number">1500</span>)</span></span>;</span><br><span class="line">TableTennisPlayer * pt = &amp;rp; <span class="comment">// 基类指针指向派生类对象</span></span><br></pre></td></tr></table></figure>

<p>然而，当我们通过基类指针或引用调用一个<strong>同时存在于基类和派生类中</strong>的方法时，默认情况下会发生什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-&gt;Name(); <span class="comment">// 调用哪个 Name() 方法？ TableTennisPlayer::Name() 还是 RatedPlayer::Name()？</span></span><br></pre></td></tr></table></figure>

<p>在没有特殊处理的情况下，C++ 默认使用<strong>静态联编 (Static Binding)</strong> 或<strong>早绑定 (Early Binding)**。这意味着编译器在编译时根据指针或引用的</strong>静态类型**（声明的类型，这里是 <code>TableTennisPlayer*</code>）来决定调用哪个版本的方法。因此，即使 <code>pt</code> 实际指向一个 <code>RatedPlayer</code> 对象，<code>pt-&gt;Name()</code> 也会调用 <code>TableTennisPlayer::Name()</code>。</p>
<p>这通常不是我们期望的行为，尤其是在处理不同类型的派生类对象时。我们希望程序能够在<strong>运行时</strong>根据指针或引用<strong>实际指向的对象类型</strong>来选择调用相应的方法。这种“多种形态”的行为就是**多态 (Polymorphism)**。</p>
<p><strong>多态</strong>是面向对象编程的三大支柱之一（另外两个是封装和继承）。它允许我们以统一的方式（通过基类接口）处理不同类型的对象，而这些对象各自以自己的方式响应相同的消息（方法调用）。</p>
<p><strong>如何实现多态？</strong></p>
<p>C++ 通过使用<strong>虚函数 (Virtual Functions)</strong> 和<strong>动态联编 (Dynamic Binding)</strong> 或<strong>晚绑定 (Late Binding)</strong> 来实现多态。</p>
<p><strong>虚函数 (Virtual Functions):</strong></p>
<ul>
<li>  要在派生类中重新定义（覆盖）基类的方法，并且希望通过基类指针/引用调用时能够执行派生类的版本，就必须在<strong>基类</strong>中将该方法声明为<strong>虚函数</strong>。</li>
<li>  通过在基类方法声明前加上 <code>virtual</code> 关键字来实现。</li>
</ul>
<p><strong>修改 <code>TableTennisPlayer</code> (tabtenn1.h)</strong></p>
<p>让我们创建一个新版本的头文件 <code>tabtenn1.h</code>，在其中将 <code>Name()</code> 方法声明为虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 添加 iostream 以便在头文件中使用 cout (虽然通常不推荐)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 - 使用虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname;</span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 将 Name() 声明为虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</span><br><span class="line">    <span class="comment">// 添加一个虚析构函数通常是好习惯 (稍后解释)</span></span><br><span class="line">    <span class="keyword">virtual</span> ~TableTennisPlayer() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RatedPlayer (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123; rating = r; &#125;</span><br><span class="line">    <span class="comment">// 覆盖基类的虚函数 Name()</span></span><br><span class="line">    <span class="comment">// C++11 推荐使用 override 关键字明确表示覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// 也可以只写 virtual void Name() const;</span></span><br><span class="line">                                        <span class="comment">// 或 void Name() const; (如果基类是 virtual，派生类同名同参方法自动也是 virtual)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TABTENN1_H_</span></span></span><br></pre></td></tr></table></figure>

<p><strong>修改实现 (tabtenn1.cpp)</strong></p>
<p>我们需要提供 <code>RatedPlayer::Name()</code> 的实现，并更新构造函数以匹配新的类名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TableTennisPlayer 方法</span></span><br><span class="line">TableTennisPlayer::TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                      : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayer 方法</span></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                         : TableTennisPlayer(fn, ln, ht), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp)</span><br><span class="line">                         : TableTennisPlayer(tp), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayer 覆盖的 Name() 方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RatedPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以调用基类的 Name() 方法</span></span><br><span class="line">    TableTennisPlayer::Name();</span><br><span class="line">    <span class="comment">// 添加自己的输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Rating: &quot;</span> &lt;&lt; rating;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态联编 (Dynamic Binding):</strong></p>
<p>当通过<strong>基类指针或引用</strong>调用一个<strong>虚函数</strong>时，程序会根据指针或引用<strong>实际指向的对象类型</strong>来决定调用哪个版本的方法。这个决定是在<strong>运行时</strong>做出的，因此称为动态联编或晚绑定。</p>
<p><strong>使用示例 (usett1.cpp)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn1.h&quot;</span> <span class="comment">// 使用包含虚函数的新版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="string">&quot;Tara&quot;</span>, <span class="string">&quot;Boomdea&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过对象直接调用，总是调用对象所属类的方法 (静态联编)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Direct call:\n&quot;</span>;</span><br><span class="line">    player1.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 TableTennisPlayer::Name()</span></span><br><span class="line">    rplayer1.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 RatedPlayer::Name()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用虚函数 (动态联编)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nUsing pointers to base type:\n&quot;</span>;</span><br><span class="line">    TableTennisPlayer * pt1 = &amp;player1;</span><br><span class="line">    TableTennisPlayer * pt2 = &amp;rplayer1;</span><br><span class="line"></span><br><span class="line">    pt1-&gt;Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// pt1 指向 TableTennisPlayer 对象，调用 TableTennisPlayer::Name()</span></span><br><span class="line">    pt2-&gt;Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// *** pt2 指向 RatedPlayer 对象，调用 RatedPlayer::Name() ***</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过引用调用虚函数 (动态联编)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nUsing references to base type:\n&quot;</span>;</span><br><span class="line">    TableTennisPlayer &amp; rt1 = player1;</span><br><span class="line">    TableTennisPlayer &amp; rt2 = rplayer1;</span><br><span class="line"></span><br><span class="line">    rt1.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// rt1 引用 TableTennisPlayer 对象，调用 TableTennisPlayer::Name()</span></span><br><span class="line">    rt2.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// *** rt2 引用 RatedPlayer 对象，调用 RatedPlayer::Name() ***</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和运行:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ usett1.cpp tabtenn1.cpp -o usett1</span><br><span class="line">./usett1</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Direct call:</span><br><span class="line">Boomdea, Tara</span><br><span class="line">Duck, Mallory, Rating: 1140</span><br><span class="line"></span><br><span class="line">Using pointers to base type:</span><br><span class="line">Boomdea, Tara</span><br><span class="line">Duck, Mallory, Rating: 1140</span><br><span class="line"></span><br><span class="line">Using references to base type:</span><br><span class="line">Boomdea, Tara</span><br><span class="line">Duck, Mallory, Rating: 1140</span><br></pre></td></tr></table></figure>

<p>可以看到，当通过基类指针 <code>pt2</code> 或基类引用 <code>rt2</code> 调用虚函数 <code>Name()</code> 时，程序在运行时检查到它们实际指向/引用的是 <code>RatedPlayer</code> 对象，因此调用了 <code>RatedPlayer::Name()</code> 版本，实现了多态行为。</p>
<p><strong>为什么需要多态？</strong></p>
<p>多态允许我们编写更通用、更灵活的代码。例如，我们可以创建一个函数，接受一个 <code>TableTennisPlayer</code> 的指针或引用数组，然后遍历这个数组，对每个元素调用 <code>Name()</code> 方法。即使数组中包含不同类型的球员（<code>TableTennisPlayer</code>, <code>RatedPlayer</code> 或其他派生类），只要 <code>Name()</code> 是虚函数，每个对象都会以自己正确的方式显示其名称和信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPlayerInfo</span><span class="params">(<span class="keyword">const</span> TableTennisPlayer &amp; player)</span> </span>&#123;</span><br><span class="line">    player.Name(); <span class="comment">// 会根据 player 实际类型调用正确的 Name() 版本</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... in main ...</span></span><br><span class="line">ShowPlayerInfo(player1);</span><br><span class="line">ShowPlayerInfo(rplayer1);</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong></p>
<ul>
<li>  <strong>多态</strong>允许以统一的方式处理不同类型的对象。</li>
<li>  C++ 通过<strong>公有继承</strong>、<strong>虚函数 (<code>virtual</code>)</strong> 和<strong>动态联编</strong>来实现多态。</li>
<li>  在基类中将希望在派生类中重新定义并希望通过基类指针/引用调用的方法声明为 <code>virtual</code>。</li>
<li>  当通过基类指针或引用调用虚函数时，程序在<strong>运行时</strong>根据对象的实际类型确定要调用的方法版本（动态联编）。</li>
<li>  如果未使用 <code>virtual</code>，则根据指针/引用的<strong>声明类型</strong>在<strong>编译时</strong>确定调用版本（静态联编）。</li>
<li>  多态是实现代码灵活性和可扩展性的关键 OOP 技术。</li>
</ul>
<h2 id="13-4-静态联编和动态联编"><a href="#13-4-静态联编和动态联编" class="headerlink" title="13.4 静态联编和动态联编"></a>13.4 静态联编和动态联编</h2><p><strong>联编 (Binding)</strong> 指的是将源代码中的函数调用（或方法调用）与其在可执行代码中的具体实现（函数体）关联起来的过程。C++ 支持两种类型的联编：静态联编和动态联编。理解它们的区别对于掌握多态至关重要。</p>
<h3 id="13-4-1-指针和引用类型的兼容性"><a href="#13-4-1-指针和引用类型的兼容性" class="headerlink" title="13.4.1 指针和引用类型的兼容性"></a>13.4.1 指针和引用类型的兼容性</h3><p>我们已经知道，在公有继承下，基类指针或引用可以指向或引用派生类对象。这是实现多态的前提。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 RatedPlayer 公有继承自 TableTennisPlayer</span></span><br><span class="line">RatedPlayer rp;</span><br><span class="line">TableTennisPlayer * pt = &amp;rp; <span class="comment">// OK</span></span><br><span class="line">TableTennisPlayer &amp; rt = rp; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>这种向上转换（将派生类指针/引用转换为基类指针/引用）是自动且安全的，因为派生类对象保证包含了基类的所有成员和接口。</p>
<p>反过来，将基类指针或引用转换为派生类指针或引用（向下转换）通常是不安全的，需要显式类型转换（如 <code>dynamic_cast</code>，将在后面章节讨论），并且只有在指针/引用确实指向一个派生类对象时才有效。</p>
<h3 id="13-4-2-虚成员函数和动态联编"><a href="#13-4-2-虚成员函数和动态联编" class="headerlink" title="13.4.2 虚成员函数和动态联编"></a>13.4.2 虚成员函数和动态联编</h3><p>现在考虑通过基类指针或引用调用成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pt-&gt;SomeMethod();</span><br><span class="line">rt.SomeMethod();</span><br></pre></td></tr></table></figure>

<p>编译器如何决定调用哪个 <code>SomeMethod</code> 的实现（基类的还是派生类的）？这取决于 <code>SomeMethod</code> 是否是<strong>虚函数</strong>以及联编方式。</p>
<p><strong>静态联编 (Static Binding / Early Binding):</strong></p>
<ul>
<li>  <strong>何时发生:</strong> 当调用的函数<strong>不是</strong>虚函数时，或者当通过<strong>对象本身</strong>（而不是指针或引用）调用函数时（无论是虚函数还是非虚函数）。</li>
<li>  <strong>决策依据:</strong> 编译器在<strong>编译时</strong>根据指针或引用的<strong>声明类型</strong>（静态类型）来决定调用哪个函数版本。</li>
<li>  <strong>行为:</strong> 即使基类指针 <code>pt</code> 指向一个派生类对象 <code>rp</code>，如果 <code>SomeMethod</code> 不是虚函数，<code>pt-&gt;SomeMethod()</code> 仍然会调用<strong>基类</strong>的 <code>SomeMethod</code> 版本。</li>
<li>  <strong>效率:</strong> 静态联编效率较高，因为在编译时就已经确定了要调用的函数地址。</li>
</ul>
<p><strong>动态联编 (Dynamic Binding / Late Binding):</strong></p>
<ul>
<li>  <strong>何时发生:</strong> 当通过<strong>基类指针或引用</strong>调用一个<strong>虚函数 (<code>virtual</code>)</strong> 时。</li>
<li>  <strong>决策依据:</strong> 程序在<strong>运行时</strong>检查指针或引用<strong>实际指向的对象类型</strong>，并调用该对象所属类的相应虚函数版本。</li>
<li>  <strong>行为:</strong> 如果基类指针 <code>pt</code> 指向一个派生类对象 <code>rp</code>，并且 <code>SomeMethod</code> 是虚函数，<code>pt-&gt;SomeMethod()</code> 会调用<strong>派生类</strong>的 <code>SomeMethod</code> 版本。这就是<strong>多态</strong>的核心。</li>
<li>  <strong>实现机制 (概念上):</strong> 编译器通常为包含虚函数的类创建一个**虚函数表 (virtual function table, vtable)**。vtable 是一个存储虚函数地址的数组。每个包含虚函数的类的对象内部都有一个隐藏的指针（通常称为 vptr），指向其类的 vtable。当通过基类指针调用虚函数时，程序通过对象的 vptr 找到 vtable，然后在 vtable 中查找并调用正确的函数地址。这个查找过程发生在运行时。</li>
<li>  <strong>效率:</strong> 动态联编比静态联编有轻微的运行时开销（需要查找 vtable），但在现代处理器上这种开销通常很小，而它带来的灵活性是巨大的。</li>
</ul>
<p><strong>总结对比:</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">静态联编 (Static Binding)</th>
<th align="left">动态联编 (Dynamic Binding)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>发生时间</strong></td>
<td align="left">编译时</td>
<td align="left">运行时</td>
</tr>
<tr>
<td align="left"><strong>触发条件</strong></td>
<td align="left">调用非虚函数，或通过对象调用任何函数</td>
<td align="left">通过<strong>基类指针/引用</strong>调用<strong>虚函数</strong></td>
</tr>
<tr>
<td align="left"><strong>决策依据</strong></td>
<td align="left">指针/引用的<strong>声明类型</strong> (静态类型)</td>
<td align="left">指针/引用<strong>实际指向的对象类型</strong> (动态类型)</td>
</tr>
<tr>
<td align="left"><strong>行为</strong></td>
<td align="left">调用声明类型的函数版本</td>
<td align="left">调用实际对象类型的函数版本 (多态)</td>
</tr>
<tr>
<td align="left"><strong>机制</strong></td>
<td align="left">直接函数调用</td>
<td align="left">通常通过虚函数表 (vtable) 实现</td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td align="left">较高</td>
<td align="left">略低于静态联编，但通常可接受</td>
</tr>
</tbody></table>
<h3 id="13-4-3-有关虚函数注意事项"><a href="#13-4-3-有关虚函数注意事项" class="headerlink" title="13.4.3 有关虚函数注意事项"></a>13.4.3 有关虚函数注意事项</h3><p>为了正确使用虚函数和动态联编，需要注意以下几点：</p>
<ol>
<li><p> <strong>在基类中声明 <code>virtual</code>:</strong> 必须在基类中将希望表现出多态行为的函数声明为 <code>virtual</code>。</p>
</li>
<li><p> <strong>派生类覆盖:</strong> 如果派生类提供了同名、同参数列表（包括 <code>const</code> 属性）的方法，它将自动覆盖（override）基类的虚函数。这个派生类方法也自动成为虚函数，无论是否显式使用了 <code>virtual</code> 关键字。</p>
</li>
<li><p><strong><code>override</code> 关键字 (C++11):</strong> 强烈建议在派生类覆盖虚函数时使用 <code>override</code> 关键字。这会让编译器检查该方法是否确实覆盖了基类中的某个虚函数。如果签名不匹配（例如，参数类型不同或 <code>const</code> 属性不同），编译器会报错，帮助捕获潜在错误。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual void func(int) override; // 错误！const 属性不匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// 正确！明确覆盖</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>final</code> 关键字 (C++11):</strong> 如果不希望某个虚函数在更深层次的派生类中被进一步覆盖，可以在其声明后加上 <code>final</code>。也可以将整个类声明为 <code>final</code>，阻止任何类从它派生。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 覆盖 func，并且不允许 Derived 的子类再覆盖它</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreDerived</span> :</span> <span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual void func() const override; // 错误！因为 Derived::func 被标记为 final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CannotInherit</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> Base &#123; <span class="comment">// 这个类不能被继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class Problem : public CannotInherit &#123;&#125;; // 错误！</span></span><br></pre></td></tr></table></figure></li>
<li><p> <strong>构造函数不能是虚函数:</strong> 对象的类型在构造完成之前是未确定的，因此构造函数无法实现动态联编。</p>
</li>
<li><p><strong>析构函数应该是虚函数:</strong> 如果一个类打算作为基类（特别是如果可能通过基类指针 <code>delete</code> 派生类对象），那么它的析构函数<strong>应该</strong>声明为虚函数 (<code>virtual ~Base();</code>)。</p>
<ul>
<li>  <strong>原因:</strong> 考虑 <code>Base *p = new Derived; delete p;</code>。如果 <code>~Base()</code> 不是虚函数，<code>delete p;</code> 只会调用 <code>~Base()</code>，派生类 <code>Derived</code> 的析构函数 <code>~Derived()</code> 将<strong>不会</strong>被调用，可能导致派生类分配的资源（如动态内存）泄漏。如果 <code>~Base()</code> 是虚函数，<code>delete p;</code> 会通过动态联编正确地调用 <code>~Derived()</code>，然后再调用 <code>~Base()</code>，确保所有资源都被释放。</li>
<li>  <strong>规则:</strong> 如果类中有任何虚函数，通常就应该提供一个虚析构函数。即使基类析构函数什么也不做，也应将其声明为 <code>virtual</code>。</li>
</ul>
</li>
<li><p> <strong>友元函数不能是虚函数:</strong> 友元函数不是类的成员函数，继承机制不适用于它们。</p>
</li>
<li><p> <strong>静态成员函数不能是虚函数:</strong> 静态成员函数与类本身关联，而不是与特定对象关联（没有 <code>this</code> 指针），因此动态联编对其没有意义。</p>
</li>
</ol>
<p>理解静态联编和动态联编的区别，以及何时、如何使用虚函数，是掌握 C++ 多态特性和编写健壮、可扩展的面向对象代码的关键。</p>
<h2 id="13-5-访问控制：protected"><a href="#13-5-访问控制：protected" class="headerlink" title="13.5 访问控制：protected"></a>13.5 访问控制：protected</h2><p>到目前为止，我们使用了 <code>public</code> 和 <code>private</code> 访问说明符来控制对类成员的访问。</p>
<ul>
<li>  <code>public</code> 成员可以被任何地方的代码访问。</li>
<li>  <code>private</code> 成员只能被定义它们的类的成员函数（以及友元）访问。</li>
</ul>
<p>在继承的背景下，<code>private</code> 成员有一个重要的限制：<strong>基类的 <code>private</code> 成员不能被派生类的成员函数直接访问</strong>。派生类需要通过基类的 <code>public</code> 或 <code>protected</code> 接口（方法）来间接与基类的私有数据交互。</p>
<p>C++ 提供了第三个访问说明符：**<code>protected</code>**。</p>
<p><strong><code>protected</code> 成员的访问规则:</strong></p>
<ul>
<li>  对于<strong>类的外部</strong>（非成员函数，非派生类），<code>protected</code> 成员的行为与 <code>private</code> 成员<strong>相同</strong>，即不可访问。</li>
<li>  对于<strong>类的成员函数</strong>（以及友元），<code>protected</code> 成员的行为与 <code>public</code> 成员<strong>相同</strong>，即可直接访问。</li>
<li>  对于<strong>派生类的成员函数</strong>，<code>protected</code> 成员的行为也与 <code>public</code> 成员<strong>相同</strong>，即派生类<strong>可以</strong>直接访问基类的 <code>protected</code> 成员。</li>
</ul>
<p><strong>总结访问权限:</strong></p>
<table>
<thead>
<tr>
<th align="left">访问来源</th>
<th align="left"><code>public</code> 成员</th>
<th align="left"><code>protected</code> 成员</th>
<th align="left"><code>private</code> 成员</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类内部 (成员函数)</td>
<td align="left">可访问</td>
<td align="left">可访问</td>
<td align="left">可访问</td>
</tr>
<tr>
<td align="left">派生类 (成员函数)</td>
<td align="left">可访问</td>
<td align="left"><strong>可访问</strong></td>
<td align="left"><strong>不可访问</strong></td>
</tr>
<tr>
<td align="left">类外部 (普通代码)</td>
<td align="left">可访问</td>
<td align="left"><strong>不可访问</strong></td>
<td align="left"><strong>不可访问</strong></td>
</tr>
</tbody></table>
<p><strong>示例：修改 <code>TableTennisPlayer</code> 使用 <code>protected</code></strong></p>
<p>让我们修改 <code>TableTennisPlayer</code> 类，将 <code>firstname</code> 和 <code>lastname</code> 设为 <code>protected</code>，看看 <code>RatedPlayer</code> 如何访问它们。</p>
<p><strong>tabtenn_prot.h (使用 protected 的版本)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN_PROT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN_PROT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 - 使用 protected 成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayerProt</span> &#123;</span></span><br><span class="line"><span class="comment">// protected 成员:</span></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// 改为 protected</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname;</span><br><span class="line"><span class="keyword">private</span>:   <span class="comment">// hasTable 仍然是 private</span></span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TableTennisPlayerProt (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                           <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// Name() 不再需要，因为派生类可以直接访问 protected 成员来构建自己的 Name()</span></span><br><span class="line">    <span class="comment">// virtual void Name() const; // 可以移除或保留</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~TableTennisPlayerProt() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayerProt</span> :</span> <span class="keyword">public</span> TableTennisPlayerProt &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RatedPlayerProt (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    RatedPlayerProt(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayerProt &amp; tp);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123; rating = r; &#125;</span><br><span class="line">    <span class="comment">// 派生类可以直接访问基类的 protected 成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 新增一个方法来演示访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TABTENN_PROT_H_</span></span></span><br></pre></td></tr></table></figure>

<p><strong>tabtenn_prot.cpp (实现)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn_prot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TableTennisPlayerProt 方法</span></span><br><span class="line">TableTennisPlayerProt::TableTennisPlayerProt (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                              : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayerProt 方法</span></span><br><span class="line">RatedPlayerProt::RatedPlayerProt(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                 : TableTennisPlayerProt(fn, ln, ht), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这个构造函数仍然需要调用基类构造函数，</span></span><br><span class="line"><span class="comment">// 因为即使 firstname/lastname 是 protected，初始化也应由基类负责。</span></span><br><span class="line"><span class="comment">// 但如果基类没有提供合适的构造函数，派生类可以在其构造函数体中</span></span><br><span class="line"><span class="comment">// 直接给 protected 成员赋值 (虽然不推荐)。</span></span><br><span class="line">RatedPlayerProt::RatedPlayerProt(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayerProt &amp; tp)</span><br><span class="line">                                 : TableTennisPlayerProt(tp), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类方法可以直接访问基类的 protected 成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RatedPlayerProt::ShowInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接访问继承来的 protected 成员 firstname 和 lastname</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rating;</span><br><span class="line">    <span class="comment">// 不能直接访问基类的 private 成员 hasTable</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; HasTable(); // 需要通过基类的 public 方法访问</span></span><br><span class="line">    <span class="keyword">if</span> (HasTable())</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Has Table: Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Has Table: No\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例 (usett_prot.cpp)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn_prot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RatedPlayerProt <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">TableTennisPlayerProt <span class="title">player1</span><span class="params">(<span class="string">&quot;Tara&quot;</span>, <span class="string">&quot;Boomdea&quot;</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 基类对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rated Player Info:\n&quot;</span>;</span><br><span class="line">    rplayer1.ShowInfo(); <span class="comment">// 调用派生类方法，该方法访问了基类的 protected 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部代码不能直接访问 protected 成员</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; rplayer1.firstname; // 错误！firstname 是 protected</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; player1.lastname;  // 错误！lastname 是 protected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部代码可以访问 public 成员</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nPlayer 1 Has Table? &quot;</span> &lt;&lt; player1.HasTable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和运行:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ usett_prot.cpp tabtenn_prot.cpp -o usett_prot</span><br><span class="line">./usett_prot</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rated Player Info:</span><br><span class="line">Name: Duck, Mallory; Rating: 1140; Has Table: Yes</span><br><span class="line"></span><br><span class="line">Player 1 Has Table? 0</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>protected</code> 的利弊:</strong></p>
<ul>
<li><strong>优点:</strong><ul>
<li>  为派生类提供比 <code>private</code> 更大的访问权限，允许派生类更直接地与基类实现交互。</li>
<li>  相比 <code>public</code>，仍然对外部世界隐藏了实现细节。</li>
</ul>
</li>
<li><strong>缺点:</strong><ul>
<li>  <strong>破坏封装:</strong> 将成员设为 <code>protected</code> 而不是 <code>private</code>，意味着基类的实现细节暴露给了所有派生类。如果将来修改基类的 <code>protected</code> 成员，可能会影响所有派生类，增加了类之间的耦合度。</li>
<li>  <strong>维护困难:</strong> 随着继承层次的加深，追踪哪些类依赖于特定的 <code>protected</code> 成员会变得困难。</li>
</ul>
</li>
</ul>
<p><strong>设计建议:</strong></p>
<ul>
<li>  优先使用 <code>private</code> 成员，并通过 <code>public</code> 或 <code>protected</code> <strong>成员函数</strong>提供对数据的访问（如果需要）。这提供了更好的封装和灵活性。</li>
<li>  只有当你确定派生类确实需要直接访问基类的某个实现细节，并且提供 <code>public/protected</code> 接口不方便或效率低下时，才考虑使用 <code>protected</code> 数据成员。</li>
<li>  <code>protected</code> <strong>成员函数</strong>通常比 <code>protected</code> <strong>数据成员</strong>更受欢迎，因为它们提供了受控的访问接口，而不是直接暴露数据。</li>
</ul>
<p>总之，<code>protected</code> 提供了一种介于 <code>private</code> 和 <code>public</code> 之间的访问控制级别，主要用于管理基类和派生类之间的访问权限。</p>
<h2 id="13-6-抽象基类"><a href="#13-6-抽象基类" class="headerlink" title="13.6 抽象基类"></a>13.6 抽象基类</h2><p>在设计类层次结构时，我们有时会遇到这样一种情况：基类本身代表的是一个非常<strong>抽象</strong>的概念，以至于创建该基类的对象本身没有意义。它存在的目的主要是为了定义一个<strong>共同的接口</strong>，供所有具体的派生类来实现。这种只作为接口规范、不能被实例化的基类称为**抽象基类 (Abstract Base Class, ABC)**。</p>
<p>例如，考虑一个图形库，可能有一个 <code>Shape</code> 基类。但什么是“形状”本身？它太抽象了。我们实际操作的是具体的形状，如 <code>Circle</code>（圆）、<code>Rectangle</code>（矩形）、<code>Triangle</code>（三角形）等。创建一个通用的 <code>Shape</code> 对象可能没有意义，但我们希望所有具体的形状类都提供某些共同的操作，比如计算面积 (<code>Area()</code>) 或绘制 (<code>Draw()</code>)。</p>
<p>C++ 通过<strong>纯虚函数 (Pure Virtual Function)</strong> 来实现抽象基类。</p>
<p><strong>纯虚函数 (Pure Virtual Function):</strong></p>
<ul>
<li><p>  纯虚函数是一种特殊的虚函数，它在基类中<strong>没有提供实现</strong>（或者说，实现被延迟到派生类）。</p>
</li>
<li><p>  它用于声明一个接口，强制所有非抽象的派生类必须提供自己的实现。</p>
</li>
<li><p><strong>语法:</strong> 在虚函数声明的末尾加上 <code>= 0</code>。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(parameters)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数声明</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>抽象基类 (ABC) 的定义:</strong></p>
<ul>
<li>  包含<strong>至少一个</strong>纯虚函数的类就是抽象基类 (ABC)。</li>
</ul>
<p><strong>ABC 的特性:</strong></p>
<ol>
<li><p><strong>不能实例化:</strong> 你<strong>不能</strong>创建抽象基类的对象。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Shape 是一个 ABC</span></span><br><span class="line"><span class="comment">// Shape myShape; // 错误！不能创建 ABC 的对象</span></span><br></pre></td></tr></table></figure>
<p> 编译器会阻止你这样做，因为 ABC 中的纯虚函数没有实现，对象是不完整的。</p>
</li>
<li><p> <strong>可以作为接口:</strong> ABC 主要用作定义接口。它规定了所有派生类必须实现哪些方法。</p>
</li>
<li><p><strong>可以有指针和引用:</strong> 虽然不能创建 ABC 的对象，但你可以声明指向 ABC 的<strong>指针</strong>或<strong>引用</strong>。这些指针或引用可以指向或引用其<strong>具体的派生类对象</strong>。这对于实现多态至关重要。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Circle 是从 Shape 派生的具体类</span></span><br><span class="line">Shape * shapePtr = <span class="keyword">new</span> Circle(<span class="number">5.0</span>); <span class="comment">// OK: 基类指针指向派生类对象</span></span><br><span class="line">Shape &amp; shapeRef = *shapePtr;       <span class="comment">// OK: 基类引用引用派生类对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p> <strong>派生类必须实现纯虚函数:</strong> 任何从 ABC 派生的类，如果<strong>没有</strong>为继承来的<strong>所有</strong>纯虚函数提供实现，那么这个派生类<strong>也</strong>将成为一个抽象基类，同样不能被实例化。只有当派生类实现了所有继承的纯虚函数时，它才成为**具体类 (Concrete Class)**，可以被实例化。</p>
</li>
</ol>
<h3 id="13-6-1-应用-ABC-概念"><a href="#13-6-1-应用-ABC-概念" class="headerlink" title="13.6.1 应用 ABC 概念"></a>13.6.1 应用 ABC 概念</h3><p>让我们定义一个简单的银行账户 ABC <code>AcctABC</code>。一个通用的“账户”可能无法直接操作，但所有具体的账户类型（如支票账户、储蓄账户）都应该有查询余额、存款、取款等操作。</p>
<p><strong>acctabc.h (ABC 定义)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ACCTABC_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCTABC_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类 AcctABC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcctABC</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fullName;</span><br><span class="line">    <span class="keyword">long</span> acctNum;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// 改为 protected 以便派生类访问</span></span><br><span class="line">    <span class="comment">// 辅助格式化函数 (protected，派生类可用)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Formatting</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::ios_base::fmtflags flag;</span><br><span class="line">        <span class="built_in">std</span>::streamsize pr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">FullName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> fullName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">AcctNum</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> acctNum; &#125;</span><br><span class="line">    <span class="function">Formatting <span class="title">SetFormat</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Restore</span><span class="params">(Formatting &amp; f)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 (ABC 也可以有构造函数)</span></span><br><span class="line">    AcctABC(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>,</span><br><span class="line">            <span class="keyword">double</span> bal = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deposit</span><span class="params">(<span class="keyword">double</span> amt)</span></span>;</span><br><span class="line">    <span class="comment">// 取款 - 设为纯虚函数，具体实现在派生类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查询余额</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> balance; &#125;</span><br><span class="line">    <span class="comment">// 查看账户信息 - 设为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚析构函数 (基类有虚函数，析构函数也应是虚的)</span></span><br><span class="line">    <span class="keyword">virtual</span> ~AcctABC() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的派生类: Brass Account (支票账户)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> :</span> <span class="keyword">public</span> AcctABC &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Brass(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>,</span><br><span class="line">          <span class="keyword">double</span> bal = <span class="number">0.0</span>) : AcctABC(s, an, bal) &#123;&#125;</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 Withdraw</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 ViewAcct</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// Brass 类没有新的纯虚函数，所以是具体类</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Brass() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的派生类: BrassPlus Account (带透支保护的支票账户)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrassPlus</span> :</span> <span class="keyword">public</span> AcctABC &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> maxLoan;     <span class="comment">// 最大透支额</span></span><br><span class="line">    <span class="keyword">double</span> rate;        <span class="comment">// 透支利率</span></span><br><span class="line">    <span class="keyword">double</span> owesBank;    <span class="comment">// 当前欠款</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BrassPlus(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>,</span><br><span class="line">              <span class="keyword">double</span> bal = <span class="number">0.0</span>, <span class="keyword">double</span> ml = <span class="number">500</span>,</span><br><span class="line">              <span class="keyword">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    BrassPlus(<span class="keyword">const</span> Brass &amp; ba, <span class="keyword">double</span> ml = <span class="number">500</span>, <span class="keyword">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 Withdraw</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 ViewAcct</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 派生类自己的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetMax</span><span class="params">(<span class="keyword">double</span> m)</span> </span>&#123; maxLoan = m; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRate</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; rate = r; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~BrassPlus() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ACCTABC_H_</span></span></span><br></pre></td></tr></table></figure>

<p><strong>acctabc.cpp (实现)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;acctabc.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ios_base;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- AcctABC 方法实现 ---</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AcctABC::AcctABC(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s, <span class="keyword">long</span> an, <span class="keyword">double</span> bal) &#123;</span><br><span class="line">    fullName = s;</span><br><span class="line">    acctNum = an;</span><br><span class="line">    balance = bal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存款 (非虚函数，所有账户类型通用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcctABC::Deposit</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Negative deposit not allowed; &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;deposit is cancelled.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        balance += amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：纯虚函数 Withdraw() 和 ViewAcct() 在基类中没有实现体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助格式化函数</span></span><br><span class="line"><span class="function">AcctABC::Formatting <span class="title">AcctABC::SetFormat</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Formatting f;</span><br><span class="line">    f.flag = <span class="built_in">cout</span>.setf(ios_base::fixed, ios_base::floatfield); <span class="comment">// use fixed-point</span></span><br><span class="line">    f.pr = <span class="built_in">cout</span>.precision(<span class="number">2</span>); <span class="comment">// for $$$.cc format</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcctABC::Restore</span><span class="params">(Formatting &amp; f)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf(f.flag, ios_base::floatfield);</span><br><span class="line">    <span class="built_in">cout</span>.precision(f.pr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Brass 方法实现 ---</span></span><br><span class="line"><span class="comment">// 实现纯虚函数 Withdraw</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brass::Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Withdrawal amount must be positive; &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;withdrawal canceled.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amt &lt;= Balance()) &#123; <span class="comment">// 使用基类的 Balance() 方法</span></span><br><span class="line">        AcctABC::Withdraw(amt); <span class="comment">// 调用基类版本来更新余额 (如果基类有实现的话，这里假设基类没实现，直接修改)</span></span><br><span class="line">        balance -= amt;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Withdrawal amount of $&quot;</span> &lt;&lt; amt</span><br><span class="line">             &lt;&lt; <span class="string">&quot; exceeds your balance.\n&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Withdrawal canceled.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现纯虚函数 ViewAcct</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brass::ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Formatting f = SetFormat(); <span class="comment">// 使用基类的格式化辅助函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Brass Client: &quot;</span> &lt;&lt; FullName() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 使用基类的 protected 方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Account Number: &quot;</span> &lt;&lt; AcctNum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 使用基类的 protected 方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Balance: $&quot;</span> &lt;&lt; Balance() &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 使用基类的 public 方法</span></span><br><span class="line">    Restore(f); <span class="comment">// 恢复格式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- BrassPlus 方法实现 ---</span></span><br><span class="line">BrassPlus::BrassPlus(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s, <span class="keyword">long</span> an, <span class="keyword">double</span> bal,</span><br><span class="line">                     <span class="keyword">double</span> ml, <span class="keyword">double</span> r) : AcctABC(s, an, bal) &#123;</span><br><span class="line">    maxLoan = ml;</span><br><span class="line">    owesBank = <span class="number">0.0</span>;</span><br><span class="line">    rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BrassPlus::BrassPlus(<span class="keyword">const</span> Brass &amp; ba, <span class="keyword">double</span> ml, <span class="keyword">double</span> r)</span><br><span class="line">           : AcctABC(ba) &#123; <span class="comment">// 使用 AcctABC 的隐式复制构造函数 (如果存在且可用)</span></span><br><span class="line">                           <span class="comment">// 或者显式调用 AcctABC(ba.FullName(), ba.AcctNum(), ba.Balance())</span></span><br><span class="line">                           <span class="comment">// (需要 ba 提供访问器或 AcctABC 成员是 protected)</span></span><br><span class="line">    maxLoan = ml;</span><br><span class="line">    owesBank = <span class="number">0.0</span>;</span><br><span class="line">    rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现纯虚函数 ViewAcct</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Formatting f = SetFormat();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BrassPlus Client: &quot;</span> &lt;&lt; FullName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Account Number: &quot;</span> &lt;&lt; AcctNum() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Balance: $&quot;</span> &lt;&lt; Balance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum loan: $&quot;</span> &lt;&lt; maxLoan &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Owed to bank: $&quot;</span> &lt;&lt; owesBank &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loan Rate: &quot;</span> &lt;&lt; <span class="number">100</span> * rate &lt;&lt; <span class="string">&quot;%\n&quot;</span>;</span><br><span class="line">    Restore(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现纯虚函数 Withdraw</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BrassPlus::Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Withdrawal amount must be positive; &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;withdrawal canceled.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Formatting f = SetFormat();</span><br><span class="line">    <span class="keyword">double</span> bal = Balance(); <span class="comment">// 获取当前余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (amt &lt;= bal) &#123; <span class="comment">// 如果余额足够</span></span><br><span class="line">        <span class="comment">// 调用基类的 Withdraw (如果它修改余额) 或直接修改</span></span><br><span class="line">        <span class="comment">// 假设 balance 是 protected:</span></span><br><span class="line">        balance -= amt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amt &lt;= bal + maxLoan - owesBank) &#123; <span class="comment">// 如果余额+剩余可透支额度足够</span></span><br><span class="line">        <span class="keyword">double</span> advance = amt - bal; <span class="comment">// 需要透支的金额</span></span><br><span class="line">        owesBank += advance * (<span class="number">1.0</span> + rate); <span class="comment">// 计算欠款 (加上利息)</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bank advance: $&quot;</span> &lt;&lt; advance &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Finance charge: $&quot;</span> &lt;&lt; advance * rate &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Deposit(advance); <span class="comment">// 先存入透支额度 (增加余额)</span></span><br><span class="line">        <span class="comment">// 再取款 (修改余额)</span></span><br><span class="line">        <span class="comment">// 假设 balance 是 protected:</span></span><br><span class="line">        balance -= amt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Credit limit exceeded. Transaction cancelled.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Restore(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例 (usebrass1.cpp)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;acctabc.h&quot;</span> <span class="comment">// 包含 ABC 和派生类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CLIENTS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AcctABC anAccount; // 错误！不能创建抽象基类对象</span></span><br><span class="line"></span><br><span class="line">    AcctABC * p_clients[CLIENTS]; <span class="comment">// 可以创建指向 ABC 的指针数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">long</span> tempnum;</span><br><span class="line">    <span class="keyword">double</span> tempbal;</span><br><span class="line">    <span class="keyword">char</span> kind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter client&#x27;s name: &quot;</span>;</span><br><span class="line">        getline(<span class="built_in">cin</span>, temp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter client&#x27;s account number: &quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tempnum;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter opening balance: $&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tempbal;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter 1 for Brass Account or &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;2 for BrassPlus Account: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; kind &amp;&amp; (kind != <span class="string">&#x27;1&#x27;</span> &amp;&amp; kind != <span class="string">&#x27;2&#x27;</span>))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter either 1 or 2: &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            p_clients[i] = <span class="keyword">new</span> Brass(temp, tempnum, tempbal);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> tmax, trate;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the overdraft limit: $&quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmax;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the interest rate &quot;</span></span><br><span class="line">                 &lt;&lt; <span class="string">&quot;as a decimal fraction: &quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; trate;</span><br><span class="line">            p_clients[i] = <span class="keyword">new</span> BrassPlus(temp, tempnum, tempbal, tmax, trate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 清除行尾换行符</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用多态性处理不同类型的账户</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++) &#123;</span><br><span class="line">        p_clients[i]-&gt;ViewAcct(); <span class="comment">// 调用虚函数 ViewAcct()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_clients[i]; <span class="comment">// 调用虚析构函数，确保正确的析构函数被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和运行:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 假设 acctabc.h 中 balance 已移至 protected</span></span><br><span class="line">g++ usebrass1.cpp acctabc.cpp -o usebrass1</span><br><span class="line">./usebrass1</span><br></pre></td></tr></table></figure>

<p>程序会提示输入客户信息，创建不同类型的账户对象，然后通过基类指针数组 <code>p_clients</code> 多态地调用 <code>ViewAcct()</code> 方法，显示每个账户的信息。最后，通过 <code>delete p_clients[i]</code> 安全地销毁对象，因为 <code>~AcctABC()</code> 是虚析构函数。</p>
<h3 id="13-6-2-ABC-理念"><a href="#13-6-2-ABC-理念" class="headerlink" title="13.6.2 ABC 理念"></a>13.6.2 ABC 理念</h3><p>抽象基类的核心理念是<strong>接口与实现分离</strong>。</p>
<ul>
<li>  <strong>接口:</strong> ABC 定义了一个通用的接口（通过纯虚函数和可能的非虚函数），规定了派生类应该具有哪些功能。</li>
<li>  <strong>实现:</strong> 具体的派生类负责提供这些功能的具体实现。</li>
</ul>
<p>使用 ABC 的好处：</p>
<ol>
<li> <strong>强制接口统一:</strong> 确保所有相关的派生类都遵循一个共同的接口规范。</li>
<li> <strong>实现多态:</strong> 允许通过基类指针或引用来统一处理不同派生类的对象，调用它们各自实现的虚函数版本。</li>
<li> <strong>代码可扩展性:</strong> 当需要添加新的账户类型（例如 <code>SavingsAccount</code>）时，只需从 <code>AcctABC</code> 派生并实现其纯虚函数即可，现有使用 <code>AcctABC*</code> 的代码（如 <code>main</code> 函数中的循环）通常无需修改就能处理新的账户类型。</li>
<li> <strong>清晰的设计:</strong> 更好地模拟现实世界中的抽象概念和层次关系。</li>
</ol>
<p>ABC 是 C++ 中实现抽象和多态的关键工具，对于设计灵活、可维护的面向对象系统非常重要。</p>
<h2 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h2><p>当继承与动态内存分配（使用 <code>new</code> 和 <code>delete</code>）结合时，我们需要特别注意析构函数、复制构造函数和赋值运算符的行为，以确保资源的正确管理。主要有两种情况：</p>
<h3 id="13-7-1-第一种情况：派生类不使用-new"><a href="#13-7-1-第一种情况：派生类不使用-new" class="headerlink" title="13.7.1 第一种情况：派生类不使用 new"></a>13.7.1 第一种情况：派生类不使用 <code>new</code></h3><p>如果基类使用了动态内存分配（因此需要自定义析构函数、复制构造函数、赋值运算符），而派生类<strong>没有</strong>使用 <code>new</code> 来分配自己的动态内存，情况相对简单。</p>
<ul>
<li><p><strong>析构函数:</strong></p>
<ul>
<li>  派生类不需要显式定义析构函数来释放内存（因为它没有分配）。</li>
<li>  当派生类对象被销毁时，会先执行派生类的析构函数（即使是编译器生成的默认版本），然后<strong>自动</strong>调用基类的析构函数。</li>
<li>  <strong>关键:</strong> 为了能通过基类指针 <code>delete</code> 派生类对象，基类的析构函数<strong>必须</strong>声明为 <code>virtual</code>。如果基类析构函数是虚函数，那么 <code>delete basePtr;</code> (其中 <code>basePtr</code> 指向派生类对象) 会先调用派生类的析构函数，再调用基类的析构函数，确保所有资源被正确释放。</li>
</ul>
</li>
<li><p><strong>复制构造函数:</strong></p>
<ul>
<li>  派生类的默认复制构造函数会执行成员逐一复制。对于继承自基类的部分，它会自动调用<strong>基类的复制构造函数</strong>。</li>
<li>  因此，如果基类的复制构造函数正确实现了深复制，那么派生类对象的基类部分也会被正确地深复制。派生类自身的成员（非动态分配）会被正常复制。</li>
</ul>
</li>
<li><p><strong>赋值运算符:</strong></p>
<ul>
<li>  派生类的默认赋值运算符会执行成员逐一赋值。对于继承自基类的部分，它会自动调用<strong>基类的赋值运算符</strong>。</li>
<li>  因此，如果基类的赋值运算符正确实现了深复制（包括处理自我赋值和释放旧内存），那么派生类对象的基类部分也会被正确地赋值。</li>
</ul>
</li>
</ul>
<p><strong>结论:</strong> 如果基类正确地管理了它的动态内存（遵循三/五法则，特别是使用虚析构函数），并且派生类没有引入新的动态内存管理需求，那么派生类通常不需要显式定义这些特殊的成员函数。</p>
<p><strong>示例 (baseDMA 和 lacksDMA):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dma.h -- 继承和动态内存分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DMA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态内存分配的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseDMA</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * label;</span><br><span class="line">    <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    baseDMA(<span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    baseDMA(<span class="keyword">const</span> baseDMA &amp; rs); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~baseDMA(); <span class="comment">// 虚析构函数</span></span><br><span class="line">    baseDMA &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> baseDMA &amp; rs); <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 - 不使用 new</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lacksDMA</span> :</span> <span class="keyword">public</span> baseDMA &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> COL_LEN = <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> color[COL_LEN];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c = <span class="string">&quot;blank&quot;</span>, <span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    <span class="comment">// 不需要自定义析构函数、复制构造函数、赋值运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> lacksDMA &amp; ls);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DMA_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dma.cpp -- 实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dma.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- baseDMA 实现 ---</span></span><br><span class="line">baseDMA::baseDMA(<span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(l) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(label, l);</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA::baseDMA(<span class="keyword">const</span> baseDMA &amp; rs) &#123; <span class="comment">// 深复制</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(rs.label) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(label, rs.label);</span><br><span class="line">    rating = rs.rating;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA::~baseDMA() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA &amp; baseDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> baseDMA &amp; rs) &#123; <span class="comment">// 深复制赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] label; <span class="comment">// 释放旧内存</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(rs.label) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(label, rs.label);</span><br><span class="line">    rating = rs.rating;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> baseDMA &amp; rs) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Label: &quot;</span> &lt;&lt; rs.label &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Rating: &quot;</span> &lt;&lt; rs.rating &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- lacksDMA 实现 ---</span></span><br><span class="line">lacksDMA::lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</span><br><span class="line">    : baseDMA(l, r) &#123; <span class="comment">// 调用基类构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strncpy</span>(color, c, COL_LEN - <span class="number">1</span>);</span><br><span class="line">    color[COL_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lacksDMA::lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">    : baseDMA(rs) &#123; <span class="comment">// 调用基类复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strncpy</span>(color, c, COL_LEN - <span class="number">1</span>);</span><br><span class="line">    color[COL_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> lacksDMA &amp; ls) &#123;</span><br><span class="line">    <span class="comment">// 调用基类的 operator&lt;&lt; (需要友元或类型转换，或者直接访问)</span></span><br><span class="line">    <span class="comment">// 这里假设通过类型转换或直接调用基类方法</span></span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> baseDMA &amp;) ls; <span class="comment">// 将派生类引用转换为基类引用来调用基类 operator&lt;&lt;</span></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Color: &quot;</span> &lt;&lt; ls.color &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usedma.cpp -- 使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dma.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">baseDMA <span class="title">shirt</span><span class="params">(<span class="string">&quot;Portabelly&quot;</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="function">lacksDMA <span class="title">balloon</span><span class="params">(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;Blimpo&quot;</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 派生类对象</span></span><br><span class="line">    <span class="function">lacksDMA <span class="title">balloon2</span><span class="params">(balloon)</span></span>; <span class="comment">// 使用默认复制构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying baseDMA object:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; shirt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying lacksDMA object:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; balloon;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of lacksDMA copy:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; balloon2;</span><br><span class="line"></span><br><span class="line">    baseDMA * p_dma = &amp;balloon; <span class="comment">// 基类指针指向派生类</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Deleting derived object via base pointer:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> p_dma; <span class="comment">// 正确调用 ~lacksDMA() (默认) 然后 ~baseDMA() (虚函数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-7-2-第二种情况：派生类使用-new"><a href="#13-7-2-第二种情况：派生类使用-new" class="headerlink" title="13.7.2 第二种情况：派生类使用 new"></a>13.7.2 第二种情况：派生类使用 <code>new</code></h3><p>如果派生类<strong>也</strong>使用了 <code>new</code> 来分配自己的动态内存，那么派生类<strong>必须</strong>提供自己的析构函数、复制构造函数和赋值运算符。</p>
<ul>
<li><p><strong>析构函数 (<code>~Derived()</code>):</strong></p>
<ul>
<li>  必须显式定义。</li>
<li>  负责 <code>delete</code> 或 <code>delete[]</code> <strong>派生类自己分配</strong>的内存。</li>
<li>  不需要（也不能）显式调用基类的析构函数；基类析构函数会在派生类析构函数执行完毕后<strong>自动</strong>被调用。</li>
<li>  基类析构函数仍应是 <code>virtual</code>。</li>
</ul>
</li>
<li><p><strong>复制构造函数 (<code>Derived(const Derived &amp;)</code>):</strong></p>
<ul>
<li>  必须显式定义。</li>
<li>  在<strong>成员初始化列表</strong>中，必须显式调用<strong>基类的复制构造函数</strong> <code>Base(other)</code> 来完成基类部分的深复制。</li>
<li>  然后，在构造函数体中，为派生类自己管理的动态内存执行深复制（分配新内存，复制数据）。</li>
</ul>
</li>
<li><p><strong>赋值运算符 (<code>Derived &amp; operator=(const Derived &amp;)</code>):</strong></p>
<ul>
<li>  必须显式定义。</li>
<li>  <strong>检查自我赋值</strong>。</li>
<li>  显式调用<strong>基类的赋值运算符</strong> <code>Base::operator=(other)</code> 来完成基类部分的深复制赋值。</li>
<li>  释放<strong>派生类当前对象</strong>的旧动态内存。</li>
<li>  为派生类当前对象的动态成员分配新内存，并从源对象复制数据。</li>
<li>  返回 <code>*this</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例 (添加 hasDMA 类):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dma.h (续)</span></span><br><span class="line"><span class="comment">// 派生类 - 使用 new</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hasDMA</span> :</span> <span class="keyword">public</span> baseDMA &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * style; <span class="comment">// 派生类管理的动态内存</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s = <span class="string">&quot;none&quot;</span>, <span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    hasDMA(<span class="keyword">const</span> hasDMA &amp; hs); <span class="comment">// 复制构造函数</span></span><br><span class="line">    ~hasDMA(); <span class="comment">// 析构函数</span></span><br><span class="line">    hasDMA &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp; hs); <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> hasDMA &amp; hs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dma.cpp (续)</span></span><br><span class="line"><span class="comment">// --- hasDMA 实现 ---</span></span><br><span class="line">hasDMA::hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</span><br><span class="line">    : baseDMA(l, r) &#123; <span class="comment">// 调用基类构造函数</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">    : baseDMA(rs) &#123; <span class="comment">// 调用基类复制构造函数</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::hasDMA(<span class="keyword">const</span> hasDMA &amp; hs)</span><br><span class="line">    : baseDMA(hs) &#123; <span class="comment">// *** 调用基类复制构造函数 ***</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>]; <span class="comment">// 深复制派生类成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, hs.style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::~hasDMA() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] style; <span class="comment">// 释放派生类分配的内存 (基类析构函数会自动调用)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp; hs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;hs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    baseDMA::<span class="keyword">operator</span>=(hs); <span class="comment">// *** 调用基类赋值运算符 ***</span></span><br><span class="line">    <span class="keyword">delete</span> [] style;        <span class="comment">// 释放派生类旧内存</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>]; <span class="comment">// 深复制派生类成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, hs.style);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> hasDMA &amp; hs) &#123;</span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> baseDMA &amp;) hs; <span class="comment">// 显示基类部分</span></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 显示派生类部分</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usedma.cpp (续)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... (之前的代码) ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nTesting hasDMA:\n&quot;</span>;</span><br><span class="line">    <span class="function">hasDMA <span class="title">map</span><span class="params">(<span class="string">&quot;Mercator&quot;</span>, <span class="string">&quot;Buffalo Keys&quot;</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    hasDMA map2 = <span class="built_in">map</span>; <span class="comment">// 调用 hasDMA 复制构造函数</span></span><br><span class="line">    hasDMA map3;</span><br><span class="line">    map3 = <span class="built_in">map</span>; <span class="comment">// 调用 hasDMA 赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying hasDMA object:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of hasDMA copy:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of hasDMA assignment:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map3;</span><br><span class="line"></span><br><span class="line">    baseDMA * p_dma2 = &amp;<span class="built_in">map</span>; <span class="comment">// 基类指针指向派生类</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Deleting derived object via base pointer:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> p_dma2; <span class="comment">// 正确调用 ~hasDMA() 然后 ~baseDMA()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-7-3-使用动态内存分配和友元的继承示例"><a href="#13-7-3-使用动态内存分配和友元的继承示例" class="headerlink" title="13.7.3 使用动态内存分配和友元的继承示例"></a>13.7.3 使用动态内存分配和友元的继承示例</h3><p>在上面的 <code>lacksDMA</code> 和 <code>hasDMA</code> 示例中，我们重载了 <code>operator&lt;&lt;</code> 作为友元函数。当在派生类的友元函数中需要显示基类信息时，有几种方法：</p>
<ol>
<li> <strong>使用基类的公有/保护接口:</strong> 如果基类提供了访问所需信息的 <code>public</code> 或 <code>protected</code> 方法，友元函数可以通过派生类对象调用这些方法。</li>
<li> <strong>使用类型转换:</strong> 将派生类对象的引用强制转换为基类对象的引用 <code>(const baseDMA &amp;) hs</code>，然后调用基类版本的 <code>operator&lt;&lt;</code>。这要求基类 <code>operator&lt;&lt;</code> 也是友元或能够通过公有接口访问所需信息。</li>
<li> <strong>让派生类的友元也是基类的友元:</strong> 这种方式比较少见，且增加了耦合度。</li>
</ol>
<p>在示例中，我们使用了类型转换 <code>(const baseDMA &amp;) hs</code> 来调用基类的 <code>operator&lt;&lt;</code>，这是一种常见的做法。</p>
<p><strong>总结:</strong></p>
<ul>
<li>  当派生类不使用 <code>new</code> 时，通常依赖基类正确实现的虚析构函数、复制构造函数和赋值运算符即可。</li>
<li>  当派生类也使用 <code>new</code> 时，派生类必须提供自己的析构函数、复制构造函数和赋值运算符。</li>
<li>  派生类的析构函数负责清理派生类资源，基类析构函数自动调用。</li>
<li>  派生类的复制构造函数必须在初始化列表中调用基类复制构造函数。</li>
<li>  派生类的赋值运算符必须显式调用基类赋值运算符。</li>
<li>  <strong>基类析构函数应始终为虚函数</strong>，以确保通过基类指针 <code>delete</code> 派生类对象时行为正确。</li>
</ul>
<h2 id="13-8-类设计回顾"><a href="#13-8-类设计回顾" class="headerlink" title="13.8 类设计回顾"></a>13.8 类设计回顾</h2><p>经过前面几章的学习，我们已经接触了 C++ 类设计的许多方面，从基础的封装到复杂的继承和动态内存管理。本节将回顾一些关键的设计决策和最佳实践。</p>
<h3 id="13-8-1-编译器生成的成员函数"><a href="#13-8-1-编译器生成的成员函数" class="headerlink" title="13.8.1 编译器生成的成员函数"></a>13.8.1 编译器生成的成员函数</h3><p>C++ 编译器可以为我们自动生成一些特殊的成员函数，但这并不总是足够的，尤其是在处理资源（如动态内存）或设计继承层次结构时。</p>
<ol>
<li><p><strong>默认构造函数 (Default Constructor):</strong></p>
<ul>
<li>  <strong>生成时机:</strong> 如果你<strong>没有</strong>声明任何构造函数。</li>
<li>  <strong>行为:</strong> 对成员执行默认初始化（内置类型不初始化，类类型调用其默认构造函数）。</li>
<li>  <strong>注意:</strong> 如果你定义了任何构造函数，编译器就不会生成默认构造函数。如果此时你还需要一个无参构造函数，必须自己定义。</li>
</ul>
</li>
<li><p><strong>析构函数 (Destructor):</strong></p>
<ul>
<li>  <strong>生成时机:</strong> 如果你没有声明析构函数。</li>
<li>  <strong>行为:</strong> 对类类型的成员调用它们的析构函数。</li>
<li>  <strong>注意:</strong> 如果类管理需要显式释放的资源（如 <code>new</code> 分配的内存），<strong>必须</strong>提供自定义析构函数。如果类打算作为基类，析构函数<strong>应该</strong>是 <code>virtual</code> 的。</li>
</ul>
</li>
<li><p><strong>复制构造函数 (Copy Constructor):</strong></p>
<ul>
<li>  <strong>生成时机:</strong> 如果你没有声明复制构造函数（且没有声明移动操作）。</li>
<li>  <strong>行为:</strong> 执行**成员逐一复制 (浅复制)**。对于类类型成员，调用其复制构造函数。</li>
<li>  <strong>注意:</strong> 如果类管理动态内存或包含不能简单复制的资源（如文件句柄），<strong>必须</strong>提供自定义复制构造函数以实现<strong>深复制</strong>。</li>
</ul>
</li>
<li><p><strong>复制赋值运算符 (Copy Assignment Operator):</strong></p>
<ul>
<li>  <strong>生成时机:</strong> 如果你没有声明复制赋值运算符（且没有声明移动操作）。</li>
<li>  <strong>行为:</strong> 执行**成员逐一赋值 (浅复制)**。对于类类型成员，调用其复制赋值运算符。</li>
<li>  <strong>注意:</strong> 如果类管理动态内存或需要特殊赋值逻辑，<strong>必须</strong>提供自定义复制赋值运算符，确保深复制、处理自我赋值并释放旧资源。</li>
</ul>
</li>
<li><p><strong>移动构造函数 (Move Constructor) (C++11):</strong></p>
<ul>
<li>  <strong>生成时机:</strong> 如果你<strong>没有</strong>声明任何复制操作（复制构造、复制赋值）、移动操作（移动构造、移动赋值）或析构函数。</li>
<li>  <strong>行为:</strong> 执行<strong>成员逐一移动</strong>。对于类类型成员，调用其移动构造函数。目的是高效地转移资源所有权，而不是复制。</li>
<li>  <strong>注意:</strong> 如果需要自定义资源转移逻辑，或者默认的成员移动不合适，可以自定义。如果定义了任何复制操作或析构函数，默认的移动构造函数通常不会生成，需要时需显式 <code>= default</code> 或自定义。</li>
</ul>
</li>
<li><p><strong>移动赋值运算符 (Move Assignment Operator) (C++11):</strong></p>
<ul>
<li>  <strong>生成时机:</strong> 与移动构造函数类似。</li>
<li>  <strong>行为:</strong> 执行<strong>成员逐一移动赋值</strong>。</li>
<li>  <strong>注意:</strong> 与移动构造函数类似，如果需要自定义或默认版本未生成，需显式处理。</li>
</ul>
</li>
</ol>
<p><strong>三/五/零法则 (Rule of Three/Five/Zero):</strong></p>
<ul>
<li>  <strong>三法则 (C++11 前):</strong> 如果你需要自定义析构函数、复制构造函数或复制赋值运算符中的<strong>任何一个</strong>，你几乎肯定需要<strong>全部三个</strong>。</li>
<li>  <strong>五法则 (C++11):</strong> 如果你需要自定义上述三个或移动构造函数/移动赋值运算符中的<strong>任何一个</strong>，你可能需要考虑<strong>全部五个</strong>。</li>
<li>  <strong>零法则 (推荐):</strong> 优先使用 RAII（资源获取即初始化）原则，利用标准库容器（<code>std::string</code>, <code>std::vector</code>）和智能指针（<code>std::unique_ptr</code>, <code>std::shared_ptr</code>）来管理资源。如果类只包含这些能自我管理的成员，通常<strong>不需要</strong>自定义任何特殊成员函数，编译器生成的默认版本就能很好地工作。</li>
</ul>
<h3 id="13-8-2-其他的类方法"><a href="#13-8-2-其他的类方法" class="headerlink" title="13.8.2 其他的类方法"></a>13.8.2 其他的类方法</h3><p>除了特殊成员函数，类还包含其他用于实现其功能的方法：</p>
<ol>
<li> <strong>构造函数 (Constructors):</strong> 除了默认构造函数，还可以定义多个构造函数来提供不同的对象初始化方式（例如，接受不同参数）。使用成员初始化列表来初始化成员变量。考虑使用 <code>explicit</code> 关键字阻止不期望的单参数隐式转换。</li>
<li> <strong>访问器 (Accessors):</strong> 通常是 <code>public const</code> 成员函数，用于获取对象的状态（私有数据成员的值），但不修改对象。例如 <code>Balance() const</code>。</li>
<li> <strong>修改器 (Mutators) / 设置器 (Setters):</strong> 用于修改对象状态（私有数据成员的值）的 <code>public</code> 成员函数。例如 <code>ResetTable(bool v)</code>。</li>
<li> <strong>功能函数 (Utility Functions):</strong> 实现类核心逻辑的其他成员函数。可以是 <code>public</code>, <code>protected</code>, 或 <code>private</code>。</li>
<li> <strong><code>const</code> 成员函数:</strong> 在函数声明和定义后加 <code>const</code>，表示该函数不会修改调用它的对象的状态（数据成员）。<code>const</code> 对象只能调用 <code>const</code> 成员函数。</li>
<li> <strong>静态成员函数 (<code>static</code>):</strong> 与类本身关联，而不是特定对象。没有 <code>this</code> 指针，只能访问静态成员。通过类名调用 (<code>ClassName::staticFunc()</code>)。</li>
<li> <strong>虚函数 (<code>virtual</code>):</strong> 用于在继承层次结构中实现多态。允许通过基类指针/引用调用派生类的特定实现。</li>
</ol>
<h3 id="13-8-3-公有继承的考虑因素"><a href="#13-8-3-公有继承的考虑因素" class="headerlink" title="13.8.3 公有继承的考虑因素"></a>13.8.3 公有继承的考虑因素</h3><p>公有继承是实现 “is-a” 关系和多态的关键，但需要仔细考虑：</p>
<ol>
<li> <strong>“is-a” 关系:</strong> 确保派生类确实是基类的一种特殊类型，并且符合基类的行为契约（Liskov 替换原则）。</li>
<li> <strong>虚析构函数:</strong> 如果类可能被用作基类（特别是如果可能通过基类指针 <code>delete</code> 派生类对象），<strong>必须</strong>将析构函数声明为 <code>virtual</code>。</li>
<li><strong>继承接口 vs. 实现:</strong><ul>
<li>  <strong>纯虚函数:</strong> 只继承接口，强制派生类提供实现（用于抽象基类）。</li>
<li>  <strong>虚函数 (有实现):</strong> 继承接口和默认实现，允许派生类覆盖默认实现。</li>
<li>  <strong>非虚函数:</strong> 继承接口和强制实现，派生类不应重新定义（覆盖非虚函数通常是坏打算）。</li>
</ul>
</li>
<li><strong>访问控制:</strong><ul>
<li>  <code>public</code> 成员构成类的公有接口。</li>
<li>  <code>private</code> 成员是实现细节，对派生类隐藏。</li>
<li>  <code>protected</code> 成员对派生类可见，但对外部隐藏。谨慎使用 <code>protected</code> 数据，它会增加基类和派生类之间的耦合。优先使用 <code>protected</code> 函数。</li>
</ul>
</li>
<li> <strong>构造函数和初始化:</strong> 派生类构造函数必须调用基类构造函数（通常在成员初始化列表中）来初始化基类部分。</li>
<li> <strong>赋值运算符:</strong> 派生类的赋值运算符需要显式调用基类的赋值运算符来处理基类部分。</li>
<li> <strong>对象切片 (Slicing):</strong> 如果将派生类对象直接按值赋给基类对象（<code>Base b = derived;</code>），派生类特有的部分会被“切掉”，只保留基类部分。这是需要避免的，通常应使用指针或引用来处理多态对象。</li>
</ol>
<h3 id="13-8-4-类函数小结"><a href="#13-8-4-类函数小结" class="headerlink" title="13.8.4 类函数小结"></a>13.8.4 类函数小结</h3><table>
<thead>
<tr>
<th align="left">函数类别</th>
<th align="left">目的与说明</th>
<th align="left">关键特性/关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>构造函数</strong></td>
<td align="left">初始化新创建的对象</td>
<td align="left">类名相同, 无返回类型, 可重载, <code>explicit</code></td>
</tr>
<tr>
<td align="left"><strong>析构函数</strong></td>
<td align="left">对象销毁前执行清理工作（释放资源）</td>
<td align="left"><code>~ClassName()</code>, 无参数, 无返回类型, <code>virtual</code></td>
</tr>
<tr>
<td align="left"><strong>复制构造函数</strong></td>
<td align="left">用同类对象初始化新对象</td>
<td align="left"><code>ClassName(const ClassName &amp;)</code>, 深复制</td>
</tr>
<tr>
<td align="left"><strong>复制赋值运算符</strong></td>
<td align="left">将一个已存在的同类对象赋给另一个</td>
<td align="left"><code>operator=(const ClassName &amp;)</code>, 深复制, 返回 <code>*this</code></td>
</tr>
<tr>
<td align="left"><strong>移动构造函数</strong></td>
<td align="left">用同类右值对象初始化新对象（转移资源）</td>
<td align="left"><code>ClassName(ClassName &amp;&amp;)</code>, C++11, 移动语义</td>
</tr>
<tr>
<td align="left"><strong>移动赋值运算符</strong></td>
<td align="left">将一个同类右值对象赋给另一个（转移资源）</td>
<td align="left"><code>operator=(ClassName &amp;&amp;)</code>, C++11, 移动语义</td>
</tr>
<tr>
<td align="left"><strong>普通成员函数</strong></td>
<td align="left">实现类的行为和功能</td>
<td align="left">隐式 <code>this</code> 指针</td>
</tr>
<tr>
<td align="left"><strong><code>const</code> 成员函数</strong></td>
<td align="left">访问对象状态，但不修改对象</td>
<td align="left">函数声明/定义后加 <code>const</code></td>
</tr>
<tr>
<td align="left"><strong><code>static</code> 成员函数</strong></td>
<td align="left">与类本身关联，而非特定对象</td>
<td align="left"><code>static</code>, 无 <code>this</code> 指针</td>
</tr>
<tr>
<td align="left"><strong><code>virtual</code> 函数</strong></td>
<td align="left">允许在派生类中覆盖，实现多态</td>
<td align="left"><code>virtual</code>, 动态联编</td>
</tr>
<tr>
<td align="left"><strong>纯虚函数</strong></td>
<td align="left">定义接口，强制派生类实现（用于 ABC）</td>
<td align="left"><code>virtual ... = 0;</code></td>
</tr>
<tr>
<td align="left"><strong>运算符重载函数</strong></td>
<td align="left">定义标准运算符用于类对象的行为</td>
<td align="left"><code>operator+</code>, <code>operator&lt;&lt;</code>, etc.</td>
</tr>
<tr>
<td align="left"><strong>转换函数</strong></td>
<td align="left">定义从类类型到其他类型的转换</td>
<td align="left"><code>operator typeName()</code>, <code>explicit</code></td>
</tr>
<tr>
<td align="left"><strong>友元函数/类</strong></td>
<td align="left">允许非成员函数或类访问私有/保护成员</td>
<td align="left"><code>friend</code></td>
</tr>
</tbody></table>
<p>设计良好的类需要仔细考虑这些不同类型的函数，确保封装性、资源管理的正确性、接口的清晰性以及在继承体系中的恰当行为。</p>
<h2 id="13-9-总结"><a href="#13-9-总结" class="headerlink" title="13.9 总结"></a>13.9 总结</h2><p>本章介绍了 C++ 的一个核心特性——<strong>继承</strong>，它允许我们基于现有类创建新类，实现代码重用和建立类之间的层次关系。</p>
<p>主要内容回顾：</p>
<ol>
<li><p><strong>基本继承:</strong></p>
<ul>
<li>  一个类（<strong>派生类</strong>）可以从另一个类（<strong>基类</strong>）继承成员（数据和方法）。</li>
<li>  <strong>公有继承 (<code>public</code>)</strong> 是最常用的方式，建立 <strong>“is-a”</strong> 关系，意味着派生类对象也是一个基类对象。基类的公有成员在派生类中仍然是公有，保护成员仍然是保护。</li>
<li>  派生类构造函数必须通过<strong>成员初始化列表</strong>调用基类构造函数来初始化继承的基类部分。</li>
</ul>
</li>
<li><p><strong>多态公有继承:</strong></p>
<ul>
<li>  <strong>多态</strong>允许我们通过基类接口（指针或引用）统一处理不同类型的派生类对象。</li>
<li>  通过在基类中将成员函数声明为<strong>虚函数 (<code>virtual</code>)</strong> 来启用多态行为。</li>
<li>  当通过基类指针或引用调用虚函数时，程序在<strong>运行时</strong>根据对象的实际类型选择调用哪个版本的方法（<strong>动态联编</strong>或晚绑定）。</li>
<li>  如果函数不是虚函数，或者通过对象直接调用，则在<strong>编译时</strong>根据指针/引用的声明类型或对象类型决定调用版本（<strong>静态联编</strong>或早绑定）。</li>
</ul>
</li>
<li><p><strong>虚函数注意事项:</strong></p>
<ul>
<li>  <code>override</code> (C++11): 推荐在派生类覆盖虚函数时使用，以进行编译器检查。</li>
<li>  <code>final</code> (C++11): 可用于阻止虚函数在更深层派生类中被覆盖，或阻止类被继承。</li>
<li>  构造函数不能是虚函数。</li>
<li>  <strong>虚析构函数:</strong> 如果类可能被用作基类（特别是涉及动态内存分配或可能通过基类指针删除派生类对象），其析构函数<strong>必须</strong>声明为 <code>virtual</code>，以确保正确的析构顺序和资源释放。</li>
</ul>
</li>
<li><p><strong>访问控制 (<code>protected</code>):</strong></p>
<ul>
<li>  <code>protected</code> 成员对类内部和派生类成员函数可见，但对外部代码不可见。</li>
<li>  它提供了介于 <code>private</code> 和 <code>public</code> 之间的访问级别。</li>
<li>  虽然 <code>protected</code> 允许派生类直接访问基类实现细节，但可能破坏封装，应谨慎使用。优先使用 <code>private</code> 数据和 <code>public/protected</code> 接口函数。</li>
</ul>
</li>
<li><p><strong>抽象基类 (ABC):</strong></p>
<ul>
<li>  包含至少一个<strong>纯虚函数 (<code>virtual ... = 0;</code>)</strong> 的类是抽象基类。</li>
<li>  ABC <strong>不能被实例化</strong>（不能创建对象）。</li>
<li>  主要用于定义一个<strong>接口规范</strong>，强制派生类实现纯虚函数。</li>
<li>  可以声明指向 ABC 的指针或引用，用于实现多态。</li>
<li>  派生类只有实现了所有继承的纯虚函数后，才能成为具体类。</li>
</ul>
</li>
<li><p><strong>继承与动态内存分配:</strong></p>
<ul>
<li>  <strong>基类使用 <code>new</code>，派生类不用:</strong> 派生类通常不需要自定义特殊成员函数，但基类必须有虚析构函数。</li>
<li>  <strong>基类和派生类都使用 <code>new</code>:</strong> 派生类<strong>必须</strong>提供自己的析构函数、复制构造函数和赋值运算符。派生类的复制构造函数和赋值运算符必须显式调用基类的对应版本来处理基类部分。基类析构函数仍需是虚函数。</li>
</ul>
</li>
<li><p><strong>类设计回顾:</strong></p>
<ul>
<li>  理解编译器生成的特殊成员函数（构造、析构、复制、移动）及其局限性。</li>
<li>  遵循三/五/零法则来管理资源，优先使用 RAII（如智能指针、标准容器）。</li>
<li>  合理使用 <code>const</code> 成员函数。</li>
<li>  谨慎设计继承关系，确保符合 “is-a” 原则。</li>
<li>  正确使用虚函数和虚析构函数实现多态和安全的资源管理。</li>
</ul>
</li>
</ol>
<p>继承是 C++ 中实现代码重用、建立类型层次结构和实现多态的关键机制。理解其工作原理、不同类型的继承（本章主要关注公有继承）以及相关的设计原则对于编写强大的、可维护的面向对象程序至关重要。</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_13/>http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_13/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-30T23:40:12+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年4月30日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Program/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Program</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/C/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>C++</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_13/&title=Chapter 13 类继承 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_13/&title=Chapter 13 类继承 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_13/&title=Chapter 13 类继承 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2025/04/30/Cpp_tutorial_Chapter_14/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Chapter 14 C++中的代码重用</p>
          <p class='content'>14.1 包含对象成员的类除了继承 (“is-a” 关系) 之外，C++ 提供了另一种重要的代码重用机制：包含 (Containment) 或 组合 (Composition)**。这种方式模拟...</p>
        </a>
      
      
        <a class='next' href='/2025/04/30/Cpp_tutorial_Chapter_12/'>
          <p class='title'>Chapter 12 类和动态内存分配<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>12.1 动态内存和类当类需要使用 new 在自由存储区（堆）上分配内存时，情况会变得比之前我们看到的类（如 Stock, Time, Vector）更复杂。这些类的数据成员本身（如 int, ...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="toc-text">13.1 一个简单的基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1-%E6%B4%BE%E7%94%9F%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-text">13.1.1 派生一个类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-text">13.1.2 构造函数：访问权限的考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-3-%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">13.1.3 使用派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-4-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E7%89%B9%E6%AE%8A%E5%85%B3%E7%B3%BB"><span class="toc-text">13.1.4 派生类和基类之间的特殊关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E7%BB%A7%E6%89%BF%EF%BC%9Ais-a-%E5%85%B3%E7%B3%BB"><span class="toc-text">13.2 继承：is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">13.3 多态公有继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-text">13.4 静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">13.4.1 指针和引用类型的兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-2-%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-text">13.4.2 虚成员函数和动态联编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-3-%E6%9C%89%E5%85%B3%E8%99%9A%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">13.4.3 有关虚函数注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9Aprotected"><span class="toc-text">13.5 访问控制：protected</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-text">13.6 抽象基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-1-%E5%BA%94%E7%94%A8-ABC-%E6%A6%82%E5%BF%B5"><span class="toc-text">13.6.1 应用 ABC 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-2-ABC-%E7%90%86%E5%BF%B5"><span class="toc-text">13.6.2 ABC 理念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">13.7 继承和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-1-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8D%E4%BD%BF%E7%94%A8-new"><span class="toc-text">13.7.1 第一种情况：派生类不使用 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BD%BF%E7%94%A8-new"><span class="toc-text">13.7.2 第二种情况：派生类使用 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-3-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%8B%E5%85%83%E7%9A%84%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B"><span class="toc-text">13.7.3 使用动态内存分配和友元的继承示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-8-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%9B%9E%E9%A1%BE"><span class="toc-text">13.8 类设计回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-1-%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">13.8.1 编译器生成的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-2-%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">13.8.2 其他的类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-3-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-text">13.8.3 公有继承的考虑因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-4-%E7%B1%BB%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93"><span class="toc-text">13.8.4 类函数小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-9-%E6%80%BB%E7%BB%93"><span class="toc-text">13.9 总结</span></a></li></ol>
    </div>
  </section>


  


</aside>



        
        
          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="Chapter 13 类继承";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        
      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5043500508'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a id="s-top" class="fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <script>
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/********************脚本懒加载函数********************************/
function loadScript(src, cb) {
var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
var script = document.createElement('script');
script.setAttribute('type','text/javascript');
if (cb) script.onload = cb;
script.setAttribute('src', src);
HEAD.appendChild(script);
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  








  <script>
  let APlayerController = new Object();
  APlayerController.id = '5043500508';  // 设定全局音乐播放ID
  APlayerController.volume = '0.7';
  loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css", window.volantis.loadcss);

  loadScript("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js")

  loadScript("https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js")


</script>




  
  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/valine.min.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";

    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      recordIP: 'false',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>





  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/app.min.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/search/hexo.min.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://uniqueland.top' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
       

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      
	 

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
      } catch (e) {
        console.log(e);
      }
	  
    });

    document.addEventListener('pjax:error', function (e) {
	  
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
