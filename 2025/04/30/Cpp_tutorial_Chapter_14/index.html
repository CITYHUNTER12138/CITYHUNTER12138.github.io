<!DOCTYPE html>
<html lang="zh-CN">
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>Chapter 14 C++中的代码重用 - Uniqueland</title>
  
    <meta name="keywords" content="Program,C++">
  

  
    <meta name="description" content="C++ tutorial">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://www.helloimg.com/images/2022/03/27/ReozOM.png">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

</head>

<body>
  

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div id="l_body">
    <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Uniqueland</p>
    
    
      <p class="subtitle">--XR's personal Blog</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/categories/"
              
              
              id="categories">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>分类</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

    <div id='safearea'>
      <div class='body-wrapper' id="pjax-container">
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
    <div class='headimg-div'>
      <a class='headimg-a'>
        <img class='headimg' src='https://s2.loli.net/2025/04/26/9F74KMasiN1YwQW.png'/>
      </a>
    </div>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Chapter 14 C++中的代码重用
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="https://raw.githubusercontent.com/srcx404/pic/refs/heads/main/xr.jpg">
    <p>XR</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2025年4月30日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Chapter 14 C++中的代码重用" data-path="/2025/04/30/Cpp_tutorial_Chapter_14/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <h2 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h2><p>除了继承 (“is-a” 关系) 之外，C++ 提供了另一种重要的代码重用机制：<strong>包含 (Containment)</strong> 或 <strong>组合 (Composition)**。这种方式模拟的是 **”has-a”</strong> （有一个）关系。</p>
<p>当一个类（称为<strong>包含类</strong>或<strong>容器类</strong>）将另一个类的对象作为其<strong>成员变量</strong>时，就使用了包含或组合。例如：</p>
<ul>
<li>  一辆 <code>Car</code> <strong>有一个</strong> <code>Engine</code>。</li>
<li>  一个 <code>Person</code> <strong>有一个</strong> <code>Name</code> (可能是 <code>string</code> 对象)。</li>
<li>  一个 <code>Order</code> <strong>有</strong>一组 <code>OrderItem</code> 对象。</li>
</ul>
<p>这种方式允许我们通过组合已有的、功能完善的类来构建更复杂的新类。</p>
<p>本节我们将设计一个 <code>Student</code> 类，它将包含一个 <code>std::string</code> 对象（表示学生姓名）和一个 <code>std::valarray&lt;double&gt;</code> 对象（表示学生的考试分数）。</p>
<h3 id="14-1-1-valarray-类简介"><a href="#14-1-1-valarray-类简介" class="headerlink" title="14.1.1 valarray 类简介"></a>14.1.1 valarray 类简介</h3><p><code>valarray</code> 是 C++ 标准库中的一个模板类（定义在 <code>&lt;valarray&gt;</code> 头文件中），专门设计用于简化和优化<strong>数值数组</strong>的操作。它提供了许多方便的功能，例如：</p>
<ul>
<li>  <strong>逐元素运算:</strong> 可以直接对整个 <code>valarray</code> 对象执行算术运算（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>），运算会自动应用于每个对应的元素。</li>
<li>  <strong>数学函数:</strong> 可以将许多标准数学函数（如 <code>sqrt()</code>, <code>abs()</code>, <code>sin()</code>）应用于 <code>valarray</code> 的所有元素。</li>
<li>  <strong>切片和索引:</strong> 提供灵活的方式来访问和操作数组的子集。</li>
<li>  <strong>聚合操作:</strong> 内置了计算总和 (<code>sum()</code>)、平均值 (<code>sum()/size()</code>)、最大值 (<code>max()</code>)、最小值 (<code>min()</code>) 等方法。</li>
</ul>
<p><strong>简单示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt; // 包含 valarray 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;   // 用于初始化示例</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; <span class="title">v1</span><span class="params">(data.data(), data.size())</span></span>; <span class="comment">// 从 double 数组创建 valarray</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v2 = &#123;<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>&#125;; <span class="comment">// 使用初始化列表 (C++11)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; <span class="title">v_sum</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 创建一个大小为 4 的 valarray</span></span><br><span class="line"></span><br><span class="line">    v_sum = v1 + v2; <span class="comment">// 逐元素相加: v_sum = &#123;11.1, 12.2, 13.3, 14.4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of elements in v1: &quot;</span> &lt;&lt; v1.sum() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of v1: &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;         <span class="comment">// 输出 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element at index 1 in v_sum: &quot;</span> &lt;&lt; v_sum[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 12.2</span></span><br><span class="line"></span><br><span class="line">    v1 *= <span class="number">2.0</span>; <span class="comment">// 所有元素乘以 2: v1 = &#123;2.2, 4.4, 6.6, 8.8&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> x : v1) &#123; <span class="comment">// C++11 范围 for 循环</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将使用 <code>valarray&lt;double&gt;</code> 来存储 <code>Student</code> 的多门课成绩。</p>
<h3 id="14-1-2-Student-类的设计"><a href="#14-1-2-Student-类的设计" class="headerlink" title="14.1.2 Student 类的设计"></a>14.1.2 Student 类的设计</h3><p>我们的 <code>Student</code> 类需要存储姓名和一组分数。</p>
<ul>
<li>  <strong>姓名:</strong> 使用 <code>std::string</code> 类。</li>
<li>  <strong>分数:</strong> 使用 <code>std::valarray&lt;double&gt;</code> 类。</li>
</ul>
<p><strong>接口设计:</strong></p>
<p>我们需要提供方法来：</p>
<ul>
<li>  构造 <code>Student</code> 对象（提供姓名和分数）。</li>
<li>  获取学生的平均分。</li>
<li>  获取学生的姓名。</li>
<li>  获取某一门课的分数。</li>
<li>  输出学生的信息。</li>
</ul>
<p><strong>studentc.h (Student 类接口)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STUDENTC_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENTC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt; // 包含 valarray</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 使用包含（组合）: Student &quot;has-a&quot; string and &quot;has-a&quot; valarray</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;               <span class="comment">// 姓名</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; scores;   <span class="comment">// 分数 (使用 valarray)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，用于输出分数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream &amp; <span class="title">arr_out</span><span class="params">(<span class="built_in">std</span>::ostream &amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Student() : name(<span class="string">&quot;Null Student&quot;</span>), scores() &#123;&#125; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="comment">// 使用 string 和 valarray 初始化</span></span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">const</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &amp; a)</span><br><span class="line">        : name(s), scores(a) &#123;&#125;</span><br><span class="line">    <span class="comment">// 使用 string 和 C 风格数组初始化</span></span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">const</span> <span class="keyword">double</span> * pd, <span class="keyword">int</span> n)</span><br><span class="line">        : name(s), scores(pd, n) &#123;&#125; <span class="comment">// valarray 构造函数接受 (指针, 数量)</span></span><br><span class="line">    <span class="comment">// 使用 C 风格字符串和 C 风格数组初始化</span></span><br><span class="line">    Student(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">const</span> <span class="keyword">double</span> * pd, <span class="keyword">int</span> n)</span><br><span class="line">        : name(str), scores(pd, n) &#123;&#125; <span class="comment">// string 和 valarray 构造函数处理转换</span></span><br><span class="line"></span><br><span class="line">    ~Student() &#123;&#125; <span class="comment">// 析构函数 (默认即可，因为 string 和 valarray 会自己管理资源)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问器</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Average</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 计算平均分</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 获取姓名 (返回 const 引用避免复制)</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>; <span class="comment">// 获取第 i 门课分数 (const 版本)</span></span><br><span class="line">    <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);     <span class="comment">// 获取/设置第 i 门课分数 (非 const 版本)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数 - 用于输入输出</span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu); <span class="comment">// 读取姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="title">getline</span><span class="params">(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu)</span></span>;   <span class="comment">// 读取姓名 (整行)</span></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Student &amp; stu);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STUDENTC_H_</span></span></span><br></pre></td></tr></table></figure>

<p><strong>关键点:</strong></p>
<ul>
<li><strong>成员初始化列表:</strong> <code>Student</code> 的构造函数使用<strong>成员初始化列表</strong>来初始化 <code>name</code> 和 <code>scores</code> 成员。<ul>
<li>  <code>name(s)</code>: 调用 <code>std::string</code> 的构造函数（或复制构造函数）来初始化 <code>name</code>。</li>
<li>  <code>scores(a)</code> 或 <code>scores(pd, n)</code>: 调用 <code>std::valarray&lt;double&gt;</code> 的相应构造函数来初始化 <code>scores</code>。</li>
</ul>
</li>
<li>  <strong>自动资源管理:</strong> 因为 <code>std::string</code> 和 <code>std::valarray</code> 都是设计良好的类，它们会自动管理自己的内存（<code>string</code> 管理字符数据，<code>valarray</code> 管理 <code>double</code> 数据）。因此，<code>Student</code> 类<strong>不需要</strong>显式地编写析构函数、复制构造函数或赋值运算符来处理 <code>name</code> 和 <code>scores</code> 的内存管理（遵循<strong>零法则</strong>）。编译器生成的默认版本会正确地调用 <code>string</code> 和 <code>valarray</code> 的相应特殊成员函数。</li>
<li>  <strong>接口转发:</strong> <code>Student</code> 类的一些方法（如 <code>operator[]</code>）将操作转发给其成员对象（<code>scores[i]</code>）。</li>
</ul>
<h3 id="14-1-3-Student-类示例"><a href="#14-1-3-Student-类示例" class="headerlink" title="14.1.3 Student 类示例"></a>14.1.3 Student 类示例</h3><p><strong>studentc.cpp (Student 类实现)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studentc.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公有方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scores.size() &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> scores.sum() / scores.size(); <span class="comment">// 使用 valarray 的 sum() 和 size()</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">Student::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 [] 访问分数</span></span><br><span class="line"><span class="keyword">double</span> Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> scores[i]; <span class="comment">// 调用 valarray 的 operator[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> scores[i]; <span class="comment">// 调用 valarray 的 operator[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法实现</span></span><br><span class="line"><span class="comment">// 输出分数数组</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">Student::arr_out</span><span class="params">(ostream &amp; os)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> lim = scores.size();</span><br><span class="line">    <span class="keyword">if</span> (lim &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">            os &lt;&lt; scores[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">4</span>) <span class="comment">// 每 5 个换行</span></span><br><span class="line">                os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>)</span><br><span class="line">            os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; empty array &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数实现</span></span><br><span class="line"><span class="comment">// 使用 &gt;&gt; 读取姓名</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, Student &amp; stu) &#123;</span><br><span class="line">    is &gt;&gt; stu.name; <span class="comment">// 调用 string 的 operator&gt;&gt;</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 getline 读取姓名 (整行)</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(istream &amp; is, Student &amp; stu)</span> </span>&#123;</span><br><span class="line">    getline(is, stu.name); <span class="comment">// 调用 string 的 getline</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &lt;&lt; 输出学生信息</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Student &amp; stu) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Scores for &quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    stu.arr_out(os); <span class="comment">// 使用私有方法输出分数</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>use_stuc.cpp (使用 Student 类)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studentc.h&quot;</span> <span class="comment">// 包含 Student 类定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pupils = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> quizzes = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student ada[pupils] = &#123; <span class="comment">// 创建 Student 对象数组</span></span><br><span class="line">        Student(quizzes), Student(quizzes), Student(quizzes) <span class="comment">// 假设有 Student(int n) 构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 studentc.h/cpp 已修改，添加构造函数 Student(int n)</span></span><br><span class="line">    <span class="comment">// Student::Student(int n) : name(&quot;Nully&quot;), scores(n) &#123;&#125; // 示例构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有 Student(int n)，则需要这样创建：</span></span><br><span class="line">    <span class="comment">// double sample_scores[quizzes] = &#123;0.0&#125;; // 示例分数</span></span><br><span class="line">    <span class="comment">// Student ada[pupils] = &#123;</span></span><br><span class="line">    <span class="comment">//     Student(&quot;Default1&quot;, sample_scores, quizzes),</span></span><br><span class="line">    <span class="comment">//     Student(&quot;Default2&quot;, sample_scores, quizzes),</span></span><br><span class="line">    <span class="comment">//     Student(&quot;Default3&quot;, sample_scores, quizzes)</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    <span class="comment">// 为了编译通过，我们假设 Student(int n) 存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">set</span>(ada[i], quizzes); <span class="comment">// 设置学生数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nStudent List:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ada[i].Name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nResults:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ada[i]; <span class="comment">// 输出完整信息 (调用 operator&lt;&lt;)</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;average: &quot;</span> &lt;&lt; ada[i].Average() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出平均分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：设置学生姓名和分数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter the student&#x27;s name: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>, sa); <span class="comment">// 使用友元 getline 读取姓名</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; quiz scores:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sa[i]; <span class="comment">// 使用 operator[] 设置分数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 需要修改 studentc.h/cpp 添加 Student(int n) 构造函数 ---</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// studentc.h 添加:</span></span><br><span class="line"><span class="comment">    explicit Student(int n) : name(&quot;Nully&quot;), scores(n) &#123;&#125; // explicit 防止意外转换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// studentc.cpp 不需要额外添加，因为初始化列表已完成工作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>编译和运行:</strong></p>
<p>你需要将 <code>studentc.cpp</code> 和 <code>use_stuc.cpp</code> 一起编译链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 假设 studentc.h/cpp 已添加 Student(int n) 构造函数</span></span><br><span class="line">g++ use_stuc.cpp studentc.cpp -o use_stuc</span><br><span class="line">./use_stuc</span><br></pre></td></tr></table></figure>

<p>程序会提示输入每个学生的名字和分数，然后显示学生列表和每个学生的详细信息及平均分。</p>
<p><strong>总结:</strong></p>
<ul>
<li>  <strong>包含 (组合)</strong> 是通过将一个类的对象作为另一个类的成员来实现的，模拟 <strong>“has-a”</strong> 关系。</li>
<li>  这是代码重用的重要方式，允许利用现有类的功能。</li>
<li>  包含类的构造函数通常使用<strong>成员初始化列表</strong>来调用成员对象的构造函数。</li>
<li>  如果成员对象能正确管理自己的资源（如 <code>std::string</code>, <code>std::valarray</code>, 智能指针），包含类通常不需要自定义析构函数、复制/移动操作（<strong>零法则</strong>）。</li>
<li>  包含类可以通过其成员对象的公有接口来使用它们的功能。</li>
</ul>
<h2 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h2><p>除了公有继承 (<code>public</code>) 模拟 “is-a” 关系外，C++ 还提供了<strong>私有继承 (<code>private</code>)**。私有继承模拟的是 **”has-a”</strong> 或更准确地说是 <strong>“is-implemented-in-terms-of”</strong> （根据…来实现）的关系。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> <span class="keyword">private</span> BaseClassName &#123;</span><br><span class="line">    <span class="comment">// ... 派生类成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>默认的继承方式（如果省略访问说明符）也是 <code>private</code> (对于 <code>class</code>)。</em></p>
<p><strong>访问规则:</strong></p>
<p>当一个类私有继承自基类时：</p>
<ul>
<li>  基类的 <code>public</code> 成员在派生类中变为 **<code>private</code>**。</li>
<li>  基类的 <code>protected</code> 成员在派生类中变为 **<code>private</code>**。</li>
<li>  基类的 <code>private</code> 成员在派生类中仍然是<strong>不可直接访问</strong>的。</li>
</ul>
<p><strong>核心思想:</strong></p>
<p>私有继承意味着派生类<strong>继承了基类的实现</strong>，但<strong>不继承其接口</strong>。基类的公有方法不会成为派生类对象的公有接口的一部分。外部代码不能通过派生类对象直接调用基类的公有方法。派生类内部的成员函数（以及友元）仍然可以访问基类的 <code>public</code> 和 <code>protected</code> 成员（因为它们在派生类内部是 <code>private</code> 的）。</p>
<p><strong>与公有继承的区别:</strong></p>
<ul>
<li>  <strong>关系:</strong> 公有继承是 “is-a”，私有继承是 “is-implemented-in-terms-of”。</li>
<li>  <strong>接口:</strong> 公有继承继承接口和实现；私有继承只继承实现。</li>
<li>  <strong>指针/引用转换:</strong> 公有继承下，基类指针/引用可以指向派生类对象；私有继承下，这种隐式转换<strong>不允许</strong>（除非在派生类内部或其友元中）。</li>
</ul>
<h3 id="14-2-1-Student-类示例（新版本）"><a href="#14-2-1-Student-类示例（新版本）" class="headerlink" title="14.2.1 Student 类示例（新版本）"></a>14.2.1 Student 类示例（新版本）</h3><p>让我们重新实现 <code>Student</code> 类，这次使用私有继承而不是包含（组合）。<code>Student</code> 类将私有继承自 <code>std::string</code>（用于姓名）和 <code>std::valarray&lt;double&gt;</code>（用于分数）。</p>
<p><strong>studenti.h (私有继承版本)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STUDENTI_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENTI_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私有继承的 Student 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有辅助函数，用于输出分数</span></span><br><span class="line">    <span class="comment">// 注意：现在可以直接访问 valarray 的方法，但它们是私有的</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream &amp; <span class="title">arr_out</span><span class="params">(<span class="built_in">std</span>::ostream &amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="comment">// 需要显式调用基类的构造函数</span></span><br><span class="line">    Student() : <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Null Student&quot;</span>), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s)</span></span></span><br><span class="line">        : std::string(s), std::valarray&lt;double&gt;() &#123;&#125;</span><br><span class="line">    explicit Student(int n) : std::string(&quot;Nully&quot;), std::valarray&lt;double&gt;(n) &#123;&#125;</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">int</span> n)</span><br><span class="line">        : <span class="built_in">std</span>::<span class="built_in">string</span>(s), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;(n) &#123;&#125;</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">const</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &amp; a)</span><br><span class="line">        : <span class="built_in">std</span>::<span class="built_in">string</span>(s), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;(a) &#123;&#125;</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">const</span> <span class="keyword">double</span> * pd, <span class="keyword">int</span> n)</span><br><span class="line">        : <span class="built_in">std</span>::<span class="built_in">string</span>(str), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;(pd, n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~Student() &#123;&#125; <span class="comment">// 析构函数 (默认即可)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问器 - 需要自己提供接口，不能直接用基类的</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Average</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 提供访问姓名的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数 - 用于输入输出</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu);</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="title">getline</span><span class="params">(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Student &amp; stu);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STUDENTI_H_</span></span></span><br></pre></td></tr></table></figure>

<p><strong>studenti.cpp (实现)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studenti.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::valarray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公有方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以访问 valarray 的 public 方法 (在 Student 内部是 private)</span></span><br><span class="line">    <span class="keyword">if</span> (valarray&lt;<span class="keyword">double</span>&gt;::size() &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> valarray&lt;<span class="keyword">double</span>&gt;::sum() / valarray&lt;<span class="keyword">double</span>&gt;::size();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">Student::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以访问 string 的 public 方法 (在 Student 内部是 private)</span></span><br><span class="line">    <span class="comment">// 需要强制类型转换回基类类型来调用</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) *<span class="keyword">this</span>; <span class="comment">// 将 *this 转换为对基类 string 的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 [] 访问分数</span></span><br><span class="line"><span class="keyword">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// 可以访问 valarray 的 public 方法 (在 Student 内部是 private)</span></span><br><span class="line">    <span class="comment">// 需要强制类型转换回基类类型来调用</span></span><br><span class="line">    <span class="keyword">return</span> valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[](i); <span class="comment">// 或者 ((valarray&lt;double&gt; &amp;)*this)[i];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[](i); <span class="comment">// 或者 ((const valarray&lt;double&gt; &amp;)*this)[i];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法实现</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">Student::arr_out</span><span class="params">(ostream &amp; os)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> lim = valarray&lt;<span class="keyword">double</span>&gt;::size();</span><br><span class="line">    <span class="keyword">if</span> (lim &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">            os &lt;&lt; <span class="keyword">operator</span>[](i) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 使用 Student::operator[]</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">4</span>)</span><br><span class="line">                os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>)</span><br><span class="line">            os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; empty array &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数实现</span></span><br><span class="line"><span class="comment">// 友元可以访问派生类的私有成员，包括继承来的私有成员（原基类的公有/保护成员）</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, Student &amp; stu) &#123;</span><br><span class="line">    <span class="comment">// 直接访问继承来的 string 部分 (现在是 stu 的私有部分)</span></span><br><span class="line">    is &gt;&gt; (<span class="built_in">string</span> &amp;)stu; <span class="comment">// 需要类型转换</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(istream &amp; is, Student &amp; stu)</span> </span>&#123;</span><br><span class="line">    getline(is, (<span class="built_in">string</span> &amp;)stu); <span class="comment">// 需要类型转换</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Student &amp; stu) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Scores for &quot;</span> &lt;&lt; (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) stu &lt;&lt; <span class="string">&quot;:\n&quot;</span>; <span class="comment">// 需要类型转换</span></span><br><span class="line">    stu.arr_out(os); <span class="comment">// 调用私有辅助函数</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例 (use_stui.cpp)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studenti.h&quot;</span> <span class="comment">// 使用私有继承版本</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 函数原型 (同之前)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pupils = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> quizzes = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student ada[pupils] = &#123;Student(quizzes), Student(quizzes), Student(quizzes)&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">set</span>(ada[i], quizzes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nStudent List:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ada[i].Name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 Student 提供的 Name() 接口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nResults:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ada[i]; <span class="comment">// 调用 Student 的 operator&lt;&lt;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;average: &quot;</span> &lt;&lt; ada[i].Average() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 Student 的 Average()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法直接访问基类方法</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ada[0].size(); // 错误！valarray::size() 在 Student 中是 private</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ada[0].length(); // 错误！string::length() 在 Student 中是 private</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法将派生类指针隐式转换为基类指针</span></span><br><span class="line">    <span class="comment">// string * pstr = &amp;ada[0]; // 错误！</span></span><br><span class="line">    <span class="comment">// valarray&lt;double&gt; * pva = &amp;ada[0]; // 错误！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 函数定义 (同之前)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter the student&#x27;s name: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>, sa); <span class="comment">// 使用友元 getline</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; quiz scores:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sa[i]; <span class="comment">// 使用 Student::operator[]</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明:</strong></p>
<ul>
<li>  <code>Student</code> 类通过私有继承获得了 <code>string</code> 和 <code>valarray&lt;double&gt;</code> 的所有实现。</li>
<li>  构造函数通过初始化列表调用基类的构造函数。</li>
<li>  由于基类的公有方法在 <code>Student</code> 中变为私有，<code>Student</code> 类必须提供自己的公有接口（如 <code>Average()</code>, <code>Name()</code>, <code>operator[]</code>）来暴露所需的功能。</li>
<li>  在 <code>Student</code> 的成员函数或友元函数内部，需要通过<strong>显式类型转换</strong>（如 <code>(const string &amp;) *this</code> 或 <code>valarray&lt;double&gt;::sum()</code>）来调用继承来的基类方法（因为它们现在是 <code>Student</code> 的私有成员）。</li>
<li>  外部代码不能直接访问继承来的基类方法，也不能将 <code>Student</code> 对象隐式转换为 <code>string</code> 或 <code>valarray&lt;double&gt;</code>。</li>
</ul>
<h3 id="14-2-2-使用包含还是私有继承"><a href="#14-2-2-使用包含还是私有继承" class="headerlink" title="14.2.2 使用包含还是私有继承"></a>14.2.2 使用包含还是私有继承</h3><p>对于 “has-a” 或 “is-implemented-in-terms-of” 的关系，我们既可以使用<strong>包含 (组合)**，也可以使用</strong>私有继承**。那么如何选择呢？</p>
<p><strong>通常推荐使用包含 (组合):</strong></p>
<ul>
<li>  <strong>更清晰:</strong> 明确表示 “has-a” 关系，代码更易于理解。<code>Student</code> 类包含一个 <code>name</code> 成员和一个 <code>scores</code> 成员，这很直观。</li>
<li>  <strong>更简单:</strong> 不需要处理继承带来的复杂性（如访问控制变化、构造函数调用链、名称冲突等）。</li>
<li><strong>更灵活:</strong><ul>
<li>  可以轻松包含<strong>多个</strong>同类型的成员对象（例如，一个学生可以有家庭住址和学校住址两个 <code>string</code> 成员）。私有继承通常只能继承一个基类一次（虽然多重继承是可能的，但更复杂）。</li>
<li>  可以包含指向对象的指针或引用，实现更松散的耦合。</li>
</ul>
</li>
<li>  <strong>封装性更好:</strong> 包含类只能通过成员对象的公有接口与其交互，不会意外地依赖其实现细节（除非成员对象本身封装不佳）。</li>
</ul>
<p><strong>私有继承的可能优势 (相对少见):</strong></p>
<ul>
<li>  <strong>访问 <code>protected</code> 成员:</strong> 如果派生类需要访问基类的 <code>protected</code> 成员（数据或函数），私有继承提供了这种能力，而包含则不行（除非通过友元）。</li>
<li>  <strong>覆盖虚函数:</strong> 如果需要覆盖基类的虚函数（即使是私有继承，基类的虚函数在派生类中仍然是虚函数，只是访问权限变为 <code>private</code>），私有继承是必要的。这在使用策略模式或模板方法模式的某些变体时可能有用，但较为高级。</li>
<li>  <strong>空基类优化 (EBO - Empty Base Optimization):</strong> 在某些情况下，如果基类是空的（没有非静态数据成员），编译器可能优化掉基类子对象占用的空间，使得私有继承的对象比包含同样空类成员的对象更小。但这通常是微优化，不应作为主要选择依据。</li>
</ul>
<p><strong>结论:</strong> 对于大多数 “has-a” 关系，**优先选择包含 (组合)**。只有在需要访问基类的 <code>protected</code> 成员或覆盖其虚函数等特殊情况下，才考虑使用私有继承。</p>
<h3 id="14-2-3-保护继承"><a href="#14-2-3-保护继承" class="headerlink" title="14.2.3 保护继承"></a>14.2.3 保护继承</h3><p>除了 <code>public</code> 和 <code>private</code> 继承，还有**保护继承 (<code>protected</code>)**。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> <span class="keyword">protected</span> BaseClassName &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>访问规则:</strong></p>
<p>当一个类保护继承自基类时：</p>
<ul>
<li>  基类的 <code>public</code> 成员在派生类中变为 **<code>protected</code>**。</li>
<li>  基类的 <code>protected</code> 成员在派生类中变为 **<code>protected</code>**。</li>
<li>  基类的 <code>private</code> 成员在派生类中仍然是<strong>不可直接访问</strong>的。</li>
</ul>
<p><strong>特点:</strong></p>
<ul>
<li>  与私有继承类似，它也是一种实现继承，不继承接口。外部代码不能访问继承来的成员。</li>
<li>  与私有继承不同的是，基类的公有和保护成员在派生类中是 <code>protected</code> 的，这意味着<strong>后续从该派生类继承的类</strong>仍然可以访问这些成员。而在私有继承下，这些成员在派生类中变为 <code>private</code>，后续的派生类就无法访问了。</li>
</ul>
<p><strong>用途:</strong> 保护继承非常少见。它主要用于一种特殊情况：你想让基类的实现对外部隐藏，但又希望后续的派生类能够访问这些实现。</p>
<h3 id="14-2-4-使用-using-重新定义访问权限"><a href="#14-2-4-使用-using-重新定义访问权限" class="headerlink" title="14.2.4 使用 using 重新定义访问权限"></a>14.2.4 使用 <code>using</code> 重新定义访问权限</h3><p>有时，在使用私有或保护继承时，我们可能希望将基类的<strong>某个</strong>特定成员恢复其原始的访问权限（或使其变为 <code>public</code>），而不是让它在派生类中保持 <code>private</code> 或 <code>protected</code>。可以使用 <code>using</code> 声明来实现这一点。</p>
<p><strong>语法:</strong></p>
<p>在派生类的定义中（通常放在 <code>public</code> 或 <code>protected</code> 部分），使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BaseClassName::MemberName;</span><br></pre></td></tr></table></figure>

<p>这会将 <code>BaseClassName</code> 中的 <code>MemberName</code>（可以是数据成员、成员函数、甚至重载的一组函数）引入到派生类的作用域，并使其具有 <code>using</code> 声明所在区域的访问权限（如果在 <code>public</code> 下，就变为 <code>public</code>；如果在 <code>protected</code> 下，就变为 <code>protected</code>）。</p>
<p><strong>示例 (修改 <code>Student</code> 类):</strong></p>
<p>假设我们希望 <code>Student</code> 类（私有继承版本）能够直接使用 <code>valarray</code> 的 <code>size()</code> 和 <code>sum()</code> 方法，就像它们是 <code>Student</code> 的公有方法一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// studenti.h (修改后)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream &amp; <span class="title">arr_out</span><span class="params">(<span class="built_in">std</span>::ostream &amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 构造函数 ...</span></span><br><span class="line">    ~Student() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 using 声明将基类的部分成员暴露为 public</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::size; <span class="comment">// 使 valarray::size() 成为 Student 的 public 成员</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[]; <span class="comment">// 使 valarray::operator[] 成为 Student 的 public 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仍然需要提供自己的接口，或者暴露更多基类成员</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Average</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// operator[] 现在通过 using 声明暴露了，可以移除 Student 自己的版本 (如果签名匹配)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 友元 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// studenti.cpp (修改后)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 现在可以直接调用 size() 和 sum() (如果 sum 也 using 了)</span></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; <span class="number">0</span>) <span class="comment">// 直接调用继承来的 size()</span></span><br><span class="line">        <span class="comment">// return sum() / size(); // 假设 sum() 也 using 了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::sum() / size(); <span class="comment">// 或者仍然显式调用</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// operator[] 的实现可以移除了，因为 using 声明提供了它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他实现可能也需要调整 ...</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> <code>using</code> 声明只改变成员的<strong>可访问性</strong>，不改变其继承属性（例如，虚函数仍然是虚函数）。它不能用来降低访问权限（例如，不能在 <code>private</code> 部分 <code>using</code> 一个基类的 <code>public</code> 成员来使其变为 <code>private</code>）。</p>
<p><code>using</code> 声明提供了一种在私有/保护继承下选择性地暴露基类接口的方法，但过度使用可能会破坏原本隐藏实现的意图。</p>
<h2 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h2><p><strong>多重继承 (Multiple Inheritance, MI)</strong> 允许一个派生类从<strong>多个</strong>基类继承。这意味着派生类可以同时拥有多个基类的特性和接口。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> accessSpecifier1 BaseClass1, accessSpecifier2 BaseClass2, ... &#123;</span><br><span class="line">    <span class="comment">// ... 派生类成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  在类头中列出所有要继承的基类，用逗号分隔。</li>
<li>  可以为每个基类指定不同的访问说明符（<code>public</code>, <code>protected</code>, <code>private</code>）。</li>
</ul>
<p><strong>示例场景:</strong></p>
<p>假设我们有一个通用的 <code>Worker</code> 类，表示工作人员的基本信息。我们还有 <code>Singer</code> 类表示歌手，<code>Waiter</code> 类表示服务员。现在我们想创建一个 <code>SingingWaiter</code> 类，表示一个既会唱歌又能提供服务的服务员。<code>SingingWaiter</code> 可以同时继承 <code>Singer</code> 和 <code>Waiter</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span> <span class="comment">/* ... id, name ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span> <span class="comment">/* ... voice range, sing() ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> &#123;</span> <span class="comment">/* ... panache, serve() ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingingWaiter 继承自 Singer 和 Waiter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;</span><br><span class="line">    <span class="comment">// ... SingingWaiter 特有的成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>潜在问题:</strong></p>
<p>多重继承虽然强大，但也引入了一些复杂性和潜在的问题：</p>
<h3 id="14-3-1-有多少-Worker-钻石问题-Diamond-Problem"><a href="#14-3-1-有多少-Worker-钻石问题-Diamond-Problem" class="headerlink" title="14.3.1 有多少 Worker (钻石问题 - Diamond Problem)"></a>14.3.1 有多少 Worker (钻石问题 - Diamond Problem)</h3><p>如果多个基类是从<strong>同一个</strong>更远的基类派生而来的，那么派生类将包含该共同基类的<strong>多个副本</strong>（每个继承路径一个）。这被称为<strong>钻石问题</strong>或<strong>菱形继承</strong>。</p>
<p><strong>示例:</strong> 假设 <code>Singer</code> 和 <code>Waiter</code> 都继承自 <code>Worker</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fullname;</span><br><span class="line">    <span class="keyword">virtual</span> ~Worker() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">/* ... show id, name ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> panache;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... show worker info + panache ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>other, alto, contralto, soprano, bass, baritone, tenor&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Vtypes = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> voice;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... show worker info + voice ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingingWaiter 继承自 Waiter 和 Singer，两者都继承自 Worker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... show all info ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，一个 <code>SingingWaiter</code> 对象内部会包含<strong>两个</strong> <code>Worker</code> 子对象：一个来自 <code>Waiter</code> 的继承路径，另一个来自 <code>Singer</code> 的继承路径。</p>
<p>这会导致几个问题：</p>
<ol>
<li><p><strong>成员访问歧义:</strong> 如果你想访问 <code>SingingWaiter</code> 对象的 <code>id</code> 或 <code>fullname</code>（来自 <code>Worker</code>），编译器不知道你指的是哪个 <code>Worker</code> 子对象的成员。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter sw;</span><br><span class="line"><span class="comment">// sw.id = 123; // 错误！歧义：Waiter::Worker::id 还是 Singer::Worker::id？</span></span><br></pre></td></tr></table></figure>
</li>
<li><p> <strong>资源冗余:</strong> <code>Worker</code> 的数据成员被存储了两次，造成浪费。</p>
</li>
</ol>
<p><strong>解决方案：虚基类 (Virtual Base Classes)</strong></p>
<p>为了解决钻石问题，C++ 引入了<strong>虚基类</strong>的概念。当一个类被声明为虚基类时，派生类在通过<strong>多条路径</strong>继承该基类时，只会包含该虚基类的<strong>一个</strong>共享子对象副本。</p>
<ul>
<li><p><strong>语法:</strong> 在派生类继承虚基类时，使用 <code>virtual</code> 关键字。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Waiter 和 Singer 将 Worker 作为虚基类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingingWaiter 正常继承 Waiter 和 Singer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>效果:</strong> 现在，<code>SingingWaiter</code> 对象只包含<strong>一个</strong>共享的 <code>Worker</code> 子对象。访问 <code>id</code> 或 <code>fullname</code> 不再有歧义。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter sw;</span><br><span class="line">sw.id = <span class="number">123</span>; <span class="comment">// OK！只有一个 Worker 子对象，没有歧义。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数责任:</strong> 当使用虚基类时，<strong>最底层的派生类</strong>（在这个例子中是 <code>SingingWaiter</code>）的构造函数<strong>负责</strong>调用虚基类（<code>Worker</code>）的构造函数。中间的基类（<code>Waiter</code>, <code>Singer</code>）在其初始化列表中对虚基类的构造函数调用会被忽略（除非该中间类是直接创建对象）。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingingWaiter 构造函数需要初始化 Worker</span></span><br><span class="line">SingingWaiter::SingingWaiter(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span><br><span class="line">    : Worker(wk), <span class="comment">// 显式调用虚基类构造函数</span></span><br><span class="line">      Waiter(wk, p),</span><br><span class="line">      Singer(wk, v) &#123;</span><br><span class="line">    <span class="comment">// Waiter(wk, p) 和 Singer(wk, v) 内部对 Worker 的构造调用会被忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="14-3-2-哪个方法-成员名冲突"><a href="#14-3-2-哪个方法-成员名冲突" class="headerlink" title="14.3.2 哪个方法 (成员名冲突)"></a>14.3.2 哪个方法 (成员名冲突)</h3><p>即使没有钻石问题，如果不同的基类提供了同名的方法或数据成员，派生类在调用该成员时也会产生<strong>歧义</strong>。</p>
<p><strong>示例:</strong> 假设 <code>Waiter</code> 和 <code>Singer</code> 都有一个名为 <code>Talent()</code> 的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Talent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Serves with style.\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Talent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sings beautifully.\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SingingWaiter sw;</span><br><span class="line"><span class="comment">// sw.Talent(); // 错误！歧义：Waiter::Talent() 还是 Singer::Talent()？</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案：使用作用域解析运算符 (<code>::</code>)</strong></p>
<p>为了解决这种歧义，需要使用作用域解析运算符明确指定要调用哪个基类的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sw.Waiter::Talent(); <span class="comment">// 调用 Waiter 版本的 Talent()</span></span><br><span class="line">sw.Singer::Talent(); <span class="comment">// 调用 Singer 版本的 Talent()</span></span><br></pre></td></tr></table></figure>

<p><strong>虚函数和歧义:</strong></p>
<p>如果冲突的方法是<strong>虚函数</strong>，情况会更复杂一些。</p>
<ul>
<li><p>  如果只有<strong>一个</strong>基类提供了该虚函数，或者所有提供该虚函数的基类都继承自<strong>同一个</strong>（可能是虚）基类的同一个虚函数，那么通过派生类对象调用通常没有歧义（动态联编会起作用）。</p>
</li>
<li><p>但是，如果不同的基类提供了<strong>签名相同但无关</strong>的虚函数，或者派生类想提供一个<strong>覆盖所有</strong>基类版本的新版本，情况会变得复杂。通常建议在派生类中提供一个新的虚函数，并显式调用所需的基类版本。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workermi.h, workermi.cpp, worktest.cpp 示例 (模拟 Worker 层次结构)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// worker0.h - 基类 Worker</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WORKER0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORKER0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// ... (Worker 定义，包含虚函数 Show() 和 Set()) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// workermi.h - MI 相关类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WORKERMI_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORKERMI_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker0.h&quot;</span> <span class="comment">// 包含基类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> panache;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Data</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Waiter() : Worker(), panache(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Waiter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">long</span> n, <span class="keyword">int</span> p = <span class="number">0</span>)</span><br><span class="line">             : Worker(s, n), panache(p) &#123;&#125;</span><br><span class="line">    Waiter(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> p = <span class="number">0</span>)</span><br><span class="line">             : Worker(wk), panache(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>other, alto, contralto, soprano, bass, baritone, tenor&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>Vtypes = <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Data</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *pv[Vtypes]; <span class="comment">// string equivs of voice types</span></span><br><span class="line">    <span class="keyword">int</span> voice;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singer() : Worker(), voice(other) &#123;&#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">long</span> n, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(s, n), voice(v) &#123;&#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(wk), voice(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Data</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SingingWaiter() &#123;&#125;</span><br><span class="line">    <span class="comment">// 显式调用虚基类 Worker 的构造函数</span></span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">long</span> n, <span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) &#123;&#125;</span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(wk), Waiter(wk, p), Singer(wk, v) &#123;&#125;</span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> Waiter &amp; wt, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(wt), Waiter(wt), Singer(wt, v) &#123;&#125; <span class="comment">// 从 Waiter 构造</span></span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> Singer &amp; sg, <span class="keyword">int</span> p = <span class="number">0</span>)</span><br><span class="line">             : Worker(sg), Waiter(sg, p), Singer(sg) &#123;&#125; <span class="comment">// 从 Singer 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// workermi.cpp - 实现 (部分)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workermi.h&quot;</span></span></span><br><span class="line"><span class="comment">// ... Worker 实现 ...</span></span><br><span class="line"><span class="comment">// --- Waiter methods ---</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker::Get(); <span class="comment">// 调用基类方法获取基本信息</span></span><br><span class="line">    Get();         <span class="comment">// 调用自己的 Get 获取 panache</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Worker::Show(); <span class="comment">// 调用基类方法显示基本信息</span></span><br><span class="line">    Data();         <span class="comment">// 调用自己的 Data 显示 panache</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">/* show panache */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Get</span><span class="params">()</span> </span>&#123; <span class="comment">/* get panache */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Singer methods ---</span></span><br><span class="line"><span class="comment">// ... (类似实现 Set, Show, Data, Get) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- SingingWaiter methods ---</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Singer::Data(); <span class="comment">// 显示 Singer 的数据</span></span><br><span class="line">    Waiter::Data(); <span class="comment">// 显示 Waiter 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Waiter::Get(); <span class="comment">// 获取 Waiter 的数据</span></span><br><span class="line">    Singer::Get(); <span class="comment">// 获取 Singer 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker::Get(); <span class="comment">// 获取 Worker 的数据 (只需要一次，因为是虚基类)</span></span><br><span class="line">    Get();         <span class="comment">// 调用 SingingWaiter::Get() 获取 Waiter 和 Singer 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Worker::Show(); <span class="comment">// 显示 Worker 的数据 (只需要一次)</span></span><br><span class="line">    Data();         <span class="comment">// 调用 SingingWaiter::Data() 显示 Waiter 和 Singer 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worktest.cpp - 使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workermi.h&quot;</span></span></span><br><span class="line"><span class="comment">// ... (main 函数创建 Worker*, Waiter*, Singer*, SingingWaiter* 数组，并通过基类指针调用 Set 和 Show) ...</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="14-3-3-MI-小结"><a href="#14-3-3-MI-小结" class="headerlink" title="14.3.3 MI 小结"></a>14.3.3 MI 小结</h3><p><strong>优点:</strong></p>
<ul>
<li>  可以组合多个不同类的功能。</li>
<li>  允许更灵活的类层次结构设计。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>  <strong>复杂性增加:</strong> 可能导致名称冲突和歧义。</li>
<li>  <strong>钻石问题:</strong> 需要使用虚基类来解决，这会增加构造函数实现的复杂性，并可能引入额外的运行时开销。</li>
<li>  <strong>难以理解和维护:</strong> 复杂的 MI 层次结构可能难以理解和调试。</li>
</ul>
<p><strong>设计建议:</strong></p>
<ul>
<li>  <strong>谨慎使用:</strong> 多重继承是一个强大的工具，但也容易被滥用。在决定使用 MI 之前，仔细考虑是否有更简单的替代方案（如包含/组合，或者单继承加接口）。</li>
<li>  <strong>优先考虑组合:</strong> 对于 “has-a” 关系，组合通常是更简单、更安全的选择。</li>
<li>  <strong>虚基类:</strong> 如果确实需要 MI 并且遇到了钻石问题，务必使用虚基类。</li>
<li>  <strong>明确解决歧义:</strong> 使用作用域解析运算符 (<code>::</code>) 来解决成员名称冲突。</li>
</ul>
<p>许多现代 C++ 实践倾向于避免复杂的多重继承，尤其是在应用层面。然而，在某些库设计（如 IO 流库）或需要混合不同抽象接口的场景中，MI 仍然是一个有用的工具。</p>
<h2 id="14-4-类模板"><a href="#14-4-类模板" class="headerlink" title="14.4 类模板"></a>14.4 类模板</h2><p>就像函数模板允许我们编写通用的函数，可以处理不同类型的数据一样，<strong>类模板 (Class Templates)</strong> 允许我们定义通用的类蓝图，可以用来创建处理不同数据类型的类。</p>
<p>类模板是参数化的类定义，其中的某些类型（或值）在定义时是未指定的，而在创建类的实例（对象）时才被指定。这极大地提高了代码的重用性，是泛型编程的核心。STL 中的容器（如 <code>vector</code>, <code>list</code>, <code>map</code>）和智能指针等都是类模板的典型应用。</p>
<h3 id="14-4-1-定义类模板"><a href="#14-4-1-定义类模板" class="headerlink" title="14.4.1 定义类模板"></a>14.4.1 定义类模板</h3><p>定义类模板的语法与函数模板类似，使用 <code>template</code> 关键字，后跟尖括号 <code>&lt;&gt;</code> 中的模板参数列表。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt; <span class="comment">// 或者 template &lt;class T1, class T2, ...&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类定义，可以使用模板参数 T1, T2 等作为类型</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 member1;</span><br><span class="line">    T2 member2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassName(<span class="keyword">const</span> T1 &amp; val1, <span class="keyword">const</span> T2 &amp; val2);</span><br><span class="line">    <span class="function">T1 <span class="title">getMember1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数的定义也需要模板前缀</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line">ClassName&lt;T1, T2, ...&gt;::ClassName(<span class="keyword">const</span> T1 &amp; val1, <span class="keyword">const</span> T2 &amp; val2)</span><br><span class="line">    : member1(val1), member2(val2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line">T1 ClassName&lt;T1, T2, ...&gt;::getMember1() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> member1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>template &lt;typename T&gt;</code> 或 <code>template &lt;class T&gt;</code>: 声明一个模板，<code>T</code> 是一个类型参数的占位符。<code>typename</code> 和 <code>class</code> 在这里是等价的。你可以使用任何有效的标识符作为类型参数名（通常用 <code>T</code>, <code>U</code>, <code>V</code> 等）。</li>
<li>  在类定义内部，可以使用模板参数 <code>T</code> 就像使用普通类型一样（例如，定义成员变量类型、函数参数类型、返回值类型）。</li>
<li>  <strong>成员函数定义:</strong> 当在类外部定义模板类的成员函数时，必须再次使用 <code>template &lt;...&gt;</code> 前缀，并且在类名后面跟上模板参数列表 <code>&lt;T1, T2, ...&gt;</code>。</li>
</ul>
<p><strong>示例：简单的 <code>Stack</code> 模板类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stacktp.h -- 一个简单的栈模板类定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACKTP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKTP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 或者 template &lt;class T&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MAX = <span class="number">10</span> &#125;; <span class="comment">// 栈的最大容量 (非类型参数可以改进)</span></span><br><span class="line">    T items[MAX];      <span class="comment">// 存储栈元素的数组，类型为 T</span></span><br><span class="line">    <span class="keyword">int</span> top;           <span class="comment">// 栈顶索引</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// push() returns false if stack already is full, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp; item)</span></span>; <span class="comment">// 参数类型为 T</span></span><br><span class="line">    <span class="comment">// pop() returns false if stack already is empty, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp; item)</span></span>;        <span class="comment">// 参数类型为 T (通过引用返回弹出的元素)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数实现 (通常也放在头文件中)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() : top(<span class="number">0</span>) &#123; <span class="comment">// 初始化栈顶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::isempty() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::isfull() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::push(<span class="keyword">const</span> T &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX) &#123;</span><br><span class="line">        items[top++] = item; <span class="comment">// 使用类型 T 的赋值操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::pop(T &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item = items[--top]; <span class="comment">// 使用类型 T 的赋值操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STACKTP_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="14-4-2-使用模板类"><a href="#14-4-2-使用模板类" class="headerlink" title="14.4.2 使用模板类"></a>14.4.2 使用模板类</h3><p>要使用类模板，你需要<strong>实例化 (Instantiate)</strong> 它。实例化是指为模板参数提供具体的类型（或值），从而创建一个具体的类。</p>
<p><strong>语法:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&lt;ConcreteType1, ConcreteType2, ...&gt; objectName(constructor_arguments);</span><br></pre></td></tr></table></figure>

<ul>
<li>  在类模板名称后面跟上尖括号 <code>&lt;&gt;</code>，并在其中指定用于替换模板参数的具体类型。</li>
<li>  然后像创建普通类的对象一样声明对象并调用构造函数。</li>
</ul>
<p><strong>示例：使用 <code>Stack</code> 模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack_user.cpp -- 使用 Stack 模板类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt; // for isalpha, etc. (假设用于处理输入)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stacktp.h&quot;</span> <span class="comment">// 包含模板定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个处理 int 的栈</span></span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; intStack; <span class="comment">// intStack 是一个 Stack&lt;int&gt; 类型的对象</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pushing integers onto intStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!intStack.isfull() &amp;&amp; i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        intStack.push(i++);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i<span class="number">-1</span> &lt;&lt; <span class="string">&quot; pushed. &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tempInt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Popping integers from intStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (intStack.pop(tempInt)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tempInt &lt;&lt; <span class="string">&quot; popped. &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个处理 string 的栈</span></span><br><span class="line">    Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringStack; <span class="comment">// stringStack 是一个 Stack&lt;std::string&gt; 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> items[] = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pushing strings onto stringStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stringStack.push(s)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\&quot; pushed. &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stack full, cannot push \&quot;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\&quot;.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tempString;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Popping strings from stringStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (stringStack.pop(tempString)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; tempString &lt;&lt; <span class="string">&quot;\&quot; popped. &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和运行:</strong></p>
<p>由于模板的实现通常放在头文件中，你只需要编译使用模板的源文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ stack_user.cpp -o stack_user</span><br><span class="line">./stack_user</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pushing integers onto intStack:</span><br><span class="line">0 pushed. 1 pushed. 2 pushed. 3 pushed. 4 pushed.</span><br><span class="line">Popping integers from intStack:</span><br><span class="line">4 popped. 3 popped. 2 popped. 1 popped. 0 popped.</span><br><span class="line">Pushing strings onto stringStack:</span><br><span class="line">&quot;apple&quot; pushed. &quot;banana&quot; pushed. &quot;cherry&quot; pushed.</span><br><span class="line">Popping strings from stringStack:</span><br><span class="line">&quot;cherry&quot; popped. &quot;banana&quot; popped. &quot;apple&quot; popped.</span><br></pre></td></tr></table></figure>

<h3 id="14-4-3-深入探讨模板类"><a href="#14-4-3-深入探讨模板类" class="headerlink" title="14.4.3 深入探讨模板类"></a>14.4.3 深入探讨模板类</h3><ul>
<li><p>  <strong>模板编译模型:</strong> 类模板本身并不会被编译成代码。只有当你用具体类型<strong>实例化</strong>模板时，编译器才会根据提供的类型生成对应的具体类（例如 <code>Stack&lt;int&gt;</code> 类和 <code>Stack&lt;string&gt;</code> 类）的代码。这个过程称为**模板实例化 (Template Instantiation)**。</p>
</li>
<li><p>  <strong>实现放在头文件:</strong> 由于编译器在实例化模板时需要看到模板的完整定义（包括成员函数的实现），所以类模板的成员函数实现<strong>通常也放在头文件中</strong> (<code>.h</code> 或 <code>.hpp</code>)，而不是单独的 <code>.cpp</code> 文件中。如果放在 <code>.cpp</code> 文件中，链接器在链接其他使用该模板的 <code>.cpp</code> 文件时，可能找不到所需实例化的代码。</p>
</li>
<li><p>  <strong>隐式实例化 (Implicit Instantiation):</strong> 当你声明一个特定类型的模板类对象时（如 <code>Stack&lt;int&gt; s;</code>），编译器会自动进行隐式实例化。</p>
</li>
<li><p><strong>显式实例化 (Explicit Instantiation):</strong> 你可以显式地指示编译器创建一个特定类型的实例，即使代码中没有直接使用该类型的对象。这在某些库设计或构建过程中可能有用。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span><span class="keyword">double</span>&gt;; <span class="comment">// 在某个 .cpp 文件中显式实例化 Stack&lt;double&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>  <strong>类型要求:</strong> 模板代码对用作模板参数的类型通常有一些隐式要求。例如，<code>Stack</code> 模板要求类型 <code>T</code> 具有可用的赋值运算符 (<code>operator=</code>)，因为 <code>push</code> 和 <code>pop</code> 方法中使用了赋值。如果尝试用不满足这些要求的类型（如没有赋值运算符的类）实例化模板，编译器会报错。</p>
</li>
</ul>
<h3 id="14-4-4-数组模板示例和非类型参数"><a href="#14-4-4-数组模板示例和非类型参数" class="headerlink" title="14.4.4 数组模板示例和非类型参数"></a>14.4.4 数组模板示例和非类型参数</h3><p>类模板不仅可以有<strong>类型参数</strong> (<code>typename T</code> 或 <code>class T</code>)，还可以有**非类型参数 (Non-type Parameters)**。非类型参数是具有固定类型的值，通常是整型（<code>int</code>, <code>size_t</code> 等）、指针、引用或枚举。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt; <span class="comment">// T 是类型参数，N 是非类型参数 (int 类型)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T ar[N]; <span class="comment">// 数组大小由模板参数 N 决定</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  非类型参数 <code>N</code> 成为模板定义的一部分。</li>
<li>  在实例化时，必须为非类型参数提供一个<strong>常量表达式</strong>。</li>
</ul>
<p><strong>示例：固定大小的数组模板 <code>ArrayTP</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arraytp.h -- 模板类 ArrayTP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYTP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYTP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for exit()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt; <span class="comment">// n 是非类型参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T ar[n]; <span class="comment">// 数组大小为 n</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ArrayTP() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ArrayTP</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">virtual</span> T <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line">ArrayTP&lt;T, n&gt;::ArrayTP(<span class="keyword">const</span> T &amp; v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ar[i] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line">T &amp; ArrayTP&lt;T, n&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ar[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line">T ArrayTP&lt;T, n&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ar[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ARRAYTP_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ArrayTP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arraytp.h&quot;</span> <span class="comment">// 包含模板定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个包含 10 个 int 的数组</span></span><br><span class="line">    ArrayTP&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; sums;</span><br><span class="line">    <span class="comment">// 实例化一个包含 10 个 double 的数组</span></span><br><span class="line">    ArrayTP&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; aves;</span><br><span class="line">    <span class="comment">// 实例化一个包含 5 个指向 double 的指针的数组</span></span><br><span class="line">    ArrayTP&lt; ArrayTP&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;, <span class="number">10</span> &gt; twodee; <span class="comment">// 模板嵌套：10x5 的 int 数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sums[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            twodee[i][j] = (i + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">            sums[i] += twodee[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        aves[i] = (<span class="keyword">double</span>) sums[i] / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sums[i] &lt;&lt; <span class="string">&quot; = average &quot;</span> &lt;&lt; aves[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ArrayTP&lt;double, 0&gt; zero_size; // 错误或无意义，取决于编译器和实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>ArrayTP&lt;int, 10&gt;</code> 和 <code>ArrayTP&lt;double, 10&gt;</code> 是<strong>不同</strong>的类型。</li>
<li>  <code>ArrayTP&lt;int, 10&gt;</code> 和 <code>ArrayTP&lt;int, 12&gt;</code> 也是<strong>不同</strong>的类型。</li>
<li>  非类型参数允许我们在编译时确定数组大小等属性，这比动态分配更高效，并且可以进行更严格的类型检查。<code>std::array</code> 就是使用非类型参数来指定大小的。</li>
</ul>
<h3 id="14-4-5-模板多功能性"><a href="#14-4-5-模板多功能性" class="headerlink" title="14.4.5 模板多功能性"></a>14.4.5 模板多功能性</h3><p>类模板可以与 C++ 的其他特性结合使用，提供强大的功能：</p>
<ul>
<li>  <strong>递归使用:</strong> 模板可以递归地使用自身，如 <code>ArrayTP&lt; ArrayTP&lt;int, 5&gt;, 10 &gt;</code> 创建二维数组。</li>
<li>  <strong>指针类型参数:</strong> 可以用指针类型实例化模板，例如 <code>Stack&lt;int*&gt;</code> 创建一个存储 <code>int</code> 指针的栈。</li>
<li>  <strong>包含模板成员:</strong> 类模板可以包含其他模板类的对象作为成员。</li>
<li>  <strong>继承:</strong> 类模板可以参与继承，可以从模板类派生，也可以从普通类派生，或者模板类本身从其他类派生。</li>
</ul>
<h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><p>有时，通用的模板定义对于某些特定类型可能不是最优的，或者根本无法工作。这时，我们需要为特定类型提供一个专门化的模板定义，这称为**模板具体化 (Template Specialization)**。</p>
<ol>
<li><p><strong>显式具体化 (Explicit Specialization):</strong> 为某个特定的类型（或一组特定类型）提供一个完全不同的类定义。</p>
<p> <strong>语法:</strong></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 空的模板参数列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;</span>SpecificType&gt; &#123;</span><br><span class="line">    <span class="comment">// 针对 SpecificType 的特殊实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> <strong>示例:</strong> 假设我们想为 <code>Stack&lt;const char*&gt;</code> 提供一个特殊版本，它能正确处理 C 风格字符串的复制。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // for strcpy, strlen</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式具体化 Stack&lt;const char*&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span><span class="keyword">const</span> <span class="keyword">char</span> *&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MAX = <span class="number">5</span> &#125;; <span class="comment">// 假设容量不同</span></span><br><span class="line">    <span class="keyword">char</span> * items[MAX]; <span class="comment">// 存储指向动态分配字符串的指针</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack(); <span class="comment">// 需要析构函数释放内存</span></span><br><span class="line">    <span class="comment">// ... isempty, isfull ...</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> &amp; item)</span></span>; <span class="comment">// 注意参数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * &amp; item)</span></span>; <span class="comment">// 注意参数类型</span></span><br><span class="line">    <span class="comment">// 需要禁用或实现复制构造和赋值</span></span><br><span class="line">    Stack(<span class="keyword">const</span> Stack &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Stack &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Stack &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 (部分)</span></span><br><span class="line">Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::Stack() : top(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i) items[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::~Stack() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] items[i]; <span class="comment">// 释放 push 时分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::push(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX) &#123;</span><br><span class="line">        items[top] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(item) + <span class="number">1</span>]; <span class="comment">// 分配新内存</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(items[top], item); <span class="comment">// 复制字符串内容</span></span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::pop(<span class="keyword">const</span> <span class="keyword">char</span> * &amp; item) &#123;</span><br><span class="line">     <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        top--;</span><br><span class="line">        item = items[top]; <span class="comment">// 返回指针 (注意：调用者不应 delete 这个指针)</span></span><br><span class="line">                           <span class="comment">// 或者更好的做法是复制一份返回</span></span><br><span class="line">        <span class="comment">// delete [] items[top]; // 如果 pop 后不再需要，则删除</span></span><br><span class="line">        <span class="comment">// items[top] = nullptr;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 其他实现 ...</span></span><br></pre></td></tr></table></figure>
<p> 当编译器遇到 <code>Stack&lt;const char *&gt;</code> 时，它会使用这个显式具体化版本，而不是通用的 <code>Stack&lt;T&gt;</code> 模板。</p>
</li>
<li><p><strong>部分具体化 (Partial Specialization):</strong> 只限制模板参数的一部分，而不是全部。例如，为所有指针类型提供一个特殊版本，或者为一个有两个类型参数的模板固定其中一个参数。</p>
<p> <strong>语法 (示例):</strong></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分具体化：T2 固定为 int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span>T1, <span class="keyword">int</span>&gt; &#123; <span class="comment">/* ... 特殊实现 ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分具体化：T1 和 T2 都是指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span>T1*, T2*&gt; &#123; <span class="comment">/* ... 特殊实现 ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分具体化：T1 和 T2 是相同类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span>T, T&gt; &#123; <span class="comment">/* ... 特殊实现 ... */</span> &#125;;</span><br></pre></td></tr></table></figure>
<p> 编译器会选择最匹配的具体化版本。如果多个部分具体化都能匹配，或者一个部分具体化和一个显式具体化都能匹配，编译器会选择“更具体”的那个。</p>
</li>
</ol>
<h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>类（无论是普通类还是模板类）可以包含本身是模板的成员函数或成员类。这称为**成员模板 (Member Templates)**。</p>
<p><strong>示例：模板构造函数和模板赋值运算符</strong></p>
<p>智能指针类（如 <code>unique_ptr</code>, <code>shared_ptr</code>）经常使用模板构造函数和模板赋值运算符，以允许从指向派生类的智能指针构造或赋值给指向基类的智能指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> : <span class="title">ptr</span><span class="params">(p)</span> </span>&#123;&#125;</span><br><span class="line">    ~SmartPtr() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板成员：模板复制构造函数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 允许从 SmartPtr&lt;U&gt; 构造 SmartPtr&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// 通常需要 U* 能够隐式转换为 T* (例如 U 是 T 的派生类)</span></span><br><span class="line">        ptr = other.get(); <span class="comment">// 简化示例，实际智能指针复制更复杂</span></span><br><span class="line">        <span class="comment">// ... 可能需要增加引用计数等 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板成员：模板赋值运算符</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// ... 类似逻辑 ...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SmartPtr&lt;Derived&gt; <span class="title">pDerived</span><span class="params">(<span class="keyword">new</span> Derived)</span></span>;</span><br><span class="line">SmartPtr&lt;Base&gt; pBase = pDerived; <span class="comment">// OK: 调用模板复制构造函数 SmartPtr&lt;Base&gt;(const SmartPtr&lt;Derived&gt;&amp;)</span></span><br></pre></td></tr></table></figure>

<p>成员模板增加了类的灵活性，允许成员函数或嵌套类处理更广泛的类型。</p>
<h3 id="14-4-8-将模板用作参数"><a href="#14-4-8-将模板用作参数" class="headerlink" title="14.4.8 将模板用作参数"></a>14.4.8 将模板用作参数</h3><p>模板本身也可以作为模板的参数，这称为**模板模板参数 (Template Template Parameters)**。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span> <span class="comment">// Container 是一个模板模板参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; items; <span class="comment">// 使用模板参数 Container 来实例化</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>template &lt;typename U&gt; class Container</code>: 声明 <code>Container</code> 是一个接受一个类型参数的类模板。</li>
<li>  在 <code>Manager</code> 内部，可以用具体的类型 <code>T</code> 来实例化 <code>Container</code>，如 <code>Container&lt;T&gt;</code>。</li>
</ul>
<p><strong>示例:</strong> 创建一个可以使用不同容器（如 <code>std::vector</code>, <code>std::list</code>, 或我们自己的 <code>Stack</code>）来存储元素的 <code>Manager</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stacktp.h&quot;</span> <span class="comment">// 假设 Stack&lt;T&gt; 在这里</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span> <span class="comment">// Container 接受一个类型参数 Elem</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; items; <span class="comment">// 使用 Container&lt;T&gt; 来存储 T 类型的元素</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设 Container 有 push_back 或 push 方法</span></span><br><span class="line">        <span class="comment">// items.push_back(item); // 如果是 vector/list</span></span><br><span class="line">        <span class="comment">// items.push(item); // 如果是 Stack</span></span><br><span class="line">        <span class="comment">// 需要更通用的方式或对 Container 有要求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::vector 作为容器</span></span><br><span class="line">    Manager&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&gt; vectorManager;</span><br><span class="line">    <span class="comment">// vectorManager.add(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::list 作为容器</span></span><br><span class="line">    Manager&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&gt; listManager;</span><br><span class="line">    <span class="comment">// listManager.add(3.14);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用我们自己的 Stack 作为容器</span></span><br><span class="line">    Manager&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Stack&gt; stackManager;</span><br><span class="line">    <span class="comment">// stackManager.add(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板模板参数使得代码更加通用，可以适配不同的模板结构。</p>
<h3 id="14-4-9-模板类和友元"><a href="#14-4-9-模板类和友元" class="headerlink" title="14.4.9 模板类和友元"></a>14.4.9 模板类和友元</h3><p>友元关系可以与类模板结合，有几种不同的形式：</p>
<ol>
<li><p><strong>非模板友元函数/类:</strong> 一个普通的（非模板）函数或类可以是模板类的友元。这意味着这个函数/类可以访问<strong>所有</strong>该模板类实例化的私有成员。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriend</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> HasFriend&lt;T&gt; &amp;)</span></span>; <span class="comment">// 非模板函数 report 是所有实例的友元</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasFriend(<span class="keyword">const</span> T &amp; i) : item(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// report 函数需要为每个实例单独定义或使用模板</span></span><br><span class="line"><span class="comment">// void report(const HasFriend&lt;int&gt; &amp; hf) &#123; std::cout &lt;&lt; hf.item; &#125; // 针对 int 实例</span></span><br><span class="line"><span class="comment">// void report(const HasFriend&lt;double&gt; &amp; hf) &#123; std::cout &lt;&lt; hf.item; &#125; // 针对 double 实例</span></span><br><span class="line"><span class="comment">// 或者将 report 也定义为模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> HasFriend&lt;T&gt; &amp; hf)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; hf.item; &#125; <span class="comment">// 模板友元函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>约束模板友元函数/类 (Bound Template Friend):</strong> 模板函数/类的特定实例化是模板类的特定实例化的友元。即 <code>Friend&lt;T&gt;</code> 是 <code>Target&lt;T&gt;</code> 的友元。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Target</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_func</span><span class="params">(<span class="keyword">const</span> Target&lt;T&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> &#123;</span></span><br><span class="line">    <span class="comment">// friend_func&lt;T&gt; 是 Target&lt;T&gt; 的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> friend_func&lt;T&gt;(<span class="keyword">const</span> Target&lt;T&gt; &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">friend_func</span><span class="params">(<span class="keyword">const</span> Target&lt;T&gt; &amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.data; <span class="comment">// 可以访问 Target&lt;T&gt; 的私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里，<code>friend_func&lt;int&gt;</code> 是 <code>Target&lt;int&gt;</code> 的友元，<code>friend_func&lt;double&gt;</code> 是 <code>Target&lt;double&gt;</code> 的友元，但 <code>friend_func&lt;int&gt;</code> 不是 <code>Target&lt;double&gt;</code> 的友元。</p>
</li>
<li><p><strong>非约束模板友元函数/类 (Unbound Template Friend):</strong> 模板函数/类的<strong>所有</strong>实例化都是模板类的<strong>所有</strong>实例化的友元。即任何 <code>Friend&lt;U&gt;</code> 都是任何 <code>Target&lt;T&gt;</code> 的友元。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherTarget</span> &#123;</span></span><br><span class="line">    <span class="comment">// 声明模板函数 show_data 为友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">// 模板参数 U 可以与 T 不同</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show_data</span><span class="params">(<span class="keyword">const</span> AnotherTarget&lt;U&gt; &amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_data</span><span class="params">(<span class="keyword">const</span> AnotherTarget&lt;U&gt; &amp; at)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; at.data; <span class="comment">// 可以访问任何 AnotherTarget&lt;U&gt; 实例的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">AnotherTarget&lt;<span class="keyword">int</span>&gt; <span class="title">ati</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">AnotherTarget&lt;<span class="keyword">double</span>&gt; <span class="title">atd</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"><span class="comment">// show_data&lt;int&gt;(ati); // OK</span></span><br><span class="line"><span class="comment">// show_data&lt;double&gt;(atd); // OK</span></span><br><span class="line"><span class="comment">// show_data&lt;int&gt;(atd); // 也能访问 atd.data，因为 show_data&lt;int&gt; 是所有 AnotherTarget 的友元</span></span><br></pre></td></tr></table></figure>
<p> 非约束友元提供了最大的访问权限，但也可能破坏封装，需要谨慎使用。</p>
</li>
</ol>
<h3 id="14-4-10-模板别名（C-11）"><a href="#14-4-10-模板别名（C-11）" class="headerlink" title="14.4.10 模板别名（C++11）"></a>14.4.10 模板别名（C++11）</h3><p>C++11 引入了 <code>using</code> 关键字（之前主要用于 <code>using</code> 声明和 <code>using</code> 指令）来创建**模板别名 (Template Aliases)**，使得使用复杂的模板类型更加方便。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为特定实例化创建别名</span></span><br><span class="line"><span class="keyword">using</span> AliasName = ExistingTemplate&lt;ConcreteType&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为模板本身创建别名 (参数化的别名)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AliasTemplateName = ExistingTemplate&lt;T, SomeFixedType, ...&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为特定实例化创建别名</span></span><br><span class="line"><span class="keyword">using</span> IntVec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> StringArray10 = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="number">10</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为模板创建别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;; <span class="comment">// Vec&lt;T&gt; 等价于 std::vector&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Array12 = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, <span class="number">12</span>&gt;; <span class="comment">// Array12&lt;T&gt; 等价于 std::array&lt;T, 12&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntVec numbers; <span class="comment">// numbers 是 std::vector&lt;int&gt;</span></span><br><span class="line">    numbers.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StringArray10 names; <span class="comment">// names 是 std::array&lt;std::string, 10&gt;</span></span><br><span class="line">    names[<span class="number">0</span>] = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Vec&lt;<span class="keyword">double</span>&gt; doubles; <span class="comment">// doubles 是 std::vector&lt;double&gt;</span></span><br><span class="line">    doubles.push_back(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    Array12&lt;<span class="keyword">char</span>&gt; chars; <span class="comment">// chars 是 std::array&lt;char, 12&gt;</span></span><br><span class="line">    chars[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板别名比传统的 <code>typedef</code> 更强大，因为 <code>typedef</code> 不能直接为模板创建别名（只能为完全实例化的类型创建别名）。模板别名提高了代码的可读性和易用性。</p>
<h2 id="14-5-总结"><a href="#14-5-总结" class="headerlink" title="14.5 总结"></a>14.5 总结</h2><p>本章探讨了 C++ 中除了公有继承之外的其他代码重用技术，包括包含（组合）、私有继承、保护继承、多重继承以及强大的类模板。这些技术提供了不同的方式来建立类之间的关系和创建可重用的通用代码。</p>
<p>主要内容回顾：</p>
<ol>
<li><p><strong>包含/组合 (Composition):</strong></p>
<ul>
<li>  通过将一个类的对象作为另一个类的成员来实现，模拟 <strong>“has-a”</strong> 关系。</li>
<li>  是代码重用的常用且推荐的方式，特别是当成员对象能自我管理资源时（遵循零法则）。</li>
<li>  包含类的构造函数使用成员初始化列表来初始化成员对象。</li>
<li>  例如，<code>Student</code> 类包含 <code>std::string</code> 和 <code>std::valarray&lt;double&gt;</code> 成员。</li>
</ul>
</li>
<li><p><strong>私有继承 (<code>private</code>):</strong></p>
<ul>
<li>  模拟 <strong>“is-implemented-in-terms-of”</strong> 关系，继承实现但不继承接口。</li>
<li>  基类的公有和保护成员在派生类中变为私有。</li>
<li>  通常不如包含直观和灵活，但可用于访问基类的保护成员或覆盖虚函数（虽然访问权限变为私有）。</li>
<li>  派生类需要提供自己的接口来暴露所需功能，内部访问基类成员通常需要类型转换。</li>
</ul>
</li>
<li><p><strong>保护继承 (<code>protected</code>):</strong></p>
<ul>
<li>  基类的公有和保护成员在派生类中变为保护。</li>
<li>  与私有继承类似，继承实现但不继承接口。</li>
<li>  允许后续的派生类访问继承来的（现在是保护的）成员。</li>
<li>  使用场景非常有限。</li>
</ul>
</li>
<li><p> <strong>包含 vs. 私有继承:</strong> 对于 “has-a” 关系，**优先选择包含 (组合)**，因为它更简单、清晰、灵活。</p>
</li>
<li><p> <strong><code>using</code> 声明与继承:</strong> 在私有或保护继承下，可以使用 <code>using Base::member;</code> 在派生类中恢复基类某个成员的可访问性（通常提升到 <code>public</code> 或 <code>protected</code>）。</p>
</li>
<li><p><strong>多重继承 (MI):</strong></p>
<ul>
<li>  允许一个类从多个基类继承。</li>
<li>  可能导致<strong>歧义</strong>（成员名冲突）和<strong>钻石问题</strong>（共同基类的多副本）。</li>
<li>  名称冲突通过作用域解析运算符 (<code>::</code>) 解决。</li>
<li>  钻石问题通过<strong>虚基类 (<code>virtual public Base</code>)</strong> 解决，确保共享基类的单一副本，但构造函数实现更复杂。</li>
<li>  应谨慎使用，优先考虑组合或单继承。</li>
</ul>
</li>
<li><p><strong>类模板:</strong></p>
<ul>
<li>  允许创建参数化的类蓝图，用于生成处理不同类型的类。</li>
<li>  使用 <code>template &lt;typename T, ...&gt;</code> 定义。</li>
<li>  通过提供具体类型来<strong>实例化</strong>模板类，如 <code>Stack&lt;int&gt;</code>。</li>
<li>  模板实现通常放在头文件中。</li>
<li>  可以有<strong>非类型参数</strong>（如 <code>template &lt;typename T, int N&gt;</code>），用于在编译时确定常量值（如数组大小）。</li>
<li>  <strong>模板具体化</strong>（显式和部分）允许为特定类型提供专门的实现。</li>
<li>  类可以包含<strong>成员模板</strong>（模板化的成员函数或嵌套类）。</li>
<li>  模板可以作为其他模板的参数（<strong>模板模板参数</strong>）。</li>
<li>  模板可以与<strong>友元</strong>结合，有约束和非约束两种形式。</li>
<li>  C++11 引入了**模板别名 (<code>using Alias = ...</code>)**，简化复杂模板类型的使用。</li>
</ul>
</li>
</ol>
<p>本章介绍的技术极大地扩展了 C++ 代码重用的可能性，从简单的对象组合到复杂的继承层次结构和强大的泛型编程工具——类模板。理解这些技术及其适用场景对于设计灵活、可维护和可重用的 C++ 代码至关重要。</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_14/>http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_14/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-30T23:40:20+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年4月30日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Program/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Program</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/C/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>C++</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_14/&title=Chapter 14 C++中的代码重用 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_14/&title=Chapter 14 C++中的代码重用 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_14/&title=Chapter 14 C++中的代码重用 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2025/04/30/Cpp_tutorial_Chapter_15/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Chapter 15 友元、异常和其他</p>
          <p class='content'>15.1 友元通常，类的 private 和 protected 成员只能被该类的成员函数访问。这是 C++ 封装性的体现，有助于保护数据和隐藏实现细节。然而，在某些特殊情况下，允许特定的外部函...</p>
        </a>
      
      
        <a class='next' href='/2025/04/30/Cpp_tutorial_Chapter_13/'>
          <p class='title'>Chapter 13 类继承<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>13.1 一个简单的基类面向对象编程 (OOP) 的一个核心优势是代码重用。除了通过包含对象成员（组合）之外，C++ 还提供了另一种强大的代码重用机制：**继承 (Inheritance)**。...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E5%8C%85%E5%90%AB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB"><span class="toc-text">14.1 包含对象成员的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-1-valarray-%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-text">14.1.1 valarray 类简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-2-Student-%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">14.1.2 Student 类的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-3-Student-%E7%B1%BB%E7%A4%BA%E4%BE%8B"><span class="toc-text">14.1.3 Student 类示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">14.2 私有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-Student-%E7%B1%BB%E7%A4%BA%E4%BE%8B%EF%BC%88%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">14.2.1 Student 类示例（新版本）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-%E4%BD%BF%E7%94%A8%E5%8C%85%E5%90%AB%E8%BF%98%E6%98%AF%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">14.2.2 使用包含还是私有继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-3-%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-text">14.2.3 保护继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-4-%E4%BD%BF%E7%94%A8-using-%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">14.2.4 使用 using 重新定义访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">14.3 多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-1-%E6%9C%89%E5%A4%9A%E5%B0%91-Worker-%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98-Diamond-Problem"><span class="toc-text">14.3.1 有多少 Worker (钻石问题 - Diamond Problem)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-2-%E5%93%AA%E4%B8%AA%E6%96%B9%E6%B3%95-%E6%88%90%E5%91%98%E5%90%8D%E5%86%B2%E7%AA%81"><span class="toc-text">14.3.2 哪个方法 (成员名冲突)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-3-MI-%E5%B0%8F%E7%BB%93"><span class="toc-text">14.3.3 MI 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">14.4 类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">14.4.1 定义类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">14.4.2 使用模板类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-3-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">14.4.3 深入探讨模板类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-4-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%E5%92%8C%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">14.4.4 数组模板示例和非类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-5-%E6%A8%A1%E6%9D%BF%E5%A4%9A%E5%8A%9F%E8%83%BD%E6%80%A7"><span class="toc-text">14.4.5 模板多功能性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-text">14.4.6 模板的具体化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-7-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-text">14.4.7 成员模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-8-%E5%B0%86%E6%A8%A1%E6%9D%BF%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-text">14.4.8 将模板用作参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-9-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-text">14.4.9 模板类和友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-10-%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D%EF%BC%88C-11%EF%BC%89"><span class="toc-text">14.4.10 模板别名（C++11）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-%E6%80%BB%E7%BB%93"><span class="toc-text">14.5 总结</span></a></li></ol>
    </div>
  </section>


  


</aside>



        
        
          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="Chapter 14 C++中的代码重用";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        
      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5043500508'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a id="s-top" class="fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <script>
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/********************脚本懒加载函数********************************/
function loadScript(src, cb) {
var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
var script = document.createElement('script');
script.setAttribute('type','text/javascript');
if (cb) script.onload = cb;
script.setAttribute('src', src);
HEAD.appendChild(script);
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  








  <script>
  let APlayerController = new Object();
  APlayerController.id = '5043500508';  // 设定全局音乐播放ID
  APlayerController.volume = '0.7';
  loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css", window.volantis.loadcss);

  loadScript("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js")

  loadScript("https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js")


</script>




  
  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/valine.min.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";

    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      recordIP: 'false',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>





  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/app.min.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/search/hexo.min.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://uniqueland.top' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
       

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      
	 

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
      } catch (e) {
        console.log(e);
      }
	  
    });

    document.addEventListener('pjax:error', function (e) {
	  
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
