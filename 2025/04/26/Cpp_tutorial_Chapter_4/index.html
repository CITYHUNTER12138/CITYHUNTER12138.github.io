<!DOCTYPE html>
<html lang="zh-CN">
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>Chapter 4 复合类型 - Uniqueland</title>
  
    <meta name="keywords" content="Program,C++">
  

  
    <meta name="description" content="C++ tutorial">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://www.helloimg.com/images/2022/03/27/ReozOM.png">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

</head>

<body>
  

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div id="l_body">
    <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Uniqueland</p>
    
    
      <p class="subtitle">--XR's personal Blog</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/categories/"
              
              
              id="categories">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>分类</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

    <div id='safearea'>
      <div class='body-wrapper' id="pjax-container">
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
    <div class='headimg-div'>
      <a class='headimg-a'>
        <img class='headimg' src='https://s2.loli.net/2025/04/26/9F74KMasiN1YwQW.png'/>
      </a>
    </div>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Chapter 4 复合类型
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="https://www.helloimg.com/images/2020/11/23/8a8ba722a8cbb8dfcd3cd817f82fa69df380c420_raw83a79d7575e179a3.md.jpg">
    <p>XR</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2025年4月26日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Chapter 4 复合类型" data-path="/2025/04/26/Cpp_tutorial_Chapter_4/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p><strong>数组 (Array)</strong> 是一种<strong>复合类型 (Compound Type)**，它允许你存储多个</strong>相同类型<strong>的值。数组中的每个值称为一个</strong>元素 (Element)<strong>，可以通过</strong>索引 (Index)** 或<strong>下标 (Subscript)</strong> 来访问特定元素。</p>
<h3 id="4-1-1-程序说明"><a href="#4-1-1-程序说明" class="headerlink" title="4.1.1 程序说明"></a>4.1.1 程序说明</h3><p>想象一下，你需要存储一年中每个月的销售额。你可以声明12个独立的 <code>double</code> 变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> salesJan, salesFeb, salesMar, <span class="comment">/* ..., */</span> salesDec; </span><br></pre></td></tr></table></figure>

<p>这种方法非常繁琐，尤其是在需要处理大量数据时。数组提供了一种更简洁、更强大的方式来处理这种情况。</p>
<p><strong>数组声明:</strong></p>
<p>声明一个数组需要指定：</p>
<ol>
<li> <strong>元素类型:</strong> 数组中存储的数据类型。</li>
<li> <strong>数组名称:</strong> 变量名。</li>
<li> <strong>数组大小:</strong> 数组可以容纳的元素数量，必须是一个<strong>常量表达式</strong>（在编译时就能确定其值的表达式，例如字面常量、<code>const</code> 常量、枚举量或 <code>sizeof</code> 表达式的结果），并且必须放在方括号 <code>[]</code> 内。</li>
</ol>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize]; </span><br></pre></td></tr></table></figure>

<p><strong>示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个可以存储 12 个 double 类型值的数组，名为 monthlySales</span></span><br><span class="line"><span class="keyword">double</span> monthlySales[<span class="number">12</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个可以存储 5 个 int 类型值的数组，名为 scores</span></span><br><span class="line"><span class="keyword">int</span> scores[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 常量定义数组大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_STUDENTS = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> studentGrades[NUM_STUDENTS]; </span><br></pre></td></tr></table></figure>

<p><strong>访问数组元素:</strong></p>
<p>使用数组名和方括号内的索引来访问数组元素。<strong>C++数组的索引从 0 开始</strong>。对于大小为 <code>N</code> 的数组，有效的索引范围是 <code>0</code> 到 <code>N-1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 monthlySales 数组的第一个元素 (一月)</span></span><br><span class="line">monthlySales[<span class="number">0</span>] = <span class="number">1500.50</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 monthlySales 数组的第三个元素 (三月)</span></span><br><span class="line">monthlySales[<span class="number">2</span>] = <span class="number">2100.75</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 scores 数组的最后一个元素</span></span><br><span class="line">scores[<span class="number">4</span>] = <span class="number">95</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 scores 数组的第二个元素</span></span><br><span class="line"><span class="keyword">int</span> secondScore = scores[<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;March sales: &quot;</span> &lt;&lt; monthlySales[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second score: &quot;</span> &lt;&lt; secondScore &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><strong>重要:</strong> C++ 不会自动检查数组索引是否越界。访问 <code>arrayName[N]</code> 或 <code>arrayName[-1]</code>（对于大小为 <code>N</code> 的数组）是**未定义行为 (Undefined Behavior)**，可能导致程序崩溃或数据损坏。程序员有责任确保使用的索引在有效范围内 (<code>0</code> 到 <code>arraySize - 1</code>)。</p>
<p><strong>数组大小必须是常量表达式:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int dynamicArray[n]; // 错误! C++ 标准不允许使用变量作为数组大小 (虽然某些编译器可能作为扩展支持)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> staticArray[SIZE]; <span class="comment">// 正确! SIZE 是 const 常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> anotherArray[<span class="number">10</span>]; <span class="comment">// 正确! 10 是字面常量</span></span><br></pre></td></tr></table></figure>

<p>如果需要在运行时确定数组大小，应该使用动态内存分配（<code>new</code>）或标准库提供的容器（如 <code>std::vector</code>），我们将在后续章节学习。</p>
<h3 id="4-1-2-数组的初始化规则"><a href="#4-1-2-数组的初始化规则" class="headerlink" title="4.1.2 数组的初始化规则"></a>4.1.2 数组的初始化规则</h3><p>在声明数组时，可以同时对其进行初始化。初始化使用花括号 <code>&#123;&#125;</code> 括起来的**初始化列表 (Initializer List)**。</p>
<p><strong>规则:</strong></p>
<ol>
<li><strong>完整初始化:</strong> 提供与数组大小相同数量的初始值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> scores[<span class="number">5</span>] = &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>, <span class="number">88</span>&#125;; <span class="comment">// scores[0]=90, scores[1]=85, ..., scores[4]=88</span></span><br><span class="line"><span class="keyword">double</span> lengths[<span class="number">3</span>] = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">0.5</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>部分初始化:</strong> 如果提供的初始值数量<strong>少于</strong>数组大小，则<strong>剩余的元素会被自动初始化为 0</strong>（对于数值类型）或相应的零等价值（对于其他类型，如字符数组的空字符 <code>\0</code>）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counts[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// counts[0]=1, counts[1]=2, counts[2]=3</span></span><br><span class="line">                           <span class="comment">// counts[3] 到 counts[9] 都被初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> readings[<span class="number">5</span>] = &#123;<span class="number">9.8f</span>&#125;; <span class="comment">// readings[0]=9.8f, 其他元素为 0.0f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组所有元素初始化为 0 的常用方法</span></span><br><span class="line"><span class="keyword">int</span> allZeros[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br></pre></td></tr></table></figure></li>
<li><strong>省略数组大小:</strong> 如果在声明时提供了初始化列表，可以省略方括号中的数组大小。编译器会根据初始化列表中的元素数量自动推断数组大小。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> values[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;; <span class="comment">// 编译器推断数组大小为 4</span></span><br><span class="line"><span class="keyword">char</span> message[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 大小为 6 (包括空字符)</span></span><br></pre></td></tr></table></figure></li>
<li><strong>不允许初始化列表元素过多:</strong> 初始化列表中的元素数量<strong>不能超过</strong>数组声明的大小。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int errors[3] = &#123;1, 2, 3, 4&#125;; // 错误! 初始化列表元素过多</span></span><br></pre></td></tr></table></figure></li>
<li><strong>未初始化数组:</strong> 如果在声明数组时没有提供初始化列表（仅适用于非静态局部数组），则数组元素的值是<strong>未定义的 (indeterminate)**，它们会包含内存中遗留的垃圾值。</strong>使用未初始化的变量是常见的错误来源。** <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> garbage[<span class="number">5</span>]; <span class="comment">// 数组元素的值是未定义的 (垃圾值)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; garbage[0]; // 错误! 使用未初始化的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> staticGarbage[<span class="number">5</span>]; <span class="comment">// 静态存储数组会被默认初始化为 0</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; staticGarbage[0]; // 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <em>(静态存储持续性的变量，如全局变量、命名空间变量、静态局部变量，会被默认零初始化)</em></li>
</ol>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完整初始化</span></span><br><span class="line">    <span class="keyword">int</span> fibonacci[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fibonacci[5]: &quot;</span> &lt;&lt; fibonacci[<span class="number">5</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分初始化</span></span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">5</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[0]: &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[1]: &quot;</span> &lt;&lt; data[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2.2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[2]: &quot;</span> &lt;&lt; data[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[3]: &quot;</span> &lt;&lt; data[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[4]: &quot;</span> &lt;&lt; data[<span class="number">4</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略大小</span></span><br><span class="line">    <span class="keyword">char</span> vowels[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of vowels: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(vowels) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有元素为 0</span></span><br><span class="line">    <span class="keyword">int</span> results[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Results[15]: &quot;</span> &lt;&lt; results[<span class="number">15</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-C-11数组初始化方法"><a href="#4-1-3-C-11数组初始化方法" class="headerlink" title="4.1.3 C++11数组初始化方法"></a>4.1.3 C++11数组初始化方法</h3><p>C++11 引入了更统一的初始化语法，称为<strong>列表初始化 (List Initialization)</strong> 或**花括号初始化 (Brace Initialization)**，它也可以用于数组。</p>
<p><strong>主要变化:</strong></p>
<ol>
<li> <strong>可以省略等号 <code>=</code>:</strong> 在使用初始化列表时，可以省略声明语句中的等号。</li>
<li> <strong>禁止缩窄转换 (Narrowing Conversion):</strong> 列表初始化不允许可能导致数据丢失的“缩窄”转换。例如，不能将浮点数直接初始化给整型数组元素，也不能将超出范围的整数值初始化给较小范围的整型数组元素。</li>
</ol>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize] &#123;<span class="built_in">initializer_list</span>&#125;; <span class="comment">// C++11 列表初始化 (可省略等号)</span></span><br><span class="line">typeName arrayName[] &#123;<span class="built_in">initializer_list</span>&#125;;         <span class="comment">// 省略大小</span></span><br></pre></td></tr></table></figure>

<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++11 列表初始化 (省略等号)</span></span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">5</span>] &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>, <span class="number">88</span>&#125;; </span><br><span class="line">    <span class="keyword">double</span> lengths[<span class="number">3</span>] &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> counts[<span class="number">10</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 部分初始化，剩余元素为 0</span></span><br><span class="line">    <span class="keyword">int</span> allZeros[<span class="number">100</span>] &#123;&#125;;     <span class="comment">// 所有元素初始化为 0 (空列表)</span></span><br><span class="line">    <span class="keyword">short</span> values[] &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;; <span class="comment">// 省略大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scores[1]: &quot;</span> &lt;&lt; scores[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 85</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counts[5]: &quot;</span> &lt;&lt; counts[<span class="number">5</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;allZeros[50]: &quot;</span> &lt;&lt; allZeros[<span class="number">50</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of values: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(values) / <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止缩窄转换示例</span></span><br><span class="line">    <span class="comment">// int errors[3] &#123;1, 2, 3.0&#125;; // 错误! double (3.0) 到 int 是缩窄转换</span></span><br><span class="line">    <span class="comment">// char chars[2] &#123; &#x27;a&#x27;, 300 &#125;; // 错误! 300 超出 char 的范围 (假设 char 是 8 位)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许非缩窄转换</span></span><br><span class="line">    <span class="keyword">char</span> chars_ok[<span class="number">3</span>] &#123; <span class="string">&#x27;a&#x27;</span>, <span class="number">66</span>, <span class="string">&#x27;c&#x27;</span> &#125;; <span class="comment">// 66 在 char 范围内，可以隐式转换为 &#x27;B&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chars OK: &quot;</span> &lt;&lt; chars_ok[<span class="number">0</span>] &lt;&lt; chars_ok[<span class="number">1</span>] &lt;&lt; chars_ok[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 aBc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建议:</strong> C++11 的列表初始化提供了更一致、更安全的初始化方式，推荐在支持 C++11 及更高标准的项目中使用。特别是 <code>typeName arrayName[size] &#123;&#125;;</code> 这种将所有元素初始化为零值的形式非常方便。</p>
<h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><p>字符串是程序中用于表示文本信息的重要数据类型。C++处理字符串有两种主要方式：</p>
<ol>
<li> <strong>C风格字符串 (C-Style String):</strong> 这是继承自C语言的方式，将字符串视为存储在 <code>char</code> 数组中并以<strong>空字符 (<code>\0</code>)</strong> 结尾的字符序列。</li>
<li> <strong><code>string</code> 类:</strong> C++标准库提供了一个强大的 <code>string</code> 类，提供了更方便、更安全的字符串操作（将在 4.3 节介绍）。</li>
</ol>
<p>本节主要关注 C 风格字符串。</p>
<p><strong>字符串字面值 (String Literal) 或字符串常量 (String Constant):</strong><br>在代码中用双引号 <code>&quot;&quot;</code> 括起来的字符序列，例如 <code>&quot;Hello, world!&quot;</code>, <code>&quot;C++&quot;</code>, <code>&quot;&quot;</code> (空字符串)。它们存储在内存的只读区域。编译器会自动在字符串字面值的末尾添加空字符 <code>\0</code>。</p>
<h3 id="4-2-1-拼接字符串常量"><a href="#4-2-1-拼接字符串常量" class="headerlink" title="4.2.1 拼接字符串常量"></a>4.2.1 拼接字符串常量</h3><p>C++允许将<strong>相邻</strong>的字符串字面值自动拼接（连接）成一个单独的字符串。这对于将较长的字符串分成多行书写非常有用，可以提高代码的可读性。</p>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相邻的字符串字面值会被自动拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is the first part, &quot;</span> <span class="string">&quot;and this is the second part.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出: This is the first part, and this is the second part.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以跨越多行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 1: Some text...\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Line 2: More text...\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Line 3: Final line.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Line 1: Some text...</span></span><br><span class="line"><span class="comment">    Line 2: More text...</span></span><br><span class="line"><span class="comment">    Line 3: Final line.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接结果是一个单独的字符串常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* long_message = <span class="string">&quot;Part 1. &quot;</span></span><br><span class="line">                               <span class="string">&quot;Part 2. &quot;</span></span><br><span class="line">                               <span class="string">&quot;Part 3.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; long_message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出: Part 1. Part 2. Part 3.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：变量和字符串字面值不能自动拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> part1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; part1 &quot; world!&quot;; // 错误! 不能这样拼接变量和字面值</span></span><br><span class="line">    <span class="comment">// 需要使用 string 类的拼接操作 (见 4.3 节) 或 cout 的链式输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; part1 &lt;&lt; <span class="string">&quot; world!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-在数组中使用字符串"><a href="#4-2-2-在数组中使用字符串" class="headerlink" title="4.2.2 在数组中使用字符串"></a>4.2.2 在数组中使用字符串</h3><p>C风格字符串本质上是 <code>char</code> 类型的数组，其特殊之处在于最后一个字符必须是**空字符 (<code>\0</code>)**。这个空字符标记了字符串的实际结束位置。</p>
<p><strong>声明和初始化:</strong></p>
<p>可以使用字符串字面值来初始化 <code>char</code> 数组。编译器会自动计算大小（包括末尾的 <code>\0</code>）并将其复制到数组中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 包含 C 风格字符串函数库 (例如 strlen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用字符串字面值初始化 char 数组</span></span><br><span class="line">    <span class="keyword">char</span> dog[<span class="number">8</span>] = <span class="string">&quot;fatcat&quot;</span>; <span class="comment">// 数组大小必须足够容纳字符串 + 空字符 (&#x27;f&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\0&#x27;)</span></span><br><span class="line">                            <span class="comment">// dog 数组大小为 8，实际使用 7 个字符 + 1 个空字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> bird[] = <span class="string">&quot;wren&quot;</span>;   <span class="comment">// 编译器自动推断大小为 5 (&#x27;w&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;n&#x27;,&#x27;\0&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用列表初始化 (需要显式包含空字符)</span></span><br><span class="line">    <span class="keyword">char</span> fish[] = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例：数组大小不足</span></span><br><span class="line">    <span class="comment">// char cat[3] = &quot;cat&quot;; // 错误! 需要大小 4 来存储 &#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog: &quot;</span> &lt;&lt; dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// cout 遇到空字符停止输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bird: &quot;</span> &lt;&lt; bird &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fish: &quot;</span> &lt;&lt; fish &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问单个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Third letter of dog: &quot;</span> &lt;&lt; dog[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;t&#x27;</span></span><br><span class="line">    dog[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>; <span class="comment">// 可以修改数组内容</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified dog: &quot;</span> &lt;&lt; dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;patcat&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strlen() 函数计算字符串长度 (不包括空字符)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of dog: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(dog) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6 (因为现在是 &quot;patcat&quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of bird: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(bird) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sizeof() 计算整个数组占用的内存大小 (包括空字符和未使用的空间)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of dog array: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(dog) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of bird array: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(bird) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点:</strong></p>
<ul>
<li>  存储 C 风格字符串的 <code>char</code> 数组大小必须至少是字符串长度加 1（为 <code>\0</code> 留出空间）。</li>
<li>  字符串字面值初始化会自动添加 <code>\0</code>。</li>
<li>  列表初始化需要手动添加 <code>\0</code>。</li>
<li>  <code>strlen()</code> 计算的是到 <code>\0</code> 为止的字符数。</li>
<li>  <code>sizeof()</code> 计算的是整个数组的字节大小。</li>
</ul>
<h3 id="4-2-3-字符串输入"><a href="#4-2-3-字符串输入" class="headerlink" title="4.2.3 字符串输入"></a>4.2.3 字符串输入</h3><p>使用 <code>cin</code> 和 <code>&gt;&gt;</code> 运算符读取 C 风格字符串（存储在 <code>char</code> 数组中）时，存在一个主要限制：<code>cin</code> 默认以<strong>空白字符</strong>（空格、制表符、换行符）作为输入的分隔符。这意味着 <code>cin &gt;&gt;</code> 只会读取到第一个空白字符之前的部分。</p>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> name[SIZE];</span><br><span class="line">    <span class="keyword">char</span> dessert[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your first name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// 读取直到遇到第一个空白字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your favorite dessert: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; dessert; <span class="comment">// 读取直到遇到第一个空白字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I see you like &quot;</span> &lt;&lt; dessert &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行示例及问题:</strong></p>
<p>如果用户输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter your first name: Ada Lovelace</span><br><span class="line">Enter your favorite dessert: Chocolate Cake</span><br></pre></td></tr></table></figure>

<p>程序输出将会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Ada!</span><br><span class="line">I see you like Lovelace. </span><br></pre></td></tr></table></figure>

<p><strong>原因:</strong></p>
<ol>
<li> <code>cin &gt;&gt; name;</code> 读取到 “Ada” 后遇到空格停止，”Ada” 被存入 <code>name</code> 数组（并自动添加 <code>\0</code>）。</li>
<li> “ Lovelace\nChocolate Cake\n” 仍然留在输入缓冲区中。</li>
<li> <code>cin &gt;&gt; dessert;</code> 从缓冲区开始读取，跳过开头的空格，读取到 “Lovelace” 后遇到换行符停止，”Lovelace” 被存入 <code>dessert</code> 数组。</li>
</ol>
<p>这显然不是我们期望的结果。<code>cin &gt;&gt;</code> 不适合读取包含空格的字符串。此外，如果用户输入的单词长度超过了数组的大小（减去 <code>\0</code> 的空间），还会导致**缓冲区溢出 (Buffer Overflow)**，这是严重的安全隐患。</p>
<h3 id="4-2-4-每次读取一行字符串输入"><a href="#4-2-4-每次读取一行字符串输入" class="headerlink" title="4.2.4 每次读取一行字符串输入"></a>4.2.4 每次读取一行字符串输入</h3><p>为了解决 <code>cin &gt;&gt;</code> 的问题，<code>iostream</code> 库提供了其他成员函数来读取整行输入，包括其中的空格，直到遇到换行符为止。常用的有两个：<code>getline()</code> 和 <code>get()</code>。</p>
<p><strong>1. <code>cin.getline(char* buffer, int size, char delimiter = &#39;\n&#39;)</code></strong></p>
<ul>
<li>  <code>buffer</code>: 用于存储输入的 <code>char</code> 数组。</li>
<li>  <code>size</code>: 缓冲区的大小。<code>getline()</code> 最多读取 <code>size - 1</code> 个字符，以确保有空间存放末尾的空字符 <code>\0</code>。</li>
<li>  <code>delimiter</code> (可选): 指定读取停止的分隔符，默认为换行符 <code>\n</code>。</li>
</ul>
<p><strong>行为:</strong></p>
<ul>
<li>  读取字符到 <code>buffer</code> 中，直到读取了 <code>size - 1</code> 个字符、遇到 <code>delimiter</code> 或到达文件末尾。</li>
<li>  如果遇到 <code>delimiter</code>，它会<strong>读取并丢弃</strong>该分隔符（通常是换行符）。</li>
<li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li>
</ul>
<p><strong>2. <code>cin.get(char* buffer, int size, char delimiter = &#39;\n&#39;)</code></strong></p>
<ul>
<li>  参数与 <code>getline()</code> 类似。</li>
</ul>
<p><strong>行为:</strong></p>
<ul>
<li>  读取字符到 <code>buffer</code> 中，直到读取了 <code>size - 1</code> 个字符、遇到 <code>delimiter</code> 或到达文件末尾。</li>
<li>  与 <code>getline()</code> 不同的是，如果遇到 <code>delimiter</code>，它<strong>不会读取</strong>该分隔符，而是将其<strong>留在输入缓冲区中</strong>。</li>
<li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> fullName[SIZE];</span><br><span class="line">    <span class="keyword">char</span> address[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 getline()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(fullName, SIZE); <span class="comment">// 读取整行，包括空格，丢弃换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your address: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(address, SIZE); <span class="comment">// 读取下一行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; fullName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 get() - 注意换行符问题</span></span><br><span class="line">    <span class="keyword">char</span> title[SIZE];</span><br><span class="line">    <span class="keyword">char</span> author[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter book title: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(title, SIZE); <span class="comment">// 读取整行，换行符留在缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果直接调用下一个 get()，它会立即读到上一个留下的换行符并停止</span></span><br><span class="line">    <span class="comment">// std::cin.get(author, SIZE); // 这将导致 author 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要处理掉留下的换行符</span></span><br><span class="line">    <span class="comment">// 方法一：再调用一次 get() 读取单个字符</span></span><br><span class="line">    <span class="comment">// std::cin.get(); // 读取并丢弃换行符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法二：使用 ignore() 跳过字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 跳过最多100个字符，直到遇到换行符（并丢弃换行符）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter author name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(author, SIZE); <span class="comment">// 现在可以正确读取作者名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Title: &quot;</span> &lt;&lt; title &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Author: &quot;</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择 <code>getline()</code> 还是 <code>get()</code>?</strong></p>
<ul>
<li>  <code>getline()</code> 通常更方便，因为它会自动处理掉行尾的换行符，使得连续读取多行输入更简单。</li>
<li>  <code>get()</code> 提供了更精细的控制，因为它允许你检查下一个字符是否是换行符，但需要你手动处理留在缓冲区的分隔符。</li>
</ul>
<p><strong>空行和 <code>getline()</code>:</strong> 如果 <code>getline()</code> 遇到空行（即用户直接按 Enter），它会读取这个空行，将一个空字符串（只包含 <code>\0</code>）存入缓冲区，并丢弃换行符。</p>
<h3 id="4-2-5-混合输入字符串和数字"><a href="#4-2-5-混合输入字符串和数字" class="headerlink" title="4.2.5 混合输入字符串和数字"></a>4.2.5 混合输入字符串和数字</h3><p>当程序需要交替读取数字（使用 <code>cin &gt;&gt;</code>）和整行字符串（使用 <code>cin.getline()</code> 或 <code>cin.get()</code>）时，经常会遇到一个问题：<code>cin &gt;&gt;</code> 读取数字后，会将数字后面的<strong>换行符</strong>留在输入缓冲区中。</p>
<p>如果紧接着调用 <code>cin.getline()</code> 或 <code>cin.get()</code>，它们会立即读到这个残留的换行符，并认为已经到达行尾，导致读取失败或读到空字符串。</p>
<p><strong>问题示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; <span class="comment">// 读取年龄，换行符留在缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="number">50</span>); <span class="comment">// 立即读到残留的换行符，getline 结束，name 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Name: []</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法:</strong></p>
<p>在读取数字后、调用 <code>getline()</code> 或 <code>get()</code> 读取整行之前，需要消耗掉输入缓冲区中残留的换行符。</p>
<ol>
<li><strong>使用 <code>cin.ignore()</code>:</strong> 这是常用的方法。<code>cin.ignore(n, delim)</code> 会跳过输入流中的字符，直到跳过了 <code>n</code> 个字符，或者遇到了 <code>delim</code> 分隔符（并丢弃该分隔符），以先到者为准。通常用于丢弃换行符： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 跳过最多100个字符，直到并包括下一个换行符</span></span><br><span class="line"><span class="comment">// 或者更简单地，如果确定只有一个换行符需要丢弃</span></span><br><span class="line"><span class="comment">// std::cin.ignore(); // 跳过下一个字符 (即换行符)</span></span><br></pre></td></tr></table></figure></li>
<li><strong>使用 <code>(cin &gt;&gt; ws)</code>:</strong> C++11 引入了 <code>std::ws</code> 输入流操纵符，它可以读取并丢弃输入流开头的所有空白字符（包括换行符）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::ws).getline(name, <span class="number">50</span>); </span><br></pre></td></tr></table></figure></li>
<li><strong>使用 <code>cin.get()</code> 读取单个字符:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get(); <span class="comment">// 读取并丢弃换行符</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>修正后的示例 (使用 <code>cin.ignore()</code>):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // 为了 numeric_limits (更健壮的 ignore)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除输入缓冲区，特别是换行符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">    <span class="comment">// numeric_limits&lt;streamsize&gt;::max() 获取流能处理的最大字符数，确保清除整行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="number">50</span>); <span class="comment">// 现在可以正确读取姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修正后的示例 (使用 <code>ws</code>):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt; // 为了 ws</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="comment">// 在 getline 之前使用 ws 跳过空白符</span></span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::ws).getline(name, <span class="number">50</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong> 混合输入数字和整行字符串时，务必记得在 <code>cin &gt;&gt; number;</code> 之后、调用 <code>getline()</code> 或 <code>get()</code> 之前，清除输入缓冲区中残留的换行符。使用 <code>cin.ignore()</code> 或 <code>(cin &gt;&gt; ws)</code> 是推荐的做法。</p>
<h2 id="4-3-string类简介"><a href="#4-3-string类简介" class="headerlink" title="4.3 string类简介"></a>4.3 string类简介</h2><p>虽然 C 风格字符串（字符数组）在 C++ 中仍然可用，但 C++ 标准库提供了一个更强大、更方便、更安全的替代品：<code>std::string</code> 类。</p>
<p><code>string</code> 类是标准库的一部分，它封装了字符序列的操作，提供了自动内存管理和丰富的成员函数来处理字符串。要使用 <code>string</code> 类，需要包含 <code>&lt;string&gt;</code> 头文件。</p>
<p><strong>基本概念:</strong></p>
<ul>
<li>  <strong>对象:</strong> <code>string</code> 类型的变量是**对象 (Object)**。对象是类的实例。</li>
<li>  <strong>自动内存管理:</strong> 与需要手动管理内存（确保数组足够大，处理空字符）的 C 风格字符串不同，<code>string</code> 对象会自动处理内存分配和释放。它可以根据需要动态增长或缩小。</li>
<li>  <strong>成员函数:</strong> <code>string</code> 类提供了许多内置的操作（成员函数），如获取长度、拼接、查找、替换等，使得字符串处理更加容易。</li>
</ul>
<p><strong>基本用法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 必须包含 string 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明 string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1; <span class="comment">// 创建一个空字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 使用 C 风格字符串字面值初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>; <span class="comment">// 使用 C 风格字符串字面值初始化 (构造函数语法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4 = s2; <span class="comment">// 使用另一个 string 对象初始化 (复制)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出空行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 World</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string 对象可以像普通变量一样使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = s2 + <span class="string">&quot;, &quot;</span> + s3 + <span class="string">&quot;!&quot;</span>; <span class="comment">// 字符串拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-1-C-11字符串初始化"><a href="#4-3-1-C-11字符串初始化" class="headerlink" title="4.3.1 C++11字符串初始化"></a>4.3.1 C++11字符串初始化</h3><p>C++11 引入的列表初始化（花括号初始化）也可以用于 <code>string</code> 对象，其行为类似于使用 C 风格字符串字面值进行初始化。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 &#123; <span class="string">&quot;Initialized with braces&quot;</span> &#125;; <span class="comment">// 使用 C 风格字符串字面值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = &#123; <span class="string">&quot;Also works with =&quot;</span> &#125;; </span><br><span class="line"><span class="comment">// std::string str3 &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;; // C++11 中通常不直接用字符列表初始化 string (会尝试调用匹配的构造函数)</span></span><br><span class="line"><span class="comment">// std::string str4 = &#123; &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27; &#125;; // 同上</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 直接使用字符列表 <code>&#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;</code> 来初始化 <code>std::string</code> 在 C++11/14 中通常不会按预期工作，因为它会尝试查找接受 <code>std::initializer_list&lt;char&gt;</code> 的构造函数，而标准 <code>std::string</code> 没有这样的构造函数。它通常会被解释为尝试调用接受 C 风格字符串 ( <code>const char*</code> ) 的构造函数，但这需要列表恰好能形成一个有效的 C 风格字符串（例如，包含 <code>\0</code>）。</p>
<p>最常用和清晰的初始化方式仍然是使用字符串字面值或另一个 <code>string</code> 对象。</p>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting1 &#123; <span class="string">&quot;Good morning&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting2 = &#123; <span class="string">&quot;Good afternoon&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// std::string letters &#123; &#x27;H&#x27;, &#x27;i&#x27;, &#x27;\0&#x27; &#125;; // 可能不按预期工作或编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Good morning</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Good afternoon</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐的初始化方式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>;       <span class="comment">// C 风格字面值</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;      <span class="comment">// 构造函数语法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3 = s1;          <span class="comment">// 复制构造</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>;      <span class="comment">// 创建包含 10 个 &#x27;c&#x27; 的字符串 &quot;cccccccccc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-赋值、拼接和附加"><a href="#4-3-2-赋值、拼接和附加" class="headerlink" title="4.3.2 赋值、拼接和附加"></a>4.3.2 赋值、拼接和附加</h3><p><code>string</code> 类重载了常见的运算符，使得赋值、拼接和附加操作非常直观。</p>
<ul>
<li>  <strong>赋值 (<code>=</code>):</strong> 可以将一个 <code>string</code> 对象、一个 C 风格字符串字面值或一个 <code>char</code> 赋给一个 <code>string</code> 对象。</li>
<li>  <strong>拼接 (<code>+</code>):</strong> 可以使用 <code>+</code> 运算符将两个 <code>string</code> 对象、<code>string</code> 对象和 C 风格字符串字面值、或者 <code>string</code> 对象和 <code>char</code> 拼接起来，生成一个新的 <code>string</code> 对象。<strong>注意：不能直接拼接两个 C 风格字符串字面值，至少有一个操作数需要是 <code>string</code> 对象。</strong></li>
<li>  <strong>附加 (<code>+=</code>):</strong> 可以使用 <code>+=</code> 运算符将一个 <code>string</code> 对象、一个 C 风格字符串字面值或一个 <code>char</code> 附加到现有 <code>string</code> 对象的末尾（修改原字符串）。</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    s3 = s1; <span class="comment">// s3 变为 &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s3 = <span class="string">&quot;Goodbye&quot;</span>; <span class="comment">// s3 变为 &quot;Goodbye&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after new assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s3 = <span class="string">&#x27;X&#x27;</span>; <span class="comment">// s3 变为 &quot;X&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after char assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 (+) - 创建新字符串</span></span><br><span class="line">    s4 = s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot;!&quot;</span>; <span class="comment">// s4 变为 &quot;Hello World!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4 (concatenated): &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s5 = s1 + <span class="string">&#x27;!&#x27;</span>; <span class="comment">// s5 变为 &quot;Hello!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s5 (string + char): &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误: 不能直接拼接两个 C 风格字符串字面值</span></span><br><span class="line">    <span class="comment">// std::string error_str = &quot;String1&quot; + &quot;String2&quot;; // 编译错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确: 至少有一个是 string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ok_str1 = s1 + <span class="string">&quot; String2&quot;</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ok_str2 = <span class="string">&quot;String1&quot;</span> + s2; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok_str1: &quot;</span> &lt;&lt; ok_str1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok_str2: &quot;</span> &lt;&lt; ok_str2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加 (+=) - 修改原字符串</span></span><br><span class="line">    s1 += <span class="string">&quot; &quot;</span>; <span class="comment">// s1 变为 &quot;Hello &quot;</span></span><br><span class="line">    s1 += s2; <span class="comment">// s1 变为 &quot;Hello World&quot;</span></span><br><span class="line">    s1 += <span class="string">&#x27;!&#x27;</span>; <span class="comment">// s1 变为 &quot;Hello World!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 after append: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-string类的其他操作"><a href="#4-3-3-string类的其他操作" class="headerlink" title="4.3.3 string类的其他操作"></a>4.3.3 string类的其他操作</h3><p><code>string</code> 类提供了大量成员函数来执行各种字符串操作。以下是一些常用的操作：</p>
<ul>
<li><strong>获取长度/大小:</strong><ul>
<li>  <code>size()</code> 或 <code>length()</code>: 返回字符串中的字符数（两者功能相同）。</li>
</ul>
</li>
<li><strong>检查是否为空:</strong><ul>
<li>  <code>empty()</code>: 如果字符串为空，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
<li><strong>访问字符:</strong><ul>
<li>  <code>[]</code> 运算符: 像数组一样通过索引访问字符（不进行边界检查）。</li>
<li>  <code>at()</code>: 通过索引访问字符（进行边界检查，如果越界会抛出 <code>std::out_of_range</code> 异常）。</li>
</ul>
</li>
<li><strong>查找:</strong><ul>
<li>  <code>find()</code>: 查找子字符串或字符首次出现的位置，返回索引；如果未找到，返回 <code>std::string::npos</code> (一个特殊的静态成员常量)。</li>
<li>  <code>rfind()</code>: 从后向前查找。</li>
<li>  <code>find_first_of()</code>, <code>find_last_of()</code>, <code>find_first_not_of()</code>, <code>find_last_not_of()</code>: 查找字符集中的任意字符或非任意字符。</li>
</ul>
</li>
<li><strong>子字符串:</strong><ul>
<li>  <code>substr(pos, count)</code>: 返回从位置 <code>pos</code> 开始，长度为 <code>count</code> 的子字符串。</li>
</ul>
</li>
<li><strong>比较:</strong><ul>
<li>  <code>compare()</code>: 比较字符串（字典序），返回负数、零或正数。</li>
<li>  重载的关系运算符 (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>): 可以直接比较 <code>string</code> 对象。</li>
</ul>
</li>
<li><strong>修改:</strong><ul>
<li>  <code>insert()</code>: 在指定位置插入字符或字符串。</li>
<li>  <code>erase()</code>: 删除指定位置和数量的字符。</li>
<li>  <code>replace()</code>: 替换指定范围的字符。</li>
<li>  <code>clear()</code>: 清空字符串。</li>
<li>  <code>append()</code>: 等同于 <code>+=</code>。</li>
</ul>
</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // 为了 std::out_of_range</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;Hello C++ World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度和空检查</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Text: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; text.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 16</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is empty? &quot;</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; text.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char (operator[]): &quot;</span> &lt;&lt; text[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 H</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fifth char (at()): &quot;</span> &lt;&lt; text.at(<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 o</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; text.at(20); // 会抛出 std::out_of_range 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">size_t</span> pos_cpp = text.find(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos_cpp != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;C++\&quot; found at index: &quot;</span> &lt;&lt; pos_cpp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;C++\&quot; not found.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> pos_l = text.find(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// 查找第一个 &#x27;l&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First &#x27;l&#x27; found at index: &quot;</span> &lt;&lt; pos_l &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos_last_l = text.rfind(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// 查找最后一个 &#x27;l&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Last &#x27;l&#x27; found at index: &quot;</span> &lt;&lt; pos_last_l &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sub = text.substr(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// 从索引 6 开始，取 3 个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Substring (6, 3): \&quot;&quot;</span> &lt;&lt; sub &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;apply&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\&quot; comes before \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp_result = s1.compare(s2); <span class="comment">// 返回负数，因为 &quot;apple&quot; &lt; &quot;apply&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Compare result: &quot;</span> &lt;&lt; cmp_result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    text.insert(<span class="number">10</span>, <span class="string">&quot; beautiful&quot;</span>); <span class="comment">// 在索引 10 处插入</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insert: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello C++ beautiful World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.erase(<span class="number">6</span>, <span class="number">4</span>); <span class="comment">// 从索引 6 开始，删除 4 个字符 (&quot;C++ &quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After erase: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello beautiful World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.replace(<span class="number">6</span>, <span class="number">9</span>, <span class="string">&quot;gorgeous&quot;</span>); <span class="comment">// 从索引 6 开始，替换 9 个字符 (&quot;beautiful&quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After replace: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello gorgeous World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.clear(); <span class="comment">// 清空字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After clear, is empty? &quot;</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; text.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-4-string类I-O"><a href="#4-3-4-string类I-O" class="headerlink" title="4.3.4 string类I/O"></a>4.3.4 string类I/O</h3><p>可以使用标准的输入输出流对象 <code>cin</code> 和 <code>cout</code> 来方便地读写 <code>string</code> 对象。</p>
<ul>
<li>  <strong>输出 (<code>cout &lt;&lt;</code>):</strong> <code>&lt;&lt;</code> 运算符被重载，可以直接将 <code>string</code> 对象输出到 <code>cout</code>。</li>
<li>  <strong>输入 (<code>cin &gt;&gt;</code>):</strong> <code>&gt;&gt;</code> 运算符被重载，可以从 <code>cin</code> 读取<strong>一个单词</strong>（以空白符——空格、制表符、换行符分隔）到 <code>string</code> 对象中。它会自动跳过开头的空白符，然后在遇到下一个空白符时停止读取。</li>
<li><strong>读取整行 (<code>getline()</code>):</strong> 如果需要读取包含空格的整行文本，应该使用 <code>getline()</code> 函数（这是一个全局函数，不是 <code>string</code> 的成员函数）。<ul>
<li>  <code>getline(cin, str)</code>: 从 <code>cin</code> 读取一行（直到遇到换行符 <code>\n</code>），并将内容（不包括换行符）存储到 <code>string</code> 对象 <code>str</code> 中。</li>
<li>  <code>getline(cin, str, delimiter)</code>: 读取直到遇到指定的 <code>delimiter</code> 字符为止。</li>
</ul>
</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word1, word2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Enter two words:&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入 (cin &gt;&gt; 读取单词)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word1 &gt;&gt; word2; <span class="comment">// 输入 &quot;Hello World&quot; (用空格隔开)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 1: &quot;</span> &lt;&lt; word1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 2: &quot;</span> &lt;&lt; word2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除输入缓冲区中可能残留的换行符 (cin &gt;&gt; 之后通常需要)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">10000</span>, <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入 (getline 读取整行)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a line of text: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line); <span class="comment">// 输入 &quot;This is a test line.&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: \&quot;&quot;</span> &lt;&lt; line &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;This is a test line.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 在混合使用 <code>cin &gt;&gt;</code> 和 <code>getline(cin, ...)</code> 时要特别小心。<code>cin &gt;&gt;</code> 读取单词后，会将换行符留在输入缓冲区中。如果紧接着调用 <code>getline()</code>，它会立即读到这个换行符并认为读取结束，导致得到一个空字符串。通常需要在 <code>cin &gt;&gt;</code> 之后、<code>getline()</code> 之前清除缓冲区中的换行符，例如使用 <code>std::cin.ignore()</code>。</p>
<h3 id="4-3-5-其他形式的字符串字面值"><a href="#4-3-5-其他形式的字符串字面值" class="headerlink" title="4.3.5 其他形式的字符串字面值"></a>4.3.5 其他形式的字符串字面值</h3><p>C++11 引入了新的字符串字面值形式，提供了对不同字符编码（如 Unicode）的更好支持。</p>
<ol>
<li><p><strong>原始字符串字面值 (Raw String Literal):</strong></p>
<ul>
<li>  语法: <code>R&quot;delimiter(raw_characters)delimiter&quot;</code></li>
<li>  <code>delimiter</code> 是一个可选的、最多16个字符的序列（不能包含空格、括号、反斜杠）。</li>
<li>  <code>raw_characters</code> 是字符串内容，其中的反斜杠 <code>\</code> 和引号 <code>&quot;</code> 等特殊字符不会被转义，按原样解释。</li>
<li>  主要用于书写包含大量特殊字符的字符串，如正则表达式、文件路径、HTML/XML代码等，避免大量的反斜杠转义。</li>
<li>  示例: <code>R&quot;(C:\Program Files\)&quot;</code>, <code>R&quot;delimiter(String with &quot;quotes&quot; and \backslashes)delimiter&quot;</code></li>
</ul>
</li>
<li><p><strong>Unicode 字符串字面值:</strong></p>
<ul>
<li>  <code>u8&quot;string&quot;</code>: UTF-8 编码的字符串 (类型是 <code>const char[]</code>，但应存储在 <code>std::string</code> 或处理 UTF-8 的地方)。</li>
<li>  <code>u&quot;string&quot;</code>: UTF-16 编码的字符串 (类型是 <code>const char16_t[]</code>)。</li>
<li>  <code>U&quot;string&quot;</code>: UTF-32 编码的字符串 (类型是 <code>const char32_t[]</code>)。</li>
</ul>
</li>
</ol>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始字符串字面值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path1 = <span class="string">&quot;C:\\Program Files\\My App\\&quot;</span>; <span class="comment">// 需要转义反斜杠</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path2 = <span class="string">R&quot;(C:\Program Files\My App\)&quot;</span>; <span class="comment">// 使用原始字符串，无需转义</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> regex = <span class="string">R&quot;(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,&#125;\b)&quot;</span>; <span class="comment">// 正则表达式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> html = <span class="string">R&quot;delimiter(</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;&lt;title&gt;Raw String&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;&lt;p&gt;&quot;Hello!&quot;&lt;/p&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;)delimiter&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path 1: &quot;</span> &lt;&lt; path1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path 2: &quot;</span> &lt;&lt; path2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Regex: &quot;</span> &lt;&lt; regex &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;HTML:\n&quot;</span> &lt;&lt; html &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unicode 字符串字面值 (主要用于需要特定编码的场景)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* utf8_str = <span class="string">u8&quot;你好，世界&quot;</span>; <span class="comment">// UTF-8 (需要支持 UTF-8 的环境/终端才能正确显示)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char16_t</span>* utf16_str = <span class="string">u&quot;你好，世界&quot;</span>; <span class="comment">// UTF-16</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char32_t</span>* utf32_str = <span class="string">U&quot;你好，世界&quot;</span>; <span class="comment">// UTF-32</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;UTF-8 String (may not display correctly): &quot;</span> &lt;&lt; utf8_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理和打印 UTF-16/32 通常需要专门的库或函数</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; utf16_str; // 不能直接用 cout 打印 char16_t* / char32_t*</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始字符串字面值在处理包含特殊字符的文本时非常方便。Unicode 字符串字面值则为处理国际化文本提供了标准化的基础。</p>
<h2 id="4-4-结构简介"><a href="#4-4-结构简介" class="headerlink" title="4.4 结构简介"></a>4.4 结构简介</h2><p>数组允许我们存储多个<strong>相同类型</strong>的数据。但有时我们需要将<strong>不同类型</strong>的数据组合成一个单一的、有意义的单元。例如，描述一件商品可能需要商品名称（字符串）、数量（整数）和单价（浮点数）。C++ 的<strong>结构 (Structure)</strong> 就提供了这种能力。</p>
<p>结构是一种用户定义的<strong>复合类型</strong>，它允许将多个不同类型的数据项（称为<strong>成员 (member)</strong> 或**字段 (field)**）捆绑在一起，形成一个新的数据类型。</p>
<h3 id="4-4-1-在程序中使用结构"><a href="#4-4-1-在程序中使用结构" class="headerlink" title="4.4.1 在程序中使用结构"></a>4.4.1 在程序中使用结构</h3><p>使用结构通常涉及以下步骤：</p>
<ol>
<li> <strong>定义结构:</strong> 使用 <code>struct</code> 关键字定义一个新的结构类型，并在花括号 <code>&#123;&#125;</code> 内声明其成员。结构定义通常放在 <code>main()</code> 函数之前或单独的头文件中。</li>
<li> <strong>声明结构变量:</strong> 使用定义好的结构类型名来声明变量。</li>
<li> <strong>访问结构成员:</strong> 使用<strong>成员运算符</strong>（点运算符 <code>.</code>) 来访问结构变量的特定成员。</li>
</ol>
<p><strong>结构定义语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructureName</span> &#123;</span></span><br><span class="line">    memberType1 memberName1;</span><br><span class="line">    memberType2 memberName2;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line">&#125;; <span class="comment">// 注意定义末尾的分号</span></span><br></pre></td></tr></table></figure>

<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 为了使用 string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义结构: 描述充气产品的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inflatable</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// 商品名称 (string 类型成员)</span></span><br><span class="line">    <span class="keyword">float</span> volume;     <span class="comment">// 体积 (float 类型成员)</span></span><br><span class="line">    <span class="keyword">double</span> price;     <span class="comment">// 价格 (double 类型成员)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 声明结构变量</span></span><br><span class="line">    Inflatable product1; <span class="comment">// 声明一个 Inflatable 类型的变量 product1</span></span><br><span class="line">    Inflatable product2; <span class="comment">// 声明另一个 Inflatable 类型的变量 product2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 访问并赋值结构成员</span></span><br><span class="line">    product1.name = <span class="string">&quot;Awesome Air Mattress&quot;</span>;</span><br><span class="line">    product1.volume = <span class="number">1.8f</span>;</span><br><span class="line">    product1.price = <span class="number">49.99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以在声明时进行初始化 (C++98/03 风格，需要按顺序)</span></span><br><span class="line">    Inflatable product3 = &#123;<span class="string">&quot;Giant Swan Floatie&quot;</span>, <span class="number">2.5f</span>, <span class="number">79.95</span>&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问并输出成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 1 Name: &quot;</span> &lt;&lt; product1.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 1 Price: $&quot;</span> &lt;&lt; product1.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 3 Name: &quot;</span> &lt;&lt; product3.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 3 Volume: &quot;</span> &lt;&lt; product3.volume &lt;&lt; <span class="string">&quot; cubic meters&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构变量之间可以直接赋值 (成员逐个复制)</span></span><br><span class="line">    product2 = product1; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 2 Name (after assignment): &quot;</span> &lt;&lt; product2.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>struct Inflatable &#123; ... &#125;;</code>: 定义了一个名为 <code>Inflatable</code> 的新类型。</li>
<li>  <code>Inflatable product1;</code>: 创建了一个 <code>Inflatable</code> 类型的变量（对象）。</li>
<li>  <code>product1.name = ...;</code>: 使用点运算符访问 <code>product1</code> 的 <code>name</code> 成员并赋值。</li>
</ul>
<h3 id="4-4-2-C-11结构初始化"><a href="#4-4-2-C-11结构初始化" class="headerlink" title="4.4.2 C++11结构初始化"></a>4.4.2 C++11结构初始化</h3><p>C++11 引入的列表初始化（花括号初始化）也适用于结构体，提供了更灵活、更安全的初始化方式。</p>
<p><strong>特点:</strong></p>
<ol>
<li> <strong>可以省略等号 <code>=</code>:</strong> 与数组类似，可以在初始化时省略等号。</li>
<li> <strong>可以按成员顺序初始化:</strong> <code>StructType var &#123;value1, value2, ...&#125;;</code></li>
<li> <strong>可以初始化部分成员 (C++20 designated initializers):</strong> C++20 允许通过指定成员名进行初始化，可以不按顺序或只初始化部分成员。但在 C++11/14/17 中，通常需要按顺序提供值。</li>
<li> <strong>空花括号初始化:</strong> <code>StructType var &#123;&#125;;</code> 会将所有成员进行<strong>零初始化</strong>（数值类型为0，指针为 <code>nullptr</code>，<code>bool</code> 为 <code>false</code>，类类型会调用默认构造函数）。</li>
<li> <strong>禁止缩窄转换:</strong> 与数组一样，列表初始化不允许可能丢失信息的缩窄转换。</li>
</ol>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++11 列表初始化 (省略等号)</span></span><br><span class="line">    Product item1 &#123; <span class="string">&quot;A123&quot;</span>, <span class="number">50</span>, <span class="number">19.95</span> &#125;; <span class="comment">// 按顺序初始化所有成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略等号，部分初始化 (C++11/14/17 中，未提供的成员会被值初始化/零初始化)</span></span><br><span class="line">    <span class="comment">// 注意：这种部分初始化对于包含 std::string 等类类型成员时，行为依赖于这些类的默认构造函数</span></span><br><span class="line">    <span class="comment">// Product item2 &#123; &quot;B456&quot;, 100 &#125;; // price 会被零初始化为 0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空花括号进行零初始化</span></span><br><span class="line">    Product item3 &#123;&#125;; <span class="comment">// id 为空字符串, quantity 为 0, price 为 0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Item 1 ID: &quot;</span> &lt;&lt; item1.id &lt;&lt; <span class="string">&quot;, Qty: &quot;</span> &lt;&lt; item1.quantity &lt;&lt; <span class="string">&quot;, Price: &quot;</span> &lt;&lt; item1.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Item 2 ID: &quot; &lt;&lt; item2.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item2.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item2.price &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Item 3 ID: \&quot;&quot;</span> &lt;&lt; item3.id &lt;&lt; <span class="string">&quot;\&quot;, Qty: &quot;</span> &lt;&lt; item3.quantity &lt;&lt; <span class="string">&quot;, Price: &quot;</span> &lt;&lt; item3.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止缩窄转换</span></span><br><span class="line">    <span class="comment">// Product item_error &#123; &quot;C789&quot;, 10.5, 25.0 &#125;; // 错误! 10.5 (double) 到 int 是缩窄转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++20 Designated Initializers (如果编译器支持 C++20)</span></span><br><span class="line">    <span class="comment">// Product item4 &#123; .id = &quot;D001&quot;, .price = 99.99 &#125;; // quantity 会被零初始化</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Item 4 ID: &quot; &lt;&lt; item4.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item4.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item4.price &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-3-结构可以将string类作为成员吗"><a href="#4-4-3-结构可以将string类作为成员吗" class="headerlink" title="4.4.3 结构可以将string类作为成员吗"></a>4.4.3 结构可以将string类作为成员吗</h3><p><strong>是的，绝对可以。</strong> 正如在 <code>4.4.1</code> 和 <code>4.4.2</code> 的示例中看到的 (<code>Inflatable</code> 和 <code>Product</code> 结构)，<code>std::string</code> 对象可以像 <code>int</code>、<code>double</code> 或其他任何类型一样作为结构的成员。</p>
<p>这使得结构能够方便地包含文本信息，并利用 <code>string</code> 类提供的所有功能（自动内存管理、拼接、查找等）。</p>
<p><strong>示例回顾:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// string 成员</span></span><br><span class="line">    <span class="keyword">int</span> studentID;</span><br><span class="line">    <span class="keyword">double</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1 &#123; <span class="string">&quot;Alice Wonderland&quot;</span>, <span class="number">12345</span>, <span class="number">3.8</span> &#125;;</span><br><span class="line">    Student s2;</span><br><span class="line">    s2.name = <span class="string">&quot;Bob The Builder&quot;</span>; <span class="comment">// 可以像普通 string 一样操作</span></span><br><span class="line">    s2.studentID = <span class="number">67890</span>;</span><br><span class="line">    s2.gpa = <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1.name &lt;&lt; <span class="string">&quot; has GPA: &quot;</span> &lt;&lt; s1.gpa &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s2.name &lt;&lt; <span class="string">&quot; has ID: &quot;</span> &lt;&lt; s2.studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-4-其他结构属性"><a href="#4-4-4-其他结构属性" class="headerlink" title="4.4.4 其他结构属性"></a>4.4.4 其他结构属性</h3><p>结构在 C++ 中具有一些方便的属性：</p>
<ol>
<li><strong>赋值 (Assignment):</strong> 可以使用赋值运算符 <code>=</code> 将一个结构变量的值赋给同类型的另一个结构变量。这会执行**成员逐一复制 (memberwise copy)**，即将源结构每个成员的值复制到目标结构对应成员中。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">111</span>, <span class="number">3.9</span>&#125;;</span><br><span class="line">Student s2;</span><br><span class="line">s2 = s1; <span class="comment">// s2 的 name, studentID, gpa 都被设置为 s1 的值</span></span><br></pre></td></tr></table></figure></li>
<li><strong>作为函数参数 (Pass by Value):</strong> 可以将结构变量按值传递给函数。函数会收到结构的一个副本，对副本成员的修改不会影响原始结构变量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayStudent</span><span class="params">(Student s)</span> </span>&#123; <span class="comment">// s 是传入结构的一个副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; s.studentID &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; s.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s.name = <span class="string">&quot;Changed&quot;</span>; <span class="comment">// 只修改副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">displayStudent(s1); <span class="comment">// 传递 s1 的副本</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1.name; <span class="comment">// 输出 &quot;Charlie&quot;，未被改变</span></span><br></pre></td></tr></table></figure></li>
<li><strong>作为函数参数 (Pass by Reference/Pointer):</strong> 为了避免复制整个结构的开销，或者需要在函数中修改原始结构，通常按引用或指针传递结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateGPA</span><span class="params">(Student&amp; s, <span class="keyword">double</span> newGPA)</span> </span>&#123; <span class="comment">// 按引用传递，可以修改原始结构</span></span><br><span class="line">    s.gpa = newGPA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printID</span><span class="params">(<span class="keyword">const</span> Student* sPtr)</span> </span>&#123; <span class="comment">// 按指针传递 (const 防止意外修改)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; sPtr-&gt;studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 -&gt; 访问指针指向的结构成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">updateGPA(s1, <span class="number">4.0</span>); <span class="comment">// 修改原始 s1</span></span><br><span class="line">printID(&amp;s1);       <span class="comment">// 传递 s1 的地址</span></span><br></pre></td></tr></table></figure></li>
<li><strong>作为函数返回值:</strong> 函数可以返回一个结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">createStudent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> id, <span class="keyword">double</span> gpa)</span> </span>&#123;</span><br><span class="line">    Student temp;</span><br><span class="line">    temp.name = name;</span><br><span class="line">    temp.studentID = id;</span><br><span class="line">    temp.gpa = gpa;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// 返回一个 Student 结构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Student s3 = createStudent(<span class="string">&quot;David&quot;</span>, <span class="number">222</span>, <span class="number">3.7</span>); </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这些特性使得结构成为组织和传递相关数据的强大工具。</p>
<h3 id="4-4-5-结构数组"><a href="#4-4-5-结构数组" class="headerlink" title="4.4.5 结构数组"></a>4.4.5 结构数组</h3><p>可以创建**结构数组 (Array of Structures)**，即数组的每个元素都是一个结构变量。这对于处理一组具有相同结构的数据非常有用，例如一个班级的学生信息、一个商店的库存列表等。</p>
<p><strong>声明和初始化:</strong></p>
<p>声明结构数组与声明普通数组类似，只是元素类型是结构类型。初始化可以使用嵌套的花括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> studentID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CLASS_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个包含 CLASS_SIZE 个 Student 结构的数组</span></span><br><span class="line">    Student classRoster[CLASS_SIZE]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结构数组 (使用嵌套花括号)</span></span><br><span class="line">    Student graduates[<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">101</span>&#125;, <span class="comment">// 初始化 graduates[0]</span></span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">102</span>&#125;    <span class="comment">// 初始化 graduates[1]</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 列表初始化</span></span><br><span class="line">    Student freshmen[CLASS_SIZE] &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">201</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;David&quot;</span>, <span class="number">202</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">203</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问结构数组中的元素及其成员</span></span><br><span class="line">    classRoster[<span class="number">0</span>].name = <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">    classRoster[<span class="number">0</span>].studentID = <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Graduate 1: &quot;</span> &lt;&lt; graduates[<span class="number">0</span>].name &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; graduates[<span class="number">0</span>].studentID &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Freshman 3 ID: &quot;</span> &lt;&lt; freshmen[<span class="number">2</span>].studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Roster 1 Name: &quot;</span> &lt;&lt; classRoster[<span class="number">0</span>].name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历结构数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nFreshmen List:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLASS_SIZE; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; freshmen[i].name &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; freshmen[i].studentID &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>Student classRoster[CLASS_SIZE];</code>: 声明了一个数组，每个元素都是 <code>Student</code> 结构。</li>
<li>  <code>graduates[0] = &#123;&quot;Alice&quot;, 101&#125;;</code>: 初始化数组的第一个元素（一个 <code>Student</code> 结构）。</li>
<li>  <code>freshmen[i].name</code>: 访问数组 <code>freshmen</code> 中索引为 <code>i</code> 的元素的 <code>name</code> 成员。</li>
</ul>
<h3 id="4-4-6-结构中的位字段"><a href="#4-4-6-结构中的位字段" class="headerlink" title="4.4.6 结构中的位字段"></a>4.4.6 结构中的位字段</h3><p><strong>位字段 (Bit Field)</strong> 是一种特殊的结构成员，它允许你指定成员变量占用的**位数 (bits)**。这主要用于需要精确控制内存布局或与硬件寄存器交互的场景。</p>
<p><strong>语法:</strong></p>
<p>在结构定义中，成员名后面跟一个冒号 <code>:</code> 和一个整数常量，表示该成员占用的位数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegisterFlags</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> readEnable : <span class="number">1</span>; <span class="comment">// 占用 1 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> writeEnable : <span class="number">1</span>; <span class="comment">// 占用 1 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mode : <span class="number">2</span>;       <span class="comment">// 占用 2 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> reserved : <span class="number">4</span>;   <span class="comment">// 占用 4 位 (通常用于填充或对齐)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>特点和注意事项:</strong></p>
<ul>
<li>  <strong>类型:</strong> 位字段的类型通常是 <code>unsigned int</code> 或 <code>signed int</code>（或 <code>int</code>，其符号性取决于实现），也可以是 <code>bool</code> (C++11，等效于 <code>: 1</code>)。</li>
<li>  <strong>内存节省:</strong> 当多个标志或小范围数值需要存储时，位字段可以显著节省内存，将它们打包到单个整数或几个字节中。</li>
<li>  <strong>硬件接口:</strong> 常用于映射硬件设备寄存器的特定位。</li>
<li>  <strong>访问:</strong> 像普通结构成员一样使用点运算符访问，但不能获取位字段的地址（<code>&amp;</code> 运算符不能用于位字段）。</li>
<li>  <strong>可移植性:</strong> 位字段的内存布局（位的排列顺序、跨字节边界的处理）可能因编译器和平台而异，因此在需要跨平台兼容性的代码中应谨慎使用。</li>
<li>  <strong>大小限制:</strong> 位数不能超过其基础类型的位数（例如，<code>unsigned int</code> 的位字段不能超过 <code>int</code> 的位数）。</li>
<li>  <strong>匿名位字段:</strong> 可以使用未命名的位字段来填充或对齐，例如 <code>unsigned int : 2;</code>。</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设用于控制某个设备的状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceStatus</span> &#123;</span></span><br><span class="line">    <span class="comment">// 打包到单个字节 (假设 unsigned int 至少 8 位)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> powerOn : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> errorFlag : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> channel : <span class="number">3</span>; <span class="comment">// 可以表示 0-7</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> : <span class="number">3</span>;       <span class="comment">// 填充未使用的 3 位，使总共 8 位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeviceStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置位字段的值</span></span><br><span class="line">    status.powerOn = <span class="number">1</span>;    <span class="comment">// 设备开机</span></span><br><span class="line">    status.errorFlag = <span class="number">0</span>; <span class="comment">// 无错误</span></span><br><span class="line">    status.channel = <span class="number">5</span>;   <span class="comment">// 设置通道为 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取位字段的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Device Status:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Power On: &quot;</span> &lt;&lt; status.powerOn &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Error Flag: &quot;</span> &lt;&lt; status.errorFlag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Channel: &quot;</span> &lt;&lt; status.channel &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位字段通常打包存储</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of DeviceStatus struct: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(DeviceStatus) &lt;&lt; <span class="string">&quot; byte(s)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出通常是 1 或 4 (取决于编译器如何对齐和打包，以及 int 的大小)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查特定标志</span></span><br><span class="line">    <span class="keyword">if</span> (status.powerOn) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Device is powered on.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能获取位字段地址</span></span><br><span class="line">    <span class="comment">// unsigned int* pPower = &amp;status.powerOn; // 错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位字段是一种底层工具，适用于特定场景，但在常规应用程序开发中不常用。</p>
<h2 id="4-5-共用体"><a href="#4-5-共用体" class="headerlink" title="4.5 共用体"></a>4.5 共用体</h2><p><strong>共用体 (Union)</strong> 是一种特殊的数据结构，它也允许在一个结构中存储不同的数据类型，但与结构体 (struct) 不同的是，共用体的<strong>所有成员共享同一块内存空间</strong>。</p>
<p><strong>核心特点:</strong></p>
<ul>
<li>  <strong>内存共享:</strong> 共用体的大小由其<strong>最大</strong>的成员的大小决定。所有成员都从相同的内存地址开始存储。</li>
<li>  <strong>同一时间只有一个成员有效:</strong> 在任何时刻，你只能有效地存储和使用共用体中的<strong>一个</strong>成员的值。当你给一个成员赋值时，可能会覆盖掉其他成员的数据。</li>
<li>  <strong>节省内存:</strong> 当你需要存储多种类型的数据，但知道在任何时候只需要用到其中一种时，共用体可以节省内存，因为它只需要分配足够容纳最大成员的空间。</li>
</ul>
<p><strong>定义共用体:</strong></p>
<p>使用 <code>union</code> 关键字定义，语法与 <code>struct</code> 类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UnionName</span> &#123;</span></span><br><span class="line">    memberType1 memberName1;</span><br><span class="line">    memberType2 memberName2;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line">&#125;; <span class="comment">// 注意定义末尾的分号</span></span><br></pre></td></tr></table></figure>

<p><strong>访问成员:</strong></p>
<p>与结构体一样，使用<strong>成员运算符</strong>（点运算符 <code>.</code>) 来访问共用体变量的成员。</p>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个共用体，可以存储 int, long 或 double</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DataValue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i_val;</span><br><span class="line">    <span class="keyword">long</span> l_val;</span><br><span class="line">    <span class="keyword">double</span> d_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataValue data; <span class="comment">// 声明一个 DataValue 共用体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of DataValue union: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(DataValue) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出的大小通常等于 sizeof(double)，因为它是最大的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 int 成员</span></span><br><span class="line">    data.i_val = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as int: &quot;</span> &lt;&lt; data.i_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 此时访问 l_val 或 d_val 的结果是未定义的/无意义的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 double 成员 (会覆盖之前的 int 值)</span></span><br><span class="line">    data.d_val = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as double: &quot;</span> &lt;&lt; data.d_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 此时访问 i_val 或 l_val 的结果是未定义的/无意义的</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Reading i_val after storing double: &quot; &lt;&lt; data.i_val &lt;&lt; std::endl; // 结果不可靠</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 long 成员 (会覆盖之前的 double 值)</span></span><br><span class="line">    data.l_val = <span class="number">1234567890L</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as long: &quot;</span> &lt;&lt; data.l_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 追踪当前有效成员 ---</span></span><br><span class="line">    <span class="comment">// 通常需要一个额外的变量来记录当前哪个成员是有效的</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> &#123;</span> INT, LONG, DOUBLE &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DataPacket</span> &#123;</span></span><br><span class="line">        DataType type; <span class="comment">// 记录当前存储的数据类型</span></span><br><span class="line">        DataValue value; <span class="comment">// 共用体存储实际值</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    DataPacket packet;</span><br><span class="line">    packet.type = INT;</span><br><span class="line">    packet.value.i_val = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型访问</span></span><br><span class="line">    <span class="keyword">if</span> (packet.type == INT) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Packet contains int: &quot;</span> &lt;&lt; packet.value.i_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ... 其他类型的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要:</strong> 程序员有责任跟踪共用体中当前哪个成员是活动的（有效的）。读取非活动成员的值会导致未定义行为或得到无意义的数据。通常会结合一个枚举类型或整数标志来指示当前存储的数据类型，如 <code>DataPacket</code> 示例所示。</p>
<p><strong>匿名共用体 (Anonymous Union):</strong></p>
<p>共用体可以不带名称直接定义在结构体或类内部（或函数局部作用域）。匿名共用体的成员可以直接通过结构/类变量访问，就像它们是结构/类的直接成员一样。匿名共用体的所有成员仍然共享相同的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> type; <span class="comment">// &#x27;I&#x27; for integer, &#x27;F&#x27; for float</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="comment">// 匿名共用体</span></span><br><span class="line">        <span class="keyword">int</span> intVal;</span><br><span class="line">        <span class="keyword">float</span> floatVal;</span><br><span class="line">    &#125;; <span class="comment">// 注意这里没有变量名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.type = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    w.intVal = <span class="number">123</span>; <span class="comment">// 直接访问匿名共用体的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w.type == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Widget value (int): &quot;</span> &lt;&lt; w.intVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.type == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// w.floatVal = 3.14f; // 如果要存 float</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Widget value (float): &quot; &lt;&lt; w.floatVal &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of Widget: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Widget) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 大小通常是 char 的大小 + 最大成员(int 或 float)的大小 + 可能的对齐填充</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景:</strong></p>
<ul>
<li>  <strong>节省内存:</strong> 当数据项有多种可能类型，但一次只使用一种时。</li>
<li>  <strong>类型双关 (Type Punning):</strong> 以不同的类型解释同一块内存区域（例如，将一个 <code>float</code> 的位模式解释为一个 <code>int</code>）。这是一种低级技巧，通常不可移植且可能违反 C++ 的严格别名规则 (strict aliasing rules)，应谨慎使用或避免。</li>
</ul>
<p><strong>与结构的比较:</strong></p>
<ul>
<li>  <strong>内存:</strong> 结构的所有成员都有自己独立的内存地址；共用体的所有成员共享起始地址。</li>
<li>  <strong>大小:</strong> 结构的大小约等于其所有成员大小之和（加上可能的对齐填充）；共用体的大小等于其最大成员的大小。</li>
<li>  <strong>有效性:</strong> 结构的所有成员可以同时有效；共用体只有一个成员能同时有效。</li>
</ul>
<p><strong>C++11 及以后的共用体:</strong></p>
<p>C++11 放宽了对共用体成员类型的限制，允许包含具有非平凡构造函数、析构函数或赋值运算符的类类型成员（如 <code>std::string</code>）。但是，如果共用体包含这样的成员，编译器<strong>不会</strong>自动生成默认的构造函数、析构函数或复制/移动操作。程序员必须<strong>手动管理</strong>这些成员的生命周期（例如，使用 placement new 在共用体内存上构造对象，并在不再需要时显式调用析构函数）。这使得包含复杂类型的共用体使用起来更加复杂和易错。对于只包含 POD (Plain Old Data) 类型（如 <code>int</code>, <code>float</code>, 指针, C 风格数组/结构）的共用体，其行为与 C 语言中类似。</p>
<h2 id="4-6-枚举"><a href="#4-6-枚举" class="headerlink" title="4.6 枚举"></a>4.6 枚举</h2><p>C++ 的 <code>enum</code> 工具提供了一种创建<strong>符号常量 (Symbolic Constant)</strong> 的方式，常用于定义一组相关的、具有名称的整数常量。这比使用 <code>const int</code> 或 <code>#define</code> 来定义一组相关常量更方便、更具可读性。</p>
<p><strong>基本概念:</strong></p>
<ul>
<li>  <strong>枚举类型 (Enumeration Type):</strong> <code>enum</code> 关键字用于创建一个新的用户定义的整数类型。</li>
<li>  <strong>枚举量 (Enumerator):</strong> 在枚举类型定义中列出的标识符。它们是具名的常量，代表整数值。</li>
</ul>
<p><strong>定义枚举:</strong></p>
<p>使用 <code>enum</code> 关键字，后跟枚举类型的名称，然后在花括号 <code>&#123;&#125;</code> 内列出枚举量，用逗号分隔。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理:</strong></p>
<ol>
<li> <strong>创建新类型:</strong> 上述语句创建了一个名为 <code>spectrum</code> 的新类型。</li>
<li> <strong>定义枚举量:</strong> <code>red</code>, <code>orange</code>, <code>yellow</code> 等成为 <code>spectrum</code> 类型的符号常量。</li>
<li><strong>自动赋值:</strong> 默认情况下，编译器将整数值赋给枚举量，从 0 开始，依次递增 1。<ul>
<li>  <code>red</code> 值为 0</li>
<li>  <code>orange</code> 值为 1</li>
<li>  <code>yellow</code> 值为 2</li>
<li>  …</li>
<li>  <code>ultraviolet</code> 值为 7</li>
</ul>
</li>
</ol>
<p><strong>声明和使用枚举变量:</strong></p>
<p>可以像使用其他类型一样声明枚举类型的变量。枚举变量通常只能被赋予该枚举类型中定义的枚举量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    spectrum band; <span class="comment">// 声明一个 spectrum 类型的变量 band</span></span><br><span class="line"></span><br><span class="line">    band = blue; <span class="comment">// 将枚举量 blue 赋给 band (合法)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current band (enum value): &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 blue 对应的整数值 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// band = 2000; // 错误! 不能直接将整数赋给枚举变量 (类型不匹配)</span></span><br><span class="line">    <span class="comment">// band = red + orange; // 错误! + 运算符未对枚举类型定义 (虽然 red 和 orange 有整数值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以将枚举量赋给 int 变量 (枚举量会自动提升为 int)</span></span><br><span class="line">    <span class="keyword">int</span> colorCode = green; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Color code for green: &quot;</span> &lt;&lt; colorCode &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以强制将 int 转换为枚举类型 (需要显式转换，且需谨慎)</span></span><br><span class="line">    band = <span class="keyword">static_cast</span>&lt;spectrum&gt;(<span class="number">3</span>); <span class="comment">// 将 3 转换为 spectrum 类型 (对应 green)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Band after cast: &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="keyword">if</span> (band == green) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The band is green.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在循环中使用 (需要注意类型转换和范围)</span></span><br><span class="line">    <span class="keyword">for</span> (band = red; band &lt;= ultraviolet; band = <span class="keyword">static_cast</span>&lt;spectrum&gt;(band + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing band: &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举的优点:</strong></p>
<ul>
<li>  <strong>提高可读性:</strong> 使用有意义的名称（如 <code>red</code>, <code>blue</code>）代替神秘的数字（0, 4）。</li>
<li>  <strong>类型安全:</strong> 枚举创建了新的类型，有助于防止将不相关的整数值赋给枚举变量（虽然可以通过强制转换绕过）。</li>
<li>  <strong>代码维护:</strong> 如果需要更改某个常量的值或添加新常量，只需修改枚举定义。</li>
</ul>
<h3 id="4-6-1-设置枚举量的值"><a href="#4-6-1-设置枚举量的值" class="headerlink" title="4.6.1 设置枚举量的值"></a>4.6.1 设置枚举量的值</h3><p>可以显式地为枚举量指定整数值。</p>
<p><strong>规则:</strong></p>
<ul>
<li>  使用赋值运算符 <code>=</code> 为枚举量指定值。</li>
<li>  未被显式赋值的枚举量的值将基于<strong>前一个</strong>枚举量的值加 1。</li>
<li>  第一个枚举量如果未显式赋值，默认为 0。</li>
<li>  不同的枚举量可以具有相同的值。</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BitField</span> &#123;</span></span><br><span class="line">    BIT_ZERO,       <span class="comment">// 默认值为 0</span></span><br><span class="line">    BIT_ONE,        <span class="comment">// 默认值为 1</span></span><br><span class="line">    BIT_TWO = <span class="number">4</span>,    <span class="comment">// 显式赋值为 4</span></span><br><span class="line">    BIT_THREE,      <span class="comment">// 值为 BIT_TWO + 1 = 5</span></span><br><span class="line">    BIT_FOUR = <span class="number">8</span>,   <span class="comment">// 显式赋值为 8</span></span><br><span class="line">    BIT_FIVE = <span class="number">8</span>,   <span class="comment">// 显式赋值为 8 (与 BIT_FOUR 相同)</span></span><br><span class="line">    BIT_SIX,        <span class="comment">// 值为 BIT_FIVE + 1 = 9</span></span><br><span class="line">    BIT_SEVEN = BIT_THREE + BIT_FOUR <span class="comment">// 值为 5 + 8 = 13</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_ZERO: &quot;</span> &lt;&lt; BIT_ZERO &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_ONE: &quot;</span> &lt;&lt; BIT_ONE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_TWO: &quot;</span> &lt;&lt; BIT_TWO &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_THREE: &quot;</span> &lt;&lt; BIT_THREE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_FOUR: &quot;</span> &lt;&lt; BIT_FOUR &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_FIVE: &quot;</span> &lt;&lt; BIT_FIVE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_SIX: &quot;</span> &lt;&lt; BIT_SIX &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_SEVEN: &quot;</span> &lt;&lt; BIT_SEVEN &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">    BitField flags = BIT_THREE;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Flags: &quot;</span> &lt;&lt; flags &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-2-枚举的取值范围"><a href="#4-6-2-枚举的取值范围" class="headerlink" title="4.6.2 枚举的取值范围"></a>4.6.2 枚举的取值范围</h3><p>虽然枚举量是 <code>int</code> 类型的常量，但枚举类型本身 (<code>spectrum</code>, <code>BitField</code> 等) 的取值范围并不一定等同于 <code>int</code>。</p>
<p><strong>C++98/03 标准:</strong></p>
<ul>
<li>  <strong>底层类型 (Underlying Type):</strong> 编译器会选择一种能够容纳所有枚举量值的<strong>整型</strong>作为该枚举的底层类型。这个类型至少要和 <code>int</code> 一样大，但如果所有枚举量的值可以用更小的类型（如 <code>char</code> 或 <code>short</code>）表示，编译器<strong>可能</strong>会选择更小的类型来节省内存。</li>
<li><strong>取值范围:</strong> 枚举变量理论上可以存储的值的范围由其底层类型决定。然而，C++ 标准对枚举变量可以<strong>合法持有</strong>的值有更严格的规定。一个枚举变量可以持有的值，其上限是大于最大枚举量值的最小的 2 的幂减 1，下限类似（如果存在负枚举量值，则为小于最小枚举量值的最大的 2 的幂加 1；如果枚举量都非负，则下限为 0）。<ul>
<li>  例如，对于 <code>enum spectrum &#123;red=0, ..., ultraviolet=7&#125;</code>，最大枚举量是 7。大于 7 的最小的 2 的幂是 8，所以上限是 8 - 1 = 7。下限是 0。因此，<code>spectrum</code> 变量理论上可以持有 0 到 7 范围内的值。</li>
<li>  对于 <code>enum BitField &#123;..., BIT_SEVEN=13&#125;</code>，最大枚举量是 13。大于 13 的最小的 2 的幂是 16，上限是 16 - 1 = 15。下限是 0。<code>BitField</code> 变量理论上可以持有 0 到 15 范围内的值。</li>
</ul>
</li>
<li>  <strong>赋值限制:</strong> 尽管范围可能比枚举量的值域宽，但 C++ 通常不允许直接将超出枚举量定义范围的整数值赋给枚举变量（即使该整数在理论范围内），需要显式类型转换。</li>
</ul>
<p><strong>C++11 作用域内枚举 (Scoped Enumeration):</strong></p>
<p>C++11 引入了 <code>enum class</code> (或 <code>enum struct</code>)，称为<strong>作用域内枚举</strong>，提供了更强的类型安全和作用域控制：</p>
<ul>
<li>  <strong>强类型:</strong> <code>enum class</code> 的枚举量不会隐式转换为整数。</li>
<li>  <strong>作用域:</strong> 枚举量的名称被限制在枚举类型的作用域内，访问时需要使用 <code>EnumType::Enumerator</code>。</li>
<li>  <strong>可指定底层类型:</strong> 可以显式指定底层整数类型，例如 <code>enum class Color : unsigned char &#123; Red, Green, Blue &#125;;</code>。</li>
<li>  <strong>无隐式转换:</strong> 不能将整数直接赋给 <code>enum class</code> 变量，也不能将 <code>enum class</code> 变量隐式转换为整数，都需要显式转换 (<code>static_cast</code>)。</li>
</ul>
<p><strong>用法与示例 (范围和 C++11):</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OldEnum</span> &#123;</span> A = <span class="number">1</span>, B = <span class="number">2</span>, C = <span class="number">4</span> &#125;; <span class="comment">// 最大值 4, 范围可能是 0-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 作用域内枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">NewEnum</span> &#123;</span> X = <span class="number">10</span>, Y = <span class="number">20</span>, Z = <span class="number">30</span> &#125;; </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span> :</span> <span class="keyword">char</span> &#123; OK = <span class="string">&#x27;O&#x27;</span>, Error = <span class="string">&#x27;E&#x27;</span>, Pending = <span class="string">&#x27;P&#x27;</span> &#125;; <span class="comment">// 指定底层类型为 char</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OldEnum oe;</span><br><span class="line">    <span class="comment">// oe = 7; // 编译错误 (通常不允许直接赋 int)</span></span><br><span class="line">    oe = <span class="keyword">static_cast</span>&lt;OldEnum&gt;(<span class="number">7</span>); <span class="comment">// 合法 (因为 7 在理论范围 0-7 内)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OldEnum value: &quot;</span> &lt;&lt; oe &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// oe = static_cast&lt;OldEnum&gt;(8); // 行为未定义或可能编译错误 (超出理论范围)</span></span><br><span class="line"></span><br><span class="line">    NewEnum ne = NewEnum::Y; <span class="comment">// 必须使用作用域解析符</span></span><br><span class="line">    <span class="comment">// int ne_val = ne; // 错误! 不能隐式转换为 int</span></span><br><span class="line">    <span class="keyword">int</span> ne_val = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ne); <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NewEnum value as int: &quot;</span> &lt;&lt; ne_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ne = 20; // 错误! 不能将 int 赋给 enum class</span></span><br><span class="line">    ne = <span class="keyword">static_cast</span>&lt;NewEnum&gt;(<span class="number">10</span>); <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NewEnum value after cast: &quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ne) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    Status s = Status::OK;</span><br><span class="line">    <span class="keyword">char</span> s_char = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(s); <span class="comment">// 转换为底层类型 char</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Status as char: &quot;</span> &lt;&lt; s_char &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 O</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong><br>传统的 <code>enum</code> 提供了一种创建命名常量的方式，但类型安全较弱，且枚举量会污染所在的作用域。C++11 的 <code>enum class</code> 提供了更强的类型安全和作用域控制，是现代 C++ 中更推荐的选择。在使用传统 <code>enum</code> 时，要注意其取值范围和与整数类型转换的规则。</p>
<h2 id="4-7-指针和自由存储空间"><a href="#4-7-指针和自由存储空间" class="headerlink" title="4.7 指针和自由存储空间"></a>4.7 指针和自由存储空间</h2><p>到目前为止，我们创建的变量（包括数组、结构等）在声明时，编译器会为其分配内存。这些变量的内存管理是自动的（自动存储或静态存储）。但是，有时我们需要在程序运行时根据需要动态地分配和释放内存。<strong>指针 (Pointer)</strong> 和 <strong>自由存储空间 (Free Store)**（也常称为</strong>堆 Heap**）是实现这一目标的关键。</p>
<p><strong>指针</strong>是一种特殊的变量，它存储的是另一个变量的<strong>内存地址</strong>。通过指针，我们可以间接地访问和修改该内存地址处的数据。</p>
<p><strong>自由存储空间</strong>是程序可以动态申请使用的内存区域。与自动变量（函数执行完就销毁）或静态变量（程序整个生命周期都存在）不同，程序员需要手动管理自由存储空间中分配的内存的生命周期。</p>
<h3 id="4-7-1-声明和初始化指针"><a href="#4-7-1-声明和初始化指针" class="headerlink" title="4.7.1 声明和初始化指针"></a>4.7.1 声明和初始化指针</h3><p><strong>声明指针:</strong></p>
<p>声明指针需要指定它将指向的数据类型，并在变量名前加上星号 <code>*</code>（星号可以靠近类型名、变量名或在两者之间）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointerName; </span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>typeName</code>: 指针将要指向的数据的类型。</li>
<li>  <code>*</code>: 表明 <code>pointerName</code> 是一个指针。</li>
<li>  <code>pointerName</code>: 指针变量的名称。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_int;      <span class="comment">// 声明一个指向 int 类型的指针 p_int</span></span><br><span class="line"><span class="keyword">double</span> * p_double; <span class="comment">// 声明一个指向 double 类型的指针 p_double</span></span><br><span class="line"><span class="keyword">char</span> * p_char;    <span class="comment">// 声明一个指向 char 类型的指针 p_char</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> * p_str; <span class="comment">// 声明一个指向 string 对象的指针 p_str</span></span><br></pre></td></tr></table></figure>

<p><strong>获取地址 (<code>&amp;</code> 运算符):</strong></p>
<p>地址运算符 <code>&amp;</code> 用于获取一个变量的内存地址。</p>
<p><strong>初始化指针:</strong></p>
<p>指针在声明时应被初始化，以避免指向不确定的内存地址。常见的初始化方式：</p>
<ol>
<li> <strong>初始化为 <code>nullptr</code> (C++11 及以后):</strong> <code>nullptr</code> 是表示空指针的关键字，表示该指针当前不指向任何有效的内存地址。这是推荐的初始化空指针的方式。</li>
<li> <strong>初始化为 <code>0</code> 或 <code>NULL</code>:</strong> 在 C++11 之前，通常使用 <code>0</code> 或宏 <code>NULL</code> (通常定义为 0) 来表示空指针。虽然仍可用，但 <code>nullptr</code> 类型更安全。</li>
<li> <strong>初始化为变量地址:</strong> 使用 <code>&amp;</code> 运算符获取一个已存在变量的地址来初始化指针。<strong>指针的类型必须与变量的类型匹配</strong>（或能隐式转换）。</li>
</ol>
<p><strong>解引用 (<code>*</code> 运算符):</strong></p>
<p>解引用运算符 <code>*</code> 用于访问指针所指向的内存地址处存储的值。当 <code>*</code> 用于已初始化的有效指针变量前时，它表示“获取指针指向的值”。</p>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> updates = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_updates; <span class="comment">// 声明一个指向 int 的指针，未初始化 (危险!)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化指针</span></span><br><span class="line">    <span class="keyword">int</span> * p_value = <span class="literal">nullptr</span>; <span class="comment">// 初始化为空指针 (推荐)</span></span><br><span class="line">    <span class="keyword">int</span> * p_zero = <span class="number">0</span>;      <span class="comment">// 初始化为空指针 (旧式)</span></span><br><span class="line">    <span class="comment">// NULL 宏通常在 &lt;cstddef&gt; 或其他 C 头文件中定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用地址初始化</span></span><br><span class="line">    p_updates = &amp;updates; <span class="comment">// 将 updates 变量的地址赋给 p_updates</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问指针信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of updates: &quot;</span> &lt;&lt; updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;             <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of updates: &quot;</span> &lt;&lt; &amp;updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;          <span class="comment">// 输出 updates 的内存地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of p_updates (address): &quot;</span> &lt;&lt; p_updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出存储在 p_updates 中的地址 (同上)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解引用运算符访问指针指向的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *p_updates: &quot;</span> &lt;&lt; *p_updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6 (updates 的值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解引用运算符修改指针指向的值</span></span><br><span class="line">    *p_updates = *p_updates + <span class="number">1</span>; <span class="comment">// 将 p_updates 指向的值 (updates) 加 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now updates has value: &quot;</span> &lt;&lt; updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向其他类型</span></span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line">    <span class="keyword">double</span> * p_price = &amp;price; <span class="comment">// p_price 指向 price</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *p_price: &quot;</span> &lt;&lt; *p_price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 99.99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int * p_wrong = &amp;price; // 错误! 指针类型 (int*) 与变量类型 (double) 不匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点:</strong></p>
<ul>
<li>  <code>int updates;</code>: <code>updates</code> 是一个 <code>int</code> 变量。</li>
<li>  <code>int * p_updates;</code>: <code>p_updates</code> 是一个指针变量，它存储的是一个 <code>int</code> 变量的地址。</li>
<li>  <code>p_updates</code>: 存储的地址值。</li>
<li>  <code>*p_updates</code>: 存储在该地址处的 <code>int</code> 值。</li>
</ul>
<h3 id="4-7-2-指针的危险"><a href="#4-7-2-指针的危险" class="headerlink" title="4.7.2 指针的危险"></a>4.7.2 指针的危险</h3><p>指针非常强大，但也容易出错，是 C++ 中常见的 bug 来源。</p>
<ol>
<li><strong>解引用未初始化的指针:</strong> 如果指针没有被初始化，它会包含一个随机的地址（垃圾值）。解引用这种指针（试图访问该随机地址处的值）会导致<strong>未定义行为</strong>，通常导致程序崩溃。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_uninitialized;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_uninitialized; // 极度危险! 程序可能崩溃</span></span><br><span class="line"><span class="comment">// *p_uninitialized = 100;      // 极度危险! 可能覆盖关键数据或导致崩溃</span></span><br></pre></td></tr></table></figure></li>
<li><strong>解引用空指针:</strong> 解引用 <code>nullptr</code> (或 <code>0</code>, <code>NULL</code>) 同样是未定义行为，通常也会导致程序崩溃。在使用指针前，最好检查它是否为空。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_null; // 危险! 程序可能崩溃</span></span><br><span class="line"><span class="keyword">if</span> (p_null != <span class="literal">nullptr</span>) &#123; <span class="comment">// 检查指针是否有效</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p_null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>悬挂指针 (Dangling Pointer):</strong> 当指针指向的内存已经被释放或不再有效时，该指针就成为悬挂指针。解引用悬挂指针也是未定义行为。这通常发生在 <code>delete</code> 之后（见 4.7.5）或指向局部变量的指针在其作用域结束后仍然存在时。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_dangle;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> local_var = <span class="number">10</span>;</span><br><span class="line">    p_dangle = &amp;local_var; <span class="comment">// p_dangle 指向局部变量</span></span><br><span class="line">&#125; <span class="comment">// local_var 在这里被销毁，内存可能被回收</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_dangle; // 危险! p_dangle 是悬挂指针</span></span><br></pre></td></tr></table></figure></li>
<li> <strong>内存泄漏 (Memory Leak):</strong> 如果使用 <code>new</code> 分配了内存（见 4.7.4），但忘记使用 <code>delete</code> 释放，或者丢失了指向该内存的唯一指针，这块内存就无法再被程序访问或释放，造成内存泄漏。程序运行时间越长，泄漏的内存越多，最终可能耗尽系统资源。</li>
</ol>
<p><strong>安全使用指针的建议:</strong></p>
<ul>
<li>  <strong>总是初始化指针:</strong> 声明指针时立即初始化为 <code>nullptr</code> 或一个有效的地址。</li>
<li>  <strong>在使用前检查:</strong> 在解引用指针前，检查它是否为 <code>nullptr</code>。</li>
<li>  <strong>谨慎处理指针生命周期:</strong> 确保指针指向的内存在指针使用期间是有效的。</li>
<li>  <strong>配对 <code>new</code> 和 <code>delete</code>:</strong> 动态分配的内存必须手动释放。</li>
</ul>
<h3 id="4-7-3-指针和数字"><a href="#4-7-3-指针和数字" class="headerlink" title="4.7.3 指针和数字"></a>4.7.3 指针和数字</h3><p>虽然指针存储的是内存地址，而地址本质上是数字，但<strong>指针类型和整数类型是不同的</strong>。不能随意将整数赋给指针（除了 <code>0</code>/<code>nullptr</code>），也不能直接将指针当作普通整数进行算术运算（指针算术有特殊规则，见 4.8）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_value = &amp;value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针的值是地址 (一个数字)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address stored in p_value: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能直接将任意整数赋给指针</span></span><br><span class="line">    <span class="comment">// p_value = 1000; // 错误! 类型不匹配 (除非使用 reinterpret_cast，但通常不安全)</span></span><br><span class="line">    </span><br><span class="line">    p_value = <span class="literal">nullptr</span>; <span class="comment">// 合法，赋空指针</span></span><br><span class="line">    p_value = <span class="number">0</span>;       <span class="comment">// 合法，赋空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针可以转换为整数 (通常使用 reinterpret_cast，不推荐)</span></span><br><span class="line">    <span class="comment">// uintptr_t address_as_int = reinterpret_cast&lt;uintptr_t&gt;(p_value); </span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Address as integer: &quot; &lt;&lt; address_as_int &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数不能直接转换为指针 (除了 0)</span></span><br><span class="line">    <span class="keyword">int</span> address_int = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// int * p_from_int = address_int; // 错误!</span></span><br><span class="line">    <span class="comment">// int * p_from_int = reinterpret_cast&lt;int*&gt;(address_int); // 可以编译，但极度危险</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将指针视为地址，而不是普通的数字，有助于避免类型错误和不安全的操作。</p>
<h3 id="4-7-4-使用new来分配内存"><a href="#4-7-4-使用new来分配内存" class="headerlink" title="4.7.4 使用new来分配内存"></a>4.7.4 使用new来分配内存</h3><p><code>new</code> 运算符用于在程序的<strong>自由存储区 (Free Store)</strong> 或 <strong>堆 (Heap)</strong> 上动态分配内存。这允许你在运行时根据需要创建变量或对象，而不是在编译时就确定。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pointerVariable = <span class="keyword">new</span> typeName;</span><br><span class="line"><span class="comment">// 或者在声明时分配</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName;</span><br><span class="line"><span class="comment">// 也可以带初始化器</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName (initializer); <span class="comment">// C++98/03</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName &#123;initializer&#125;; <span class="comment">// C++11 列表初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>new</code>: 运算符。</li>
<li>  <code>typeName</code>: 要分配内存的数据类型。</li>
<li>  <code>initializer</code> (可选): 用于初始化新分配内存的值。</li>
</ul>
<p><strong>工作流程:</strong></p>
<ol>
<li> <code>new</code> 在自由存储区找到一块足够大的、未使用的内存块，以存储 <code>typeName</code> 类型的数据。</li>
<li> <code>new</code> 返回这块内存的<strong>起始地址</strong>。</li>
<li> 这个地址被赋给一个相应类型的指针变量。</li>
</ol>
<p><strong>如果 <code>new</code> 无法分配所需的内存（例如内存不足），它会抛出一个 <code>std::bad_alloc</code> 异常</strong>（除非使用了 <code>new (std::nothrow)</code> 版本，该版本在失败时返回 <code>nullptr</code>）。</p>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt; // 为了 std::bad_alloc (虽然不一定需要显式包含) 和 std::nothrow</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配一个 int 的内存</span></span><br><span class="line">    <span class="keyword">int</span> * p_int = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 在自由存储区分配一个 int 大小的内存</span></span><br><span class="line">    <span class="keyword">if</span> (p_int == <span class="literal">nullptr</span>) &#123; <span class="comment">// 理论检查 (对于普通 new，失败会抛异常)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p_int = <span class="number">101</span>; <span class="comment">// 通过指针访问并赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个 double 并初始化</span></span><br><span class="line">    <span class="keyword">double</span> * p_double = <span class="keyword">new</span> <span class="keyword">double</span> (<span class="number">99.99</span>); <span class="comment">// 分配并初始化为 99.99</span></span><br><span class="line">    <span class="comment">// 或者 C++11 列表初始化</span></span><br><span class="line">    <span class="comment">// double * p_double = new double &#123;99.99&#125;; </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically allocated int: &quot;</span> &lt;&lt; *p_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically allocated double: &quot;</span> &lt;&lt; *p_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of int: &quot;</span> &lt;&lt; p_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of double: &quot;</span> &lt;&lt; p_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 内存释放将在下一节讲解 ---</span></span><br><span class="line">    <span class="comment">// delete p_int; </span></span><br><span class="line">    <span class="comment">// delete p_double;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 nothrow 版本 (失败时返回 nullptr)</span></span><br><span class="line">    <span class="keyword">int</span> * p_lots_of_ints = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>[<span class="number">1000000000</span>]; <span class="comment">// 尝试分配巨大数组</span></span><br><span class="line">    <span class="keyword">if</span> (p_lots_of_ints == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huge memory allocation failed, but program continues.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huge memory allocation succeeded (unlikely).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// delete[] p_lots_of_ints; // 如果成功，需要释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态分配的内存<strong>不会</strong>像自动变量那样在作用域结束时自动释放。程序员必须负责在不再需要时手动释放它。</p>
<h3 id="4-7-5-使用delete释放内存"><a href="#4-7-5-使用delete释放内存" class="headerlink" title="4.7.5 使用delete释放内存"></a>4.7.5 使用delete释放内存</h3><p><code>delete</code> 运算符用于释放由 <code>new</code> 分配的内存，将其归还给自由存储区，以便后续可以重新分配使用。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointerVariable; </span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>delete</code>: 运算符。</li>
<li>  <code>pointerVariable</code>: 指向由 <code>new</code>（**不是 <code>new[]</code>**）分配的内存的指针。</li>
</ul>
<p><strong>工作流程:</strong></p>
<ol>
<li> <code>delete</code> 接收一个指针，该指针必须指向由 <code>new</code> 分配的内存块的起始地址。</li>
<li> <code>delete</code> 释放该指针指向的内存块。</li>
<li> 指针变量本身的值<strong>不会</strong>被自动修改（它仍然存储着那个现在无效的地址），成为**悬挂指针 (Dangling Pointer)**。</li>
</ol>
<p><strong>重要规则:</strong></p>
<ul>
<li>  <strong><code>new</code> 和 <code>delete</code> 必须配对使用:</strong> 每个 <code>new</code> 都应该对应一个 <code>delete</code>。</li>
<li>  <strong>不要 <code>delete</code> 同一块内存两次:</strong> 对同一块内存执行两次 <code>delete</code> 是未定义行为。</li>
<li>  <strong>不要 <code>delete</code> 不是由 <code>new</code> 分配的内存:</strong> 例如，不要 <code>delete</code> 指向自动变量（栈变量）或静态变量的指针。</li>
<li>  <strong>不要 <code>delete</code> 空指针 (<code>nullptr</code>):</strong> 对空指针执行 <code>delete</code> 是安全且无效果的。</li>
<li>  <strong><code>delete</code> 之后将指针设为 <code>nullptr</code>:</strong> 释放内存后，最好立即将指针设置为 <code>nullptr</code>，以防止它成为悬挂指针被意外使用。</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 分配内存</span></span><br><span class="line">    <span class="keyword">int</span> * p_value = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">double</span> * p_temp = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">    *p_temp = <span class="number">123.45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before delete:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value points to: &quot;</span> &lt;&lt; *p_value &lt;&lt; <span class="string">&quot; at address &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_temp points to: &quot;</span> &lt;&lt; *p_temp &lt;&lt; <span class="string">&quot; at address &quot;</span> &lt;&lt; p_temp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p_value; </span><br><span class="line">    <span class="keyword">delete</span> p_temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAfter delete:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p_value 和 p_temp 现在是悬挂指针!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value still holds address: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; Accessing *p_value: &quot; &lt;&lt; *p_value &lt;&lt; std::endl; // 危险! 未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将指针设为 nullptr (好习惯)</span></span><br><span class="line">    p_value = <span class="literal">nullptr</span>;</span><br><span class="line">    p_temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After setting to nullptr:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value holds: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 或类似表示空指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nullptr 调用 delete 是安全的</span></span><br><span class="line">    <span class="keyword">delete</span> p_value; <span class="comment">// 无效果</span></span><br><span class="line">    <span class="keyword">delete</span> p_temp; <span class="comment">// 无效果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例:</span></span><br><span class="line">    <span class="keyword">int</span> stack_var = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_stack = &amp;stack_var;</span><br><span class="line">    <span class="comment">// delete p_stack; // 严重错误! 不能 delete 栈内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> * p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">int</span> * p2 = p1; <span class="comment">// p1 和 p2 指向同一块内存</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="comment">// delete p2; // 严重错误! 删除了同一块内存两次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忘记 <code>delete</code> 会导致内存泄漏，而错误地使用 <code>delete</code> 则可能导致程序崩溃或数据损坏。正确管理动态内存是 C++ 编程中的一项重要技能。</p>
<h3 id="4-7-6-使用new来创建动态数组"><a href="#4-7-6-使用new来创建动态数组" class="headerlink" title="4.7.6 使用new来创建动态数组"></a>4.7.6 使用new来创建动态数组</h3><p>除了分配单个变量的内存，<code>new</code> 也可以用来动态分配<strong>数组</strong>。这在你需要在运行时确定数组大小时非常有用。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointerVariable = <span class="keyword">new</span> typeName [numberOfElements];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName [numberOfElements];</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>new</code>: 运算符。</li>
<li>  <code>typeName</code>: 数组元素的数据类型。</li>
<li>  <code>numberOfElements</code>: 数组的大小，可以是一个变量或表达式，在运行时计算其值。</li>
<li>  <code>[]</code>: 表明要分配的是一个数组。</li>
</ul>
<p><code>new[]</code> 会分配一块连续的内存，足以容纳 <code>numberOfElements</code> 个 <code>typeName</code> 类型的元素，并返回指向<strong>数组第一个元素</strong>的指针。</p>
<p><strong>释放动态数组 (<code>delete[]</code>):</strong></p>
<p>释放由 <code>new[]</code> 分配的数组内存<strong>必须</strong>使用 <code>delete[]</code> 运算符，而不是 <code>delete</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pointerVariable;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>delete[]</code>: 用于释放数组内存的运算符。</li>
<li>  <code>pointerVariable</code>: 指向由 <code>new[]</code> 分配的数组内存的指针。</li>
</ul>
<p><strong><code>delete[]</code> 和 <code>delete</code> 的区别至关重要:</strong></p>
<ul>
<li>  <code>delete[]</code> 知道需要释放的是一个数组，它会正确地调用数组中每个对象（如果是类类型）的析构函数（如果需要），并释放整个数组占用的内存。</li>
<li>  如果对 <code>new[]</code> 分配的内存使用 <code>delete</code>（没有 <code>[]</code>），行为是<strong>未定义的</strong>。对于基本类型可能看似正常工作（但仍是错误的），但对于包含对象的数组，很可能只调用第一个对象的析构函数，并可能导致内存损坏或泄漏。</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the size of the dynamic array: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid size.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用 new[] 分配动态数组</span></span><br><span class="line">    <span class="keyword">int</span> * dynArray = <span class="keyword">new</span> <span class="keyword">int</span>[size]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查分配是否成功 (可选，对于普通 new[] 失败会抛异常)</span></span><br><span class="line">    <span class="keyword">if</span> (dynArray == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 像普通数组一样使用指针访问动态数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        dynArray[i] = i * <span class="number">10</span>; <span class="comment">// 使用数组下标访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic array elements:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; dynArray[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *(dynArray + i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 也可以使用指针算术访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用 delete[] 释放动态数组内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] dynArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将指针设为 nullptr (好习惯)</span></span><br><span class="line">    dynArray = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic array deleted.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例:</span></span><br><span class="line">    <span class="keyword">double</span> * p_arr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// delete p_arr; // 错误! 应该使用 delete [] p_arr;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong></p>
<ul>
<li>  使用 <code>new typeName[size]</code> 分配动态数组。</li>
<li>  使用 <code>delete [] pointerVariable</code> 释放动态数组。</li>
<li>  <strong>必须</strong>匹配 <code>new[]</code> 和 <code>delete[]</code>，否则行为未定义。</li>
<li>  动态数组提供了在运行时确定数组大小的灵活性，但需要程序员负责内存管理。</li>
</ul>
<h2 id="4-8-指针、数组和指针算术"><a href="#4-8-指针、数组和指针算术" class="headerlink" title="4.8 指针、数组和指针算术"></a>4.8 指针、数组和指针算术</h2><p>指针和数组在 C++ 中有着非常紧密的联系。理解这种关系以及指针算术对于有效地使用 C++ 处理内存和数据集合至关重要。</p>
<h3 id="4-8-1-程序说明"><a href="#4-8-1-程序说明" class="headerlink" title="4.8.1 程序说明"></a>4.8.1 程序说明</h3><p>指针算术允许我们对指针执行一些特殊的算术运算，主要是加法和减法，以便在内存中移动，特别是在数组中。</p>
<p><strong>指针与数组名的关系:</strong></p>
<p>在 C++ 中，数组名在很多情况下会被隐式地当作指向其<strong>第一个元素</strong>的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> wages[<span class="number">3</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2000.0</span>, <span class="number">3000.0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> *p_wages = wages; <span class="comment">// 数组名 wages 被当作指向第一个元素的指针 (&amp;wages[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of first element (&amp;wages[0]): &quot;</span> &lt;&lt; &amp;wages[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of array name (wages):        &quot;</span> &lt;&lt; wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出与 &amp;wages[0] 相同</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of pointer (p_wages):         &quot;</span> &lt;&lt; p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出与 &amp;wages[0] 相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问数组元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First element via pointer (*p_wages): &quot;</span> &lt;&lt; *p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针算术: 将指针移动到下一个元素</span></span><br><span class="line">    p_wages = p_wages + <span class="number">1</span>; <span class="comment">// 指针加 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address after p_wages + 1:          &quot;</span> &lt;&lt; p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 wages[1] 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *(p_wages + 1) (now *p_wages): &quot;</span> &lt;&lt; *p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组下标访问 (即使是通过指针)</span></span><br><span class="line">    p_wages = wages; <span class="comment">// 重置指针指向第一个元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing via pointer subscript p_wages[1]: &quot;</span> &lt;&lt; p_wages[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing via array name subscript wages[1]: &quot;</span> &lt;&lt; wages[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组名和指针的区别:</span></span><br><span class="line">    <span class="comment">// 1. sizeof: sizeof(wages) 是整个数组的大小 (3 * sizeof(double))</span></span><br><span class="line">    <span class="comment">//            sizeof(p_wages) 是指针本身的大小 (通常 4 或 8 字节)</span></span><br><span class="line">    <span class="comment">// 2. 地址: &amp;wages 是整个数组的地址 (类型是 double(*)[3])</span></span><br><span class="line">    <span class="comment">//         &amp;p_wages 是指针变量 p_wages 自身的地址</span></span><br><span class="line">    <span class="comment">// 3. 修改: 数组名 wages 是常量，不能修改 (不能 wages = wages + 1;)</span></span><br><span class="line">    <span class="comment">//         指针 p_wages 是变量，可以修改指向其他地址 (p_wages = p_wages + 1;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(wages): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(wages) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(p_wages): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(p_wages) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针算术规则:</strong></p>
<ul>
<li>  <strong>指针加整数 <code>p + n</code>:</strong> 结果是一个指向 <code>p</code> 原来指向位置之后第 <code>n</code> 个<strong>元素</strong>的地址。编译器会根据指针指向的类型大小自动计算实际地址偏移量（<code>地址 = p的地址 + n * sizeof(指向的类型)</code>）。</li>
<li>  <strong>指针减整数 <code>p - n</code>:</strong> 结果是一个指向 <code>p</code> 原来指向位置之前第 <code>n</code> 个元素的地址。</li>
<li>  <strong>指针减指针 <code>p1 - p2</code>:</strong> 结果是两个指针之间相隔的<strong>元素数量</strong>（一个整数）。只有当两个指针指向<strong>同一个数组</strong>（或超出末尾一个位置）中的元素时，这个操作才有意义。结果的类型是 <code>std::ptrdiff_t</code> (在 <code>&lt;cstddef&gt;</code> 中定义)。</li>
<li>  <strong>递增/递减:</strong> <code>++p</code>, <code>p++</code>, <code>--p</code>, <code>p--</code> 分别使指针指向下一个或上一个元素。</li>
<li>  <strong>比较:</strong> 可以使用关系运算符 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) 比较指向<strong>同一个数组</strong>元素的指针，判断它们的相对位置。也可以使用 <code>==</code> 和 <code>!=</code> 比较指针是否指向同一个地址（或是否都为空）。</li>
</ul>
<p><strong>数组下标和指针的关系:</strong></p>
<p>表达式 <code>arrayName[i]</code> 在 C++ 中等价于 <code>*(arrayName + i)</code>。<br>同样，如果 <code>p</code> 是一个指向数组元素的指针，<code>p[i]</code> 等价于 <code>*(p + i)</code>。</p>
<p>这意味着你可以对数组名使用指针算术（概念上），也可以对指针使用数组下标表示法。</p>
<h3 id="4-8-2-指针小结"><a href="#4-8-2-指针小结" class="headerlink" title="4.8.2 指针小结"></a>4.8.2 指针小结</h3><p>让我们回顾一下关于指针的关键概念：</p>
<ol>
<li> <strong>声明:</strong> 使用 <code>typeName * pointerName;</code> 声明一个指向 <code>typeName</code> 类型数据的指针。</li>
<li><strong>初始化:</strong><ul>
<li>  使用 <code>&amp;</code> 获取变量地址: <code>pointerName = &amp;variableName;</code></li>
<li>  初始化为空指针: <code>pointerName = nullptr;</code> (C++11) 或 <code>pointerName = 0;</code></li>
<li>  使用 <code>new</code> 分配动态内存: <code>pointerName = new typeName;</code> 或 <code>pointerName = new typeName[size];</code></li>
</ul>
</li>
<li> <strong>解引用:</strong> 使用 <code>*</code> 访问指针指向的值: <code>value = *pointerName;</code> 或 <code>*pointerName = newValue;</code>。</li>
<li> <strong>指针与数组:</strong> 数组名通常可视为指向第一个元素的常量指针。指针算术允许在数组元素间移动。<code>array[i]</code> 等价于 <code>*(array + i)</code>。</li>
<li> <strong>动态内存:</strong> 使用 <code>new</code> 分配，必须使用 <code>delete</code> (对应 <code>new</code>) 或 <code>delete[]</code> (对应 <code>new[]</code>) 释放。</li>
<li> <strong>危险:</strong> 未初始化指针、空指针解引用、悬挂指针、内存泄漏、错误的 <code>delete</code>/<code>delete[]</code> 使用。</li>
<li> <strong>指针本身 vs 指向的值:</strong> <code>pointerName</code> 存储的是地址，<code>*pointerName</code> 是该地址处的值。</li>
</ol>
<h3 id="4-8-3-指针和字符串"><a href="#4-8-3-指针和字符串" class="headerlink" title="4.8.3 指针和字符串"></a>4.8.3 指针和字符串</h3><p>C 风格字符串本质上是 <code>char</code> 类型的数组，以空字符 <code>\0</code> 结尾。因此，指针在处理 C 风格字符串时非常常用。</p>
<ul>
<li>  <strong>字符串字面值:</strong> 字符串字面值（如 <code>&quot;Hello&quot;</code>) 在内存中存储为 <code>const char</code> 数组，并以 <code>\0</code> 结尾。字符串字面值本身可以被当作指向其第一个字符的 <code>const char*</code> 指针。</li>
<li>  <strong><code>char</code> 指针:</strong> 可以声明 <code>char*</code> 或 <code>const char*</code> 指针来指向 C 风格字符串。</li>
</ul>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strlen()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> animal[<span class="number">20</span>] = <span class="string">&quot;bear&quot;</span>; <span class="comment">// animal 是 char 数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bird = <span class="string">&quot;wren&quot;</span>; <span class="comment">// bird 是指向 &quot;wren&quot; 字符串字面值第一个字符 &#x27;w&#x27; 的指针</span></span><br><span class="line">    <span class="keyword">char</span> *p_animal; <span class="comment">// 未初始化的 char 指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; bird &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// cout 知道如何处理 char* (打印直到 \0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针指向数组</span></span><br><span class="line">    p_animal = animal; <span class="comment">// p_animal 指向 animal 数组的第一个字符 &#x27;b&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer p_animal points to: &quot;</span> &lt;&lt; p_animal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;bear&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符串内容</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char via array: &quot;</span> &lt;&lt; animal[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// b</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char via pointer: &quot;</span> &lt;&lt; *p_animal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针算术遍历字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using pointer arithmetic:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_bird = bird;</span><br><span class="line">    <span class="keyword">while</span> (*p_bird != <span class="string">&#x27;\0&#x27;</span>) &#123; <span class="comment">// 循环直到遇到空字符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p_bird &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p_bird++; <span class="comment">// 指针移动到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串字面值和指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_literal = <span class="string">&quot;This is a literal&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p_literal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// p_literal[0] = &#x27;t&#x27;; // 错误! 字符串字面值通常是只读的 (const char*)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配字符串</span></span><br><span class="line">    <span class="keyword">char</span> *p_dynamic_str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(<span class="string">&quot;Dynamic String&quot;</span>) + <span class="number">1</span>]; <span class="comment">// +1 为了空字符</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p_dynamic_str, <span class="string">&quot;Dynamic String&quot;</span>); <span class="comment">// 使用 strcpy 复制 (不安全，最好用 strncpy 或 C++ string)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic string: &quot;</span> &lt;&lt; p_dynamic_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] p_dynamic_str; <span class="comment">// 释放动态分配的数组</span></span><br><span class="line">    p_dynamic_str = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>  <code>cout</code> 对 <code>char*</code> 有特殊处理，它会打印从指针指向地址开始直到遇到空字符 <code>\0</code> 的所有字符。</li>
<li>  修改字符串字面值是未定义行为，应使用 <code>const char*</code> 指向它们。</li>
<li>  处理 C 风格字符串时要特别注意缓冲区溢出问题（例如使用 <code>strcpy</code> 时目标数组不够大），并确保字符串以 <code>\0</code> 结尾。<code>std::string</code> 类通常是更安全、更方便的选择。</li>
</ul>
<h3 id="4-8-4-使用new创建动态结构"><a href="#4-8-4-使用new创建动态结构" class="headerlink" title="4.8.4 使用new创建动态结构"></a>4.8.4 使用new创建动态结构</h3><p>就像可以动态分配基本类型和数组一样，也可以使用 <code>new</code> 动态创建结构体（或类）对象。</p>
<p><strong>分配:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StructureName * pointerVariable = <span class="keyword">new</span> StructureName;</span><br></pre></td></tr></table></figure>

<p>这会在自由存储区分配足够存储 <code>StructureName</code> 结构所有成员的内存，并调用该结构的<strong>构造函数</strong>（如果是类或有构造函数的结构），然后返回指向新创建结构的指针。</p>
<p><strong>访问成员:</strong></p>
<p>当通过指针访问结构或类的成员时，不能直接使用点运算符 <code>.</code>。有两种方式：</p>
<ol>
<li> <strong>解引用再用点 (<code>(*ptr).member</code>)</strong>: 先解引用指针 <code>*ptr</code> 得到结构本身，然后使用点运算符访问成员。括号是必需的，因为点运算符的优先级高于解引用运算符。</li>
<li> <strong>箭头运算符 (<code>ptr-&gt;member</code>)</strong>: 这是更常用、更简洁的方式。箭头运算符 <code>-&gt;</code> 专门用于通过指针访问其指向的结构或类的成员。<code>ptr-&gt;member</code> 完全等价于 <code>(*ptr).member</code>。</li>
</ol>
<p><strong>释放:</strong></p>
<p>使用 <code>delete</code> 释放由 <code>new</code> 创建的单个结构对象。<code>delete</code> 会先调用该对象的<strong>析构函数</strong>（如果需要），然后释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointerVariable;</span><br><span class="line">pointerVariable = <span class="literal">nullptr</span>; <span class="comment">// 好习惯</span></span><br></pre></td></tr></table></figure>

<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inflatable</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态创建 Inflatable 结构</span></span><br><span class="line">    Inflatable *ps = <span class="keyword">new</span> Inflatable; <span class="comment">// 在自由存储区创建结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问成员</span></span><br><span class="line">    <span class="comment">// 方法 1: 解引用和点运算符</span></span><br><span class="line">    (*ps).name = <span class="string">&quot;Dynamic Floatie&quot;</span>;</span><br><span class="line">    (*ps).volume = <span class="number">1.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 2: 箭头运算符 (更常用)</span></span><br><span class="line">    ps-&gt;price = <span class="number">29.99</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically created structure:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Name: &quot;</span> &lt;&lt; ps-&gt;name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Volume: &quot;</span> &lt;&lt; (*ps).volume &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 两种方式都可以用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Price: &quot;</span> &lt;&lt; ps-&gt;price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Address: &quot;</span> &lt;&lt; ps &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态创建的结构</span></span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Structure deleted.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-5-自动存储、静态存储和动态存储"><a href="#4-8-5-自动存储、静态存储和动态存储" class="headerlink" title="4.8.5 自动存储、静态存储和动态存储"></a>4.8.5 自动存储、静态存储和动态存储</h3><p>C++ 程序中的变量和数据根据其内存分配方式和生命周期，可以分为三种主要的存储类别：</p>
<ol>
<li><p><strong>自动存储持续性 (Automatic Storage Duration):</strong></p>
<ul>
<li>  <strong>内存区域:</strong> 通常在称为<strong>栈 (Stack)</strong> 的内存区域分配。</li>
<li>  <strong>分配/释放:</strong> 内存的分配和释放在函数（或代码块）进入和退出时自动进行。</li>
<li>  <strong>生命周期:</strong> 变量在声明它的函数或代码块执行期间存在，块结束时自动销毁。</li>
<li>  <strong>例子:</strong> 函数内部声明的非 <code>static</code> 局部变量（包括函数参数）。</li>
<li>  <strong>特点:</strong> 分配和释放速度快，管理简单（自动），但空间有限，生命周期受限于作用域。</li>
</ul>
</li>
<li><p><strong>静态存储持续性 (Static Storage Duration):</strong></p>
<ul>
<li>  <strong>内存区域:</strong> 在程序的整个生命周期内都存在于内存的某个固定区域（通常是静态/全局数据区）。</li>
<li>  <strong>分配/释放:</strong> 内存在程序启动时分配（或首次使用时，对于某些静态变量），在程序结束时释放。</li>
<li>  <strong>生命周期:</strong> 从程序开始执行到程序结束。</li>
<li>  <strong>例子:</strong> 在函数外部声明的变量（全局变量）、使用 <code>static</code> 关键字在函数内部或类内部声明的变量。</li>
<li>  <strong>特点:</strong> 生命周期长，可以跨函数调用保持其值，但全局变量可能导致命名冲突和管理复杂性。</li>
</ul>
</li>
<li><p><strong>动态存储持续性 (Dynamic Storage Duration):</strong></p>
<ul>
<li>  <strong>内存区域:</strong> 在称为<strong>自由存储区 (Free Store)</strong> 或 <strong>堆 (Heap)</strong> 的内存区域分配。</li>
<li>  <strong>分配/释放:</strong> 内存由程序员使用 <code>new</code> (或 <code>malloc</code> 等 C 函数) 显式分配，并且<strong>必须</strong>使用 <code>delete</code> (或 <code>free</code>) 显式释放。</li>
<li>  <strong>生命周期:</strong> 从 <code>new</code> 分配成功开始，直到程序员使用 <code>delete</code> 释放为止。生命周期与函数或代码块的作用域无关。</li>
<li>  <strong>例子:</strong> 使用 <code>new</code> 创建的变量、数组或对象。</li>
<li>  <strong>特点:</strong> 提供了最大的灵活性，可以在运行时根据需要分配任意大小的内存，生命周期由程序员控制。但管理复杂，容易出现内存泄漏（忘记 <code>delete</code>）或悬挂指针（<code>delete</code> 后仍使用指针）等问题。</li>
</ul>
</li>
</ol>
<p><strong>示例对比:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_static_var = <span class="number">10</span>; <span class="comment">// 静态存储 (全局)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> file_static_var = <span class="number">20</span>; <span class="comment">// 静态存储 (文件作用域)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> auto_var = <span class="number">30</span>; <span class="comment">// 自动存储 (栈)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> func_static_var = <span class="number">40</span>; <span class="comment">// 静态存储 (函数作用域，只初始化一次)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *dynamic_var = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">50</span>); <span class="comment">// 动态存储 (堆)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Inside func:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  auto_var address: &quot;</span> &lt;&lt; &amp;auto_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; auto_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  func_static_var address: &quot;</span> &lt;&lt; &amp;func_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; ++func_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  dynamic_var address: &quot;</span> &lt;&lt; dynamic_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; *dynamic_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> dynamic_var; <span class="comment">// 必须手动释放动态内存</span></span><br><span class="line">    dynamic_var = <span class="literal">nullptr</span>;</span><br><span class="line">&#125; <span class="comment">// auto_var 在这里销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Global static var address: &quot;</span> &lt;&lt; &amp;global_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; global_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File static var address: &quot;</span> &lt;&lt; &amp;file_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; file_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling func first time:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    func();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling func second time:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    func(); <span class="comment">// 注意 func_static_var 的值会保持</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int* dangling_ptr;</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     int temp_auto = 100; // 自动存储</span></span><br><span class="line">    <span class="comment">//     dangling_ptr = &amp;temp_auto;</span></span><br><span class="line">    <span class="comment">// &#125; // temp_auto 销毁</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *dangling_ptr; // 错误! 悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解这三种存储方式对于编写健壮、高效且无内存错误的 C++ 程序至关重要。现代 C++ 倾向于使用 RAII (Resource Acquisition Is Initialization) 技术和智能指针（如 <code>std::unique_ptr</code>, <code>std::shared_ptr</code>）来自动管理动态内存，以减少手动 <code>new</code>/<code>delete</code> 带来的风险。</p>
<h2 id="4-9-类型组合"><a href="#4-9-类型组合" class="headerlink" title="4.9 类型组合"></a>4.9 类型组合</h2><p>C++ 的强大之处在于其类型系统允许你将基本类型、复合类型（数组、结构、共用体、枚举）和指针以多种方式组合起来，创建更复杂的数据结构来精确地模拟现实世界的问题。</p>
<p>本章我们已经接触了一些组合：</p>
<ul>
<li>  <strong>结构数组 (Array of Structures):</strong> 数组的每个元素都是一个结构体 (见 4.4.5)。</li>
<li>  <strong>结构包含 <code>std::string</code> 成员:</strong> 结构体可以包含类类型的成员 (见 4.4.3)。</li>
<li>  <strong>指针指向结构:</strong> 可以声明指向结构体对象的指针 (见 4.8.4)。</li>
<li>  <strong>指针指向数组 (或数组名视为指针):</strong> 指针可以用来操作数组 (见 4.8.1)。</li>
</ul>
<p>本节将进一步探讨一些常见的类型组合方式。</p>
<p><strong>1. 结构包含数组成员:</strong></p>
<p>结构体可以包含数组作为其成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentGrades</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> studentName;</span><br><span class="line">    <span class="keyword">int</span> grades[<span class="number">5</span>]; <span class="comment">// 包含一个 int 数组作为成员</span></span><br><span class="line">    <span class="keyword">int</span> numGrades; <span class="comment">// 记录实际存储的成绩数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentGrades alice;</span><br><span class="line">    alice.studentName = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    alice.grades[<span class="number">0</span>] = <span class="number">95</span>;</span><br><span class="line">    alice.grades[<span class="number">1</span>] = <span class="number">88</span>;</span><br><span class="line">    alice.grades[<span class="number">2</span>] = <span class="number">92</span>;</span><br><span class="line">    alice.numGrades = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; alice.studentName &lt;&lt; <span class="string">&quot;&#x27;s first grade: &quot;</span> &lt;&lt; alice.grades[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alice.numGrades; ++i) &#123;</span><br><span class="line">        sum += alice.grades[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (alice.numGrades &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average grade: &quot;</span> &lt;&lt; sum / alice.numGrades &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 结构包含指针成员:</strong></p>
<p>结构体可以包含指针作为成员。这常用于指向动态分配的内存或指向其他数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DynamicData</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> label;</span><br><span class="line">    <span class="keyword">int</span>* data_ptr; <span class="comment">// 指向动态分配的 int 数组</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DynamicData myData;</span><br><span class="line">    myData.label = <span class="string">&quot;Sensor Readings&quot;</span>;</span><br><span class="line">    myData.size = <span class="number">10</span>;</span><br><span class="line">    myData.data_ptr = <span class="keyword">new</span> <span class="keyword">int</span>[myData.size]; <span class="comment">// 动态分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化动态数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myData.size; ++i) &#123;</span><br><span class="line">        myData.data_ptr[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Label: &quot;</span> &lt;&lt; myData.label &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data at index 3: &quot;</span> &lt;&lt; myData.data_ptr[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// **重要:** 必须手动释放指针成员指向的动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] myData.data_ptr; </span><br><span class="line">    myData.data_ptr = <span class="literal">nullptr</span>; <span class="comment">// 避免悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 当结构包含指针成员指向动态内存时，需要特别注意内存管理（复制、赋值、析构），这通常涉及到类的特殊成员函数（拷贝构造函数、拷贝赋值运算符、析构函数），我们将在后续章节深入学习。</p>
<p><strong>3. 指针数组 (Array of Pointers):</strong></p>
<p>可以创建数组，其每个元素都是一个指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span>* ptr_array[<span class="number">3</span>]; <span class="comment">// 声明一个包含 3 个 int* 指针的数组</span></span><br><span class="line"></span><br><span class="line">    ptr_array[<span class="number">0</span>] = &amp;a; <span class="comment">// 第一个元素指向 a</span></span><br><span class="line">    ptr_array[<span class="number">1</span>] = &amp;b; <span class="comment">// 第二个元素指向 b</span></span><br><span class="line">    ptr_array[<span class="number">2</span>] = &amp;c; <span class="comment">// 第三个元素指向 c</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Values via pointer array:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Value at *ptr_array[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; *ptr_array[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以指向动态分配的内存</span></span><br><span class="line">    <span class="keyword">int</span>* dyn_ptr_array[<span class="number">2</span>];</span><br><span class="line">    dyn_ptr_array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">    dyn_ptr_array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDynamic values:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *dyn_ptr_array[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *dyn_ptr_array[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> dyn_ptr_array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span> dyn_ptr_array[<span class="number">1</span>];</span><br><span class="line">    dyn_ptr_array[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    dyn_ptr_array[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针数组常用于存储 C 风格字符串数组（<code>const char*[]</code>）或管理一组动态分配的对象。</p>
<p><strong>4. 指向指针的指针 (Pointer to Pointer):</strong></p>
<p>指针本身也是变量，它也有自己的内存地址。因此，可以声明一个指向指针的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> *ptr = &amp;value;      <span class="comment">// ptr 指向 value (int*)</span></span><br><span class="line">    <span class="keyword">int</span> **pptr = &amp;ptr;      <span class="comment">// pptr 指向 ptr (int**)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;             <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of value (&amp;value): &quot;</span> &lt;&lt; &amp;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of ptr (address of value): &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// value 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via ptr (*ptr): &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;           <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of ptr (&amp;ptr): &quot;</span> &lt;&lt; &amp;ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of pptr (address of ptr): &quot;</span> &lt;&lt; pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// ptr 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via pptr (*pptr): &quot;</span> &lt;&lt; *pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// ptr 的值 (即 value 的地址)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via pptr (**pptr): &quot;</span> &lt;&lt; **pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// value 的值 (42)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">    **pptr = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 50</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指向指针的指针常用于：</p>
<ul>
<li>  在函数中修改调用者传入的指针本身（使其指向不同的地址）。</li>
<li>  处理动态分配的指针数组（例如 <code>char** argv</code> in <code>main</code>）。</li>
</ul>
<p><strong>总结:</strong></p>
<p>通过组合基本类型、数组、结构、指针等，可以构建出非常灵活和强大的数据结构。理解每种组合方式的内存布局、访问方式以及（特别是涉及指针和动态内存时）生命周期管理规则是编写复杂 C++程序的关键。随着学习的深入，我们将看到更多高级的组合和抽象方式，例如使用类和标准库容器。</p>
<h2 id="4-10-数组的替代品"><a href="#4-10-数组的替代品" class="headerlink" title="4.10 数组的替代品"></a>4.10 数组的替代品</h2><p>虽然 C++ 内置的数组（包括动态分配的数组）功能强大，但它们存在一些固有的缺点：数组大小通常需要在编译时确定（对于栈上的数组），或者需要手动进行动态内存管理（对于堆上的数组），并且不提供边界检查等安全特性。</p>
<p>C++ 标准模板库 (STL) 提供了更安全、更灵活的数组替代品：<code>vector</code> 和 <code>array</code>。</p>
<h3 id="4-10-1-模板类vector"><a href="#4-10-1-模板类vector" class="headerlink" title="4.10.1 模板类vector"></a>4.10.1 模板类vector</h3><p><code>std::vector</code> 是 STL 提供的一个<strong>动态数组</strong>模板类。它封装了动态大小的数组，可以根据需要自动增长或缩小，并负责管理其元素的内存。</p>
<p><strong>特点:</strong></p>
<ul>
<li>  <strong>动态大小:</strong> 可以在运行时添加或删除元素，<code>vector</code> 会自动处理内存的重新分配。</li>
<li>  <strong>内存管理:</strong> 自动管理元素存储的内存（通常在自由存储区/堆上分配）。</li>
<li>  <strong>随机访问:</strong> 像普通数组一样，可以通过索引 <code>[]</code> 快速访问任何元素。</li>
<li>  <strong>边界检查 (可选):</strong> 提供 <code>at()</code> 成员函数进行带边界检查的元素访问。</li>
<li>  <strong>丰富的成员函数:</strong> 提供 <code>push_back()</code>, <code>pop_back()</code>, <code>size()</code>, <code>empty()</code>, <code>clear()</code>, <code>insert()</code>, <code>erase()</code> 等多种方便的操作。</li>
<li>  <strong>模板类:</strong> <code>vector</code> 是一个模板，需要指定存储的元素类型，例如 <code>std::vector&lt;int&gt;</code>, <code>std::vector&lt;double&gt;</code>, <code>std::vector&lt;std::string&gt;</code>。</li>
</ul>
<p><strong>使用方法:</strong></p>
<ol>
<li> <strong>包含头文件:</strong> <code>#include &lt;vector&gt;</code></li>
<li><strong>声明和初始化:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores; <span class="comment">// 创建一个空的 int vector</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">lengths</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建包含 10 个 double 元素的 vector (默认初始化为 0.0)</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">names</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;Unknown&quot;</span>)</span></span>; <span class="comment">// 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 列表初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;; <span class="comment">// 创建并初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>访问元素:</strong><ul>
<li>  <code>[]</code> 运算符: <code>scores[0]</code>, <code>names[i]</code> (不进行边界检查)。</li>
<li>  <code>at()</code> 函数: <code>scores.at(0)</code>, <code>names.at(i)</code> (进行边界检查，越界抛出 <code>std::out_of_range</code> 异常)。</li>
</ul>
</li>
<li><strong>常用操作:</strong><ul>
<li>  <code>push_back(value)</code>: 在 <code>vector</code> 末尾添加一个元素。</li>
<li>  <code>size()</code>: 返回 <code>vector</code> 中元素的数量。</li>
<li>  <code>empty()</code>: 检查 <code>vector</code> 是否为空。</li>
<li>  <code>clear()</code>: 移除所有元素。</li>
<li>  <code>pop_back()</code>: 移除末尾的元素。</li>
</ul>
</li>
</ol>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建和初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers; <span class="comment">// 空 vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tasks &#123;<span class="string">&quot;Read&quot;</span>, <span class="string">&quot;Write&quot;</span>, <span class="string">&quot;Code&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.push_back(<span class="number">10</span>); <span class="comment">// numbers: &#123;10&#125;</span></span><br><span class="line">    numbers.push_back(<span class="number">20</span>); <span class="comment">// numbers: &#123;10, 20&#125;</span></span><br><span class="line">    numbers.push_back(<span class="number">30</span>); <span class="comment">// numbers: &#123;10, 20, 30&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First number: &quot;</span> &lt;&lt; numbers[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second task: &quot;</span> &lt;&lt; tasks.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Write</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; tasks.at(3); // 会抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    numbers[<span class="number">0</span>] = <span class="number">15</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of tasks: &quot;</span> &lt;&lt; tasks.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 vector (C++11 基于范围的 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Numbers: 15 20 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 vector (传统 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tasks:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tasks.size(); ++i) &#123; <span class="comment">// 使用 size_t 作为索引类型</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tasks[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Tasks: Read Write Code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除末尾元素</span></span><br><span class="line">    numbers.pop_back(); <span class="comment">// numbers: &#123;15, 20&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Last number after pop: &quot;</span> &lt;&lt; numbers.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// back() 访问最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::vector</code> 是 C++ 中替代动态数组的首选方案，因为它更安全、更易于管理。</p>
<h3 id="4-10-2-模板类array（C-11）"><a href="#4-10-2-模板类array（C-11）" class="headerlink" title="4.10.2 模板类array（C++11）"></a>4.10.2 模板类array（C++11）</h3><p>C++11 引入了 <code>std::array</code> 模板类，它封装了<strong>固定大小</strong>的数组。与 C 风格数组类似，其大小在编译时确定，但它提供了更现代的接口和一些 <code>vector</code> 具有的便利性（如 <code>size()</code>, <code>at()</code>）。</p>
<p><strong>特点:</strong></p>
<ul>
<li>  <strong>固定大小:</strong> 数组大小必须在编译时指定为模板参数，之后不能改变。</li>
<li>  <strong>内存位置:</strong> 通常在栈上分配内存（如果作为局部变量声明），与 C 风格数组类似，除非显式使用 <code>new</code> 创建。</li>
<li>  <strong>类型安全:</strong> 大小是类型的一部分 (<code>std::array&lt;int, 5&gt;</code> 和 <code>std::array&lt;int, 10&gt;</code> 是不同的类型)。</li>
<li>  <strong>STL 接口:</strong> 提供与 <code>vector</code> 类似的接口，如 <code>size()</code>, <code>empty()</code>, <code>at()</code>, <code>[]</code>, <code>front()</code>, <code>back()</code>，以及迭代器支持，可以方便地与 STL 算法一起使用。</li>
<li>  <strong>无开销抽象:</strong> 通常不会比 C 风格数组带来额外的运行时性能开销。</li>
<li>  <strong>模板类:</strong> 需要指定元素类型和大小，例如 <code>std::array&lt;int, 10&gt;</code>, <code>std::array&lt;double, 3&gt;</code>。</li>
</ul>
<p><strong>使用方法:</strong></p>
<ol>
<li> <strong>包含头文件:</strong> <code>#include &lt;array&gt;</code></li>
<li><strong>声明和初始化:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; scores; <span class="comment">// 创建包含 5 个 int 的 array (元素值未定义，除非是静态存储)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 3&gt; coords &#123;&#125;; <span class="comment">// 创建包含 3 个 double 的 array, 零初始化 &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 列表初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; values &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建并初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 2&gt; names &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 初始化列表的元素数量不能超过 array 的大小</span></span><br><span class="line"><span class="comment">// std::array&lt;int, 3&gt; errors &#123;1, 2, 3, 4&#125;; // 错误!</span></span><br><span class="line"><span class="comment">// 如果元素数量少于 array 大小，剩余元素会被值初始化 (通常为 0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; partial &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// &#123;10, 20, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>访问元素:</strong><ul>
<li>  <code>[]</code> 运算符: <code>scores[0]</code>, <code>names[i]</code> (不进行边界检查)。</li>
<li>  <code>at()</code> 函数: <code>scores.at(0)</code>, <code>names.at(i)</code> (进行边界检查，越界抛出 <code>std::out_of_range</code> 异常)。</li>
</ul>
</li>
<li><strong>常用操作:</strong><ul>
<li>  <code>size()</code>: 返回数组的大小（编译时常量）。</li>
<li>  <code>empty()</code>: 检查数组是否为空（对于大小 &gt; 0 的 <code>std::array</code> 总是返回 <code>false</code>）。</li>
<li>  <code>fill(value)</code>: 将所有元素设置为指定值。</li>
<li>  <code>front()</code>: 访问第一个元素。</li>
<li>  <code>back()</code>: 访问最后一个元素。</li>
</ul>
</li>
</ol>
<p><strong>用法与示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // 为了 std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建和初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; data &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 3&gt; colors &#123;<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; temps &#123;&#125;; <span class="comment">// &#123;0.0, 0.0, 0.0, 0.0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First data element: &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second color: &quot;</span> &lt;&lt; colors.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Green</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A temperature: &quot;</span> &lt;&lt; temps[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of data array: &quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充</span></span><br><span class="line">    temps.fill(<span class="number">25.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Filled temperature: &quot;</span> &lt;&lt; temps[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 25.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 (C++11 基于范围的 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Colors:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; color : colors) &#123; <span class="comment">// 使用 const 引用避免复制</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Colors: Red Green Blue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 STL 算法一起使用</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="built_in">std</span>::accumulate(temps.begin(), temps.end(), <span class="number">0.0</span>); <span class="comment">// 计算总和</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of temperatures: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::array</code> 是替代需要固定大小数组的 C 风格数组的现代 C++ 方案。</p>
<h3 id="4-10-3-比较数组、vector对象和array对象"><a href="#4-10-3-比较数组、vector对象和array对象" class="headerlink" title="4.10.3 比较数组、vector对象和array对象"></a>4.10.3 比较数组、vector对象和array对象</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">C 风格数组 (<code>T[]</code>)</th>
<th align="left"><code>std::vector&lt;T&gt;</code></th>
<th align="left"><code>std::array&lt;T, N&gt;</code> (C++11)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>大小</strong></td>
<td align="left">固定 (编译时确定栈数组，运行时确定堆数组)</td>
<td align="left">动态 (可运行时改变)</td>
<td align="left">固定 (编译时确定)</td>
</tr>
<tr>
<td align="left"><strong>内存分配</strong></td>
<td align="left">栈 (局部) 或 静态区 或 堆 (<code>new[]</code>)</td>
<td align="left">通常在堆上 (自由存储区)</td>
<td align="left">通常在栈上 (除非用 <code>new</code> 创建)</td>
</tr>
<tr>
<td align="left"><strong>大小信息</strong></td>
<td align="left">无内置方法获取大小 (需单独传递)</td>
<td align="left"><code>size()</code> 成员函数</td>
<td align="left"><code>size()</code> 成员函数 (编译时常量)</td>
</tr>
<tr>
<td align="left"><strong>边界检查</strong></td>
<td align="left">无 (不安全)</td>
<td align="left"><code>at()</code> 提供检查, <code>[]</code> 不提供</td>
<td align="left"><code>at()</code> 提供检查, <code>[]</code> 不提供</td>
</tr>
<tr>
<td align="left"><strong>赋值/复制</strong></td>
<td align="left">不能直接赋值/复制整个数组</td>
<td align="left">可以直接赋值/复制 (深拷贝)</td>
<td align="left">可以直接赋值/复制 (成员逐一复制)</td>
</tr>
<tr>
<td align="left"><strong>作为函数参数</strong></td>
<td align="left">通常退化为指针 (丢失大小信息)</td>
<td align="left">可以按值、引用或指针传递</td>
<td align="left">可以按值、引用或指针传递</td>
</tr>
<tr>
<td align="left"><strong>STL 兼容性</strong></td>
<td align="left">有限 (需要指针和大小)</td>
<td align="left">完全兼容 (提供迭代器等)</td>
<td align="left">完全兼容 (提供迭代器等)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">通常最快 (直接内存访问)</td>
<td align="left">访问速度快，添加/删除可能涉及内存重分配</td>
<td align="left">通常与 C 风格数组性能相同</td>
</tr>
<tr>
<td align="left"><strong>头文件</strong></td>
<td align="left">无需</td>
<td align="left"><code>&lt;vector&gt;</code></td>
<td align="left"><code>&lt;array&gt;</code></td>
</tr>
</tbody></table>
<p><strong>选择建议:</strong></p>
<ul>
<li>  <strong>需要动态大小:</strong> 如果数组大小在运行时才能确定，或者需要在程序运行期间改变大小，**<code>std::vector</code> 是最佳选择**。</li>
<li><strong>需要固定大小 (编译时已知):</strong> 如果数组大小在编译时就确定且不会改变：<ul>
<li>  **优先选择 <code>std::array</code> (C++11 及以后)**。它提供了与 C 风格数组相同的性能和内存布局（通常在栈上），但具有更安全、更方便的接口（如 <code>size()</code>, <code>at()</code>, 迭代器）。</li>
<li>  如果不能使用 C++11 或有特定 C 接口兼容性需求，可以使用 C 风格数组，但要特别注意安全性和大小管理。</li>
</ul>
</li>
<li>  <strong>性能关键且大小固定:</strong> <code>std::array</code> 和 C 风格数组通常性能最佳。</li>
</ul>
<p>总的来说，在现代 C++ 中，应优先使用 <code>std::vector</code> 和 <code>std::array</code> 而不是 C 风格数组，以获得更好的类型安全、内存管理和易用性。</p>
<h2 id="4-11-总结"><a href="#4-11-总结" class="headerlink" title="4.11 总结"></a>4.11 总结</h2><p>本章介绍了C++的**复合类型 (Compound Types)**，它们允许我们将多个值组合成一个数据单元。</p>
<p>我们首先学习了**数组 (Array)**，它用于存储一系列相同类型的数据。我们了解了如何声明数组、使用索引访问元素（从0开始），以及初始化数组的各种规则，包括C++11引入的更安全的列表初始化方法。我们强调了数组大小必须是常量表达式，并且访问数组时需要注意边界，避免越界访问。</p>
<p>接着，我们探讨了处理文本数据的两种方式。第一种是传统的<strong>C风格字符串</strong>，即以空字符 <code>\0</code> 结尾的 <code>char</code> 数组。我们学习了如何拼接字符串常量、在数组中使用字符串、以及使用 <code>cin</code> 和 <code>getline</code> 读取字符串输入，并特别注意了混合输入数字和整行字符串时可能遇到的问题。</p>
<p>第二种，也是C++中更推荐的方式，是使用标准库提供的 <strong><code>string</code> 类</strong>。<code>string</code> 类提供了自动内存管理、方便的赋值、拼接 (<code>+</code>) 和附加 (<code>+=</code>) 操作，以及大量用于查找、修改、比较和访问字符的成员函数。我们还学习了如何使用 <code>cin</code>, <code>cout</code>, 和 <code>getline</code> 对 <code>string</code> 对象进行输入输出，并了解了C++11引入的原始字符串字面值和Unicode字符串字面值。</p>
<p><strong>结构 (Structure)</strong> 被引入作为一种创建自定义复合类型的方式，允许将不同类型的数据项（成员）组合在一起。我们学习了如何定义结构、声明结构变量、使用点运算符 (<code>.</code>) 访问成员，以及C++11的列表初始化。我们还看到结构体可以包含 <code>string</code> 对象或数组作为成员，结构变量可以相互赋值，可以作为函数参数（按值、按引用、按指针）和返回值。<strong>结构数组</strong>允许我们管理一组结构对象，而<strong>位字段</strong>则提供了一种在结构内精确控制成员占用位数的方式。</p>
<p><strong>共用体 (Union)</strong> 作为另一种复合类型被介绍，其特点是所有成员共享同一块内存空间，主要用于节省内存或进行类型双关（需谨慎）。我们了解了如何定义和访问共用体，以及使用匿名共用体。</p>
<p><strong>枚举 (Enum)</strong> 提供了一种创建具名整数常量的方式，提高了代码的可读性和类型安全。我们学习了如何定义枚举、显式设置枚举量的值、枚举的取值范围，并简要介绍了C++11引入的更安全的**作用域内枚举 (<code>enum class</code>)**。</p>
<p>本章的一个核心内容是<strong>指针 (Pointer)</strong> 和**自由存储空间 (Free Store / Heap)**。指针是存储内存地址的变量。我们学习了如何声明和初始化指针（包括使用 <code>&amp;</code> 获取地址和初始化为 <code>nullptr</code>），如何使用解引用运算符 <code>*</code> 访问指针指向的值，并强调了使用未初始化指针、空指针或悬挂指针的危险。</p>
<p>我们学习了使用 <code>new</code> 运算符在自由存储区动态分配内存（用于单个变量或对象），以及使用 <code>delete</code> 运算符释放这些内存。同样，我们学习了使用 <code>new[]</code> 动态分配数组，并强调<strong>必须</strong>使用 <code>delete[]</code> 来释放动态数组内存。正确配对 <code>new</code>/<code>delete</code> 和 <code>new[]</code>/<code>delete[]</code> 对于避免内存泄漏和程序崩溃至关重要。</p>
<p>指针与数组的紧密关系以及<strong>指针算术</strong>也被详细讨论。数组名通常可视为指向第一个元素的指针，指针算术允许在数组元素间移动。我们还看到了如何使用指针处理C风格字符串，以及如何动态创建结构并使用箭头运算符 (<code>-&gt;</code>) 通过指针访问其成员。最后，我们区分了三种主要的存储持续性：自动存储（栈）、静态存储和动态存储（堆）。</p>
<p>我们还探讨了如何<strong>组合</strong>这些类型，例如创建包含数组或指针成员的结构、指针数组以及指向指针的指针，以构建更复杂的数据表示。</p>
<p>最后，我们介绍了C++标准库提供的内置数组的现代替代品：**<code>std::vector</code>**（动态大小数组）和 **<code>std::array</code>**（固定大小数组，C++11）。它们提供了更安全、更方便的接口和自动内存管理（对于 <code>vector</code>），是现代C++编程中推荐的选择。</p>
<p>通过本章的学习，我们掌握了创建和使用各种复合数据类型以及进行动态内存管理的基本技能。</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/>http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-26T20:01:30+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年4月26日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Program/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Program</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/C/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>C++</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/&title=Chapter 4 复合类型 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/&title=Chapter 4 复合类型 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/&title=Chapter 4 复合类型 - Uniqueland&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2025/04/26/Cpp_tutorial_Chapter_5/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Chapter 5 循环和关系表达式</p>
          <p class='content'>5.1 for循环循环是编程中的基本控制结构，它允许我们重复执行一段代码，直到满足某个条件为止。for 循环是 C++ 中最常用的循环结构之一，特别适用于已知循环次数或需要按特定步长迭代的情况。...</p>
        </a>
      
      
        <a class='next' href='/2025/03/31/windows_exception/'>
          <p class='title'>Windows异常处理机制深度解析<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>什么是Windows异常Windows异常是指在程序执行过程中遇到的非正常情况，这些情况会中断程序正常的执行流程。Windows操作系统提供了完善的异常处理机制来应对这些情况，使程序能够优雅地处...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%95%B0%E7%BB%84"><span class="toc-text">4.1 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%A8%8B%E5%BA%8F%E8%AF%B4%E6%98%8E"><span class="toc-text">4.1.1 程序说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-text">4.1.2 数组的初始化规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-C-11%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">4.1.3 C++11数组初始化方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.2 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-text">4.2.1 拼接字符串常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.2.2 在数组中使用字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="toc-text">4.2.3 字符串输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E6%AF%8F%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="toc-text">4.2.4 每次读取一行字符串输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E6%B7%B7%E5%90%88%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97"><span class="toc-text">4.2.5 混合输入字符串和数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-string%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-text">4.3 string类简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-C-11%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">4.3.1 C++11字符串初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E8%B5%8B%E5%80%BC%E3%80%81%E6%8B%BC%E6%8E%A5%E5%92%8C%E9%99%84%E5%8A%A0"><span class="toc-text">4.3.2 赋值、拼接和附加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-string%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-text">4.3.3 string类的其他操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-string%E7%B1%BBI-O"><span class="toc-text">4.3.4 string类I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-%E5%85%B6%E4%BB%96%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-text">4.3.5 其他形式的字符串字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="toc-text">4.4 结构简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84"><span class="toc-text">4.4.1 在程序中使用结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-C-11%E7%BB%93%E6%9E%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">4.4.2 C++11结构初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%B0%86string%E7%B1%BB%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%90%97"><span class="toc-text">4.4.3 结构可以将string类作为成员吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-4-%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E5%B1%9E%E6%80%A7"><span class="toc-text">4.4.4 其他结构属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-5-%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-text">4.4.5 结构数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-6-%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-text">4.4.6 结构中的位字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-text">4.5 共用体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%9E%9A%E4%B8%BE"><span class="toc-text">4.6 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E8%AE%BE%E7%BD%AE%E6%9E%9A%E4%B8%BE%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-text">4.6.1 设置枚举量的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-text">4.6.2 枚举的取值范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E6%8C%87%E9%92%88%E5%92%8C%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">4.7 指针和自由存储空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E9%92%88"><span class="toc-text">4.7.1 声明和初始化指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E6%8C%87%E9%92%88%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="toc-text">4.7.2 指针的危险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E5%AD%97"><span class="toc-text">4.7.3 指针和数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E4%BD%BF%E7%94%A8new%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">4.7.4 使用new来分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-5-%E4%BD%BF%E7%94%A8delete%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-text">4.7.5 使用delete释放内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-6-%E4%BD%BF%E7%94%A8new%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">4.7.6 使用new来创建动态数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF"><span class="toc-text">4.8 指针、数组和指针算术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-%E7%A8%8B%E5%BA%8F%E8%AF%B4%E6%98%8E"><span class="toc-text">4.8.1 程序说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-2-%E6%8C%87%E9%92%88%E5%B0%8F%E7%BB%93"><span class="toc-text">4.8.2 指针小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-3-%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.8.3 指针和字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-4-%E4%BD%BF%E7%94%A8new%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E7%BB%93%E6%9E%84"><span class="toc-text">4.8.4 使用new创建动态结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-5-%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E3%80%81%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%92%8C%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8"><span class="toc-text">4.8.5 自动存储、静态存储和动态存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E7%B1%BB%E5%9E%8B%E7%BB%84%E5%90%88"><span class="toc-text">4.9 类型组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81"><span class="toc-text">4.10 数组的替代品</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-1-%E6%A8%A1%E6%9D%BF%E7%B1%BBvector"><span class="toc-text">4.10.1 模板类vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-2-%E6%A8%A1%E6%9D%BF%E7%B1%BBarray%EF%BC%88C-11%EF%BC%89"><span class="toc-text">4.10.2 模板类array（C++11）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-3-%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84%E3%80%81vector%E5%AF%B9%E8%B1%A1%E5%92%8Carray%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.10.3 比较数组、vector对象和array对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-%E6%80%BB%E7%BB%93"><span class="toc-text">4.11 总结</span></a></li></ol>
    </div>
  </section>


  


</aside>



        
        
          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="Chapter 4 复合类型";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        
      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5043500508'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a id="s-top" class="fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <script>
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/********************脚本懒加载函数********************************/
function loadScript(src, cb) {
var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
var script = document.createElement('script');
script.setAttribute('type','text/javascript');
if (cb) script.onload = cb;
script.setAttribute('src', src);
HEAD.appendChild(script);
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  








  <script>
  let APlayerController = new Object();
  APlayerController.id = '5043500508';  // 设定全局音乐播放ID
  APlayerController.volume = '0.7';
  loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css", window.volantis.loadcss);

  loadScript("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js")

  loadScript("https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js")


</script>




  
  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/valine.min.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";

    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      recordIP: 'false',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>





  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/app.min.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/search/hexo.min.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://uniqueland.top' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://uniqueland.top' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
       

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      
	 

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
      } catch (e) {
        console.log(e);
      }
	  
    });

    document.addEventListener('pjax:error', function (e) {
	  
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
